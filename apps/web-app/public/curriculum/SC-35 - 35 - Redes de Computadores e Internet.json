{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T21:37:56.232Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - SC-35",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 287
    },
    "areas": [
      {
        "id": "10",
        "name": "Ciência da Computação",
        "description": "Área dedicada ao estudo de fundamentos e tecnologias computacionais, incluindo redes e sistemas distribuídos.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "SC-35 - Redes de Computadores e Internet",
            "description": "Noções básicas de redes de computadores: hardware e software. Necessidade de protocolos: o modelo TCP/IP. O nível de aplicação: protocolos de suporte e de serviços. O nível de transporte: os protocolos TCP e UDP, e controle de congestionamento. O nível de rede: plano de dados; plano de controle com Redes Definidas por Software; algoritmos de roteamento; o protocolo IP. O nível de enlace: padrões IEEE. Bibliografia: TANENBAUM, A. S.; WETHERALL, D. Redes de computadores. 5. ed. São Paulo: Pearson, 2011. KUROSE, J. F.; ROSS, K.W. Computer networking. 7. ed. Harlow: Pearson, 2017. NADEAU, T. D.; GRAY, K. SDN-Software Defined Networks: an authoritative review of network programmability technologies. Beijing: O ́Reilly, 2014.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Noções Básicas de Redes de Computadores",
                "description": "Introduz hardware e software fundamentais em redes de computadores.",
                "totalSkills": 55,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Hardware e Software Fundamentais em Redes",
                    "description": "Componentes básicos de hardware e software utilizados em redes de computadores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Componentes de Hardware em Redes de Computadores",
                        "description": "Principais dispositivos físicos e componentes materiais utilizados para estabelecer, conectar e gerenciar redes de computadores, incluindo interfaces, cabos e equipamentos de interconexão.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Identificar os componentes básicos de hardware de rede",
                            "description": "Reconhecer e listar os principais componentes de hardware, como Placa de Interface de Rede (NIC), cabos (UTP, fibra ótica), repetidores, hubs, bridges, switches e roteadores, associando cada um ao seu papel fundamental na transmissão de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de hardware de rede e listar componentes principais",
                                  "subSteps": [
                                    "Pesquise a definição de hardware de rede e sua importância na transmissão de dados.",
                                    "Liste os componentes básicos: NIC, cabos UTP e fibra ótica, repetidores, hubs, bridges, switches e roteadores.",
                                    "Crie uma tabela simples com colunas para nome, tipo (conexão ou dispositivo) e função preliminar.",
                                    "Assista a um vídeo introdutório sobre redes (5-10 minutos).",
                                    "Anote perguntas sobre diferenças entre componentes."
                                  ],
                                  "verification": "Verifique se a lista está completa com 8 componentes e se há uma tabela organizada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com internet",
                                    "Bloco de notas ou planilha digital (Google Sheets)",
                                    "Vídeo introdutório sobre hardware de rede (ex: YouTube - 'Componentes de Rede Básicos')"
                                  ],
                                  "tips": [
                                    "Use diagramas visuais para memorizar; comece com imagens reais dos componentes."
                                  ],
                                  "learningObjective": "Compreender o papel geral do hardware de rede na transmissão de dados e identificar os componentes principais.",
                                  "commonMistakes": [
                                    "Confundir hardware com software; omitir cabos como componentes essenciais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar componentes de conexão física: NIC e cabos",
                                  "subSteps": [
                                    "Descreva a Placa de Interface de Rede (NIC): função de conectar o computador à rede via porta Ethernet ou wireless.",
                                    "Explique cabos UTP (par trançado): uso em LANs curtas, suscetível a interferências.",
                                    "Detalhe cabos de fibra ótica: transmissão de luz para longas distâncias, alta velocidade e imunidade a interferências.",
                                    "Compare velocidades e distâncias suportadas por cada cabo.",
                                    "Identifique portas e conectores (RJ-45 para UTP)."
                                  ],
                                  "verification": "Crie flashcards com imagens e descrições; teste-se recitando funções sem olhar.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Imagens de NIC e cabos (busque online)",
                                    "Flashcards app (ex: Anki)",
                                    "Diagrama de conectores impresso ou digital"
                                  ],
                                  "tips": [
                                    "Visualize instalando uma NIC em um PC; foque em como os dados são convertidos em sinais elétricos/ópticos."
                                  ],
                                  "learningObjective": "Reconhecer NIC e cabos, associando-os à conversão e transmissão inicial de dados.",
                                  "commonMistakes": [
                                    "Confundir UTP com fibra em termos de custo e aplicação; ignorar wireless em NICs modernas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar dispositivos de extensão e comutação: repetidores, hubs, bridges e switches",
                                  "subSteps": [
                                    "Descreva repetidores: amplificam sinal para estender alcance em camadas físicas.",
                                    "Explique hubs: dispositivo camada 1, broadcast para todas as portas, ineficiente.",
                                    "Detalhe bridges: conectam segmentos de rede, filtram tráfego por MAC (camada 2).",
                                    "Estude switches: como hubs inteligentes, enviam dados só para o destino via MAC address.",
                                    "Compare hub vs switch em termos de colisões e eficiência."
                                  ],
                                  "verification": "Monte um fluxograma mostrando fluxo de dados em cada dispositivo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (ex: Draw.io ou papel e caneta)",
                                    "Vídeos comparativos (ex: 'Hub vs Switch')",
                                    "Tabela de camadas OSI básica"
                                  ],
                                  "tips": [
                                    "Pense em broadcast como 'gritar para todos' vs switch como 'chamar pelo nome'; teste com simulações online."
                                  ],
                                  "learningObjective": "Diferenciar funções desses dispositivos na propagação e filtragem de dados em redes locais.",
                                  "commonMistakes": [
                                    "Confundir bridge com router; achar que hubs são obsoletos sem entender legado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar roteadores e integrar conhecimentos sobre transmissão de dados",
                                  "subSteps": [
                                    "Descreva roteadores: conectam redes diferentes (LAN a WAN), roteiam pacotes por IP (camada 3).",
                                    "Revise todos os componentes e associe ao modelo OSI: NIC/cabos (1), repetidor/hub (1), bridge/switch (2), router (3).",
                                    "Simule uma transmissão de dados: do PC via NIC, cabo, switch, router.",
                                    "Identifique como cada componente previne perdas ou erros na transmissão.",
                                    "Crie um mapa mental conectando todos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o caminho de um pacote de dados em uma rede simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Mapa mental tool (ex: MindMeister)",
                                    "Simulador de rede online (ex: Cisco Packet Tracer free version)",
                                    "Modelo OSI impresso"
                                  ],
                                  "tips": [
                                    "Use analogias: router como 'carteiro entre cidades'; foque em endereçamento (MAC vs IP)."
                                  ],
                                  "learningObjective": "Integrar todos os componentes, entendendo seu papel coletivo na transmissão confiável de dados.",
                                  "commonMistakes": [
                                    "Confundir roteamento (IP) com switching (MAC); subestimar impacto de cabos na qualidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenhe e rotule um diagrama de uma rede doméstica simples: PC com NIC conectado via cabo UTP a um switch, que se conecta a um roteador com saída para fibra ótica à internet. Explique o fluxo de dados de um vídeo streaming do PC ao roteador.",
                              "finalVerifications": [
                                "Liste corretamente os 8 componentes com pelo menos uma função cada.",
                                "Diferencie hub de switch e bridge de roteador.",
                                "Descreva o papel de cada um na transmissão de dados sem erros.",
                                "Identifique camadas OSI básicas associadas.",
                                "Crie um diagrama funcional de rede com todos os componentes.",
                                "Explique por que fibra é usada para longas distâncias."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e nomenclatura (90% correto).",
                                "Correção nas funções e associações à transmissão de dados.",
                                "Profundidade nas diferenças entre componentes similares (ex: hub vs switch).",
                                "Qualidade do diagrama ou mapa mental (claro e completo).",
                                "Capacidade de explicar fluxos de dados em cenários práticos.",
                                "Ausência de confusões com software ou camadas avançadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais elétricos/ópticos e atenuação em cabos.",
                                "Matemática: Modelagem de topologias de rede e cálculo de distâncias máximas.",
                                "Eletrônica: Entendimento de circuitos em NICs e conectores RJ-45.",
                                "Informática Geral: Integração com software de configuração de redes."
                              ],
                              "realWorldApplication": "Em uma empresa, configurar uma LAN com switches e roteadores para conectar computadores, impressoras e internet, garantindo transmissão eficiente de dados sem gargalos, como em escritórios ou data centers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Descrever as funções dos dispositivos de interconexão",
                            "description": "Explicar detalhadamente as funções de hubs (broadcast de frames), switches (comutação em camada 2 com tabelas MAC), bridges (filtragem de tráfego) e roteadores (roteamento em camada 3 com endereços IP), destacando diferenças em termos de camadas OSI.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Modelo OSI e Camadas Relevantes",
                                  "subSteps": [
                                    "Estude o modelo OSI, focando nas camadas Física (1), Enlace (2) e Rede (3).",
                                    "Identifique as funções principais de cada camada: transmissão de bits (1), frames e MAC (2), pacotes e IP (3).",
                                    "Desenhe um diagrama simples das camadas 1-3 e anote exemplos de protocolos.",
                                    "Compare colisão de domínio e broadcast em camadas inferiores."
                                  ],
                                  "verification": "Crie um diagrama das camadas OSI 1-3 com funções anotadas e explique verbalmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama OSI impresso ou online (ex: Khan Academy), papel e caneta.",
                                  "tips": "Use mnemônicos como 'Please Do Not Throw Sausage Pizza Away' para lembrar as camadas.",
                                  "learningObjective": "Compreender as camadas OSI 1-3 para contextualizar dispositivos de rede.",
                                  "commonMistakes": "Confundir camada 2 (MAC) com camada 3 (IP); sempre diferencie endereços."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Funções de Hubs e Bridges",
                                  "subSteps": [
                                    "Aprenda que hubs operam na camada 1: broadcast de frames para todas as portas.",
                                    "Entenda bridges na camada 2: filtram tráfego usando tabelas MAC para reduzir colisões.",
                                    "Simule um hub: imagine um frame chegando e sendo enviado a todos os dispositivos.",
                                    "Simule um bridge: frame vai só para o segmento necessário baseado em MAC aprendida.",
                                    "Note diferenças: hub aumenta colisões, bridge divide domínios de colisão."
                                  ],
                                  "verification": "Descreva em um parágrafo como um hub difere de um bridge em uma rede com 4 PCs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Vídeos tutoriais (ex: Cisco Networking Basics no YouTube), simulador como Packet Tracer.",
                                  "tips": "Pense no hub como uma 'fita adesiva' conectando tudo; bridge como um 'porteiro inteligente'.",
                                  "learningObjective": "Diferenciar operações de hubs (L1 broadcast) e bridges (L2 filtragem MAC).",
                                  "commonMistakes": "Achar que bridges roteiam IP; eles só filtram frames locais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Funções de Switches",
                                  "subSteps": [
                                    "Saiba que switches são camada 2 avançados: comutação baseada em tabelas MAC dinâmicas.",
                                    "Aprenda sobre aprendizado MAC: switch observa portas de origem e constrói tabela.",
                                    "Entenda encaminhamento unicast: frame só para porta destino, reduz broadcast.",
                                    "Diferencie de hubs: switches criam domínios de colisão por porta (full-duplex).",
                                    "Teste conceito: trace um frame de PC1 para PC3 em um switch de 8 portas."
                                  ],
                                  "verification": "Monte uma tabela MAC simples para um switch com 3 conexões e simule encaminhamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Packet Tracer ou GNS3 para simulação, quadro branco para tabelas.",
                                  "tips": "Switches 'aprendem' como um cérebro; limpe a tabela com 'clear mac-address-table'.",
                                  "learningObjective": "Dominar comutação de switches em camada 2 com tabelas MAC.",
                                  "commonMistakes": "Confundir switch com roteador; switches não olham IP."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Funções de Roteadores e Comparações",
                                  "subSteps": [
                                    "Estude roteadores na camada 3: roteiam pacotes IP entre redes usando tabelas de roteamento.",
                                    "Aprenda sobre headers IP: source/dest IP guiam decisões de next-hop.",
                                    "Compare todos: hub (L1 todos), bridge/switch (L2 MAC local), router (L3 IP inter-redes).",
                                    "Destaque domínios: colisão (hub/bridge), broadcast (switch/router).",
                                    "Crie uma tabela comparativa de camadas, funções e limitações."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e explique diferenças em uma rede mista.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabela comparativa em Excel/Google Sheets, diagramas de rede.",
                                  "tips": "Roteadores 'conectam mundos'; use 'show ip route' em CLI para ver tabelas.",
                                  "learningObjective": "Comparar dispositivos por camadas OSI e funções específicas.",
                                  "commonMistakes": "Dizer que switches roteiam; eles ficam na mesma sub-rede."
                                }
                              ],
                              "practicalExample": "Em uma rede doméstica: hub conecta 4 dispositivos (todos veem tráfego, lento); substitua por switch (tráfego direto PC1-PC2 para streaming sem interferência); bridge une duas LANs filtrando; roteador conecta à internet roteando pacotes IP para google.com.",
                              "finalVerifications": [
                                "Explicar broadcast em hub vs. unicast em switch.",
                                "Desenhar tabela MAC de um switch após 3 frames.",
                                "Diferenciar filtragem de bridge de roteamento de router.",
                                "Identificar camada OSI de cada dispositivo.",
                                "Simular tráfego em uma rede com todos os dispositivos.",
                                "Listar 3 diferenças entre switch e router."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas camadas OSI (L1 hub, L2 bridge/switch, L3 router) - 25%.",
                                "Descrição correta de funções (broadcast, MAC learning, IP routing) - 30%.",
                                "Comparações claras e tabelas completas - 20%.",
                                "Exemplos práticos viáveis - 15%.",
                                "Ausência de erros comuns (ex: confundir MAC/IP) - 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tabelas MAC como funções de mapeamento (endereço -> porta).",
                                "Física: Camada 1 envolve sinais elétricos e transmissão de bits.",
                                "Lógica/Algoritmos: Aprendizado MAC como algoritmo de árvore de decisão simples.",
                                "Segurança: Implicações de broadcast em hubs para vulnerabilidades."
                              ],
                              "realWorldApplication": "Em empresas, switches segmentam redes para eficiência; roteadores gerenciam tráfego WAN para cloud; bridges conectam VLANs legadas; hubs raros, mas úteis em testes para simular colisões em data centers."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Diferenciar mídias de transmissão em redes",
                            "description": "Comparar mídias guiadas (cabos coaxiais, par trançado, fibra ótica) e não guiadas (rádio, infravermelho, micro-ondas), descrevendo características como largura de banda, atenuação, custo e aplicações típicas em redes locais e de longa distância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as Mídias Guiadas de Transmissão",
                                  "subSteps": [
                                    "Defina mídias guiadas como meios físicos que direcionam o sinal, como cabos.",
                                    "Descreva o cabo coaxial: estrutura (condutor central, isolante, malha, capa), largura de banda (até 1 Gbps), atenuação moderada, custo médio.",
                                    "Explique o par trançado: tipos (UTP/STP), largura de banda (até 10 Gbps em Cat6+), atenuação alta em distâncias longas, custo baixo.",
                                    "Detalhe a fibra ótica: tipos (monomodo/multimodo), largura de banda muito alta (10+ Gbps), atenuação baixa, custo alto.",
                                    "Registre características em uma tabela comparativa inicial."
                                  ],
                                  "verification": "Criar uma tabela resumindo as três mídias guiadas com pelo menos 4 características cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de redes ou PDF online sobre mídias de transmissão",
                                    "Planilha ou papel para tabela",
                                    "Vídeo tutorial sobre cabos (YouTube: 'Tipos de cabos de rede')"
                                  ],
                                  "tips": "Use diagramas visuais para entender a estrutura interna dos cabos; foque em imagens para memorizar.",
                                  "learningObjective": "Identificar e descrever as principais mídias guiadas e suas características básicas.",
                                  "commonMistakes": [
                                    "Confundir par trançado com coaxial (par trançado é mais barato e flexível)",
                                    "Ignorar diferenças entre UTP e STP no par trançado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender as Mídias Não Guiadas de Transmissão",
                                  "subSteps": [
                                    "Defina mídias não guiadas como ondas eletromagnéticas sem meio físico.",
                                    "Descreva rádio (Wi-Fi): frequências (2.4/5 GHz), largura de banda média (até 1-10 Gbps), atenuação alta por obstáculos, custo baixo.",
                                    "Explique infravermelho (IrDA): curto alcance, largura de banda baixa-média, sensível a luz direta, custo baixo, uso em dispositivos próximos.",
                                    "Detalhe micro-ondas: ponto-a-ponto, largura de banda alta, atenuação por distância/condições climáticas, custo médio-alto.",
                                    "Registre em uma tabela comparativa com as guiadas."
                                  ],
                                  "verification": "Listar as três mídias não guiadas com exemplos de uso e pelo menos 3 características cada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Mesmos materiais do step 1",
                                    "Vídeo sobre wireless: 'Tipos de transmissão sem fio'"
                                  ],
                                  "tips": "Pense em exemplos cotidianos como Wi-Fi em casa para associar conceitos.",
                                  "learningObjective": "Identificar e descrever as principais mídias não guiadas e suas limitações.",
                                  "commonMistakes": [
                                    "Confundir rádio com micro-ondas (rádio é omni-direcional, micro-ondas direcional)",
                                    "Subestimar impacto de interferências em não guiadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Características Chave",
                                  "subSteps": [
                                    "Compare largura de banda: guiadas (fibra > coaxial > par) vs não guiadas (micro-ondas > rádio > IR).",
                                    "Analise atenuação: guiadas baixa em fibra, alta em par; não guiadas alta por distância/obstáculos.",
                                    "Avalie custo: não guiadas geralmente mais baratas que fibra.",
                                    "Discuta outros fatores: segurança (guiadas mais seguras), instalação (não guiadas mais fácil).",
                                    "Crie uma matriz de comparação 2x2 (guiadas vs não guiadas por característica)."
                                  ],
                                  "verification": "Preencher uma matriz de comparação com 4 características principais para todos os tipos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para matriz",
                                    "Artigos comparativos online (ex: Cisco Networking Basics)"
                                  ],
                                  "tips": "Use cores na matriz: verde para vantagens, vermelho para desvantagens.",
                                  "learningObjective": "Realizar comparações quantitativas e qualitativas entre mídias guiadas e não guiadas.",
                                  "commonMistakes": [
                                    "Ignorar contexto de distância (guiadas para longa, não guiadas para curta)",
                                    "Generalizar custos sem considerar escala"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Aplicações Típicas",
                                  "subSteps": [
                                    "Mapeie aplicações locais: par trançado (LAN Ethernet), rádio (Wi-Fi).",
                                    "Mapeie longa distância: fibra ótica (backbones), micro-ondas (links rurais).",
                                    "Exemplos específicos: coaxial em TV a cabo, IR em controles remotos.",
                                    "Discuta trade-offs: custo vs performance em cenários reais.",
                                    "Crie um fluxograma de escolha de mídia baseado em necessidades."
                                  ],
                                  "verification": "Desenhar um fluxograma ou tabela de aplicações com pelo menos 2 exemplos por tipo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel ou ferramenta de fluxograma online (Draw.io)",
                                    "Casos de estudo de redes reais"
                                  ],
                                  "tips": "Considere seu ambiente: rede de casa usa quais mídias?",
                                  "learningObjective": "Aplicar conhecimentos para selecionar mídias adequadas a cenários de rede.",
                                  "commonMistakes": [
                                    "Atribuir fibra a LANs locais (é overkill, use par ou Wi-Fi)",
                                    "Esquecer aplicações híbridas modernas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa com escritório local (LAN) e filial a 50km, use par trançado/rádio para LAN interna (baixo custo, curta distância) e fibra/micro-ondas para link inter-oficinas (alta banda, baixa atenuação). Compare: par trançado atenua muito em 50km, rádio interfere em áreas urbanas.",
                              "finalVerifications": [
                                "Explicar corretamente 3 mídias guiadas e 3 não guiadas com 4 características cada.",
                                "Preencher matriz comparativa sem erros factuais.",
                                "Identificar aplicação correta para 5 cenários dados (local/longa distância).",
                                "Diferenciar trade-offs em custo vs performance verbalmente.",
                                "Criar fluxograma de escolha de mídia funcional.",
                                "Listar prós/contras de cada tipo em quiz autoaplicado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas descrições técnicas (80% correto).",
                                "Profundidade da comparação (cobertura de todas características chave).",
                                "Criatividade e acurácia em exemplos práticos.",
                                "Capacidade de aplicar em cenários reais sem erros.",
                                "Clareza na comunicação (tabelas/fluxogramas legíveis).",
                                "Identificação correta de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas eletromagnéticas e atenuação.",
                                "Matemática: Cálculos de largura de banda e taxas de perda de sinal.",
                                "Engenharia: Design de infraestrutura de redes.",
                                "Economia: Análise custo-benefício em escolhas tecnológicas."
                              ],
                              "realWorldApplication": "Projetistas de redes usam isso para escolher cabos Ethernet (par trançado) em prédios, Wi-Fi (rádio) em escritórios abertos, fibra em data centers e micro-ondas em telecomunicações rurais, otimizando performance e custo em ISPs como Vivo ou Claro."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Componentes de Software em Redes de Computadores",
                        "description": "Programas, protocolos e sistemas operacionais essenciais para o controle, gerenciamento e comunicação em redes de computadores, incluindo stacks de protocolos e drivers.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Identificar os componentes básicos de software de rede",
                            "description": "Listar e reconhecer drivers de rede, pilha de protocolos TCP/IP, sistemas operacionais com suporte a rede (como Windows, Linux) e utilitários de configuração (ifconfig, ipconfig), explicando sua integração com o hardware.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Drivers de Rede e sua Integração com Hardware",
                                  "subSteps": [
                                    "Pesquise o que são drivers de rede e sua função como intermediários entre hardware e SO.",
                                    "Identifique exemplos de drivers para placas de rede comuns (ex: Realtek, Intel).",
                                    "Explique como drivers traduzem comandos do SO para o hardware físico.",
                                    "Instale um driver de rede em uma VM ou máquina virtual para observação.",
                                    "Verifique o status do driver no gerenciador de dispositivos."
                                  ],
                                  "verification": "Confirme que consegue listar funções do driver e visualizar sua instalação no sistema.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com acesso à internet",
                                    "Máquina virtual (VirtualBox ou VMware)",
                                    "Documentação de drivers de rede"
                                  ],
                                  "tips": "Sempre baixe drivers do site oficial do fabricante para evitar malware.",
                                  "learningObjective": "Compreender o papel dos drivers como ponte entre software e hardware de rede.",
                                  "commonMistakes": [
                                    "Confundir drivers com firmware",
                                    "Ignorar atualizações de drivers que causam incompatibilidades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Pilha de Protocolos TCP/IP",
                                  "subSteps": [
                                    "Estude os 4 layers da pilha TCP/IP: Application, Transport, Internet, Link.",
                                    "Liste protocolos chave: HTTP (Application), TCP/UDP (Transport), IP (Internet), Ethernet (Link).",
                                    "Desenhe um diagrama simples da pilha e anote como dados fluem de cima para baixo.",
                                    "Use ferramentas como Wireshark para capturar pacotes e identificar layers.",
                                    "Explique como a pilha integra com drivers para envio/recebimento de dados."
                                  ],
                                  "verification": "Crie um diagrama da pilha TCP/IP e identifique protocolos em um pacote capturado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Papel e caneta ou ferramenta de diagrama (Draw.io)",
                                    "Tutoriais online sobre TCP/IP"
                                  ],
                                  "tips": "Lembre-se: TCP/IP é um modelo, não uma implementação específica; foque nos conceitos.",
                                  "learningObjective": "Reconhecer a estrutura da pilha TCP/IP e sua interação com outros componentes.",
                                  "commonMistakes": [
                                    "Confundir TCP/IP com OSI (7 layers)",
                                    "Ignorar o papel do Link layer na integração hardware"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Sistemas Operacionais com Suporte a Rede",
                                  "subSteps": [
                                    "Compare suporte a rede no Windows (Gerenciador de Dispositivos, ncpa.cpl) e Linux (NetworkManager).",
                                    "Instale e configure rede básica em uma VM Windows e Linux.",
                                    "Liste serviços de rede: DHCP client, DNS resolver em cada SO.",
                                    "Descreva como SOs gerenciam drivers e pilha TCP/IP internamente.",
                                    "Teste conectividade entre VMs para verificar suporte."
                                  ],
                                  "verification": "Configure rede em ambas VMs e teste ping entre elas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "VMs com Windows e Linux",
                                    "ISO de instalação se necessário",
                                    "Documentação Microsoft e Linux man pages"
                                  ],
                                  "tips": "Use bridges em VMs para simular rede real sem complicações.",
                                  "learningObjective": "Identificar como Windows e Linux suportam e integram componentes de rede.",
                                  "commonMistakes": [
                                    "Não ativar rede compartilhada nas VMs",
                                    "Confundir configurações de IP estático vs DHCP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar Utilitários de Configuração e Integração Geral",
                                  "subSteps": [
                                    "Aprenda comandos: ipconfig/ifconfig para ver configurações de rede.",
                                    "Execute comandos para listar interfaces, IPs, máscaras e gateways.",
                                    "Configure IP manualmente com netsh (Windows) ou ip command (Linux).",
                                    "Explique como utilitários interagem com drivers, SO e TCP/IP.",
                                    "Resolva um problema simulado: 'sem conexão' diagnosticando com esses tools."
                                  ],
                                  "verification": "Gere relatórios de configuração de rede usando ipconfig/ifconfig e resolva um cenário de falha.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Terminal/Command Prompt",
                                    "VMs configuradas",
                                    "Lista de comandos de referência"
                                  ],
                                  "tips": "Pratique em modo não-root no Linux para segurança.",
                                  "learningObjective": "Usar utilitários para configurar e diagnosticar componentes de software de rede.",
                                  "commonMistakes": [
                                    "Erros de sintaxe em comandos",
                                    "Não flushar DNS cache após mudanças"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório doméstico, instale Ubuntu em uma VM, baixe driver para placa virtual, configure IP via ifconfig, capture tráfego TCP/IP com Wireshark para acessar um site, verificando integração completa.",
                              "finalVerifications": [
                                "Liste corretamente os 4 componentes principais com definições.",
                                "Desenhe e explique diagrama de integração hardware-software.",
                                "Execute ipconfig/ifconfig e interprete saída em Windows/Linux.",
                                "Identifique layers TCP/IP em um pacote real capturado.",
                                "Resolva cenário: 'driver ausente causa perda de conectividade'."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e descrição de cada componente (80% correto).",
                                "Demonstração prática de comandos e ferramentas em ambiente simulado.",
                                "Explicação clara da integração entre componentes.",
                                "Diagrama ou mapa conceitual completo e legível.",
                                "Resolução autônoma de pelo menos um problema de configuração."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de sub-redes e endereços IP binários.",
                                "Física: Compreensão de sinais elétricos que drivers modulam.",
                                "Lógica/Algoritmos: Fluxo de dados na pilha de protocolos.",
                                "Segurança: Configurações seguras em SOs para evitar vulnerabilidades."
                              ],
                              "realWorldApplication": "Em uma empresa, use esses conhecimentos para diagnosticar falhas de rede, configurar estações de trabalho Windows/Linux e otimizar tráfego TCP/IP em data centers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Explicar a necessidade de protocolos em redes",
                            "description": "Descrever por que protocolos são fundamentais para a interoperabilidade em redes heterogêneas, introduzindo o modelo TCP/IP como suite padrão e suas camadas básicas (aplicação, transporte, rede e enlace).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de protocolos em redes",
                                  "subSteps": [
                                    "Defina o que é um protocolo em termos simples: conjunto de regras para comunicação entre dispositivos.",
                                    "Discuta cenários cotidianos sem regras, como uma conversa sem idioma comum, para ilustrar confusão.",
                                    "Explique que protocolos padronizam formatos de dados, sequências e tratamento de erros.",
                                    "Liste exemplos iniciais de protocolos simples, como apertos de mão em negociações.",
                                    "Resuma a importância da padronização para evitar caos em comunicações."
                                  ],
                                  "verification": "Escreva uma definição de protocolo e um exemplo de falha sem ele; revise com um colega.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta para anotações; vídeo introdutório sobre protocolos (YouTube: 'What is a Network Protocol?').",
                                  "tips": "Use analogias do dia a dia, como regras de trânsito, para fixar o conceito.",
                                  "learningObjective": "Identificar protocolos como regras essenciais para comunicação ordenada em redes.",
                                  "commonMistakes": "Confundir protocolos com hardware; lembrar que são software/regras lógicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar a necessidade de interoperabilidade em redes heterogêneas",
                                  "subSteps": [
                                    "Defina redes heterogêneas: dispositivos de diferentes fabricantes, SOs e tecnologias.",
                                    "Descreva problemas sem protocolos: incompatibilidade de dados, falhas de roteamento e perda de pacotes.",
                                    "Ilustre com exemplo: um PC Windows enviando dados para um Mac sem protocolos comuns.",
                                    "Discuta benefícios: conectividade universal, escalabilidade e inovação aberta.",
                                    "Crie um diagrama simples mostrando falha vs sucesso com protocolos."
                                  ],
                                  "verification": "Desenhe um fluxograma de comunicação falha vs bem-sucedida e explique oralmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de desenho como Draw.io ou papel; artigos sobre interoperabilidade (RFCs básicas).",
                                  "tips": "Pense em dispositivos IoT variados conectados à internet para contextualizar heterogeneidade.",
                                  "learningObjective": "Reconhecer como protocolos habilitam comunicação entre sistemas diversos.",
                                  "commonMistakes": "Ignorar erros de dados; enfatize que protocolos lidam com formatação e correção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o modelo TCP/IP como suite padrão",
                                  "subSteps": [
                                    "Apresente TCP/IP como suite dominante da internet, desenvolvida nos anos 70.",
                                    "Compare brevemente com modelo OSI (7 camadas) vs TCP/IP (4-5 camadas efetivas).",
                                    "Explique por que TCP/IP prevaleceu: simplicidade, robustez e adoção global.",
                                    "Liste protocolos chave: TCP (confiável), UDP (rápido), IP (endereçamento).",
                                    "Descreva o funcionamento geral: encapsulamento de dados através das camadas."
                                  ],
                                  "verification": "Liste 3 vantagens do TCP/IP sobre alternativas e recite sua história básica.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Diagrama TCP/IP (impresso ou online); simulador Wireshark para visualização básica.",
                                  "tips": "Memorize acrônimo 'A-T-N-E' para camadas: Application, Transport, Network, (Data) Link.",
                                  "learningObjective": "Entender TCP/IP como base da internet moderna e sua evolução.",
                                  "commonMistakes": "Confundir TCP/IP com HTTP; TCP/IP é a suite, HTTP é aplicação sobre ela."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever as camadas básicas do modelo TCP/IP",
                                  "subSteps": [
                                    "Camada Aplicação: Protocolos como HTTP, FTP; foco em serviços usuário-final.",
                                    "Camada Transporte: TCP (conexão-oriented, controle de fluxo), UDP (sem conexão).",
                                    "Camada Rede: IP (roteamento, endereços lógicos IPv4/IPv6).",
                                    "Camada Enlace: Ethernet, Wi-Fi; transmissão física de frames.",
                                    "Explique interações: dados 'embalados' de app para enlace e vice-versa."
                                  ],
                                  "verification": "Crie um mapa mental das 4 camadas com 1 protocolo/exemplo cada; teste explicando.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Mapa mental tool (MindMeister); vídeo Khan Academy sobre TCP/IP layers.",
                                  "tips": "Visualize como cebola: camadas envolvem dados progressivamente.",
                                  "learningObjective": "Mapear funções e protocolos das camadas TCP/IP básicas.",
                                  "commonMistakes": "Trocar camadas Rede e Transporte; Rede é roteamento global, Transporte é end-to-end."
                                }
                              ],
                              "practicalExample": "Simule uma rede simples com 2 computadores diferentes (um Linux, um Windows) usando ping (ICMP sobre IP): sem protocolos IP, o ping falha; com eles, interoperam perfeitamente, demonstrando necessidade para heterogeneidade.",
                              "finalVerifications": [
                                "Explicar verbalmente por que redes sem protocolos causam caos em 1 minuto.",
                                "Desenhar e rotular as 4 camadas TCP/IP corretamente.",
                                "Identificar 2 protocolos por camada com funções breves.",
                                "Discutir interoperabilidade com exemplo real de dispositivos mistos.",
                                "Comparar TCP vs UDP em cenários apropriados.",
                                "Listar 3 benefícios da suite TCP/IP para a internet."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação de protocolos e interoperabilidade (20%)",
                                "Precisão nas descrições das camadas TCP/IP (25%)",
                                "Uso correto de exemplos e analogias (20%)",
                                "Compreensão de heterogeneidade e padronização (20%)",
                                "Capacidade de diagramação e verificação prática (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em checksums de protocolos para detecção de erros.",
                                "Física: Propagação de sinais na camada enlace (ondas eletromagnéticas).",
                                "Língua Portuguesa: Analogias linguísticas para regras de comunicação padronizada.",
                                "História: Evolução da internet (ARPANET para TCP/IP nos anos 70)."
                              ],
                              "realWorldApplication": "Na internet diária, protocolos TCP/IP permitem que seu smartphone Android acesse sites em servidores AWS (Linux), garantindo e-mails, streaming e chamadas funcionem globalmente sem falhas de compatibilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Descrever software de gerenciamento de rede",
                            "description": "Explicar o papel de softwares como SNMP para monitoramento, DHCP para alocação dinâmica de IP e ferramentas de diagnóstico (ping, traceroute), incluindo exemplos de configuração básica em ambientes reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o SNMP para Monitoramento de Redes",
                                  "subSteps": [
                                    "Pesquisar a definição de SNMP e suas versões principais (v1, v2c, v3).",
                                    "Identificar os componentes chave: Gerenciador (Manager), Agente (Agent) e MIB (Management Information Base).",
                                    "Explicar as operações básicas: Get (leitura), Set (escrita) e Trap (notificações assíncronas).",
                                    "Analisar exemplos de uso em monitoramento de dispositivos de rede.",
                                    "Comparar SNMP com outros protocolos de gerenciamento."
                                  ],
                                  "verification": "Listar e descrever corretamente os três componentes principais do SNMP e pelo menos duas operações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 1155/1157 para SNMP",
                                    "Tutoriais online sobre SNMP (ex: Cisco Networking Academy)",
                                    "Ferramenta gratuita como iReasoning MIB Browser"
                                  ],
                                  "tips": "Comece pelas versões mais recentes (v3) para entender melhorias em segurança como autenticação e criptografia.",
                                  "learningObjective": "Dominar os fundamentos do SNMP e seu papel no monitoramento proativo de redes.",
                                  "commonMistakes": [
                                    "Confundir Trap com polling periódico",
                                    "Ignorar diferenças de segurança entre versões do SNMP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o DHCP para Alocação Dinâmica de IPs",
                                  "subSteps": [
                                    "Definir DHCP e seu protocolo DORA (Discover, Offer, Request, Acknowledge).",
                                    "Descrever o papel do servidor DHCP, cliente e relay agent.",
                                    "Explicar opções configuráveis como lease time, gateway padrão e DNS servers.",
                                    "Simular o processo de alocação de IP em uma rede local.",
                                    "Discutir vantagens sobre atribuição estática de IPs."
                                  ],
                                  "verification": "Desenhar o fluxo DORA e explicar cada etapa verbalmente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "RFC 2131 para DHCP",
                                    "Simulador de rede como Packet Tracer (Cisco)",
                                    "Servidor DHCP local via software como ISC DHCP"
                                  ],
                                  "tips": "Use diagramas para visualizar o processo DORA, facilitando a memorização.",
                                  "learningObjective": "Entender como o DHCP automatiza a configuração de rede e reduz erros manuais.",
                                  "commonMistakes": [
                                    "Confundir lease time com TTL de DNS",
                                    "Esquecer o papel do relay agent em sub-redes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar Ferramentas de Diagnóstico: Ping e Traceroute",
                                  "subSteps": [
                                    "Aprender o comando ping: sintaxe, opções (-c para contagem, -i para intervalo) e interpretação de resultados (RTT, perda de pacotes).",
                                    "Estudar traceroute (ou tracert no Windows): rastreamento de rota, hops e timeouts.",
                                    "Executar testes práticos em rede local e externa.",
                                    "Interpretar saídas comuns: falhas de conectividade, loops de roteamento.",
                                    "Comparar com ferramentas avançadas como mtr (my traceroute)."
                                  ],
                                  "verification": "Executar ping e traceroute para um site externo e interpretar os resultados em um relatório curto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Terminal de comando (Linux/Windows)",
                                    "Rede local ou internet para testes",
                                    "Documentação man ping/traceroute"
                                  ],
                                  "tips": "Sempre teste com -c 4 no ping para resultados rápidos e evite floods acidentais.",
                                  "learningObjective": "Saber diagnosticar problemas de conectividade usando ferramentas essenciais.",
                                  "commonMistakes": [
                                    "Interpretar RTT alto como falha sem considerar latência de rede",
                                    "Ignorar firewalls bloqueando ICMP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Configurações Básicas em Ambientes Reais",
                                  "subSteps": [
                                    "Configurar SNMP em um dispositivo simulado (ex: habilitar agente em roteador virtual).",
                                    "Instalar e configurar um servidor DHCP simples (ex: em Linux com dhcpd).",
                                    "Executar diagnósticos integrados: monitorar via SNMP e testar com ping/traceroute.",
                                    "Simular um cenário real: rede com 5 dispositivos alocando IPs dinamicamente.",
                                    "Documentar configurações e troubleshooting realizado."
                                  ],
                                  "verification": "Demonstrar uma configuração funcional de DHCP com monitoramento SNMP e diagnóstico bem-sucedido.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Cisco Packet Tracer ou GNS3 para simulação",
                                    "Máquina virtual com Ubuntu para servidor DHCP",
                                    "Documentação de configuração específica do software"
                                  ],
                                  "tips": "Salve configurações em arquivos de texto para reutilização e teste incrementalmente.",
                                  "learningObjective": "Aplicar conhecimentos em configurações práticas, integrando todos os softwares.",
                                  "commonMistakes": [
                                    "Esquecer de liberar portas UDP (161/162 para SNMP, 67/68 para DHCP)",
                                    "Não verificar logs de erro durante configuração"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma pequena empresa com 10 computadores, configure um servidor DHCP em um Raspberry Pi para alocar IPs automaticamente, habilite SNMP v3 no roteador principal para monitoramento de tráfego, e use ping/traceroute para diagnosticar lentidão na conexão com o servidor cloud, identificando um hop com alta latência.",
                              "finalVerifications": [
                                "Explicar o fluxo DORA do DHCP com diagrama.",
                                "Listar componentes SNMP e dar exemplo de Trap.",
                                "Interpretar saída de traceroute com perda de pacotes.",
                                "Descrever configuração básica de SNMP em um roteador.",
                                "Demonstrar ping com opções avançadas.",
                                "Integrar ferramentas em um cenário de troubleshooting."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 100% de acerto nos termos técnicos.",
                                "Profundidade prática: Execução bem-sucedida de pelo menos uma configuração.",
                                "Clareza na explicação: Uso de exemplos reais e diagramas.",
                                "Completude: Cobertura de todos os softwares (SNMP, DHCP, ping/traceroute).",
                                "Criatividade em troubleshooting: Identificação de 3 cenários comuns de falha.",
                                "Integração: Conexão entre ferramentas em um fluxo unificado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de sub-redes e endereços IP em DHCP.",
                                "Segurança da Informação: Autenticação no SNMP v3 e riscos de broadcast DHCP.",
                                "Administração: Gerenciamento de recursos de rede em TI empresarial.",
                                "Física: Propagação de sinais e latência medida por ping/traceroute."
                              ],
                              "realWorldApplication": "Administradores de rede em empresas usam esses softwares diariamente para manter redes estáveis, como em data centers onde SNMP monitora milhares de dispositivos, DHCP gerencia IPs em escritórios remotos e ping/traceroute resolvem outages em tempo real, evitando perdas financeiras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.4",
                            "name": "Relacionar hardware e software em uma rede funcional",
                            "description": "Demonstrar como o software (ex.: drivers e protocolos) interage com o hardware (ex.: NIC e switches) para formar uma rede operacional, usando diagramas simples de uma LAN básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar componentes de hardware fundamentais em uma rede",
                                  "subSteps": [
                                    "Liste os principais dispositivos de hardware: NIC (Network Interface Card), switches, roteadores e cabos Ethernet.",
                                    "Descreva a função de cada um: NIC conecta o computador à rede, switch direciona tráfego local, roteadores conectam redes diferentes.",
                                    "Examine fisicamente ou em imagens um NIC e um switch, notando portas RJ-45.",
                                    "Pesquise especificações básicas de um switch comum (ex.: número de portas, velocidade suportada).",
                                    "Crie uma tabela simples comparando hardware de rede com periféricos comuns."
                                  ],
                                  "verification": "Concluído quando a tabela de hardware for criada e funções explicadas corretamente em voz alta ou por escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Imagens ou diagramas de hardware de rede",
                                    "Acesso à internet para pesquisa rápida",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Use analogias como 'switch é como um poste de luz distribuindo energia' para fixar conceitos.",
                                  "learningObjective": "Compreender o papel físico do hardware na formação de redes.",
                                  "commonMistakes": [
                                    "Confundir switch com roteador (switch é local, roteador interliga redes)",
                                    "Ignorar cabos como componente essencial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar componentes de software fundamentais em uma rede",
                                  "subSteps": [
                                    "Liste softwares chave: drivers de NIC, protocolos TCP/IP, sistemas operacionais de rede (ex.: configurações no Windows/Linux).",
                                    "Explique drivers: software que permite ao SO comunicar com hardware específico.",
                                    "Descreva protocolos: regras de comunicação como IP para endereçamento e Ethernet para camada física.",
                                    "Instale ou simule a instalação de um driver de rede em um ambiente virtual (ex.: VirtualBox).",
                                    "Verifique configurações de rede no seu SO atual (ipconfig/ifconfig)."
                                  ],
                                  "verification": "Concluído quando drivers e protocolos forem listados com exemplos e configurações de rede visualizadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Computador com SO instalado",
                                    "Software de virtualização opcional",
                                    "Documentação de drivers online"
                                  ],
                                  "tips": "Sempre associe software a hardware específico: 'driver é o tradutor entre SO e NIC'.",
                                  "learningObjective": "Reconhecer como software habilita funcionalidades de hardware de rede.",
                                  "commonMistakes": [
                                    "Achar que protocolos são apenas 'apps'",
                                    "Não diferenciar driver de protocolo (driver é específico de hardware, protocolo é padrão universal)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar interações entre hardware e software em uma rede",
                                  "subSteps": [
                                    "Desenhe um fluxograma simples: dados do app → SO → driver → NIC → cabo → switch → NIC → driver → SO → app.",
                                    "Simule o processo: envie um ping entre dois dispositivos e trace o caminho (hardware e software envolvidos).",
                                    "Discuta falhas comuns: driver ausente causa 'NIC não detectado', protocolo errado causa 'sem conectividade'.",
                                    "Crie um mapa mental ligando cada hardware a seu software correspondente.",
                                    "Explique camada OSI básica: hardware na camada 1-2, software em camadas superiores."
                                  ],
                                  "verification": "Concluído quando fluxograma for desenhado e um ping simulado for explicado passo a passo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (Draw.io ou papel)",
                                    "Dois dispositivos conectados em rede para teste de ping"
                                  ],
                                  "tips": "Pense em camadas: hardware é o 'corpo', software é o 'cérebro' da rede.",
                                  "learningObjective": "Mapear interações precisas entre hardware e software para funcionamento de rede.",
                                  "commonMistakes": [
                                    "Ignorar ordem de camadas (hardware primeiro)",
                                    "Confundir driver com firmware (driver é no host, firmware no dispositivo)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir diagrama de uma LAN básica funcional",
                                  "subSteps": [
                                    "Desenhe diagrama de LAN: dois PCs com NICs → switch → conexões via cabos Ethernet.",
                                    "Anote softwares: drivers instalados em cada PC, protocolo IP configurado (ex.: 192.168.1.x).",
                                    "Teste conectividade: configure IPs estáticos e execute ping entre PCs.",
                                    "Adicione legendas explicando interações (setas com labels como 'via driver' ou 'protocolo TCP/IP').",
                                    "Documente o diagrama em um relatório curto com capturas de tela."
                                  ],
                                  "verification": "Concluído quando diagrama for finalizado, ping funcionar e relatório escrito.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Dois computadores ou VMs",
                                    "Switch ou roteador simples",
                                    "Cabos Ethernet",
                                    "Ferramenta de diagramação"
                                  ],
                                  "tips": "Use IPs da mesma sub-rede para teste rápido (ex.: 192.168.1.10 e 192.168.1.11).",
                                  "learningObjective": "Demonstrar uma rede operacional via diagrama e teste prático.",
                                  "commonMistakes": [
                                    "IPs em sub-redes diferentes causando falha no ping",
                                    "Esquecer de ativar drivers ou compartilhar conexão"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure uma LAN caseira: conecte dois laptops via switch Ethernet. Instale drivers de NIC atualizados, configure IPs estáticos (192.168.1.10/24 e 192.168.1.11/24), execute ping bem-sucedido e desenhe diagrama mostrando fluxo de pacotes via drivers e protocolos Ethernet/IP.",
                              "finalVerifications": [
                                "Desenhar corretamente diagrama de LAN com hardware e software anotados.",
                                "Executar ping entre dois dispositivos com explicação das interações.",
                                "Identificar e resolver uma falha simulada (ex.: driver desinstalado).",
                                "Explicar verbalmente o papel de NIC, driver, switch e TCP/IP.",
                                "Criar tabela comparativa de hardware-software em redes.",
                                "Simular tráfego de rede usando ferramentas como Wireshark básico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes hardware e software (90% correto).",
                                "Clareza e completude do diagrama de LAN (todas interações mostradas).",
                                "Sucesso no teste prático de conectividade (ping com <1% perda).",
                                "Profundidade nas explicações de interações (uso de exemplos concretos).",
                                "Criatividade em analogias e avoidance de erros comuns.",
                                "Qualidade do relatório final (organizado, com imagens)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Sinais elétricos e transmissão em cabos Ethernet.",
                                "Matemática: Endereçamento IP binário e máscaras de sub-rede.",
                                "Lógica/Algoritmos: Fluxo de dados como algoritmo sequencial.",
                                "Eletrônica: Funcionamento básico de circuitos em NICs e switches."
                              ],
                              "realWorldApplication": "Em escritórios, configurar LANs para compartilhamento de impressoras e arquivos, garantindo que drivers e protocolos estejam alinhados para evitar downtime; essencial para TI em empresas, suporte técnico e IoT doméstico."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1",
                              "10.1.1.1.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Modelo TCP/IP e Necessidade de Protocolos",
                    "description": "Importância dos protocolos de comunicação e introdução ao modelo TCP/IP.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Necessidade de Protocolos em Redes de Computadores",
                        "description": "Explicação sobre a importância dos protocolos para padronizar a comunicação entre dispositivos heterogêneos em redes, resolvendo problemas de interoperabilidade entre hardware e software.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Identificar problemas sem protocolos",
                            "description": "Reconhecer desafios como falta de padronização em formatos de dados, controle de fluxo e detecção de erros em comunicações sem protocolos, usando exemplos simples de redes sem regras comuns.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Comunicação sem Protocolos",
                                  "subSteps": [
                                    "Defina comunicação em rede como troca de dados entre dispositivos.",
                                    "Explique que protocolos são conjuntos de regras compartilhadas para formatação, envio e recebimento de dados.",
                                    "Descreva cenários sem protocolos como trocas livres, sem regras comuns.",
                                    "Discuta por que redes modernas evitam isso com exemplos históricos como ARPANET inicial.",
                                    "Liste benefícios de regras comuns em comunicações cotidianas."
                                  ],
                                  "verification": "Resuma em 3 frases o que é comunicação sem protocolos e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Vídeo introdutório sobre redes (YouTube: 'What are Network Protocols'), quadro branco ou papel para anotações.",
                                  "tips": "Use analogia de conversa sem idioma comum para visualizar o caos.",
                                  "learningObjective": "Entender o papel fundamental dos protocolos na comunicação de rede.",
                                  "commonMistakes": "Confundir protocolos com hardware; protocolos são regras lógicas, não físicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Falta de Padronização em Formatos de Dados",
                                  "subSteps": [
                                    "Simule envio de mensagem: 'Olá' de A para B sem formato definido.",
                                    "Mostre como B interpreta 'Olá' como números binários errados sem padrão.",
                                    "Compare com protocolo: dados sempre em bytes fixos (ex: ASCII).",
                                    "Crie diagramas de dados mal interpretados (ex: imagem como texto).",
                                    "Teste com ferramenta simples como terminal enviando strings aleatórias."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando interpretação errada de dados sem padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de terminal (PuTTY ou cmd), papel e lápis para diagramas, exemplos de binário online.",
                                  "tips": "Pense em enviar uma foto por texto sem codificação; resulta em lixo.",
                                  "learningObjective": "Reconhecer como ausência de formato causa misinterpretação de dados.",
                                  "commonMistakes": "Ignorar que dados incluem não só texto, mas imagens e comandos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Problemas de Controle de Fluxo e Detecção de Erros",
                                  "subSteps": [
                                    "Explique controle de fluxo: remetente envia rápido, receptor não acompanha sem sinalização.",
                                    "Simule sobrecarga: A envia 100 pacotes, B perde maioria sem confirmação.",
                                    "Discuta detecção de erros: ruído corrompe bits sem checksum ou retransmissão.",
                                    "Use exemplo: mensagem 'Hi' vira 'Hx' por interferência, indetectável.",
                                    "Compare com TCP: ACKs e checksums resolvem isso."
                                  ],
                                  "verification": "Liste 3 consequências de falta de controle de fluxo e 2 de detecção de erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Simulador de rede online (ex: Cisco Packet Tracer free trial), vídeo sobre TCP handshake.",
                                  "tips": "Imagine falar ao telefone sem pausas; o outro não entende nada.",
                                  "learningObjective": "Identificar falhas em gerenciamento de velocidade e integridade de dados.",
                                  "commonMistakes": "Confundir erros de transmissão com erros de roteamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Identificação em Exemplos Simples de Redes",
                                  "subSteps": [
                                    "Crie cenário: 2 PCs conectados via cabo sem software de protocolo.",
                                    "Envie dados e observe falhas: formatação, perda, corrupção.",
                                    "Registre problemas em tabela: tipo de problema, causa, impacto.",
                                    "Proponha soluções básicas: adotar formato simples compartilhado.",
                                    "Discuta evolução para protocolos como TCP/IP."
                                  ],
                                  "verification": "Crie um relatório curto com exemplo simulado e problemas identificados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Dois computadores ou VMs com Wireshark para captura de pacotes raw, tabela em Excel/Google Sheets.",
                                  "tips": "Comece com rede local simples para isolar variáveis.",
                                  "learningObjective": "Diagnosticar problemas reais em comunicações sem protocolos.",
                                  "commonMistakes": "Subestimar impacto cumulativo: um problema leva a cadeia de falhas."
                                }
                              ],
                              "practicalExample": "Dois computadores conectados por cabo Ethernet sem configuração de protocolo: PC1 envia 'Temperatura: 25C' como texto cru. PC2, com software diferente, lê como comando binário, causando reinício. Sem controle de fluxo, PC1 satura a linha, perdendo 70% dos dados; ruído altera '25C' para '2%C', indetectável sem checksum.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 problemas principais sem protocolos.",
                                "Identificar falhas em diagrama de comunicação fornecido.",
                                "Simular cenário e listar problemas observados.",
                                "Comparar rede sem vs. com protocolo em tabela.",
                                "Propor 2 soluções básicas para cada problema.",
                                "Passar quiz de 5 questões sobre conceitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de problemas (padronização, fluxo, erros): 30%",
                                "Uso correto de exemplos e analogias: 20%",
                                "Profundidade nos sub-passos e verificações: 20%",
                                "Clareza em diagramas e relatórios: 15%",
                                "Conexão com conceitos de rede reais: 10%",
                                "Criatividade em soluções propostas: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e checksums para detecção de erros.",
                                "Física: Transmissão de sinais e interferência eletromagnética.",
                                "Língua Portuguesa: Padronização de formatos como gramática em comunicação.",
                                "História: Evolução de redes desde ARPANET sem protocolos rígidos."
                              ],
                              "realWorldApplication": "Em IoT inicial ou redes ad-hoc em desastres, ausência de protocolos causa falhas como dados corrompidos em sensores médicos ou perda de comandos em drones, destacando necessidade de padrões como MQTT para confiabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Explicar funções básicas dos protocolos",
                            "description": "Descrever as principais funções dos protocolos, como encapsulamento de dados, endereçamento, roteamento e garantia de entrega, diferenciando hardware (ex.: cabos, switches) e software (ex.: protocolos).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e a Necessidade de Protocolos em Redes",
                                  "subSteps": [
                                    "Defina o que é um protocolo em termos de comunicação de rede: um conjunto de regras padronizadas para troca de dados.",
                                    "Explique por que redes precisam de protocolos: para garantir que dispositivos heterogêneos se comuniquem de forma confiável.",
                                    "Compare protocolos a regras de trânsito: sem eles, haveria caos na comunicação.",
                                    "Identifique exemplos cotidianos, como o protocolo de aperto de mão em uma conversa.",
                                    "Pesquise brevemente a origem dos protocolos na história das redes (ex.: ARPANET)."
                                  ],
                                  "verification": "Escreva uma definição de protocolo em suas próprias palavras e liste 3 razões para sua necessidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook ou papel para anotações",
                                    "Vídeo introdutório sobre redes (ex.: Khan Academy)",
                                    "Acesso à internet para pesquisa rápida"
                                  ],
                                  "tips": "Use analogias simples do dia a dia para fixar o conceito, como protocolos sociais.",
                                  "learningObjective": "Entender o papel fundamental dos protocolos como base para comunicação em redes.",
                                  "commonMistakes": [
                                    "Confundir protocolos apenas com software avançado, ignorando sua simplicidade conceitual",
                                    "Achar que protocolos são opcionais em redes modernas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever as Principais Funções dos Protocolos",
                                  "subSteps": [
                                    "Estude encapsulamento de dados: processo de adicionar cabeçalhos aos dados para roteamento.",
                                    "Aprenda endereçamento: atribuição de identificadores únicos (ex.: IP addresses) para origem e destino.",
                                    "Entenda roteamento: seleção do melhor caminho para os dados através da rede.",
                                    "Explique garantia de entrega: mecanismos como ACKs no TCP para confirmar recebimento.",
                                    "Crie um diagrama simples mostrando dados passando por essas funções."
                                  ],
                                  "verification": "Desenhe um fluxograma ilustrando as 4 funções principais em uma transmissão de dados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Ferramenta online como draw.io",
                                    "Recursos visuais sobre modelo TCP/IP"
                                  ],
                                  "tips": "Lembre-se: pense no encapsulamento como embrulhar um presente com etiquetas.",
                                  "learningObjective": "Dominar as funções chave: encapsulamento, endereçamento, roteamento e garantia de entrega.",
                                  "commonMistakes": [
                                    "Misturar roteamento com endereçamento",
                                    "Ignorar que garantia de entrega não é universal (ex.: UDP não tem)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Hardware e Software nas Redes",
                                  "subSteps": [
                                    "Liste componentes de hardware: cabos (físicos), switches (conectam localmente), roteadores (dirigem tráfego).",
                                    "Descreva software: protocolos como TCP/IP que definem regras lógicas de comunicação.",
                                    "Compare: hardware transporta sinais elétricos/ópticos; software interpreta e controla os dados.",
                                    "Exemplo: um switch (hardware) usa protocolos como Ethernet (software) internamente.",
                                    "Crie uma tabela comparativa com exemplos."
                                  ],
                                  "verification": "Preencha uma tabela comparando 3 exemplos de hardware vs. software em redes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Imagens de componentes de rede (ex.: Google Images)"
                                  ],
                                  "tips": "Hardware é 'o que você toca'; software é 'o que roda no computador'.",
                                  "learningObjective": "Distinguir claramente o papel físico do hardware versus o lógico dos protocolos.",
                                  "commonMistakes": [
                                    "Achar que switches executam protocolos complexos sozinhos, sem software",
                                    "Confundir firmware (software em hardware) com protocolos de rede"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Funções dos Protocolos no Modelo TCP/IP",
                                  "subSteps": [
                                    "Revise camadas TCP/IP: Application, Transport, Internet, Link.",
                                    "Mapeie funções: endereçamento/roteamento na camada Internet (IP), garantia na Transport (TCP).",
                                    "Simule uma conexão: dados de um email passando pelas funções.",
                                    "Discuta limitações: nem todos protocolos garantem entrega (ex.: UDP para streaming).",
                                    "Resuma em um mapa mental conectando tudo."
                                  ],
                                  "verification": "Crie um mapa mental ligando funções dos protocolos às camadas TCP/IP.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de mindmap como MindMeister ou papel",
                                    "Diagrama TCP/IP impresso ou online"
                                  ],
                                  "tips": "Comece do topo (aplicação) e desça pelas camadas para visualizar o fluxo.",
                                  "learningObjective": "Aplicar conceitos de protocolos no contexto prático do modelo TCP/IP.",
                                  "commonMistakes": [
                                    "Confundir TCP/IP com OSI",
                                    "Achar que todas camadas fazem todas funções"
                                  ]
                                }
                              ],
                              "practicalExample": "Imagine enviando um email: 1) Encapsulamento: você escreve o texto e o cliente de email adiciona cabeçalhos. 2) Endereçamento: insere o email do destinatário (resolve para IP). 3) Roteamento: pacotes viajam por roteadores até o destino. 4) Garantia: TCP confirma entrega com ACKs. Hardware como cabos/switches transportam, protocolos gerenciam.",
                              "finalVerifications": [
                                "Liste e explique as 4 funções principais dos protocolos com exemplos.",
                                "Diferencie hardware (ex.: switch) de software (ex.: TCP) em uma transmissão.",
                                "Desenhe o fluxo de dados em uma rede simples usando TCP/IP.",
                                "Identifique qual função falha se um pacote se perde sem ACK.",
                                "Explique por que protocolos são necessários em redes heterogêneas.",
                                "Compare analogia de 'carta pelos correios' com funções de protocolos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das 4 funções principais (encapsulamento, endereçamento, roteamento, garantia).",
                                "Clareza na diferenciação entre hardware físico e software lógico.",
                                "Uso correto de exemplos do modelo TCP/IP.",
                                "Capacidade de criar diagramas ou fluxogramas ilustrativos.",
                                "Identificação de erros comuns e analogias adequadas.",
                                "Compreensão integrada: conexão entre funções e camadas de rede."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação binária de endereços IP e máscaras de sub-rede.",
                                "Física: Transmissão de sinais elétricos/ópticos em cabos e switches.",
                                "Linguagens: Protocolos como 'gramática' padronizada para comunicação digital.",
                                "História: Evolução dos protocolos desde ARPANET até internet moderna.",
                                "Educação Financeira: Impacto de falhas em protocolos em e-commerce (ex.: entregas seguras)."
                              ],
                              "realWorldApplication": "Protocolos como TCP/IP permitem o funcionamento da internet diária: navegação web (HTTP sobre TCP), streaming de vídeo (UDP para baixa latência), emails confiáveis e transações bancárias seguras, diferenciando infraestrutura física (cabos submarinos) de lógica de software."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Relacionar protocolos com interoperabilidade",
                            "description": "Analisar como protocolos permitem que dispositivos de diferentes fabricantes (ex.: Windows e Linux) se comuniquem, citando exemplos reais como a internet global.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Interoperabilidade",
                                  "subSteps": [
                                    "Defina interoperabilidade como a capacidade de sistemas diferentes trabalharem juntos.",
                                    "Discuta barreiras sem padrões, como linguagens proprietárias de fabricantes.",
                                    "Identifique exemplos iniciais: impressoras de marcas diferentes em redes mistas.",
                                    "Pesquise definições em fontes confiáveis como RFCs da IETF.",
                                    "Anote diferenças entre compatibilidade e interoperabilidade."
                                  ],
                                  "verification": "Escreva uma definição clara de interoperabilidade e cite uma fonte.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Notebook para anotações",
                                    "Documentos RFC básicos (ex: RFC 791)"
                                  ],
                                  "tips": "Use analogias cotidianas, como plugues elétricos padronizados.",
                                  "learningObjective": "Definir e diferenciar interoperabilidade de compatibilidade.",
                                  "commonMistakes": [
                                    "Confundir com 'compatibilidade para cima'",
                                    "Ignorar contexto de redes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Papel dos Protocolos na Interoperabilidade",
                                  "subSteps": [
                                    "Explique protocolos como 'regras comuns' para comunicação.",
                                    "Descreva como protocolos abstraem hardware e software heterogêneos.",
                                    "Analise camadas do modelo TCP/IP e seu papel na interoperabilidade.",
                                    "Compare comunicação sem protocolos (caos) vs. com protocolos (ordem).",
                                    "Crie um diagrama simples de handshake TCP entre Windows e Linux."
                                  ],
                                  "verification": "Desenhe um fluxograma mostrando troca de dados via protocolo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (Draw.io ou papel)",
                                    "Documentação TCP/IP",
                                    "Vídeos curtos sobre modelo OSI/TCP/IP"
                                  ],
                                  "tips": "Pense em protocolos como 'idioma universal' para máquinas.",
                                  "learningObjective": "Explicar como protocolos habilitam comunicação entre sistemas díspares.",
                                  "commonMistakes": [
                                    "Achar que protocolos só definem formato de dados",
                                    "Esquecer abstração de camadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Reais de Protocolos em Ação",
                                  "subSteps": [
                                    "Estude HTTP: navegador Windows acessando site em servidor Linux.",
                                    "Examine SMTP para e-mails entre Gmail (Google) e Outlook (Microsoft).",
                                    "Simule ping entre máquina Windows e Linux usando ICMP.",
                                    "Discuta DNS resolvendo nomes independentes de SO.",
                                    "Registre capturas de tráfego com Wireshark para visualização."
                                  ],
                                  "verification": "Capture e explique um pacote de rede entre SOs diferentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Duas VMs (Windows e Linux)",
                                    "Comandos ping/traceroute"
                                  ],
                                  "tips": "Use VMs gratuitas como VirtualBox para testes reais.",
                                  "learningObjective": "Identificar protocolos em cenários reais de interoperabilidade.",
                                  "commonMistakes": [
                                    "Focar só em TCP/IP sem exemplos concretos",
                                    "Ignorar falhas sem protocolos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com a Internet Global e Conclusões",
                                  "subSteps": [
                                    "Conecte protocolos à escala global: bilhões de dispositivos via TCP/IP.",
                                    "Discuta evolução: de ARPANET proprietária para internet aberta.",
                                    "Avalie impactos: IoT, cloud computing multi-provedor.",
                                    "Debata limitações atuais (ex: IPv4 vs IPv6).",
                                    "Escreva um parágrafo resumindo a relação protocolos-interoperabilidade."
                                  ],
                                  "verification": "Redija um ensaio curto (200 palavras) com exemplos globais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigos sobre história da internet",
                                    "Notebook",
                                    "Referências IETF/ICANN"
                                  ],
                                  "tips": "Inclua estatísticas: >5 bilhões de usuários conectados via protocolos.",
                                  "learningObjective": "Sintetizar como protocolos sustentam a internet global.",
                                  "commonMistakes": [
                                    "Generalizar sem exemplos específicos",
                                    "Subestimar escala global"
                                  ]
                                }
                              ],
                              "practicalExample": "Um laptop Windows (Dell) acessa um servidor web Apache no Linux (Ubuntu) via HTTP/TCP/IP: o protocolo HTTP garante que o pedido 'GET /' seja entendido independentemente do SO, permitindo download de uma página web globalmente acessível.",
                              "finalVerifications": [
                                "Explica interoperabilidade com definição precisa e exemplo.",
                                "Lista 3 protocolos que habilitam comunicação cross-plataforma.",
                                "Demonstra com Wireshark tráfego entre SOs diferentes.",
                                "Relaciona TCP/IP à internet global com fatos históricos.",
                                "Identifica erro comum em cenários sem protocolos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas: 30%)",
                                "Uso de exemplos reais e relevantes (25%)",
                                "Profundidade de análise de protocolos (20%)",
                                "Clareza em diagramas/fluxogramas (15%)",
                                "Conexões com aplicações globais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em protocolos de controle de erro.",
                                "História: Evolução da ARPANET para internet padronizada.",
                                "Língua Portuguesa: Redação técnica de relatórios de rede.",
                                "Física: Sinais elétricos abstraídos por protocolos de camada física."
                              ],
                              "realWorldApplication": "Na internet global, protocolos como TCP/IP permitem que smartphones Android se comuniquem com servidores AWS (Linux-based), suportando e-commerce, streaming e IoT em escala planetária, essencial para economias digitais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Introdução ao Modelo TCP/IP",
                        "description": "Visão geral do modelo TCP/IP como suite de protocolos em camadas que estrutura a comunicação em redes, comparado brevemente ao modelo OSI para contextualização.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Descrever a estrutura em camadas do TCP/IP",
                            "description": "Explicar as quatro camadas principais do modelo TCP/IP (Aplicação, Transporte, Internet e Enlace) e como cada uma abstrai complexidades para a camada superior.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito geral do modelo TCP/IP em camadas",
                                  "subSteps": [
                                    "Pesquise a origem e propósito do modelo TCP/IP como base da internet.",
                                    "Compare brevemente com o modelo OSI para destacar diferenças (TCP/IP tem 4 camadas principais).",
                                    "Identifique as 4 camadas: Aplicação, Transporte, Internet e Enlace.",
                                    "Desenhe um diagrama simples da pilha de camadas.",
                                    "Explique o princípio de abstração: cada camada esconde complexidades da superior."
                                  ],
                                  "verification": "Crie um diagrama das 4 camadas e explique verbalmente o fluxo de dados de cima para baixo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Vídeo introdutório sobre TCP/IP (ex: Khan Academy)"
                                  ],
                                  "tips": "Pense nas camadas como uma cebola: cada uma protege a interna.",
                                  "learningObjective": "Compreender a arquitetura em camadas e o conceito de abstração no TCP/IP.",
                                  "commonMistakes": [
                                    "Confundir TCP/IP com OSI (7 camadas)",
                                    "Achar que camadas são rígidas e não interagem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Camada de Aplicação",
                                  "subSteps": [
                                    "Liste protocolos comuns: HTTP, FTP, SMTP, DNS.",
                                    "Descreva como ela lida com interfaces de usuário e dados de aplicação.",
                                    "Explique que ela abstrai o resto da rede para o software.",
                                    "Exemplo: Como um navegador usa HTTP sem se preocupar com roteamento.",
                                    "Registre funções principais em uma tabela."
                                  ],
                                  "verification": "Explique como um email é gerado nesta camada sem envolver rede física.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de protocolos de aplicação (Wikipedia ou RFCs)",
                                    "Navegador web para testar HTTP"
                                  ],
                                  "tips": "Lembre-se: esta camada é 'o que o usuário vê'.",
                                  "learningObjective": "Identificar funções e protocolos da Camada de Aplicação e sua abstração.",
                                  "commonMistakes": [
                                    "Confundir com Transporte (TCP/UDP)",
                                    "Ignorar DNS como aplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Camada de Transporte",
                                  "subSteps": [
                                    "Descreva protocolos principais: TCP (confiável, com controle de fluxo) e UDP (rápido, sem garantia).",
                                    "Explique segmentação de dados, portas e garantia de entrega.",
                                    "Mostre como ela abstrai a rede IP para a aplicação (ex: multiplexação via portas).",
                                    "Compare TCP vs UDP com exemplos (video streaming vs web).",
                                    "Crie um fluxograma de envio de segmento TCP."
                                  ],
                                  "verification": "Diferencie TCP e UDP em um cenário prático e liste portas comuns (80, 443).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas TCP handshake (Wireshark tutorial)",
                                    "Ferramenta como netstat para ver portas"
                                  ],
                                  "tips": "Portas são como apartamentos em um prédio: roteiam para apps corretos.",
                                  "learningObjective": "Dominar mecanismos de Transporte e como abstraem a camada inferior.",
                                  "commonMistakes": [
                                    "Achar TCP sempre melhor que UDP",
                                    "Confundir portas com IPs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar a Camada de Internet (ou Rede)",
                                  "subSteps": [
                                    "Foco no IP: endereçamento, roteamento e datagramas.",
                                    "Explique IPv4 vs IPv6 brevemente.",
                                    "Descreva como fragmenta pacotes e roteia entre redes.",
                                    "Mostre abstração para Transporte: IP não garante entrega, só roteia.",
                                    "Simule roteamento com um mapa de rede simples."
                                  ],
                                  "verification": "Descreva o caminho de um pacote IP de sua máquina a um servidor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta traceroute ou ping",
                                    "Explicação de IP headers"
                                  ],
                                  "tips": "IP é como o correio: endereça, mas não garante chegada.",
                                  "learningObjective": "Compreender roteamento IP e abstração para camadas superiores.",
                                  "commonMistakes": [
                                    "Confundir IP com MAC (endereço físico)",
                                    "Ignorar fragmentação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Compreender a Camada de Enlace (ou Acesso à Rede) e integrações",
                                  "subSteps": [
                                    "Descreva protocolos: Ethernet, Wi-Fi (802.11), ARP.",
                                    "Explique frames, endereços MAC e detecção de erros (CRC).",
                                    "Mostre como abstrai hardware físico para IP (ex: ARP resolve IP para MAC).",
                                    "Integre todas camadas: fluxo completo de um pacote.",
                                    "Crie um diagrama end-to-end de uma conexão."
                                  ],
                                  "verification": "Trace o fluxo completo de dados através das 4 camadas em um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark para capturar pacotes reais",
                                    "Diagrama completo TCP/IP stack"
                                  ],
                                  "tips": "Esta camada é 'o fio': lida com bits no cabo ou ar.",
                                  "learningObjective": "Integrar todas as camadas e entender abstrações completas.",
                                  "commonMistakes": [
                                    "Chamar de 'Física' (é OSI)",
                                    "Esquecer ARP na transição IP-Enlace"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao acessar um site como google.com: 1) Aplicação gera HTTP request; 2) Transporte encapsula em TCP (porta 443); 3) Internet adiciona IP header e roteia; 4) Enlace usa Ethernet frame para enviar ao roteador vizinho. Use Wireshark para capturar e ver cada camada.",
                              "finalVerifications": [
                                "Listar e nomear corretamente as 4 camadas em ordem.",
                                "Explicar um protocolo exemplo por camada.",
                                "Desenhar diagrama de encapsulamento de dados.",
                                "Diferenciar abstração de cada camada para a superior.",
                                "Simular fluxo de um pacote simples com traceroute.",
                                "Identificar erros comuns em descrições de camadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e funções das 4 camadas (90% correto).",
                                "Clareza na explicação de abstrações entre camadas.",
                                "Uso correto de exemplos e protocolos específicos.",
                                "Qualidade do diagrama ou fluxograma criado.",
                                "Capacidade de integrar camadas em um cenário end-to-end.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de checksums e endereços IP/subnetting.",
                                "Física: Transmissão de sinais elétricos/ópticos na camada de Enlace.",
                                "História: Evolução do ARPANET para internet moderna.",
                                "Lógica/Algoritmos: Roteamento como problema de grafo.",
                                "Segurança: Conceitos iniciais de firewalls por camada."
                              ],
                              "realWorldApplication": "Diagnosticar problemas de rede (ex: 'por que site não carrega? Cheque DNS na Aplicação ou rota IP'), desenvolver apps cliente-servidor, configurar roteadores domésticos, ou entender ciberataques como DDoS que exploram camadas Transporte/Internet."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Comparar TCP/IP com modelo OSI",
                            "description": "Mapear as camadas TCP/IP às sete camadas OSI, destacando simplificações do TCP/IP para eficiência prática na internet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Modelo OSI de Referência",
                                  "subSteps": [
                                    "Liste as sete camadas do modelo OSI em ordem: Física, Enlace, Rede, Transporte, Sessão, Apresentação e Aplicação.",
                                    "Descreva brevemente a função de cada camada, focando em responsabilidades como codificação física, endereçamento MAC, roteamento IP, controle de fluxo TCP, gerenciamento de sessões, tradução de dados e interfaces de usuário.",
                                    "Crie um diagrama simples das camadas OSI empilhadas.",
                                    "Identifique exemplos de protocolos para cada camada (ex: Ethernet para Enlace, IP para Rede).",
                                    "Explique o princípio de separação de responsabilidades no OSI."
                                  ],
                                  "verification": "Crie um fluxograma ou tabela resumindo as 7 camadas com funções e protocolos; revise se cobre todas as camadas corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Recursos online: diagrama OSI da Wikipedia ou Cisco Networking Academy"
                                  ],
                                  "tips": "Use mnemônicos como 'Please Do Not Throw Sausage Pizza Away' para lembrar as camadas.",
                                  "learningObjective": "Compreender a estrutura teórica de 7 camadas do modelo OSI e suas funções específicas.",
                                  "commonMistakes": [
                                    "Confundir camadas de Transporte (TCP/UDP) com Rede (IP)",
                                    "Esquecer a camada de Apresentação (formatação de dados)",
                                    "Invertir a ordem das camadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Modelo TCP/IP",
                                  "subSteps": [
                                    "Identifique as 4-5 camadas do TCP/IP: Enlace/Rede (ou Acesso à Rede), Internet, Transporte e Aplicação.",
                                    "Descreva funções: Acesso à Rede (hardware físico e MAC), Internet (roteamento IP), Transporte (TCP/UDP para confiabilidade), Aplicação (HTTP, FTP).",
                                    "Compare o escopo: TCP/IP é prático, implementado na internet real.",
                                    "Liste protocolos chave: IP, TCP, UDP, ICMP no nível Internet.",
                                    "Desenhe um diagrama das camadas TCP/IP."
                                  ],
                                  "verification": "Desenhe e rotule o diagrama TCP/IP; confirme se as camadas e protocolos estão corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama",
                                    "Documentação TCP/IP da IETF ou Khan Academy vídeos"
                                  ],
                                  "tips": "Lembre-se: TCP/IP é 'de baixo para cima' como OSI, mas agrupado para simplicidade.",
                                  "learningObjective": "Dominar a arquitetura prática de 4 camadas do TCP/IP e protocolos associados.",
                                  "commonMistakes": [
                                    "Achar que TCP/IP tem 7 camadas iguais ao OSI",
                                    "Confundir camada Aplicação TCP/IP com apenas apps web",
                                    "Ignorar a camada de Acesso à Rede"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Camadas TCP/IP para OSI",
                                  "subSteps": [
                                    "Mapeie: TCP/IP Acesso à Rede → OSI Física + Enlace; Internet → Rede; Transporte → Transporte; Aplicação → Sessão + Apresentação + Aplicação.",
                                    "Crie uma tabela de correspondência lado a lado com exemplos de protocolos.",
                                    "Explique sobreposições: TCP/IP 'cola' Sessão/Apresentação na Aplicação.",
                                    "Desenhe diagramas alinhados mostrando o mapeamento.",
                                    "Teste o mapeamento com um fluxo de dados exemplo (ex: HTTP request)."
                                  ],
                                  "verification": "Complete uma tabela de mapeamento e valide com uma fonte confiável como RFCs ou tutoriais.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha ou tabela em Google Sheets",
                                    "Diagramas prontos de comparação OSI vs TCP/IP online"
                                  ],
                                  "tips": "Use setas no diagrama para mostrar como camadas TCP/IP abrangem múltiplas OSI.",
                                  "learningObjective": "Realizar mapeamento preciso entre as camadas dos dois modelos.",
                                  "commonMistakes": [
                                    "Mapear incorretamente Transporte TCP/IP apenas para Transporte OSI",
                                    "Esquecer que Aplicação TCP/IP cobre 3 camadas OSI",
                                    "Achar que há mapeamento 1:1 perfeito"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Simplificações e Eficiência do TCP/IP",
                                  "subSteps": [
                                    "Discuta por que TCP/IP simplifica: menos camadas reduzem overhead e complexidade para implementação prática.",
                                    "Compare eficiência: OSI é teórico (nunca implementado integralmente), TCP/IP otimizado para internet escalável.",
                                    "Exemplifique ganhos: Menos abstrações = latência menor em redes reais.",
                                    "Debata prós/contras: TCP/IP mais flexível, mas menos modular que OSI.",
                                    "Resuma diferenças chave em bullet points."
                                  ],
                                  "verification": "Escreva um parágrafo explicando 3 simplificações do TCP/IP vs OSI e seus benefícios.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Artigos comparativos: 'OSI vs TCP/IP' no GeeksforGeeks",
                                    "Vídeos do Professor Messer"
                                  ],
                                  "tips": "Pense em eficiência como 'menos camadas = menos 'saltos' no processamento de pacotes'.",
                                  "learningObjective": "Avaliar razões práticas pelas quais TCP/IP prevalece sobre OSI na internet.",
                                  "commonMistakes": [
                                    "Achar TCP/IP 'inferior' por ter menos camadas",
                                    "Ignorar que simplificações melhoram performance real",
                                    "Confundir OSI com implementações modernas"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um diagrama lado a lado comparando OSI e TCP/IP enquanto simula o envio de um pacote HTTP: trace o caminho desde a camada Física (bits no cabo) até Aplicação (navegador renderizando página), destacando como TCP/IP agrupa camadas para agilizar o processo em uma rede Wi-Fi doméstica.",
                              "finalVerifications": [
                                "Pode listar e mapear corretamente todas as camadas TCP/IP para OSI?",
                                "Explica pelo menos 3 simplificações do TCP/IP?",
                                "Cria um diagrama preciso de comparação?",
                                "Identifica protocolos corretos para cada camada mapeada?",
                                "Descreve benefícios de eficiência do TCP/IP na prática?",
                                "Responde a perguntas sobre diferenças sem erros comuns?"
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de camadas (100% correto ganha nota máxima)",
                                "Profundidade na explicação de funções e protocolos (detalhes em todas as camadas)",
                                "Clareza nos diagramas e tabelas (legíveis e bem rotulados)",
                                "Análise crítica de simplificações e eficiência (exemplos concretos)",
                                "Completude dos passos (todos subSteps executados)",
                                "Criatividade no practicalExample (aplicação realista)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de latência e throughput em redes (equações de propagação)",
                                "Física: Transmissão de sinais na camada Física (ondas eletromagnéticas)",
                                "Engenharia: Design modular de sistemas (princípios de abstração em software/hardware)",
                                "História da Tecnologia: Evolução de protocolos da ARPANET à internet moderna"
                              ],
                              "realWorldApplication": "Na administração de redes empresariais, profissionais usam essa comparação para diagnosticar problemas de conectividade (ex: falha na camada Transporte TCP vs roteamento IP), otimizando firewalls e VPNs que operam no modelo TCP/IP simplificado para suportar milhões de dispositivos na internet global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Identificar aplicações do modelo TCP/IP",
                            "description": "Citar exemplos de uso do TCP/IP na internet moderna, como navegação web (HTTP sobre TCP/IP) e streaming (UDP sobre TCP/IP).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica do modelo TCP/IP",
                                  "subSteps": [
                                    "Estude os 4 layers principais: Application, Transport, Internet e Network Access.",
                                    "Leia uma visão geral das funções de cada layer (ex: Transport gerencia TCP/UDP).",
                                    "Desenhe um diagrama simples dos layers e anote exemplos iniciais.",
                                    "Compare brevemente com o modelo OSI para evitar confusões.",
                                    "Anote as diferenças entre TCP (confiável) e UDP (rápido)."
                                  ],
                                  "verification": "Liste corretamente os 4 layers e dê uma função para cada um.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama do modelo TCP/IP (impresso ou online)",
                                    "Artigo introdutório sobre TCP/IP (ex: Wikipedia ou Khan Academy)"
                                  ],
                                  "tips": "Use mnemônicos como 'ATIN' para lembrar Application, Transport, Internet, Network Access.",
                                  "learningObjective": "Dominar os layers do TCP/IP e suas funções fundamentais.",
                                  "commonMistakes": [
                                    "Confundir TCP/IP (4 layers) com OSI (7 layers)",
                                    "Achar que TCP/IP é só um protocolo, não um modelo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar protocolos chave nos layers de Transporte e Aplicação",
                                  "subSteps": [
                                    "Estude TCP: conexão orientada, garantia de entrega, usado em HTTP/HTTPS.",
                                    "Estude UDP: sem conexão, baixa latência, usado em streaming e jogos.",
                                    "Liste protocolos de aplicação: HTTP (web), FTP (arquivos), DNS (resolução de nomes).",
                                    "Anote como eles 'sobrepoem' TCP/IP (ex: HTTP usa TCP no Transport).",
                                    "Crie uma tabela mapeando protocolo > layer > função."
                                  ],
                                  "verification": "Explique a diferença entre TCP e UDP com um exemplo cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de protocolos TCP/IP",
                                    "Vídeo curto sobre TCP vs UDP (ex: YouTube, 5min)"
                                  ],
                                  "tips": "Pense em TCP como 'carta registrada' (confiável) e UDP como 'jornal arremessado' (rápido, mas pode perder).",
                                  "learningObjective": "Associar protocolos específicos aos layers corretos do TCP/IP.",
                                  "commonMistakes": [
                                    "Achar que UDP é sempre melhor que TCP",
                                    "Confundir HTTP (aplicação) com TCP (transporte)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar aplicações cotidianas do TCP/IP",
                                  "subSteps": [
                                    "Analise navegação web: HTTP/HTTPS sobre TCP para carregar páginas.",
                                    "Analise streaming: UDP para vídeo em tempo real (ex: Netflix, YouTube live).",
                                    "Identifique outros: email (SMTP sobre TCP), jogos online (UDP).",
                                    "Simule acessando sites e pense: 'Qual protocolo está usando TCP/IP aqui?'.",
                                    "Registre 5 exemplos pessoais de uso diário."
                                  ],
                                  "verification": "Cite 3 exemplos reais de aplicações usando TCP/IP com layer correto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Navegador web",
                                    "Ferramenta Wireshark básica ou site whatismyipaddress.com para ver protocolos"
                                  ],
                                  "tips": "Use o developer tools do navegador (F12) para ver requisições HTTP/TCP.",
                                  "learningObjective": "Reconhecer TCP/IP em ações cotidianas da internet.",
                                  "commonMistakes": [
                                    "Ignorar que quase toda internet usa TCP/IP",
                                    "Dizer 'UDP sobre TCP/IP' sem especificar layer"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e expandir conhecimento com cenários práticos",
                                  "subSteps": [
                                    "Crie um fluxograma de uma navegação web: DNS > TCP > HTTP.",
                                    "Debata prós/contras: por que streaming usa UDP não TCP?",
                                    "Pesquise um exemplo avançado: VoIP (Voice over IP) com UDP.",
                                    "Teste-se: explique para um colega ou grave um áudio resumindo.",
                                    "Atualize sua tabela com novos exemplos encontrados."
                                  ],
                                  "verification": "Descreva um cenário completo de aplicação TCP/IP sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para fluxograma",
                                    "Gravador de voz ou parceiro de estudo"
                                  ],
                                  "tips": "Explique como se fosse para uma criança de 10 anos para fixar conceitos.",
                                  "learningObjective": "Aplicar o conhecimento em cenários reais e autoavaliar.",
                                  "commonMistakes": [
                                    "Generalizar demais sem exemplos concretos",
                                    "Esquecer o layer Internet (IP) em todos os fluxos"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao assistir um vídeo no YouTube, o player usa UDP sobre IP para streaming em tempo real (layer Transport/Internet), evitando atrasos de retransmissão do TCP, enquanto o site inicial carrega via HTTP sobre TCP.",
                              "finalVerifications": [
                                "Pode citar pelo menos 4 aplicações cotidianas usando TCP/IP com protocolos corretos?",
                                "Explica a diferença entre uso de TCP e UDP em exemplos reais?",
                                "Lista os 4 layers e associa um protocolo a cada um?",
                                "Identifica corretamente HTTP como aplicação sobre TCP?",
                                "Descreve um fluxo completo de navegação web no modelo TCP/IP?",
                                "Reconhece limitações, como por que streaming prefere UDP?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de layers e protocolos (sem confusões TCP/UDP)",
                                "Quantidade e relevância de exemplos cotidianos (mínimo 3 concretos)",
                                "Clareza na explicação de 'sobreposição' (ex: HTTP sobre TCP/IP)",
                                "Uso correto de terminologia técnica sem erros comuns",
                                "Capacidade de criar fluxogramas ou diagramas lógicos",
                                "Demonstração de compreensão prática via simulações ou testes"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de endereços IP e sub-redes no layer Internet.",
                                "Física: Princípios de transmissão de dados em redes (sinais elétricos/ópticos).",
                                "História: Evolução da internet desde ARPANET até TCP/IP moderno.",
                                "Segurança da Informação: HTTPS como extensão segura de HTTP/TCP.",
                                "Desenvolvimento de Software: Integração de sockets TCP/UDP em programação."
                              ],
                              "realWorldApplication": "Técnicos de rede usam isso para diagnosticar falhas (ex: 'por que o streaming trava? UDP perdido'), desenvolvedores constroem apps cliente-servidor eficientes, e usuários otimizam conexões em home office ou jogos online."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Camadas Básicas do Modelo TCP/IP",
                        "description": "Detalhes introdutórios das camadas de Aplicação, Transporte, Rede e Enlace no contexto da necessidade de protocolos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Descrever camada de Aplicação",
                            "description": "Explicar protocolos de suporte e serviços na camada de aplicação (ex.: HTTP, DNS), focando em interfaces para aplicações usuário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e Função da Camada de Aplicação",
                                  "subSteps": [
                                    "Defina a camada de aplicação no modelo TCP/IP como a camada superior responsável por protocolos que suportam serviços diretamente acessíveis ao usuário.",
                                    "Compare com camadas inferiores (transporte, rede, enlace, física) para destacar seu foco em interfaces de aplicação.",
                                    "Identifique serviços comuns como web, email e resolução de nomes.",
                                    "Estude o diagrama do modelo TCP/IP destacando a posição da camada de aplicação.",
                                    "Anote as responsabilidades principais: formatação de dados para o usuário e abstração de detalhes de rede."
                                  ],
                                  "verification": "Crie um diagrama simples da pilha TCP/IP rotulando a camada de aplicação e liste 3 funções dela.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagrama do modelo TCP/IP (impresso ou online), caderno para anotações, vídeo introdutório sobre TCP/IP (ex: Khan Academy).",
                                  "tips": "Use analogias como 'a camada de aplicação é como o garçom que entrega o pedido diretamente ao cliente'.",
                                  "learningObjective": "Entender o papel e posição da camada de aplicação no modelo TCP/IP.",
                                  "commonMistakes": "Confundir com camada de transporte (foco em dados vs. entrega confiável)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Protocolos Principais da Camada de Aplicação",
                                  "subSteps": [
                                    "Estude o HTTP: defina como protocolo para transferência de hipertexto, métodos (GET, POST), status codes (200, 404).",
                                    "Analise o DNS: explique resolução de nomes de domínio em IP, tipos de registros (A, MX, CNAME).",
                                    "Liste outros protocolos: SMTP para email, FTP para arquivos.",
                                    "Compare HTTP e DNS em termos de statelessness e hierarquia de resolução.",
                                    "Registre exemplos de portas padrão: HTTP (80), HTTPS (443), DNS (53)."
                                  ],
                                  "verification": "Escreva uma tabela comparando HTTP, DNS e SMTP com colunas para função, porta e exemplo de uso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Documentação RFC de HTTP (RFC 2616) e DNS (RFC 1035), ferramentas online como Wireshark demo ou whatsmydns.net.",
                                  "tips": "Memorize com mnemônicos: 'HTTP para páginas, DNS para endereços'.",
                                  "learningObjective": "Identificar e descrever funções de protocolos chave como HTTP e DNS.",
                                  "commonMistakes": "Achar que DNS é camada de transporte; lembre que é aplicação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Interfaces para Aplicações Usuário",
                                  "subSteps": [
                                    "Descreva como protocolos fornecem APIs ou sockets para apps (ex: bibliotecas como requests em Python para HTTP).",
                                    "Simule uma requisição HTTP: cliente envia request, servidor responde com headers e body.",
                                    "Explore resolução DNS: app chama gethostbyname(), DNS resolve domínio.",
                                    "Discuta abstração: app não precisa saber detalhes de IP ou roteamento.",
                                    "Identifique exemplos de apps: navegador usa HTTP/DNS, email client usa SMTP/IMAP."
                                  ],
                                  "verification": "Desenhe um fluxograma de uma navegação web mostrando chamadas HTTP e DNS.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Editor de código simples (VS Code), terminal para comandos como nslookup ou curl http://example.com.",
                                  "tips": "Teste comandos reais no terminal para ver respostas HTTP/DNS ao vivo.",
                                  "learningObjective": "Explicar como a camada de aplicação interfaceia com software usuário.",
                                  "commonMistakes": "Ignorar que interfaces são de alto nível, não binárias de rede."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Aplicar Conhecimentos",
                                  "subSteps": [
                                    "Resuma protocolos e interfaces em um mapa mental.",
                                    "Crie um cenário: 'Navegando example.com' traçando passos de DNS a HTTP.",
                                    "Discuta limitações: HTTP stateless, DNS caching issues.",
                                    "Pesquise variações: HTTP/2, HTTP/3, DNS over HTTPS (DoH).",
                                    "Prepare explicação oral ou escrita para um 'aluno iniciante'."
                                  ],
                                  "verification": "Grave um vídeo de 2 minutos explicando a camada de aplicação com exemplos HTTP/DNS.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramenta de gravação (celular), mapa mental tool (ex: MindMeister free).",
                                  "tips": "Fale em voz alta para praticar clareza e fluidez.",
                                  "learningObjective": "Integrar conceitos para descrever a camada de aplicação de forma coesa.",
                                  "commonMistakes": "Sobrecarregar com detalhes avançados; foque no básico."
                                }
                              ],
                              "practicalExample": "Ao abrir 'www.google.com' no navegador: 1) DNS resolve domínio para IP; 2) HTTP/HTTPS envia GET request para servidor; 3) Servidor retorna página HTML via interface de aplicação, abstraindo rede subjacente.",
                              "finalVerifications": [
                                "Liste e descreva 3 protocolos da camada de aplicação com suas portas.",
                                "Explique diferença entre HTTP request e DNS query.",
                                "Desenhe pilha TCP/IP destacando camada de aplicação.",
                                "Simule resolução de domínio com nslookup.",
                                "Identifique interfaces usadas por um app web (ex: fetch API).",
                                "Compare com camada de transporte (TCP/UDP)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e posição da camada de aplicação (20%)",
                                "Descrição detalhada de protocolos HTTP/DNS (30%)",
                                "Explicação clara de interfaces para apps usuário (20%)",
                                "Uso de exemplos concretos e diagramas (15%)",
                                "Identificação de erros comuns e limitações (10%)",
                                "Clareza e estrutura na comunicação (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de sockets e bibliotecas como requests para HTTP em Python/JavaScript.",
                                "Segurança da Informação: HTTPS, certificados SSL/TLS na camada aplicação.",
                                "Desenvolvimento Web: APIs RESTful baseadas em HTTP.",
                                "Matemática: Árvores de resolução DNS como estruturas hierárquicas."
                              ],
                              "realWorldApplication": "Desenvolvedores web usam HTTP para criar sites interativos; administradores de rede configuram DNS para hospedagem; apps mobile integram SMTP para notificações por email, garantindo comunicação usuário-servidor sem gerenciar rede baixa."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Explicar camada de Transporte",
                            "description": "Detalhar TCP (conexão orientada, confiável) vs. UDP (sem conexão, rápida), e conceitos iniciais de controle de congestionamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introduzir a Camada de Transporte no Modelo TCP/IP",
                                  "subSteps": [
                                    "Explicar a posição da camada de Transporte entre a Camada de Rede e a Camada de Aplicação.",
                                    "Descrever funções principais: segmentação de dados, numeração de segmentos, controle de fluxo e erro.",
                                    "Discutir a importância para comunicação fim-a-fim entre hosts.",
                                    "Identificar protocolos principais: TCP e UDP.",
                                    "Visualizar diagrama do modelo TCP/IP destacando a camada."
                                  ],
                                  "verification": "Criar um diagrama simples da pilha TCP/IP com a camada de Transporte destacada e funções listadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama do modelo TCP/IP (imagem ou software como Draw.io), vídeo introdutório sobre TCP/IP (ex: Khan Academy).",
                                  "tips": "Use analogias como 'correio' para entender fim-a-fim vs hop-by-hop.",
                                  "learningObjective": "Compreender o papel e funções básicas da camada de Transporte.",
                                  "commonMistakes": "Confundir com camada de Rede (que é roteamento, não fim-a-fim)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o Protocolo UDP (User Datagram Protocol)",
                                  "subSteps": [
                                    "Descrever UDP como protocolo sem conexão e não confiável.",
                                    "Listar cabeçalho UDP: portas de origem/destino, comprimento e checksum.",
                                    "Explicar vantagens: baixa sobrecarga, alta velocidade, multicast suportado.",
                                    "Discutir usos: streaming, DNS, VoIP.",
                                    "Simular envio de datagramas UDP sem garantia de entrega."
                                  ],
                                  "verification": "Escrever uma tabela comparando cabeçalho UDP com suas funções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentação RFC 768 (UDP), ferramenta como Wireshark para capturar tráfego UDP.",
                                  "tips": "Pense em UDP como 'carta enviada sem aviso de recebimento'.",
                                  "learningObjective": "Dominar características e aplicações do UDP.",
                                  "commonMistakes": "Achar que UDP garante ordem de pacotes (não garante nada)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Protocolo TCP (Transmission Control Protocol)",
                                  "subSteps": [
                                    "Descrever TCP como protocolo orientado a conexão e confiável.",
                                    "Explicar handshake de 3 vias (SYN, SYN-ACK, ACK).",
                                    "Detalhar mecanismos: controle de erro (checksum, ACKs), controle de fluxo (janela deslizante), reenvio de pacotes perdidos.",
                                    "Listar cabeçalho TCP: portas, sequência, ACK, flags (SYN, FIN, etc.).",
                                    "Discutir usos: HTTP, FTP, e-mail."
                                  ],
                                  "verification": "Desenhar o fluxo de handshake TCP e explicar cada passo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "RFC 793 (TCP), simulador TCP online (ex: TCP Handshake Simulator).",
                                  "tips": "Visualize TCP como 'telefone': conexão estabelecida antes de falar.",
                                  "learningObjective": "Entender os mecanismos de confiabilidade do TCP.",
                                  "commonMistakes": "Ignorar que TCP tem overhead alto devido a ACKs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar TCP e UDP",
                                  "subSteps": [
                                    "Criar tabela de comparação: conexão (sim/não), confiabilidade, velocidade, overhead.",
                                    "Analisar cenários: quando usar TCP (dados críticos) vs UDP (tempo real).",
                                    "Discutir trade-offs: confiabilidade vs latência.",
                                    "Exemplificar com aplicações reais.",
                                    "Testar diferenças capturando tráfego com Wireshark."
                                  ],
                                  "verification": "Preencher e discutir uma tabela de comparação completa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Wireshark, tabela modelo em Excel ou papel.",
                                  "tips": "Lembre: TCP = 'confiável mas lento', UDP = 'rápido mas arriscado'.",
                                  "learningObjective": "Saber escolher protocolo baseado em necessidades.",
                                  "commonMistakes": "Generalizar que TCP é sempre melhor (não para real-time)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Introduzir Conceitos Iniciais de Controle de Congestionamento",
                                  "subSteps": [
                                    "Explicar congestionamento: rede sobrecarregada causa perda de pacotes.",
                                    "Descrever detecção: timeout de ACKs ou duplicados.",
                                    "Apresentar algoritmo simples: Tahoe (slow start, congestion avoidance).",
                                    "Discutir papel no TCP: ajustar taxa de envio dinamicamente.",
                                    "Simular gráfico de janela de congestionamento."
                                  ],
                                  "verification": "Explicar em palavras como TCP reage a congestionamento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos de congestionamento (RFC 5681), simulador ns-3 ou online.",
                                  "tips": "Analogia: dirigir em engarrafamento - reduza velocidade ao ver atrasos.",
                                  "learningObjective": "Compreender basics de controle de congestionamento no TCP.",
                                  "commonMistakes": "Confundir com controle de fluxo (fluxo é receptor, congestionamento é rede)."
                                }
                              ],
                              "practicalExample": "Em um jogo online como Fortnite, UDP envia posições de jogadores rapidamente (aceitando perdas ocasionais para baixa latência), enquanto TCP é usado no login para garantir que credenciais cheguem intactas sem perda.",
                              "finalVerifications": [
                                "Explicar handshake TCP em 3 passos.",
                                "Listar 3 diferenças chave TCP vs UDP.",
                                "Descrever como TCP detecta perda de pacotes.",
                                "Dar 2 exemplos de apps UDP e 2 de TCP.",
                                "Explicar por que UDP é usado em streaming.",
                                "Desenhar janela de congestionamento simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas diferenças TCP/UDP (exatidão >90%).",
                                "Compreensão de confiabilidade e conexão.",
                                "Correta descrição de handshake e congestionamento.",
                                "Uso correto de analogias e exemplos.",
                                "Capacidade de tabela/comparação clara.",
                                "Identificação de aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidades em perda de pacotes e algoritmos de janela.",
                                "Física: Transmissão de sinais e latência em redes.",
                                "Segurança: Controle de erro relaciona-se a criptografia básica.",
                                "Estatística: Análise de throughput e congestionamento."
                              ],
                              "realWorldApplication": "No dia a dia, TCP garante que páginas web carreguem completamente (ex: Google), enquanto UDP acelera chamadas de vídeo no WhatsApp ou streams no YouTube, evitando travamentos por priorizar velocidade sobre perfeição."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Apresentar camada de Rede",
                            "description": "Introduzir protocolo IP, plano de dados, algoritmos de roteamento e conceitos de SDN (Redes Definidas por Software) no plano de controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introduzir o Protocolo IP e Funções da Camada de Rede",
                                  "subSteps": [
                                    "Explicar o papel da camada de rede no modelo TCP/IP como responsável pelo roteamento lógico entre hosts.",
                                    "Descrever endereçamento IP (IPv4 e IPv6) e estrutura dos pacotes IP (header, payload).",
                                    "Discutir serviços como fragmentação, TTL e checksum.",
                                    "Comparar com camada de enlace para destacar diferenças.",
                                    "Realizar diagrama simples de um pacote IP."
                                  ],
                                  "verification": "Criar um diagrama anotado de um pacote IP e explicar suas funções principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Slides sobre modelo TCP/IP, Wireshark para captura de pacotes, quadro branco.",
                                  "tips": "Use analogias como 'endereço postal' para IP para facilitar compreensão.",
                                  "learningObjective": "Compreender as funções fundamentais do protocolo IP na camada de rede.",
                                  "commonMistakes": "Confundir IP com MAC address (camada de enlace)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Plano de Dados e Plano de Controle",
                                  "subSteps": [
                                    "Definir plano de dados: encaminhamento de pacotes baseado em tabelas de roteamento.",
                                    "Definir plano de controle: cálculo e distribuição de rotas entre roteadores.",
                                    "Exemplificar com roteadores tradicionais onde ambos os planos estão acoplados.",
                                    "Discutir vantagens da separação para escalabilidade.",
                                    "Desenhar fluxograma comparativo dos planos."
                                  ],
                                  "verification": "Desenhar e rotular um fluxograma mostrando fluxo de pacotes nos dois planos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagramas de rede, software de simulação como Cisco Packet Tracer.",
                                  "tips": "Pense no plano de dados como 'motorista seguindo GPS' e controle como 'atualizando o GPS'.",
                                  "learningObjective": "Distinguir e exemplificar os planos de dados e controle na camada de rede.",
                                  "commonMistakes": "Achar que plano de controle lida diretamente com dados de usuário."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Algoritmos de Roteamento",
                                  "subSteps": [
                                    "Introduzir roteamento de vetor de distância (ex: RIP) e link-state (ex: OSPF).",
                                    "Explicar métricas como hop count, custo de link e convergência.",
                                    "Comparar algoritmos com exemplos de rede pequena.",
                                    "Mencionar BGP para roteamento interdomínio.",
                                    "Simular roteamento em uma topologia simples."
                                  ],
                                  "verification": "Simular uma rede com 3 roteadores e calcular tabela de roteamento manualmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Packet Tracer ou GNS3, tabelas de roteamento em papel.",
                                  "tips": "Comece com redes pequenas para evitar confusão com loops de roteamento.",
                                  "learningObjective": "Identificar e comparar algoritmos básicos de roteamento.",
                                  "commonMistakes": "Ignorar convergência lenta em RIP para redes grandes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Apresentar Conceitos de SDN no Plano de Controle",
                                  "subSteps": [
                                    "Definir SDN: separação programável de plano de controle do data plane via OpenFlow.",
                                    "Explicar controlador SDN centralizado e switches como forwarders.",
                                    "Discutir benefícios: automação, segurança e escalabilidade.",
                                    "Comparar SDN com redes tradicionais.",
                                    "Explorar arquitetura: Application, Control, Data layers."
                                  ],
                                  "verification": "Descrever um cenário SDN resolvendo um problema de roteamento tradicional.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Vídeos sobre Mininet/SDN, documentação OpenFlow.",
                                  "tips": "Use exemplos de data centers como Google B4 para ilustrar impacto real.",
                                  "learningObjective": "Compreender SDN como evolução da camada de rede.",
                                  "commonMistakes": "Confundir SDN com virtualização de rede (NFV)."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 5 departamentos, configure roteadores usando OSPF para roteamento interno e SDN controller para políticas dinâmicas de tráfego, simulando no Packet Tracer: envie pacotes IP de um host A para B, observe TTL decrementar e rotas atualizadas via controlador.",
                              "finalVerifications": [
                                "Explicar corretamente as funções do protocolo IP.",
                                "Diferenciar plano de dados de plano de controle com exemplo.",
                                "Listar e comparar dois algoritmos de roteamento.",
                                "Descrever arquitetura SDN e um benefício.",
                                "Montar diagrama completo da camada de rede.",
                                "Simular roteamento simples sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (IP, planos, roteamento, SDN).",
                                "Capacidade de diagramação e visualização.",
                                "Compreensão de interdependências entre conceitos.",
                                "Aplicação em simulações práticas.",
                                "Identificação de erros comuns e soluções.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grafos e algoritmos de caminho mais curto (Dijkstra em OSPF).",
                                "Física: Propagação de sinais em meios físicos suportando IP.",
                                "Segurança da Informação: IPSec na camada de rede.",
                                "Administração: Otimização de redes para negócios via SDN."
                              ],
                              "realWorldApplication": "Na internet global, BGP roteia tráfego entre ISPs usando IP; em data centers como AWS, SDN controla fluxos dinâmicos para balanceamento de carga, reduzindo latência em serviços de streaming como Netflix."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.4",
                            "name": "Mencionar camada de Enlace",
                            "description": "Descrever padrões IEEE 802 (ex.: Ethernet) para comunicação ponto a ponto em redes locais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito e funções da Camada de Enlace",
                                  "subSteps": [
                                    "Identificar a posição da Camada de Enlace no modelo TCP/IP (equivalente à camada de enlace de dados no OSI).",
                                    "Listar funções principais: enquadramento, controle de acesso ao meio (MAC), detecção e correção de erros.",
                                    "Explicar diferenciação da Camada Física (bits crus) e Camada de Rede (roteamento).",
                                    "Desenhar um diagrama simples do fluxo de dados na camada.",
                                    "Relacionar com protocolos como ARP para resolução de endereços."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo as funções e posição da camada, sem erros conceituais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama do modelo TCP/IP (impresso ou online)",
                                    "Vídeo introdutório sobre modelo TCP/IP (ex.: Khan Academy)"
                                  ],
                                  "tips": "Use analogias como 'envelope' para enquadramento de dados.",
                                  "learningObjective": "Dominar as responsabilidades fundamentais da Camada de Enlace.",
                                  "commonMistakes": "Confundir com roteamento (função da Camada de Rede) ou transmissão física pura."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os padrões IEEE 802",
                                  "subSteps": [
                                    "Definir IEEE 802 como família de padrões para redes locais (LAN) e metropolitanas (MAN).",
                                    "Listar exemplos principais: 802.3 (Ethernet), 802.11 (Wi-Fi), 802.15 (Bluetooth).",
                                    "Explicar subcamada LLC (Logical Link Control) e MAC (Media Access Control).",
                                    "Pesquisar história breve: origem nos anos 80 para padronizar LANs.",
                                    "Comparar com outros padrões não-IEEE."
                                  ],
                                  "verification": "Criar uma tabela comparativa de 3 padrões IEEE 802 com suas aplicações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Página da Wikipedia sobre IEEE 802",
                                    "Documentação oficial IEEE (resumo PDF)"
                                  ],
                                  "tips": "Foquem em MAC para controle de acesso em meios compartilhados.",
                                  "learningObjective": "Entender a estrutura e propósito da família IEEE 802.",
                                  "commonMistakes": "Achar que IEEE 802 é só Ethernet; é uma família ampla."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o padrão Ethernet (IEEE 802.3) em detalhes",
                                  "subSteps": [
                                    "Descrever formato do frame Ethernet: préambulo, endereços MAC, tipo/length, dados, CRC.",
                                    "Explicar CSMA/CD para detecção de colisões em redes half-duplex.",
                                    "Discutir velocidades modernas: 10/100/1000 Mbps, full-duplex em switches.",
                                    "Analisar endereços MAC: 48 bits, OUI + NIC.",
                                    "Simular envio de um frame entre dois hosts."
                                  ],
                                  "verification": "Desenhar e rotular um frame Ethernet completo com exemplo de dados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online (ex.: draw.io)",
                                    "Simulador Wireshark para captura de pacotes Ethernet"
                                  ],
                                  "tips": "Memorize campos obrigatórios do frame para visualização rápida.",
                                  "learningObjective": "Conhecer a estrutura e operação do Ethernet como exemplo chave.",
                                  "commonMistakes": "Ignorar CRC como mera soma; é um polinômio para detecção robusta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar comunicação ponto a ponto em redes locais",
                                  "subSteps": [
                                    "Definir comunicação ponto a ponto vs. broadcast em LANs.",
                                    "Explicar como Ethernet usa MAC para direcionar frames em switches (tabela CAM).",
                                    "Discutir topologias: estrela com switches para evitar colisões.",
                                    "Relacionar com protocolos de rede local: VLANs, STP para loops.",
                                    "Testar conceitualmente uma troca de frames entre dois PCs conectados."
                                  ],
                                  "verification": "Descrever em diagrama o fluxo de um pacote de PC1 para PC2 em uma LAN Ethernet.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de rede LAN simples",
                                    "Tutorial sobre switches vs. hubs"
                                  ],
                                  "tips": "Pense em switches como 'correios inteligentes' que aprendem MACs.",
                                  "learningObjective": "Aplicar conceitos em cenários de comunicação local real.",
                                  "commonMistakes": "Confundir ponto a ponto com unicast; ponto a ponto é físico direto."
                                }
                              ],
                              "practicalExample": "Conecte dois computadores via cabo Ethernet crossover (ou switch). Use Wireshark para capturar e analisar um ping: identifique o frame Ethernet com endereços MAC origem/destino, verifique CRC e confirme comunicação ponto a ponto sem colisões em full-duplex.",
                              "finalVerifications": [
                                "Explicar verbalmente as funções da Camada de Enlace em 1 minuto.",
                                "Desenhar corretamente um frame Ethernet com todos os campos.",
                                "Listar 3 padrões IEEE 802 e suas aplicações.",
                                "Diferenciar comunicação ponto a ponto de broadcast em LAN.",
                                "Simular em papel o fluxo de dados em uma rede local simples.",
                                "Identificar erros em um frame Ethernet malformado."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: uso correto de termos como MAC, frame, CRC.",
                                "Completude: cobertura de todos os elementos chave (funções, padrões, Ethernet).",
                                "Clareza na explicação: diagramas legíveis e descrições concisas.",
                                "Aplicação prática: ligação com exemplos reais de LANs.",
                                "Profundidade: inclusão de detalhes como CSMA/CD e full-duplex.",
                                "Originalidade: evitar cópias literais; demonstrar compreensão."
                              ],
                              "crossCurricularConnections": [
                                "Física: Transmissão de sinais elétricos e ópticos em cabos Ethernet.",
                                "Matemática: Cálculo de checksums CRC com polinômios.",
                                "Eletrônica: Entendimento de hardware como NICs e switches.",
                                "Segurança da Informação: Detecção de erros e prevenção de colisões."
                              ],
                              "realWorldApplication": "Em redes domésticas e empresariais, Ethernet (IEEE 802.3) habilita comunicação ponto a ponto em LANs para streaming, compartilhamento de arquivos e internet via switches Gigabit, formando a base de data centers e infraestruturas de TI globais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Nível de Aplicação: Protocolos de Suporte e Serviços",
                    "description": "Protocolos que fornecem suporte e serviços no nível de aplicação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Protocolos de Suporte no Nível de Aplicação",
                        "description": "Protocolos que oferecem serviços essenciais de suporte para o funcionamento de aplicações, como resolução de nomes de domínio e configuração dinâmica de endereços IP, permitindo que outros protocolos e serviços operem corretamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "DNS (Domain Name System)",
                            "description": "Compreender o funcionamento do protocolo DNS, incluindo sua hierarquia de servidores (raiz, TLD, autoritativos), o processo de resolução de nomes (recursivo e iterativo) e sua importância para traduzir nomes legíveis em endereços IP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a hierarquia de servidores DNS",
                                  "subSteps": [
                                    "Estude os servidores raiz (root servers): identificadores . (ponto) e sua função de direcionar para TLDs.",
                                    "Analise os servidores TLD (Top-Level Domain): gerenciam domínios como .com, .br, .org.",
                                    "Explore os servidores autoritativos: armazenam registros DNS específicos para um domínio.",
                                    "Entenda o fluxo hierárquico: do root -> TLD -> autoritativo.",
                                    "Identifique caches locais em resolvers (como no seu roteador ou ISP)."
                                  ],
                                  "verification": "Desenhe um diagrama da hierarquia DNS e explique o caminho para resolver 'exemplo.com'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama em branco",
                                    "Documentação IETF RFC 1034/1035",
                                    "Vídeo explicativo sobre DNS hierarchy"
                                  ],
                                  "tips": "Use analogia de uma árvore genealógica para visualizar a hierarquia.",
                                  "learningObjective": "Identificar e descrever os três níveis principais da hierarquia DNS.",
                                  "commonMistakes": [
                                    "Confundir servidores raiz com TLDs.",
                                    "Ignorar o papel do cache local no processo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o processo de resolução recursiva",
                                  "subSteps": [
                                    "Explique como o resolver do cliente envia query completa ao servidor DNS local.",
                                    "Descreva o servidor local consultando root, depois TLD, depois autoritativo recursivamente.",
                                    "Analise a resposta final com o IP sendo retornada ao cliente.",
                                    "Discuta o preenchimento do cache em cada servidor intermediário.",
                                    "Simule com um exemplo: resolver 'www.google.com' via recursivo."
                                  ],
                                  "verification": "Simule verbalmente ou em papel o caminho recursivo para um domínio dado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta online de simulação DNS (dnsviz.net)",
                                    "Papel e caneta para fluxograma"
                                  ],
                                  "tips": "Pense no recursivo como 'delegar tudo para o próximo servidor'.",
                                  "learningObjective": "Descrever o fluxo completo de resolução recursiva passo a passo.",
                                  "commonMistakes": [
                                    "Achar que o cliente faz todas as consultas.",
                                    "Esquecer o papel do cache na redução de latência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar o processo de resolução iterativa",
                                  "subSteps": [
                                    "Entenda o resolver consultando root e recebendo referral para TLD.",
                                    "Continue iterativamente: TLD refere para autoritativo, que responde com IP.",
                                    "Compare com recursivo: cliente ou resolver faz todas as queries.",
                                    "Exemplo prático: use flag +trace no dig para ver iteração.",
                                    "Discuta quando usar iterativo (ferramentas de diagnóstico)."
                                  ],
                                  "verification": "Execute 'dig +trace exemplo.com' e interprete o output iterativo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Terminal com dig instalado",
                                    "Comando nslookup (alternativa)"
                                  ],
                                  "tips": "Iterativo é como 'perguntar um por um' em uma cadeia de contatos.",
                                  "learningObjective": "Diferenciar e demonstrar resolução iterativa via ferramenta.",
                                  "commonMistakes": [
                                    "Confundir referral com resposta final.",
                                    "Não usar ferramentas para validar."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar a importância do DNS e aplicações práticas",
                                  "subSteps": [
                                    "Discuta tradução de nomes legíveis (google.com) para IPs numéricos.",
                                    "Analise impacto na internet: sem DNS, só IPs diretos.",
                                    "Estude tipos de registros: A, CNAME, MX, NS.",
                                    "Pratique queries: dig google.com A, dig google.com MX.",
                                    "Reflita sobre falhas: o que acontece se DNS falha?"
                                  ],
                                  "verification": "Resolva 3 domínios diferentes e liste tipos de registros retornados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Terminal Linux/Windows/Mac",
                                    "Site whatsmydns.net para testes globais"
                                  ],
                                  "tips": "Sempre teste com domínios reais para fixar conceitos.",
                                  "learningObjective": "Explicar o papel crítico do DNS na navegação web.",
                                  "commonMistakes": [
                                    "Subestimar dependência diária do DNS.",
                                    "Ignorar registros além de A (como MX para email)."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o comando 'dig +trace www.exemplo.com' no terminal, observe o processo iterativo: root refere para TLD .com, TLD para autoritativo de exemplo.com, que retorna o IP 93.184.216.34. Isso simula resolução real em tempo real.",
                              "finalVerifications": [
                                "Desenhar e rotular diagrama completo da hierarquia DNS.",
                                "Explicar diferenças entre recursivo e iterativo com exemplos.",
                                "Executar dig/nslookup para 5 domínios e interpretar resultados.",
                                "Listar 3 tipos de registros DNS e seus usos.",
                                "Descrever impacto de falha DNS em serviços web/email."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da hierarquia (root/TLD/autoritativo).",
                                "Correta distinção entre resoluções recursiva e iterativa.",
                                "Uso correto de ferramentas como dig com flags apropriadas.",
                                "Compreensão de registros DNS e caches.",
                                "Explicação clara da importância para a internet moderna.",
                                "Capacidade de troubleshooting básico (ex: TTL, NXDOMAIN)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: DNSSEC e ataques como spoofing/DNS amplification.",
                                "Programação: Implementar cliente DNS simples em Python (socket library).",
                                "História da Computação: Evolução do DNS desde ARPANET.",
                                "Matemática: Árvores e grafos para modelar hierarquia DNS."
                              ],
                              "realWorldApplication": "O DNS permite acessar sites como 'google.com' em vez de memorizar IPs como 142.250.190.14; é essencial para navegação web, emails (MX records), load balancing (CNAME) e serviços como Netflix/Spotify que dependem de resoluções rápidas e em cache."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "DHCP (Dynamic Host Configuration Protocol)",
                            "description": "Explicar o protocolo DHCP, seu processo DORA (Discover, Offer, Request, Acknowledgment), atribuição dinâmica de endereços IP, máscaras de sub-rede, gateways e servidores DNS, e seu papel na configuração automática de hosts em redes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos do DHCP",
                                  "subSteps": [
                                    "Defina o que é DHCP e sua função principal na alocação dinâmica de endereços IP.",
                                    "Compare DHCP com configuração estática de IP, destacando vantagens como escalabilidade e redução de erros humanos.",
                                    "Identifique os componentes principais: Cliente DHCP, Servidor DHCP e Relay Agent.",
                                    "Estude a porta UDP utilizada (67 para servidor, 68 para cliente) e o escopo de leases.",
                                    "Revise a RFC 2131 para fundamentos oficiais do protocolo."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos básicos e liste 3 vantagens do DHCP sobre IP estático.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 2131",
                                    "Vídeo tutorial introdutório sobre DHCP (YouTube ou Khan Academy)",
                                    "Notas em um editor de texto"
                                  ],
                                  "tips": "Use analogias como 'DHCP é como um bibliotecário alocando números de catálogo automaticamente'.",
                                  "learningObjective": "Compreender o propósito e componentes fundamentais do DHCP.",
                                  "commonMistakes": [
                                    "Confundir DHCP com DNS",
                                    "Achar que DHCP é apenas para endereços IP, ignorando outros parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o Processo DORA",
                                  "subSteps": [
                                    "Explique a fase Discover: Cliente envia broadcast UDP para encontrar servidores DHCP.",
                                    "Descreva a fase Offer: Servidor responde com proposta de IP e parâmetros.",
                                    "Detalhe a fase Request: Cliente seleciona uma oferta e faz broadcast de solicitação.",
                                    "Aborde a fase Acknowledgment: Servidor confirma a alocação com lease time.",
                                    "Simule o fluxo DORA com um diagrama desenhado à mão ou ferramenta como draw.io."
                                  ],
                                  "verification": "Desenhe e rotule um diagrama do processo DORA, indicando mensagens e broadcasts.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (draw.io ou papel e caneta)",
                                    "Wireshark para capturar tráfego real (opcional)",
                                    "Simulador de rede como Cisco Packet Tracer"
                                  ],
                                  "tips": "Lembre-se: DORA é broadcast-heavy na Discover/Request para garantir descoberta em redes desconhecidas.",
                                  "learningObjective": "Mapear sequencialmente o handshake DORA e seus broadcasts.",
                                  "commonMistakes": [
                                    "Inverter Offer e Request",
                                    "Esquecer que Acknowledgment é unicast"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Parâmetros DHCP: IP, Máscara, Gateway e DNS",
                                  "subSteps": [
                                    "Configure um pool de IPs em um servidor DHCP simulado (ex: isc-dhcp-server ou roteador virtual).",
                                    "Defina máscara de sub-rede, gateway padrão (default router) e servidores DNS nas opções DHCP.",
                                    "Entenda opções DHCP: option routers (gateway), option domain-name-servers (DNS), subnet-mask.",
                                    "Teste atribuição em um cliente virtual, verificando ipconfig/ifconfig.",
                                    "Ajuste lease time e reserve IPs por MAC address (DHCP reservation)."
                                  ],
                                  "verification": "Configure um servidor DHCP em Packet Tracer e obtenha IP dinâmico em um cliente.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Cisco Packet Tracer ou GNS3",
                                    "VM com Ubuntu para isc-dhcp-server",
                                    "Documentação de configuração do servidor DHCP"
                                  ],
                                  "tips": "Sempre especifique o range de IPs dentro da sub-rede para evitar conflitos.",
                                  "learningObjective": "Implementar configuração prática de parâmetros essenciais no DHCP.",
                                  "commonMistakes": [
                                    "Configurar gateway fora da sub-rede",
                                    "Ignorar broadcast relay em sub-redes múltiplas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação, Troubleshooting e Melhores Práticas",
                                  "subSteps": [
                                    "Use comandos como ipconfig /renew, dhclient para forçar renovação de lease.",
                                    "Capture pacotes com Wireshark filtrando bootp para diagnosticar falhas DORA.",
                                    "Identifique problemas comuns: pool esgotado, relay mal configurado, conflitos de IP.",
                                    "Implemente segurança: DHCP snooping em switches para prevenir rogue servers.",
                                    "Documente um checklist de troubleshooting para cenários reais."
                                  ],
                                  "verification": "Simule uma falha (ex: servidor off) e resolva usando Wireshark e comandos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Cisco Packet Tracer com múltiplos dispositivos",
                                    "Checklist de troubleshooting em PDF"
                                  ],
                                  "tips": "Ative logging no servidor DHCP para auditoria de leases.",
                                  "learningObjective": "Diagnosticar e resolver issues comuns em implantações DHCP.",
                                  "commonMistakes": [
                                    "Não filtrar corretamente em Wireshark (use 'bootp')",
                                    "Confundir lease expired com IP conflict"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório com Cisco Packet Tracer: Configure um roteador como servidor DHCP para uma LAN com 10 PCs. Defina pool 192.168.1.100-200/24, gateway 192.168.1.1 e DNS 8.8.8.8. Ligue um PC, verifique ipconfig e capture DORA com simulação de PDU.",
                              "finalVerifications": [
                                "Explicar verbalmente o processo DORA sem erros.",
                                "Configurar servidor DHCP fornecendo IP, máscara, gateway e DNS a um cliente.",
                                "Diagnosticar falha em renovação de lease usando Wireshark.",
                                "Listar 3 opções DHCP comuns e seus propósitos.",
                                "Demonstrar reserva de IP por MAC address.",
                                "Desenhar diagrama de DHCP relay em rede segmentada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do processo DORA (100% das fases corretas).",
                                "Sucesso na configuração prática (cliente obtém todos os parâmetros corretos).",
                                "Identificação correta de pelo menos 3 problemas comuns e soluções.",
                                "Diagrama claro e rotulado do fluxo DHCP.",
                                "Explicação de segurança (ex: snooping) em contexto real.",
                                "Tempo de conclusão dentro dos estimados com qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de sub-redes e ranges de IP (aritmética binária).",
                                "Segurança da Informação: Prevenção de ataques rogue DHCP.",
                                "Administração de Sistemas: Integração com Active Directory e DNS dinâmico.",
                                "Engenharia de Software: Automação de configuração via scripts (Ansible para DHCP).",
                                "Física: Ondas de rádio em Wi-Fi com DHCP para IoT."
                              ],
                              "realWorldApplication": "Em empresas, DHCP automatiza configuração de milhares de dispositivos em escritórios, data centers e ISPs residenciais, reduzindo tempo de setup e erros; ex: rede corporativa com VLANs usando relays para centralizar servidores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Identificar Aplicações de Protocolos de Suporte",
                            "description": "Reconhecer cenários onde DNS e DHCP são utilizados, diferenciando falhas de resolução de nomes de problemas de configuração IP, e descrever impactos em redes sem esses protocolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de DNS e DHCP",
                                  "subSteps": [
                                    "Estude a definição de DNS: Domain Name System, que traduz nomes de domínio em endereços IP.",
                                    "Estude a definição de DHCP: Dynamic Host Configuration Protocol, que atribui IPs automaticamente a dispositivos.",
                                    "Identifique funções principais: DNS para resolução de nomes, DHCP para configuração dinâmica de rede.",
                                    "Revise exemplos iniciais: DNS em navegação web, DHCP em conexões Wi-Fi automáticas.",
                                    "Anote diferenças fundamentais entre os dois protocolos."
                                  ],
                                  "verification": "Resuma em um parágrafo as funções de DNS e DHCP, confirmando com uma fonte confiável como documentação Cisco.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial DNS/DHCP (RFCs ou sites como Cisco Networking Academy)",
                                    "Vídeos introdutórios no YouTube (5-10 min)"
                                  ],
                                  "tips": "Use mnemônicos: DNS = 'Nomes para Números', DHCP = 'IPs Dinâmicos Automáticos'.",
                                  "learningObjective": "Dominar definições e papéis fundamentais dos protocolos.",
                                  "commonMistakes": [
                                    "Confundir DNS com DHCP",
                                    "Achar que DNS atribui IPs",
                                    "Ignorar o escopo de rede local vs. global"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Cenários de Aplicação de DNS e DHCP",
                                  "subSteps": [
                                    "Liste cenários DNS: acesso a sites (ex: google.com), e-mails, serviços cloud.",
                                    "Liste cenários DHCP: boot de laptops em rede corporativa, smartphones em Wi-Fi doméstico.",
                                    "Crie um diagrama simples mostrando fluxo DNS (cliente -> resolvedor -> servidor raiz).",
                                    "Crie um diagrama DHCP (Discover -> Offer -> Request -> ACK).",
                                    "Simule cenários em um ambiente virtual como Wireshark ou simulador."
                                  ],
                                  "verification": "Desenhe e explique dois diagramas de cenários, um para cada protocolo, para um colega ou gravando vídeo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io ou papel)",
                                    "Simulador Packet Tracer ou GNS3 gratuito"
                                  ],
                                  "tips": "Pense em 'todos os dias': DNS para navegar, DHCP para conectar sem configurar manualmente.",
                                  "learningObjective": "Reconhecer contextos reais onde cada protocolo é essencial.",
                                  "commonMistakes": [
                                    "Limitar DNS só a internet",
                                    "Esquecer DHCP em redes cabeadas",
                                    "Não considerar falhas em cenários híbridos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Falhas de Resolução de Nomes de Problemas de Configuração IP",
                                  "subSteps": [
                                    "Analise falhas DNS: 'Nome não resolvido' - teste ping por IP funciona, mas nome falha.",
                                    "Analise falhas DHCP: Sem IP atribuído - 'IP inválido' ou APIPA (169.x.x.x).",
                                    "Pratique troubleshooting: Use comandos nslookup (DNS) vs. ipconfig/release-renew (DHCP).",
                                    "Crie tabela comparativa: Sintomas, comandos de diagnóstico, soluções iniciais.",
                                    "Teste em ambiente simulado: Desative DNS e observe vs. desative DHCP."
                                  ],
                                  "verification": "Execute testes em simulador e registre logs de falhas diferenciadas em relatório.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Comandos de terminal (Windows/Linux: nslookup, ipconfig, dhclient)",
                                    "Wireshark para captura de pacotes"
                                  ],
                                  "tips": "Regra: Se IP ok mas nome falha = DNS; Se sem IP = DHCP.",
                                  "learningObjective": "Diagnosticar precisamente tipos de falhas baseadas em sintomas.",
                                  "commonMistakes": [
                                    "Confundir cache DNS com falha DHCP",
                                    "Ignorar firewall em testes",
                                    "Não testar ping IP primeiro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever Impactos em Redes sem DNS e DHCP",
                                  "subSteps": [
                                    "Descreva rede sem DNS: Necessidade de IPs manuais para tudo, impossível navegar por nomes.",
                                    "Descreva rede sem DHCP: Configuração manual de IPs em cada dispositivo, escalabilidade zero.",
                                    "Quantifique impactos: Tempo gasto, erros humanos, downtime em grandes redes.",
                                    "Simule rede manual vs. automatizada e compare eficiência.",
                                    "Escreva relatório de 200 palavras sobre consequências em cenários realistas."
                                  ],
                                  "verification": "Apresente relatório com simulações, destacando métricas como tempo de configuração.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha para comparações (Excel/Google Sheets)",
                                    "Simulador de rede"
                                  ],
                                  "tips": "Pense em escala: 10 PCs ok manual, 1000 impossível sem automação.",
                                  "learningObjective": "Avaliar dependências e riscos de ausência dos protocolos.",
                                  "commonMistakes": [
                                    "Subestimar impacto em redes pequenas",
                                    "Confundir com outros protocolos como ARP",
                                    "Não considerar custos operacionais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 50 computadores, um funcionário não acessa 'intranet.empresa.com', mas ping 192.168.1.10 funciona: falha DNS (servidor indisponível). Outro PC mostra 'Sem conexão de rede' e IP 169.254.x.x: falha DHCP (servidor não responde). Sem DNS, todos usam IPs manuais (lento); sem DHCP, configuração manual leva horas e gera conflitos.",
                              "finalVerifications": [
                                "Explique verbalmente 3 cenários de uso de DNS e DHCP.",
                                "Diferencie falhas com exemplos de comandos de diagnóstico.",
                                "Descreva 4 impactos sem os protocolos em uma rede de 100 dispositivos.",
                                "Simule uma falha em ferramenta e resolva.",
                                "Crie tabela comparativa precisa.",
                                "Responda quiz de 10 perguntas com 90% acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários (80% cobertura).",
                                "Clareza na diferenciação de falhas (com exemplos concretos).",
                                "Profundidade na análise de impactos (quantitativa e qualitativa).",
                                "Uso correto de terminologia técnica.",
                                "Criatividade em diagramas e simulações.",
                                "Completude do relatório (todos elementos presentes)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Vulnerabilidades em DNS (DNS spoofing) e DHCP (rogue servers).",
                                "Administração de Sistemas: Configuração de servidores DNS/DHCP em Linux/Windows.",
                                "Matemática: Cálculos de sub-redes e pools de IPs em DHCP.",
                                "Lógica de Programação: Scripts para automação de testes DHCP/DNS."
                              ],
                              "realWorldApplication": "Profissionais de TI usam isso diariamente para troubleshooting em helpdesks, configurando redes em empresas, data centers ou provedores de internet, reduzindo tempo de inatividade e custos operacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Protocolos de Serviços no Nível de Aplicação",
                        "description": "Protocolos que fornecem serviços diretamente acessados pelos usuários finais, como navegação web, transferência de arquivos e envio de e-mails, operando sobre o transporte TCP ou UDP.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "HTTP e HTTPS",
                            "description": "Descrever o protocolo HTTP (HyperText Transfer Protocol), métodos (GET, POST), códigos de status (200, 404), persistência de conexões e a segurança adicionada pelo HTTPS com TLS/SSL.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Protocolo HTTP",
                                  "subSteps": [
                                    "Pesquisar a definição oficial de HTTP como protocolo de aplicação para transferência de hipertexto.",
                                    "Identificar sua operação no nível de aplicação do modelo TCP/IP.",
                                    "Explicar o fluxo cliente-servidor: requisição, resposta e stateless nature.",
                                    "Diferenciar componentes de uma URL (scheme, host, path, query).",
                                    "Visualizar uma requisição HTTP básica em diagrama."
                                  ],
                                  "verification": "Diagramar e descrever verbalmente uma requisição HTTP completa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs - HTTP Overview",
                                    "Vídeo introdutório sobre protocolos web (YouTube)",
                                    "Bloco de notas para diagramas"
                                  ],
                                  "tips": [
                                    "HTTP é stateless: cada requisição é independente.",
                                    "Use analogia de pedido em restaurante para cliente-servidor."
                                  ],
                                  "learningObjective": "Entender o papel e estrutura básica do HTTP na comunicação web.",
                                  "commonMistakes": [
                                    "Confundir HTTP com HTML (linguagem vs protocolo)",
                                    "Acreditar que HTTP mantém estado entre requisições"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Métodos HTTP e Códigos de Status",
                                  "subSteps": [
                                    "Listar e descrever métodos principais: GET (leitura idempotente), POST (criação não-idempotente), PUT (atualização), DELETE (remoção).",
                                    "Explicar idempotência e segurança de métodos.",
                                    "Memorizar e categorizar códigos de status: 2xx (sucesso, ex: 200 OK), 4xx (erro cliente, ex: 404 Not Found), 5xx (erro servidor, ex: 500).",
                                    "Testar métodos GET e POST usando ferramentas de linha de comando ou DevTools.",
                                    "Analisar respostas reais de sites públicos."
                                  ],
                                  "verification": "Executar requisições GET e POST com curl e interpretar status codes corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "curl ou wget instalado",
                                    "Browser com DevTools (F12 > Network)",
                                    "Postman gratuito"
                                  ],
                                  "tips": [
                                    "GET para dados, POST para envios sensíveis.",
                                    "Sempre cheque headers em respostas."
                                  ],
                                  "learningObjective": "Dominar métodos HTTP comuns e interpretação de códigos de status.",
                                  "commonMistakes": [
                                    "Usar POST para buscas simples (use GET)",
                                    "Confundir 404 (não encontrado) com 500 (erro servidor)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Persistência de Conexões no HTTP",
                                  "subSteps": [
                                    "Comparar HTTP/1.0 (conexões curtas por requisição) vs HTTP/1.1 (keep-alive por default).",
                                    "Explicar header Connection: keep-alive e seu papel na reutilização de TCP sockets.",
                                    "Discutir HTTP pipelining e seus benefícios em performance (menos latência).",
                                    "Identificar limitações como HOL blocking e transição para HTTP/2.",
                                    "Observar headers em tráfego real via DevTools."
                                  ],
                                  "verification": "Identificar e explicar headers de persistência em uma resposta HTTP/1.1 real.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Browser DevTools (aba Network)",
                                    "Documentação HTTP/1.1 RFC 2616 (seção keep-alive)",
                                    "Site de teste como httpbin.org"
                                  ],
                                  "tips": [
                                    "Persistência reduz overhead de handshakes TCP.",
                                    "HTTP/2 multiplexa para melhor eficiência."
                                  ],
                                  "learningObjective": "Compreender como persistência otimiza conexões HTTP.",
                                  "commonMistakes": [
                                    "Achar que HTTP/1.0 tem keep-alive por default",
                                    "Ignorar que pipelining pode causar bloqueios"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender a Segurança do HTTPS com TLS/SSL",
                                  "subSteps": [
                                    "Explicar vulnerabilidades do HTTP: eavesdropping e man-in-the-middle.",
                                    "Descrever handshake TLS: ClientHello, ServerHello, troca de certificados e chaves assimétricas para sessão simétrica.",
                                    "Diferenciar SSL (obsoleto) de TLS (atual padrão).",
                                    "Verificar certificados em browsers (cadeia de confiança CA).",
                                    "Comparar requisições HTTP vs HTTPS usando ferramentas e observar diferenças."
                                  ],
                                  "verification": "Descrever o handshake TLS passo a passo e identificar diferenças em tráfego criptografado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Site badssl.com para testes HTTPS",
                                    "Wireshark (demo básica)",
                                    "Documentação Mozilla TLS"
                                  ],
                                  "tips": [
                                    "HTTPS usa porta 443 vs 80 do HTTP.",
                                    "Certificados auto-assinados são para dev, não produção."
                                  ],
                                  "learningObjective": "Dominar os benefícios e mecanismo de segurança do HTTPS.",
                                  "commonMistakes": [
                                    "Pensar que HTTPS previne todos ataques (não autenticação falha)",
                                    "Confundir criptografia com autenticação"
                                  ]
                                },
                                {
                                  "practicalExample": "Use curl para uma requisição GET: `curl -v http://httpbin.org/get` (observe status 200 e headers). Em seguida, POST: `curl -X POST -d '{\"key\":\"value\"}' http://httpbin.org/post`. Compare com HTTPS: `curl -v https://httpbin.org/get` e note handshake TLS. Analise persistência via múltiplas requisições no mesmo socket.",
                                  "finalVerifications": [
                                    "Descrever corretamente pelo menos 4 métodos HTTP e seus usos.",
                                    "Explicar 5 códigos de status com exemplos.",
                                    "Diferenciar persistência em HTTP/1.1 vs 1.0.",
                                    "Desenhar fluxo de handshake TLS/SSL.",
                                    "Identificar quando usar HTTPS vs HTTP."
                                  ],
                                  "assessmentCriteria": [
                                    "Precisão conceitual e terminologia técnica (30%).",
                                    "Capacidade de exemplos práticos e testes (25%).",
                                    "Compreensão de segurança e persistência (20%).",
                                    "Integração de todos conceitos em explicação coesa (15%).",
                                    "Identificação de erros comuns e soluções (10%)."
                                  ],
                                  "crossCurricularConnections": [
                                    "Segurança da Informação: Criptografia assimétrica e certificados digitais.",
                                    "Desenvolvimento Web: Construção de APIs RESTful.",
                                    "Redes de Computadores: Camadas TCP/IP e sockets.",
                                    "Matemática: Algoritmos de chave pública (RSA).",
                                    "Ética Digital: Privacidade e proteção de dados."
                                  ],
                                  "realWorldApplication": "HTTPS é essencial para e-commerce (compras seguras), banking apps e APIs públicas (ex: Google Maps, Twitter API), prevenindo roubo de dados em Wi-Fi públicas e garantindo confiança em comunicações web."
                                }
                              ]
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "SMTP, POP3 e IMAP",
                            "description": "Explicar SMTP para envio de e-mails, POP3 para download e exclusão de mensagens, e IMAP para acesso remoto sincronizado, incluindo portas padrão (25, 110, 143) e fluxos de operação básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos dos Protocolos de Email",
                                  "subSteps": [
                                    "Identifique o papel dos protocolos no modelo TCP/IP, especificamente no nível de aplicação.",
                                    "Diferencie cliente e servidor em comunicações de email.",
                                    "Descreva o fluxo geral de envio e recebimento de emails.",
                                    "Liste os protocolos principais: SMTP, POP3 e IMAP.",
                                    "Explique por que múltiplos protocolos são necessários para email completo."
                                  ],
                                  "verification": "Resuma em um diagrama simples os papéis de cada protocolo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do modelo TCP/IP",
                                    "Documentação RFC 5321 (SMTP), RFC 1939 (POP3), RFC 3501 (IMAP)"
                                  ],
                                  "tips": "Use analogias como 'correio postal' para envio (SMTP) e 'caixa de correio' para recebimento (POP3/IMAP).",
                                  "learningObjective": "Compreender o ecossistema de protocolos de email e suas interdependências.",
                                  "commonMistakes": [
                                    "Confundir SMTP com protocolos de recebimento",
                                    "Ignorar que SMTP é apenas para envio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "SMTP: Protocolo de Envio de Emails",
                                  "subSteps": [
                                    "Descreva o SMTP como protocolo push para envio de mensagens do cliente para servidor.",
                                    "Explique comandos básicos: HELO/EHLO, MAIL FROM, RCPT TO, DATA, QUIT.",
                                    "Detalhe o fluxo de operação: conexão, autenticação, envio de envelope e corpo.",
                                    "Identifique a porta padrão 25 (ou 587 para submission).",
                                    "Discuta limitações: SMTP não gerencia recebimento ou armazenamento."
                                  ],
                                  "verification": "Simule um fluxo SMTP manual via telnet em um servidor de teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta telnet ou netcat",
                                    "Servidor SMTP de teste como mailhog"
                                  ],
                                  "tips": "Pratique com telnet localhost 25 para ver respostas reais do servidor.",
                                  "learningObjective": "Dominar o funcionamento e comandos do SMTP para envio.",
                                  "commonMistakes": [
                                    "Usar porta errada (ex: 25 vs 465 para SMTPS)",
                                    "Esquecer ponto final (.) no comando DATA"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "POP3: Download e Exclusão de Emails",
                                  "subSteps": [
                                    "Descreva POP3 como protocolo pull para download de mensagens do servidor para cliente.",
                                    "Explique fases: Authorization (USER/PASS), Transaction (LIST, RETR, DELE), Update (QUIT).",
                                    "Detalhe o comportamento: emails são baixados e tipicamente deletados do servidor.",
                                    "Identifique a porta padrão 110 (ou 995 para POP3S).",
                                    "Compare com IMAP: POP3 não sincroniza pastas ou estados."
                                  ],
                                  "verification": "Conecte via telnet a um servidor POP3 e liste/retrieve uma mensagem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cliente POP3 de teste",
                                    "Telnet ou ferramenta similar"
                                  ],
                                  "tips": "Lembre-se: DELE marca para deleção apenas no QUIT.",
                                  "learningObjective": "Entender o ciclo de vida de emails com POP3 e suas implicações de armazenamento local.",
                                  "commonMistakes": [
                                    "Assumir sincronização bidirecional",
                                    "Deletar emails acidentalmente sem QUIT"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "IMAP: Acesso Remoto Sincronizado",
                                  "subSteps": [
                                    "Descreva IMAP como protocolo para acesso remoto, mantendo emails no servidor com sincronização.",
                                    "Explique comandos: LOGIN, SELECT, FETCH, STORE, CLOSE, LOGOUT.",
                                    "Detalhe flags (ex: \\Seen, \\Deleted) e suporte a pastas hierárquicas.",
                                    "Identifique a porta padrão 143 (ou 993 para IMAPS).",
                                    "Compare fluxos: visualização sem download completo, multi-dispositivo."
                                  ],
                                  "verification": "Configure um cliente IMAP e demonstre sincronização em dois dispositivos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Cliente email como Thunderbird",
                                    "Conta IMAP de teste (ex: Gmail IMAP)"
                                  ],
                                  "tips": "Habilite IMAP no Gmail para testes reais.",
                                  "learningObjective": "Mestre o IMAP para gerenciamento centralizado de emails.",
                                  "commonMistakes": [
                                    "Confundir portas (143 vs 993)",
                                    "Ignorar suporte a namespaces/pastas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparação, Portas e Fluxos Integrados",
                                  "subSteps": [
                                    "Compare SMTP (envio), POP3 (download local), IMAP (acesso remoto).",
                                    "Revise portas: SMTP 25/587, POP3 110/995, IMAP 143/993.",
                                    "Desenhe fluxos completos: envio via SMTP + recebimento via POP3/IMAP.",
                                    "Discuta segurança: uso de STARTTLS ou SSL/TLS.",
                                    "Identifique cenários de uso: POP3 para conexões lentas, IMAP para mobile."
                                  ],
                                  "verification": "Crie um fluxograma integrando todos os protocolos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como draw.io",
                                    "Tabela comparativa"
                                  ],
                                  "tips": "Use cores para diferenciar envio vs recebimento nos diagramas.",
                                  "learningObjective": "Integrar conhecimentos para fluxos de email end-to-end.",
                                  "commonMistakes": [
                                    "Portas erradas em produção",
                                    "Não considerar autenticação moderna (OAuth)"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure o Thunderbird para usar IMAP em uma conta Gmail (porta 993 SSL), envie um email via SMTP externo (porta 587 STARTTLS), e compare com POP3 baixando emails localmente, verificando sincronização em outro dispositivo.",
                              "finalVerifications": [
                                "Explique corretamente as portas padrão e suas variantes seguras.",
                                "Descreva fluxos de operação sem erros em SMTP, POP3 e IMAP.",
                                "Diferencie POP3 de IMAP em termos de armazenamento e sincronização.",
                                "Simule um comando básico de cada protocolo via telnet.",
                                "Crie um diagrama de fluxo de email completo.",
                                "Identifique quando usar cada protocolo em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nos comandos, portas e fluxos (80%+ correto).",
                                "Profundidade nos substeps e verificações práticas.",
                                "Clareza em comparações e diagramas.",
                                "Demonstração prática com ferramentas reais.",
                                "Identificação correta de erros comuns e dicas.",
                                "Integração de conceitos em exemplos do mundo real."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Integração com TLS/SSL e autenticação.",
                                "Programação: Implementação de clientes email em Python (smtplib, imaplib).",
                                "Redes: Análise de tráfego com Wireshark nos protocolos.",
                                "Sistemas Operacionais: Configuração de servidores MTAs como Postfix.",
                                "Administração de Sistemas: Troubleshooting de conexões email."
                              ],
                              "realWorldApplication": "Em empresas, configure Outlook ou Gmail para IMAP sincronizado em múltiplos dispositivos; diagnostique falhas de envio SMTP em helpdesk; migre de POP3 para IMAP para melhor mobilidade em times remotos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "FTP (File Transfer Protocol)",
                            "description": "Compreender o FTP, modos ativo e passivo, comandos (LIST, RETR, STOR), autenticação e sua operação em modo texto/binário para transferência de arquivos em redes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos do Protocolo FTP",
                                  "subSteps": [
                                    "Estude a definição de FTP como protocolo de camada de aplicação para transferência de arquivos via TCP/IP.",
                                    "Identifique as portas padrão: 21 para controle e 20 para dados.",
                                    "Diferencie FTP de outros protocolos como HTTP ou SFTP.",
                                    "Analise o modelo cliente-servidor do FTP.",
                                    "Revise o fluxo básico de uma sessão FTP: conexão, autenticação, comandos, desconexão."
                                  ],
                                  "verification": "Explique em suas palavras o que é FTP e liste as portas usadas; demonstre com um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 959 do FTP",
                                    "Vídeo tutorial introdutório sobre FTP",
                                    "Diagrama de rede básico"
                                  ],
                                  "tips": "Use analogias como 'FTP é como enviar pacotes postais pela internet' para fixar conceitos.",
                                  "learningObjective": "Compreender os conceitos fundamentais e arquitetura do FTP.",
                                  "commonMistakes": [
                                    "Confundir FTP com TFTP",
                                    "Ignorar que FTP usa duas conexões (controle e dados)",
                                    "Achar que FTP é criptografado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modos de Conexão Ativo e Passivo",
                                  "subSteps": [
                                    "Descreva o modo ativo: cliente abre porta >1023, servidor conecta de 20 para essa porta.",
                                    "Descreva o modo passivo (PASV): servidor abre porta >1023, cliente conecta nela.",
                                    "Compare vantagens: ativo para servidores antigos, passivo para firewalls/NAT comuns.",
                                    "Simule cenários com firewalls bloqueando modos ativo.",
                                    "Teste comandos PASV e PORT em um cliente FTP simulado."
                                  ],
                                  "verification": "Desenhe diagramas de fluxo para ambos os modos e identifique quando usar cada um.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta online como Wireshark para capturar tráfego FTP",
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Diagramas prontos de modos FTP"
                                  ],
                                  "tips": "Lembre: 'Passivo é para quando o cliente 'liga' para o servidor, evitando problemas de NAT'.",
                                  "learningObjective": "Diferenciar e aplicar modos ativo e passivo em contextos de rede reais.",
                                  "commonMistakes": [
                                    "Confundir quem inicia a conexão de dados",
                                    "Não considerar impactos de firewalls",
                                    "Usar modo ativo por padrão em redes modernas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comandos Essenciais do FTP",
                                  "subSteps": [
                                    "Aprenda comando LIST: lista arquivos no diretório remoto.",
                                    "Pratique RETR: recupera (download) arquivo do servidor.",
                                    "Pratique STOR: armazena (upload) arquivo no servidor.",
                                    "Explore outros: CWD (mudar diretório), PWD (diretório atual), QUIT (sair).",
                                    "Execute sequências de comandos em um cliente de linha de comando como ftp ou lftp."
                                  ],
                                  "verification": "Execute uma sessão completa: conecte, liste, baixe e suba um arquivo teste.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Servidor FTP local (ex: FileZilla Server)",
                                    "Cliente FTP como command-line ftp ou FileZilla Client",
                                    "Arquivos de teste (txt e binário)"
                                  ],
                                  "tips": "Sempre teste com arquivos pequenos primeiro para evitar erros de transferência.",
                                  "learningObjective": "Dominar comandos básicos para navegação e transferência de arquivos.",
                                  "commonMistakes": [
                                    "Esquecer de especificar modo binário para arquivos não-texto",
                                    "Usar comandos em maiúsculas/minúsculas incorretas",
                                    "Não verificar diretório atual antes de transferir"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Autenticação e Modos de Transferência",
                                  "subSteps": [
                                    "Entenda autenticação: usuário/senha em texto plano via comando USER e PASS.",
                                    "Configure modo texto (ASCII): para arquivos legíveis como .txt, converte quebras de linha.",
                                    "Configure modo binário (IMAGE): para arquivos binários como .jpg, sem conversão.",
                                    "Use comandos TYPE A (ASCII) e TYPE I (Image/binário).",
                                    "Discuta riscos de segurança: prefira FTPS ou SFTP para produção."
                                  ],
                                  "verification": "Transfira um arquivo .txt e um .jpg corretamente em ambos os modos, verificando integridade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Cliente FTP com suporte a modos",
                                    "Arquivos de teste: hello.txt e image.jpg",
                                    "Hash tool como md5sum para verificar integridade"
                                  ],
                                  "tips": "Comando 'hash' ou md5sum antes/depois para confirmar que o arquivo não corrompeu.",
                                  "learningObjective": "Gerenciar autenticação segura e escolher modos de transferência apropriados.",
                                  "commonMistakes": [
                                    "Enviar binários em modo ASCII (corrompe arquivos)",
                                    "Expor credenciais em logs",
                                    "Ignorar que autenticação FTP é insegura"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um servidor FTP local com FileZilla Server. Como cliente, conecte em modo passivo, autentique com usuário 'test/user' senha 'pass123', liste diretório, baixe 'documento.txt' em modo ASCII, suba 'foto.jpg' em modo binário, verifique hashes para integridade.",
                              "finalVerifications": [
                                "Explique diferenças entre modos ativo e passivo com diagramas.",
                                "Liste e demonstre 5 comandos FTP principais.",
                                "Transfira arquivos texto e binário corretamente sem corrupção.",
                                "Identifique riscos de segurança do FTP e alternativas.",
                                "Configure uma sessão FTP completa via linha de comando.",
                                "Resolva um problema simulado de conexão falhando por firewall."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de conceitos fundamentais (30%)",
                                "Correta diferenciação e aplicação de modos ativo/passivo (25%)",
                                "Domínio prático de comandos e transferências (20%)",
                                "Escolha apropriada de modos texto/binário e verificação de integridade (15%)",
                                "Identificação de limitações de segurança (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Comparar FTP com SFTP/FTPS para criptografia.",
                                "Programação: Automatizar FTP com scripts Python (ftplib).",
                                "Redes: Integração com TCP/IP, portas e NAT/firewalls.",
                                "Administração de Sistemas: Configuração de servidores FTP em Linux/Windows."
                              ],
                              "realWorldApplication": "Usado por webmasters para upload de sites em servidores hospedados, administradores de sistemas para backups automatizados de arquivos entre servidores, e em legacy systems para compartilhamento de grandes volumes de dados em redes corporativas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.4",
                            "name": "Diferenciação entre Protocolos de Serviços",
                            "description": "Comparar protocolos de serviços como HTTP, SMTP e FTP em termos de portas, orientação cliente-servidor, stateless/stateful e dependências de protocolos de suporte como DNS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais dos Protocolos",
                                  "subSteps": [
                                    "Defina o que são portas de rede e liste exemplos comuns (ex: 80 para HTTP).",
                                    "Explique o modelo cliente-servidor: cliente inicia conexão, servidor responde.",
                                    "Diferencie stateless (sem memória de sessões anteriores, como HTTP) de stateful (mantém estado, como FTP).",
                                    "Descreva o papel do DNS na resolução de nomes para IPs antes de usar protocolos de serviço.",
                                    "Crie um diagrama simples ilustrando cliente-servidor com DNS."
                                  ],
                                  "verification": "Preencha uma tabela com definições corretas dos 4 conceitos e diagrama aprovado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Documentação IANA para portas"
                                  ],
                                  "tips": "Use analogias: porta como endereço de apartamento, stateless como caixa de correio sem memória.",
                                  "learningObjective": "Dominar terminologia chave para análise comparativa de protocolos.",
                                  "commonMistakes": [
                                    "Confundir stateless com stateful (HTTP é stateless por padrão)",
                                    "Ignorar que DNS é pré-requisito para todos os protocolos de aplicação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Protocolo HTTP em Detalhe",
                                  "subSteps": [
                                    "Pesquise porta padrão (80/443 para HTTPS), modelo cliente-servidor e stateless nature.",
                                    "Leia RFC 2616 ou documentação MDN sobre requisição-resposta HTTP.",
                                    "Teste uma conexão HTTP simples usando curl ou browser dev tools.",
                                    "Identifique dependências: resolve DNS primeiro, depois conecta via TCP porta 80.",
                                    "Anote exemplos de cabeçalhos HTTP que mostram stateless (sem cookies)."
                                  ],
                                  "verification": "Execute comando curl http://example.com e explique saída em relatório curto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Terminal com curl instalado",
                                    "Browser com DevTools",
                                    "RFCs online (ietf.org)"
                                  ],
                                  "tips": "Sempre especifique --http1.1 no curl para simular protocolo puro.",
                                  "learningObjective": "Entender características únicas do HTTP como protocolo web stateless.",
                                  "commonMistakes": [
                                    "Achar HTTP stateful devido a cookies/sessões (é stateless no núcleo)",
                                    "Confundir porta 80 com 443."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Protocolos SMTP e FTP",
                                  "subSteps": [
                                    "Para SMTP: porta 25/587, cliente-servidor para email, stateless por mensagem, depende de DNS MX records.",
                                    "Para FTP: portas 20/21, stateful com sessões de controle/dados, cliente-servidor, depende de DNS.",
                                    "Compare internamente: SMTP texto-based, FTP binário com modos ativo/passivo.",
                                    "Simule SMTP com telnet smtp.gmail.com 587 (use EHLO).",
                                    "Simule FTP com ftp ftp.example.com (comando ls, get)."
                                  ],
                                  "verification": "Registre saídas de telnet/ftp em screenshots ou logs com explicações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Telnet ou nc (netcat)",
                                    "Cliente FTP como FileZilla",
                                    "Servidores públicos para teste"
                                  ],
                                  "tips": "Use contas de email teste para SMTP; evite spam.",
                                  "learningObjective": "Mapear specs técnicas de SMTP e FTP para comparação futura.",
                                  "commonMistakes": [
                                    "Esquecer modo passivo no FTP (stateful requer)",
                                    "Confundir SMTP porta 25 com 110 (POP3)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Contrastar os Protocolos",
                                  "subSteps": [
                                    "Crie tabela comparativa: linhas para portas, C/S, state/stateless, DNS deps.",
                                    "Preencha: HTTP (80, stateless), SMTP (25, stateless/msg), FTP (21, stateful).",
                                    "Discuta diferenças: HTTP request-response rápida vs FTP transferências longas.",
                                    "Identifique cenários onde um é preferido (web vs email vs files).",
                                    "Revise dependências comuns: todos usam TCP sobre IP, resolvem via DNS."
                                  ],
                                  "verification": "Tabela completa e precisa, com pelo menos 3 insights de comparação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Use cores na tabela para destacar similaridades/diferenças.",
                                  "learningObjective": "Sintetizar conhecimentos em comparação acionável.",
                                  "commonMistakes": [
                                    "Classificar SMTP como stateful (é por transação)",
                                    "Omitir DNS como dependência universal."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture tráfego de navegação web (HTTP), envio de email (SMTP via Outlook) e download de arquivo (FTP). Analise pacotes para portas, fluxos C/S e evidências de estado/DNS queries.",
                              "finalVerifications": [
                                "Liste corretamente portas padrão: HTTP=80, SMTP=25, FTP=21.",
                                "Classifique cada protocolo como stateless ou stateful com justificativa.",
                                "Descreva orientação cliente-servidor para os três.",
                                "Explique dependência em DNS para resolução de hostnames.",
                                "Preencha tabela comparativa sem erros.",
                                "Simule uma conexão simples para cada protocolo."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual em portas e características (100% correto).",
                                "Profundidade na distinção stateless/stateful com exemplos.",
                                "Clareza na tabela comparativa e diagramas.",
                                "Evidência de testes práticos (logs/screenshots).",
                                "Identificação correta de dependências como DNS e TCP.",
                                "Insights sobre aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Portas como sistema numérico de 0-65535 para roteamento.",
                                "Segurança da Informação: Vulnerabilidades como FTP plaintext vs HTTPS.",
                                "Desenvolvimento de Software: Integração HTTP em APIs web.",
                                "Administração de Sistemas: Configuração de servidores SMTP/FTP."
                              ],
                              "realWorldApplication": "Navegação web diária usa HTTP stateless para sites rápidos; SMTP envia bilhões de emails/dia via servidores cliente-servidor; FTP transfere arquivos grandes em data centers, todos dependendo de DNS para acessibilidade global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Nível de Transporte: TCP, UDP e Controle de Congestionamento",
                    "description": "Protocolos TCP e UDP, além de mecanismos de controle de congestionamento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Protocolo UDP (User Datagram Protocol)",
                        "description": "O UDP é um protocolo de transporte sem conexão (connectionless), não orientado a conexão, que oferece um serviço de datagrama de melhor esforço, sem garantias de entrega, ordem, duplicação ou controle de fluxo, sendo leve e adequado para aplicações que priorizam baixa latência.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Identificar as principais características do UDP",
                            "description": "Listar e explicar as características fundamentais do UDP, como ausência de conexão, falta de confiabilidade (sem ACKs ou retransmissões), mínimo overhead de cabeçalho (8 bytes) e suporte a multicast/unicast, comparando com protocolos orientados a conexão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Contexto e Definição Básica do UDP",
                                  "subSteps": [
                                    "Estude o modelo TCP/IP e identifique o nível de transporte.",
                                    "Leia a RFC 768 para a definição oficial do UDP como User Datagram Protocol.",
                                    "Anote a posição do UDP no stack de protocolos ao lado do TCP.",
                                    "Desenhe um diagrama simples do cabeçalho UDP (8 bytes: source port, destination port, length, checksum).",
                                    "Pesquise exemplos iniciais de uso como DNS e DHCP."
                                  ],
                                  "verification": "Desenhe corretamente o stack TCP/IP com UDP destacado e explique sua função em 1 frase.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 768 (disponível online)",
                                    "Diagrama do modelo TCP/IP",
                                    "Editor de texto ou papel para desenhos"
                                  ],
                                  "tips": "Comece pelo diagrama para visualizar melhor a simplicidade do UDP.",
                                  "learningObjective": "Entender o papel do UDP como protocolo de transporte leve e sem conexão.",
                                  "commonMistakes": [
                                    "Confundir UDP com IP (UDP é transporte, IP é rede)",
                                    "Ignorar que UDP é definido na RFC 768"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar e Explicar as Características Fundamentais do UDP",
                                  "subSteps": [
                                    "Identifique ausência de conexão: sem handshake (three-way como TCP).",
                                    "Explique falta de confiabilidade: sem ACKs, retransmissões ou controle de ordem.",
                                    "Detalhe overhead mínimo: cabeçalho de apenas 8 bytes.",
                                    "Descreva suporte a multicast e unicast (um para muitos ou um para um).",
                                    "Registre que permite datagramas independentes (best-effort delivery)."
                                  ],
                                  "verification": "Crie uma tabela com 5 características principais e explicações breves para cada uma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela em spreadsheet ou papel",
                                    "Referências online sobre UDP (Wikipedia, tutoriais Cisco)"
                                  ],
                                  "tips": "Use bullet points para cada característica e associe a um ícone ou imagem mental.",
                                  "learningObjective": "Memorizar e articular as 4-5 características chave do UDP com precisão.",
                                  "commonMistakes": [
                                    "Achar que UDP tem ACKs (não tem)",
                                    "Exagerar o tamanho do cabeçalho (é fixo em 8 bytes)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar UDP com Protocolos Orientados a Conexão como TCP",
                                  "subSteps": [
                                    "Crie uma tabela de comparação: conexão (UDP: não / TCP: sim), confiabilidade (UDP: não / TCP: sim).",
                                    "Compare overhead: UDP 8 bytes vs TCP 20+ bytes.",
                                    "Discuta cenários: UDP para baixa latência vs TCP para integridade.",
                                    "Analise implicações: perda de pacotes em UDP requer aplicação para lidar.",
                                    "Teste com exemplo: por que streaming usa UDP mas downloads usam TCP?"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito 3 diferenças chave e 2 cenários de uso preferencial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de comparação em Excel/Google Sheets",
                                    "Diagramas de TCP vs UDP handshake"
                                  ],
                                  "tips": "Foque em trade-offs: velocidade vs confiabilidade para fixar a comparação.",
                                  "learningObjective": "Diferenciar UDP de TCP destacando vantagens/desvantagens em contextos reais.",
                                  "commonMistakes": [
                                    "Dizer que UDP é sempre mais lento (é mais rápido por simplicidade)",
                                    "Ignorar multicast exclusivo do UDP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Verificar o Entendimento das Características",
                                  "subSteps": [
                                    "Resuma todas as características em um mapa mental.",
                                    "Responda a 5 perguntas de auto-teste sobre UDP vs TCP.",
                                    "Capture tráfego de rede simples (ex: ping ou nslookup) para observar UDP.",
                                    "Explique para um 'parceiro de estudo' ou grave um vídeo curto.",
                                    "Identifique 2 aplicações reais que usam UDP e por quê."
                                  ],
                                  "verification": "Mapa mental completo e respostas corretas a todas as perguntas de teste.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de mapa mental (MindMeister ou papel)",
                                    "Comando nslookup no terminal para gerar tráfego UDP"
                                  ],
                                  "tips": "Explique como se estivesse ensinando a uma criança para reforçar.",
                                  "learningObjective": "Consolidar conhecimento para recall imediato e aplicação.",
                                  "commonMistakes": [
                                    "Não testar com ferramenta real (teoria sem prática falha)",
                                    "Confundir unicast com broadcast"
                                  ]
                                }
                              ],
                              "practicalExample": "Use o Wireshark para capturar uma consulta DNS (nslookup google.com): observe pacotes UDP de 53 portas sem ACKs ou retransmissões, destacando o cabeçalho de 8 bytes e entrega best-effort.",
                              "finalVerifications": [
                                "Liste corretamente pelo menos 4 características principais do UDP.",
                                "Explique a ausência de confiabilidade com exemplos de perda de pacotes.",
                                "Compare overhead de cabeçalho UDP vs TCP com números exatos.",
                                "Identifique 2 cenários onde UDP é preferível a TCP.",
                                "Descreva suporte a multicast e sua utilidade.",
                                "Desenhe o cabeçalho UDP corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: todas as características listadas sem erros.",
                                "Profundidade de explicação: cada característica com justificativa clara.",
                                "Qualidade da comparação: tabela ou lista com pelo menos 5 diferenças.",
                                "Evidência prática: screenshot ou descrição de captura de tráfego UDP.",
                                "Clareza na síntese: mapa mental ou resumo conciso e organizado.",
                                "Aplicação contextual: ligação correta com usos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidades e estatísticas para modelar perda de pacotes em redes não confiáveis.",
                                "Física: Analogia com transmissão de ondas de rádio (best-effort sem garantias).",
                                "Programação: Implementação de sockets UDP em Python para envio de datagramas.",
                                "Segurança da Informação: Riscos de spoofing em protocolos sem conexão.",
                                "Estatística: Análise de latência e throughput em experimentos de rede."
                              ],
                              "realWorldApplication": "UDP é essencial em streaming de vídeo (Netflix/YouTube para baixa latência), jogos online multiplayer (Fortnite para atualizações rápidas), chamadas VoIP (Zoom/WhatsApp), consultas DNS e broadcasting de dados em IoT, priorizando velocidade sobre garantia de entrega."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Descrever a estrutura do cabeçalho UDP",
                            "description": "Analisar os campos do cabeçalho UDP: portas de origem e destino (16 bits cada), comprimento (16 bits) e checksum (16 bits opcional), explicando o papel de cada um na identificação de processos e verificação básica de integridade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral do cabeçalho UDP",
                                  "subSteps": [
                                    "Ler a RFC 768 para entender que o cabeçalho UDP é fixo em 8 bytes (64 bits).",
                                    "Visualizar um diagrama do cabeçalho mostrando os quatro campos sequenciais.",
                                    "Identificar a ordem dos campos: Source Port, Destination Port, Length e Checksum.",
                                    "Notar que todos os campos são de 16 bits e representados em big-endian.",
                                    "Comparar brevemente com o cabeçalho TCP para destacar a simplicidade do UDP."
                                  ],
                                  "verification": "Desenhar manualmente o diagrama do cabeçalho UDP com os tamanhos corretos de cada campo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 768 (disponível online)",
                                    "Diagrama do cabeçalho UDP (imagem ou ferramenta como draw.io)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Sempre comece com o diagrama para visualizar a estrutura antes de mergulhar nos detalhes.",
                                  "learningObjective": "Identificar a composição fixa de 8 bytes do cabeçalho UDP e a sequência dos campos principais.",
                                  "commonMistakes": [
                                    "Confundir o tamanho total com TCP (20+ bytes)",
                                    "Ignorar a ordem big-endian dos campos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o campo Porta de Origem (Source Port)",
                                  "subSteps": [
                                    "Explicar que é um campo de 16 bits (0-65535) que identifica o processo ou aplicação remetente.",
                                    "Entender que permite multiplexação: múltiplas aplicações no mesmo host.",
                                    "Converter um valor hexadecimal de exemplo (ex: 0x1234) para decimal (4660).",
                                    "Discutir portas efêmeras (1024-65535) vs bem-conhecidas (0-1023).",
                                    "Verificar em um exemplo real como portas são atribuídas dinamicamente."
                                  ],
                                  "verification": "Identificar corretamente a porta de origem em um cabeçalho UDP capturado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora binária/hexadecimal",
                                    "Exemplos de pacotes UDP em Wireshark",
                                    "Lista de portas IANA"
                                  ],
                                  "tips": "Lembre-se: source port é do remetente e pode ser efêmera para respostas.",
                                  "learningObjective": "Descrever o papel da porta de origem na identificação do processo remetente e multiplexação.",
                                  "commonMistakes": [
                                    "Confundir source com destination port",
                                    "Achar que é obrigatória (pode ser 0 para pacotes sem porta)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o campo Porta de Destino (Destination Port)",
                                  "subSteps": [
                                    "Descrever como campo de 16 bits que indica o processo receptor esperado.",
                                    "Explicar seu uso no demultiplexação no receptor.",
                                    "Comparar com source port: destination geralmente é fixa (ex: 53 para DNS).",
                                    "Praticar conversão de hex para decimal e identificar serviços comuns.",
                                    "Entender que erros na porta levam a discard do pacote."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença entre source e destination ports com exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de portas de serviços comuns (IANA)",
                                    "Ferramenta Wireshark para captura"
                                  ],
                                  "tips": "Associe portas a serviços: 53=DNS, 123=NTP para memorizar.",
                                  "learningObjective": "Explicar como a porta de destino facilita a entrega ao processo correto no host receptor.",
                                  "commonMistakes": [
                                    "Invertir source e destination",
                                    "Pensar que ambas são sempre efêmeras"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o campo Comprimento (Length)",
                                  "subSteps": [
                                    "Definir como 16 bits indicando o tamanho total do datagrama UDP (header 8 bytes + dados).",
                                    "Calcular exemplo: header 8 + dados 100 = length 108 bytes.",
                                    "Entender mínimo 8 (sem dados) e máximo 65535 bytes.",
                                    "Verificar como o SO usa para alocar buffer no receptor.",
                                    "Comparar com IP length para evitar confusões."
                                  ],
                                  "verification": "Calcular corretamente o length para um datagrama com dados conhecidos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Exemplos de pacotes UDP",
                                    "Documentação UDP/IP"
                                  ],
                                  "tips": "Sempre inclua os 8 bytes do header no cálculo.",
                                  "learningObjective": "Compreender o campo length como indicador do tamanho total do datagrama UDP.",
                                  "commonMistakes": [
                                    "Esquecer de somar o header",
                                    "Confundir com tamanho só dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar o campo Checksum",
                                  "subSteps": [
                                    "Explicar que é 16 bits opcional para verificação de integridade (pseudo-header + UDP + dados).",
                                    "Descrever quando é usado: obrigatório com IPv6, opcional com IPv4 (zero se não usado).",
                                    "Entender cálculo: soma de 16 bits com carry-around, complemento de 1.",
                                    "Verificar se checksum zero indica não calculado.",
                                    "Discutir limitações: detecta erros, mas não corrige."
                                  ],
                                  "verification": "Identificar se checksum está presente e validar um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 768 e RFC 1071 para checksum",
                                    "Ferramenta online de cálculo de checksum UDP",
                                    "Wireshark"
                                  ],
                                  "tips": "Teste desabilitando checksum em apps para ver impacto em redes ruins.",
                                  "learningObjective": "Descrever o papel do checksum na verificação básica de integridade do datagrama.",
                                  "commonMistakes": [
                                    "Achar checksum obrigatório sempre",
                                    "Confundir com autenticação (só integridade)"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture tráfego DNS (UDP porta 53): identifique source port (ex: 54321 efêmera), destination port (53), length (ex: 42 bytes para query simples) e checksum (valor calculado). Desenhe o cabeçalho destacando cada campo e explique como o receptor usa as portas para rotear à aplicação DNS.",
                              "finalVerifications": [
                                "Desenhar o cabeçalho UDP completo com bits e rótulos corretos.",
                                "Explicar o papel de cada campo em uma frase clara.",
                                "Identificar todos os campos em um pacote real capturado no Wireshark.",
                                "Calcular length e validar checksum para um exemplo dado.",
                                "Diferenciar UDP header de TCP header em tamanho e campos.",
                                "Listar cenários onde checksum é zero."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos tamanhos (todos 16 bits) e ordem dos campos.",
                                "Correta explicação funcional de portas para multiplexação/demultiplexação.",
                                "Entendimento de length como total (header + data).",
                                "Descrição precisa do checksum como opcional e seu escopo.",
                                "Uso de exemplos reais para ilustrar conceitos.",
                                "Ausência de confusões com protocolos como TCP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão entre binário, hexadecimal e decimal para valores de portas e length.",
                                "Segurança da Informação: Conceitos de integridade de dados via checksum.",
                                "Física: Transmissão de bits em redes (endianness e representação numérica).",
                                "Programação: Uso de sockets UDP em linguagens como Python para definir portas.",
                                "Estatística: Análise de tráfego de rede com ferramentas como Wireshark."
                              ],
                              "realWorldApplication": "Em aplicações de baixa latência como consultas DNS (porta 53), streaming de vídeo multicast (ex: IPTV), jogos online (ex: Fortnite usa UDP para atualizações rápidas) e VoIP (ex: Discord), onde a simplicidade do cabeçalho UDP permite entrega rápida sem handshakes, priorizando velocidade sobre garantia de entrega."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Reconhecer aplicações e cenários de uso do UDP",
                            "description": "Exemplificar usos do UDP em aplicações como DNS, DHCP, streaming de vídeo (ex: RTP) e jogos online, justificando a escolha devido à tolerância a perdas e baixa sobrecarga em detrimento da confiabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar características fundamentais do UDP",
                                  "subSteps": [
                                    "Identifique as principais características do UDP: sem conexão, sem garantia de entrega, sem controle de fluxo e baixa sobrecarga.",
                                    "Compare brevemente com TCP: UDP não reenvia pacotes perdidos, priorizando velocidade sobre confiabilidade.",
                                    "Liste vantagens: tolerância a perdas, baixa latência e simplicidade.",
                                    "Anote cenários onde confiabilidade não é crítica, como dados em tempo real.",
                                    "Crie um diagrama simples comparando cabeçalhos UDP (8 bytes) vs TCP (20+ bytes)."
                                  ],
                                  "verification": "Crie uma tabela comparativa UDP vs TCP com pelo menos 5 diferenças chave; revise se todas as características estão corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação UDP/TCP (RFC 768), quadro branco ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Foquem em 'por quê' UDP é 'fire-and-forget': memorize que é ideal para multicast e broadcast.",
                                  "learningObjective": "Compreender por que o UDP é escolhido em cenários de baixa latência e tolerância a perdas.",
                                  "commonMistakes": [
                                    "Confundir UDP com TCP achando que garante entrega; ignorar o impacto da baixa sobrecarga em redes congestionadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar aplicações em serviços de rede: DNS e DHCP",
                                  "subSteps": [
                                    "Estude DNS: consultas UDP na porta 53 para resolução rápida de nomes; falhas são toleradas com reenvios rápidos.",
                                    "Explique DHCP: descoberta e oferta de IP via UDP (portas 67/68), onde perda ocasional não compromete o processo.",
                                    "Simule uma consulta DNS: envie uma requisição UDP e observe resposta sem ACK.",
                                    "Justifique: velocidade > confiabilidade em setups iniciais ou frequentes.",
                                    "Pesquise estatísticas: 90%+ das consultas DNS usam UDP."
                                  ],
                                  "verification": "Descreva fluxos DNS e DHCP em um fluxograma, destacando uso de UDP e razões.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark para capturar tráfego DNS/DHCP, tutoriais online sobre DNS (ex: Cloudflare Learning)"
                                  ],
                                  "tips": "Use Wireshark para ver pacotes reais: filtre 'udp.port == 53' para DNS.",
                                  "learningObjective": "Identificar e justificar o uso de UDP em protocolos de configuração e resolução de rede.",
                                  "commonMistakes": [
                                    "Achar que DNS sempre usa TCP; esquecer que DHCP usa broadcast UDP."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar aplicações em tempo real: Streaming e Jogos Online",
                                  "subSteps": [
                                    "Analise RTP/RTSP sobre UDP: para streaming de vídeo/áudio, onde atrasos > perdas.",
                                    "Estude jogos online: pacotes UDP para posições de jogadores; perda de um frame é aceitável.",
                                    "Simule streaming: use VLC com RTP/UDP e observe perda simulada.",
                                    "Justifique: baixa latência crítica; reenvio causaria 'lag'.",
                                    "Liste exemplos: Netflix/YouTube (QUIC/UDP), Fortnite/Minecraft multiplayer."
                                  ],
                                  "verification": "Grave um vídeo curto (1 min) explicando RTP em streaming e teste com perda de pacotes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "VLC player, Wireshark, vídeos tutoriais RTP (RFC 3550)"
                                  ],
                                  "tips": "Teste perda: use 'netem' no Linux para simular 5% packet loss em UDP stream.",
                                  "learningObjective": "Reconhecer cenários onde tolerância a perdas do UDP habilita aplicações interativas.",
                                  "commonMistakes": [
                                    "Confundir RTP com TCP; subestimar impacto de latência em jogos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar justificativas e cenários de uso",
                                  "subSteps": [
                                    "Compile uma lista de 5+ aplicações UDP com justificativas: tolerância a perdas vs baixa sobrecarga.",
                                    "Crie matriz: aplicação | razão UDP | alternativa TCP | quando trocar.",
                                    "Debata cenários híbridos: DNS usa TCP para respostas grandes (>512 bytes).",
                                    "Aplique a casos reais: por quê VoIP usa UDP?",
                                    "Revise e refine exemplos pessoais."
                                  ],
                                  "verification": "Produza um mindmap conectando UDP a aplicações com setas justificativas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de mindmap (MindMeister ou papel), notas dos steps anteriores"
                                  ],
                                  "tips": "Priorize 'trade-offs': UDP ganha em velocidade, perde em confiabilidade.",
                                  "learningObjective": "Justificar escolhas de UDP em contextos específicos vs TCP.",
                                  "commonMistakes": [
                                    "Generalizar UDP como 'ruim'; ignorar evoluções como QUIC."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um servidor de jogo multiplayer simples usando UDP em Python (biblioteca socket): envie posições de jogadores a cada 50ms. Introduza 10% perda de pacotes com netem; observe que o jogo continua fluido sem reenvios, justificando UDP para baixa latência.",
                              "finalVerifications": [
                                "Liste corretamente 4 aplicações UDP (DNS, DHCP, RTP, jogos) com justificativas precisas.",
                                "Explique trade-off UDP vs TCP em 2 cenários sem erros.",
                                "Capture e analise tráfego Wireshark mostrando UDP em uso real.",
                                "Crie tabela comparativa com overhead e latência.",
                                "Debata verbalmente por quê streaming prefere UDP (demo em 1 min).",
                                "Identifique quando TCP seria melhor (ex: transferências de arquivos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas características UDP (tolerância a perdas, baixa sobrecarga).",
                                "Diversidade e relevância de exemplos (mínimo 4 aplicações).",
                                "Justificativas lógicas e baseadas em trade-offs.",
                                "Uso correto de ferramentas como Wireshark para evidências.",
                                "Capacidade de sintetizar em matriz ou mindmap clara.",
                                "Compreensão de cenários híbridos (UDP/TCP)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidades de perda de pacotes e modelagem estatística de redes.",
                                "Física: Analogia com transmissão de ondas de rádio (sem ACK).",
                                "Engenharia de Software: Design de protocolos low-latency.",
                                "Segurança da Informação: Vulnerabilidades UDP (spoofing em DNS/DHCP)."
                              ],
                              "realWorldApplication": "Em serviços como Netflix (streaming via DASH/UDP), jogos como League of Legends (movimento de personagens), ou IoT (sensores enviando dados periódicos sem ACK), onde atrasos de milissegundos impactam experiência do usuário mais que perdas ocasionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Protocolo TCP (Transmission Control Protocol)",
                        "description": "O TCP é um protocolo de transporte orientado a conexão, confiável e full-duplex, que garante entrega ordenada, sem erros e sem duplicatas dos dados, utilizando mecanismos como controle de fluxo, controle de erro e preparação para controle de congestionamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Explicar o estabelecimento e término de conexão TCP",
                            "description": "Descrever o three-way handshake (SYN, SYN-ACK, ACK) para abertura de conexão e o four-way handshake (FIN, ACK, FIN, ACK) para fechamento, incluindo números de sequência e ACK para sincronização inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos do TCP e a necessidade de handshakes",
                                  "subSteps": [
                                    "Estude o que é o protocolo TCP: orientado a conexão, confiável e com controle de fluxo.",
                                    "Identifique por que handshakes são necessários: estabelecer parâmetros de conexão e sincronizar sequência.",
                                    "Diferencie TCP de UDP: TCP requer handshakes para garantir entrega ordenada.",
                                    "Revise os flags principais: SYN (sincronizar), ACK (reconhecer), FIN (finalizar).",
                                    "Analise o cabeçalho TCP básico: campos de sequência (seq) e número de ACK."
                                  ],
                                  "verification": "Resuma em 3 frases os motivos para handshakes no TCP e liste os 3 flags principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do cabeçalho TCP",
                                    "Vídeo introdutório sobre TCP (YouTube: 5-10 min)"
                                  ],
                                  "tips": "Use analogia de 'aperto de mão' para lembrar a sincronização inicial.",
                                  "learningObjective": "Entender o papel fundamental dos handshakes na inicialização e término confiável de conexões TCP.",
                                  "commonMistakes": [
                                    "Confundir TCP com UDP (stateless)",
                                    "Ignorar que handshakes sincronizam números de sequência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o Three-Way Handshake para estabelecimento de conexão",
                                  "subSteps": [
                                    "Cliente envia SYN com seq=x (número inicial aleatório).",
                                    "Servidor responde SYN-ACK: seq=y, ack=x+1 (sincroniza cliente).",
                                    "Cliente envia ACK: seq=x+1, ack=y+1 (confirma servidor).",
                                    "Desenhe o diagrama com setas e valores de seq/ack exemplo (x=100, y=300).",
                                    "Simule com ferramenta online ou papel: trace os pacotes."
                                  ],
                                  "verification": "Desenhe o diagrama do three-way handshake com seq/ack corretos e explique verbalmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de simulação TCP (ex: tcp-handshake-simulator)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Lembre: 'SYN, SYN-ACK, ACK' como uma conversa: 'Oi?', 'Oi, tudo bem?', 'Tudo bem!'",
                                  "learningObjective": "Dominar a sequência SYN, SYN-ACK, ACK e o papel dos números de sequência na sincronização.",
                                  "commonMistakes": [
                                    "Esquecer de incrementar seq/ack em +1",
                                    "Trocar cliente/servidor nas respostas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Four-Way Handshake para término de conexão",
                                  "subSteps": [
                                    "Cliente envia FIN: seq=a (fim de dados enviados).",
                                    "Servidor responde ACK: ack=a+1 (confirma recebimento).",
                                    "Servidor envia FIN: seq=b.",
                                    "Cliente responde ACK: ack=b+1 (confirma fechamento).",
                                    "Compare com three-way: four-way permite fechamento independente (half-close)."
                                  ],
                                  "verification": "Liste os 4 pacotes em ordem com flags e explique por que são 4 (não 3).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama comparativo three/four-way",
                                    "Simulador online de TCP close"
                                  ],
                                  "tips": "Pense como 'tchau' separado: um diz tchau (FIN), outro confirma (ACK), depois inverte.",
                                  "learningObjective": "Compreender a sequência FIN-ACK-FIN-ACK e o suporte a half-close no TCP.",
                                  "commonMistakes": [
                                    "Confundir com three-way (usar só 3 pacotes)",
                                    "Não notar ACK após cada FIN"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar números de sequência e ACK nos handshakes",
                                  "subSteps": [
                                    "Explique seq: identifica próximo byte esperado pelo remetente.",
                                    "Explique ACK: confirma bytes recebidos até esse número.",
                                    "Trace exemplo completo: three-way com seq iniciais, depois dados, four-way.",
                                    "Discuta ataques como SYN flood (explorar three-way).",
                                    "Pratique com captura real ou simulação."
                                  ],
                                  "verification": "Simule um handshake completo com dados de 100 bytes e verifique seq/ack finais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Captura de exemplo TCP (arquivo .pcap)"
                                  ],
                                  "tips": "Seq/ACK sempre +1 por byte ou segmento; memorize com 'contador de pacotes confiáveis'.",
                                  "learningObjective": "Integrar seq/ACK aos handshakes para entender sincronização total.",
                                  "commonMistakes": [
                                    "Não incrementar corretamente (+1 por segmento)",
                                    "Confundir seq com ACK"
                                  ]
                                }
                              ],
                              "practicalExample": "Abra o Wireshark, inicie captura em interface de rede, acesse um site HTTP (ex: http://example.com). Filtre por 'tcp.analysis.handshake' para ver three-way SYN/SYN-ACK/ACK. Feche a conexão e filtre por 'tcp.flags.fin==1' para four-way. Anote seq/ACK de cada pacote.",
                              "finalVerifications": [
                                "Desenhar e rotular three-way e four-way handshakes com seq/ACK exemplo.",
                                "Explicar verbalmente a diferença entre abertura e fechamento de conexão.",
                                "Identificar flags corretos em uma captura Wireshark fornecida.",
                                "Simular um handshake completo em papel com dados trocados.",
                                "Discutir o que acontece se um ACK for perdido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de pacotes e flags (SYN, SYN-ACK, ACK, FIN).",
                                "Correta explicação de números de sequência e ACK (incremento +1).",
                                "Compreensão de sincronização inicial e half-close.",
                                "Uso de exemplos concretos ou diagramas claros.",
                                "Identificação de erros comuns como SYN flood."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências aritméticas nos números seq/ACK (+1 incremental).",
                                "Física: Analogia com sinais eletromagnéticos em comunicação (handshakes como sincronização de ondas).",
                                "Segurança da Informação: Vulnerabilidades como SYN flood e mitigação.",
                                "Lógica/Algoritmos: Estados finitos da máquina de estados TCP."
                              ],
                              "realWorldApplication": "Garante conexões confiáveis em navegação web (HTTPS), emails (SMTP), transferências de arquivos (FTP) e streaming (ex: Netflix), evitando perda de dados e assegurando ordem na entrega sobre redes instáveis como internet pública."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Descrever mecanismos de controle de erro no TCP",
                            "description": "Explicar detecção de erros via checksum, confirmações (ACKs cumulativos e seletivos), temporizadores de retransmissão (baseados em RTT estimado) e detecção de perda por timeout ou duplicação de ACKs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o mecanismo de checksum para detecção de erros",
                                  "subSteps": [
                                    "Estudar a definição de checksum no cabeçalho TCP: soma de 16 bits dos campos do cabeçalho e payload.",
                                    "Aprender o algoritmo de cálculo: somar palavras de 16 bits, complementar para 1's e incluir no cabeçalho.",
                                    "Entender o processo de verificação no receptor: recalcular e comparar com o recebido.",
                                    "Analisar o que acontece em caso de erro detectado: descarte do segmento.",
                                    "Diferenciar checksum (detecção básica) de mecanismos mais avançados como CRC."
                                  ],
                                  "verification": "Calcular manualmente o checksum de um segmento TCP simulado e verificar se corresponde.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 793 (TCP)",
                                    "Calculadora binária ou simulador online de checksum TCP"
                                  ],
                                  "tips": [
                                    "Sempre inclua o próprio campo checksum como zero no cálculo inicial.",
                                    "Pratique com exemplos numéricos para fixar."
                                  ],
                                  "learningObjective": "Explicar precisamente como o TCP usa checksum para detectar corrupção de dados.",
                                  "commonMistakes": [
                                    "Confundir checksum com correção de erros.",
                                    "Ignorar o cabeçalho pseudo-IP no cálculo.",
                                    "Calcular em decimal em vez de hexadecimal."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar as confirmações ACK cumulativas e seletivas",
                                  "subSteps": [
                                    "Definir ACK cumulativo: confirma todos os bytes até o número de sequência especificado.",
                                    "Explicar ACK seletivo (SACK): informa blocos contínuos de dados recebidos corretamente, permitindo retransmissão precisa.",
                                    "Comparar os dois: cumulativo é simples, SACK otimiza em redes com perdas.",
                                    "Analisar o campo ACK no cabeçalho TCP e opções SACK.",
                                    "Simular uma sequência de segmentos com ACKs em diagramas."
                                  ],
                                  "verification": "Desenhar um diagrama de fluxo TCP com ACK cumulativo e SACK para 5 segmentos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de sequência TCP (Wireshark tutoriais)",
                                    "RFC 2018 (TCP Selective Acknowledgment)"
                                  ],
                                  "tips": [
                                    "Visualize ACKs como 'janelas deslizantes' para entender cumulatividade.",
                                    "SACK reduz 'head-of-line blocking' em conexões rápidas."
                                  ],
                                  "learningObjective": "Diferenciar e descrever o papel dos ACKs na confirmação confiável de dados.",
                                  "commonMistakes": [
                                    "Confundir ACK com SYN/ACK de handshake.",
                                    "Achar que ACK seletivo é padrão sem opção.",
                                    "Ignorar impacto na largura de banda."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar temporizadores de retransmissão baseados em RTT",
                                  "subSteps": [
                                    "Explicar RTT (Round-Trip Time): tempo médio de ida e volta estimado.",
                                    "Descrever o algoritmo Jacobson/Karels: RTT amostrado, variação (RTTVAR), RTO = RTTM + 4*RTTVAR.",
                                    "Entender backoff exponencial em retransmissões múltiplas.",
                                    "Estudar o papel do timer no cabeçalho TCP (sem campo explícito, gerenciado pelo SO).",
                                    "Simular cálculo de RTO com exemplos numéricos."
                                  ],
                                  "verification": "Calcular RTO para um RTT de 100ms com variação de 20ms.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "RFC 6298 (Computing TCP's Retransmission Timer)",
                                    "Ferramenta como tcptrace para análise RTT"
                                  ],
                                  "tips": [
                                    "Use smoothed RTT (RTTM = (1-α)RTTM + αRTTs) com α=0.125.",
                                    "Monitore variações em redes reais com ping."
                                  ],
                                  "learningObjective": "Calcular e explicar como o TCP ajusta temporizadores para retransmissões eficientes.",
                                  "commonMistakes": [
                                    "Usar RTT fixo em vez de estimado.",
                                    "Esquecer backoff exponencial.",
                                    "Confundir RTO com keep-alive timers."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar detecção de perda por timeout ou duplicação de ACKs",
                                  "subSteps": [
                                    "Definir detecção por timeout: RTO expira sem ACK, retransmite o segmento mais antigo.",
                                    "Explicar detecção por duplicate ACKs: 3 DUPACKs indicam perda, ativa fast retransmit.",
                                    "Comparar: timeout conservador, DUPACK reativo e rápido.",
                                    "Descrever fast recovery após fast retransmit (RFC 5681).",
                                    "Analisar cenários de perda em rede com Wireshark."
                                  ],
                                  "verification": "Identificar em um trace Wireshark: timeout vs. 3 DUPACKs.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark com captura TCP real",
                                    "RFC 5681 (TCP Congestion Control)"
                                  ],
                                  "tips": [
                                    "3 DUPACKs = perda de 1 segmento; mais indica múltiplas perdas.",
                                    "Fast recovery infla/infla janela de congestão."
                                  ],
                                  "learningObjective": "Descrever triggers de retransmissão e suas diferenças.",
                                  "commonMistakes": [
                                    "Achar que timeout é sempre usado primeiro.",
                                    "Confundir DUPACK com ACK out-of-order.",
                                    "Ignorar limiar de 3 DUPACKs."
                                  ]
                                }
                              ],
                              "practicalExample": "Capture tráfego TCP com Wireshark durante download de um arquivo grande: observe checksums válidos/inválidos (simule erros), ACKs cumulativos/seletivos em perdas artificiais (usando tcpedit), timeouts via netem delay/loss, e DUPACKs/fast retransmit.",
                              "finalVerifications": [
                                "Explicar cálculo e verificação de checksum TCP.",
                                "Diferenciar ACK cumulativo de SACK com exemplo.",
                                "Calcular RTO para RTT dado.",
                                "Descrever sequência de eventos em timeout e 3 DUPACKs.",
                                "Identificar mecanismos em um trace Wireshark.",
                                "Explicar por que esses mecanismos garantem confiabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nos conceitos (checksum, ACK, RTT, perda).",
                                "Uso correto de terminologia RFC (ex: RTO, SACK, fast retransmit).",
                                "Capacidade de exemplos numéricos/diagramas.",
                                "Completude: cobrir todos os 4 mecanismos.",
                                "Clareza na distinção entre detecção e recuperação.",
                                "Aplicação prática via simulação ou análise."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos modulares e estatística em RTT/RTTVAR.",
                                "Física: Propagação de sinais, ruído e perda de pacotes em redes.",
                                "Estatística/Probabilidade: Modelos de perda e backoff exponencial.",
                                "Segurança da Informação: Confiabilidade vs. criptografia em camadas.",
                                "Engenharia de Software: Design de protocolos tolerantes a falhas."
                              ],
                              "realWorldApplication": "Esses mecanismos garantem entrega confiável de dados na internet, como em streaming de vídeo (Netflix), e-mails (Gmail) e transferências financeiras (HTTPS), evitando corrupção ou perda em redes instáveis com latência variável."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Analisar o controle de fluxo via janela deslizante",
                            "description": "Detalhar o mecanismo de janela deslizante no TCP, onde o receptor anuncia o tamanho da janela disponível (rwnd), o remetente ajusta a taxa de envio e o impacto na eficiência da transmissão contínua de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de janela deslizante",
                                  "subSteps": [
                                    "Estude a definição de janela deslizante como um mecanismo para controlar o fluxo de dados em protocolos como TCP.",
                                    "Identifique os componentes chave: sequência de números, tamanho da janela e ponteiros de envio/recebimento.",
                                    "Desenhe um diagrama simples mostrando o buffer do remetente e receptor com janelas sobrepostas.",
                                    "Compare janela deslizante com stop-and-wait para destacar a melhoria em throughput.",
                                    "Revise exemplos iniciais de como a janela 'desliza' à medida que ACKs são recebidos."
                                  ],
                                  "verification": "Desenhe e explique um diagrama de janela deslizante com pelo menos 4 pacotes enviados e ACKs correspondentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagramas de TCP (RFC 793), vídeo tutorial sobre sliding window (Khan Academy ou YouTube), papel e caneta para esboços.",
                                  "tips": "Use setas coloridas no diagrama para representar envio, ACK e deslize da janela.",
                                  "learningObjective": "Explicar o mecanismo de janela deslizante e seus componentes fundamentais.",
                                  "commonMistakes": "Confundir janela deslizante com controle de congestionamento; assumir que é apenas para perda de pacotes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o anúncio de rwnd pelo receptor",
                                  "subSteps": [
                                    "Leia sobre o campo 'Window' no cabeçalho TCP que carrega o rwnd (receive window).",
                                    "Entenda como o receptor calcula rwnd baseado no espaço livre no buffer de recepção.",
                                    "Simule cenários onde rwnd varia: buffer cheio (rwnd=0) vs. buffer vazio (rwnd máximo).",
                                    "Estude o impacto de delays na propagação no anúncio de rwnd atualizado.",
                                    "Capture pacotes reais com Wireshark para observar variações de rwnd em uma conexão TCP."
                                  ],
                                  "verification": "Capture e anote um tráfego TCP mostrando pelo menos duas mudanças no campo Window.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Wireshark instalado, conexão de rede ativa, documentação RFC 793 (seção sobre window).",
                                  "tips": "Filtre por 'tcp.analysis.window_update' no Wireshark para focar em anúncios de janela.",
                                  "learningObjective": "Descrever como e por que o receptor anuncia rwnd dinamicamente.",
                                  "commonMistakes": "Ignorar que rwnd é em bytes, não pacotes; confundir com cwnd (controle de congestão)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar o ajuste da taxa de envio pelo remetente",
                                  "subSteps": [
                                    "Aprenda como o remetente usa o mínimo entre rwnd anunciado e seu próprio cwnd para determinar bytes pendentes.",
                                    "Simule o envio: envie até o limite da janela, pause se rwnd=0 (zero window probing).",
                                    "Estude o algoritmo de zero window probing: envie 1 byte, espere ACK com novo rwnd.",
                                    "Calcule throughput teórico: throughput = rwnd / RTT.",
                                    "Implemente uma simulação simples em Python usando sockets para observar ajustes."
                                  ],
                                  "verification": "Calcule e demonstre throughput para rwnd=16KB e RTT=100ms.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python com biblioteca socket, simulador ns-3 ou tshark, calculadora.",
                                  "tips": "Comece com simulação textual antes de código para visualizar limites de envio.",
                                  "learningObjective": "Explicar como o remetente adapta sua taxa baseada em rwnd.",
                                  "commonMistakes": "Esquecer que rwnd é anunciado pelo receptor, mas ajustado pelo remetente localmente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o impacto na eficiência da transmissão contínua",
                                  "subSteps": [
                                    "Compare eficiência com/sem controle de fluxo: pipe vs. bursty traffic.",
                                    "Analise cenários de mismatch: receptor lento causa buffer overflow sem rwnd.",
                                    "Quantifique ganhos: redução de overhead de ACKs e aumento de utilization da link.",
                                    "Discuta limitações: silly window syndrome e soluções (Nagle, delayed ACKs).",
                                    "Crie um gráfico de throughput vs. rwnd variável em diferentes RTTs."
                                  ],
                                  "verification": "Produza um gráfico ou tabela mostrando eficiência para rwnd=1KB, 64KB em RTT=50ms/500ms.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de plotagem (Excel, Matplotlib), dados simulados de steps anteriores.",
                                  "tips": "Use log scale para rwnd para visualizar melhor impactos em grandes variações.",
                                  "learningObjective": "Quantificar como controle de fluxo via rwnd melhora eficiência em transmissões contínuas.",
                                  "commonMistakes": "Atribuir todos ganhos de throughput ao controle de fluxo, ignorando congestão."
                                }
                              ],
                              "practicalExample": "Em uma transferência de arquivo de 1MB via HTTP/TCP (ex: wget de um servidor web), monitore com Wireshark o rwnd caindo à medida que o buffer do receptor enche durante pico de uso; o remetente reduz envio para ~rwnd/RTT, evitando perdas e retransmissões desnecessárias.",
                              "finalVerifications": [
                                "Explicar em 3 frases o ciclo completo: anúncio rwnd → ajuste envio → deslize janela → impacto eficiência.",
                                "Diagramar um cenário com rwnd=0 e recuperação via probing.",
                                "Calcular throughput para rwnd=32KB, RTT=200ms (esperado: 160KB/s).",
                                "Identificar rwnd em um capture Wireshark de conexão real.",
                                "Comparar com UDP (sem controle de fluxo) em termos de riscos.",
                                "Listar 2 limitações do mecanismo e soluções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de rwnd e seu cálculo (80% dos componentes corretos).",
                                "Correção em diagramas/simulações (sem erros em sequência/ACKs).",
                                "Cálculos de throughput precisos (±10% do valor teórico).",
                                "Análise de impacto qualitativa e quantitativa equilibrada.",
                                "Uso correto de terminologia TCP (rwnd vs cwnd).",
                                "Criatividade em exemplos reais ou simulações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de filas (teoria de colas M/M/1 para buffers).",
                                "Física: Analogia com fluxo de fluidos em tubos (janela como diâmetro).",
                                "Economia: Alocação eficiente de recursos limitados (buffer como capital).",
                                "Engenharia de Software: Design de buffers em aplicações cliente-servidor."
                              ],
                              "realWorldApplication": "Em serviços de streaming como Netflix, o controle de fluxo via rwnd ajusta dinamicamente a taxa de envio de vídeo para evitar buffer underflow no cliente lento, maximizando qualidade sem interrupções, especialmente em redes móveis variáveis."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.4",
                            "name": "Interpretar a estrutura do cabeçalho TCP",
                            "description": "Examinar os campos principais do cabeçalho TCP (20-60 bytes): portas, sequência/ACK numbers, flags (SYN, ACK, FIN, RST), janela, checksum, opções como MSS e timestamps.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral do cabeçalho TCP",
                                  "subSteps": [
                                    "Ler a seção relevante do RFC 793 sobre o formato do cabeçalho TCP.",
                                    "Visualizar e memorizar o diagrama do cabeçalho TCP, identificando os 20 bytes fixos e o campo de opções variáveis.",
                                    "Identificar os principais offsets: portas (0-4), sequência (4-8), ACK (8-12), offset/dados (12-13), flags (13), janela (14-16), checksum (16-18), urgent pointer (18-20).",
                                    "Calcular exemplos de tamanho total: 20 bytes sem opções, até 60 com opções comuns.",
                                    "Comparar com cabeçalho UDP para destacar diferenças."
                                  ],
                                  "verification": "Desenhar manualmente o diagrama do cabeçalho TCP com offsets corretos e rotular todos os campos principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 793 (seção 3.1)",
                                    "Diagrama do cabeçalho TCP de sites como Wireshark ou Cisco"
                                  ],
                                  "tips": "Use cores diferentes para campos fixos e opções ao desenhar para melhor memorização.",
                                  "learningObjective": "Entender a composição espacial e o tamanho variável do cabeçalho TCP.",
                                  "commonMistakes": [
                                    "Confundir offsets com cabeçalho IP",
                                    "Ignorar que opções podem adicionar até 40 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar campos de portas e números de sequência/ACK",
                                  "subSteps": [
                                    "Explicar o propósito das portas de origem e destino (16 bits cada): identificação de sockets.",
                                    "Estudar números de sequência (32 bits): byte inicial da stream de dados.",
                                    "Analisar número de ACK (32 bits): confirmação do próximo byte esperado.",
                                    "Praticar conversões: hexadecimal para decimal em exemplos como seq=0x12345678.",
                                    "Simular handshake: SYN com seq=1000, SYN-ACK com ack=1001."
                                  ],
                                  "verification": "Listar e explicar os valores de portas e seq/ACK em um exemplo de 3-way handshake.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de conversão hex-dec",
                                    "Exemplos de pacotes TCP de tutoriais"
                                  ],
                                  "tips": "Lembre-se: seq conta bytes enviados, ACK confirma recebidos.",
                                  "learningObjective": "Dominar como portas e números gerenciam conexões e fluxo de dados.",
                                  "commonMistakes": [
                                    "Trocar source/dest ports",
                                    "Confundir seq com ACK em respostas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar flags, janela e checksum",
                                  "subSteps": [
                                    "Listar e definir flags principais: SYN (inicia conexão), ACK (confirmação), FIN (fim), RST (reset), URG (urgente).",
                                    "Analisar campo de janela (16 bits): tamanho da janela de recepção para controle de fluxo.",
                                    "Estudar checksum (16 bits): verificação de integridade, calculado sobre pseudo-header + TCP.",
                                    "Simular cenários: pacote com SYN+ACK flags set, janela=65535.",
                                    "Verificar cálculo simples de checksum com ferramenta online."
                                  ],
                                  "verification": "Identificar flags ativas e calcular janela/checksum em um cabeçalho hex fornecido.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora de checksum TCP online",
                                    "Exemplos hex de pacotes Wireshark"
                                  ],
                                  "tips": "Flags são bits individuais no byte 13; memorize mnemônicos como 'SAFR' para SYN,ACK,FIN,RST.",
                                  "learningObjective": "Interpretar controle de conexão, fluxo e integridade via esses campos.",
                                  "commonMistakes": [
                                    "Interpretar janela como absoluta em vez de relativa",
                                    "Ignorar pseudo-header no checksum"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar opções comuns e interpretar cabeçalho completo",
                                  "subSteps": [
                                    "Descrever opções: MSS (Maximum Segment Size, 4 bytes), Timestamps (10 bytes), Window Scale.",
                                    "Calcular data offset: (header length em words de 4 bytes) = 5 + (opções/4).",
                                    "Usar Wireshark para capturar e decodificar um cabeçalho real com opções.",
                                    "Mapear todos os campos em um dump hex completo.",
                                    "Comparar cabeçalhos de diferentes fases: SYN, DATA, FIN."
                                  ],
                                  "verification": "Decodificar um cabeçalho TCP completo de uma captura Wireshark e listar todos os campos com valores e propósitos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Captura de tráfego TCP exemplo (tcpdump ou pcap file)"
                                  ],
                                  "tips": "Filtre por 'tcp' no Wireshark para focar; expanda 'TCP' para ver opções detalhadas.",
                                  "learningObjective": "Integrar todos os campos para análise holística de um cabeçalho TCP.",
                                  "commonMistakes": [
                                    "Errar data offset levando a misparse",
                                    "Ignorar opções em headers expandidos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Wireshark, capture um SYN packet: Source Port: 54321, Dest Port: 80, Seq: 0x1a2b3c4d, SYN flag set, Window: 64240, Checksum: 0xabc1, Options: MSS 1460, Timestamp. Interprete: cliente inicia conexão HTTP com MSS negociado.",
                              "finalVerifications": [
                                "Identificar corretamente source/dest ports e seu papel em sockets.",
                                "Explicar diferença entre seq e ACK numbers com exemplo numérico.",
                                "Listar flags ativas em pacotes SYN, SYN-ACK e FIN.",
                                "Calcular tamanho total do header dado opções.",
                                "Validar checksum em um cabeçalho fornecido.",
                                "Mapear todas opções comuns como MSS e timestamps."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e rotulagem de todos os campos principais (90%+ correto).",
                                "Explicação clara do propósito funcional de cada campo.",
                                "Correta interpretação de um cabeçalho hex real sem erros de offset.",
                                "Demonstração de cálculo de checksum ou data offset.",
                                "Uso correto de ferramentas como Wireshark para validação.",
                                "Conexão lógica entre campos e fases do handshake TCP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de checksum usando soma de 16 bits e carry-over.",
                                "Segurança da Informação: Análise de flags para detecção de scans SYN ou ataques RST.",
                                "Programação: Implementação de sockets TCP em Python/Java usando bibliotecas como socket.",
                                "Física: Analogia de transmissão de dados com ondas e janelas de sinal.",
                                "Estatística: Análise de distribuição de portas e números de sequência em tráfego real."
                              ],
                              "realWorldApplication": "Diagnosticar problemas de conectividade em redes empresariais, configurar firewalls baseados em flags TCP, otimizar throughput via análise de janela e MSS em data centers, ou forense digital em investigações de cibersegurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Controle de Congestionamento no TCP",
                        "description": "Mecanismos do TCP para detectar e responder a congestionamentos na rede, ajustando dinamicamente a taxa de envio para evitar colapso, incluindo fases como Slow Start, Congestion Avoidance, Fast Retransmit e Fast Recovery.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Descrever o algoritmo Slow Start",
                            "description": "Explicar como o TCP inicia com uma janela de congestionamento (cwnd) de 1 MSS, dobrando-a a cada RTT bem-sucedido até o threshold (ssthresh), visando probe rápido da capacidade da rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais do Slow Start",
                                  "subSteps": [
                                    "Defina janela de congestionamento (cwnd) como o limite de dados não confirmados que o remetente pode enviar.",
                                    "Explique MSS (Maximum Segment Size) como o tamanho máximo de um segmento TCP.",
                                    "Descreva RTT (Round-Trip Time) como o tempo para um pacote ir e voltar.",
                                    "Identifique ssthresh (slow start threshold) como o limite para transição de Slow Start para Congestion Avoidance.",
                                    "Relacione esses conceitos ao objetivo de probing rápido da largura de banda da rede."
                                  ],
                                  "verification": "Liste e defina corretamente cwnd, MSS, RTT e ssthresh em um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagramas de TCP de fontes como RFC 5681",
                                    "Vídeo introdutório sobre TCP congestion control (Khan Academy ou similar)"
                                  ],
                                  "tips": "Use analogias como 'cwnd é como o tamanho da mangueira testando o fluxo da rede'.",
                                  "learningObjective": "Compreender os termos chave que formam a base do algoritmo Slow Start.",
                                  "commonMistakes": [
                                    "Confundir cwnd com receive window (rwnd)",
                                    "Ignorar que MSS é em bytes, não pacotes",
                                    "Pensar que RTT é fixo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever a Inicialização do Algoritmo",
                                  "subSteps": [
                                    "Inicie com cwnd = 1 MSS no início da conexão TCP (após SYN/ACK).",
                                    "Configure ssthresh baseado em condições anteriores ou valor alto inicial.",
                                    "Envie o primeiro segmento e aguarde ACK.",
                                    "Explique que no início, apenas 1 MSS é enviado para evitar sobrecarga súbita.",
                                    "Registre o estado inicial em uma tabela de simulação."
                                  ],
                                  "verification": "Crie uma tabela mostrando cwnd inicial = 1 MSS e ssthresh alto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para tabela",
                                    "Ferramenta online como TCP Slow Start simulator"
                                  ],
                                  "tips": "Lembre-se: Slow Start não é 'lento'; é exponencial após o primeiro ACK.",
                                  "learningObjective": "Dominar o ponto de partida conservador do algoritmo.",
                                  "commonMistakes": [
                                    "Assumir cwnd inicia em 0",
                                    "Esquecer ajuste após handshake TCP",
                                    "Confundir com valor padrão moderno de 10 MSS"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Crescimento Exponencial da Janela",
                                  "subSteps": [
                                    "A cada RTT com ACKs bem-sucedidos, dobre cwnd (ex: 1→2→4→8 MSS).",
                                    "Receba ACK cumulativo e aumente cwnd por 1 MSS por ACK recebido.",
                                    "Continue dobrando até cwnd atingir ssthresh.",
                                    "Simule 3-4 RTTs calculando cwnd em cada ciclo.",
                                    "Descreva como isso permite probing rápido sem perda de pacotes."
                                  ],
                                  "verification": "Simule e liste cwnd para 4 RTTs: RTT1:1, RTT2:2, RTT3:4, RTT4:8.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel para simulação",
                                    "RFC 5681 seção 3.1",
                                    "Animais interativos de TCP congestion"
                                  ],
                                  "tips": "Pense em termos de ACKs: cada ACK 'libera' espaço para mais 1 MSS.",
                                  "learningObjective": "Entender o mecanismo de duplicação exponencial por RTT.",
                                  "commonMistakes": [
                                    "Aumentar linearmente em vez de exponencial",
                                    "Contar RTT sem ACKs",
                                    "Ignorar ACKs atrasados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Término e Transição do Slow Start",
                                  "subSteps": [
                                    "Pare de dobrar quando cwnd >= ssthresh e transite para Congestion Avoidance (aumento linear).",
                                    "Descreva reação a perdas: reduza ssthresh para metade cwnd, reset cwnd para 1 MSS.",
                                    "Compare com Fast Recovery em versões modernas.",
                                    "Desenhe um gráfico de cwnd vs. tempo mostrando a curva exponencial.",
                                    "Resuma benefícios: descoberta rápida de capacidade sem congestionamento inicial."
                                  ],
                                  "verification": "Desenhe gráfico com cwnd crescendo exponencialmente até ssthresh.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io",
                                    "Gráficos de exemplo de Wireshark TCP análise"
                                  ],
                                  "tips": "Visualize: a curva 'escada' de cwnd dobra até o platô.",
                                  "learningObjective": "Compreender condições de saída e robustez do algoritmo.",
                                  "commonMistakes": [
                                    "Confundir término com perda obrigatória",
                                    "Esquecer reset em timeout",
                                    "Misturar com Reno/NewReno"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma conexão TCP baixando uma página web: No RTT1, envie 1 MSS (header HTML); RTT2: 2 MSS (imagens iniciais); RTT3: 4 MSS (conteúdo principal), dobrando até detectar capacidade da rede Wi-Fi doméstica, evitando buffer overflow no roteador.",
                              "finalVerifications": [
                                "Descreva verbalmente o ciclo completo de Slow Start em 1 minuto.",
                                "Simule 5 RTTs em papel mostrando valores exatos de cwnd.",
                                "Explique diferença entre Slow Start e Congestion Avoidance.",
                                "Identifique impacto de uma perda no RTT3.",
                                "Desenhe diagrama de sequência TCP com ACKs e crescimento cwnd.",
                                "Compare com UDP (sem controle)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição inicial (cwnd=1 MSS).",
                                "Correta explicação do crescimento exponencial por RTT.",
                                "Entendimento de ssthresh e transição.",
                                "Uso correto de termos técnicos (MSS, ACK cumulativo).",
                                "Capacidade de simular cenários simples.",
                                "Identificação de erros comuns no algoritmo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Crescimento exponencial (2^n) e sequências geométricas.",
                                "Física: Analogia com fluxo de fluidos e largura de banda como vazão.",
                                "Estatística: Probabilidade de perdas em redes e médias de RTT.",
                                "Programação: Implementar simulação em Python com sockets."
                              ],
                              "realWorldApplication": "No carregamento de sites, Slow Start permite que navegadores como Chrome dobrem rapidamente o throughput em conexões novas, otimizando o tempo de carregamento inicial de páginas em redes variáveis como 4G/5G, evitando lentidão ou congestionamento desnecessário."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Explicar o Congestion Avoidance",
                            "description": "Detalhar a fase onde cwnd aumenta linearmente (1 MSS por RTT), mantendo estabilidade após Slow Start, e o ajuste de ssthresh para metade em caso de perda detectada por timeout.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Ativador e Propósito do Congestion Avoidance",
                                  "subSteps": [
                                    "Revise as fases anteriores do controle de congestionamento TCP: Slow Start e seu threshold (ssthresh).",
                                    "Identifique que Congestion Avoidance inicia quando cwnd >= ssthresh.",
                                    "Explique o objetivo: aumentar cwnd de forma conservadora para sondar capacidade da rede sem causar colapso.",
                                    "Compare com Slow Start: exponencial vs. linear.",
                                    "Desenhe um diagrama simples mostrando transição de Slow Start para Congestion Avoidance."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito quando e por quê o Congestion Avoidance é ativado, citando ssthresh.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de fases TCP (papel ou ferramenta como Draw.io)",
                                    "Referência RFC 5681 sobre TCP congestion control"
                                  ],
                                  "tips": "Use analogia de tráfego: Slow Start é acelerar rápido, Congestion Avoidance é manter velocidade constante testando limites.",
                                  "learningObjective": "Compreender o gatilho e rationale da fase Congestion Avoidance no algoritmo TCP.",
                                  "commonMistakes": [
                                    "Confundir com Slow Start (exponencial vs. linear)",
                                    "Ignorar papel do ssthresh como divisor de fases"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detalhar o Aumento Linear do Congestion Window (cwnd)",
                                  "subSteps": [
                                    "Aprenda a regra: cwnd aumenta em 1 MSS por RTT completo (Round-Trip Time).",
                                    "Calcule exemplo: se cwnd=10 MSS e RTT=100ms, após um RTT bem-sucedido, cwnd=11 MSS.",
                                    "Entenda implementação: via ACKs cumulativos, incremento efetivo de 1/cwnd por ACK.",
                                    "Simule 3 RTTs: registre cwnd inicial, ACKs recebidos e novo cwnd.",
                                    "Compare crescimento: após 10 RTTs, aumento de ~10 MSS vs. Slow Start (~1024 MSS)."
                                  ],
                                  "verification": "Simule em tabela: mostre cwnd após 5 RTTs partindo de ssthresh=16 MSS.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel para simulação",
                                    "Ferramenta online como TCP congestion simulator"
                                  ],
                                  "tips": "Lembre: RTT é tempo de ida e volta; conte ACKs para incremento preciso.",
                                  "learningObjective": "Dominar o mecanismo de aumento linear de cwnd (1 MSS/RTT) e sua implementação via ACKs.",
                                  "commonMistakes": [
                                    "Aumentar cwnd por ACK em vez de por RTT",
                                    "Confundir MSS com MTU"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Manutenção de Estabilidade e Sondagem da Rede",
                                  "subSteps": [
                                    "Discuta como crescimento linear previne oscilações: probe lento da banda disponível.",
                                    "Explique 'sawtooth' pattern: cwnd cresce linearmente até perda, então cai.",
                                    "Descreva steady-state: cwnd oscila ao redor capacidade da rede.",
                                    "Compare com Reno/Tahoe: foco em linear probe pós-Slow Start.",
                                    "Crie gráfico: eixo X=RTT, Y=cwnd, mostre fase linear estável."
                                  ],
                                  "verification": "Desenhe e explique gráfico de cwnd vs. RTT mostrando estabilidade linear.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de gráficos como Desmos ou papel quadriculado",
                                    "Vídeo explicativo sobre TCP sawtooth"
                                  ],
                                  "tips": "Pense em elevador lotado: suba devagar para testar capacidade sem sobrecarga.",
                                  "learningObjective": "Explicar como o crescimento linear mantém estabilidade e sonda rede efetivamente.",
                                  "commonMistakes": [
                                    "Achar que é crescimento exponencial contínuo",
                                    "Ignorar padrão sawtooth"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reação a Perdas Detectadas por Timeout",
                                  "subSteps": [
                                    "Defina detecção: timeout de RTO (Retransmission Timeout) indica perda severa.",
                                    "Regra: ssthresh = cwnd/2; cwnd = 1 MSS; reinicia Slow Start.",
                                    "Simule: cwnd=20 MSS, timeout → ssthresh=10, cwnd=1.",
                                    "Diferencie de 3 dup ACKs (fast recovery, não timeout).",
                                    "Registre sequência: perda → timeout → ajuste → Slow Start até ssthresh novo."
                                  ],
                                  "verification": "Explique passo a passo reação a timeout com números exemplo (cwnd inicial=24).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referência RFC 5681 seção timeout",
                                    "Simulador TCP como ns-3 ou online tool"
                                  ],
                                  "tips": "Timeout é 'pânico': rede muito congestionada, reset agressivo.",
                                  "learningObjective": "Compreender ajuste de ssthresh e reset de cwnd em perdas por timeout.",
                                  "commonMistakes": [
                                    "Confundir timeout com 3 dup ACKs (ssthresh/2 mas fast recovery)",
                                    "Não dividir ssthresh por 2 exatamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma conexão TCP baixando um arquivo de 1MB via Wi-Fi congestionado: após Slow Start atingir cwnd=16 MSS (ssthresh), entra em Congestion Avoidance. cwnd cresce 1 MSS/RTT (ex: RTT=50ms, cresce devagar). Se pacote perdido por timeout (RTO=1s), ssthresh=8 MSS, cwnd=1 MSS, reinicia Slow Start até 8, então linear novamente. Monitore com Wireshark: filtre 'tcp.analysis.lost_segment' e observe cwnd via expert info.",
                              "finalVerifications": [
                                "Descreve corretamente ativação quando cwnd >= ssthresh.",
                                "Explica aumento de 1 MSS por RTT com exemplo numérico.",
                                "Diferencia reação a timeout vs. 3 dup ACKs.",
                                "Desenha gráfico sawtooth de cwnd.",
                                "Simula sequência completa: Slow Start → Congestion Avoidance → perda por timeout.",
                                "Compara crescimento linear vs. exponencial."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mecanismo de incremento (1 MSS/RTT via ACKs).",
                                "Correta descrição de thresholds e resets em timeout.",
                                "Uso de analogias ou diagramas para clareza.",
                                "Diferenciação clara de fases TCP.",
                                "Exemplos quantitativos corretos (ex: cwnd após N RTTs).",
                                "Compreensão de estabilidade e probe conservador."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Crescimento linear (sequências aritméticas) vs. exponencial.",
                                "Física: Analogia com fluxo de tráfego e controle de capacidade em tubulações.",
                                "Estatística: Modelagem probabilística de perdas e timeouts.",
                                "Economia: Otimização de recursos em redes compartilhadas (alocação de banda)."
                              ],
                              "realWorldApplication": "No streaming Netflix ou Zoom calls, TCP Congestion Avoidance previne bufferbloat em redes domésticas: cresce taxa de envio linearmente após inicialização rápida, ajusta ssthresh/2 em timeouts (ex: spike de uso na rede), mantendo vídeo fluido sem pausas totais, otimizando throughput em ISPs congestionados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Analisar Fast Retransmit e Fast Recovery",
                            "description": "Descrever triggers (3 ACKs duplicados), retransmissão imediata sem timeout, inflação temporária de cwnd (para 3+ ACKs dup) e recuperação rápida reduzindo cwnd para ssthresh sem reset total.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Triggers do Fast Retransmit",
                                  "subSteps": [
                                    "Estude o mecanismo de ACKs duplicados no TCP: um ACK duplicado é enviado quando um segmento out-of-order é recebido.",
                                    "Identifique o trigger principal: recepção de 3 ACKs duplicados consecutivos pelo remetente.",
                                    "Compare com o timeout RTO: Fast Retransmit age antes do timeout.",
                                    "Revise o diagrama de fluxo TCP para visualizar o estado após 3 ACKs dup.",
                                    "Anote diferenças entre perda de segmento único e múltiplos."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando sequência de pacotes e ACKs que triggeram o Fast Retransmit.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama TCP padrão, Wireshark capture exemplo, notas de aula sobre TCP sequence numbers.",
                                  "tips": "Use animações online como as do Wireshark ou TCP simulators para visualizar ACKs.",
                                  "learningObjective": "Explicar precisamente quando e por que 3 ACKs duplicados indicam perda de pacote.",
                                  "commonMistakes": "Confundir ACK duplicado com ACK perdido; achar que 2 ACKs já triggeram."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Retransmissão Imediata sem Timeout",
                                  "subSteps": [
                                    "Descreva o processo: ao receber 3º ACK dup, retransmita o segmento perdido imediatamente.",
                                    "Simule em pseudocódigo: if (dupACKs >= 3) { retransmit(segment); }",
                                    "Compare performance: reduza latência vs. esperar RTO (tipicamente 200ms+).",
                                    "Examine impacto no throughput: mantém fluxo contínuo.",
                                    "Teste em ferramenta: capture tráfego com perda simulada."
                                  ],
                                  "verification": "Implemente um script simples ou use ns-3 para demonstrar retransmissão sem timeout.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de simulação TCP (ns-3 ou Mininet), pseudocódigo editor.",
                                  "tips": "Foquem em 'duplicate ACK threshold' configurável em stacks TCP.",
                                  "learningObjective": "Demonstrar como Fast Retransmit evita delays desnecessários em perdas isoladas.",
                                  "commonMistakes": "Ignorar que retransmissão é do segmento mais antigo não-ACKed, não necessariamente o último dup ACK."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Inflação Temporária do Congestion Window (cwnd)",
                                  "subSteps": [
                                    "Defina inflação: cwnd = cwnd + 1 por cada ACK dup adicional além dos 3 iniciais.",
                                    "Calcule exemplo: se cwnd=10, ssthresh=20, após 3 dup: cwnd >= ssthresh + 3.",
                                    "Entenda estado: entra em Fast Recovery (não slow start).",
                                    "Modele gráfico: plote cwnd vs. ACKs recebidos.",
                                    "Discuta limite: inflação para permitir ACKs em flight."
                                  ],
                                  "verification": "Crie tabela ou gráfico manual mostrando evolução de cwnd com 5 ACKs dup.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora ou spreadsheet para simular cwnd, gráficos TCP congestion.",
                                  "tips": "Lembre: inflação é 'cwnd +=1 por dupACK' até ACK de novo material.",
                                  "learningObjective": "Calcular e justificar inflação de cwnd para sustentar pipe durante recovery.",
                                  "commonMistakes": "Confundir inflação com multiplicação; achar que volta a slow start imediatamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar a Recuperação Rápida e Redução de cwnd",
                                  "subSteps": [
                                    "Descreva saída: ao receber ACK de recuperação (new ACK), reduza cwnd = ssthresh.",
                                    "Compare com Reno: sem reset total para 1 (slow start).",
                                    "Analise benefícios: preserva throughput alto pós-recovery.",
                                    "Simule fim: cwnd/2 approx via ssthresh, mas permite inflar temporariamente.",
                                    "Revise implementação RFC 5681 para detalhes exatos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o estado final de cwnd após ACK recovery.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "RFC 5681 PDF, simulador TCP congestion control.",
                                  "tips": "ssthresh é min(cwnd/2, flightSize/2) tipicamente.",
                                  "learningObjective": "Diferenciar Fast Recovery de timeout recovery, destacando redução parcial.",
                                  "commonMistakes": "Pensar que cwnd é halved imediatamente; ignorar distinção entre ssthresh e cwnd final."
                                }
                              ],
                              "practicalExample": "Em uma conexão TCP de download de vídeo (ex: YouTube), um pacote é perdido devido a ruído wireless. Receptor envia 3 ACKs dup para o último byte correto. Servidor detecta, retransmite imediatamente o perdido, infla cwnd para 3+ dupACKs, continua enviando novos pacotes, e ao receber ACK recovery, seta cwnd=ssthresh, evitando pausas longas no streaming.",
                              "finalVerifications": [
                                "Pode diagramar sequência exata de ACKs e ações do remetente?",
                                "Calcula corretamente inflação de cwnd para 5 dupACKs?",
                                "Explica diferença entre Fast Retransmit/Recovery e timeout-based recovery?",
                                "Identifica quando Fast Recovery é ativado vs. slow start?",
                                "Simula em ferramenta e verifica ausência de timeout?",
                                "Discute limitações em perdas múltiplas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos triggers (3 dupACKs).",
                                "Correta modelagem de inflação e deflação de cwnd.",
                                "Comparação quantitativa de performance (latência, throughput).",
                                "Uso de diagramas ou simulações para suporte.",
                                "Identificação de erros comuns e exceções (ex: múltiplas perdas).",
                                "Conexão com RFCs ou implementações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de janelas deslizantes e cálculos probabilísticos de perda.",
                                "Física: Analogia com controle de tráfego em rodovias (backpressure).",
                                "Estatística: Análise de distribuições de ACKs em tráfego real.",
                                "Programação: Implementação em sockets TCP ou bibliotecas como Scapy."
                              ],
                              "realWorldApplication": "Melhora eficiência em redes WAN como internet, reduzindo latência em downloads, VoIP e streaming; essencial em data centers (ex: Google TCP tweaks) para lidar com perdas raras sem penalidades excessivas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Nível de Rede: Protocolo IP, Roteamento e SDN",
                    "description": "Plano de dados e controle, algoritmos de roteamento, protocolo IP e Redes Definidas por Software.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Plano de Dados e Plano de Controle",
                        "description": "Conceitos fundamentais da separação entre plano de dados (responsável pelo encaminhamento de pacotes) e plano de controle (responsável por decisões de roteamento e configuração da rede).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Diferenciar plano de dados e plano de controle",
                            "description": "Explicar as funções do plano de dados (forwarding de pacotes baseado em tabelas) e do plano de controle (cálculo de rotas e gerenciamento de switches/roteadores), com exemplos de switches tradicionais versus SDN.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Plano de Dados e Plano de Controle",
                                  "subSteps": [
                                    "Leia definições básicas: plano de dados como camada de forwarding rápido de pacotes, plano de controle como camada de decisão e gerenciamento.",
                                    "Identifique a separação lógica em redes modernas versus integração em hardware tradicional.",
                                    "Desenhe um diagrama simples mostrando os dois planos interagindo em um switch.",
                                    "Pesquise termos chave: forwarding table, routing table, SDN controller.",
                                    "Anote diferenças iniciais em velocidade e complexidade."
                                  ],
                                  "verification": "Crie um diagrama anotado distinguindo os dois planos e explique oralmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Artigos introdutórios sobre SDN (ex: Open Networking Foundation)"
                                  ],
                                  "tips": "Use analogias como 'plano de dados = estrada automática, plano de controle = GPS planejador'.",
                                  "learningObjective": "Dominar definições e arquitetura básica dos planos.",
                                  "commonMistakes": [
                                    "Confundir planos como físicos em vez de lógicos",
                                    "Ignorar a separação em SDN"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Funções do Plano de Dados",
                                  "subSteps": [
                                    "Estude como o plano de dados usa tabelas de forwarding para encaminhar pacotes baseados em headers (MAC/IP).",
                                    "Simule forwarding: trace um pacote de origem A para destino B usando uma tabela estática.",
                                    "Compare hardware: ASICs em switches para alta velocidade sem CPU.",
                                    "Identifique limitações: incapacidade de adaptação dinâmica sem atualizações de tabela.",
                                    "Pratique com ferramenta: use Wireshark para observar forwarding em uma rede local."
                                  ],
                                  "verification": "Descreva o fluxo de um pacote através do plano de dados e liste 3 funções principais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Documentação de forwarding tables"
                                  ],
                                  "tips": "Foque em 'lookup rápido' – o plano de dados é otimizado para throughput, não inteligência.",
                                  "learningObjective": "Entender mecanismos de forwarding e limitações do plano de dados.",
                                  "commonMistakes": [
                                    "Pensar que plano de dados calcula rotas (isso é controle)",
                                    "Subestimar velocidade de hardware dedicado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Funções do Plano de Controle",
                                  "subSteps": [
                                    "Descreva cálculos de rotas usando algoritmos como OSPF ou BGP no plano de controle.",
                                    "Explore gerenciamento: instalação de regras em switches/roteadores via protocolos como OpenFlow.",
                                    "Simule um controller SDN enviando atualizações para múltiplos switches.",
                                    "Compare com tradicional: CPU integrada vs controller centralizado.",
                                    "Liste responsabilidades: topologia discovery, load balancing, falha recovery."
                                  ],
                                  "verification": "Explique como o plano de controle atualiza tabelas do plano de dados em um cenário de falha de link.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Mininet ou simulador SDN",
                                    "Documentos OpenFlow specification",
                                    "Vídeos tutoriais sobre SDN controllers"
                                  ],
                                  "tips": "Visualize como um 'cérebro central' – lento mas esperto, delegando execução ao plano de dados.",
                                  "learningObjective": "Compreender decisões, gerenciamento e protocolos do plano de controle.",
                                  "commonMistakes": [
                                    "Confundir controle com processamento de pacotes individuais",
                                    "Ignorar escalabilidade em SDN"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar em Contextos Tradicionais versus SDN",
                                  "subSteps": [
                                    "Compare switches tradicionais: planos integrados na CPU do dispositivo.",
                                    "Analise SDN: desacoplados, com controller remoto (ex: Ryu, ONOS).",
                                    "Crie tabela comparativa: velocidade, flexibilidade, escalabilidade.",
                                    "Simule exemplo: rede tradicional vs SDN lidando com tráfego bursty.",
                                    "Discuta vantagens SDN: programação centralizada, global view."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e dê 2 exemplos de cada arquitetura.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de tabela como Google Sheets",
                                    "Exemplos de topologias em Packet Tracer/Mininet"
                                  ],
                                  "tips": "Use 'tradicional = rígido e distribuído, SDN = flexível e centralizado'.",
                                  "learningObjective": "Diferenciar arquiteturas e destacar benefícios da separação.",
                                  "commonMistakes": [
                                    "Achar SDN mais lento overall (apenas controle é)",
                                    "Não notar single point of failure em SDN"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede de data center com 4 switches: no modo tradicional, cada switch calcula rotas localmente (plano integrado); em SDN, um controller central (plano de controle) detecta congestão, recalcula rotas e atualiza tabelas de forwarding em todos switches (plano de dados executa). Simule no Mininet: envie tráfego, falhe um link e observe atualizações.",
                              "finalVerifications": [
                                "Explique verbalmente as funções principais de cada plano sem erros.",
                                "Desenhe e label um diagrama de interação entre planos em SDN.",
                                "Diferencie com exemplos: como um pacote é tratado em switch tradicional vs SDN.",
                                "Identifique 3 vantagens da separação em SDN.",
                                "Resolva um cenário: 'O que acontece se o controller falha?'",
                                "Compare tabelas de forwarding vs routing tables."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre forwarding e cálculo de rotas (30%)",
                                "Uso de exemplos relevantes: tradicionais vs SDN (25%)",
                                "Profundidade em funções e limitações (20%)",
                                "Clareza em diagramas/tabelas comparativas (15%)",
                                "Aplicação prática via simulação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grafos e algoritmos de roteamento (Dijkstra, Bellman-Ford).",
                                "Programação: Implementação de controllers SDN em Python (Ryu/POX).",
                                "Segurança da Informação: Políticas de controle para firewalls dinâmicos.",
                                "Engenharia de Software: Arquitetura desacoplada (microservices analogy)."
                              ],
                              "realWorldApplication": "Em provedores de nuvem como Google ou AWS, SDN separa controle (otimização global de tráfego) de dados (milhões de pacotes/segundo), permitindo auto-scaling, fault-tolerance e virtualização de redes em data centers massivos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Identificar vantagens da separação de planos",
                            "description": "Descrever benefícios como maior flexibilidade, programabilidade e escalabilidade, comparando arquiteturas integradas com separadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Arquiteturas de Rede Integradas",
                                  "subSteps": [
                                    "Defina Plano de Dados (forwarding) e Plano de Controle (routing decisions) em roteadores tradicionais.",
                                    "Descreva como ambos os planos estão acoplados no mesmo dispositivo.",
                                    "Identifique limitações iniciais, como rigidez em atualizações e escalabilidade limitada.",
                                    "Pesquise um diagrama de roteador tradicional.",
                                    "Anote exemplos de protocolos como OSPF ou BGP usados no plano de controle."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando os planos integrados e liste 2 limitações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Computer Networking: A Top-Down Approach', diagramas online de roteadores Cisco"
                                  ],
                                  "tips": "Use analogia de um carro onde motor e direção estão fundidos para visualizar o acoplamento.",
                                  "learningObjective": "Entender o funcionamento básico de planos integrados em redes tradicionais.",
                                  "commonMistakes": "Confundir Plano de Dados com camadas físicas; foque em forwarding vs decisões."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Arquiteturas com Separação de Planos (SDN)",
                                  "subSteps": [
                                    "Defina SDN e a separação: Plano de Dados em switches, Plano de Controle em controladores centralizados.",
                                    "Descreva comunicação via protocolos como OpenFlow.",
                                    "Liste componentes chave: switches OpenFlow, controlador SDN (ex: ONOS, Ryu).",
                                    "Compare logicamente com integradas: controle centralizado vs distribuído.",
                                    "Visualize um diagrama SDN básico."
                                  ],
                                  "verification": "Desenhe um diagrama SDN destacando a separação e rotule os fluxos de comunicação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Documentação OpenFlow.org, tutoriais Mininet SDN"
                                  ],
                                  "tips": "Pense no controlador como o 'cérebro' remoto dirigindo múltiplos 'corpos' (switches).",
                                  "learningObjective": "Diferenciar SDN de arquiteturas tradicionais pela separação de planos.",
                                  "commonMistakes": "Achar que SDN elimina hardware; switches ainda são necessários."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Vantagens Específicas da Separação",
                                  "subSteps": [
                                    "Liste flexibilidade: atualizações de políticas sem tocar hardware.",
                                    "Descreva programabilidade: controle via software (APIs, linguagens como Python).",
                                    "Explique escalabilidade: controladores gerenciam milhares de switches.",
                                    "Compare métricas: tempo de deploy de novas regras em integradas vs SDN.",
                                    "Registre outras vantagens como simplicidade de gerenciamento e inovação rápida."
                                  ],
                                  "verification": "Escreva uma tabela comparativa com 3 vantagens e evidências para cada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigos sobre SDN benefits (ex: ONF whitepapers), planilha Google Sheets"
                                  ],
                                  "tips": "Quantifique: SDN pode reduzir tempo de config de horas para minutos.",
                                  "learningObjective": "Associar separação de planos a benefícios mensuráveis.",
                                  "commonMistakes": "Ignorar trade-offs como latência inicial; foque em vantagens principais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação Prática e Sintetizar Benefícios",
                                  "subSteps": [
                                    "Simule cenários: migrar tráfego em data center tradicional vs SDN.",
                                    "Debata prós/cons em um fórum ou auto-reflexão.",
                                    "Crie um resumo: 'Por que separar planos melhora redes modernas?'",
                                    "Pesquise cases reais (Google B4, AT&T).",
                                    "Prepare uma apresentação de 1 minuto explicando uma vantagem chave."
                                  ],
                                  "verification": "Grave um vídeo curto ou escreva parágrafo comparando arquiteturas em um caso real.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta Mininet para simulação básica, cases de estudo SDN"
                                  ],
                                  "tips": "Use bullet points para comparações rápidas: Integrado | Separado | Vantagem.",
                                  "learningObjective": "Sintetizar vantagens em contextos aplicados.",
                                  "commonMistakes": "Generalizar sem exemplos; sempre ancorar em cenários concretos."
                                }
                              ],
                              "practicalExample": "Em um data center, uma arquitetura integrada exige login em cada roteador para atualizar rotas durante pico de tráfego (lento e arriscado). Com SDN, o controlador central envia regras via OpenFlow para todos switches em segundos, permitindo redirecionamento dinâmico sem downtime, ilustrando flexibilidade e escalabilidade.",
                              "finalVerifications": [
                                "Pode listar e explicar 3 vantagens principais sem consultar notas?",
                                "Consegue desenhar diagramas comparativos de ambas arquiteturas?",
                                "Identifica corretamente protocolos como OpenFlow na separação?",
                                "Compara cenários reais mostrando benefícios?",
                                "Explica programabilidade com exemplo de API SDN?",
                                "Discute escalabilidade em contextos de grandes redes?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de planos de dados e controle (90% correto).",
                                "Profundidade na lista de vantagens com exemplos (mínimo 3 bem fundamentados).",
                                "Clareza em comparações visuais ou tabulares.",
                                "Uso correto de terminologia SDN (OpenFlow, controlador).",
                                "Capacidade de aplicar a cenários reais (data centers, clouds).",
                                "Ausência de confusões entre arquiteturas integradas e separadas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de APIs SDN em Python para controle de rede.",
                                "Gestão de Projetos: Escalabilidade em implantações de infraestrutura.",
                                "Matemática: Modelagem de grafos para roteamento otimizado.",
                                "Economia: Redução de custos operacionais em redes corporativas."
                              ],
                              "realWorldApplication": "Empresas como Google usam SDN em sua rede B4 para gerenciar tráfego global com alta escalabilidade, permitindo atualizações programáticas que economizam milhões em hardware e tempo, aplicado em clouds AWS, Azure e telcos para redes 5G dinâmicas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Exemplificar fluxo de operação entre planos",
                            "description": "Traçar o fluxo de um pacote desde o plano de controle (instalação de regras) até o plano de dados (encaminhamento), usando diagramas simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de Plano de Controle e Plano de Dados em SDN",
                                  "subSteps": [
                                    "Estudar a definição de SDN e a separação entre planos de controle e dados.",
                                    "Identificar funções do Plano de Controle: instalação e gerenciamento de regras de fluxo.",
                                    "Identificar funções do Plano de Dados: processamento e encaminhamento de pacotes.",
                                    "Analisar exemplos de protocolos como OpenFlow para comunicação entre planos.",
                                    "Comparar com redes tradicionais sem separação de planos."
                                  ],
                                  "verification": "Escrever um resumo de 3-5 frases diferenciando os dois planos e suas interações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação SDN/OpenFlow",
                                    "Vídeo introdutório sobre SDN (ex: YouTube Mininet tutorial)",
                                    "Diagrama básico de arquitetura SDN"
                                  ],
                                  "tips": "Use analogia de 'cérebro' (controle) e 'músculos' (dados) para fixar conceitos.",
                                  "learningObjective": "Diferenciar funções e interações entre Plano de Controle e Plano de Dados em SDN.",
                                  "commonMistakes": "Confundir instalação de regras (controle) com encaminhamento de pacotes (dados)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear o fluxo de chegada e processamento inicial de um pacote no Plano de Dados",
                                  "subSteps": [
                                    "Descrever a chegada de um pacote a um switch no Plano de Dados.",
                                    "Explicar a consulta à tabela de fluxo (flow table) para matching de regras.",
                                    "Detalhar ações se regra existe: aplicar action (ex: encaminhar porta X).",
                                    "Descrever o que acontece se não há match: pacote é enviado ao controlador.",
                                    "Listar headers de pacote relevantes (ex: IP src/dst, porta TCP)."
                                  ],
                                  "verification": "Desenhar um fluxograma simples do processamento inicial e rotulá-lo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta Draw.io",
                                    "Exemplo de tabela de fluxo OpenFlow"
                                  ],
                                  "tips": "Comece pelo pacote físico: Ethernet frame > IP > TCP/UDP.",
                                  "learningObjective": "Descrever o fluxo inicial de um pacote no Plano de Dados e condições de consulta ao controle.",
                                  "commonMistakes": "Ignorar que o Plano de Dados age reativamente baseado em regras pré-instaladas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a interação com o Plano de Controle para instalação de regras",
                                  "subSteps": [
                                    "Explicar o envio do Packet-In do switch para o controlador.",
                                    "Detalhar processamento no controlador: decisão de regra baseada em políticas.",
                                    "Descrever o retorno via Packet-Out ou Flow-Mod para instalar regra na tabela.",
                                    "Analisar instalação da regra: match fields, actions, contadores.",
                                    "Simular o ciclo: pacote trigger > instalação > pacotes subsequentes usam regra."
                                  ],
                                  "verification": "Escrever sequência de mensagens OpenFlow (Packet-In > Flow-Mod > Packet-Out).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência OpenFlow Switch Specification",
                                    "Simulador Mininet ou Wireshark"
                                  ],
                                  "tips": "Pense no controlador como um 'árbitro' que define regras sob demanda.",
                                  "learningObjective": "Explicar o mecanismo de instalação de regras do Controle para o Dados.",
                                  "commonMistakes": "Achar que todo pacote vai ao controlador; regras são cacheadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar um diagrama simples ilustrando o fluxo completo entre planos",
                                  "subSteps": [
                                    "Esboçar componentes: Host A/B, Switch (Dados), Controlador (Controle).",
                                    "Traçar setas: pacote A->Switch > consulta > Packet-In > Flow-Mod > encaminhamento.",
                                    "Adicionar labels: 'Regra ausente', 'Match encontrado', 'Encaminhado'.",
                                    "Incluir timeline ou estados da tabela de fluxo antes/depois.",
                                    "Refinar para clareza: cores para planos (azul controle, verde dados)."
                                  ],
                                  "verification": "Apresentar diagrama a um par para explicação verbal sem erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io, Lucidchart)",
                                    "Exemplos de diagramas SDN online"
                                  ],
                                  "tips": "Mantenha simples: 5-7 elementos, foque no fluxo linear.",
                                  "learningObjective": "Visualizar e diagramar o fluxo de operação completo entre planos.",
                                  "commonMistakes": "Diagrama muito complexo; omitir retorno do controlador."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simular e validar o fluxo com um exemplo prático",
                                  "subSteps": [
                                    "Escolher cenário: pacote HTTP de Host A (192.168.1.1) para B (192.168.1.2).",
                                    "Simular passo a passo no diagrama: chegada, miss, instalação, hit.",
                                    "Executar simulação em ferramenta (Mininet se possível).",
                                    "Analisar logs: verificar instalação de fluxo e encaminhamento.",
                                    "Documentar variações (ex: regra já existe)."
                                  ],
                                  "verification": "Gravar vídeo curto (1 min) explicando o diagrama com o exemplo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Mininet ou Cisco Packet Tracer",
                                    "Terminal para simulação SDN"
                                  ],
                                  "tips": "Use IPs reais e portas para tornar concreto.",
                                  "learningObjective": "Aplicar o fluxo em um cenário simulado e validar compreensão.",
                                  "commonMistakes": "Não considerar timeouts de regras ou múltiplos switches."
                                }
                              ],
                              "practicalExample": "Em uma rede SDN simples com dois hosts (A: 192.168.1.10 porta 80 para B: 192.168.1.20 porta 80), o switch recebe o primeiro pacote SYN TCP. Sem regra na flow table, envia Packet-In ao controlador Ryu. Controlador instala Flow-Mod (match: srcIP=192.168.1.10,dstIP=192.168.1.20 -> output porta 2). Pacote é encaminhado via Packet-Out, e fluxos subsequentes usam a regra diretamente.",
                              "finalVerifications": [
                                "O diagrama mostra corretamente a chegada do pacote e consulta à flow table?",
                                "A interação Packet-In/Flow-Mod/Packet-Out está representada?",
                                "O fluxo de pacotes subsequentes usa a regra instalada sem nova consulta?",
                                "Headers relevantes (IP, porta) são mencionados no match?",
                                "Há distinção visual entre Plano de Controle e Dados?",
                                "O exemplo prático é traçado end-to-end sem lacunas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Fluxo reflete SDN corretamente (30%)",
                                "Clareza do diagrama: Fácil de seguir, labels adequados (25%)",
                                "Detalhe nos passos: Interações entre planos explícitas (20%)",
                                "Exemplo prático: Concreto e realista (15%)",
                                "Validação: Verificações internas sem erros (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de grafos para topologias de rede e fluxos.",
                                "Programação: Implementação de controladores SDN em Python (Ryu/ONOS).",
                                "Física: Propagação de sinais em cabos Ethernet e latência em switches.",
                                "Administração: Políticas de rede e otimização de tráfego em empresas."
                              ],
                              "realWorldApplication": "Em data centers como o Google B4 ou redes empresariais com Cisco ACI, onde SDN separa controle para otimizar roteamento dinâmico de tráfego de vídeo/conferências, reduzindo latência e permitindo balanceamento automático de carga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Algoritmos de Roteamento",
                        "description": "Algoritmos utilizados no plano de controle para determinar os melhores caminhos para os pacotes em redes de computadores.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Classificar algoritmos de roteamento",
                            "description": "Diferenciar algoritmos adaptativos (distance-vector como RIP e link-state como OSPF) de não adaptativos, explicando métricas como custo e hops.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos fundamentais de roteamento e classificação básica",
                                  "subSteps": [
                                    "Defina roteamento como o processo de seleção de caminhos em uma rede.",
                                    "Classifique algoritmos em adaptativos (ajustam rotas dinamicamente) e não adaptativos (tabelas estáticas).",
                                    "Identifique exemplos iniciais: não adaptativos (tabelas fixas), adaptativos (RIP, OSPF).",
                                    "Revise diferenças chave: atualizações periódicas vs manuais.",
                                    "Anote prós e contras de cada categoria em um diagrama."
                                  ],
                                  "verification": "Crie um fluxograma simples distinguindo adaptativos de não adaptativos com pelo menos 3 exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Artigo introdutório sobre roteamento IP (ex: Cisco Networking Basics)"
                                  ],
                                  "tips": "Use analogias como GPS dinâmico (adaptativo) vs mapa fixo (não adaptativo) para fixar conceitos.",
                                  "learningObjective": "Compreender a distinção fundamental entre algoritmos adaptativos e não adaptativos de roteamento.",
                                  "commonMistakes": [
                                    "Confundir adaptativos com estáticos",
                                    "Ignorar atualizações dinâmicas",
                                    "Não diferenciar protocolos de algoritmos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar algoritmos não adaptativos e suas limitações",
                                  "subSteps": [
                                    "Descreva tabelas de roteamento estáticas: configuração manual de rotas.",
                                    "Explique uso em redes pequenas e estáveis.",
                                    "Discuta limitações: não detectam falhas automaticamente, escalam mal.",
                                    "Simule uma tabela estática para uma rede de 3 roteadores.",
                                    "Compare com adaptativos em termos de manutenção."
                                  ],
                                  "verification": "Configure uma tabela estática hipotética em texto e identifique 2 cenários onde falha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de rede como Packet Tracer (versão gratuita)",
                                    "Documentação de comandos IP route"
                                  ],
                                  "tips": "Teste em simulador para ver impacto de falha de link sem atualização automática.",
                                  "learningObjective": "Dominar características e limitações dos algoritmos não adaptativos.",
                                  "commonMistakes": [
                                    "Subestimar overhead de configuração manual",
                                    "Confundir com default routes",
                                    "Não considerar escalabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar algoritmos distance-vector adaptativos (ex: RIP)",
                                  "subSteps": [
                                    "Explique distance-vector: usa distância (hops) para calcular rotas, atualiza vizinhos.",
                                    "Detalhe RIP: protocolo v1/v2, métrica hops (máx 15), atualizações periódicas.",
                                    "Simule convergência: como rotas se propagam após mudança.",
                                    "Discuta problemas: loops de contagem ao infinito, slow convergence.",
                                    "Calcule rota exemplo: rede com 4 nós, custo em hops."
                                  ],
                                  "verification": "Desenhe tabela de roteamento RIP para rede linear de 4 roteadores e simule falha.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Packet Tracer ou GNS3 para simulação RIP",
                                    "RFC 1058 para RIP specs"
                                  ],
                                  "tips": "Use 'debug ip rip' em simuladores para observar atualizações em tempo real.",
                                  "learningObjective": "Classificar e explicar funcionamento do RIP como distance-vector.",
                                  "commonMistakes": [
                                    "Confundir hops com custo bandwidth",
                                    "Ignorar limite de 15 hops",
                                    "Não entender poison reverse"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar algoritmos link-state adaptativos (ex: OSPF) e métricas",
                                  "subSteps": [
                                    "Descreva link-state: cada roteador conhece topologia completa via flooding de LSAs.",
                                    "Detalhe OSPF: áreas, Dijkstra SPF para caminhos mais curtos, métricas custo (bandwidth-based).",
                                    "Compare com RIP: convergência rápida, sem loops.",
                                    "Explique métricas: hops (quantidade saltos), custo (inverso bandwidth).",
                                    "Classifique ambos em tabela comparativa."
                                  ],
                                  "verification": "Crie tabela comparativa RIP vs OSPF vs estáticos, incluindo métricas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulador com OSPF config",
                                    "RFC 2328 OSPF",
                                    "Vídeo tutorial OSPF vs RIP"
                                  ],
                                  "tips": "Priorize custo sobre hops em cenários reais para otimizar tráfego.",
                                  "learningObjective": "Diferenciar link-state de distance-vector e métricas chave.",
                                  "commonMistakes": [
                                    "Confundir flooding com broadcasting",
                                    "Achar OSPF simples como RIP",
                                    "Ignorar hierarquia de áreas OSPF"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 5 roteadores conectados em malha parcial, configure RIP (distance-vector, métrica hops) e observe convergência lenta após falha de link (5 minutos+). Substitua por OSPF (link-state, métrica custo) e veja reconvergência em segundos, classificando cada um corretamente.",
                              "finalVerifications": [
                                "Classifique corretamente 5 algoritmos como adaptativos ou não adaptativos.",
                                "Explique diferenças RIP (distance-vector, hops) vs OSPF (link-state, custo).",
                                "Simule tabela de roteamento estática vs dinâmica em ferramenta.",
                                "Identifique limitações de cada tipo em cenários reais.",
                                "Compare métricas hops vs custo com exemplos numéricos.",
                                "Crie fluxograma de classificação de algoritmos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção adaptativo vs não adaptativo (80%+ correto).",
                                "Detalhe correto de RIP/OSPF com exemplos de funcionamento.",
                                "Explicação clara de métricas (hops, custo) com cálculos.",
                                "Identificação de prós/contras e limitações práticas.",
                                "Uso de simulações ou diagramas para suporte.",
                                "Tabela comparativa completa e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Algoritmo de Dijkstra para shortest paths.",
                                "Física: Propagação de sinais e latência em links de rede.",
                                "Segurança da Informação: Vulnerabilidades em atualizações de roteamento (ex: BGP hijacking similar).",
                                "Administração: Planejamento de redes em empresas (custo vs performance)."
                              ],
                              "realWorldApplication": "Em provedores de internet como a Verizon, OSPF (link-state) roteia tráfego em backbones globais usando custo baseado em bandwidth para otimizar velocidade, enquanto RIP é usado em redes locais pequenas; tabelas estáticas em DMZs seguras sem mudanças dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Simular algoritmo Distance-Vector",
                            "description": "Executar manualmente iterações do algoritmo RIP em uma topologia simples de 3 roteadores, calculando tabelas de roteamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a topologia da rede e inicializar tabelas de roteamento",
                                  "subSteps": [
                                    "Desenhe uma topologia linear simples com 3 roteadores: A conectado a B (custo 1 hop), B conectado a C (custo 1 hop).",
                                    "Atribua redes locais a cada roteador: Rede A em Roteador A (custo 0), Rede B em B (0), Rede C em C (0).",
                                    "Inicialize a tabela de roteamento de cada roteador: apenas rotas diretas conhecidas (própria rede: 0 hops, vizinhos diretos: 1 hop), outros destinos: infinito (ex: 16 hops no RIP).",
                                    "Anote as tabelas iniciais: A {A:0 via A, B:1 via B, C:∞}, B {A:1 via A, B:0 via B, C:1 via C}, C {A:∞, B:1 via B, C:0 via C}.",
                                    "Confirme que não há rotas indiretas ainda."
                                  ],
                                  "verification": "Tabelas iniciais refletem apenas conexões diretas, com infinito para destinos desconhecidos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de desenho (ex: Draw.io)",
                                    "Caneta e lápis",
                                    "Tabela modelo de roteamento impressa"
                                  ],
                                  "tips": "Use símbolos claros como ∞ para infinito e mantenha colunas consistentes: Destino | Distância | Próximo Salto.",
                                  "learningObjective": "Compreender a inicialização das tabelas em algoritmos Distance-Vector como RIP.",
                                  "commonMistakes": [
                                    "Definir custos iniciais incorretos para vizinhos diretos (deve ser 1 hop)",
                                    "Esquecer de inicializar destinos não conectados como infinito",
                                    "Confundir redes locais com roteadores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a primeira iteração de troca de mensagens RIP",
                                  "subSteps": [
                                    "Simule o envio de mensagens RIP: Cada roteador envia sua tabela atual para vizinhos diretos (A envia para B, B para A e C, C para B).",
                                    "Atualize tabela de A: Recebe de B {A:1, B:0, C:1} → A aprende C via B com custo 1+1=2.",
                                    "Atualize tabela de B: Recebe de A {A:0, B:1, C:∞} (sem mudança para C) e de C {A:∞, B:1, C:0} (aprende A via C? custo 1+1=2, mas já tem melhor via A).",
                                    "Atualize tabela de C: Recebe de B {A:1, B:0, C:1} → C aprende A via B com custo 1+1=2.",
                                    "Registre tabelas após iteração 1: A {A:0, B:1, C:2 via B}, B sem mudanças principais, C {A:2 via B, B:1, C:0}."
                                  ],
                                  "verification": "Cada roteador atualizou rotas com base nas mensagens recebidas, adicionando 1 hop ao custo anunciado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabelas iniciais do passo 1",
                                    "Folha para registrar mensagens enviadas/recebidas"
                                  ],
                                  "tips": "Sempre adicione exatamente 1 ao custo recebido; ignore rotas com custo >=16 (infinito).",
                                  "learningObjective": "Dominar o mecanismo de troca e atualização de distâncias na primeira iteração do RIP.",
                                  "commonMistakes": [
                                    "Não adicionar 1 hop ao custo recebido",
                                    "Atualizar com rotas piores sem comparar",
                                    "Enviar mensagens para não-vizinhos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a segunda iteração de troca de mensagens",
                                  "subSteps": [
                                    "Repita o envio: Use tabelas da iteração 1 como entrada.",
                                    "Atualize A: Recebe de B (agora com C:1) → confirma C:2 via B.",
                                    "Atualize B: Recebe de A (C:2) e C (A:2) → B já tem melhores rotas, sem mudanças.",
                                    "Atualize C: Recebe de B (A:2? B anuncia A:1 de iteração anterior) → confirma A:2 via B.",
                                    "Verifique se houve mudanças: Nesta topologia linear, convergência ocorre aqui."
                                  ],
                                  "verification": "Tabelas após iteração 2 são idênticas às da iteração 1, indicando estabilização parcial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabelas da iteração 1",
                                    "Cronograma de iterações para rastrear mudanças"
                                  ],
                                  "tips": "Compare sempre nova distância com atual: adote se menor ou igual via novo próximo salto.",
                                  "learningObjective": "Identificar propagação de rotas indiretas através de múltiplas iterações.",
                                  "commonMistakes": [
                                    "Propagar distâncias sem incrementar hop count",
                                    "Não detectar rotas melhores já existentes",
                                    "Assumir convergência prematura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar convergência e analisar tabelas finais",
                                  "subSteps": [
                                    "Execute uma terceira iteração para confirmar: Nenhuma mudança deve ocorrer.",
                                    "Liste tabelas finais: A {A:0, B:1 via B, C:2 via B}, B {A:1 via A, B:0, C:1 via C}, C {A:2 via B, B:1 via B, C:0}.",
                                    "Calcule caminhos totais: Ex: De A para C: A→B→C (2 hops).",
                                    "Discuta limitações: Count-to-infinity não ocorre aqui, mas note em loops.",
                                    "Documente o número de iterações para convergência (2 iterações)."
                                  ],
                                  "verification": "Todas tabelas estáveis, com rotas ótimas baseadas em menor número de hops.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Todas tabelas anteriores",
                                    "Gráfico da topologia com caminhos destacados"
                                  ],
                                  "tips": "Marque tabelas estáveis com 'CONVERGIDO'; valide manualmente caminhos.",
                                  "learningObjective": "Avaliar convergência e interpretar tabelas finais em Distance-Vector.",
                                  "commonMistakes": [
                                    "Ignorar split horizon se aplicável (não usado aqui)",
                                    "Erro em próximo salto final",
                                    "Confundir hops com custos assimétricos"
                                  ]
                                }
                              ],
                              "practicalExample": "Topologia: Roteadores A-B-C em linha (A-B:1 hop, B-C:1 hop). Redes: A/24 em A, B/24 em B, C/24 em C. Após convergência: A roteia C via B (2 hops); C roteia A via B (2 hops). Simule em papel ou ferramentas como Packet Tracer para validar.",
                              "finalVerifications": [
                                "Tabelas finais de todos roteadores mostram distâncias corretas: A-C=2, C-A=2.",
                                "Próximos saltos estão corretos (ex: A para C via B).",
                                "Convergência alcançada em <=3 iterações sem loops.",
                                "Nenhuma rota com custo >=16.",
                                "Todos destinos alcançáveis listados.",
                                "Documentação inclui mensagens trocadas por iteração."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de distância (100% correto).",
                                "Correta identificação de atualizações por iteração.",
                                "Explicação clara de regras RIP (hop count +1, infinito=16).",
                                "Análise de convergência e caminhos ótimos.",
                                "Uso consistente de notação e documentação.",
                                "Identificação de potenciais problemas como count-to-infinity."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e menor caminho (Bellman-Ford).",
                                "Física: Propagação de sinais em redes (latência como hops).",
                                "Programação: Implementação em Python com loops de iteração.",
                                "Segurança: Vulnerabilidades em DV como envenenamento de rotas."
                              ],
                              "realWorldApplication": "RIP (RIPv2) usado em redes pequenas/legadas para roteamento automático; simulação essencial para troubleshoot em cenários como falhas de link em LANs empresariais ou ISPs regionais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Explicar algoritmo Link-State",
                            "description": "Descrever o processo de flooding de LSAs, construção de grafo e uso de Dijkstra em OSPF, com exemplo numérico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Link-State Advertisements (LSAs) e o Processo de Flooding",
                                  "subSteps": [
                                    "Defina o que é um LSA: pacotes que contêm informações sobre o estado dos enlaces de um roteador.",
                                    "Explique o flooding: mecanismo onde cada roteador envia LSAs para todos os vizinhos, que por sua vez retransmitem para outros vizinhos, evitando loops com IDs de sequência.",
                                    "Discuta tipos de LSAs em OSPF (ex: Router LSA tipo 1, Network LSA tipo 2).",
                                    "Descreva como o flooding garante sincronização do banco de dados em toda a área OSPF.",
                                    "Identifique o papel do Hello Protocol na detecção de vizinhos para iniciar flooding."
                                  ],
                                  "verification": "Escreva um diagrama simples mostrando um roteador A enviando LSA para B e C, e eles retransmitindo para D.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, diagrama de rede básica, documentação RFC 2328 (OSPFv2).",
                                  "tips": "Use animações online de flooding para visualizar a propagação em rede em estrela ou malha.",
                                  "learningObjective": "Compreender como LSAs são gerados e disseminados para criar uma visão consistente da topologia.",
                                  "commonMistakes": "Confundir flooding com broadcasting simples; lembre-se que é confiável e usa ACKs para retransmissão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Banco de Dados de Estado de Enlace (LSDB)",
                                  "subSteps": [
                                    "Colete LSAs recebidas de todos os roteadores na área OSPF.",
                                    "Armazene LSAs em uma estrutura de dados indexada por ID do roteador e número de sequência.",
                                    "Resolva LSAs mais recentes descartando versões antigas baseadas em Age e Sequence Number.",
                                    "Verifique integridade com checksums e autenticação.",
                                    "Sincronize LSDB com vizinhos via Database Description (DD) packets durante adjacência."
                                  ],
                                  "verification": "Liste os LSAs em uma tabela fictícia para 3 roteadores, indicando seq# e age.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou quadro branco, simulador como GNS3 ou Packet Tracer com OSPF configurado.",
                                  "tips": "Pense no LSDB como uma 'Wikipedia' da rede: todos têm a mesma página atualizada.",
                                  "learningObjective": "Dominar a formação de um banco de dados unificado de topologia de rede.",
                                  "commonMistakes": "Ignorar o papel da sequência no flooding; sempre priorize LSAs com seq# mais alto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Grafo da Rede a partir do LSDB",
                                  "subSteps": [
                                    "Parse cada LSA para extrair vértices (roteadores) e arestas (enlaces com custos).",
                                    "Crie uma matriz de adjacência ou lista de adjacência representando o grafo direcionado ponderado.",
                                    "Inclua custos de enlace baseados em métricas OSPF (ex: bandwidth inversa).",
                                    "Identifique roteadores stub e áreas virtuais se aplicável.",
                                    "Valide o grafo para consistência (sem enlaces unidirecionais inválidos)."
                                  ],
                                  "verification": "Desenhe o grafo para uma rede de 4 nós com enlaces rotulados por custo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de grafos como Graphviz ou draw.io, LSDB de exemplo impresso.",
                                  "tips": "Represente roteadores como nós numerados e enlaces como setas com pesos.",
                                  "learningObjective": "Transformar dados de LSAs em uma representação gráfica da topologia.",
                                  "commonMistakes": "Confundir grafo com árvore; o grafo inicial é completo antes de Dijkstra."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Algoritmo de Dijkstra para Calcular Rotas Mais Curtas",
                                  "subSteps": [
                                    "Inicialize distâncias: 0 para o roteador fonte, infinito para outros.",
                                    "Use fila de prioridade para selecionar nó com menor distância tentadora.",
                                    "Relaxe arestas: para cada vizinho, atualize distância se caminho melhor.",
                                    "Marque nós visitados e repita até todos processados.",
                                    "Construa tabela de roteamento com next-hop e custo cumulativo."
                                  ],
                                  "verification": "Execute Dijkstra manualmente em um grafo de 4 nós e liste distâncias finais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora, pseudocódigo de Dijkstra impresso, simulador OSPF.",
                                  "tips": "Implemente em Python para prática; use heapq para fila eficiente.",
                                  "learningObjective": "Executar shortest path em grafo ponderado a partir da visão local.",
                                  "commonMistakes": "Esquecer de marcar nós como permanentes; sempre use conjunto S de visitados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar Exemplo Numérico Completo do Algoritmo Link-State",
                                  "subSteps": [
                                    "Configure rede exemplo: 4 roteadores A,B,C,D com custos A-B:1, A-C:3, B-C:1, B-D:5, C-D:2.",
                                    "Simule flooding: A gera LSA, flood para todos.",
                                    "Construa LSDB e grafo compartilhado.",
                                    "Execute Dijkstra de A: esperados caminhos A-B (1), A-C (2 via B), A-D (4 via B-C).",
                                    "Compare tabelas de roteamento geradas."
                                  ],
                                  "verification": "Preencha tabela de roteamento final e trace um pacote de A para D.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, vídeo tutorial OSPF Link-State.",
                                  "tips": "Use cores para LSAs de diferentes roteadores no diagrama.",
                                  "learningObjective": "Integrar todos os passos em um exemplo prático com números.",
                                  "commonMistakes": "Calcular caminhos errados; verifique soma de custos em cada relaxação."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com roteadores R1 (ID 1.1.1.1), R2 (2.2.2.2), R3 (3.3.3.3), R4 (4.4.4.4): enlaces R1-R2(custo 10), R1-R3(20), R2-R3(5), R2-R4(30), R3-R4(15). Após flooding de LSAs, cada roteador constrói grafo idêntico e roda Dijkstra de R1, resultando em rota R1->R2->R3->R4 com custo 30 (melhor que direta).",
                              "finalVerifications": [
                                "Descreva verbalmente o flooding de um LSA em uma rede de 5 nós.",
                                "Construa LSDB para rede exemplo com 3 LSAs.",
                                "Desenhe grafo e execute Dijkstra passo a passo.",
                                "Explique diferenças entre Link-State e Distance-Vector.",
                                "Trace pacote usando rotas calculadas.",
                                "Identifique falha: se enlace R2-R3 cai, como rede converge?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de flooding (inclui ACKs e seq#).",
                                "Correção na construção de grafo e LSDB.",
                                "Execução precisa de Dijkstra com relaxações corretas.",
                                "Inclusão de exemplo numérico com cálculos exatos.",
                                "Explicação clara de OSPF contexto.",
                                "Identificação de erros comuns em roteamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Algoritmos de Shortest Path (Dijkstra).",
                                "Programação: Implementação de grafos em Python/Java com heaps.",
                                "Física: Analogia com propagação de ondas (flooding como difusão).",
                                "Segurança: Autenticação de LSAs em OSPF.",
                                "Economia: Otimização de custos em redes (métrica como latência/bandwidth)."
                              ],
                              "realWorldApplication": "No OSPF de protocolos de roteamento em redes empresariais e ISPs, como na backbone da Internet, onde Link-State permite convergência rápida (segundos) após falhas, otimizando tráfego em data centers da AWS ou redes 5G, evitando loops e blackholes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Protocolo IP",
                        "description": "Protocolo principal do nível de rede no modelo TCP/IP, responsável pelo endereçamento, roteamento e entrega de datagramas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Descrever estrutura do datagrama IP",
                            "description": "Analisar campos do cabeçalho IPv4 (versão, comprimento, TTL, protocolo, checksum) e IPv6 (simplificações), com exemplos de encapsulamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito básico de datagrama IP e estrutura geral do cabeçalho IPv4",
                                  "subSteps": [
                                    "Defina datagrama IP como a unidade básica de dados na camada de rede.",
                                    "Identifique que o datagrama consiste em cabeçalho + payload.",
                                    "Descreva o tamanho mínimo e máximo do cabeçalho IPv4 (20 bytes mínimo, até 60 com opções).",
                                    "Liste os 12 campos principais do cabeçalho IPv4 em ordem.",
                                    "Explique o propósito geral do cabeçalho: roteamento e entrega."
                                  ],
                                  "verification": "Desenhe um diagrama simples do cabeçalho IPv4 e rotule os 12 campos corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama de cabeçalho IPv4 (RFC 791), papel e caneta ou ferramenta de desenho como Draw.io.",
                                  "tips": "Use mnemônicos como 'Very Intelligent People Take Home Pizza And Checksum' para lembrar campos.",
                                  "learningObjective": "Compreender a composição e propósito do datagrama IP IPv4.",
                                  "commonMistakes": "Confundir datagrama com frame ( camada de enlace ) ou segmento (TCP)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar campos específicos do cabeçalho IPv4: Versão, Comprimento (IHL), TTL, Protocolo e Checksum",
                                  "subSteps": [
                                    "Versão (4 bits): Confirme valor 4 para IPv4.",
                                    "IHL (Internet Header Length, 4 bits): Calcule comprimento total do cabeçalho (mínimo 5 palavras de 32 bits).",
                                    "TTL (Time To Live, 8 bits): Explique decremento por roteador para evitar loops.",
                                    "Protocolo (8 bits): Associe valores como 6 (TCP), 17 (UDP).",
                                    "Checksum (16 bits): Descreva cálculo (somatório de 16 bits com complemento de 1) e recálculo em cada hop."
                                  ],
                                  "verification": "Calcule manualmente o checksum de um cabeçalho IPv4 de exemplo fornecido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora binária ou Python script para checksum IP, exemplo de cabeçalho hex.",
                                  "tips": "Pratique com Wireshark: capture pacotes e inspecione esses campos em tempo real.",
                                  "learningObjective": "Dominar o papel e cálculo de campos críticos IPv4 para roteamento e integridade.",
                                  "commonMistakes": "Esquecer que checksum é apenas do cabeçalho (não payload) e deve ser recalculado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o cabeçalho IPv6: Simplificações e diferenças chave em relação ao IPv4",
                                  "subSteps": [
                                    "Descreva estrutura fixa de 40 bytes do cabeçalho IPv6 (sem IHL variável).",
                                    "Compare campos: Versão (6), Next Header (substitui Protocolo), Hop Limit (substitui TTL).",
                                    "Note ausência de checksum no cabeçalho (confiança em camadas inferiores).",
                                    "Explique extensões como Hop-by-Hop, Routing para funcionalidades avançadas.",
                                    "Liste endereços IPv6 (128 bits) vs IPv4 (32 bits)."
                                  ],
                                  "verification": "Compare diagramas lado a lado de cabeçalhos IPv4 e IPv6, destacando 5 diferenças principais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "RFC 8200 (IPv6), diagramas comparativos online.",
                                  "tips": "Lembre: IPv6 é 'simples e fixo' para velocidade em roteadores modernos.",
                                  "learningObjective": "Diferenciar IPv6 de IPv4, focando em simplificações para escalabilidade.",
                                  "commonMistakes": "Confundir Hop Limit com TTL (mesmo propósito, nomes diferentes)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplos de encapsulamento de datagrama IP em frames e análise prática",
                                  "subSteps": [
                                    "Descreva encapsulamento: Dados TCP/UDP + IP Header = Datagrama IP → + Ethernet Header/Trailer = Frame.",
                                    "Capture um pacote com Wireshark e identifique cabeçalho IP dentro do frame Ethernet.",
                                    "Analise um exemplo IPv4: trace campos versão=4, TTL decrementando.",
                                    "Simule IPv6: Note next header chain para extensões.",
                                    "Discuta transição dual-stack IPv4/IPv6."
                                  ],
                                  "verification": "Use Wireshark para capturar e anotar 3 pacotes IP, descrevendo encapsulamento.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Wireshark instalado, rede local para captura de tráfego.",
                                  "tips": "Filtre por 'ip' no Wireshark para focar em datagramas IP.",
                                  "learningObjective": "Aplicar conhecimento em cenários reais de encapsulamento e análise.",
                                  "commonMistakes": "Ignorar que IP é 'best effort' sem garantias de entrega."
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture um ping (ICMP sobre IP): Analise cabeçalho IPv4 com versão=4, IHL=5 (20 bytes), TTL=64→63 após roteador, protocolo=1 (ICMP), verifique checksum. Para IPv6, ping6 e note hop limit=64, next header=58 (ICMPv6), sem checksum.",
                              "finalVerifications": [
                                "Desenhar e rotular corretamente cabeçalhos IPv4 e IPv6.",
                                "Calcular checksum IPv4 de um exemplo dado.",
                                "Explicar diferença entre TTL/Hop Limit com exemplo de loop avoidance.",
                                "Identificar protocolo/next header em um dump hex.",
                                "Descrever encapsulamento IP em Ethernet frame.",
                                "Comparar 3 simplificações IPv6 vs IPv4."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de campos (100% corretos).",
                                "Capacidade de calcular checksum IPv4 manualmente.",
                                "Clareza em diagramas e comparações IPv4/IPv6.",
                                "Exemplos práticos com Wireshark ou simulação.",
                                "Entendimento de encapsulamento (camadas OSI).",
                                "Identificação de erros comuns em cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de checksum (aritmética modular 16 bits).",
                                "Física: Transmissão de bits em cabos/rede sem fio.",
                                "Segurança da Informação: Análise de pacotes para detecção de anomalias.",
                                "Programação: Scripts Python com Scapy para gerar/analisar pacotes IP."
                              ],
                              "realWorldApplication": "Em redes empresariais, administradores usam esse conhecimento para diagnosticar problemas de roteamento (TTL expirado), configurar firewalls (filtrar por protocolo), migrar para IPv6 e otimizar tráfego em data centers com SDN."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Explicar endereçamento IP",
                            "description": "Diferenciar classes IPv4, CIDR, subnetting e transição para IPv6 (endereços 128 bits, hierarquia), calculando máscaras de sub-rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as Classes de Endereços IPv4",
                                  "subSteps": [
                                    "Estude a estrutura de um endereço IPv4 (32 bits, 4 octetos).",
                                    "Memorize as classes A, B, C, D, E: ranges (ex: A: 1-126, B: 128-191).",
                                    "Aprenda o número de hosts por classe e máscaras padrão (A: /8, B: /16, C: /24).",
                                    "Pratique convertendo endereços decimais para binários nos primeiros octetos.",
                                    "Identifique endereços reservados (127.0.0.0 loopback, 0.0.0.0 default)."
                                  ],
                                  "verification": "Liste corretamente as 5 classes com ranges, máscaras e hosts máximos sem consultar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagramas de classes IPv4, calculadora binária online (ex: subnet-calculator.com), papel e caneta.",
                                  "tips": "Use mnemônicos: 'A para Grandes redes, C para Pequenas'.",
                                  "learningObjective": "Diferenciar classes IPv4 por tamanho de rede e hosts.",
                                  "commonMistakes": "Confundir range de Classe B (128-191) com C (192-223); ignorar bits de rede/host."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar CIDR e Superação das Classes",
                                  "subSteps": [
                                    "Explique CIDR (Classless Inter-Domain Routing) como alternativa às classes fixas.",
                                    "Aprenda notação /n (prefix length, ex: /24 = 255.255.255.0).",
                                    "Compare classes vs CIDR: CIDR permite alocação flexível (VLSM).",
                                    "Calcule hosts disponíveis: 2^(32-n) - 2.",
                                    "Pratique convertendo máscaras dotted decimal para /n e vice-versa."
                                  ],
                                  "verification": "Converta 5 máscaras aleatórias entre formatos e calcule hosts para cada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabela CIDR (/0 a /32), simulador online como ipcalc.net, exercícios em PDF.",
                                  "tips": "Lembre: /n significa primeiros n bits são rede; conte zeros em binário para hosts.",
                                  "learningObjective": "Explicar como CIDR substitui classes para eficiência.",
                                  "commonMistakes": "Esquecer subtrair 2 hosts (network + broadcast); confundir /n com octetos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Subnetting e Cálculo de Máscaras",
                                  "subSteps": [
                                    "Defina subnetting: dividir rede em sub-redes menores.",
                                    "Aprenda a calcular sub-redes: ex: 192.168.1.0/24 em 4 sub-redes (/26).",
                                    "Pratique: encontre endereço de rede, broadcast, range de hosts.",
                                    "Use método binário: 'empreste' bits de host para rede.",
                                    "Resolva problemas: quantas sub-redes? Máscara nova?"
                                  ],
                                  "verification": "Resolva 3 problemas de subnetting completos (rede, broadcast, hosts) em <10min cada.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Planilha Excel para cálculos binários, app Cisco Packet Tracer, worksheets de subnetting.",
                                  "tips": "Comece pelo binário do último octeto; multiplique por 256 para próximo endereço.",
                                  "learningObjective": "Calcular máscaras e sub-redes manualmente.",
                                  "commonMistakes": "Não alinhar potências de 2; incluir network/broadcast como hosts válidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar IPv6: Estrutura e Hierarquia",
                                  "subSteps": [
                                    "Compare IPv4 (32 bits) vs IPv6 (128 bits, hexadecimal).",
                                    "Estude formato: 8 grupos de 4 hex (ex: 2001:db8::1).",
                                    "Aprenda abreviações: zeros duplos (::), hierarquia (global unicast, link-local).",
                                    "Entenda prefixos: /64 padrão para LANs.",
                                    "Pratique convertendo IPv4 para IPv6 dual-stack."
                                  ],
                                  "verification": "Gere 3 endereços IPv6 válidos e identifique tipos (unicast/multicast).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação RFC 4291, gerador IPv6 online (ipv6-generator.com), vídeos Khan Academy.",
                                  "tips": "Conte 128 bits sempre; :: substitui múltiplos :0000:.",
                                  "learningObjective": "Descrever estrutura e hierarquia IPv6.",
                                  "commonMistakes": "Usar decimais em IPv6; ignorar /64 para SLAAC."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Transição IPv4 para IPv6",
                                  "subSteps": [
                                    "Liste motivos: esgotamento IPv4, simplicidade IPv6 (sem NAT).",
                                    "Estude mecanismos: dual-stack, tunneling (6to4), tradução (NAT64).",
                                    "Compare subnetting: IPv6 fixo /64 vs flexível IPv4.",
                                    "Discuta hierarquia ISP: /48 para clientes.",
                                    "Simule uma transição em rede mista."
                                  ],
                                  "verification": "Descreva prós/contras de 3 estratégias de transição e calcule sub-redes mistas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Diagramas de transição (dual-stack), simulador GNS3, case studies RIPE NCC.",
                                  "tips": "Dual-stack primeiro para compatibilidade gradual.",
                                  "learningObjective": "Explicar transição e diferenças chave.",
                                  "commonMistakes": "Achar IPv6 'só maior'; subestimar auto-config (SLAAC)."
                                }
                              ],
                              "practicalExample": "Em um laboratório com Cisco Packet Tracer: configure uma rede 192.168.0.0/24 dividida em 4 sub-redes (/26), atribua IPs a 3 hosts, teste ping. Em seguida, habilite IPv6 dual-stack com prefixo 2001:db8:1::/64 e verifique conectividade.",
                              "finalVerifications": [
                                "Calcule corretamente sub-redes para 192.168.1.0/24 em 8 sub-redes.",
                                "Converta 255.255.255.192 para /n e identifique hosts.",
                                "Gere endereço IPv6 link-local para MAC 00:11:22:33:44:55.",
                                "Explique por que CIDR resolve desperdício de classes.",
                                "Liste 3 diferenças subnetting IPv4 vs IPv6.",
                                "Simule transição dual-stack em ferramenta online."
                              ],
                              "assessmentCriteria": [
                                "Precisão em cálculos de máscaras e sub-redes (80% correto).",
                                "Compreensão conceitual: explicação clara de CIDR vs classes.",
                                "Habilidade prática: configuração simulada sem erros.",
                                "Profundidade em IPv6: hierarquia e abreviações corretas.",
                                "Integração: ligação transição com problemas reais IPv4.",
                                "Clareza na comunicação: diagramas e exemplos usados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações binárias, potências de 2, conversão base 16.",
                                "Segurança da Informação: Endereçamento seguro em IPv6 (sem NAT).",
                                "Física: Propagação de sinais em redes (latência em transições).",
                                "Administração: Planejamento de alocação de IPs em empresas."
                              ],
                              "realWorldApplication": "Em TI empresarial, configure sub-redes para departamentos (ex: /24 para RH, /26 para Finanças), migre para IPv6 em data centers para escalabilidade infinita, evitando esgotamento de IPs como visto na explosão IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Identificar serviços do IP",
                            "description": "Listar características como best-effort delivery, fragmentação, sem garantias de entrega ou ordem, e relação com ICMP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios fundamentais do Protocolo IP",
                                  "subSteps": [
                                    "Leia a seção introdutória do RFC 791 (Internet Protocol) para entender o escopo do IP como protocolo de datagrama.",
                                    "Identifique que o IP opera no modelo best-effort, sem conexões de estado.",
                                    "Estude o cabeçalho IP básico: versão, comprimento, TTL, protocolo, checksum.",
                                    "Desenhe um diagrama simples de um pacote IP mostrando campos relevantes.",
                                    "Compare IP com protocolos de camada superior como TCP para destacar diferenças."
                                  ],
                                  "verification": "Crie um mapa mental resumindo os princípios do IP e verifique se inclui best-effort e datagrama.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 791 (disponível em ietf.org)",
                                    "Diagramas de cabeçalho IP de sites como geeksforgeeks.org"
                                  ],
                                  "tips": "Foquem no fato de que IP não mantém estado de conexão para escalabilidade.",
                                  "learningObjective": "Entender o IP como serviço de entrega não confiável de datagramas.",
                                  "commonMistakes": [
                                    "Confundir IP com TCP (que adiciona confiabilidade)",
                                    "Ignorar que IP é connectionless"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Best-Effort Delivery e Ausência de Garantias",
                                  "subSteps": [
                                    "Defina best-effort: entrega sem garantias de chegada, ordem ou duplicatas.",
                                    "Simule perda de pacotes em um ambiente Wireshark ou ferramenta online como packetlife.net.",
                                    "Liste cenários onde pacotes IP podem ser descartados: TTL=0, checksum inválido, congestionamento.",
                                    "Discuta implicações: roteadores descartam pacotes sem notificação obrigatória.",
                                    "Compare com correio postal: envia mas não garante entrega."
                                  ],
                                  "verification": "Explique em voz alta por que um email pode chegar fora de ordem via IP puro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark (gratuito)",
                                    "Simulador de rede como Cisco Packet Tracer"
                                  ],
                                  "tips": "Lembre-se: TCP constrói sobre IP para adicionar garantias.",
                                  "learningObjective": "Identificar e exemplificar a natureza não confiável do IP.",
                                  "commonMistakes": [
                                    "Achar que IP garante ordem (isso é TCP)",
                                    "Confundir best-effort com unreliable sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Fragmentação e Reassembly",
                                  "subSteps": [
                                    "Aprenda sobre MTU (Maximum Transmission Unit) e por que fragmentação ocorre.",
                                    "Analise campos no cabeçalho IP: Identification, Fragment Offset, Flags (DF, MF).",
                                    "Capture pacotes fragmentados no Wireshark e reconstrua-os mentalmente.",
                                    "Entenda reassembly no destino (não em roteadores intermediários).",
                                    "Teste enviando pacotes grandes via ping com tamanho > MTU."
                                  ],
                                  "verification": "Gere um pacote fragmentado e liste os offsets corretos para reassembly.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Comando ping com -s (ex: ping -s 3000 google.com)"
                                  ],
                                  "tips": "DF flag previne fragmentação; use para Path MTU Discovery.",
                                  "learningObjective": "Descrever como IP gerencia pacotes grandes via fragmentação.",
                                  "commonMistakes": [
                                    "Pensar que roteadores fazem reassembly",
                                    "Ignorar overhead de fragmentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Relação com ICMP e Síntese dos Serviços",
                                  "subSteps": [
                                    "Estude ICMP como protocolo auxiliar do IP (Type 3: Destination Unreachable, Type 11: Time Exceeded).",
                                    "Capture ICMP via ping e identifique mensagens de erro relacionadas a IP.",
                                    "Liste serviços IP completos: roteamento, endereçamento, fragmentação, best-effort + ICMP para feedback.",
                                    "Crie uma tabela comparando serviços IP vs. TCP/UDP.",
                                    "Resuma em um quiz pessoal: 'Quais garantias IP NÃO fornece?'"
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre serviços IP e ICMP.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação ICMP RFC 792",
                                    "Wireshark filtro: icmp"
                                  ],
                                  "tips": "ICMP não é para dados, só controle/erros.",
                                  "learningObjective": "Conectar ICMP aos serviços IP e sintetizar características chave.",
                                  "commonMistakes": [
                                    "Usar ICMP para dados (é só signaling)",
                                    "Confundir ICMP com IP propriamente dito"
                                  ]
                                }
                              ],
                              "practicalExample": "Use Wireshark para capturar tráfego de um ping com tamanho grande (-s 2000): observe fragmentação IP, best-effort (perda simulada via firewall), e ICMP Time Exceeded se TTL baixo. Liste offsets e confirme ausência de ordem garantida.",
                              "finalVerifications": [
                                "Liste corretamente 4 serviços principais do IP: best-effort, fragmentação, sem garantias de entrega/ordem, suporte via ICMP.",
                                "Explique com diagrama como um pacote é fragmentado e remontado.",
                                "Simule perda de pacote e descreva resposta ICMP esperada.",
                                "Diferencie IP de TCP em termos de garantias.",
                                "Capture e anote um pacote IP real mostrando campos relevantes.",
                                "Responda: 'Por que IP é escalável apesar de best-effort?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de best-effort e exemplos concretos (80%+ correto).",
                                "Compreensão de fragmentação: identificação correta de campos e processo.",
                                "Correta relação IP-ICMP sem confusões.",
                                "Uso de ferramentas como Wireshark com evidências (screenshots/anotações).",
                                "Síntese: tabela ou lista clara de serviços sem omissões.",
                                "Criatividade em analogias reais (ex: correio postal)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de checksum IP (aritmética modular de 16 bits).",
                                "Física: Analogia com propagação de sinais em redes (perdas por ruído).",
                                "Segurança da Informação: Vulnerabilidades ICMP (ex: ping flood).",
                                "Estatística: Probabilidades de perda em redes congestionadas."
                              ],
                              "realWorldApplication": "Na internet cotidiana, todo tráfego HTTP/HTTPS usa IP best-effort; navegadores/streaming lidam com perdas/fragmentação via TCP/QUIC. Roteadores globais dependem de fragmentação para MTUs variados, e ICMP diagnostica falhas (ex: traceroute usa ICMP Time Exceeded)."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.4",
                        "name": "Redes Definidas por Software (SDN)",
                        "description": "Abordagem moderna que separa o plano de controle do plano de dados, permitindo programação centralizada da rede.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.4.1",
                            "name": "Descrever arquitetura SDN",
                            "description": "Explicar camadas: plano de dados (switches OpenFlow), plano de controle (controlador como ONOS ou Ryu) e plano de aplicação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de SDN",
                                  "subSteps": [
                                    "Pesquisar a definição de SDN (Software-Defined Networking) e sua evolução histórica.",
                                    "Comparar SDN com redes tradicionais, destacando a separação de planos de controle e dados.",
                                    "Identificar os principais benefícios: flexibilidade, programabilidade e gerenciamento centralizado.",
                                    "Listar os componentes principais da arquitetura SDN: plano de dados, controle e aplicação.",
                                    "Explicar o papel da interface southbound e northbound."
                                  ],
                                  "verification": "Criar um resumo de 1 parágrafo explicando SDN e listar 3 benefícios principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet para artigos sobre SDN",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use diagramas simples para visualizar a separação de planos desde o início.",
                                  "learningObjective": "Compreender os fundamentos e motivações da arquitetura SDN.",
                                  "commonMistakes": [
                                    "Confundir SDN com virtualização de redes",
                                    "Ignorar a importância da programabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o Plano de Dados",
                                  "subSteps": [
                                    "Explicar o papel do plano de dados: encaminhamento de pacotes em switches e roteadores.",
                                    "Detalhar switches OpenFlow: protocolo padrão para comunicação com controladores.",
                                    "Descrever flux tables e como as regras de fluxo são instaladas pelo controlador.",
                                    "Exemplificar o fluxo de um pacote: match-action em tabelas de fluxo.",
                                    "Discutir protocolos alternativos como P4 para switches programáveis."
                                  ],
                                  "verification": "Desenhar um diagrama de um switch OpenFlow recebendo uma regra de fluxo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io ou papel e caneta",
                                    "Documentação OpenFlow oficial"
                                  ],
                                  "tips": "Foquem em exemplos concretos de regras de fluxo para fixar o conceito.",
                                  "learningObjective": "Dominar o funcionamento do plano de dados e switches OpenFlow.",
                                  "commonMistakes": [
                                    "Achar que switches SDN são apenas hardware comum",
                                    "Confundir plano de dados com roteamento tradicional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o Plano de Controle",
                                  "subSteps": [
                                    "Definir o plano de controle: cérebro da rede, gerenciando switches via APIs.",
                                    "Apresentar controladores populares: ONOS (escalável), Ryu (Python-based), OpenDaylight.",
                                    "Explicar comunicação southbound: OpenFlow para instalar fluxos nos switches.",
                                    "Discutir funções: cálculo de caminhos, balanceamento de carga, detecção de falhas.",
                                    "Explorar APIs REST ou gRPC para integração com aplicações."
                                  ],
                                  "verification": "Listar 3 funções de um controlador e descrever como ele se comunica com um switch.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de Ryu ou ONOS online",
                                    "Vídeos tutoriais curtos sobre controladores SDN"
                                  ],
                                  "tips": "Instale um mininet virtual para testar conceitos se possível.",
                                  "learningObjective": "Entender o papel central do controlador SDN e exemplos práticos.",
                                  "commonMistakes": [
                                    "Subestimar a necessidade de alta disponibilidade no controlador",
                                    "Confundir southbound com northbound"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever o Plano de Aplicação e Visão Geral",
                                  "subSteps": [
                                    "Explicar o plano de aplicação: apps que usam políticas de alto nível via northbound API.",
                                    "Exemplos de apps: firewall SDN, load balancer, monitoramento de tráfego.",
                                    "Descrever integrações: REST APIs, linguagens como Python para desenvolver apps.",
                                    "Montar uma visão geral: interações entre os 3 planos com um diagrama completo.",
                                    "Discutir desafios: latência, escalabilidade e segurança entre planos."
                                  ],
                                  "verification": "Criar um diagrama completo da arquitetura SDN com labels para cada plano e interfaces.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação",
                                    "Exemplos de apps SDN de repositórios GitHub"
                                  ],
                                  "tips": "Use setas no diagrama para mostrar fluxo de controle e dados.",
                                  "learningObjective": "Integrar todos os planos em uma descrição coesa da arquitetura SDN.",
                                  "commonMistakes": [
                                    "Omitir as interfaces de comunicação",
                                    "Ignorar apps reais no plano de aplicação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 5 switches conectados a servidores web, use um controlador Ryu no plano de controle para instalar regras OpenFlow que direcionem tráfego de alta prioridade para caminhos curtos, enquanto apps no plano de aplicação monitoram latência via northbound API e ajustam dinamicamente.",
                              "finalVerifications": [
                                "Descrever verbalmente as 3 camadas principais da arquitetura SDN.",
                                "Explicar o papel de um switch OpenFlow com um exemplo de regra de fluxo.",
                                "Nomear pelo menos 2 controladores SDN e suas linguagens principais.",
                                "Desenhar um diagrama básico mostrando interações entre planos.",
                                "Identificar uma aplicação real no plano de aplicação.",
                                "Comparar SDN com rede tradicional em 2 pontos chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das 3 camadas (plano de dados, controle, aplicação).",
                                "Correta identificação de protocolos como OpenFlow e exemplos de controladores.",
                                "Completude do diagrama com interfaces southbound/northbound.",
                                "Uso de exemplos práticos e concretos.",
                                "Clareza na explicação de interações entre planos.",
                                "Ausência de confusões com conceitos de redes tradicionais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de controladores e apps em Python (Ryu).",
                                "Segurança da Informação: Implementação de firewalls e detecção de intrusões via SDN.",
                                "Matemática: Algoritmos de roteamento otimizado (grafos e caminhos mínimos).",
                                "Gestão de Projetos: Escalabilidade e deploy de redes SDN em ambientes empresariais.",
                                "Inteligência Artificial: Apps SDN com ML para previsão de tráfego."
                              ],
                              "realWorldApplication": "Em data centers do Google (usando OpenFlow e controladores customizados) para balanceamento dinâmico de tráfego, reduzindo latência em 30%; ou em redes 5G de operadoras como Verizon, onde SDN gerencia slicing de rede para serviços diferenciados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.4.2",
                            "name": "Exemplificar protocolo OpenFlow",
                            "description": "Descrever fluxos, tabelas de fluxo e match-action em switches SDN, com exemplo de regra para roteamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de SDN e OpenFlow",
                                  "subSteps": [
                                    "Estude a arquitetura SDN: plano de dados, plano de controle e plano de gerenciamento.",
                                    "Leia a definição oficial do protocolo OpenFlow no site da Open Networking Foundation (ONF).",
                                    "Identifique os papéis principais: switch OpenFlow, controlador SDN e protocolo de comunicação.",
                                    "Assista a um vídeo introdutório de 5 minutos sobre SDN vs. redes tradicionais.",
                                    "Anote as diferenças chave entre switches legados e switches SDN."
                                  ],
                                  "verification": "Resuma em 3 frases os componentes principais da arquitetura SDN e o papel do OpenFlow.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Site da ONF (opennetworking.org)",
                                    "Vídeo introdutório no YouTube sobre SDN",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Comece pelo diagrama de arquitetura SDN para visualizar melhor.",
                                  "learningObjective": "Entender a base conceitual de SDN e como OpenFlow separa controle de dados.",
                                  "commonMistakes": [
                                    "Confundir OpenFlow com SDN (OpenFlow é o protocolo sul da SDN)",
                                    "Ignorar o papel do controlador SDN"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Fluxos e Tabelas de Fluxo em OpenFlow",
                                  "subSteps": [
                                    "Defina 'fluxo' como uma sequência de pacotes com características comuns (match fields).",
                                    "Descreva a estrutura de uma tabela de fluxo: conjunto de entradas com match, action e contadores.",
                                    "Estude como os switches processam pacotes: lookup na tabela, match ou Packet-In para controlador.",
                                    "Desenhe um diagrama simples de uma tabela de fluxo com 3 entradas exemplo.",
                                    "Simule o processamento de um pacote em uma tabela vazia."
                                  ],
                                  "verification": "Crie um esboço de tabela de fluxo com pelo menos 2 entradas e explique o fluxo de um pacote.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação OpenFlow Switch Specification (versão 1.3+)",
                                    "Ferramenta de desenho como Draw.io",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Use analogia de 'tráfego de rua' onde fluxos são rotas e tabelas são semáforos.",
                                  "learningObjective": "Dominar como fluxos são armazenados e processados em tabelas de switches OpenFlow.",
                                  "commonMistakes": [
                                    "Pensar que tabelas de fluxo são estáticas (elas são dinâmicas via controlador)",
                                    "Esquecer contadores de pacotes/bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Match Fields e Actions",
                                  "subSteps": [
                                    "Liste match fields comuns: entrada/saída port, Ethernet src/dst, IP src/dst, TCP/UDP ports.",
                                    "Explique ações: forward (output ports), drop, modify (set fields como VLAN, IP TTL).",
                                    "Estude prioridades: higher priority matches first.",
                                    "Crie exemplos de match-action para drop de pacotes ICMP e forward de HTTP.",
                                    "Compare com wildcards (*) para matches parciais."
                                  ],
                                  "verification": "Escreva 2 regras match-action: uma para rotear IPv4 e outra para bloquear porta 80.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Especificação OpenFlow (seção 5: Flow Table)",
                                    "Mininet ou Wireshark para visualização opcional"
                                  ],
                                  "tips": "Lembre-se: match é como uma chave, action é a decisão.",
                                  "learningObjective": "Saber especificar matches precisos e ações associadas em regras OpenFlow.",
                                  "commonMistakes": [
                                    "Confundir match fields com actions",
                                    "Ignorar ordem de prioridade nas tabelas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar Regra de Roteamento com OpenFlow",
                                  "subSteps": [
                                    "Escolha um cenário: rotear tráfego de host A (10.0.0.1) para host B (10.0.0.2) via switch.",
                                    "Escreva uma regra: match IP dst=10.0.0.2, action=output port 2, set next hop.",
                                    "Simule instalação da regra via controlador (ex: Ryu ou POX).",
                                    "Teste com ferramenta como Mininet: envie ping e verifique fluxos.",
                                    "Analise logs do switch para confirmar match-action."
                                  ],
                                  "verification": "Implemente e demonstre uma regra de roteamento em Mininet, capturando tráfego com tcpdump.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Mininet instalado",
                                    "Controlador SDN como Ryu/POX",
                                    "tcpdump ou Wireshark"
                                  ],
                                  "tips": "Use comandos Mininet: mn --topo single,3 --controller remote para teste rápido.",
                                  "learningObjective": "Aplicar conceitos em um exemplo prático de roteamento SDN.",
                                  "commonMistakes": [
                                    "Esquecer de instalar regra no switch",
                                    "Não limpar fluxos antigos com 'dpctl del-flows'"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um data center, uma regra OpenFlow no switch S1: match(in_port=1, ip_dst=192.168.1.100), action(set_field(vlan_vid=10), output=2). Isso roteia tráfego de porta 1 para porta 2, adicionando VLAN 10 para segmentação, permitindo isolamento de VMs sem hardware dedicado.",
                              "finalVerifications": [
                                "Descreva corretamente uma tabela de fluxo com match-action.",
                                "Explique o processo Packet-In/Packet-Out.",
                                "Crie uma regra válida para roteamento IPv4 simples.",
                                "Diferencie SDN tradicional de OpenFlow 1.3+ (múltiplas tabelas).",
                                "Simule um fluxo em Mininet sem erros.",
                                "Identifique erros comuns em regras match-action."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de fluxos e tabelas (80% cobertura de conceitos chave).",
                                "Correção sintática em exemplos de regras OpenFlow.",
                                "Profundidade nos substeps com pelo menos 4 ações por step.",
                                "Uso correto de terminologia (match fields, actions, priorities).",
                                "Demonstração prática via simulação ou diagrama.",
                                "Conexão clara com roteamento SDN."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em match fields (AND/OR com wildcards).",
                                "Programação: Scripts em Python para controladores SDN (Ryu/ONOS).",
                                "Física: Propagação de sinais em redes ópticas para SDN em larga escala.",
                                "Segurança da Informação: Regras OpenFlow para firewalls dinâmicos."
                              ],
                              "realWorldApplication": "Em provedores de nuvem como Google ou AWS, OpenFlow otimiza roteamento em data centers, reduzindo latência em 30-50% via caminhos dinâmicos baseados em tráfego real-time, e em telcos para 5G slicing de rede."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.4.3",
                            "name": "Listar vantagens e desafios do SDN",
                            "description": "Discutir benefícios (gerenciamento centralizado, inovação rápida) e problemas (single point of failure, escalabilidade do controlador).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de SDN",
                                  "subSteps": [
                                    "Defina SDN e seus componentes principais: plano de dados, plano de controle e plano de aplicação.",
                                    "Compare SDN com redes tradicionais, destacando a separação de controle e forwarding.",
                                    "Identifique o papel do controlador SDN e switches compatíveis.",
                                    "Estude a arquitetura OpenFlow como protocolo padrão para SDN.",
                                    "Anote diferenças chave em um diagrama simples."
                                  ],
                                  "verification": "Crie um diagrama ou mapa mental resumindo os componentes e diferenças do SDN.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo 'What is SDN?' do Open Networking Foundation (ONF)",
                                    "Vídeo 'SDN Explained' no YouTube (10-15 min)",
                                    "Papel e caneta ou ferramenta como Draw.io"
                                  ],
                                  "tips": "Use analogias como 'tráfego de cidade' onde o controlador é o 'centro de controle'.",
                                  "learningObjective": "Compreender a arquitetura SDN para contextualizar vantagens e desafios.",
                                  "commonMistakes": "Confundir SDN com virtualização de rede; SDN foca em programação centralizada, não apenas virtualização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Listar Vantagens do SDN",
                                  "subSteps": [
                                    "Pesquise gerenciamento centralizado: como um controlador único simplifica configurações.",
                                    "Liste inovação rápida: atualizações de software sem hardware.",
                                    "Discuta programabilidade: APIs para automação e orquestração.",
                                    "Explore escalabilidade em redes grandes e otimização de tráfego dinâmica.",
                                    "Colete pelo menos 4 vantagens com exemplos breves."
                                  ],
                                  "verification": "Escreva uma lista de 4-6 vantagens com uma frase explicativa cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Cisco SDN",
                                    "Blog 'Advantages of SDN' da VMware",
                                    "Notas do Step 1"
                                  ],
                                  "tips": "Priorize vantagens mensuráveis, como redução de 50% no tempo de configuração.",
                                  "learningObjective": "Reconhecer benefícios operacionais e estratégicos do SDN.",
                                  "commonMistakes": "Ignorar contextos específicos; vantagens variam por escala (ex: data centers vs. enterprise)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Listar Desafios do SDN",
                                  "subSteps": [
                                    "Analise single point of failure: falha no controlador afeta toda a rede.",
                                    "Discuta escalabilidade do controlador: gargalos em redes muito grandes.",
                                    "Explore complexidade de segurança: superfície de ataque maior no plano de controle.",
                                    "Considere dependência de hardware compatível e custos iniciais.",
                                    "Liste 4-6 desafios com impactos potenciais."
                                  ],
                                  "verification": "Crie uma tabela comparando desafios com mitigações possíveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo 'Challenges in SDN' da IEEE",
                                    "Whitepaper 'SDN Risks' da NIST",
                                    "Notas do Step 2"
                                  ],
                                  "tips": "Pense em soluções como controladores distribuídos (ex: ONOS) para mitigar.",
                                  "learningObjective": "Avaliar limitações técnicas e operacionais do SDN.",
                                  "commonMistakes": "Superestimar desafios sem evidências; baseie em casos reais como falhas em controladores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Vantagens e Desafios em uma Lista Balanceada",
                                  "subSteps": [
                                    "Compile listas de vantagens e desafios em um documento unificado.",
                                    "Adicione prós e contras lado a lado para comparação.",
                                    "Discuta trade-offs: como benefícios superam desafios em cenários específicos.",
                                    "Prepare uma apresentação ou resumo verbal de 2 minutos.",
                                    "Revise para clareza e precisão."
                                  ],
                                  "verification": "Apresente ou grave um resumo listando 5 vantagens e 5 desafios com justificativas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta Google Docs ou PowerPoint",
                                    "Notas dos Steps 2 e 3",
                                    "Gravador de áudio"
                                  ],
                                  "tips": "Use bullet points numerados para listas claras e impactantes.",
                                  "learningObjective": "Capacitar-se a discutir SDN de forma equilibrada e informada.",
                                  "commonMistakes": "Lista desbalanceada; garanta igual ênfase em prós e contras."
                                }
                              ],
                              "practicalExample": "Em um data center da Google, SDN permite gerenciar milhões de fluxos de tráfego via controlador centralizado (vantagem: otimização rápida), mas uma falha no controlador poderia parar serviços (desafio: single point of failure), mitigada com controladores redundantes.",
                              "finalVerifications": [
                                "Lista pelo menos 4 vantagens com explicações precisas.",
                                "Identifica 4 desafios principais, incluindo single point of failure e escalabilidade.",
                                "Compara SDN tradicional vs. SDN em um diagrama.",
                                "Explica um trade-off real, como custo vs. flexibilidade.",
                                "Apresenta síntese oral ou escrita sem erros conceituais.",
                                "Sugere uma mitigação para cada desafio listado."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todas as vantagens e desafios chave cobertos (80%+).",
                                "Precisão: Conceitos SDN corretos, sem confusões com NFV ou SDN tradicional.",
                                "Profundidade: Explicações vão além de listas superficiais, com exemplos.",
                                "Equilíbrio: Vantagens e desafios tratados de forma imparcial.",
                                "Clareza: Listas organizadas, linguagem acessível e sem jargões não explicados.",
                                "Criatividade: Inclui conexões reais ou mitigações inovadoras."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos de otimização de grafos para roteamento SDN.",
                                "Administração: Gerenciamento de projetos ágeis em implantações SDN.",
                                "Segurança da Informação: Análise de riscos em controladores centralizados.",
                                "Economia: Análise custo-benefício de SDN em infraestruturas empresariais."
                              ],
                              "realWorldApplication": "Empresas como Amazon AWS e Microsoft Azure usam SDN para escalar serviços de nuvem dinamicamente, reduzindo latência em 30-50%, mas implementam clusters de controladores para evitar falhas únicas, demonstrando equilíbrio entre vantagens e desafios."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.6",
                    "name": "Nível de Enlace: Padrões IEEE",
                    "description": "Padrões IEEE para comunicação no nível de enlace de dados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.6.1",
                        "name": "IEEE 802.3 (Ethernet)",
                        "description": "Padrão IEEE para redes locais cabeadas, definindo o formato de quadros, controle de acesso ao meio via CSMA/CD e velocidades variadas como 10 Mbps, 100 Mbps, 1 Gbps e superiores.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.1.1",
                            "name": "Identificar a estrutura do quadro Ethernet",
                            "description": "Descrever os campos do quadro Ethernet, incluindo preâmbulo, endereços MAC de origem e destino, tipo/length, dados, CRC e seu propósito na detecção de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura geral do quadro Ethernet",
                                  "subSteps": [
                                    "Pesquise e memorize os componentes principais: Preamble (7 bytes), SFD (1 byte), Destination MAC (6 bytes), Source MAC (6 bytes), Length/Type (2 bytes), Data (46-1500 bytes), Pad (opcional), FCS/CRC (4 bytes).",
                                    "Desenhe um diagrama linear representando a sequência dos campos com seus tamanhos aproximados.",
                                    "Identifique o tamanho mínimo e máximo do quadro (64 a 1518 bytes sem VLAN tag).",
                                    "Compare com frames de outros protocolos para destacar diferenças.",
                                    "Anote o formato hexadecimal típico de cada campo."
                                  ],
                                  "verification": "Desenhe o diagrama completo e rotule todos os campos corretamente sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de quadro Ethernet de uma fonte confiável como Wireshark ou Cisco documentation"
                                  ],
                                  "tips": "Use cores diferentes para cada campo no diagrama para facilitar a memorização visual.",
                                  "learningObjective": "Compreender a composição sequencial e tamanhos dos campos do quadro Ethernet.",
                                  "commonMistakes": [
                                    "Esquecer o SFD após o Preamble",
                                    "Confundir o tamanho total incluindo IFG (Interframe Gap)",
                                    "Ignorar o Padding opcional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os campos de sincronização e endereçamento",
                                  "subSteps": [
                                    "Estude o Preamble: sequência alternada 10101010 para sincronização do clock receptor.",
                                    "Aprenda o SFD: padrão 10101011 que marca o início do frame.",
                                    "Descreva Destination MAC: endereço unicast/multicast/broadcast do receptor.",
                                    "Explique Source MAC: endereço único do transmissor.",
                                    "Pratique convertendo endereços MAC de decimal para hexadecimal (ex: 00:1A:2B:3C:4D:5E)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o propósito de cada campo e forneça um exemplo de MAC address.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal online",
                                    "Lista de exemplos de MAC addresses",
                                    "Vídeo tutorial sobre Ethernet frame (YouTube/Khan Academy)"
                                  ],
                                  "tips": "Lembre-se: MAC addresses são globais (OUI) + locais, sempre 48 bits.",
                                  "learningObjective": "Dominar o papel dos campos iniciais na sincronização e roteamento camada 2.",
                                  "commonMistakes": [
                                    "Confundir Destination com Source MAC",
                                    "Achar que Preamble é parte dos dados",
                                    "Esquecer que SFD indica o fim do preamble"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar os campos de controle e payload",
                                  "subSteps": [
                                    "Diferencie Type ( EtherType, ex: 0x0800 para IPv4) de Length (tamanho dos dados).",
                                    "Entenda Data/Payload: contém protocolo superior (IP, ARP), mínimo 46 bytes.",
                                    "Aprenda sobre Padding: bytes zeros adicionados se Data < 46 bytes para mínimo 64 bytes.",
                                    "Calcule um exemplo: se Data=20 bytes, adicione 26 bytes de pad.",
                                    "Identifique como o Length/Type determina o parsing correto."
                                  ],
                                  "verification": "Dado um frame com Length=60, liste o tamanho de Data, Pad e confirme total.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark para capturar frames reais",
                                    "Calculadora para tamanhos",
                                    "Tabela de EtherTypes"
                                  ],
                                  "tips": "Se >1500, é Jumbo frame; foque em padrão 802.3.",
                                  "learningObjective": "Compreender como Type/Length, Data e Pad gerenciam o conteúdo variável.",
                                  "commonMistakes": [
                                    "Confundir Type (valor >1500) com Length (≤1500)",
                                    "Esquecer padding para frames pequenos",
                                    "Achar que Data inclui headers de layer 3"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar a verificação de integridade com CRC",
                                  "subSteps": [
                                    "Aprenda FCS/CRC-32: polinômio CRC calcula checksum sobre todos os campos exceto Preamble/SFD.",
                                    "Entenda detecção de erros: receptor recalcula CRC e compara; mismatch descarta frame.",
                                    "Simule cálculo CRC com ferramenta online para um frame simples.",
                                    "Discuta limitações: detecta erros, não corrige; não protege contra colisões perfeitas.",
                                    "Monte um frame completo: preencha todos campos e compute CRC."
                                  ],
                                  "verification": "Capture um frame no Wireshark, identifique CRC e explique se está correto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "CRC calculator online (ex: crccalc.com)",
                                    "Exemplo de frame hex dump"
                                  ],
                                  "tips": "CRC cobre DestMAC ao Pad; IFG não é transmitido.",
                                  "learningObjective": "Explicar o mecanismo de detecção de erros via CRC no Ethernet.",
                                  "commonMistakes": [
                                    "Incluir Preamble no cálculo CRC",
                                    "Confundir CRC com checksum IP",
                                    "Achar que CRC corrige erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Capture um frame Ethernet real usando Wireshark em uma rede local: identifique Preamble/SFD (pré-captura), DestMAC (ex: ff:ff:ff:ff:ff:ff para broadcast), SrcMAC, Type=0x0800 (IPv4), Data (pacote IP), e verifique CRC sem erros. Desenhe e anote cada campo.",
                              "finalVerifications": [
                                "Liste todos os 8 campos principais em ordem com tamanhos exatos.",
                                "Explique o propósito único de cada campo em uma frase.",
                                "Dado um hex dump parcial, complete os campos faltantes.",
                                "Calcule se um frame de 50 bytes de data precisa de padding e quanto.",
                                "Simule detecção de erro alterando um bit e verificando CRC mismatch.",
                                "Compare quadro Ethernet v2 vs 802.3."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e ordenação dos campos (100% correto).",
                                "Compreensão profunda dos propósitos, especialmente CRC (explicação sem erros).",
                                "Habilidade em diagramas e cálculos manuais (tamanhos/padding).",
                                "Uso correto de terminologia (MAC, EtherType, FCS).",
                                "Aplicação prática via Wireshark ou simulação (frames analisados corretamente).",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de polinômios CRC e operações bitwise/hexadecimais.",
                                "Física: Sinais elétricos e sincronização de clock no Preamble.",
                                "Segurança da Informação: Detecção de integridade e prevenção de ataques de falsificação.",
                                "Engenharia: Design de protocolos de rede e padrões IEEE."
                              ],
                              "realWorldApplication": "Em redes LAN domésticas ou empresariais, switches roteiam frames Ethernet usando MAC addresses; CRC previne transmissão de dados corrompidos em cabos Ethernet, WiFi bridges ou data centers, garantindo confiabilidade em streaming, VoIP e internet."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.2",
                            "name": "Explicar o protocolo CSMA/CD",
                            "description": "Detalhar o funcionamento do Carrier Sense Multiple Access with Collision Detection, incluindo detecção de colisões, backoff exponencial e sua relevância em redes half-duplex.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios fundamentais do CSMA/CD",
                                  "subSteps": [
                                    "Defina CSMA (Carrier Sense Multiple Access): um método onde estações escutam o meio antes de transmitir.",
                                    "Explique 'Carrier Sense': verificação se o canal está livre (sem sinal detectado).",
                                    "Discuta 'Multiple Access': múltiplas estações compartilham o meio físico.",
                                    "Introduza 'Collision Detection': detecção de colisões durante transmissão.",
                                    "Relacione com redes half-duplex onde transmissão e recepção não ocorrem simultaneamente."
                                  ],
                                  "verification": "Resuma os quatro componentes principais (CSMA e CD) em uma frase coesa e liste diferenças para full-duplex.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de rede Ethernet básica (papel/caneta)",
                                    "Vídeo introdutório sobre Ethernet (YouTube: 'CSMA/CD Explained')"
                                  ],
                                  "tips": "Use analogia de uma sala de reuniões: escute antes de falar (carrier sense), detecte interrupções (collision).",
                                  "learningObjective": "Identificar e definir os componentes chave do protocolo CSMA/CD.",
                                  "commonMistakes": [
                                    "Confundir CSMA/CD com CSMA/CA (WiFi usa CA, não CD)",
                                    "Ignorar que é para half-duplex apenas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o processo de transmissão e Carrier Sense",
                                  "subSteps": [
                                    "Estações monitoram o canal continuamente (carrier sense).",
                                    "Se canal livre por tempo mínimo (IFG - Interframe Gap), inicie transmissão.",
                                    "Envie quadro Ethernet enquanto continua monitorando o canal.",
                                    "Se sinal detectado durante transmissão, pare e processe colisão.",
                                    "Calcule o tempo de detecção de colisão baseado na largura de slot (slot time = 512 bit times em 10Mbps Ethernet)."
                                  ],
                                  "verification": "Desenhe um fluxograma simples do processo de transmissão sem colisão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online (Draw.io)",
                                    "Documentação IEEE 802.3 seção 4.2.3"
                                  ],
                                  "tips": "Lembre-se: transmissão começa apenas após carrier sense positivo; pratique desenhando o timing.",
                                  "learningObjective": "Mapear a sequência exata de eventos na transmissão inicial.",
                                  "commonMistakes": [
                                    "Esquecer o IFG (9.6µs em 10Mbps)",
                                    "Achar que carrier sense é 100% preciso devido a propagação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar detecção e sinalização de colisões",
                                  "subSteps": [
                                    "Durante transmissão, compare sinal transmitido com recebido; diferença indica colisão.",
                                    "Envie sinal de jam (32 bits de violação) para garantir detecção por todas estações.",
                                    "Pare transmissão imediatamente após detecção.",
                                    "Propague o sinal de jam para o comprimento máximo do cabo (para alcance).",
                                    "Todas estações detectam jam e abortam transmissão."
                                  ],
                                  "verification": "Simule verbalmente uma colisão entre duas estações e liste ações pós-detecção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de rede (Cisco Packet Tracer ou Wireshark com captura Ethernet)",
                                    "Papel para timeline de colisão"
                                  ],
                                  "tips": "Pense em colisão como eco detectado; jam garante que todos 'ouçam' o problema.",
                                  "learningObjective": "Detalhar mecanismos de detecção e notificação de colisões.",
                                  "commonMistakes": [
                                    "Confundir jam signal com padding",
                                    "Subestimar importância do sinal de jam para detecção remota"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o algoritmo de backoff exponencial e relevância",
                                  "subSteps": [
                                    "Calcule k = min(retransmissões, 10); escolha r aleatório [0, 2^k - 1].",
                                    "Aguarde r * slot time antes de retry (truncated binary exponential backoff).",
                                    "Após 16 tentativas falhas, descarte quadro (excesso de colisões).",
                                    "Discuta eficiência: reduz probabilidade de colisões repetidas.",
                                    "Compare com CSMA/CA (WiFi) e por que CSMA/CD é obsoleto em full-duplex Gigabit Ethernet."
                                  ],
                                  "verification": "Calcule backoff para k=3 (ex: r=0,1,2,3,4,5,6,7) e explique por que exponencial.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel para backoff",
                                    "Artigo 'Ethernet CSMA/CD Efficiency'"
                                  ],
                                  "tips": "Backoff exponencial evita 'captura' por uma estação dominante; teste cálculos manualmente.",
                                  "learningObjective": "Compreender e calcular o mecanismo de retry pós-colisão.",
                                  "commonMistakes": [
                                    "Usar backoff linear em vez de exponencial truncado",
                                    "Ignorar limite de 16 tentativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede Ethernet 10Mbps half-duplex com 3 PCs conectados via hub: PC1 transmite, PC2 inicia após IFG mas colide; ambos detectam, enviam jam, calculam backoff (ex: PC1 espera 3 slots, PC2 1 slot), retry sem colisão.",
                              "finalVerifications": [
                                "Desenhe diagrama completo de fluxo CSMA/CD incluindo colisão e backoff.",
                                "Explique por que CSMA/CD requer cabos curtos (<2500m com repetidores).",
                                "Compare CSMA/CD vs CSMA/CA em termos de detecção.",
                                "Calcule slot time para 100Mbps Ethernet.",
                                "Liste limitações em redes modernas (full-duplex não precisa)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: todos componentes CSMA/CD corretos?",
                                "Clareza do fluxograma: sequência lógica e timings evidentes?",
                                "Profundidade no backoff: cálculo correto e justificativa exponencial?",
                                "Contexto histórico: relevância para IEEE 802.3 e obsolescência?",
                                "Explicação verbal: fluida sem erros comuns?",
                                "Integração de exemplo prático: aplicável e realista?"
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais e delay em cabos coaxiais.",
                                "Matemática: Probabilidades em backoff exponencial e eficiência (1/(1+5p/8)).",
                                "História da Computação: Evolução de LANs nos anos 80 (Xerox/DEC).",
                                "Engenharia: Design de protocolos distribuídos sem coordenação central.",
                                "Estatística: Análise de throughput vs carga de tráfego."
                              ],
                              "realWorldApplication": "Embora obsoleto em Ethernets modernas (full-duplex/switches), princípios de detecção de conflitos inspiram CSMA/CA em WiFi e algoritmos em sistemas distribuídos como blockchain consensus."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.3",
                            "name": "Comparar variantes do Ethernet",
                            "description": "Diferenciar Ethernet clássico (10BASE5/10BASE-T), Fast Ethernet (100BASE-TX), Gigabit Ethernet (1000BASE-T) e 10 Gigabit Ethernet em termos de velocidade, cabo e full-duplex.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos do Ethernet clássico (10BASE5 e 10BASE-T)",
                                  "subSteps": [
                                    "Pesquise a história e topologia do 10BASE5 (coaxial grosso, barramento).",
                                    "Identifique as especificações: velocidade de 10 Mbps, cabo RG-8, half-duplex primário.",
                                    "Estude o 10BASE-T: velocidade 10 Mbps, par trançado Cat3, topologia estrela com hubs.",
                                    "Anote suporte limitado a full-duplex no 10BASE-T com switches.",
                                    "Visualize diagramas de rede para cada variante."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo com specs principais e desenhe um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.3",
                                    "Imagens de cabos coaxiais e UTP",
                                    "Vídeo introdutório sobre Ethernet histórico"
                                  ],
                                  "tips": "Use tabelas para organizar specs iniciais; foque em diferenças de cabo e topologia.",
                                  "learningObjective": "Identificar corretamente as características básicas do Ethernet clássico.",
                                  "commonMistakes": [
                                    "Confundir 10BASE5 com topologia estrela",
                                    "Ignorar half-duplex como padrão no clássico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Fast Ethernet (100BASE-TX)",
                                  "subSteps": [
                                    "Revise as melhorias: velocidade 100 Mbps, cabo Cat5 UTP.",
                                    "Estude sinalização 4B/5B e codificação MLT-3.",
                                    "Discuta suporte nativo a full-duplex com switches.",
                                    "Compare com clássico: distância máxima 100m por segmento.",
                                    "Identifique limitações em ambientes ruidosos."
                                  ],
                                  "verification": "Liste 5 diferenças chave do 10BASE-T e justifique com specs técnicas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Especificação IEEE 802.3u",
                                    "Ferramenta de desenho de rede como draw.io",
                                    "Exemplos de pinouts RJ-45"
                                  ],
                                  "tips": "Teste cabos Cat5 reais se disponível para sentir a diferença física.",
                                  "learningObjective": "Diferenciar Fast Ethernet em velocidade, cabo e modos duplex.",
                                  "commonMistakes": [
                                    "Achar que usa Cat3",
                                    "Confundir com 100BASE-FX (fibra)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Gigabit Ethernet (1000BASE-T) e 10 Gigabit Ethernet",
                                  "subSteps": [
                                    "Estude 1000BASE-T: 1 Gbps, Cat5e UTP, 4 pares bidirecionais, full-duplex obrigatório.",
                                    "Analise codificação PAM-5 e correção de erros.",
                                    "Para 10GBASE-T: 10 Gbps, Cat6a/7, alcance 100m, alto consumo de energia.",
                                    "Note evoluções: auto-negociação avançada e suporte a PoE em variantes.",
                                    "Registre requisitos de cabo mais rigorosos para 10GbE."
                                  ],
                                  "verification": "Descreva em bullet points as specs de velocidade, cabo e duplex para ambos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "IEEE 802.3ab e 802.3an",
                                    "Comparativos de cabos Cat5e vs Cat6a",
                                    "Simulador de rede como Cisco Packet Tracer"
                                  ],
                                  "tips": "Use calculadoras online de throughput para visualizar ganhos de velocidade.",
                                  "learningObjective": "Compreender as especificações avançadas de Gigabit e 10GbE.",
                                  "commonMistakes": [
                                    "Pensar que 1000BASE-T usa apenas 2 pares",
                                    "Subestimar ruído em 10GBASE-T"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar todas as variantes e sintetizar diferenças",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para variante, velocidade, cabo, duplex, alcance.",
                                    "Destaque evoluções: de half para full-duplex, coax para UTP avançado.",
                                    "Discuta impactos: latência reduzida em full-duplex, gargalos em velocidades baixas.",
                                    "Simule cenários: quando usar cada uma em redes legadas vs modernas.",
                                    "Revise e refine a tabela com fontes verificadas."
                                  ],
                                  "verification": "Apresente a tabela comparativa e explique 3 trade-offs principais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel",
                                    "Fontes: Wikipedia IEEE 802.3, livros de redes como Kurose",
                                    "Quiz online sobre Ethernet"
                                  ],
                                  "tips": "Inclua coluna de 'uso atual' para contextualizar obsolescência.",
                                  "learningObjective": "Sintetizar comparações precisas entre variantes do Ethernet.",
                                  "commonMistakes": [
                                    "Erros em velocidades (ex: 1000BASE-T como 100Mbps)",
                                    "Ignorar full-duplex como feature chave moderna"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede de escritório pequena, identifique um hub 10BASE-T legado causando gargalos (10Mbps half-duplex) e proponha upgrade para switch 1000BASE-T full-duplex, calculando ganho de throughput de 20Mbps para 2Gbps efetivo, usando cabo Cat5e existente.",
                              "finalVerifications": [
                                "Pode listar velocidades exatas: 10/100/1000/10000 Mbps?",
                                "Identifica cabos corretos: coax para 10BASE5, Cat5 para 100/1000BASE-T?",
                                "Explica full-duplex vs half-duplex com exemplo de colisão?",
                                "Cria tabela comparativa sem erros factuais?",
                                "Discute limitações reais de cada variante?",
                                "Aplica conceitos a um cenário de rede simples?"
                              ],
                              "assessmentCriteria": [
                                "Precisão factual em velocidades, cabos e duplex (90%+ correto).",
                                "Profundidade na tabela comparativa (todas variantes cobertas).",
                                "Capacidade de explicar trade-offs (ex: custo vs performance).",
                                "Uso correto de terminologia IEEE (ex: 100BASE-TX).",
                                "Criatividade em exemplos práticos e conexões reais.",
                                "Completude dos steps com verificações pessoais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais em cabos e atenuação.",
                                "Matemática: Cálculo de throughput (bits/segundo) e latência.",
                                "História: Evolução da tecnologia de redes desde 1980s.",
                                "Eletrônica: Pinouts RJ-45 e codificações de sinal.",
                                "Engenharia: Design de topologias de rede escaláveis."
                              ],
                              "realWorldApplication": "Em data centers, escolher 10GBASE-T para servidores de alto tráfego reduz latência em aplicações cloud; em residências, upgrade de 100BASE-TX para 1000BASE-T habilita streaming 4K sem buffering, otimizando infraestrutura existente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.2",
                        "name": "IEEE 802.11 (Wi-Fi)",
                        "description": "Família de padrões IEEE para redes locais sem fio (WLAN), abrangendo controle de acesso via CSMA/CA, modulações e frequências como 2.4 GHz e 5 GHz.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.2.1",
                            "name": "Descrever os modos de operação do 802.11",
                            "description": "Explicar infraestruturas BSS (Basic Service Set) com AP, IBSS (ad-hoc) e ESS (Extended Service Set), incluindo beacons e associação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais do IEEE 802.11",
                                  "subSteps": [
                                    "Leia a introdução ao padrão IEEE 802.11 e seus objetivos principais para redes sem fio.",
                                    "Identifique os termos chave: STA (Station), AP (Access Point), BSSID (Basic Service Set Identifier).",
                                    "Estude a diferença entre serviço básico e serviço estendido.",
                                    "Revise o papel das camadas MAC e PHY no contexto Wi-Fi.",
                                    "Anote definições de BSS, IBSS e ESS em suas próprias palavras."
                                  ],
                                  "verification": "Crie um glossário com pelo menos 10 termos relacionados e defina-os corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.11 (seções 1-4)",
                                    "Diagramas de arquitetura Wi-Fi de sites como Cisco ou Wi-Fi Alliance"
                                  ],
                                  "tips": "Use mnemônicos para lembrar: BSS = Basic Service Set (com AP), IBSS = Independent BSS (sem AP).",
                                  "learningObjective": "Compreender a terminologia e arquitetura base do 802.11 para contextualizar os modos de operação.",
                                  "commonMistakes": "Confundir STA com AP; lembrar que toda STA pode ser cliente ou ponto de acesso em certos modos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Modo Infrastructure BSS",
                                  "subSteps": [
                                    "Descreva o BSS como uma rede centrada em um AP único.",
                                    "Explique como estações (STAs) se comunicam via AP, não diretamente.",
                                    "Estude o BSSID como o MAC address do AP.",
                                    "Desenhe um diagrama simples de um BSS com AP e múltiplas STAs.",
                                    "Simule o fluxo de dados: STA1 -> AP -> STA2."
                                  ],
                                  "verification": "Desenhe e rotule um diagrama de BSS que inclua AP, STAs e setas de comunicação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io",
                                    "Vídeos tutoriais sobre BSS no YouTube (canais como NetworkChuck)"
                                  ],
                                  "tips": "Pense no AP como um 'hub central' em uma estrela de rede sem fio.",
                                  "learningObjective": "Dominar a estrutura e funcionamento do BSS infrastructure mode.",
                                  "commonMistakes": "Achar que STAs em BSS se comunicam diretamente; sempre via AP."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Modo Ad-hoc IBSS",
                                  "subSteps": [
                                    "Defina IBSS como rede peer-to-peer sem AP.",
                                    "Explique que todas as STAs são iguais e se comunicam diretamente.",
                                    "Entenda o IBSS ID e seleção dinâmica de coordenadores.",
                                    "Compare IBSS com BSS em termos de alcance e mobilidade.",
                                    "Desenhe um diagrama de IBSS com 3-4 STAs conectadas."
                                  ],
                                  "verification": "Compare BSS e IBSS em uma tabela de diferenças (pelo menos 5 colunas).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulador de redes como Cisco Packet Tracer (modo Wi-Fi ad-hoc)",
                                    "Artigos sobre redes mesh ad-hoc"
                                  ],
                                  "tips": "IBSS é ideal para cenários temporários como compartilhamento de arquivos entre laptops.",
                                  "learningObjective": "Compreender as características e usos do modo independente ad-hoc.",
                                  "commonMistakes": "Ignorar limitações de alcance em IBSS devido à falta de AP de alta potência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar o Modo Extended ESS",
                                  "subSteps": [
                                    "Defina ESS como múltiplos BSSs conectados via backbone com fio.",
                                    "Explique o SSID comum para roaming seamless entre APs.",
                                    "Estude distribuição system (DS) para interconexão de BSSs.",
                                    "Descreva cenários de handover em ESS.",
                                    "Crie um diagrama de ESS com 2-3 BSSs e backbone."
                                  ],
                                  "verification": "Explique em 3 frases como um laptop faz roaming em uma ESS.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Wi-Fi sobre ESS e roaming",
                                    "Diagramas de redes empresariais Wi-Fi"
                                  ],
                                  "tips": "ESS é como 'Wi-Fi corporativo' com múltiplos APs cobrindo grandes áreas.",
                                  "learningObjective": "Entender como ESS estende cobertura e suporta mobilidade.",
                                  "commonMistakes": "Confundir ESS com simples repetidores; ESS requer DS wired."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Dominar Beacons e Processo de Associação",
                                  "subSteps": [
                                    "Descreva beacons como frames periódicos do AP contendo SSID, capacidades.",
                                    "Explique scanning: passivo (escuta beacons) vs ativo (probes).",
                                    "Detalhe autenticação (open/shared key) e associação (frame assoc req/rsp).",
                                    "Simule o processo completo: scan -> auth -> assoc.",
                                    "Compare beacons em BSS/ESS vs ausência em IBSS."
                                  ],
                                  "verification": "Liste os passos de associação em ordem numerada e descreva cada frame envolvido.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark para capturar beacons reais",
                                    "IEEE 802.11 spec seção 11 (MAC frames)"
                                  ],
                                  "tips": "Use Wireshark em sua rede Wi-Fi para ver beacons ao vivo!",
                                  "learningObjective": "Explicar mecanismos de descoberta e conexão nos modos 802.11.",
                                  "commonMistakes": "Pular autenticação antes de associação; beacons são só para discovery."
                                }
                              ],
                              "practicalExample": "Configure uma rede doméstica BSS conectando seu smartphone ao roteador Wi-Fi (AP), observe beacons no Wireshark. Em seguida, ative modo ad-hoc no Windows/Linux para conectar dois laptops diretamente e compartilhe arquivos sem internet, demonstrando IBSS. Para ESS, visite um shopping com Wi-Fi multi-AP e note roaming seamless.",
                              "finalVerifications": [
                                "Desenhe diagramas precisos de BSS, IBSS e ESS.",
                                "Explique verbalmente a diferença entre modos em 2 minutos.",
                                "Capture e identifique um beacon frame no Wireshark.",
                                "Liste 5 vantagens/desvantagens de cada modo.",
                                "Simule associação passo a passo com um parceiro.",
                                "Crie uma tabela comparativa de beacons em cada modo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de BSS, IBSS e ESS (90% correto).",
                                "Correta explicação de beacons, scanning e associação.",
                                "Uso de diagramas claros e rotulados.",
                                "Identificação de erros comuns evitados.",
                                "Conexão conceitual entre modos e aplicações reais.",
                                "Profundidade nos substeps com exemplos próprios."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas de rádio e interferência em Wi-Fi.",
                                "Segurança da Informação: Autenticação e criptografia durante associação.",
                                "Matemática: Cálculo de throughput baseado em beacons e contendas CSMA/CA.",
                                "Engenharia: Design de redes mesh semelhantes a IBSS em IoT."
                              ],
                              "realWorldApplication": "Em redes domésticas (BSS para internet via roteador), hotspots públicos (ESS para cobertura ampla em aeroportos), ou resgates de emergência (IBSS ad-hoc entre dispositivos sem infraestrutura para coordenação rápida)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.2",
                            "name": "Explicar o mecanismo CSMA/CA",
                            "description": "Detalhar Carrier Sense Multiple Access with Collision Avoidance, incluindo RTS/CTS, NAV (Network Allocation Vector) e ACK para evitar colisões em ambientes sem fio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do CSMA/CA e Diferenças com CSMA/CD",
                                  "subSteps": [
                                    "Definir CSMA/CA como Carrier Sense Multiple Access with Collision Avoidance",
                                    "Comparar com CSMA/CD usado em Ethernet cabeado",
                                    "Explicar limitações wireless: half-duplex, hidden terminals e propagação variável",
                                    "Listar componentes chave: Carrier Sense, RTS/CTS, NAV, ACK",
                                    "Desenhar diagrama básico de rede wireless com múltiplos nós"
                                  ],
                                  "verification": "Criar um diagrama comparativo e explicar oralmente as diferenças em 2 minutos",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso à internet para diagramas de referência"
                                  ],
                                  "tips": "Foquem na impossibilidade de detectar colisões durante transmissão em wireless",
                                  "learningObjective": "Compreender por que CSMA/CA é essencial em redes IEEE 802.11",
                                  "commonMistakes": [
                                    "Confundir avoidance com detection",
                                    "Ignorar problemas de propagação em wireless"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Mecanismo de Carrier Sense (CCA)",
                                  "subSteps": [
                                    "Descrever Physical Carrier Sense (energia no canal)",
                                    "Explicar Virtual Carrier Sense via NAV",
                                    "Simular cenário: nó escuta canal antes de transmitir",
                                    "Discutir thresholds de detecção de energia (ex: -82 dBm)",
                                    "Identificar quando deferir transmissão"
                                  ],
                                  "verification": "Simular em papel: nó A tenta transmitir enquanto canal ocupado",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador online de redes (ex: NS-3 demo)",
                                    "Folha de cálculo para thresholds"
                                  ],
                                  "tips": "Carrier Sense previne transmissão imediata, mas não resolve hidden nodes",
                                  "learningObjective": "Dominar como sensoriamento evita acessos simultâneos iniciais",
                                  "commonMistakes": [
                                    "Achar que carrier sense resolve todos os problemas de colisão",
                                    "Confundir physical com virtual sense"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Problema Hidden Terminal e Solução RTS/CTS",
                                  "subSteps": [
                                    "Desenhar cenário hidden terminal: nós A, B, C onde A e C não se veem",
                                    "Explicar colisão em B se A e C transmitirem juntos",
                                    "Detalhar RTS: Request to Send com duração do frame",
                                    "Descrever CTS: Clear to Send broadcast por receptor",
                                    "Simular handshake RTS/CTS em diagrama temporal"
                                  ],
                                  "verification": "Diagramar fluxo RTS/CTS resolvendo hidden terminal",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (ex: Draw.io)",
                                    "Vídeos tutoriais IEEE 802.11"
                                  ],
                                  "tips": "RTS/CTS é opcional, usado em frames grandes para eficiência",
                                  "learningObjective": "Entender como RTS/CTS mitiga colisões em topologias wireless",
                                  "commonMistakes": [
                                    "Confundir hidden com exposed terminal",
                                    "Esquecer broadcast de CTS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender NAV (Network Allocation Vector) e Reserva de Canal",
                                  "subSteps": [
                                    "Definir NAV como temporizador virtual baseado em duração em RTS/CTS/DATA",
                                    "Explicar atualização de NAV por todos os nós que ouvem",
                                    "Mostrar como NAV silencia nós desnecessários",
                                    "Discutir exposed terminal: NAV permite transmissão paralela segura",
                                    "Calcular exemplo: NAV = tempo de DATA + ACK + SIFS"
                                  ],
                                  "verification": "Calcular NAV para um frame de 1000 bytes e verificar silêncio",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de taxas de dados 802.11"
                                  ],
                                  "tips": "NAV cria 'reserva virtual' sem overhead físico",
                                  "learningObjective": "Mestre o papel do NAV na coordenação distribuída",
                                  "commonMistakes": [
                                    "Achar NAV global em vez de local por nó",
                                    "Ignorar resets por ACK"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Finalizar com Transmissão de Dados, ACK e Backoff Exponencial",
                                  "subSteps": [
                                    "Descrever fluxo completo: Sense -> RTS/CTS -> DATA -> ACK",
                                    "Explicar ACK imediato após SIFS para confirmação",
                                    "Detalhar Binary Exponential Backoff (BEB) após colisão detectada",
                                    "Simular retry: CW min 15, dobra até 1023 slots",
                                    "Resumir todo mecanismo em um diagrama unificado"
                                  ],
                                  "verification": "Explicar fluxo end-to-end e simular uma colisão com backoff",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Rede Wi-Fi para captura opcional"
                                  ],
                                  "tips": "SIFS < DIFS para prioridade a ACKs e CTS",
                                  "learningObjective": "Integrar todos os elementos em um protocolo coeso",
                                  "commonMistakes": [
                                    "Esquecer ACK para confiabilidade",
                                    "Confundir backoff com carrier sense"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure Wireshark em modo monitor em um adaptador Wi-Fi compatível (ex: Alfa AWUS036N), capture tráfego em uma rede movimentada (café com múltiplos laptops). Identifique pacotes RTS/CTS/NAV updates/DATA/ACK e reconstrua o fluxo CSMA/CA em um diagrama.",
                              "finalVerifications": [
                                "Diagramar fluxo completo CSMA/CA incluindo hidden node resolução",
                                "Explicar verbalmente diferenças CSMA/CA vs CSMA/CD",
                                "Calcular NAV para um cenário dado",
                                "Simular backoff após colisão",
                                "Identificar pacotes RTS/CTS em captura Wireshark",
                                "Discutir quando RTS/CTS é desabilitado"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de RTS/CTS e NAV",
                                "Correta identificação de problemas wireless (hidden/exposed)",
                                "Compreensão de carrier sense físico/virtual",
                                "Exatidão no fluxo temporal (SIFS/DIFS)",
                                "Capacidade de simular cenários práticos",
                                "Integração correta de ACK e backoff"
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas de rádio e interferência",
                                "Matemática: Probabilidade de colisão e algoritmos de backoff exponencial",
                                "Segurança da Informação: Vulnerabilidades como deautenticação em 802.11",
                                "Engenharia de Software: Protocolos distribuídos e coordenação assíncrona",
                                "Estatística: Análise de throughput em simulações de rede"
                              ],
                              "realWorldApplication": "CSMA/CA é o coração do MAC em todos os roteadores Wi-Fi (802.11a/b/g/n/ac/ax), garantindo acesso justo em casas, escritórios e hotspots públicos com dezenas de dispositivos, otimizando throughput em ambientes ruidosos como aeroportos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.3",
                            "name": "Identificar variantes do 802.11",
                            "description": "Comparar 802.11a/b/g/n/ac/ax em termos de bandas de frequência, velocidades máximas, MIMO e eficiência espectral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as bases históricas e introdução às variantes 802.11",
                                  "subSteps": [
                                    "Pesquise a evolução do padrão IEEE 802.11 desde 1997, focando em b, a, g, n, ac e ax.",
                                    "Identifique os nomes comerciais: Wi-Fi 1 (b), Wi-Fi 2 (a), Wi-Fi 3 (g), Wi-Fi 4 (n), Wi-Fi 5 (ac), Wi-Fi 6 (ax).",
                                    "Crie uma linha do tempo simples com datas de aprovação.",
                                    "Registre as bandas iniciais: 2.4 GHz para b/g/n/ax, 5 GHz para a/n/ac/ax.",
                                    "Anote velocidades teóricas máximas aproximadas para cada."
                                  ],
                                  "verification": "Crie uma tabela com nome, ano e banda básica de cada variante; verifique contra fontes confiáveis como Wikipedia ou IEEE.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Planilha ou papel para tabela",
                                    "Site IEEE 802.11 ou Wikipedia"
                                  ],
                                  "tips": "Use cores para diferenciar bandas (azul para 2.4 GHz, vermelho para 5 GHz).",
                                  "learningObjective": "Compreender o contexto histórico e bandas primárias das variantes Wi-Fi.",
                                  "commonMistakes": [
                                    "Confundir 802.11a com 2.4 GHz (é 5 GHz)",
                                    "Ignorar anos de lançamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar bandas de frequência e velocidades máximas",
                                  "subSteps": [
                                    "Liste bandas exatas: b/g/n/ax (2.4 GHz), a/n/ac/ax (5 GHz), ax (6 GHz opcional).",
                                    "Registre velocidades: b=11 Mbps, a/g=54 Mbps, n=600 Mbps (4x4), ac=6.93 Gbps (8x8), ax=9.6 Gbps.",
                                    "Calcule diferenças percentuais entre gerações consecutivas.",
                                    "Crie um gráfico de barras comparando velocidades.",
                                    "Note interferências: 2.4 GHz (mais congestionado) vs 5/6 GHz (menos)."
                                  ],
                                  "verification": "Gere uma tabela comparativa com bandas e velocidades; teste recitando de memória.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel",
                                    "Fontes: Cisco ou Wi-Fi Alliance sites"
                                  ],
                                  "tips": "Converta todas velocidades para Mbps para facilitar comparação.",
                                  "learningObjective": "Dominar bandas e velocidades máximas teóricas das variantes.",
                                  "commonMistakes": [
                                    "Usar velocidades reais em vez de teóricas",
                                    "Confundir n com apenas 2.4 GHz (dual-band)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar MIMO e suas evoluções nas variantes",
                                  "subSteps": [
                                    "Defina MIMO: Multiple Input Multiple Output, streams espaciais.",
                                    "Detalhe por variante: b/a/g (SISO, 1x1), n (MIMO até 4x4), ac (MU-MIMO até 8x8), ax (UL/DL MU-MIMO melhorado).",
                                    "Compare ganhos: n dobra/triplica throughput, ac/acess simultâneo multi-dispositivos.",
                                    "Pesquise beamforming: ausente em b/a/g, básico em n, avançado em ac/ax.",
                                    "Crie diagrama de streams para n/ac/ax."
                                  ],
                                  "verification": "Desenhe fluxogramas de MIMO para n, ac e ax; explique diferenças oralmente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Papel/caneta para diagramas",
                                    "Vídeos YouTube sobre MIMO Wi-Fi"
                                  ],
                                  "tips": "Pense em MIMO como 'pistas múltiplas' em uma rodovia para throughput maior.",
                                  "learningObjective": "Entender como MIMO evoluiu e impacta performance em cada variante.",
                                  "commonMistakes": [
                                    "Achar que todas suportam MIMO (só n em diante)",
                                    "Confundir SU-MIMO com MU-MIMO"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar eficiência espectral e sintetizar comparações",
                                  "subSteps": [
                                    "Defina eficiência espectral: bits/Hz/antenna (b ~0.5, g ~3, n ~5-10, ac ~10-20, ax ~30+ com OFDMA).",
                                    "Compare: ax usa OFDMA/1024-QAM para >4x eficiência de ac.",
                                    "Crie matriz comparativa completa: linhas=variantes, colunas=bandas/vel/max/MIMO/efic.",
                                    "Identifique trade-offs: velocidade vs alcance (2.4 melhor alcance).",
                                    "Teste com quiz autoavaliativo de 10 perguntas."
                                  ],
                                  "verification": "Preencha matriz sem consultar notas; acerte 90% no quiz.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matriz em planilha",
                                    "Quiz online como Quizlet sobre Wi-Fi standards"
                                  ],
                                  "tips": "Eficiência = velocidade / (largura banda * streams); foque em tendências.",
                                  "learningObjective": "Sintetizar comparações completas incluindo eficiência espectral.",
                                  "commonMistakes": [
                                    "Subestimar ganhos de ax (OFDMA não é só velocidade)",
                                    "Ignorar eficiência em cenários multi-usuário"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao comprar um roteador para casa com muitos dispositivos IoT, compare: escolha 802.11ax para eficiência em 2.4/5 GHz com MU-MIMO, evitando lentidão de n/ac em redes congestionadas.",
                              "finalVerifications": [
                                "Recite bandas, velocidades máximas e suporte MIMO para cada variante sem erros.",
                                "Explique por que ax é mais eficiente que ac em um parágrafo.",
                                "Preencha tabela comparativa em menos de 5 minutos.",
                                "Identifique cenário ideal para cada variante (ex: b para legado, ax para moderno).",
                                "Calcule ganho de velocidade n vs g corretamente.",
                                "Descreva trade-offs de frequência (alcance vs velocidade)."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: 100% correto em specs técnicas.",
                                "Completude: Todas variantes cobertas em todos aspectos.",
                                "Profundidade: Explicações incluem causas (ex: por que MIMO aumenta throughput).",
                                "Clareza: Tabelas/diagramas legíveis e bem organizados.",
                                "Aplicação: Liga specs a cenários reais.",
                                "Autoavaliação: Identifica gaps próprios corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Física: Ondas eletromagnéticas e propagação em bandas de frequência.",
                                "Matemática: Cálculos de throughput e eficiência espectral (bits/Hz).",
                                "Engenharia: Design de sistemas de comunicação e otimização de rede.",
                                "Estatística: Análise de performance em cenários multi-usuário."
                              ],
                              "realWorldApplication": "Em TI empresarial, selecione AP Wi-Fi ax para escritórios densos, reduzindo latência 75% vs ac; em residências, migre de g/n para ax para streaming 4K simultâneo sem buffering."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.3",
                        "name": "IEEE 802.1 (Gerenciamento de Enlace)",
                        "description": "Padrões IEEE para bridging, VLANs e spanning tree no nível de enlace, essenciais para interconexão de LANs e prevenção de loops.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.3.1",
                            "name": "Descrever o protocolo STP (Spanning Tree Protocol)",
                            "description": "Explicar IEEE 802.1D STP para evitar loops em redes com bridges/switches, incluindo eleição de root bridge, portas blocking/listening/learning/forwarding.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Loops em Redes Ethernet",
                                  "subSteps": [
                                    "Explicar o que são loops em topologias de rede com bridges/switches redundantes.",
                                    "Descrever os efeitos catastróficos de loops, como broadcast storms e instabilidade na tabela de endereços MAC.",
                                    "Introduzir o IEEE 802.1D STP como algoritmo para criar uma topologia em árvore sem loops.",
                                    "Diferenciar redundância física de loops lógicos."
                                  ],
                                  "verification": "Desenhar uma topologia com loop e simular manualmente um broadcast storm em um diagrama.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de rede impresso ou software como Draw.io"
                                  ],
                                  "tips": [
                                    "Visualize frames broadcast circulando infinitamente até colapso da rede."
                                  ],
                                  "learningObjective": "Identificar e explicar os riscos de loops em redes com múltiplos caminhos.",
                                  "commonMistakes": [
                                    "Confundir loops com simples conexões redundantes sem STP."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever a Eleição do Root Bridge",
                                  "subSteps": [
                                    "Explicar o Bridge Protocol Data Unit (BPDU) e seu papel na comunicação entre switches.",
                                    "Detalhar os critérios de eleição: menor Bridge ID (Priority + endereço MAC).",
                                    "Simular o processo de troca de BPDUs até consenso sobre o root bridge.",
                                    "Discutir o papel do root bridge como referência central da topologia."
                                  ],
                                  "verification": "Em um cenário com 3 switches, identificar corretamente o root bridge com base nos BIDs fornecidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para priorizar BIDs",
                                    "Tabela de exemplo de BIDs"
                                  ],
                                  "tips": [
                                    "Lembre-se: Priority é configurável (padrão 32768), MAC quebra empates."
                                  ],
                                  "learningObjective": "Dominar o mecanismo de eleição do root bridge via BPDUs.",
                                  "commonMistakes": [
                                    "Ignorar que todos os switches enviam BPDUs inicialmente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Seleção de Portas Root e Designated",
                                  "subSteps": [
                                    "Definir custo de caminho (path cost) baseado na velocidade da porta (ex: 100 Mbps = custo 19).",
                                    "Descrever seleção da porta Root: menor custo para o root bridge.",
                                    "Explicar portas Designated: menor custo para segmentos não-root.",
                                    "Identificar portas Blocked: não selecionadas como root ou designated.",
                                    "Calcular o spanning tree completo em uma topologia simples."
                                  ],
                                  "verification": "Mapear portas root/designated/blocked em um diagrama de 4 switches.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela IEEE de path costs",
                                    "Software de simulação como Packet Tracer"
                                  ],
                                  "tips": [
                                    "Sempre some custos cumulativos do root até a porta atual."
                                  ],
                                  "learningObjective": "Calcular e justificar seleções de portas no STP.",
                                  "commonMistakes": [
                                    "Usar velocidade errada para calcular path cost."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhar os Estados das Portas e Timers STP",
                                  "subSteps": [
                                    "Listar e definir estados: Blocking (descarta frames), Listening (aprende topologia), Learning (aprende MACs), Forwarding (tráfego normal).",
                                    "Explicar transições: Hello Time (2s), Forward Delay (15s), Max Age (20s).",
                                    "Descrever reconvergência após falha (Topology Change Notification).",
                                    "Diferenciar STP clássico de variantes como RSTP."
                                  ],
                                  "verification": "Desenhar um diagrama de transição de estados para uma porta bloqueada virando forwarding.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cronograma de timers STP",
                                    "Vídeo animado de estados de porta"
                                  ],
                                  "tips": [
                                    "Listening + Learning = 30s de Forward Delay para estabilidade."
                                  ],
                                  "learningObjective": "Explicar operações dinâmicas das portas STP e convergência.",
                                  "commonMistakes": [
                                    "Confundir Listening (sem learning) com Learning (sem forwarding)."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere três switches em triângulo: Switch A (BID 0001.MAC-A), B (0002.MAC-B), C (0003.MAC-C). A é eleito root. Porta B-C bloqueada (highest cost). Tráfego flui A->B e A->C; BPDUs de A propagam via designated ports.",
                              "finalVerifications": [
                                "Explicar corretamente por que STP previne loops.",
                                "Identificar root bridge em cenário dado.",
                                "Listar e definir os 4 estados das portas.",
                                "Calcular path costs e selecionar portas corretamente.",
                                "Descrever timers e processo de convergência.",
                                "Diferenciar STP de protocolos sem loop prevention."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de BPDUs e eleição de root (20%)",
                                "Correção na seleção de portas e path costs (25%)",
                                "Domínio dos estados das portas e transições (25%)",
                                "Explicação clara de timers e reconvergência (15%)",
                                "Uso de exemplos práticos e diagramas (10%)",
                                "Ausência de erros comuns como confusão de estados (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e árvores geradoras mínimas (Kruskal/Prim).",
                                "Física: Propagação de sinais elétricos e latência em cabos Ethernet.",
                                "Segurança da Informação: Prevenção de ataques de broadcast storm (DoS).",
                                "Administração: Planejamento de redes redundantes em TI empresarial."
                              ],
                              "realWorldApplication": "Em data centers e LANs corporativas, STP garante redundância sem loops, evitando falhas em massa como broadcast storms que derrubam redes inteiras durante picos de tráfego."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.2",
                            "name": "Explicar VLANs (IEEE 802.1Q)",
                            "description": "Detalhar o tagging de quadros com VID (VLAN ID), trunk ports e como VLANs segmentam broadcasts no domínio de enlace.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de VLANs e sua Necessidade",
                                  "subSteps": [
                                    "Defina VLAN como uma rede lógica segmentada em um switch físico.",
                                    "Explique que VLANs criam domínios de broadcast separados para melhorar segurança e performance.",
                                    "Discuta limitações de redes planas sem VLANs, como broadcasts excessivos.",
                                    "Identifique cenários onde VLANs são essenciais, como em empresas com departamentos isolados.",
                                    "Crie um diagrama simples mostrando uma rede sem e com VLANs."
                                  ],
                                  "verification": "Desenhe um diagrama comparando rede plana vs. VLANs e explique verbalmente as diferenças.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Vídeo introdutório sobre VLANs (YouTube: 'What is VLAN')"
                                  ],
                                  "tips": "Use analogia de apartamentos em um prédio: switch é o prédio, VLANs são andares isolados.",
                                  "learningObjective": "Explicar o propósito e benefícios das VLANs na segmentação de redes.",
                                  "commonMistakes": [
                                    "Confundir VLANs com sub-redes IP",
                                    "Achar que VLANs substituem roteadores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Padrão IEEE 802.1Q e Tagging de Frames",
                                  "subSteps": [
                                    "Descreva o header 802.1Q: TPID (0x8100), Priority (3 bits), CFI (1 bit), VID (12 bits para 4096 VLANs).",
                                    "Explique como um frame untagged se torna tagged ao entrar em uma VLAN.",
                                    "Simule o processo de tagging: frame Ethernet + header 802.1Q.",
                                    "Diferencie frames tagged de untagged e native VLAN.",
                                    "Analise um exemplo de frame com Wireshark ou diagrama."
                                  ],
                                  "verification": "Identifique e rotule componentes de um frame 802.1Q em um diagrama fornecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama de frame Ethernet 802.1Q",
                                    "Ferramenta Wireshark ou imagem de captura de pacotes"
                                  ],
                                  "tips": "Lembre-se: VID 0 é prioridade, VID 4095 reservado; foque em VID 1-4094.",
                                  "learningObjective": "Detalhar a estrutura do tagging IEEE 802.1Q e seu impacto nos frames.",
                                  "commonMistakes": [
                                    "Confundir TPID com VID",
                                    "Ignorar que tagging adiciona 4 bytes ao frame"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Access Ports e Trunk Ports",
                                  "subSteps": [
                                    "Defina access port: porta para um host em uma única VLAN, envia/recebe untagged.",
                                    "Defina trunk port: carrega tráfego de múltiplas VLANs, usa tagging 802.1Q.",
                                    "Explique negociação DTP (Dynamic Trunking Protocol) para trunks.",
                                    "Configure conceitualmente um trunk permitindo VLANs específicas (ex: allowed VLANs 10,20).",
                                    "Descreva native VLAN em trunks (untagged para uma VLAN padrão)."
                                  ],
                                  "verification": "Classifique portas em um cenário de switch e justifique se é access ou trunk.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador Cisco Packet Tracer",
                                    "Documentação Cisco sobre port modes"
                                  ],
                                  "tips": "Teste em simulador: 'switchport mode trunk' vs 'switchport mode access'.",
                                  "learningObjective": "Distinguir e explicar configurações de portas para VLANs.",
                                  "commonMistakes": [
                                    "Achar que access ports suportam múltiplas VLANs",
                                    "Esquecer native VLAN em trunks"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Segmentação de Broadcasts com VLANs",
                                  "subSteps": [
                                    "Explique domínio de broadcast: frames broadcast (FF:FF:FF:FF:FF:FF) não cruzam VLANs.",
                                    "Simule um broadcast em uma VLAN: fica confinado ao switch ports da mesma VLAN.",
                                    "Compare com rede sem VLANs: broadcast inunda todos os ports.",
                                    "Discuta benefícios: redução de tráfego, isolamento de falhas.",
                                    "Verifique com exemplo: ping broadcast em hosts de VLANs diferentes."
                                  ],
                                  "verification": "Explique por que um broadcast de VLAN 10 não atinge VLAN 20 em um diagrama.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Packet Tracer com topologia de múltiplas VLANs",
                                    "Captura Wireshark de broadcast"
                                  ],
                                  "tips": "Use 'debug ip packet' em simuladores para visualizar floods.",
                                  "learningObjective": "Demonstrar como VLANs limitam domínios de broadcast no layer 2.",
                                  "commonMistakes": [
                                    "Pensar que VLANs segmentam no layer 3",
                                    "Confundir broadcast com unicast tagged"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ambiente corporativo, configure VLAN 10 para Finanças e VLAN 20 para RH em um switch Cisco. Use trunk entre switches para conectar servidores. Um broadcast de impressora na VLAN 10 não chega ao RH, evitando congestionamento.",
                              "finalVerifications": [
                                "Explicar corretamente o header 802.1Q com VID.",
                                "Diferenciar access vs trunk ports com exemplos.",
                                "Desenhar diagrama mostrando broadcast confinado a uma VLAN.",
                                "Identificar native VLAN em um trunk.",
                                "Simular tagging em Packet Tracer.",
                                "Listar 3 benefícios de VLANs para broadcasts."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do tagging 802.1Q (80% dos componentes corretos).",
                                "Clareza na distinção de port types com exemplos práticos.",
                                "Correta representação de segmentação de broadcasts em diagramas.",
                                "Uso correto de terminologia IEEE (VID, TPID, trunk).",
                                "Capacidade de simular configuração básica em ferramenta.",
                                "Explicação integrada de todos os conceitos."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: VLANs como controle de acesso layer 2.",
                                "Administração de Sistemas: Configuração em switches empresariais.",
                                "Matemática: Cálculo de overhead de 4 bytes em frames.",
                                "Física: Analogia com isolamento elétrico em redes.",
                                "Gestão de Projetos: Planejamento de segmentação em implantações de rede."
                              ],
                              "realWorldApplication": "Em data centers como AWS ou empresas como bancos, VLANs isolam tráfego sensível (ex: pagamentos em VLAN separada), reduzem latência de broadcasts e facilitam escalabilidade sem rewiring físico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.3",
                            "name": "Identificar funções de bridges",
                            "description": "Descrever filtragem e encaminhamento baseado em tabelas MAC, aprendizado transparente e seu papel na extensão de LANs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico e o Papel dos Bridges na Extensão de LANs",
                                  "subSteps": [
                                    "Defina um bridge como um dispositivo de camada 2 que conecta segmentos de LAN.",
                                    "Explique como bridges estendem LANs reduzindo colisões e melhorando desempenho.",
                                    "Diferencie bridges de repetidores (amplificam sinal) e hubs (flooding de frames).",
                                    "Identifique limitações: bridges não segmentam broadcast domains completamente.",
                                    "Descreva topologias comuns: bridges conectando CSMA/CD Ethernet segments."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o papel dos bridges em extensão de LANs e recite sem olhar notas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cisco Networking Academy: Módulo IEEE 802.1",
                                    "Livro 'Redes de Computadores' de Tanenbaum (Capítulo 4)",
                                    "Vídeo Khan Academy sobre LANs"
                                  ],
                                  "tips": "Visualize bridges como 'porteiros' que decidem se um pacote passa ou não entre salas (segmentos).",
                                  "learningObjective": "Entender o propósito fundamental dos bridges na arquitetura de redes locais.",
                                  "commonMistakes": [
                                    "Confundir bridges com routers (layer 3 vs layer 2)",
                                    "Acreditar que bridges eliminam broadcasts completamente",
                                    "Ignorar que bridges são predecessores dos switches modernos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Filtragem e Encaminhamento Baseado em Tabelas MAC",
                                  "subSteps": [
                                    "Descreva a tabela MAC de um bridge: mapeamento de endereços MAC para portas.",
                                    "Explique filtragem: frames descartados se destino conhecido na mesma porta de origem.",
                                    "Detalhe encaminhamento: frames enviados apenas para porta com MAC destino conhecido.",
                                    "Discuta flooding: frames desconhecidos enviados para todas as portas exceto origem.",
                                    "Simule um exemplo: frame de PC1 para PC2 atravessa bridge ou é filtrado."
                                  ],
                                  "verification": "Desenhe uma tabela MAC simples e simule filtragem/encaminhamento para 3 frames de teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador Packet Tracer (Cisco)",
                                    "Folha de papel para diagramas",
                                    "Tutorial YouTube: 'Bridge MAC Learning'"
                                  ],
                                  "tips": "Lembre-se: tabela MAC é dinâmica e envelhece (timeout ~5 minutos para entradas inativas).",
                                  "learningObjective": "Dominar mecanismos de decisão de frames em bridges usando tabelas MAC.",
                                  "commonMistakes": [
                                    "Pensar que bridges usam IP para decisões (só MAC)",
                                    "Esquecer flooding para MACs desconhecidos",
                                    "Confundir filtragem com roteamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Aprendizado Transparente (Transparent Bridging)",
                                  "subSteps": [
                                    "Defina aprendizado transparente: bridges 'escutam' frames para aprender MACs dinamicamente.",
                                    "Descreva o processo: ao receber frame, aprende MAC origem/porta e atualiza tabela.",
                                    "Explique STP (Spanning Tree Protocol) para evitar loops em topologias redundantes.",
                                    "Simule aprendizado: sequência de frames e evolução da tabela MAC.",
                                    "Discuta vantagens: configuração zero, autoconfiguração em redes Ethernet."
                                  ],
                                  "verification": "Registre passos de aprendizado para uma topologia de 3 PCs e 1 bridge em um diagrama.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Packet Tracer ou GNS3 para simulação",
                                    "Documentação IEEE 802.1D",
                                    "Artigo Wikipedia: Transparent Bridging"
                                  ],
                                  "tips": "Use 'show mac address-table' em simuladores para visualizar aprendizado em tempo real.",
                                  "learningObjective": "Compreender como bridges constroem tabelas MAC automaticamente sem configuração manual.",
                                  "commonMistakes": [
                                    "Ignorar timeouts na tabela MAC",
                                    "Confundir com source-route bridging (IBM)",
                                    "Esquecer STP para loops"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Funções e Aplicar em Cenários Práticos",
                                  "subSteps": [
                                    "Resuma todas funções: filtragem, encaminhamento, aprendizado transparente.",
                                    "Analise impacto: redução de tráfego desnecessário e extensão eficiente de LANs.",
                                    "Compare com switches: bridges de 2 portas vs switches multi-porta.",
                                    "Discuta evoluções: VLANs e bridges virtuais em switches modernos.",
                                    "Planeje um lab: configure bridge virtual e teste filtragem."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as 3 funções principais com um exemplo integrado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Packet Tracer lab file",
                                    "Quiz online Cisco sobre bridges",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Teste cenários de falha: o que acontece se MAC não estiver na tabela?",
                                  "learningObjective": "Sintetizar funções de bridges para identificação e descrição completa.",
                                  "commonMistakes": [
                                    "Subestimar broadcast storms sem STP",
                                    "Achar bridges obsoletos (ainda base para switches)",
                                    "Misturar com layer 3 switching"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma LAN de escritório com dois segmentos (Sala A e Sala B), um bridge conecta-os. PCs na Sala A enviam frames para PCs na Sala B: bridge aprende MACs, filtra tráfego local à Sala A (não encaminha para B) e encaminha apenas inter-segmento, reduzindo colisões em 50%. Simule no Packet Tracer adicionando PCs, bridge e capturando tráfego com Wireshark.",
                              "finalVerifications": [
                                "Descreva corretamente filtragem e encaminhamento com tabela MAC em um diagrama.",
                                "Explique aprendizado transparente com sequência de 4 frames exemplo.",
                                "Identifique papel de bridges na extensão de LANs sem erros.",
                                "Diferencie bridge de switch e hub.",
                                "Simule um cenário sem loops usando STP básico.",
                                "Liste 3 vantagens do transparent bridging."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de tabela MAC e decisões de frame (90% correto).",
                                "Profundidade no aprendizado transparente (inclui timeouts e flooding).",
                                "Capacidade de diagramar topologias e fluxos de frames.",
                                "Integração correta de funções em cenários reais.",
                                "Identificação de erros comuns e STP para loops.",
                                "Explicação clara do impacto na performance de LANs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de dados (tabelas hash para MAC lookup).",
                                "Física: Propagação de sinais Ethernet e detecção de colisões CSMA/CD.",
                                "Segurança da Informação: Segmentação de rede para isolamento de broadcasts/malware.",
                                "Programação: Implementação de bridges em Python com Scapy para captura MAC.",
                                "Administração: Planejamento de infraestrutura de rede em empresas."
                              ],
                              "realWorldApplication": "Em redes corporativas legadas ou IoT, bridges estendem LANs em prédios antigos, segmentam tráfego para melhorar performance (ex: hospitais conectando alas sem switches caros), e formam base para switches gerenciados em data centers, reduzindo latência e colisões em ambientes com alto tráfego local."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Necessidade de Protocolos e Modelo TCP/IP",
                "description": "Explica a importância dos protocolos e apresenta o modelo TCP/IP.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Necessidade de Protocolos em Redes",
                    "description": "Explica os motivos e problemas resolvidos pela adoção de protocolos padronizados em redes de computadores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Heterogeneidade em Redes de Computadores",
                        "description": "Explora as diferenças em hardware e software que tornam a comunicação em redes desafiadora sem padrões comuns.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Identificar diferenças de hardware em redes",
                            "description": "Reconhecer variações em dispositivos como roteadores, switches e hosts de diferentes fabricantes que impedem comunicação direta sem protocolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes básicos de hardware de rede",
                                  "subSteps": [
                                    "Liste os principais dispositivos de rede: roteadores, switches e hosts (computadores, servidores).",
                                    "Descreva a função primária de cada um: roteadores conectam redes diferentes, switches conectam dispositivos na mesma rede, hosts enviam/recebem dados.",
                                    "Identifique interfaces comuns: portas Ethernet (RJ-45), Wi-Fi, seriais (para roteadores avançados).",
                                    "Pesquise exemplos de fabricantes populares: Cisco, TP-Link, Ubiquiti para roteadores/switches; Dell, HP para hosts.",
                                    "Anote variações físicas: tamanho, número de portas, suporte a PoE (Power over Ethernet)."
                                  ],
                                  "verification": "Crie um diagrama simples com os três tipos de dispositivos e suas funções principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou software de diagramação como Draw.io; acesso à internet para pesquisa básica.",
                                  "tips": "Use imagens reais de dispositivos para visualização melhor.",
                                  "learningObjective": "Diferenciar funções e interfaces básicas de hardware de rede.",
                                  "commonMistakes": "Confundir roteador com switch (roteador gerencia tráfego entre redes, switch é layer 2)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar diferenças técnicas entre fabricantes",
                                  "subSteps": [
                                    "Compare interfaces físicas: Cisco usa portas modulares (GBIC/SFP), TP-Link usa RJ-45 fixas.",
                                    "Examine protocolos proprietários: Cisco tem DTP (Dynamic Trunking Protocol), outros usam padrões 802.1Q.",
                                    "Verifique velocidades suportadas: alguns switches gigabit vs. fast Ethernet em modelos baratos.",
                                    "Identifique diferenças em firmware: atualizações proprietárias vs. open-source como OpenWRT.",
                                    "Registre variações em autenticação: RADIUS em enterprise vs. WPA2 simples em consumer."
                                  ],
                                  "verification": "Elabore uma tabela comparativa com pelo menos 3 fabricantes e 4 diferenças por dispositivo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha (Google Sheets ou Excel); sites de fabricantes (Cisco.com, TP-Link.com).",
                                  "tips": "Foque em specs de modelos específicos, como Cisco Catalyst 2960 vs. TP-Link TL-SG108.",
                                  "learningObjective": "Reconhecer especificações técnicas que variam por fabricante.",
                                  "commonMistakes": "Ignorar diferenças de layer (OSI): hardware layer 1/2 vs. software layer 3+."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar impactos das diferenças na comunicação",
                                  "subSteps": [
                                    "Simule incompatibilidade: tente conectar switch Cisco (trunking proprietário) a switch genérico.",
                                    "Explique necessidade de padrões: Ethernet IEEE 802.3 resolve cabos/interfaces, mas não configs avançadas.",
                                    "Discuta VLANs: tags 802.1Q universais, mas native VLAN difere por vendor.",
                                    "Analise hosts: drivers de NIC variam, causando issues sem protocolos como IP.",
                                    "Teste conceitualmente: sem protocolo, frames não são interpretados corretamente."
                                  ],
                                  "verification": "Descreva em parágrafos um cenário onde dois dispositivos não se comunicam e por quê.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Simulador de rede como Packet Tracer (gratuito); vídeos YouTube sobre incompatibilidades.",
                                  "tips": "Use Packet Tracer para simular falhas reais sem hardware físico.",
                                  "learningObjective": "Entender como diferenças impedem comunicação direta.",
                                  "commonMistakes": "Atribuir falhas só a software, ignorando hardware físico (ex: conector não padrão)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em cenários reais",
                                  "subSteps": [
                                    "Examine hardware local: identifique modelo/marca de roteador, switch e PC.",
                                    "Pesquise datasheet online e liste 3 diferenças potenciais com outro fabricante.",
                                    "Crie checklist de verificação para interoperabilidade.",
                                    "Discuta soluções: usar protocolos padronizados como TCP/IP para abstrair diferenças.",
                                    "Registre lições aprendidas em um relatório curto."
                                  ],
                                  "verification": "Apresente checklist e relatório com exemplos reais do seu ambiente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Hardware de rede local; acesso internet para datasheets.",
                                  "tips": "Fotografe dispositivos para referência visual.",
                                  "learningObjective": "Aplicar conhecimento para identificar diferenças práticas.",
                                  "commonMistakes": "Superestimar compatibilidade de marcas consumer sem testar."
                                }
                              ],
                              "practicalExample": "Em uma rede doméstica, um roteador TP-Link (portas RJ-45 fixas, WPA2-PSK) não se comunica diretamente com um switch Cisco Catalyst (portas SFP, 802.1Q trunking) sem configuração de VLAN padrão e conversor de mídia, destacando necessidade de protocolos como Ethernet e IP para mediação.",
                              "finalVerifications": [
                                "Pode listar 5 diferenças chave entre roteadores Cisco e TP-Link.",
                                "Explica corretamente por que switches de fabricantes diferentes precisam de 802.1Q para trunking.",
                                "Identifica interfaces incompatíveis em um diagrama misto de vendors.",
                                "Simula em Packet Tracer uma falha de comunicação e corrige com protocolo.",
                                "Cria tabela comparativa precisa de hardware hosts vs. switches.",
                                "Descreve impacto de PoE proprietário em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas diferenças identificadas (sem erros factuais).",
                                "Completude da tabela/diagrama (cobertura de pelo menos 3 dispositivos).",
                                "Clareza na explicação de impactos na comunicação.",
                                "Uso correto de terminologia de rede (layer, protocolo, interface).",
                                "Criatividade no exemplo prático e conexões reais.",
                                "Profundidade nos substeps (mínimo 4 por step)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Entender sinais elétricos em interfaces RJ-45 vs. fibra ótica.",
                                "Matemática: Cálculo de throughput baseado em velocidades de portas variáveis.",
                                "Física: Propagação de sinais em cabos e limitações de hardware.",
                                "Programação: Desenvolvimento de drivers de rede para hosts específicos."
                              ],
                              "realWorldApplication": "Em TI empresarial, administradores de rede usam esse conhecimento para troubleshooting em ambientes multi-vendor, evitando downtime ao configurar protocolos padronizados como TCP/IP, garantindo interoperabilidade em data centers híbridos de Cisco, Juniper e Huawei."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Identificar diferenças de software em redes",
                            "description": "Analisar como sistemas operacionais e aplicações distintas criam incompatibilidades na troca de dados sem protocolos padronizados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender diferenças fundamentais em Sistemas Operacionais",
                                  "subSteps": [
                                    "Pesquise os principais SOs de rede: Windows, Linux (Ubuntu) e macOS.",
                                    "Liste diferenças em gerenciamento de rede: como Windows usa NetBIOS vs. Linux usa sockets Unix.",
                                    "Compare estruturas de arquivos: NTFS vs. ext4 vs. APFS e impactos em compartilhamento.",
                                    "Identifique diferenças em autenticação: Kerberos no Windows vs. PAM no Linux.",
                                    "Documente como essas diferenças afetam comunicação direta sem abstrações."
                                  ],
                                  "verification": "Criar uma tabela comparativa com pelo menos 5 diferenças chave documentadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Computador com acesso à internet, navegadores, notas ou planilha (Google Sheets).",
                                  "tips": "Use diagramas Venn para visualizar sobreposições e diferenças claramente.",
                                  "learningObjective": "Compreender como variações em SOs criam barreiras nativas na comunicação de rede.",
                                  "commonMistakes": "Confundir diferenças de hardware com software; focar apenas em interfaces gráficas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar diferenças em aplicações de software",
                                  "subSteps": [
                                    "Selecione aplicações comuns: browsers (Chrome vs. Firefox), editores de texto (Notepad++ vs. Vim).",
                                    "Examine formatos de dados proprietários: .docx do MS Word vs. .odt do LibreOffice.",
                                    "Compare protocolos de comunicação embutidos: APIs REST em apps web vs. sockets em apps desktop.",
                                    "Teste compatibilidade básica: abra um arquivo criado em uma app no outro SO/app.",
                                    "Registre falhas observadas, como corrupção de dados ou rejeição de conexão."
                                  ],
                                  "verification": "Gerar relatório com screenshots de 3 testes de compatibilidade falhados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Múltiplos SOs via VMs (VirtualBox gratuito), aplicações instaladas em cada.",
                                  "tips": "Instale VMs leves para simular ambientes sem custo alto.",
                                  "learningObjective": "Identificar como apps heterogêneas amplificam incompatibilidades de SO.",
                                  "commonMistakes": "Ignorar diferenças em bibliotecas subjacentes como OpenSSL vs. proprietárias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular troca de dados sem protocolos padronizados",
                                  "subSteps": [
                                    "Configure uma rede local simples entre dois SOs diferentes (ex: Windows e Linux).",
                                    "Tente transferir dados raw via sockets TCP diretos sem HTTP/FTP.",
                                    "Envie um arquivo binário simples (imagem) e observe falhas de parsing.",
                                    "Repita com dados textuais formatados diferentemente (ex: encoding UTF-8 vs. ANSI).",
                                    "Analise logs de erro para mapear causas de incompatibilidade."
                                  ],
                                  "verification": "Capturar logs de rede (Wireshark) mostrando falhas de handshake ou parsing.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "VirtualBox ou rede física, Wireshark (gratuito), comandos de socket (netcat).",
                                  "tips": "Use netcat (nc) para simulações rápidas: nc -l -p 1234 no receptor.",
                                  "learningObjective": "Demonstrar empiricamente incompatibilidades na troca de dados heterogênea.",
                                  "commonMistakes": "Assumir que firewalls são a única causa; desative temporariamente para isolar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar análise de incompatibilidades",
                                  "subSteps": [
                                    "Compile achados dos steps anteriores em um diagrama de fluxo de falhas.",
                                    "Classifique incompatibilidades: semânticas (interpretação de dados), sintáticas (formatos), de protocolo.",
                                    "Discuta cenários onde isso ocorre: redes peer-to-peer sem middleware.",
                                    "Proponha hipóteses de como protocolos padronizados mitigam isso.",
                                    "Crie um resumo executivo com recomendações."
                                  ],
                                  "verification": "Produzir diagrama e resumo de 1 página explicando 3 incompatibilidades principais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas de diagramação (Draw.io gratuito), documento de texto.",
                                  "tips": "Use setas em diagramas para mostrar 'ponto de falha' claramente.",
                                  "learningObjective": "Integrar conhecimentos para analisar impactos sistêmicos de heterogeneidade.",
                                  "commonMistakes": "Generalizar demais sem evidências empíricas dos testes."
                                }
                              ],
                              "practicalExample": "Em uma rede doméstica, tente compartilhar uma planilha Excel (.xlsx) criada no Windows/MS Office para um Linux/LibreOffice via compartilhamento SMB direto. O Linux falha ao interpretar metadados proprietários do Excel, corrompendo fórmulas, ilustrando incompatibilidade sem protocolo como SMBv3 ou conversão via ODF.",
                              "finalVerifications": [
                                "Lista precisa de 5+ diferenças entre SOs em gerenciamento de rede.",
                                "Relatório com evidências de 3 testes de apps incompatíveis.",
                                "Capturas de Wireshark mostrando falhas em trocas raw.",
                                "Diagrama de fluxo identificando causas raiz de incompatibilidades.",
                                "Explicação clara de como protocolos padronizados resolvem heterogeneidade.",
                                "Resumo conectando achados ao contexto de redes reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de diferenças de SO (0-25%)",
                                "Qualidade e profundidade de testes de aplicações (0-25%)",
                                "Análise empírica de trocas de dados via logs (0-20%)",
                                "Síntese em diagrama e resumo coerente (0-20%)",
                                "Conexão explícita à necessidade de protocolos (0-10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação binária e endianness em dados de rede.",
                                "Física: Transmissão de sinais analógicos vs. digitais em hardware heterogêneo.",
                                "História: Evolução de SOs desde UNIX vs. MS-DOS.",
                                "Língua Portuguesa: Análise de logs técnicos e redação de relatórios claros."
                              ],
                              "realWorldApplication": "Em empresas com frotas mistas de Windows e Linux (ex: servidores cloud AWS), identificar essas diferenças previne falhas em integrações IoT ou migrações de dados, garantindo uso de protocolos como TCP/IP para interoperabilidade em indústrias como manufatura e telecom."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Exemplificar problemas causados pela heterogeneidade",
                            "description": "Descrever cenários reais onde hardware e software heterogêneos falham em se comunicar, como pacotes não interpretados entre redes diferentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de heterogeneidade em redes de computadores",
                                  "subSteps": [
                                    "Defina heterogeneidade como a presença de hardware, software, protocolos ou arquiteturas diferentes em uma rede.",
                                    "Classifique tipos: hardware (ex: processadores Intel vs ARM), software (SOs Windows vs Linux), protocolos (Ethernet vs Wi-Fi).",
                                    "Pesquise exemplos históricos, como redes proprietárias dos anos 80.",
                                    "Crie um diagrama simples mostrando uma rede homogênea vs heterogênea.",
                                    "Anote impactos potenciais na comunicação de dados."
                                  ],
                                  "verification": "Diagrama criado e definições anotadas corretamente, sem erros conceituais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel/caneta ou ferramenta de diagramação como Draw.io; acesso à internet para pesquisa rápida.",
                                  "tips": "Use analogias cotidianas, como pessoas falando línguas diferentes em uma reunião.",
                                  "learningObjective": "Dominar a definição e classificação de heterogeneidade para basear exemplos de problemas.",
                                  "commonMistakes": "Confundir heterogeneidade com redundância ou confundir hardware com software."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar problemas causados por diferenças de hardware",
                                  "subSteps": [
                                    "Estude diferenças físicas: tamanhos de frames Ethernet (1500 bytes) vs outros padrões.",
                                    "Simule falha: dispositivo com MTU diferente descartando pacotes grandes.",
                                    "Analise velocidades: rede 10Mbps tentando conectar a 1Gbps causando colisões.",
                                    "Registre exemplo: roteador Cisco com Apple AirPort falhando em negociação de link.",
                                    "Liste 3 impactos: perda de pacotes, atrasos, incompatibilidade de cabos/conectores."
                                  ],
                                  "verification": "Lista de 3 exemplos de falhas de hardware com descrições curtas e precisas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação técnica de Ethernet (RFC 894); simulador de rede como Cisco Packet Tracer.",
                                  "tips": "Foque em camadas físicas (OSI 1) para manter o escopo claro.",
                                  "learningObjective": "Reconhecer falhas específicas de hardware heterogêneo na comunicação.",
                                  "commonMistakes": "Ignorar diferenças de camada física e focar só em software."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar problemas decorrentes de heterogeneidade de software e protocolos",
                                  "subSteps": [
                                    "Explore diferenças de protocolos: TCP/IP vs IPX/SPX em redes Novell.",
                                    "Descreva pacotes não interpretados: headers incompatíveis levando a rejeição.",
                                    "Simule cenário: máquina Linux enviando dados para Windows sem Samba ativo.",
                                    "Identifique erros comuns: checksums falhando, ordem de bytes (big-endian vs little-endian).",
                                    "Crie tabela comparativa de protocolos heterogêneos e seus problemas."
                                  ],
                                  "verification": "Tabela comparativa completa com pelo menos 4 protocolos e problemas associados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Wireshark para captura de pacotes; RFCs de protocolos (ex: RFC 791 para IP).",
                                  "tips": "Capture tráfego real em sua rede local para visualizar headers.",
                                  "learningObjective": "Exemplificar falhas de software/protocolos em cenários reais de rede.",
                                  "commonMistakes": "Generalizar demais sem citar protocolos específicos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e exemplificar cenários reais completos de falhas",
                                  "subSteps": [
                                    "Monte cenário 1: Rede corporativa misturando switches Ethernet e Token Ring legados.",
                                    "Monte cenário 2: IoT com sensores Zigbee e dispositivos Wi-Fi sem gateway.",
                                    "Descreva falhas: pacotes perdidos, timeouts, necessidade de tradução manual.",
                                    "Apresente em narrativa: 'Empresa X perdeu dados por incompatibilidade ARM-x86'.",
                                    "Valide com referências reais, como problemas Y2K em redes heterogêneas."
                                  ],
                                  "verification": "Dois cenários narrados com falhas detalhadas e soluções implícitas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas de escrita (Google Docs); casos de estudo online sobre falhas de rede.",
                                  "tips": "Torne vívido com impactos: 'perda de US$1M em transações falhas'.",
                                  "learningObjective": "Sintetizar conhecimentos em exemplos acionáveis e realistas.",
                                  "commonMistakes": "Criar cenários irreais ou sem ligação clara à heterogeneidade."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa, um servidor Windows com software legado envia pacotes com headers IPX para um cliente Linux esperando TCP/IP. Os pacotes são descartados como 'não interpretados', causando falha total na transferência de arquivos, timeouts e necessidade de reinstalação de protocolos comuns como Samba.",
                              "finalVerifications": [
                                "Pode listar pelo menos 5 problemas específicos causados por heterogeneidade.",
                                "Consegue diagramar um cenário de falha com hardware/software diferentes.",
                                "Explica corretamente por que pacotes não são interpretados em redes heterogêneas.",
                                "Identifica soluções básicas como protocolos padronizados (ex: TCP/IP).",
                                "Cria um exemplo original realista de problema em IoT ou rede empresarial.",
                                "Demonstra compreensão diferenciando heterogeneidade de outros problemas de rede."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nos exemplos (sem erros conceituais).",
                                "Detalhe e clareza nas descrições de cenários.",
                                "Uso de exemplos reais ou simulados viáveis.",
                                "Conexão explícita entre heterogeneidade e problemas de comunicação.",
                                "Criatividade na construção de narrativas práticas.",
                                "Completude da tabela/diagrama de análise."
                              ],
                              "crossCurricularConnections": [
                                "Física: Ondas eletromagnéticas e interferências em mídias heterogêneas.",
                                "Matemática: Codificação binária e endianness em representações numéricas.",
                                "Língua Portuguesa: Redação clara de relatórios técnicos de falhas.",
                                "História da Computação: Evolução de redes proprietárias para padronizadas."
                              ],
                              "realWorldApplication": "Na Internet global, heterogeneidade é resolvida por TCP/IP, mas falhas persistem em IoT (ex: smart homes com protocolos Z-Wave e Bluetooth colidindo), redes industriais (Indústria 4.0 com PLCs legados) e cibersegurança (ataques explorando incompatibilidades de protocolos)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Complexidade da Comunicação em Redes",
                        "description": "Detalha as múltiplas tarefas necessárias para comunicação confiável, que demandam regras padronizadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Listar tarefas básicas de comunicação em redes",
                            "description": "Enumerar funções como enquadramento de dados, endereçamento, roteamento, detecção e correção de erros sem as quais a comunicação falha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a complexidade da comunicação em redes e identificar tarefas básicas",
                                  "subSteps": [
                                    "Pesquise o que é comunicação em redes e por que ela é complexa sem protocolos.",
                                    "Identifique problemas comuns como perda de dados, erros de transmissão e roteamento incorreto.",
                                    "Liste intuitivamente 4-5 tarefas que uma rede deve realizar para comunicação bem-sucedida.",
                                    "Compare sua lista inicial com exemplos padrão de protocolos como TCP/IP.",
                                    "Anote definições preliminares para cada tarefa identificada."
                                  ],
                                  "verification": "Você tem uma lista inicial de pelo menos 4 tarefas com definições breves anotadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Livro ou site sobre redes (ex: Khan Academy, Cisco Networking Basics)",
                                    "Caderno e caneta"
                                  ],
                                  "tips": "Comece com analogias cotidianas, como enviar uma carta pelo correio, para visualizar as tarefas.",
                                  "learningObjective": "Entender a necessidade de tarefas básicas para comunicação confiável em redes.",
                                  "commonMistakes": "Confundir tarefas de rede com aplicações de software; ignorar a sequência lógica das tarefas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar enquadramento de dados e detecção/correção de erros",
                                  "subSteps": [
                                    "Defina enquadramento de dados e seu papel em separar bits em frames.",
                                    "Aprenda sobre detecção de erros (ex: CRC, checksum) e correção (ex: retransmissão).",
                                    "Desenhe um diagrama simples de um frame de dados com campos de controle de erro.",
                                    "Explique por que sem enquadramento e controle de erros a comunicação falha.",
                                    "Crie um exemplo de frame corrompido e como detectá-lo."
                                  ],
                                  "verification": "Diagrama de frame desenhado e exemplo de detecção de erro descrito corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Internet para tutoriais (ex: YouTube sobre framing em redes)",
                                    "Papel e lápis para diagramas",
                                    "Simulador online de frames (opcional, como Wireshark demo)"
                                  ],
                                  "tips": "Use ferramentas visuais como diagramas para fixar conceitos; teste com bits simples (ex: 1011).",
                                  "learningObjective": "Dominar como dados são preparados e protegidos contra erros na camada de enlace.",
                                  "commonMistakes": "Confundir enquadramento com encapsulamento; achar que checksum corrige erros automaticamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar endereçamento e roteamento",
                                  "subSteps": [
                                    "Defina endereçamento (MAC e IP) e sua importância para identificar remetente/destinatário.",
                                    "Estude roteamento: como pacotes viajam através de múltiplos nós usando tabelas de roteamento.",
                                    "Compare endereçamento lógico (IP) vs físico (MAC).",
                                    "Simule um caminho de roteamento de um pacote de casa para servidor.",
                                    "Liste protocolos relacionados (ex: ARP, ICMP)."
                                  ],
                                  "verification": "Pode traçar um caminho de roteamento simples e diferenciar tipos de endereços.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramentas online como Cisco Packet Tracer (versão gratuita)",
                                    "Vídeos sobre OSI model layers 2-3",
                                    "Mapa mental software (ex: Draw.io)"
                                  ],
                                  "tips": "Pratique com traceroute no seu computador para ver roteamento real.",
                                  "learningObjective": "Compreender como dados são direcionados corretamente em redes multi-hop.",
                                  "commonMistakes": "Misturar MAC (local) com IP (global); ignorar o papel de switches vs roteadores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar e listar todas as tarefas básicas de comunicação",
                                  "subSteps": [
                                    "Reúna todas as tarefas: enquadramento, endereçamento, roteamento, detecção/correção de erros.",
                                    "Ordene-as logicamente na sequência de transmissão.",
                                    "Escreva uma lista numerada com uma frase explicativa para cada.",
                                    "Crie um fluxograma mostrando dependências entre tarefas.",
                                    "Teste sua lista explicando para alguém ou gravando um áudio."
                                  ],
                                  "verification": "Lista completa de 4-5 tarefas com explicações e fluxograma finalizados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Caderno com anotações anteriores",
                                    "Ferramenta de fluxograma (ex: Lucidchart free)",
                                    "Gravador de voz (celular)"
                                  ],
                                  "tips": "Garanta que cada tarefa seja 'básica' e essencial; revise contra modelo TCP/IP.",
                                  "learningObjective": "Sintetizar conhecimento em uma lista acionável de tarefas indispensáveis.",
                                  "commonMistakes": "Omitir tarefas chave; listar funções avançadas como criptografia em vez de básicas."
                                }
                              ],
                              "practicalExample": "Ao enviar um email de seu laptop para um servidor via WiFi: dados são enquadrados em frames Ethernet com checksum para erros; endereçados com IP/MAC; roteados por roteadores domésticos e ISP até o destino, com detecção de erros em cada hop.",
                              "finalVerifications": [
                                "Pode listar verbalmente as 4 tarefas principais sem hesitação.",
                                "Explica corretamente o impacto de falha em cada tarefa.",
                                "Desenha um frame básico com campos chave.",
                                "Traça um roteamento simples de 3 hops.",
                                "Identifica erros comuns em exemplos dados."
                              ],
                              "assessmentCriteria": [
                                "Lista inclui todas as tarefas essenciais (enquadramento, endereçamento, roteamento, detecção/correção) - 30%",
                                "Cada tarefa descrita com precisão e exemplo - 25%",
                                "Sequência lógica demonstrada via fluxograma - 20%",
                                "Verificações e dicas pessoais adicionadas - 15%",
                                "Compreensão de dependências entre tarefas - 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos de checksum e CRC para detecção de erros.",
                                "Física: Propagação de sinais e interferências afetando erros de transmissão.",
                                "Língua Portuguesa: Analogias claras para explicar conceitos técnicos a leigos.",
                                "História da Tecnologia: Evolução de protocolos desde ARPANET."
                              ],
                              "realWorldApplication": "Essas tarefas sustentam a internet diária, como streaming de vídeo no Netflix (roteamento eficiente), chamadas Zoom (detecção de erros para áudio claro) e navegação web (endereçamento para carregar páginas corretas), evitando falhas que causariam perda de dados ou conexões quebradas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Explicar a necessidade de abstração de complexidades",
                            "description": "Compreender como protocolos ocultam detalhes baixos do nível para permitir que aplicações se comuniquem simplesmente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a complexidade da comunicação direta em redes",
                                  "subSteps": [
                                    "Identifique os desafios de enviar dados diretamente entre computadores: diferenças em hardware, formatos de dados, ruído em cabos, roteamento através de múltiplos dispositivos.",
                                    "Descreva o processo bit a bit: codificação elétrica, detecção de erros, endereçamento físico (MAC), fragmentação em pacotes.",
                                    "Compare com comunicação humana sem linguagem comum: imagine gritar instruções em idiomas diferentes através de uma multidão barulhenta.",
                                    "Liste pelo menos 5 complexidades específicas (ex.: latência, perda de pacotes, variação de velocidades de link).",
                                    "Discuta por que programadores de aplicações não podem lidar com todos esses detalhes diariamente."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo 5 complexidades e explique por que elas tornam a comunicação direta impraticável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Vídeo introdutório sobre camadas de rede (ex.: Khan Academy Redes), papel e caneta para diagrama.",
                                  "tips": "Use analogias cotidianas como dirigir um carro sem saber mecânica para visualizar complexidades ocultas.",
                                  "learningObjective": "Identificar e listar as múltiplas complexidades técnicas na comunicação de rede de baixo nível.",
                                  "commonMistakes": "Confundir complexidades físicas com lógicas; ignorar variações entre redes (Wi-Fi vs. Ethernet)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de abstração em sistemas computacionais",
                                  "subSteps": [
                                    "Defina abstração: processo de esconder detalhes desnecessários para focar em funcionalidades de alto nível.",
                                    "Estude exemplos em programação: funções que abstraem loops, bibliotecas como math.h que escondem algoritmos.",
                                    "Aplique a redes: imagine uma pilha de camadas onde cada uma resolve um problema e passa uma interface simples para a camada superior.",
                                    "Desenhe um diagrama simples de abstração: do bit físico ao 'enviar mensagem' de uma app.",
                                    "Explique benefícios: simplicidade, portabilidade, reutilização de código."
                                  ],
                                  "verification": "Crie um diagrama de abstração com 3 níveis e rotule o que cada nível esconde.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de desenho online (ex.: Draw.io), artigo sobre abstração em CS (Wikipedia Abstração (Ciência da Computação)).",
                                  "tips": "Pense em abstração como caixas pretas: você usa a saída sem abrir para ver os fios internos.",
                                  "learningObjective": "Explicar abstração como mecanismo para simplificar interações complexas em sistemas em camadas.",
                                  "commonMistakes": "Confundir abstração com simplificação total; esquecer que abstrações ainda dependem de camadas inferiores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar como protocolos implementam abstração de complexidades",
                                  "subSteps": [
                                    "Descreva protocolos como contratos padronizados entre camadas: ex. Ethernet cuida de MAC, IP de roteamento.",
                                    "Estude o modelo TCP/IP: cada camada (Link, Internet, Transporte, Aplicação) abstrai a inferior.",
                                    "Analise um fluxo: app chama socket.send() → TCP segmenta e garante entrega → IP roteia → Link transmite bits.",
                                    "Compare sem vs. com protocolos: sem = código custom para cada hardware; com = APIs universais.",
                                    "Discuta trade-offs: overhead de protocolos vs. simplicidade para desenvolvedores."
                                  ],
                                  "verification": "Explique em 200 palavras como um protocolo TCP abstrai complexidades de rede para uma app web.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Diagrama TCP/IP (RFC 1122 resumo), simulador de rede online (ex.: Cisco Packet Tracer gratuito).",
                                  "tips": "Visualize protocolos como tradutores em uma cadeia: cada um converte para o próximo sem que o topo saiba o idioma base.",
                                  "learningObjective": "Demonstrar como protocolos de rede criam interfaces simples ocultando detalhes de baixo nível.",
                                  "commonMistakes": "Achar que protocolos eliminam complexidade (eles a distribuem em camadas); ignorar falhas que 'vazam' para cima."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a necessidade de abstração para comunicação simples de aplicações",
                                  "subSteps": [
                                    "Resuma: sem abstração, apps precisariam de código específico por rede/hardware; com protocolos, usam APIs genéricas.",
                                    "Crie uma tabela comparativa: Colunas 'Sem Protocolos' vs. 'Com Protocolos' para tarefas como enviar email.",
                                    "Discuta escalabilidade: bilhões de dispositivos se comunicam graças a abstrações padronizadas.",
                                    "Reflita: por que desenvolvedores focam em lógica de negócio, não em bits?",
                                    "Prepare um pitch de 1 minuto explicando o conceito para um leigo."
                                  ],
                                  "verification": "Grave ou escreva um pitch de 1 minuto explicando a necessidade de abstração em redes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gravador de voz ou editor de texto, exemplos de código socket (Python socket library).",
                                  "tips": "Use a analogia do correio: você escreve carta, não gerencia caminhões ou aviões.",
                                  "learningObjective": "Articular a necessidade essencial de abstração para permitir desenvolvimento de aplicações focadas em funcionalidades.",
                                  "commonMistakes": "Superestimar simplicidade (apps ainda lidam com erros de rede); não ligar a contextos reais como web apps."
                                }
                              ],
                              "practicalExample": "Ao enviar um email via Gmail, a aplicação web usa uma API simples como 'enviar(mensagem)'. Protocolos como SMTP/TCP/IP abstraem: codificação de texto em bits, detecção de erros, roteamento global através de ISPs, garantindo entrega sem que o programador gerencie cabos ou roteadores.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 complexidades de baixo nível abstraídas por protocolos.",
                                "Desenhar pilha TCP/IP mostrando onde a abstração ocorre em cada camada.",
                                "Comparar código de app com/ sem abstração (ex.: socket API vs. raw bits).",
                                "Identificar em um diagrama de rede qual camada esconde hardware específico.",
                                "Responder: 'Por que um app Android se comunica com servidor Linux sem mudanças?'",
                                "Listar 2 benefícios e 1 limitação da abstração em protocolos."
                              ],
                              "assessmentCriteria": [
                                "Clareza na distinção entre níveis de complexidade (baixo vs. alto).",
                                "Uso preciso de terminologia (abstração, protocolo, camada).",
                                "Qualidade de analogias e diagramas para ilustrar conceitos.",
                                "Profundidade na conexão entre abstração e simplicidade de apps.",
                                "Capacidade de identificar trade-offs (ex.: overhead vs. usabilidade).",
                                "Originalidade no exemplo prático fornecido."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Abstração em funções e módulos modulares.",
                                "Física: Camadas de abstração em sistemas físicos (ex.: circuitos a dispositivos).",
                                "Língua Portuguesa: Abstração linguística em metáforas e hierarquias semânticas.",
                                "História: Evolução de padrões de comunicação humana (idiomas padronizados)."
                              ],
                              "realWorldApplication": "Desenvolvedores de apps como WhatsApp ou Netflix usam bibliotecas de rede (ex.: HTTP clients) sem conhecimento de protocolos PHY/MAC, permitindo foco em UX e escalabilidade global, economizando anos de desenvolvimento em rede customizada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Analisar falhas sem gerenciamento de comunicação",
                            "description": "Discutir perdas de dados, duplicações e desordem de pacotes em redes sem protocolos para controle de fluxo e ordenação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender comunicação em rede sem protocolos de gerenciamento",
                                  "subSteps": [
                                    "Definir comunicação em rede básica: envio de pacotes de dados sem confirmação ou controle.",
                                    "Explicar modelo simples: remetente envia bits/pacotes via meio físico (fio, ar).",
                                    "Identificar ausência de mecanismos: sem ACK, sem numeração sequencial, sem controle de fluxo.",
                                    "Discutir premissas: rede ideal vs. real (ruído, interferência, colisões).",
                                    "Desenhar diagrama de envio unidirecional simples."
                                  ],
                                  "verification": "Criar diagrama mostrando envio sem resposta e pontos potenciais de falha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Vídeo introdutório sobre redes básicas (ex: Khan Academy)"
                                  ],
                                  "tips": "Compare com envio de carta sem aviso de entrega para visualizar simplicidade.",
                                  "learningObjective": "Entender o funcionamento básico de redes sem camadas de gerenciamento.",
                                  "commonMistakes": [
                                    "Assumir que todas as redes têm controle automático",
                                    "Confundir pacotes com mensagens completas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar perdas de dados em redes sem controle",
                                  "subSteps": [
                                    "Explicar causas: ruído no canal, colisões em redes compartilhadas, falhas de hardware.",
                                    "Simular perda: pacote enviado mas não recebido devido a sinal fraco.",
                                    "Discutir impacto: dados incompletos, retransmissão manual ineficiente.",
                                    "Calcular exemplo simples: probabilidade de perda em 10% dos pacotes.",
                                    "Identificar detecção: apenas pela ausência de resposta esperada."
                                  ],
                                  "verification": "Simular perda em um diagrama e explicar consequências para o receptor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador online de redes (ex: Cisco Packet Tracer gratuito)",
                                    "Calculadora para probabilidades"
                                  ],
                                  "tips": "Use analógica: gritar em uma multidão barulhenta onde voz some.",
                                  "learningObjective": "Identificar e descrever mecanismos e impactos de perda de dados.",
                                  "commonMistakes": [
                                    "Ignorar perdas por colisão em redes Ethernet primitivas",
                                    "Pensar que perda só ocorre em wireless"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar duplicações de pacotes sem ordenação",
                                  "subSteps": [
                                    "Descrever causas: retransmissões manuais por dúvida, ecos no canal, loops de roteamento simples.",
                                    "Simular duplicação: remetente envia duas vezes por precaução, receptor recebe cópias.",
                                    "Analisar impacto: processamento redundante, confusão no estado da aplicação.",
                                    "Exemplo: arquivo transferido com blocos duplicados causando corrupção.",
                                    "Discutir detecção: receptor deve ignorar duplicatas manualmente."
                                  ],
                                  "verification": "Criar sequência de pacotes mostrando duplicação e seu efeito no receptor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para sequências de pacotes",
                                    "Artigo sobre ARPANET falhas iniciais"
                                  ],
                                  "tips": "Pense em fax antigo enviando páginas duas vezes por segurança.",
                                  "learningObjective": "Explicar origens e consequências de pacotes duplicados.",
                                  "commonMistakes": [
                                    "Confundir duplicação com perda",
                                    "Subestimar impacto em fluxos de dados contínuos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar desordem de pacotes e síntese das falhas",
                                  "subSteps": [
                                    "Explicar causas: rotas diferentes, atrasos variáveis, processamento assíncrono.",
                                    "Simular desordem: pacote 1 chega após pacote 2 devido a caminhos alternos.",
                                    "Discutir impacto: reconstrução incorreta de mensagem, perda de ordem lógica.",
                                    "Sintetizar falhas: perda + duplicação + desordem = comunicação não confiável.",
                                    "Concluir necessidade: por que protocolos como TCP são essenciais."
                                  ],
                                  "verification": "Montar puzzle de pacotes desordenados e reordenar manualmente, notando dificuldades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Cartões com números de pacotes para simulação física",
                                    "Vídeo sobre problemas em UDP"
                                  ],
                                  "tips": "Use cartas embaralhadas chegando em ordem errada para visualizar.",
                                  "learningObjective": "Analisar desordem e integrar todas as falhas em uma visão coesa.",
                                  "commonMistakes": [
                                    "Assumir que redes sempre entregam em ordem FIFO",
                                    "Ignorar variabilidade de latência"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma transferência de arquivo via rede UDP (sem controle): envie 10 pacotes numerados; observe 2 perdidos, 1 duplicado e 3 fora de ordem usando Wireshark ou simulador, reconstruindo manualmente e notando corrupção.",
                              "finalVerifications": [
                                "Explicar três causas de perda de dados sem protocolos.",
                                "Dar exemplo concreto de duplicação e seu impacto.",
                                "Desenhar sequência mostrando desordem de pacotes.",
                                "Discutir por que comunicação sem gerenciamento é ineficiente.",
                                "Identificar cenários onde tolerar falhas (ex: vídeo streaming).",
                                "Comparar com rede com TCP/IP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de causas de cada falha (perda, duplicação, desordem).",
                                "Uso de exemplos concretos e diagramas claros.",
                                "Análise de impactos na aplicação final.",
                                "Compreensão da necessidade de protocolos de gerenciamento.",
                                "Capacidade de simular falhas em cenários práticos.",
                                "Síntese lógica conectando falhas à complexidade de redes."
                              ],
                              "crossCurricularConnections": [
                                "Física: Ruído em sinais e propagação de ondas eletromagnéticas.",
                                "Matemática: Probabilidade de perda e modelagem estocástica de pacotes.",
                                "Estatística: Análise de taxas de erro em experimentos de rede.",
                                "História: Evolução de redes como ARPANET e lições de falhas iniciais."
                              ],
                              "realWorldApplication": "Em aplicações UDP como jogos online ou VoIP, onde perdas são toleradas por baixa latência, mas analisadas para otimizar QoS; ou em IoT com baterias limitadas evitando ACKs pesados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Benefícios e Problemas Resolvidos por Protocolos Padronizados",
                        "description": "Apresenta como protocolos resolvem interoperabilidade, confiabilidade e escalabilidade em redes.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Descrever interoperabilidade proporcionada por protocolos",
                            "description": "Explicar como protocolos permitem que dispositivos heterogêneos se comuniquem usando regras comuns, como no modelo TCP/IP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de interoperabilidade em redes",
                                  "subSteps": [
                                    "Defina interoperabilidade como a capacidade de sistemas diferentes trabalharem juntos sem problemas de compatibilidade.",
                                    "Identifique exemplos cotidianos, como um PC Windows enviando email para um Mac via Gmail.",
                                    "Diferencie interoperabilidade de compatibilidade de hardware, focando em comunicação de software.",
                                    "Pesquise definições oficiais de fontes como RFCs da IETF.",
                                    "Anote diferenças entre sistemas homogêneos e heterogêneos."
                                  ],
                                  "verification": "Escreva uma definição clara de interoperabilidade e cite um exemplo real; revise com um colega ou ferramenta de correção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notebook, acesso à internet para RFCs (ex: ietf.org), dicionário técnico de redes.",
                                  "tips": "Use analogias como 'idioma comum' para facilitar a memorização.",
                                  "learningObjective": "Definir e exemplificar interoperabilidade em contextos de rede.",
                                  "commonMistakes": "Confundir interoperabilidade com performance ou velocidade de rede."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o papel dos protocolos na comunicação entre dispositivos",
                                  "subSteps": [
                                    "Explique que protocolos são conjuntos de regras padronizadas para troca de dados.",
                                    "Descreva como protocolos definem formato de pacotes, ordem de envio e tratamento de erros.",
                                    "Compare comunicação sem protocolos (caos) vs. com protocolos (ordem).",
                                    "Estude camadas do modelo OSI onde protocolos atuam (ex: camada de rede).",
                                    "Crie um fluxograma simples de uma mensagem sendo enviada via protocolo."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando uma troca de dados com e sem protocolo; explique oralmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta para diagramas, software de desenho como Draw.io, vídeo introdutório sobre protocolos no YouTube.",
                                  "tips": "Pense em protocolos como 'regras de trânsito' para dados.",
                                  "learningObjective": "Explicar como protocolos estruturam a comunicação em redes.",
                                  "commonMistakes": "Achar que protocolos só lidam com hardware, ignorando software e lógica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar dispositivos heterogêneos e unificação por protocolos",
                                  "subSteps": [
                                    "Liste dispositivos heterogêneos: smartphone Android, roteador Cisco, servidor Linux.",
                                    "Descreva desafios sem protocolos: formatos de dados incompatíveis, erros de interpretação.",
                                    "Mostre como protocolos comuns resolvem isso, permitindo tradução automática.",
                                    "Simule uma rede mista em um simulador como Cisco Packet Tracer.",
                                    "Registre cenários onde interoperabilidade falha sem padrões."
                                  ],
                                  "verification": "Configure uma simulação simples de rede heterogênea e demonstre comunicação bem-sucedida.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Cisco Packet Tracer (gratuito), lista de dispositivos comuns em redes.",
                                  "tips": "Comece com 3 dispositivos diferentes para manter simples.",
                                  "learningObjective": "Demonstrar como protocolos superam heterogeneidade de dispositivos.",
                                  "commonMistakes": "Subestimar o impacto de diferenças em velocidades ou mídias físicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conceito no modelo TCP/IP",
                                  "subSteps": [
                                    "Revise as camadas TCP/IP: Application, Transport, Internet, Link.",
                                    "Explique interoperabilidade em ação: HTTP (app) sobre TCP (transporte) sobre IP (internet).",
                                    "Trace um pacote de um browser para um servidor web global.",
                                    "Compare TCP/IP com outros modelos como OSI para destacar padronização.",
                                    "Crie um relatório resumindo benefícios da interoperabilidade no TCP/IP."
                                  ],
                                  "verification": "Rastreie um ping entre dois dispositivos e explique protocolos envolvidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta Wireshark para captura de pacotes, documentação TCP/IP (RFC 791, 793).",
                                  "tips": "Use comandos como 'ping' e 'tracert' para visualização prática.",
                                  "learningObjective": "Ilustrar interoperabilidade usando o modelo TCP/IP como exemplo.",
                                  "commonMistakes": "Confundir TCP com IP ou ignorar que ambos são necessários para interoperabilidade total."
                                }
                              ],
                              "practicalExample": "Imagine um smartphone Android conectado via Wi-Fi a um roteador TP-Link, acessando um site hospedado em um servidor AWS rodando Linux: protocolos como Wi-Fi (IEEE 802.11), IP, TCP e HTTP garantem que dados fluam perfeitamente, apesar das diferenças de hardware e SO.",
                              "finalVerifications": [
                                "Definição precisa de interoperabilidade fornecida verbalmente.",
                                "Exemplo correto de dispositivos heterogêneos comunicando via protocolos.",
                                "Diagrama do fluxo de dados no TCP/IP desenhado e explicado.",
                                "Simulação em Packet Tracer executada com sucesso.",
                                "Relatório de 200 palavras sobre benefícios de protocolos.",
                                "Resposta a perguntas sobre erros comuns em redes sem padrões."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na definição de interoperabilidade (20%)",
                                "Uso de exemplos concretos e relevantes (25%)",
                                "Compreensão do papel dos protocolos em heterogeneidade (25%)",
                                "Aplicação correta ao modelo TCP/IP (20%)",
                                "Qualidade de diagramas e simulações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em checksums de protocolos.",
                                "Física: Propagação de sinais em mídias heterogêneas.",
                                "Língua Portuguesa: Redação técnica de relatórios sobre redes.",
                                "História: Evolução de protocolos desde ARPANET."
                              ],
                              "realWorldApplication": "Na Internet das Coisas (IoT), protocolos como MQTT permitem que geladeiras inteligentes (diversos fabricantes) se comuniquem com apps em smartphones, otimizando logística em supermercados ou monitoramento remoto em cidades inteligentes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Identificar resolução de problemas de confiabilidade",
                            "description": "Detalhar como protocolos lidam com erros, perdas e congestionamentos, garantindo entrega confiável de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Problemas Comuns de Confiabilidade em Redes",
                                  "subSteps": [
                                    "Liste os principais problemas: erros de bit, perda de pacotes e congestionamento de rede.",
                                    "Explique causas: ruído em cabos, colisões em redes sem fio, sobrecarga de roteadores.",
                                    "Diferencie entre redes não confiáveis (ex: UDP) e confiáveis (ex: TCP).",
                                    "Desenhe um diagrama simples mostrando um pacote perdido em trânsito.",
                                    "Discuta impacto: dados corrompidos levam a retransmissões desnecessárias."
                                  ],
                                  "verification": "Crie um mapa mental com 3 problemas, causas e impactos; revise com um colega.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta digital como Draw.io; capítulo sobre camadas de rede em livro de Kurose & Ross.",
                                  "tips": "Use analogias como 'carta perdida no correio' para visualizar perdas.",
                                  "learningObjective": "Compreender os desafios fundamentais de transmissão de dados em redes não ideais.",
                                  "commonMistakes": "Confundir perda de pacotes com atraso; ignorar que erros podem ocorrer em qualquer camada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Mecanismos de Detecção de Erros em Protocolos",
                                  "subSteps": [
                                    "Estude checksums: como TCP/UDP calculam soma de verificação para detectar corrupção.",
                                    "Analise sequência de números: TCP usa para ordenar pacotes e detectar duplicatas/perdas.",
                                    "Simule cálculo de checksum com uma ferramenta online ou calculadora.",
                                    "Compare com CRC (Cyclic Redundancy Check) usado em Ethernet.",
                                    "Teste com Wireshark: capture pacotes e verifique campos de checksum."
                                  ],
                                  "verification": "Capture e analise 5 pacotes em Wireshark, identificando checksum válido/inválido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Wireshark instalado; tutorial de checksum TCP; computador com conexão de rede.",
                                  "tips": "Lembre-se: detecção != correção; protocolos confiáveis vão além.",
                                  "learningObjective": "Dominar como protocolos detectam erros e perdas iniciais.",
                                  "commonMistakes": "Achar que UDP é sempre ruim; checksum detecta mas não corrige sozinho."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Recuperação de Perdas e Controle de Fluxo",
                                  "subSteps": [
                                    "Descreva ACKs (acknowledgments): receptor envia confirmação para remetente.",
                                    "Explique timeouts e retransmissões: se sem ACK, reenvia após timer.",
                                    "Estude controle de fluxo: janelas deslizantes para evitar sobrecarga do receptor.",
                                    "Simule handshake TCP de 3 vias para conexão confiável.",
                                    "Discuta Go-Back-N vs Selective Repeat para eficiência."
                                  ],
                                  "verification": "Desenhe fluxograma de uma retransmissão bem-sucedida; simule com ferramenta como Packet Tracer.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Cisco Packet Tracer ou ns-3 simulador; diagramas TCP de RFC 793.",
                                  "tips": "Pense em ACKs como 'recibos' de entrega para rastrear.",
                                  "learningObjective": "Entender como protocolos garantem entrega ordenada e completa.",
                                  "commonMistakes": "Ignorar que ACKs podem se perder, exigindo timers duplicados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Controle de Congestionamento",
                                  "subSteps": [
                                    "Defina congestionamento: filas cheias em roteadores causam perdas.",
                                    "Estude algoritmos TCP: Tahoe, Reno (slow start, congestion avoidance).",
                                    "Simule com gráfico: taxa de envio vs perda de pacotes.",
                                    "Compare com ECN (Explicit Congestion Notification).",
                                    "Analise impacto em aplicações reais como HTTP."
                                  ],
                                  "verification": "Crie tabela comparando TCP Reno vs Cubic em cenários de alta carga.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Gráficos de congestionamento de artigos; simulador Mininet.",
                                  "tips": "Visualize como 'trânsito': reduza velocidade ao detectar engarrafamento.",
                                  "learningObjective": "Compreender adaptação dinâmica para estabilidade de rede.",
                                  "commonMistakes": "Confundir controle de fluxo (receptor) com congestionamento (rede)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Aplicar Conhecimento em Cenários",
                                  "subSteps": [
                                    "Revise todos mecanismos: detecção, recuperação, controle.",
                                    "Analise trace Wireshark de uma transferência TCP com perdas induzidas.",
                                    "Identifique em logs: ACKs perdidos, retransmissões, ajustes de janela.",
                                    "Debata: por que TCP é 'confiável' mas não infalível?",
                                    "Crie quiz autoavaliação com 10 perguntas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como TCP resolve um cenário específico de perda.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Wireshark traces de exemplo; quiz template.",
                                  "tips": "Use 'por quês' para conectar mecanismos aos problemas.",
                                  "learningObjective": "Integrar conceitos para identificar soluções de confiabilidade holisticamente.",
                                  "commonMistakes": "Superestimar TCP como 100% confiável; ignorar overhead."
                                }
                              ],
                              "practicalExample": "Ao baixar um arquivo de 10MB via HTTP/TCP, se 2 pacotes forem perdidos devido a congestionamento Wi-Fi, o TCP detecta via ACK ausente, retransmite seletivamente os perdidos usando números de sequência, ajusta a janela de congestionamento para evitar mais perdas, garantindo que o arquivo chegue completo e ordenado, sem corrompimento detectado por checksums falhos.",
                              "finalVerifications": [
                                "Liste e explique 3 problemas de confiabilidade resolvidos por TCP.",
                                "Descreva o papel de ACKs, timeouts e janelas deslizantes em uma transferência.",
                                "Analise um trace Wireshark identificando retransmissão e controle de congestionamento.",
                                "Diferencie detecção de erros vs recuperação de perdas.",
                                "Simule um cenário onde UDP falha mas TCP succeeds.",
                                "Crie diagrama de handshake TCP de 3 vias."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta identificação de mecanismos (checksum, ACK, etc.) - 30%",
                                "Profundidade de análise: Explicação de interações entre detecção/recuperação/controle - 25%",
                                "Exemplos práticos: Uso de analogias ou simulações reais - 20%",
                                "Clareza de comunicação: Diagramas e fluxogramas legíveis - 15%",
                                "Compreensão integrada: Conexão a aplicações reais sem erros comuns - 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidades de erro em canais (modelo binomial), algoritmos de checksum.",
                                "Física: Propagação de sinais, ruído em meios de transmissão (ópticos/elétricos).",
                                "Estatística: Análise de traces de rede, médias de latência em congestionamento.",
                                "Engenharia de Software: Design de APIs tolerantes a falhas inspiradas em TCP."
                              ],
                              "realWorldApplication": "Em serviços como Netflix ou Zoom, TCP garante que vídeos sejam entregues sem lacunas apesar de perdas em redes móveis congestionadas, usando retransmissões e controle de fluxo para priorizar qualidade sobre velocidade pura, evitando buffering excessivo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Exemplificar escalabilidade com protocolos padronizados",
                            "description": "Mostrar como protocolos suportam crescimento de redes globais, como a Internet, através de modularidade e padronização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de escalabilidade em redes",
                                  "subSteps": [
                                    "Defina escalabilidade como a capacidade de uma rede crescer em tamanho, usuários ou tráfego sem perda de desempenho.",
                                    "Identifique desafios de redes não escaláveis, como gargalos em comunicação proprietária.",
                                    "Pesquise estatísticas históricas do crescimento da Internet (ex: de 1 milhão de hosts em 1993 para bilhões hoje).",
                                    "Compare redes pequenas (LAN) vs. globais (Internet).",
                                    "Anote limitações de sistemas centralizados."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo escalabilidade e liste 3 desafios resolvidos por protocolos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Internet para pesquisa (Wikipedia: História da Internet), caderno para anotações.",
                                  "tips": "Use analogias como 'estradas' para visualizar crescimento de tráfego.",
                                  "learningObjective": "Entender o que significa escalabilidade e por que redes precisam dela.",
                                  "commonMistakes": "Confundir escalabilidade com velocidade; escalabilidade foca em crescimento sustentável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar modularidade nos protocolos de rede",
                                  "subSteps": [
                                    "Explique modularidade como dividir funções em camadas independentes (ex: modelo OSI ou TCP/IP).",
                                    "Desenhe um diagrama simples das camadas TCP/IP (Aplicação, Transporte, Rede, Enlace).",
                                    "Mostre como uma camada pode evoluir sem afetar outras (ex: adicionar IPv6 na camada de rede).",
                                    "Identifique exemplos: HTTP na camada de aplicação não depende de mudanças no roteamento IP.",
                                    "Discuta benefícios: reutilização e manutenção facilitada."
                                  ],
                                  "verification": "Crie um diagrama das camadas TCP/IP rotulando funções modulares.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou ferramenta online como draw.io, documento TCP/IP basics.",
                                  "tips": "Pense em blocos de Lego: cada camada é um bloco que se conecta sem alterar os outros.",
                                  "learningObjective": "Reconhecer como modularidade permite expansões independentes em protocolos.",
                                  "commonMistakes": "Ignorar interdependências entre camadas; enfatize abstrações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o papel da padronização na escalabilidade",
                                  "subSteps": [
                                    "Defina padronização como acordos globais (ex: IETF para RFCs).",
                                    "Compare protocolos proprietários (limitados) vs. padronizados (abertos como TCP/IP).",
                                    "Liste benefícios: interoperabilidade entre vendors, inovação coletiva.",
                                    "Pesquise RFC 791 (IPv4) e como evoluiu para IPv6 sem quebrar a Internet.",
                                    "Discuta como padronização permite bilhões de dispositivos heterogêneos se conectarem."
                                  ],
                                  "verification": "Liste 4 vantagens da padronização com exemplos de protocolos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Site IETF.org para RFCs, vídeo Khan Academy sobre TCP/IP.",
                                  "tips": "Use o exemplo da eletricidade: padrões de plugues permitem qualquer aparelho funcionar em qualquer tomada.",
                                  "learningObjective": "Compreender como padronização resolve problemas de compatibilidade em escala global.",
                                  "commonMistakes": "Achar que padronização inibe inovação; ela a acelera via colaboração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar escalabilidade da Internet com TCP/IP",
                                  "subSteps": [
                                    "Descreva o crescimento da Internet: ARPANET para WWW global.",
                                    "Mostre como modularidade TCP/IP permitiu adicionar WWW (HTTP) sem recriar a rede.",
                                    "Simule escalabilidade: imagine adicionar 1 bilhão de usuários via novos roteadores IP-compatíveis.",
                                    "Crie um caso: Como Netflix escala streaming global usando HTTP/TCP/IP padronizados.",
                                    "Conclua ligando modularidade + padronização ao sucesso escalável."
                                  ],
                                  "verification": "Escreva um exemplo de 200 palavras exemplificando escalabilidade da Internet.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Vídeos YouTube 'How Internet Works', simulador Cisco Packet Tracer (opcional).",
                                  "tips": "Use timelines para mostrar evolução cronológica.",
                                  "learningObjective": "Aplicar conceitos para exemplificar escalabilidade real da Internet.",
                                  "commonMistakes": "Focar só em velocidade; destaque crescimento de nós/usuários."
                                }
                              ],
                              "practicalExample": "Na Internet, o protocolo HTTP (padronizado) roda sobre TCP/IP modular: adicione milhões de servidores web sem alterar roteadores globais, permitindo escalar de 100 sites em 1994 para 1.8 bilhão hoje.",
                              "finalVerifications": [
                                "Explica corretamente escalabilidade como crescimento sustentável.",
                                "Desenha diagrama preciso das camadas TCP/IP.",
                                "Lista pelo menos 3 benefícios de modularidade e padronização.",
                                "Fornece exemplo concreto da Internet escalando.",
                                "Identifica como IPv6 foi adicionado sem downtime global.",
                                "Compara redes proprietárias vs. padronizadas adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação de conceitos (20%)",
                                "Precisão técnica em protocolos e camadas (25%)",
                                "Qualidade do diagrama e exemplos (20%)",
                                "Profundidade na ligação modularidade-padronização-escalabilidade (20%)",
                                "Criatividade em analogias e aplicações reais (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para modelar crescimento de redes.",
                                "História: Evolução da ARPANET à Internet moderna.",
                                "Economia: Impacto de padrões abertos no mercado global de TI.",
                                "Física: Analogias com ondas e transmissão de sinais padronizados."
                              ],
                              "realWorldApplication": "Empresas como Google e AWS usam protocolos padronizados (TCP/IP, HTTP/3) para escalar serviços cloud para bilhões de usuários, adicionando data centers globais sem recertificar hardware."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.4",
                            "name": "Relacionar protocolos ao modelo TCP/IP",
                            "description": "Conectar a necessidade de protocolos à adoção do modelo TCP/IP como solução padronizada para redes modernas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Necessidade de Protocolos em Redes",
                                  "subSteps": [
                                    "Discutir problemas de comunicação sem protocolos padronizados, como incompatibilidade entre dispositivos",
                                    "Exemplificar com analogia de idiomas diferentes em uma conversa internacional",
                                    "Definir protocolo como conjunto de regras para troca de dados em redes",
                                    "Listar benefícios principais: interoperabilidade, confiabilidade e escalabilidade",
                                    "Identificar problemas resolvidos: falhas de comunicação, perda de dados e ineficiência"
                                  ],
                                  "verification": "Escrever um parágrafo resumindo 3 razões principais para a necessidade de protocolos",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro branco ou papel",
                                    "Marcadores",
                                    "Diagrama simples de rede impresso"
                                  ],
                                  "tips": "Use analogias cotidianas como regras de trânsito para tornar o conceito acessível",
                                  "learningObjective": "Explicar a motivação fundamental para o uso de protocolos em redes de computadores",
                                  "commonMistakes": [
                                    "Confundir protocolos com hardware de rede",
                                    "Subestimar o papel da padronização",
                                    "Ignorar exemplos de falhas sem protocolos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Modelo TCP/IP como Solução Padronizada",
                                  "subSteps": [
                                    "Apresentar a história breve do TCP/IP: origem na ARPANET e adoção pela Internet",
                                    "Descrever as 4 camadas principais: Aplicação, Transporte, Internet e Enlace/Rede",
                                    "Explicar o princípio de camadas: cada uma com responsabilidades específicas",
                                    "Comparar brevemente com o modelo OSI para contextualizar",
                                    "Destacar por que TCP/IP se tornou o padrão global: simplicidade e eficácia"
                                  ],
                                  "verification": "Desenhar um diagrama das 4 camadas do TCP/IP e rotulá-las corretamente",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou software de desenho como Draw.io",
                                    "Vídeo curto sobre TCP/IP (ex: YouTube 5min)",
                                    "Referência impressa do modelo TCP/IP"
                                  ],
                                  "tips": "Visualize as camadas como andares de um prédio, cada um com funções independentes",
                                  "learningObjective": "Identificar o modelo TCP/IP como framework padronizado para organizar protocolos",
                                  "commonMistakes": [
                                    "Confundir TCP/IP com apenas TCP ou IP",
                                    "Misturar camadas do TCP/IP com OSI",
                                    "Achar que TCP/IP é rígido e não evolui"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Protocolos Chave às Camadas do TCP/IP",
                                  "subSteps": [
                                    "Listar protocolos por camada: Aplicação (HTTP, FTP), Transporte (TCP, UDP), Internet (IP, ICMP), Enlace (Ethernet)",
                                    "Explicar como protocolos interagem entre camadas (encapsulamento)",
                                    "Simular fluxo de dados: de uma requisição HTTP até o envio físico",
                                    "Discutir como cada protocolo resolve necessidades específicas da camada",
                                    "Relacionar de volta à necessidade inicial: padronização permite interoperabilidade"
                                  ],
                                  "verification": "Criar uma tabela associando 5 protocolos às suas camadas e funções",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Lista impressa de protocolos comuns",
                                    "Ferramenta Wireshark para demo opcional"
                                  ],
                                  "tips": "Pense em 'camadas como cebola': dados são embrulhados progressivamente",
                                  "learningObjective": "Conectar protocolos específicos ao modelo TCP/IP, mostrando sua organização hierárquica",
                                  "commonMistakes": [
                                    "Atribuir protocolos à camada errada",
                                    "Ignorar interação entre camadas",
                                    "Listar protocolos obsoletos sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Benefícios e Aplicação Prática da Padronização TCP/IP",
                                  "subSteps": [
                                    "Revisar problemas sem padronização e como TCP/IP os resolve",
                                    "Discutir vantagens: universalidade, robustez (TCP) e eficiência (UDP)",
                                    "Explorar evoluções modernas: IPv6, TCP congestion control",
                                    "Relacionar à Internet atual: bilhões de dispositivos conectados",
                                    "Debater limitações e por que ainda é dominante"
                                  ],
                                  "verification": "Explicar oralmente ou por escrito como TCP/IP resolve 2 problemas de protocolos não padronizados",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigos curtos sobre história da Internet",
                                    "Gráfico de crescimento da Internet",
                                    "Quiz online sobre TCP/IP"
                                  ],
                                  "tips": "Conecte ao dia a dia: 'Sem TCP/IP, não haveria WhatsApp ou Netflix'",
                                  "learningObjective": "Avaliar o impacto da adoção do TCP/IP como solução global para redes modernas",
                                  "commonMistakes": [
                                    "Superestimar perfeição do TCP/IP",
                                    "Confundir benefícios com outros modelos",
                                    "Não relacionar de volta à necessidade inicial de protocolos"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao navegar em um site (HTTP na camada Aplicação), o navegador usa TCP (Transporte) para garantir entrega confiável dos pacotes IP (Internet), que são transmitidos via Ethernet (Enlace), demonstrando como protocolos se integram no modelo TCP/IP para carregar a página sem erros.",
                              "finalVerifications": [
                                "Desenhar e explicar o diagrama das camadas TCP/IP com pelo menos 3 protocolos por camada",
                                "Simular verbalmente o fluxo de uma requisição web através das camadas",
                                "Listar 4 benefícios da padronização TCP/IP em relação a redes não padronizadas",
                                "Identificar e corrigir erros em um diagrama TCP/IP incompleto",
                                "Explicar por que TCP/IP resolveu a necessidade de protocolos em redes modernas"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e mapeamento de protocolos às camadas TCP/IP",
                                "Clareza na explicação da relação entre necessidade de protocolos e adoção do modelo",
                                "Uso de exemplos concretos e analogias para demonstrar compreensão",
                                "Capacidade de relacionar conceitos teóricos a aplicações reais",
                                "Profundidade na análise de benefícios e problemas resolvidos pela padronização",
                                "Criatividade e correção no diagrama ou simulação final"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de redes com grafos e algoritmos de roteamento (ex: Dijkstra em IP)",
                                "História: Evolução da ARPANET para a Internet moderna e impacto cultural",
                                "Física: Transmissão de sinais elétricos/ópticos nas camadas inferiores",
                                "Economia: Efeitos da padronização na indústria de TI e globalização digital"
                              ],
                              "realWorldApplication": "O modelo TCP/IP é a base de toda a Internet, permitindo que dispositivos heterogêneos (celulares, servidores, IoT) se comuniquem globalmente em serviços como streaming (Netflix via TCP/UDP), e-commerce (HTTPS) e redes sociais, resolvendo caos de comunicação não padronizada em escala mundial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Arquitetura Geral do Modelo TCP/IP",
                    "description": "Apresenta a estrutura em camadas do modelo TCP/IP e suas funções principais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Camada de Aplicação",
                        "description": "A camada de aplicação no modelo TCP/IP engloba protocolos que fornecem serviços diretamente aos usuários finais, como suporte a aplicações de rede e comunicação cliente-servidor.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Identificar protocolos principais da camada de aplicação",
                            "description": "Reconhecer e listar protocolos como HTTP, HTTPS, FTP, SMTP e DNS, explicando brevemente suas funções principais no contexto do modelo TCP/IP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Camada de Aplicação no Modelo TCP/IP",
                                  "subSteps": [
                                    "Estude o modelo TCP/IP e identifique as 4 camadas principais: Aplicação, Transporte, Rede e Enlace.",
                                    "Foque na camada de Aplicação: ela fornece serviços de rede diretamente para aplicativos do usuário.",
                                    "Anote exemplos genéricos de protocolos de aplicação e suas responsabilidades gerais.",
                                    "Desenhe um diagrama simples da pilha TCP/IP destacando a camada de Aplicação.",
                                    "Compare com o modelo OSI para contextualizar (camada 7)."
                                  ],
                                  "verification": "Você pode desenhar e rotular corretamente a camada de Aplicação em um diagrama TCP/IP.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama TCP/IP impresso ou digital",
                                    "Notebook e caneta",
                                    "Vídeo introdutório sobre TCP/IP (ex: Khan Academy)"
                                  ],
                                  "tips": "Use cores diferentes para cada camada no diagrama para melhor memorização visual.",
                                  "learningObjective": "Compreender o papel e posição da camada de Aplicação no modelo TCP/IP.",
                                  "commonMistakes": "Confundir camada de Aplicação com Transporte (TCP/UDP); lembre-se que Aplicação é user-facing."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Protocolos HTTP, HTTPS, FTP e SMTP",
                                  "subSteps": [
                                    "Pesquise HTTP: protocolo para transferência de hipertexto (web pages).",
                                    "Analise HTTPS: versão segura de HTTP com criptografia SSL/TLS.",
                                    "Estude FTP: para upload/download de arquivos entre cliente e servidor.",
                                    "Examine SMTP: para envio de emails (Simple Mail Transfer Protocol).",
                                    "Crie uma tabela comparativa com portas padrão (HTTP:80, HTTPS:443, FTP:21, SMTP:25)."
                                  ],
                                  "verification": "Preencha uma tabela com nome, função breve e porta para cada protocolo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Acesso à internet para RFCs ou Wireshark demo",
                                    "Planilha ou tabela em papel/digital"
                                  ],
                                  "tips": "Use Wireshark para capturar tráfego real e ver headers HTTP em ação.",
                                  "learningObjective": "Reconhecer funções principais e portas dos protocolos HTTP, HTTPS, FTP e SMTP.",
                                  "commonMistakes": "Esquecer que HTTPS é HTTP + segurança; sempre associe à criptografia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Protocolo DNS e Sintetizar Conhecimentos",
                                  "subSteps": [
                                    "Estude DNS: Domain Name System, resolve nomes de domínio em IPs (ex: google.com -> 142.250.190.78).",
                                    "Explique o processo de resolução DNS: cliente -> servidor recursivo -> root -> TLD -> autoritativo.",
                                    "Liste diferenças: DNS é consulta-nome-IP, enquanto outros são para dados (web, arquivos, email).",
                                    "Crie flashcards com um protocolo por lado: nome, função, exemplo de uso.",
                                    "Revise todos os 5 protocolos em uma mente map conectando à camada de Aplicação."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o fluxo DNS e liste todos os protocolos com funções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de flashcards como Anki",
                                    "Comando 'nslookup' no terminal para demo DNS"
                                  ],
                                  "tips": "Teste DNS real no terminal com 'nslookup www.example.com' para ver resolução ao vivo.",
                                  "learningObjective": "Identificar DNS como protocolo de resolução de nomes e integrar com os demais.",
                                  "commonMistakes": "Confundir DNS com DHCP (DHCP aloca IPs, DNS resolve nomes)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Cenários Práticos",
                                  "subSteps": [
                                    "Simule cenários: 'Navegando na web' -> HTTP/HTTPS; 'Enviando email' -> SMTP; etc.",
                                    "Use ferramentas como browser dev tools para inspecionar requests HTTP.",
                                    "Crie um quiz auto-aplicado: liste protocolos por atividade (download arquivo -> FTP).",
                                    "Discuta em fórum ou com par: 'Qual protocolo usa porta 53?' (DNS).",
                                    "Registre exemplos reais de uso diário para cada protocolo."
                                  ],
                                  "verification": "Resolva 10 cenários identificando o protocolo correto com justificativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Browser com dev tools (F12)",
                                    "Lista de cenários impressa"
                                  ],
                                  "tips": "Ative 'Preserve log' no dev tools para ver múltiplos requests.",
                                  "learningObjective": "Aplicar conhecimento para identificar protocolos em contextos reais do TCP/IP.",
                                  "commonMistakes": "Assumir que todo web é HTTP; lembre HTTPS para sites seguros."
                                }
                              ],
                              "practicalExample": "Ao acessar 'https://www.exemplo.com', o navegador usa HTTPS (camada Aplicação) sobre TCP (Transporte) para carregar a página segura; digite 'nslookup www.exemplo.com' para ver DNS resolvendo o domínio primeiro, seguido de FTP se baixar um arquivo via cliente FTP.",
                              "finalVerifications": [
                                "Liste corretamente os 5 protocolos: HTTP, HTTPS, FTP, SMTP, DNS.",
                                "Explique função principal de cada um em 1 frase.",
                                "Identifique portas padrão para todos.",
                                "Descreva um fluxo completo: DNS -> HTTP para acessar um site.",
                                "Diferencie protocolos de Aplicação de Transporte.",
                                "Capture e identifique tráfego de um protocolo via Wireshark."
                              ],
                              "assessmentCriteria": [
                                "Precisão na lista e funções dos protocolos (100% correto).",
                                "Explicações breves e contextualizadas no TCP/IP (claras e concisas).",
                                "Uso correto de portas e exemplos práticos.",
                                "Capacidade de identificar em cenários simulados (90% acerto).",
                                "Diagrama ou tabela bem organizada demonstrando compreensão.",
                                "Ausência de confusões com outras camadas (ex: TCP como aplicação)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: HTTPS e criptografia TLS.",
                                "Programação: Uso de bibliotecas como requests (Python) para HTTP.",
                                "Matemática: Endereços IP como notação decimal vs. binário em DNS.",
                                "História: Evolução da internet desde ARPANET até protocolos modernos."
                              ],
                              "realWorldApplication": "Esses protocolos sustentam a internet diária: HTTP/HTTPS para navegação e e-commerce, SMTP para emails corporativos, FTP para compartilhamento de arquivos em empresas, DNS para todo acesso a sites, permitindo comunicação global eficiente e segura."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Descrever funções da camada de aplicação",
                            "description": "Explicar como a camada de aplicação lida com a interface entre software de usuário e a rede, incluindo suporte a serviços como transferência de arquivos e navegação web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico da Camada de Aplicação",
                                  "subSteps": [
                                    "Ler a definição oficial da camada de aplicação no modelo TCP/IP como a interface entre aplicativos do usuário e a rede.",
                                    "Analisar a posição da camada de aplicação no topo da pilha TCP/IP (acima de transporte, rede, enlace e física).",
                                    "Comparar brevemente com camadas inferiores, destacando que ela foca em serviços de alto nível."
                                  ],
                                  "verification": "Explicar oralmente ou por escrito o papel da camada de aplicação em 2-3 frases claras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama da pilha TCP/IP",
                                    "Texto introdutório sobre modelo TCP/IP"
                                  ],
                                  "tips": "Visualize a camada de aplicação como o 'frente de loja' dos aplicativos, lidando diretamente com o usuário.",
                                  "learningObjective": "Entender a definição e posição hierárquica da camada de aplicação no modelo TCP/IP.",
                                  "commonMistakes": "Confundir com a camada de aplicação do modelo OSI, que inclui apresentação e sessão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as Funções Principais da Camada de Aplicação",
                                  "subSteps": [
                                    "Listar funções chave: suporte a serviços como transferência de arquivos (FTP), navegação web (HTTP) e email (SMTP).",
                                    "Explicar como ela fornece interface padronizada entre software do usuário e a rede subjacente.",
                                    "Descrever o processamento de dados de aplicação para envio pela rede, incluindo encapsulamento inicial."
                                  ],
                                  "verification": "Criar uma tabela com pelo menos 4 funções principais e suas descrições breves.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de protocolos de aplicação (HTTP, FTP, SMTP)",
                                    "Vídeo explicativo sobre funções TCP/IP"
                                  ],
                                  "tips": "Associe cada função a um aplicativo cotidiano para fixar o conceito.",
                                  "learningObjective": "Dominar as funções essenciais da camada de aplicação na intermediação usuário-rede.",
                                  "commonMistakes": "Acreditar que a camada de aplicação gerencia roteamento, que é função da camada de rede."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Protocolos e Serviços Associados",
                                  "subSteps": [
                                    "Estudar protocolos comuns: HTTP/HTTPS para web, FTP para arquivos, SMTP/POP3/IMAP para email.",
                                    "Simular o fluxo de um serviço, como uma requisição HTTP do navegador à rede.",
                                    "Identificar portas padrão usadas (ex: 80 para HTTP, 21 para FTP)."
                                  ],
                                  "verification": "Desenhar um diagrama de fluxo para um protocolo como HTTP, mostrando interação com camadas inferiores.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Tabela de portas TCP/UDP comuns",
                                    "Ferramenta Wireshark para captura de pacotes (opcional)",
                                    "Documentação de protocolos RFC"
                                  ],
                                  "tips": "Use ferramentas como curl para testar comandos HTTP simples no terminal.",
                                  "learningObjective": "Conhecer protocolos chave e seu papel na camada de aplicação.",
                                  "commonMistakes": "Misturar protocolos de aplicação com os de transporte como TCP/UDP."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Interações e Importância Prática",
                                  "subSteps": [
                                    "Explicar como a camada de aplicação depende das camadas inferiores para entrega confiável de dados.",
                                    "Discutir extensões modernas como WebSockets para comunicação em tempo real.",
                                    "Refletir sobre o impacto em serviços cotidianos e segurança (ex: TLS na aplicação)."
                                  ],
                                  "verification": "Responder a 5 perguntas de autoavaliação sobre interações e exemplos reais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Diagrama de encapsulamento de pacotes TCP/IP",
                                    "Casos de estudo de falhas de rede"
                                  ],
                                  "tips": "Pense em cenários de falha: o que acontece se a camada de aplicação envia dados mal formatados?",
                                  "learningObjective": "Compreender integrações e aplicações reais da camada de aplicação.",
                                  "commonMistakes": "Ignorar a dependência de camadas inferiores, achando que aplicação gerencia tudo sozinha."
                                }
                              ],
                              "practicalExample": "Ao abrir um navegador e acessar 'www.exemplo.com', o HTTP na camada de aplicação formata a requisição, passa para a camada de transporte (TCP porta 80) que a segmenta e envia pela rede, permitindo a navegação web.",
                              "finalVerifications": [
                                "Listar corretamente pelo menos 4 funções principais da camada de aplicação.",
                                "Identificar 3 protocolos comuns e suas portas associadas.",
                                "Explicar a interface entre software de usuário e rede em termos simples.",
                                "Desenhar a pilha TCP/IP destacando a camada de aplicação.",
                                "Simular verbalmente o fluxo de uma transferência FTP."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas descrições de funções (sem erros conceituais).",
                                "Completude: inclusão de exemplos de protocolos e interações.",
                                "Clareza na explicação da interface usuário-rede.",
                                "Uso correto de terminologia técnica (ex: encapsulamento, portas).",
                                "Capacidade de relacionar a teoria a exemplos práticos.",
                                "Profundidade nas diferenças com outras camadas.",
                                "Criatividade em diagramas ou simulações."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de sockets em linguagens como Python para implementar clientes HTTP.",
                                "Segurança da Informação: Integração de HTTPS e certificados TLS na camada de aplicação.",
                                "Matemática: Cálculo de checksums e endereçamento de portas.",
                                "Desenvolvimento de Software: Design de APIs RESTful baseadas em HTTP.",
                                "Sistemas Operacionais: Gerenciamento de processos de rede em SOs."
                              ],
                              "realWorldApplication": "Na desenvolvimento de aplicativos web e móveis, entender a camada de aplicação permite criar serviços eficientes como streaming de vídeo (RTSP), e-commerce (HTTPS) e colaboração em nuvem (WebSockets), otimizando a comunicação cliente-servidor em empresas como Google e Netflix."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Diferenciar protocolos de suporte e serviços",
                            "description": "Distinguir entre protocolos que suportam aplicações (ex.: DNS para resolução de nomes) e aqueles que fornecem serviços diretos (ex.: HTTP para web).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Protocolos de Camada de Aplicação",
                                  "subSteps": [
                                    "Revise a arquitetura do modelo TCP/IP, focando na camada de aplicação.",
                                    "Defina 'protocolo de suporte' como aqueles que habilitam funcionalidades indiretas, como resolução de nomes (DNS).",
                                    "Defina 'protocolo de serviço' como aqueles que entregam conteúdo ou serviços diretamente ao usuário, como transferência de páginas web (HTTP).",
                                    "Identifique a porta padrão e o propósito principal de cada tipo usando diagramas.",
                                    "Compare com camadas inferiores para contextualizar."
                                  ],
                                  "verification": "Crie um diagrama simples distinguindo os dois tipos de protocolos e explique verbalmente ou por escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama do modelo TCP/IP, tabela de portas IANA (iana.org/assignments/service-names-port-numbers).",
                                  "tips": "Use mnemônicos: Suporte = 'ajuda nos bastidores' (DNS resolve antes de conectar); Serviço = 'direto ao ponto' (HTTP entrega o conteúdo).",
                                  "learningObjective": "Diferenciar conceitualmente protocolos de suporte e serviço na camada de aplicação.",
                                  "commonMistakes": "Confundir com protocolos de transporte (ex: TCP/UDP); ignorar que suporte é indireto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Protocolos de Suporte com Exemplos Práticos",
                                  "subSteps": [
                                    "Estude DNS: função de resolução de nomes para IPs, portas 53 (UDP/TCP).",
                                    "Explore DHCP: alocação dinâmica de IPs, porta 67/68 UDP.",
                                    "Examine SNMP: gerenciamento de rede, porta 161/162 UDP.",
                                    "Simule uma consulta DNS usando ferramenta como nslookup.",
                                    "Registre como esses protocolos 'preparam o terreno' sem entregar dados finais."
                                  ],
                                  "verification": "Execute nslookup para um domínio e explique como é suporte, não serviço direto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas: nslookup ou dig (Linux/Mac), Wireshark para captura de pacotes.",
                                  "tips": "Capture tráfego com Wireshark filtrando por porta 53 para visualizar DNS em ação.",
                                  "learningObjective": "Identificar e exemplificar pelo menos 3 protocolos de suporte comuns.",
                                  "commonMistakes": "Achar que DNS entrega conteúdo web (não, só resolve nomes)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Protocolos de Serviço Direto",
                                  "subSteps": [
                                    "Estude HTTP/HTTPS: entrega de páginas web, portas 80/443 TCP.",
                                    "Analise FTP: transferência de arquivos, portas 20/21 TCP.",
                                    "Revise SMTP/IMAP: envio/recebimento de email, portas 25/143/993 TCP.",
                                    "Acesse um site via browser e inspecione headers HTTP no DevTools.",
                                    "Note como esses protocolos interagem diretamente com o aplicativo usuário."
                                  ],
                                  "verification": "Use curl ou browser DevTools para fazer uma requisição HTTP e descrever o serviço direto fornecido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Browser com DevTools, curl (comando: curl -I http://example.com), Wireshark.",
                                  "tips": "No DevTools (F12), vá para Network tab e recarregue página para ver HTTP em detalhes.",
                                  "learningObjective": "Reconhecer e demonstrar 3 protocolos de serviço direto.",
                                  "commonMistakes": "Confundir HTTP com DNS (HTTP usa DNS, mas é serviço; DNS é suporte)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação e Comparação",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para Suporte vs. Serviço (propósito, exemplos, portas, dependências).",
                                    "Simule cenários: 'Acessar site' – DNS (suporte) + HTTP (serviço).",
                                    "Resolva exercícios: classifique 5 protocolos dados (ex: Telnet=serviço, NTP=suporte).",
                                    "Discuta dependências: serviços frequentemente usam suporte.",
                                    "Crie um fluxograma de comunicação de rede destacando diferenças."
                                  ],
                                  "verification": "Classifique corretamente 10 protocolos em uma lista mista e justifique cada um.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha ou papel para tabela, lista de protocolos (RFCs ou Wikipedia TCP/IP).",
                                  "tips": "Pergunte: 'Isso resolve/gerencia ou entrega/consome dados?' para diferenciar.",
                                  "learningObjective": "Aplicar diferenciação em cenários reais e criar resumo comparativo.",
                                  "commonMistakes": "Classificar mal protocolos híbridos (ex: SIP tem suporte e serviço; foque no principal)."
                                }
                              ],
                              "practicalExample": "Ao acessar 'www.google.com': 1) DNS (suporte) resolve o nome para IP; 2) HTTP (serviço) baixa a página. Capture com Wireshark para ver DNS query seguido de HTTP GET.",
                              "finalVerifications": [
                                "Liste e explique 3 protocolos de suporte e 3 de serviço com portas.",
                                "Classifique corretamente uma lista de 8 protocolos mistos.",
                                "Descreva um fluxo completo de rede (ex: email via SMTP + DNS).",
                                "Crie diagrama comparativo sem erros conceituais.",
                                "Explique verbalmente a diferença para um 'parceiro de estudo'.",
                                "Simule falha: 'Sem DNS, HTTP falha?' (Sim, suporte essencial)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção conceitual (suporte indireto vs. serviço direto).",
                                "Correta identificação de exemplos com portas e funções.",
                                "Demonstração prática via ferramentas (Wireshark, nslookup).",
                                "Tabela/fluxograma claro e completo.",
                                "Justificativas lógicas sem confusões com outras camadas.",
                                "Compreensão de dependências entre tipos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar cliente HTTP em Python (requests) vs. resolver DNS (socket.gethostbyname).",
                                "Segurança: Analisar vulnerabilidades (DNS spoofing vs. HTTP injection).",
                                "Matemática: Modelar latência de rede (suporte adiciona delay ao serviço).",
                                "Linguagens: Comparar sintaxe de comandos (nslookup vs. curl)."
                              ],
                              "realWorldApplication": "Em administração de redes, diferenciar ajuda a diagnosticar falhas: 'Site não carrega? Teste DNS primeiro (suporte), depois HTTP (serviço).' Essencial para suporte técnico, DevOps e cibersegurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Camada de Transporte",
                        "description": "A camada de transporte fornece comunicação fim-a-fim confiável ou não, utilizando protocolos como TCP e UDP, com mecanismos de controle de congestionamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Comparar protocolos TCP e UDP",
                            "description": "Explicar as diferenças entre TCP (orientado a conexão, confiável, com controle de fluxo) e UDP (sem conexão, não confiável, de baixa latência), incluindo usos típicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as características principais do protocolo TCP",
                                  "subSteps": [
                                    "Defina TCP como protocolo de camada de transporte orientado a conexão.",
                                    "Explique o processo de handshake de três vias (SYN, SYN-ACK, ACK).",
                                    "Descreva mecanismos de confiabilidade: controle de erros, retransmissão e ordenação de pacotes.",
                                    "Identifique controle de fluxo (janela deslizante) e controle de congestão.",
                                    "Liste exemplos de portas comuns usadas por TCP (ex: 80 para HTTP)."
                                  ],
                                  "verification": "Criar uma tabela com pelo menos 5 características do TCP e explicá-las verbalmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação RFC 793 (TCP)",
                                    "Vídeo introdutório sobre TCP no YouTube",
                                    "Diagrama de handshake TCP"
                                  ],
                                  "tips": "Visualize o handshake como uma 'conversa' antes de enviar dados para garantir conexão.",
                                  "learningObjective": "Compreender os fundamentos de confiabilidade e conexão do TCP.",
                                  "commonMistakes": [
                                    "Confundir TCP com IP (TCP é camada de transporte)",
                                    "Ignorar o custo de overhead do TCP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender as características principais do protocolo UDP",
                                  "subSteps": [
                                    "Defina UDP como protocolo sem conexão e não orientado.",
                                    "Explique a ausência de handshake, controle de fluxo ou retransmissão.",
                                    "Descreva o cabeçalho simples de UDP (origem, destino, comprimento, checksum).",
                                    "Discuta vantagens: baixa latência e overhead mínimo.",
                                    "Liste exemplos de portas comuns (ex: 53 para DNS)."
                                  ],
                                  "verification": "Listar 5 diferenças do UDP em relação a protocolos confiáveis e simular envio sem ACK.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 768 (UDP)",
                                    "Comparador de cabeçalhos TCP/UDP online",
                                    "Ferramenta Wireshark para captura de pacotes UDP"
                                  ],
                                  "tips": "Pense em UDP como 'carta enviada sem confirmação de recebimento'.",
                                  "learningObjective": "Identificar simplicidade e trade-offs de performance do UDP.",
                                  "commonMistakes": [
                                    "Achar que UDP é sempre mais lento",
                                    "Esquecer que UDP tem checksum básico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar diferenças chave entre TCP e UDP",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: conexão (TCP sim, UDP não), confiabilidade (TCP sim, UDP não).",
                                    "Compare overhead: TCP maior (20 bytes+), UDP menor (8 bytes).",
                                    "Analise latência: UDP mais baixa, TCP com delays por ACKs.",
                                    "Discuta ordenação e duplicatas: TCP gerencia, UDP não.",
                                    "Avalie checksum e erros: ambos têm, mas TCP retransmite."
                                  ],
                                  "verification": "Preencher tabela comparativa com 8 diferenças e discutir com parceiro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Infográfico TCP vs UDP",
                                    "Simulador de rede como Cisco Packet Tracer"
                                  ],
                                  "tips": "Use mnemônicos: TCP = 'Telefone Confiável', UDP = 'Datagrama Urgente'.",
                                  "learningObjective": "Realizar comparação sistemática das características.",
                                  "commonMistakes": [
                                    "Ignorar contexto de uso na comparação",
                                    "Confundir camadas (TCP/UDP são transporte, não rede)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar usos típicos e cenários de aplicação",
                                  "subSteps": [
                                    "Liste aplicações TCP: web (HTTP), email (SMTP), transferências de arquivo (FTP).",
                                    "Liste aplicações UDP: streaming vídeo (ex: VoIP), jogos online, DNS.",
                                    "Explique por quê: TCP para dados críticos, UDP para tempo real.",
                                    "Simule cenários: perda de pacotes em vídeo call (UDP tolera).",
                                    "Discuta híbridos como QUIC (UDP com confiabilidade TCP-like)."
                                  ],
                                  "verification": "Mapear 5 aplicações reais a TCP ou UDP justificando a escolha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de portas IANA",
                                    "Exemplos de tráfego Wireshark",
                                    "Artigos sobre VoIP e latência"
                                  ],
                                  "tips": "Pergunte: 'Precisa de garantia ou velocidade?' para escolher.",
                                  "learningObjective": "Aplicar conhecimentos em contextos práticos de rede.",
                                  "commonMistakes": [
                                    "Achar UDP inadequado para qualquer dado importante",
                                    "Não considerar evolução como WebRTC"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando netcat no terminal: envie dados via TCP (nc -l -p 1234) e UDP (nc -u -l -p 1234), capture com Wireshark para observar handshakes ausentes no UDP e perda simulada de pacotes.",
                              "finalVerifications": [
                                "Explicar handshake TCP sem erros.",
                                "Listar 5 diferenças principais TCP vs UDP.",
                                "Identificar 3 apps TCP e 3 UDP corretamente.",
                                "Desenhar cabeçalhos simplificados de ambos.",
                                "Simular cenário onde UDP falha e TCP succeeds.",
                                "Discutir trade-off latência vs confiabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas características (sem confusões conceituais).",
                                "Completude da tabela comparativa (mínimo 8 itens).",
                                "Justificativa clara para usos típicos.",
                                "Uso correto de terminologia técnica.",
                                "Demonstração prática via simulação ou Wireshark.",
                                "Conexão com modelo TCP/IP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de checksums e probabilidades de perda de pacotes.",
                                "Física: Analogia com propagação de sinais e latência em redes.",
                                "Segurança da Informação: Vulnerabilidades em UDP (amplificação DDoS).",
                                "Desenvolvimento de Software: Implementação de sockets em Python (TCP/UDP).",
                                "Estatística: Análise de throughput e perda em experimentos de rede."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps de streaming como Netflix (UDP para vídeo low-latency) vs downloads de arquivos via HTTP (TCP para integridade total), otimizando performance em jogos multiplayer onde perda ocasional de posição é tolerável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Descrever mecanismos de controle de congestionamento",
                            "description": "Identificar e descrever algoritmos básicos como Tahoe, Reno e Cubic usados no TCP para evitar sobrecarga na rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Congestionamento de Rede",
                                  "subSteps": [
                                    "Defina congestionamento de rede e seus impactos (perda de pacotes, atraso).",
                                    "Explique a janela de congestionamento (cwnd) no TCP.",
                                    "Descreva detecção de congestionamento via timeout ou duplicate ACKs.",
                                    "Identifique fases de controle: slow start, congestion avoidance.",
                                    "Revise o papel do ACK e RTT na detecção."
                                  ],
                                  "verification": "Resuma em um diagrama os mecanismos de detecção de congestionamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 5681 (TCP Congestion Control)",
                                    "Vídeo Khan Academy sobre TCP",
                                    "Artigo Wikipedia: TCP congestion control"
                                  ],
                                  "tips": "Use analogias como trânsito em estradas para visualizar.",
                                  "learningObjective": "Compreender fundamentos de congestionamento e detecção no TCP.",
                                  "commonMistakes": "Confundir congestionamento com perda por corrupção de pacotes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Algoritmo Tahoe",
                                  "subSteps": [
                                    "Descreva o comportamento no slow start e congestion avoidance.",
                                    "Explique reação a timeout: reset cwnd para 1 MSS.",
                                    "Detalhe reação a 3 duplicate ACKs: slow start threshold pela metade, retransmitir.",
                                    "Compare com comportamento original do TCP.",
                                    "Simule um cenário de perda por timeout."
                                  ],
                                  "verification": "Desenhe gráfico de evolução da cwnd para Tahoe em perda.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 2001 (TCP Tahoe)",
                                    "Ferramenta de simulação como Packet Tracer"
                                  ],
                                  "tips": "Foque na simplicidade agressiva do Tahoe.",
                                  "learningObjective": "Dominar funcionamento e limitações do Tahoe.",
                                  "commonMistakes": "Ignorar distinção entre timeout e fast retransmit."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Algoritmo Reno",
                                  "subSteps": [
                                    "Diferencie fast recovery do Tahoe.",
                                    "Explique inflação da cwnd durante fast recovery (cwnd = ssthresh + 3*MSS).",
                                    "Descreva deflação após ACKs novos.",
                                    "Compare reação a timeout vs. 3 dup ACKs.",
                                    "Analise melhorias em redes com perdas não-congestionadas."
                                  ],
                                  "verification": "Compare gráficos de cwnd Tahoe vs. Reno em mesmo cenário.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "RFC 2581 (TCP Reno)",
                                    "Slides de curso sobre TCP variants"
                                  ],
                                  "tips": "Visualize Reno como 'mais suave' que Tahoe em recuperação rápida.",
                                  "learningObjective": "Entender aprimoramentos do Reno sobre Tahoe.",
                                  "commonMistakes": "Confundir slow start com fast recovery."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Algoritmo Cubic",
                                  "subSteps": [
                                    "Descreva função cúbica para crescimento de cwnd baseado em tempo.",
                                    "Explique cálculo de W_max e beta para multiplicativo decrease.",
                                    "Compare com Reno em redes de alta largura/banda atrasada (BDP).",
                                    "Detalhe detecção híbrida de congestionamento (Reno-like).",
                                    "Revise adoção no Linux kernel."
                                  ],
                                  "verification": "Calcule cwnd em um exemplo numérico com Cubic.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "RFC 5682 (Cubic)",
                                    "Gráficos interativos de Cubic vs. Reno"
                                  ],
                                  "tips": "Use calculadora para função cúbica: cwnd = C*(t - K)^3.",
                                  "learningObjective": "Compreender Cubic para redes modernas de alta performance.",
                                  "commonMistakes": "Subestimar foco em BDP alto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar Algoritmos e Aplicações",
                                  "subSteps": [
                                    "Tabela comparativa: reação a perdas, eficiência em diferentes redes.",
                                    "Discuta evolução: Tahoe → Reno → Cubic.",
                                    "Analise cenários: LAN (Reno bom), WAN (Cubic melhor).",
                                    "Explore ferramentas para observar (Wireshark, tcpdump).",
                                    "Resuma vantagens/desvantagens."
                                  ],
                                  "verification": "Crie tabela de comparação e explique escolha por rede.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark para captura TCP",
                                    "Artigo 'Evolution of TCP Congestion Control'"
                                  ],
                                  "tips": "Teste em Wireshark tráfego real para validar.",
                                  "learningObjective": "Sintetizar conhecimentos para descrição contextual.",
                                  "commonMistakes": "Generalizar sem considerar tipo de rede."
                                }
                              ],
                              "practicalExample": "Use Wireshark para capturar tráfego HTTP em uma rede congestionada (simule com netem no Linux: tc qdisc add dev eth0 root netem delay 100ms loss 1%). Observe evolução da cwnd e identifique se Reno ou Cubic está ativo via padrões de ACKs e retransmissões.",
                              "finalVerifications": [
                                "Descreva com diagrama reação de Tahoe a 3 dup ACKs.",
                                "Explique por que Cubic supera Reno em links de alta latência.",
                                "Identifique em log Wireshark um evento de fast recovery.",
                                "Compare eficiência em throughput para BDP=1000 pacotes.",
                                "Liste 3 limitações do Tahoe em redes modernas.",
                                "Simule cálculo de W_cubic para t=10s, C=0.4."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de algoritmos (80% cobertura de mecanismos chave).",
                                "Uso correto de terminologia (cwnd, ssthresh, fast recovery).",
                                "Qualidade de diagramas/gráficos para evolução de cwnd.",
                                "Análise comparativa com exemplos quantitativos.",
                                "Aplicação prática demonstrada via ferramenta/simulação.",
                                "Clareza na distinção de cenários de uso."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções cúbicas e exponenciais no crescimento de janelas.",
                                "Física: Analogia com fluxo de fluidos e gargalos em tubulações.",
                                "Estatística: Probabilidade de perdas e modelagem estocástica de redes.",
                                "Economia: Otimização de recursos em sistemas distribuídos."
                              ],
                              "realWorldApplication": "Esses algoritmos garantem estabilidade da internet global, otimizando downloads/streaming em conexões variadas (ex: Netflix usa Cubic-like para alta qualidade em WiFi/mobile), prevenindo colapsos em data centers como AWS durante picos de tráfego."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Explicar segmentação e remontagem",
                            "description": "Detalhar como a camada de transporte divide dados em segmentos (TCP) ou datagramas (UDP) e garante a entrega ordenada no receptor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Básico de Segmentação na Camada de Transporte",
                                  "subSteps": [
                                    "Revise a função da camada de transporte no modelo TCP/IP.",
                                    "Identifique por que os dados são divididos em unidades menores (segmentos ou datagramas).",
                                    "Compare o tamanho típico de um segmento TCP (até 1460 bytes) com datagramas UDP.",
                                    "Desenhe um diagrama simples mostrando dados de aplicação divididos em segmentos.",
                                    "Explique o overhead adicionado pelos cabeçalhos de transporte."
                                  ],
                                  "verification": "Crie um diagrama anotado mostrando a divisão de uma mensagem de 5000 bytes em 4 segmentos TCP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama do modelo TCP/IP",
                                    "Folha de papel ou ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Use analogia de cortar uma pizza grande em fatias para transportar.",
                                  "learningObjective": "Compreender a necessidade e o processo inicial de segmentação de dados.",
                                  "commonMistakes": "Confundir segmentação com fragmentação da camada de rede (IP)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Segmentação e Cabeçalhos no TCP",
                                  "subSteps": [
                                    "Estude o cabeçalho TCP: campos de porta origem/destino, sequência e ACK.",
                                    "Simule a atribuição de números de sequência sequenciais para cada segmento.",
                                    "Discuta como o TCP lida com dados maiores que o MTU usando MSS (Maximum Segment Size).",
                                    "Identifique flags importantes como SYN, ACK e FIN.",
                                    "Calcule o tamanho total de um segmento com cabeçalho de 20 bytes."
                                  ],
                                  "verification": "Liste os 5 primeiros campos do cabeçalho TCP e explique o papel dos números de sequência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 793 para TCP",
                                    "Ferramenta Wireshark para capturar pacotes reais"
                                  ],
                                  "tips": "Capture tráfego HTTP real no Wireshark para ver segmentos TCP ao vivo.",
                                  "learningObjective": "Dominar como o TCP segmenta dados e adiciona metadados para controle.",
                                  "commonMistakes": "Ignorar que números de sequência começam em um valor aleatório no handshake."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Datagramas UDP e Diferenças com TCP",
                                  "subSteps": [
                                    "Examine o cabeçalho UDP simples: apenas portas e checksum.",
                                    "Explique que UDP não segmenta com numeração ou garantia de ordem.",
                                    "Compare cenários: TCP para email confiável vs UDP para vídeo streaming.",
                                    "Discuta quando usar UDP apesar da falta de segmentação ordenada.",
                                    "Simule perda de datagramas UDP sem reenvio."
                                  ],
                                  "verification": "Crie uma tabela comparativa TCP vs UDP com 5 diferenças chave em segmentação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela comparativa TCP/UDP impressa",
                                    "Vídeos curtos de streaming UDP como DNS"
                                  ],
                                  "tips": "Pense em UDP como 'envio postal sem rastreamento' vs TCP 'entrega com assinatura'.",
                                  "learningObjective": "Diferenciar segmentação confiável (TCP) de não confiável (UDP).",
                                  "commonMistakes": "Achar que UDP sempre segmenta como TCP; UDP envia datagramas atômicos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender Remontagem e Garantia de Ordem no Receptor",
                                  "subSteps": [
                                    "Descreva como o receptor TCP usa números de sequência para reordenar segmentos.",
                                    "Explique ACKs cumulativos e reenvio de segmentos perdidos.",
                                    "Simule um cenário com segmentos fora de ordem (ex: 1,3,2 chegam).",
                                    "Discuta buffers de remontagem e janelas deslizantes.",
                                    "Compare com UDP, onde a aplicação deve remontar se necessário."
                                  ],
                                  "verification": "Simule em papel a remontagem de 5 segmentos chegados fora de ordem usando numeração.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulador online de TCP como TCPtrace",
                                    "Papel e caneta para simulação manual"
                                  ],
                                  "tips": "Use cartões numerados para fisicamente simular chegada e remontagem de segmentos.",
                                  "learningObjective": "Explicar mecanismos de remontagem ordenada no TCP.",
                                  "commonMistakes": "Confundir ACKs com confirmação imediata; TCP usa ACKs atrasados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Conceitos com uma Simulação Prática",
                                  "subSteps": [
                                    "Configure Wireshark para capturar uma conexão TCP (ex: download de arquivo).",
                                    "Analise segmentos enviados e ACKs recebidos, identificando segmentação.",
                                    "Observe remontagem em tempo real no fluxo de dados reconstruído.",
                                    "Teste com UDP enviando pacotes DNS e notando ausência de ordem.",
                                    "Registre lições aprendidas em um relatório curto."
                                  ],
                                  "verification": "Produza um screenshot do Wireshark mostrando 3 segmentos TCP com números de sequência.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Conexão de internet para testes reais"
                                  ],
                                  "tips": "Filtre por 'tcp.port == 80' para focar em HTTP e ver segmentação clara.",
                                  "learningObjective": "Aplicar conhecimentos em uma simulação real para reforçar segmentação e remontagem.",
                                  "commonMistakes": "Não filtrar capturas, resultando em tráfego excessivo e confusão."
                                }
                              ],
                              "practicalExample": "Ao enviar uma página web de 10KB via HTTP/TCP, o dado é dividido em ~7 segmentos numerados (1-7000, 7001- etc.). Se chegarem como 3,1,2,4..., o receptor segura 3 até 1 e 2 chegarem, então ACK 4 e remonta na ordem correta para a aplicação.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre segmento TCP e datagrama UDP.",
                                "Desenhar e rotular um cabeçalho TCP com números de sequência.",
                                "Simular remontagem de segmentos fora de ordem em um exemplo dado.",
                                "Identificar em Wireshark um fluxo TCP com ACKs confirmando ordem.",
                                "Comparar impactos de perda em TCP vs UDP.",
                                "Listar 3 vantagens da segmentação para eficiência de rede."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de cabeçalhos TCP/UDP (90% correto).",
                                "Clareza na explicação de numeração de sequência e ACKs.",
                                "Capacidade de simular remontagem sem erros lógicos.",
                                "Uso correto de analogias e diagramas para ilustrar conceitos.",
                                "Diferenciação precisa entre TCP (ordenado) e UDP (best-effort).",
                                "Aplicação prática demonstrada via Wireshark ou simulação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências numéricas e aritmética modular em números de sequência.",
                                "Física: Analogia com transmissão de ondas/partículas e recombinação.",
                                "Programação: Implementação de sockets TCP/UDP em Python.",
                                "Estatística: Probabilidade de perda de pacotes e impacto na ordem."
                              ],
                              "realWorldApplication": "Em videochamadas como Zoom (UDP para baixa latência, com remontagem na app), ou downloads HTTP/TCP onde segmentos perdidos são reenviados para garantir páginas web completas e ordenadas, evitando conteúdo embaralhado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Camada de Internet (Rede)",
                        "description": "A camada de internet gerencia o roteamento de pacotes entre redes, utilizando o protocolo IP, planos de dados e controle, incluindo SDN e algoritmos de roteamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Descrever o protocolo IP e datagramas",
                            "description": "Explicar o funcionamento do IP como protocolo sem conexão, estrutura de datagramas IP (cabeçalho com endereços origem/destino) e sua função no roteamento best-effort.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as características fundamentais do protocolo IP",
                                  "subSteps": [
                                    "Pesquise a definição de protocolo IP como protocolo de camada de rede no modelo TCP/IP.",
                                    "Identifique que o IP é sem conexão (connectionless), ou seja, não estabelece sessão antes de enviar dados.",
                                    "Explique o conceito de best-effort delivery: o IP envia pacotes sem garantia de entrega, ordem ou integridade.",
                                    "Diferencie datagramas IP de pacotes com conexão, como TCP.",
                                    "Anote exemplos de falhas no best-effort, como perda de pacotes."
                                  ],
                                  "verification": "Resuma em 3 frases as características principais e compartilhe com um colega para feedback.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 791 (padrão IP)",
                                    "Diagramas do modelo TCP/IP",
                                    "Vídeo introdutório sobre IP no YouTube"
                                  ],
                                  "tips": "Use analogias como correio postal: envia sem confirmar recebimento.",
                                  "learningObjective": "Compreender o papel e as limitações do IP como protocolo sem conexão.",
                                  "commonMistakes": [
                                    "Confundir IP com TCP (que é com conexão)",
                                    "Achar que IP garante entrega de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a estrutura geral de um datagrama IP",
                                  "subSteps": [
                                    "Desenhe um datagrama IP dividido em cabeçalho e payload (dados).",
                                    "Identifique o tamanho típico do cabeçalho: 20 bytes mínimos (versão IPv4).",
                                    "Liste os campos principais: versão, comprimento do cabeçalho, tipo de serviço, comprimento total, ID, flags, fragment offset, TTL, protocolo, checksum, endereço origem e destino.",
                                    "Explique que o payload contém dados de protocolos superiores como TCP ou UDP.",
                                    "Compare com IPv6 para notar diferenças básicas."
                                  ],
                                  "verification": "Crie um diagrama simples do datagrama e rotule 5 campos chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io",
                                    "Exemplo de captura Wireshark de datagrama IP",
                                    "Tabela de campos do cabeçalho IP"
                                  ],
                                  "tips": "Memorize com mnemônicos: 'Very Clever People Take Coffee And Drink Every Sip' para campos iniciais.",
                                  "learningObjective": "Visualizar e descrever a composição de um datagrama IP.",
                                  "commonMistakes": [
                                    "Ignorar o campo checksum (verificação de erros)",
                                    "Confundir payload com cabeçalho"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar os endereços origem e destino no cabeçalho IP",
                                  "subSteps": [
                                    "Descreva os endereços IP como 32 bits (IPv4) em notação decimal pontuada (ex: 192.168.1.1).",
                                    "Explique o endereço origem: IP do remetente, usado para respostas.",
                                    "Explique o endereço destino: IP do receptor final, guia o roteamento.",
                                    "Simule uma troca: envie um ping (ICMP sobre IP) e capture os endereços.",
                                    "Discuta NAT e como endereços privados são traduzidos."
                                  ],
                                  "verification": "Capture um pacote real com Wireshark e identifique origem/destino corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Comando ping no terminal",
                                    "Calculadora de IP online"
                                  ],
                                  "tips": "Teste pingando google.com para ver endereços reais em ação.",
                                  "learningObjective": "Entender como endereços IP direcionam datagramas pela rede.",
                                  "commonMistakes": [
                                    "Trocar origem por destino",
                                    "Esquecer representação binária/hex"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender o papel do IP no roteamento best-effort",
                                  "subSteps": [
                                    "Descreva o roteamento: roteadores leem endereço destino e encaminham via tabelas de roteamento.",
                                    "Explique TTL (Time To Live): decrementa a cada salto, previne loops.",
                                    "Discuta fragmentação: datagramas grandes são divididos e remontados no destino.",
                                    "Simule um caminho de roteamento com traceroute.",
                                    "Relacione com best-effort: sem ACKs, confiabilidade em camadas superiores."
                                  ],
                                  "verification": "Execute traceroute e explique o caminho com TTL em pelo menos 3 saltos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Comando traceroute/pathping",
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Mapa mental de roteamento IP"
                                  ],
                                  "tips": "Visualize roteadores como postes de entrega postal decidindo rotas.",
                                  "learningObjective": "Descrever como IP roteia datagramas de forma não confiável.",
                                  "commonMistakes": [
                                    "Pensar que IP remonta fragmentos (feito no destino)",
                                    "Confundir roteamento com switching L2"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture tráfego de um ping para 8.8.8.8: identifique o datagrama IP, cabeçalho com origem (seu IP), destino (8.8.8.8), TTL decrementando em traceroute, e explique por que um pacote perdido não é reenviado pelo IP.",
                              "finalVerifications": [
                                "Desenhar e rotular corretamente o cabeçalho IP com 10 campos principais.",
                                "Explicar verbalmente 'sem conexão e best-effort' com exemplo de perda de pacote.",
                                "Identificar origem/destino em uma captura Wireshark real.",
                                "Executar traceroute e interpretar TTL e saltos.",
                                "Diferenciar datagrama IP de frame Ethernet ou segmento TCP.",
                                "Listar 3 limitações do IP resolvidas por TCP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das características sem conexão e best-effort (80% corretude).",
                                "Detalhe completo do cabeçalho IP, incluindo origem/destino e TTL.",
                                "Uso correto de terminologia técnica (datagrama, roteamento, fragmentação).",
                                "Capacidade de aplicar em exemplo prático com Wireshark ou traceroute.",
                                "Identificação de erros comuns e limitações do protocolo.",
                                "Clareza na explicação de roteamento best-effort."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão binário-decimal para endereços IP e cálculos de checksum.",
                                "Física: Transmissão de sinais digitais em cabos/rede sem fio como base para datagramas.",
                                "Segurança da Informação: Vulnerabilidades IP como spoofing de origem.",
                                "Estatística: Probabilidades de perda de pacotes em redes reais."
                              ],
                              "realWorldApplication": "Todo tráfego da internet usa IP para rotear e-mails, vídeos no YouTube e acessos a sites; sem IP, não há navegação global, e serviços como VoIP dependem de seu best-effort com compensações em apps."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Identificar planos de dados e controle",
                            "description": "Diferenciar o plano de dados (encaminhamento de pacotes) do plano de controle (cálculo de rotas), com ênfase em Redes Definidas por Software (SDN).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Roteamento Tradicional em Redes",
                                  "subSteps": [
                                    "Estude o funcionamento de roteadores tradicionais, onde dados e controle são integrados no mesmo dispositivo.",
                                    "Analise como roteadores calculam rotas (controle) e encaminham pacotes (dados) usando protocolos como OSPF ou BGP.",
                                    "Identifique limitações: escalabilidade baixa, configuração manual e lentidão em atualizações.",
                                    "Desenhe um diagrama simples de um roteador tradicional destacando a integração.",
                                    "Pesquise exemplos reais de redes legadas em empresas."
                                  ],
                                  "verification": "Crie um diagrama anotado explicando a integração de planos em roteadores tradicionais e liste 3 limitações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama em branco",
                                    "Artigos sobre OSPF/BGP (ex: Cisco docs)",
                                    "Vídeo introdutório sobre roteamento (YouTube/Khan Academy)"
                                  ],
                                  "tips": "Use analogia: roteador tradicional é como um motorista que planeja e dirige ao mesmo tempo.",
                                  "learningObjective": "Entender a arquitetura monolítica de roteadores tradicionais e suas ineficiências.",
                                  "commonMistakes": [
                                    "Confundir plano de dados com camada física",
                                    "Ignorar protocolos de roteamento dinâmico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Separação de Planos de Dados e Controle",
                                  "subSteps": [
                                    "Defina plano de dados: hardware que encaminha pacotes baseado em tabelas de fluxo (forwarding table).",
                                    "Defina plano de controle: software que calcula rotas, instala regras e gerencia topologia.",
                                    "Compare: em redes tradicionais, ambos no mesmo dispositivo; na separação, controle é centralizado.",
                                    "Estude fluxogramas mostrando comunicação via protocolos como OpenFlow.",
                                    "Simule mentalmente: pacotes chegam ao switch de dados, regras vêm do controlador."
                                  ],
                                  "verification": "Escreva definições curtas para cada plano e desenhe um fluxograma de interação entre eles.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel para fluxogramas",
                                    "Documentação OpenFlow (opennetworking.org)",
                                    "Ferramenta de desenho online (draw.io)"
                                  ],
                                  "tips": "Pense no plano de controle como o 'cérebro' remoto e dados como os 'músculos' locais.",
                                  "learningObjective": "Diferenciar conceitualmente os dois planos e sua interação.",
                                  "commonMistakes": [
                                    "Achar que plano de dados calcula rotas",
                                    "Confundir com separação de camadas OSI"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Redes Definidas por Software (SDN)",
                                  "subSteps": [
                                    "Estude arquitetura SDN: switches de dados + controlador central (ex: OpenDaylight, ONOS).",
                                    "Aprenda como SDN usa southbound APIs (OpenFlow) para programar switches.",
                                    "Analise vantagens: centralização, programabilidade, automação e escalabilidade.",
                                    "Instale e explore um mininet (simulador SDN) para ver controlador instalando fluxos.",
                                    "Compare SDN com redes tradicionais em termos de gerenciamento."
                                  ],
                                  "verification": "Configure um cenário simples no Mininet e capture screenshot de fluxos instalados pelo controlador.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Mininet instalado (mininet.org)",
                                    "Controlador Ryu ou POX",
                                    "Tutorial Mininet SDN (YouTube)"
                                  ],
                                  "tips": "Comece com Mininet VM para evitar problemas de instalação.",
                                  "learningObjective": "Compreender SDN como implementação prática da separação de planos.",
                                  "commonMistakes": [
                                    "Confundir controlador SDN com servidor DHCP",
                                    "Ignorar southbound/northbound APIs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e Aplicar os Conceitos",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: tradicional vs. separado (SDN) para dados/controle.",
                                    "Simule cenários: falha de link em SDN (controlador recalcula) vs. tradicional.",
                                    "Discuta ênfase SDN: abstração de hardware, apps northbound para políticas.",
                                    "Resolva exercícios: identifique planos em diagramas mistos.",
                                    "Reflita sobre impacto: como SDN habilita redes intent-based."
                                  ],
                                  "verification": "Preencha tabela comparativa e resolva 3 exercícios de identificação de planos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela modelo em Excel/Google Sheets",
                                    "Exercícios impressos ou online (Packet Tracer SDN labs)"
                                  ],
                                  "tips": "Use cores na tabela: verde para dados, azul para controle.",
                                  "learningObjective": "Aplicar diferenciação em contextos práticos e enfatizar SDN.",
                                  "commonMistakes": [
                                    "Subestimar centralização em SDN como ponto único de falha",
                                    "Misturar plano de controle com plano de gerenciamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um data center do Google (projeto B4), switches de dados encaminham tráfego de vídeo em massa usando tabelas de fluxo otimizadas, enquanto um controlador SDN central calcula rotas dinâmicas baseadas em latência e carga, ajustando em segundos via OpenFlow – simulável no Mininet com topologia de 4 switches.",
                              "finalVerifications": [
                                "Explique verbalmente a diferença entre planos de dados e controle em 1 minuto.",
                                "Desenhe e label diagrama SDN com setas mostrando fluxo de pacotes e regras.",
                                "Identifique planos em um diagrama híbrido (tradicional + SDN).",
                                "Liste 3 vantagens SDN da separação.",
                                "Simule no Mininet: instale fluxo e verifique encaminhamento.",
                                "Responda quiz: 'O que acontece se controlador falha?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de planos de dados (forwarding) e controle (routing).",
                                "Correta representação visual da separação em SDN.",
                                "Compreensão de protocolos como OpenFlow e arquiteturas SDN.",
                                "Identificação de limitações tradicionais vs. benefícios SDN.",
                                "Capacidade de simular/aplicar em ferramenta prática (Mininet).",
                                "Uso correto de terminologia (southbound API, controlador)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolver apps para controladores SDN em Python (Ryu/ONOS).",
                                "Matemática: Algoritmos de roteamento (Dijkstra, Bellman-Ford) no plano de controle.",
                                "Segurança: Políticas de segurança centralizadas via SDN controllers.",
                                "Gestão de Projetos: Escalabilidade e automação em redes empresariais."
                              ],
                              "realWorldApplication": "Em provedores de nuvem como AWS ou Azure, SDN separa controle (otimização global de rotas) de dados (tráfego de alta velocidade), permitindo auto-scaling e recuperação rápida de falhas, reduzindo custos operacionais em 50% em data centers grandes."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Listar algoritmos de roteamento",
                            "description": "Descrever algoritmos como Distance Vector (RIP), Link State (OSPF) e Path Vector (BGP), explicando princípios básicos de convergência e escalabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Roteamento Dinâmico",
                                  "subSteps": [
                                    "Definir roteamento e sua importância na camada de rede do modelo TCP/IP",
                                    "Diferenciar roteamento estático de dinâmico, destacando a necessidade de protocolos dinâmicos",
                                    "Explicar conceitos chave: tabela de roteamento, métricas de custo (hops, largura de banda) e atualizações periódicas",
                                    "Introduzir convergência (tempo para rede se estabilizar após mudança) e escalabilidade (capacidade de lidar com redes grandes)",
                                    "Revisar problemas comuns como loops de roteamento e count-to-infinity"
                                  ],
                                  "verification": "Escrever um parágrafo resumindo roteamento dinâmico, convergência e escalabilidade, sem erros conceituais",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Capítulo sobre roteamento em livro CCNA",
                                    "Vídeo 'Routing Basics' no YouTube (Khan Academy ou Cisco Networking Academy)"
                                  ],
                                  "tips": "Use diagramas de rede simples para visualizar tabelas de roteamento",
                                  "learningObjective": "Dominar os conceitos básicos que sustentam os algoritmos de roteamento",
                                  "commonMistakes": [
                                    "Confundir roteamento com encaminhamento de pacotes na camada 2",
                                    "Ignorar o impacto da escalabilidade em redes reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Algoritmo Distance Vector (RIP)",
                                  "subSteps": [
                                    "Descrever o princípio: cada roteador compartilha sua tabela completa com vizinhos (algoritmo Bellman-Ford)",
                                    "Explicar cálculo de distância: métrica baseada em hops, atualizações periódicas a cada 30 segundos",
                                    "Analisar convergência: lenta devido a propagação sequencial, suscetível a loops e count-to-infinity",
                                    "Discutir limitações de escalabilidade: máximo 15 hops, não adequado para redes grandes",
                                    "Exemplificar com um cenário de 3 roteadores em linha"
                                  ],
                                  "verification": "Desenhar uma tabela de roteamento RIP para uma topologia simples e simular uma falha de link",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador Packet Tracer ou GNS3",
                                    "RFC 1058 (RIP specification)"
                                  ],
                                  "tips": "Lembre-se: 'distância' é compartilhada, não o caminho completo",
                                  "learningObjective": "Compreender o funcionamento, prós e contras do RIP em termos de convergência e escalabilidade",
                                  "commonMistakes": [
                                    "Pensar que RIP usa caminho completo em vez de vetores de distância",
                                    "Subestimar problemas de convergência lenta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Algoritmo Link State (OSPF)",
                                  "subSteps": [
                                    "Descrever o princípio: cada roteador constrói um mapa completo da topologia (LSA - Link State Advertisements)",
                                    "Explicar algoritmo Dijkstra (SPF): calcular caminho mais curto a partir do grafo de links",
                                    "Analisar convergência: rápida, pois todos recebem atualizações simultâneas e recalculam independentes",
                                    "Discutir escalabilidade: hierárquica com áreas, suporta redes grandes, mas consome mais CPU/memória",
                                    "Comparar brevemente com RIP em um diagrama"
                                  ],
                                  "verification": "Listar os passos do Dijkstra para uma rede com 4 nós e identificar o caminho mais curto",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Diagrama interativo de OSPF no NetAcad",
                                    "RFC 2328 (OSPF v2)"
                                  ],
                                  "tips": "Visualize a rede como um grafo: nós=roteadores, arestas=custos de links",
                                  "learningObjective": "Mestre o OSPF, focando em sua superioridade em convergência para redes internas",
                                  "commonMistakes": [
                                    "Confundir LSAs com tabelas de distância",
                                    "Ignorar o overhead computacional do Dijkstra"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Algoritmo Path Vector (BGP) e Comparações",
                                  "subSteps": [
                                    "Descrever o princípio: usado entre AS (Autonomous Systems), caminhos como sequências de AS (evita loops)",
                                    "Explicar políticas: atributos como AS_PATH, LOCAL_PREF para decisões de roteamento",
                                    "Analisar convergência: lenta em grandes mudanças devido a políticas, mas escalável para Internet global",
                                    "Comparar os três: DV (simples, lenta), LS (rápida, redes médias), PV (política-driven, global)",
                                    "Resumir tabela comparativa: convergência, escalabilidade, uso típico"
                                  ],
                                  "verification": "Criar uma tabela comparativa dos 3 algoritmos com colunas para princípio, convergência e escalabilidade",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 4271 (BGP-4)",
                                    "Simulação BGP no EVE-NG"
                                  ],
                                  "tips": "BGP é 'exterior': pense em ISPs trocando rotas entre domínios",
                                  "learningObjective": "Listar e comparar os algoritmos, enfatizando princípios de convergência e escalabilidade",
                                  "commonMistakes": [
                                    "Confundir BGP com IGP (é EGP)",
                                    "Subestimar o papel de políticas na convergência BGP"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Cisco Packet Tracer, configure uma rede com 4 roteadores: ative RIP em uma sub-rede, OSPF em outra e simule BGP entre dois AS. Desligue um link e meça o tempo de convergência observando as tabelas de roteamento atualizarem.",
                              "finalVerifications": [
                                "Listar corretamente RIP, OSPF e BGP com seus tipos (DV, LS, PV)",
                                "Explicar como cada um calcula rotas e lida com convergência",
                                "Identificar cenários de uso: RIP (pequenas redes), OSPF (empresariais), BGP (Internet)",
                                "Desenhar diagrama simples mostrando loop em DV vs mapa em LS",
                                "Comparar escalabilidade: hops limitados em RIP vs global em BGP",
                                "Definir count-to-infinity e como LS/OSPF o evitam"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos princípios (Bellman-Ford, Dijkstra, AS_PATH)",
                                "Correta análise de convergência (lenta em DV/PV, rápida em LS)",
                                "Avaliação realista de escalabilidade e limitações",
                                "Uso de exemplos ou diagramas para ilustrar conceitos",
                                "Capacidade de comparar os algoritmos em tabela ou prosa clara",
                                "Ausência de confusões entre IGPs (RIP/OSPF) e EGPs (BGP)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e algoritmos de caminho mais curto (Dijkstra, Bellman-Ford)",
                                "Física: Propagação de sinais e latência em links de rede",
                                "Administração: Políticas de roteamento e gerenciamento de tráfego em empresas",
                                "Segurança da Informação: Vulnerabilidades como BGP hijacking",
                                "Economia: Custos de escalabilidade em provedores de Internet"
                              ],
                              "realWorldApplication": "RIP em redes LAN pequenas; OSPF em data centers empresariais para convergência rápida; BGP roteia o tráfego global da Internet entre ISPs, gerenciando bilhões de rotas com políticas para otimizar custos e desempenho."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.4",
                        "name": "Camada de Enlace de Dados",
                        "description": "A camada de enlace fornece comunicação ponto-a-ponto em redes locais, baseada em padrões IEEE como Ethernet.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.4.1",
                            "name": "Explicar funções da camada de enlace",
                            "description": "Descrever detecção e correção de erros, controle de acesso ao meio (CSMA/CD) e enquadramento de dados em redes locais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel geral da camada de enlace no modelo TCP/IP",
                                  "subSteps": [
                                    "Identificar a posição da camada de enlace no modelo TCP/IP (camada 2).",
                                    "Listar as funções principais: enquadramento, detecção/correção de erros e controle de acesso ao meio.",
                                    "Diferenciar camada de enlace de camadas adjacentes (física e de rede).",
                                    "Explicar o foco em redes locais (LAN)."
                                  ],
                                  "verification": "Criar um diagrama do modelo TCP/IP destacando a camada de enlace e suas funções.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama do modelo TCP/IP (impresso ou digital)",
                                    "Vídeo introdutório sobre camadas OSI/TCP/IP"
                                  ],
                                  "tips": "Use analogias como 'envelope' para enquadramento para fixar conceitos.",
                                  "learningObjective": "Entender a função e posição da camada de enlace.",
                                  "commonMistakes": "Confundir com camada de rede (foco em roteamento)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar detecção e correção de erros",
                                  "subSteps": [
                                    "Explicar métodos de detecção: paridade, checksum e CRC (Cyclic Redundancy Check).",
                                    "Demonstrar cálculo simples de CRC em um exemplo de frame.",
                                    "Discutir correção de erros: retransmissão via ACK/NACK.",
                                    "Comparar detecção vs. correção em protocolos como Ethernet."
                                  ],
                                  "verification": "Calcular CRC para um dado de exemplo e verificar integridade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou ferramenta online de CRC",
                                    "Exemplos de frames Ethernet"
                                  ],
                                  "tips": "Pratique com bits binários pequenos para visualizar erros.",
                                  "learningObjective": "Dominar mecanismos de detecção e correção de erros.",
                                  "commonMistakes": "Achar que CRC corrige erros automaticamente (só detecta)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender controle de acesso ao meio (CSMA/CD)",
                                  "subSteps": [
                                    "Definir CSMA/CD: Carrier Sense Multiple Access with Collision Detection.",
                                    "Descrever o processo: escuta, transmissão, detecção de colisão, backoff.",
                                    "Simular uma colisão em rede compartilhada.",
                                    "Comparar com CSMA/CA usado em Wi-Fi."
                                  ],
                                  "verification": "Desenhar fluxograma do processo CSMA/CD com colisão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulador de rede (Cisco Packet Tracer ou online)",
                                    "Vídeo de simulação CSMA/CD"
                                  ],
                                  "tips": "Pense em uma rodovia: escute antes de entrar.",
                                  "learningObjective": "Explicar como CSMA/CD gerencia acesso em LANs.",
                                  "commonMistakes": "Confundir CSMA/CD (Ethernet cabeada) com CSMA/CA (Wi-Fi)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar enquadramento de dados",
                                  "subSteps": [
                                    "Definir enquadramento: adicionar cabeçalho e trailer ao payload.",
                                    "Descrever estrutura de frame Ethernet: préâmbulo, endereços MAC, dados, CRC.",
                                    "Explicar delimitação de frames para separar dados na rede.",
                                    "Discutir overhead e impacto na eficiência."
                                  ],
                                  "verification": "Montar um frame Ethernet exemplo com todos os campos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Modelo de frame Ethernet (diagrama)",
                                    "Ferramenta Wireshark para captura real"
                                  ],
                                  "tips": "Use Wireshark para ver frames reais em sua rede.",
                                  "learningObjective": "Compreender como dados são enquadrados para transmissão local.",
                                  "commonMistakes": "Ignorar endereços MAC como exclusivos da camada de enlace."
                                }
                              ],
                              "practicalExample": "Em uma rede Ethernet de escritório, dois PCs enviam pacotes simultaneamente: CSMA/CD detecta colisão via sinal deformado, para transmissões, aplica backoff exponencial e retransmite frames com CRC para verificar erros.",
                              "finalVerifications": [
                                "Definir corretamente as três funções principais da camada de enlace.",
                                "Calcular CRC para um frame simples sem erros.",
                                "Desenhar e explicar fluxograma CSMA/CD.",
                                "Montar estrutura completa de um frame Ethernet.",
                                "Diferenciar detecção de erros de controle de acesso."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (90% correto).",
                                "Uso de exemplos práticos e diagramas.",
                                "Explicação clara de CSMA/CD e CRC.",
                                "Completude: cobrir todas funções (erros, acesso, enquadramento).",
                                "Capacidade de relacionar a LANs reais.",
                                "Clareza na diferenciação de camadas.",
                                "Criatividade em analogias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos de checksum e polinômios CRC.",
                                "Física: Propagação de sinais elétricos e detecção de colisões.",
                                "Segurança da Informação: Integridade de dados via detecção de erros.",
                                "Eletrônica: Sincronização de bits no préâmbulo do frame."
                              ],
                              "realWorldApplication": "Na configuração de uma rede Wi-Fi doméstica ou Ethernet corporativa, a camada de enlace garante que dados de streaming de vídeo cheguem sem erros ou colisões, otimizando o tráfego local entre roteador e dispositivos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.4.2",
                            "name": "Identificar padrões IEEE 802",
                            "description": "Listar e descrever padrões como IEEE 802.3 (Ethernet), IEEE 802.11 (Wi-Fi) e suas velocidades, topologias e componentes (switches, hubs).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito geral dos padrões IEEE 802",
                                  "subSteps": [
                                    "Pesquise a definição de IEEE e sua função em padrões de rede.",
                                    "Identifique que IEEE 802 refere-se à família de padrões para a camada de enlace de dados (LAN/MAN).",
                                    "Liste os principais padrões da família IEEE 802 (ex: 802.3, 802.11, 802.15).",
                                    "Explique a estrutura numerada dos padrões (ex: 802.x onde x indica o tipo).",
                                    "Anote a importância para interoperabilidade em redes."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo explicando IEEE 802 e liste 3 padrões principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet (site IEEE.org)",
                                    "Caderno para anotações",
                                    "Vídeo introdutório sobre modelo OSI/TCP/IP"
                                  ],
                                  "tips": "Comece pelo site oficial do IEEE para fontes confiáveis; evite wikis não verificadas.",
                                  "learningObjective": "Entender o escopo e a organização da família IEEE 802 na camada de enlace.",
                                  "commonMistakes": [
                                    "Confundir IEEE 802 com TCP/IP (IEEE é camada 2, TCP/IP é modelo completo)",
                                    "Ignorar que 802 abrange LAN, MAN e PAN"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o padrão IEEE 802.3 (Ethernet)",
                                  "subSteps": [
                                    "Descreva a história e evolução do Ethernet (de 10 Mbps a 100 Gbps).",
                                    "Liste velocidades principais: 10BASE-T (10 Mbps), Fast Ethernet (100 Mbps), Gigabit (1 Gbps), 10 Gigabit.",
                                    "Identifique topologias suportadas: estrela, barramento (legado).",
                                    "Explique componentes: hubs (legado, half-duplex), switches (full-duplex, VLANs).",
                                    "Anote CSMA/CD como mecanismo de controle de acesso."
                                  ],
                                  "verification": "Desenhe um diagrama simples de uma rede Ethernet com switches e liste 4 velocidades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de rede (ferramentas como Draw.io)",
                                    "Documentação IEEE 802.3 (resumo online)",
                                    "Simulador de rede como Cisco Packet Tracer"
                                  ],
                                  "tips": "Use tabelas para comparar velocidades e topologias; memorize '802.3 = fio cabeado'.",
                                  "learningObjective": "Dominar características, velocidades, topologias e componentes do Ethernet.",
                                  "commonMistakes": [
                                    "Confundir hub com switch (hub é multi-port repeater)",
                                    "Esquecer evolução para full-duplex sem CSMA/CD"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o padrão IEEE 802.11 (Wi-Fi)",
                                  "subSteps": [
                                    "Liste as versões: 802.11a/b/g/n/ac/ax (Wi-Fi 4/5/6).",
                                    "Descreva velocidades: até 11 Mbps (b), 54 Mbps (g), 1.3 Gbps (ac), 9.6 Gbps (ax).",
                                    "Identifique bandas: 2.4 GHz, 5 GHz, 6 GHz (ax).",
                                    "Explique topologias: BSS (infraestrutura), IBSS (ad-hoc).",
                                    "Mencione componentes: Access Points (AP), estações cliente, repetidores."
                                  ],
                                  "verification": "Crie uma tabela comparando 3 versões Wi-Fi com velocidades e bandas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de especificações Wi-Fi (site Wi-Fi Alliance)",
                                    "Vídeos sobre evolução Wi-Fi",
                                    "Roteador Wi-Fi para observação prática"
                                  ],
                                  "tips": "Associe '802.11 = sem fio'; foque em MU-MIMO e OFDMA para ax.",
                                  "learningObjective": "Conhecer evoluções, velocidades, frequências e componentes do Wi-Fi.",
                                  "commonMistakes": [
                                    "Misturar velocidades reais vs teóricas",
                                    "Ignorar interferências em 2.4 GHz"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar padrões, topologias e componentes",
                                  "subSteps": [
                                    "Compare 802.3 vs 802.11: cabeado vs sem fio, velocidades, alcance.",
                                    "Liste topologias comuns: estrela (Ethernet), BSS (Wi-Fi).",
                                    "Identifique componentes compartilhados: switches/AP como bridges.",
                                    "Crie um fluxograma para identificar padrão por cenário (ex: LAN cabeada = 802.3).",
                                    "Revise outros padrões brevemente (ex: 802.15 Zigbee)."
                                  ],
                                  "verification": "Responda a 5 perguntas de identificação: 'Qual padrão para Wi-Fi Gigabit?'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma (Lucidchart ou papel)",
                                    "Quiz online sobre IEEE 802",
                                    "Lista de cenários reais"
                                  ],
                                  "tips": "Use mnemônicos: '3 para fio, 11 para ar'; pratique com quizzes.",
                                  "learningObjective": "Aplicar conhecimento para identificar e diferenciar padrões IEEE 802.",
                                  "commonMistakes": [
                                    "Generalizar todos como Ethernet",
                                    "Esquecer componentes híbridos em redes modernas"
                                  ]
                                }
                              ],
                              "practicalExample": "Projeto uma rede mista: Use switches Ethernet (802.3) para conectar PCs em escritório e Access Points Wi-Fi (802.11ac) para dispositivos móveis, diagramando topologias estrela e BSS, especificando velocidades de 1 Gbps cabeado e 866 Mbps sem fio.",
                              "finalVerifications": [
                                "Liste corretamente pelo menos 5 padrões IEEE 802 com descrições breves.",
                                "Descreva velocidades e topologias de 802.3 e 802.11 sem erros.",
                                "Identifique componentes como switches, hubs e APs em contextos corretos.",
                                "Compare diferenças entre Ethernet e Wi-Fi em um parágrafo.",
                                "Crie um diagrama funcional de rede usando padrões IEEE 802.",
                                "Responda quiz com 90% de acerto sobre identificação de padrões."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas descrições de padrões, velocidades e componentes (peso 30%).",
                                "Completude da lista de topologias e exemplos práticos (peso 25%).",
                                "Capacidade de comparação e identificação contextual (peso 20%).",
                                "Qualidade de diagramas e tabelas criados (peso 15%).",
                                "Uso correto de terminologia técnica IEEE (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais eletromagnéticos em Wi-Fi (frequências e interferência).",
                                "Matemática: Cálculo de throughput e latência em redes (taxas de dados).",
                                "Eletrônica: Hardware de rede (circuitos em switches e APs).",
                                "Segurança da Informação: Protocolos de autenticação em 802.11 (WPA3).",
                                "Engenharia: Design de topologias para otimização de redes."
                              ],
                              "realWorldApplication": "Em redes corporativas, usar 802.3 para backbone de alta velocidade e 802.11 para acesso móvel; em casa, configurar roteador Wi-Fi com switches Ethernet para gaming/streaming estável; em IoT, combinar com 802.15 para smart homes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Camada de Aplicação no TCP/IP",
                    "description": "Descreve os protocolos de suporte e serviços na camada de aplicação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Protocolos de Suporte na Camada de Aplicação",
                        "description": "Protocolos que fornecem serviços essenciais de suporte para o funcionamento das aplicações, como resolução de nomes de domínio e configuração dinâmica de hosts.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Identificar e descrever o protocolo DNS",
                            "description": "Explicar o funcionamento do Domain Name System (DNS), incluindo sua hierarquia de servidores (raiz, TLD, autoritativos), o processo de resolução de nomes (recursivo e iterativo) e sua importância para mapear nomes legíveis para endereços IP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o propósito e a importância do DNS",
                                  "subSteps": [
                                    "Defina DNS como o sistema de nomes de domínio que traduz nomes legíveis por humanos (ex: www.example.com) em endereços IP numéricos.",
                                    "Explique a necessidade do DNS: facilita a memorização e uso da internet em vez de IPs.",
                                    "Discuta problemas sem DNS: usuários teriam que memorizar IPs como 192.0.2.1.",
                                    "Identifique componentes básicos: resolvedores (stub resolvers em dispositivos), servidores DNS.",
                                    "Pesquise estatísticas: DNS lida com bilhões de consultas diárias."
                                  ],
                                  "verification": "Escreva um parágrafo explicando o que é DNS e por que é essencial, citando um exemplo real.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet para pesquisa rápida",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Use analogia: DNS é como uma agenda telefônica da internet.",
                                    "Foquem em usabilidade humana vs. precisão de máquinas."
                                  ],
                                  "learningObjective": "Explicar o papel fundamental do DNS na navegação web e mapeamento de nomes para IPs.",
                                  "commonMistakes": [
                                    "Confundir DNS com DHCP (DHCP aloca IPs dinâmicos).",
                                    "Achar que DNS armazena IPs permanentemente (usa cache temporário)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a hierarquia de servidores DNS",
                                  "subSteps": [
                                    "Descreva servidores raiz: 13 clusters globais, respondem com TLD servers.",
                                    "Explique TLD servers: gerenciam domínios como .com, .org; apontam para authoritative servers.",
                                    "Detalhe authoritative name servers: armazenam registros DNS oficiais para domínios específicos.",
                                    "Desenhe um diagrama da hierarquia: cliente -> root -> TLD -> authoritative.",
                                    "Discuta distribuição geográfica para redundância e baixa latência."
                                  ],
                                  "verification": "Crie um diagrama simples da hierarquia DNS e rotule cada nível com funções.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho online (ex: draw.io)",
                                    "Documentação IANA sobre root servers"
                                  ],
                                  "tips": [
                                    "Memorize: Root (. ) -> TLD (.com) -> Authoritative (example.com).",
                                    "Pense em pirâmide: base ampla (root), topo específico (authoritative)."
                                  ],
                                  "learningObjective": "Mapear e descrever os três níveis principais da hierarquia DNS e suas responsabilidades.",
                                  "commonMistakes": [
                                    "Confundir TLD com authoritative (TLD delega para authoritative).",
                                    "Ignorar redundância: há múltiplos servidores por nível."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender o processo de resolução recursiva de DNS",
                                  "subSteps": [
                                    "Descreva o fluxo: Stub resolver envia query para recursive resolver (ex: ISP DNS).",
                                    "Recursive resolver consulta root, que indica TLD; TLD indica authoritative.",
                                    "Authoritative responde com IP; recursive cacheia e retorna ao cliente.",
                                    "Simule com exemplo: resolver www.example.com passo a passo.",
                                    "Explique cache: acelera consultas futuras, com TTL para expiração."
                                  ],
                                  "verification": "Execute uma resolução recursiva manual usando ferramenta como dig (com +trace) e anote os passos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Comando dig ou nslookup no terminal",
                                    "Acesso à internet"
                                  ],
                                  "tips": [
                                    "Use 'dig www.example.com @8.8.8.8' para simular.",
                                    "Recursive é 'preguiçoso': servidor faz todo o trabalho."
                                  ],
                                  "learningObjective": "Descrever sequencialmente o processo recursivo, destacando o papel do recursive resolver.",
                                  "commonMistakes": [
                                    "Achar que cliente consulta todos os servidores diretamente.",
                                    "Esquecer cache e TTL na resposta."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aprender o processo de resolução iterativa e integrar conceitos",
                                  "subSteps": [
                                    "Explique iterativa: resolvedor consulta root diretamente, root responde TLD; resolvedor consulta TLD, etc.",
                                    "Compare com recursiva: iterativa é stepwise pelo resolvedor, recursiva delega tudo.",
                                    "Discuta quando usar cada: recursiva comum em ISPs, iterativa em ferramentas de diagnóstico.",
                                    "Integre hierarquia: ambos usam root -> TLD -> authoritative.",
                                    "Reflita importância: DNS escalável suporta internet global."
                                  ],
                                  "verification": "Compare recursiva vs. iterativa em uma tabela e execute dig iterativo (+trace off).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Terminal com dig",
                                    "Tabela comparativa em documento"
                                  ],
                                  "tips": [
                                    "Iterativa: resolvedor 'pula de pedra em pedra'.",
                                    "Pratique com domínios reais como google.com."
                                  ],
                                  "learningObjective": "Diferenciar resolução recursiva e iterativa, aplicando à hierarquia DNS.",
                                  "commonMistakes": [
                                    "Confundir fluxos: recursiva é server-driven, iterativa client-driven.",
                                    "Subestimar latência na iterativa."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o comando 'dig google.com @8.8.8.8 +trace' no terminal, observe o processo recursivo completo: root servers indicam TLD .com, que aponta para authoritative de google.com, retornando IPs como 142.250.190.14. Analise o tempo de resposta e TTL dos registros.",
                              "finalVerifications": [
                                "Desenhe e explique a hierarquia DNS com exemplos de servidores.",
                                "Descreva passo a passo uma resolução recursiva para www.exemplo.com.br.",
                                "Execute e interprete saída de dig para resolução iterativa.",
                                "Explique diferenças entre recursiva e iterativa com prós/contras.",
                                "Discuta impacto de falha DNS (ex: DDoS em root servers).",
                                "Identifique registros DNS comuns (A, CNAME, NS)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da hierarquia (root, TLD, authoritative).",
                                "Completude no fluxo de resolução recursiva e iterativa.",
                                "Uso correto de terminologia técnica (stub resolver, TTL, cache).",
                                "Capacidade de diagramas claros e exemplos práticos.",
                                "Compreensão da importância escalável do DNS.",
                                "Identificação de erros comuns e soluções."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Vulnerabilidades como DNS spoofing e DNSSEC.",
                                "História da Computação: Evolução desde hosts.txt para DNS em 1983 (RFC 1034/1035).",
                                "Matemática: Árvores hierárquicas e grafos na estrutura DNS.",
                                "Linguagens: Parsing de nomes de domínio como expressões regulares."
                              ],
                              "realWorldApplication": "Todo acesso web (navegação, apps, emails) inicia com DNS para traduzir domínios em IPs; administradores de rede configuram DNS para sites empresariais, e cibersegurança monitora abusos como phishing via DNS hijacking."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Compreender o protocolo DHCP",
                            "description": "Descrever o Dynamic Host Configuration Protocol (DHCP), seus quatro passos principais (Discover, Offer, Request, Acknowledgment - DORA), o papel do servidor e cliente DHCP, e como ele atribui dinamicamente endereços IP, máscaras de sub-rede e outros parâmetros de configuração de rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos fundamentais do DHCP",
                                  "subSteps": [
                                    "Ler a definição oficial do Dynamic Host Configuration Protocol (DHCP) conforme RFC 2131.",
                                    "Identificar o problema resolvido: configuração manual de endereços IP em redes grandes.",
                                    "Listar os principais componentes: cliente DHCP, servidor DHCP e agente de relay (opcional).",
                                    "Comparar DHCP com configuração estática de IP, destacando vantagens como automação e escalabilidade.",
                                    "Explicar o escopo de lease (tempo de concessão do IP)."
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras explicando o que é DHCP e suas vantagens.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 2131 (disponível online)",
                                    "Vídeo introdutório sobre DHCP no YouTube (ex: canal NetworkChuck)"
                                  ],
                                  "tips": "Use analogia: DHCP é como um 'balcão de check-in' em um hotel que atribui quartos automaticamente.",
                                  "learningObjective": "Compreender o propósito, componentes e vantagens do protocolo DHCP.",
                                  "commonMistakes": [
                                    "Confundir DHCP com DNS (DHCP é para IP, DNS para nomes)",
                                    "Ignorar o papel do relay agent em redes segmentadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detalhar o processo DORA (Discover, Offer, Request, Acknowledgment)",
                                  "subSteps": [
                                    "Descrever o passo Discover: Cliente envia broadcast UDP porta 67 para descobrir servidores.",
                                    "Explicar Offer: Servidor responde com oferta de IP via broadcast UDP porta 68.",
                                    "Detalhar Request: Cliente envia broadcast solicitando o IP oferecido.",
                                    "Finalizar com Acknowledgment: Servidor confirma com detalhes de configuração via broadcast.",
                                    "Diagrama o fluxo DORA com setas e timers (ex: uso de ferramenta como draw.io)."
                                  ],
                                  "verification": "Desenhar e rotular o diagrama DORA, identificando portas UDP e tipos de mensagem.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (draw.io ou papel e caneta)",
                                    "Wireshark para captura simulada de pacotes DHCP"
                                  ],
                                  "tips": "Lembre-se: Todos os passos iniciais usam broadcast (255.255.255.255) para alcançar servidores.",
                                  "learningObjective": "Dominar a sequência exata e o mecanismo de comunicação no processo DORA.",
                                  "commonMistakes": [
                                    "Invertir a ordem dos passos",
                                    "Esquecer que Offer e Ack podem vir de múltiplos servidores (seleção pelo cliente)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender os papéis do servidor e cliente DHCP",
                                  "subSteps": [
                                    "Descrever funções do servidor: Manter pool de IPs, responder requests, renovar leases.",
                                    "Explicar ações do cliente: Iniciar Discover ao boot, renovar lease antes do fim (T1/T2 timers).",
                                    "Analisar o papel do relay agent: Forward mensagens unicast entre sub-redes.",
                                    "Simular cenários: Cliente sem servidor (fallback para APIPA 169.254.x.x).",
                                    "Estudar opções DHCP (ex: opção 3 para gateway padrão)."
                                  ],
                                  "verification": "Simular verbalmente um cenário onde um cliente obtém IP de um servidor remoto via relay.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Microsoft ou Cisco sobre DHCP server",
                                    "Simulador de rede como Packet Tracer (gratuito)"
                                  ],
                                  "tips": "Pense no servidor como 'bibliotecário' que empresta livros (IPs) por tempo limitado.",
                                  "learningObjective": "Diferenciar responsabilidades e interações entre cliente, servidor e relay.",
                                  "commonMistakes": [
                                    "Achar que cliente escolhe IP aleatório (não, servidor oferece)",
                                    "Ignorar renovação automática de lease"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar parâmetros atribuídos e configuração prática",
                                  "subSteps": [
                                    "Listar parâmetros comuns: IP, máscara de sub-rede, gateway padrão, DNS servers.",
                                    "Explicar opções DHCP (ex: 1=mask, 3=router, 6=DNS).",
                                    "Configurar um servidor DHCP simples (ex: em Linux com isc-dhcp-server).",
                                    "Capturar tráfego DHCP com Wireshark e analisar campos.",
                                    "Testar renovação de lease forçando expiração."
                                  ],
                                  "verification": "Executar captura Wireshark de um processo DHCP real e anotar 5 parâmetros recebidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Wireshark (gratuito)",
                                    "Máquina virtual com Ubuntu para servidor DHCP",
                                    "Roteador doméstico"
                                  ],
                                  "tips": "Ative promiscuous mode no Wireshark para capturar broadcasts.",
                                  "learningObjective": "Identificar e configurar parâmetros de rede via DHCP.",
                                  "commonMistakes": [
                                    "Confundir broadcast com unicast após Ack",
                                    "Não considerar conflitos de IP no pool"
                                  ]
                                }
                              ],
                              "practicalExample": "Conecte um laptop novo a uma rede Wi-Fi doméstica: o roteador (servidor DHCP) executa DORA automaticamente, atribuindo IP 192.168.1.100, máscara 255.255.255.0, gateway 192.168.1.1 e DNS 8.8.8.8. Capture com Wireshark para ver o processo em ação.",
                              "finalVerifications": [
                                "Listar corretamente os 4 passos DORA na ordem exata.",
                                "Explicar o uso de broadcasts nos passos iniciais do DORA.",
                                "Identificar pelo menos 5 parâmetros comuns atribuídos pelo DHCP.",
                                "Descrever o processo de renovação de lease (T1 e T2).",
                                "Simular um diagrama DORA sem erros.",
                                "Diferenciar DHCP de configuração estática com exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da sequência DORA (100% dos passos corretos).",
                                "Compreensão de broadcasts vs unicast no protocolo.",
                                "Capacidade de listar e explicar pelo menos 4 parâmetros DHCP.",
                                "Qualidade do diagrama ou simulação prática.",
                                "Identificação correta de erros comuns como conflitos de IP.",
                                "Explicação clara dos papéis de cliente e servidor."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de máscaras de sub-rede e pools de IP (aritmética binária).",
                                "Segurança da Informação: Vulnerabilidades como DHCP starvation e spoofing.",
                                "Programação: Implementar cliente/servidor DHCP usando bibliotecas como Scapy em Python.",
                                "Física: Propagação de sinais broadcast em redes Ethernet sem fio."
                              ],
                              "realWorldApplication": "Em redes corporativas e domésticas, o DHCP automatiza a alocação de IPs para centenas de dispositivos, evitando conflitos e simplificando gerenciamento; usado em data centers para VMs dinâmicas e em ISPs para clientes residenciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Diferenciar protocolos de suporte de outros na camada",
                            "description": "Comparar protocolos de suporte como DNS e DHCP com protocolos de aplicação, destacando que os de suporte são fundamentais para o funcionamento das aplicações sem implementarem serviços de usuário final diretamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura da camada de aplicação no modelo TCP/IP",
                                  "subSteps": [
                                    "Estude o papel geral da camada de aplicação no modelo TCP/IP.",
                                    "Identifique que ela inclui protocolos que suportam aplicações e aqueles que são aplicações em si.",
                                    "Leia definições oficiais de 'protocolos de suporte' versus 'protocolos de aplicação final'.",
                                    "Anote as funções principais da camada: fornecer serviços de rede para aplicativos.",
                                    "Visualize diagramas do modelo TCP/IP destacando a camada 7."
                                  ],
                                  "verification": "Crie um diagrama simples da camada de aplicação e liste 2 funções principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama do modelo TCP/IP (impresso ou online), notas de aula sobre redes.",
                                  "tips": "Use cores diferentes para diferenciar suporte de aplicação nos diagramas.",
                                  "learningObjective": "Compreender o escopo da camada de aplicação e suas subcategorias de protocolos.",
                                  "commonMistakes": "Confundir camada de aplicação com camada de transporte (TCP/UDP)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar protocolos de suporte (ex: DNS e DHCP)",
                                  "subSteps": [
                                    "Descreva o DNS: resolve nomes de domínio em IPs (suporte para localização).",
                                    "Explique o DHCP: atribui IPs dinamicamente (suporte para configuração de rede).",
                                    "Liste características: operam em background, essenciais para aplicações funcionarem.",
                                    "Pesquise portas padrão (DNS:53 UDP/TCP, DHCP:67/68 UDP).",
                                    "Simule um fluxo: como um PC usa DHCP ao ligar."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras sobre DNS e DHCP, destacando seu papel de suporte.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentação RFC de DNS (RFC 1035) e DHCP (RFC 2131), Wireshark para captura de pacotes.",
                                  "tips": "Capture tráfego real com Wireshark para ver DNS/DHCP em ação.",
                                  "learningObjective": "Identificar e descrever funções de protocolos de suporte na camada de aplicação.",
                                  "commonMistakes": "Achar que DNS/DHCP são protocolos de camada de rede (eles são aplicação)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar protocolos de aplicação final (ex: HTTP, FTP, SMTP)",
                                  "subSteps": [
                                    "Descreva HTTP: transferência de páginas web (serviço direto ao usuário).",
                                    "Explique FTP: transferência de arquivos (aplicação específica).",
                                    "Liste SMTP: envio de emails (serviço de usuário final).",
                                    "Note portas (HTTP:80, FTP:20/21, SMTP:25).",
                                    "Compare fluxos: usuário interage diretamente com esses protocolos."
                                  ],
                                  "verification": "Liste 3 protocolos de aplicação e explique um serviço de usuário para cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Lista de portas IANA, exemplos de comandos curl/telnet para HTTP/FTP.",
                                  "tips": "Use curl http://example.com para testar HTTP e observar resposta.",
                                  "learningObjective": "Reconhecer protocolos que implementam serviços diretos ao usuário final.",
                                  "commonMistakes": "Confundir protocolos como HTTP com suporte (HTTP depende de DNS, mas é aplicação)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e diferenciar protocolos de suporte dos de aplicação",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: função, dependência, interação usuário, exemplos.",
                                    "Destaque: suporte = fundamentais, não visíveis ao usuário; aplicação = serviços diretos.",
                                    "Discuta dependências: aplicações usam suporte (ex: HTTP precisa DNS).",
                                    "Analise cenários: sem DHCP, HTTP não conecta; sem DNS, FTP falha em resolução.",
                                    "Resuma diferenças chave em bullet points."
                                  ],
                                  "verification": "Preencha tabela comparativa com pelo menos 5 diferenças claras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou papel para tabela, exemplos de tráfego capturado.",
                                  "tips": "Use 'suporte = infraestrutura invisível' como mnemônico.",
                                  "learningObjective": "Diferenciar com precisão protocolos de suporte de outros na camada de aplicação.",
                                  "commonMistakes": "Ignorar que suporte é essencial mas não oferece serviço final."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa, o DHCP atribui IPs automaticamente aos computadores (suporte, invisível), permitindo que browsers usem HTTP para acessar sites (aplicação final). Sem DHCP/DNS, o HTTP falha, mas eles não são acessados diretamente pelo usuário.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças entre DNS/DHCP e HTTP/FTP.",
                                "Identificar corretamente 5 protocolos como suporte ou aplicação em uma lista mista.",
                                "Desenhar um fluxograma mostrando dependência de suporte para uma aplicação.",
                                "Simular falha de DNS e explicar impacto em SMTP.",
                                "Preencher tabela comparativa sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de suporte vs. aplicação (90% correto).",
                                "Uso correto de exemplos reais (DNS/DHCP vs. HTTP/SMTP).",
                                "Compreensão de dependências e papéis fundamentais.",
                                "Clareza na tabela ou diagrama comparativo.",
                                "Capacidade de aplicar em cenários práticos sem confusões de camadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de sub-redes e endereços IP em DHCP.",
                                "Segurança da Informação: Vulnerabilidades em DNS (DNS spoofing).",
                                "Programação: Implementar cliente DNS em Python (socket library).",
                                "Administração: Configuração de servidores DHCP em Linux."
                              ],
                              "realWorldApplication": "Administradores de rede usam essa distinção para troubleshooting: verificar DHCP/DNS antes de debugar falhas em apps como webmail (SMTP/HTTP), otimizando configuração de data centers e evitando downtime em empresas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1",
                              "10.1.2.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Protocolos de Serviços na Camada de Aplicação",
                        "description": "Protocolos que implementam serviços específicos de aplicação para usuários finais, como transferência de arquivos, e-mail e navegação web, operando diretamente sobre TCP ou UDP.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Analisar o protocolo HTTP",
                            "description": "Explicar o HyperText Transfer Protocol (HTTP), suas versões (1.1 e 2), métodos principais (GET, POST, PUT), códigos de status (200 OK, 404 Not Found), cabeçalhos e o modelo cliente-servidor stateless.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do HTTP e o Modelo Cliente-Servidor Stateless",
                                  "subSteps": [
                                    "Leia a definição oficial do HTTP como protocolo de aplicação para transferência de hipertexto.",
                                    "Desenhe um diagrama simples do modelo cliente-servidor, mostrando o navegador (cliente) enviando requisição ao servidor web.",
                                    "Explique o conceito de stateless: cada requisição é independente, sem memória de requisições anteriores.",
                                    "Identifique exemplos de sessões stateless na web cotidiana, como acessar páginas sem login.",
                                    "Pesquise a evolução histórica do HTTP desde sua criação por Tim Berners-Lee."
                                  ],
                                  "verification": "Desenhe e explique o diagrama cliente-servidor em um papel ou ferramenta digital, confirmando compreensão do stateless.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 2616 (HTTP/1.1)",
                                    "Ferramenta de desenho como Draw.io ou papel e caneta",
                                    "Vídeo introdutório sobre HTTP no YouTube"
                                  ],
                                  "tips": "Use analogias como 'cada ligação telefônica é independente' para entender stateless.",
                                  "learningObjective": "Compreender a base arquitetural do HTTP e seu comportamento stateless.",
                                  "commonMistakes": [
                                    "Confundir stateless com sessionless (cookies podem simular estado)",
                                    "Ignorar que HTTP é texto-based e legível por humanos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os Métodos HTTP Principais (GET, POST, PUT)",
                                  "subSteps": [
                                    "Liste e defina GET (recuperar dados, idempotente, cacheável).",
                                    "Descreva POST (enviar dados para criar/atualizar, não idempotente).",
                                    "Explique PUT (atualizar ou criar recurso específico, idempotente).",
                                    "Compare os métodos com exemplos: GET para buscar post, POST para submeter formulário, PUT para editar perfil.",
                                    "Pratique identificando métodos em URLs comuns (ex: ?param=value indica GET)."
                                  ],
                                  "verification": "Crie uma tabela comparativa dos métodos com exemplos e propriedades (idempotência, segurança).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre HTTP methods",
                                    "Postman ou Insomnia para simular requisições"
                                  ],
                                  "tips": "Lembre-se: GET para leitura, POST para criação, PUT para substituição completa.",
                                  "learningObjective": "Dominar os usos e diferenças dos métodos HTTP principais.",
                                  "commonMistakes": [
                                    "Usar POST para buscas simples (use GET)",
                                    "Confundir PUT com PATCH (PUT substitui todo recurso)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Códigos de Status e Cabeçalhos HTTP",
                                  "subSteps": [
                                    "Memorize famílias de status: 2xx (sucesso), 4xx (erro cliente), 5xx (erro servidor).",
                                    "Estude exemplos chave: 200 OK, 404 Not Found, 500 Internal Server Error.",
                                    "Liste cabeçalhos comuns: Content-Type, Authorization, User-Agent, Cache-Control.",
                                    "Examine uma requisição real: abra DevTools no browser e inspecione Network tab.",
                                    "Explique como cabeçalhos afetam o comportamento (ex: Cache-Control para caching)."
                                  ],
                                  "verification": "Capture uma requisição no browser DevTools e anote status + 3 cabeçalhos com explicações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Browser com DevTools (Chrome/Firefox)",
                                    "Site de teste como httpbin.org",
                                    "Lista de códigos HTTP no Wikipedia"
                                  ],
                                  "tips": "Primeiro dígito da família de status dá a ideia geral; foque nos mais comuns primeiro.",
                                  "learningObjective": "Interpretar respostas HTTP através de status e cabeçalhos.",
                                  "commonMistakes": [
                                    "Confundir 404 (não encontrado) com 500 (erro servidor)",
                                    "Ignorar cabeçalhos de segurança como CORS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Versões HTTP/1.1 e HTTP/2",
                                  "subSteps": [
                                    "Descreva HTTP/1.1: texto puro, uma requisição por conexão, head-of-line blocking.",
                                    "Explique HTTP/2: binário, multiplexação (múltiplas requisições na mesma conexão), compressão de cabeçalhos.",
                                    "Identifique diferenças chave: performance, suporte a push server.",
                                    "Teste em DevTools: force HTTP/1.1 vs HTTP/2 em sites como google.com.",
                                    "Discuta quando usar cada: HTTP/2 para apps modernas, fallback para 1.1."
                                  ],
                                  "verification": "Crie um quadro comparativo com prós/contras e teste protocol versão em DevTools.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "DevTools Protocol tab",
                                    "RFC 7540 (HTTP/2)",
                                    "Ferramenta como https://http2.pro/"
                                  ],
                                  "tips": "HTTP/2 acelera sites; verifique o protocolo na aba Network do DevTools.",
                                  "learningObjective": "Diferenciar evoluções do protocolo e impactos na performance.",
                                  "commonMistakes": [
                                    "Achar que HTTP/2 é sempre melhor sem suporte",
                                    "Confundir HTTP/2 com HTTP/3 (QUIC)"
                                  ]
                                }
                              ],
                              "practicalExample": "Abra o DevTools no Chrome (F12), vá para Network tab, recarregue uma página como example.com, filtre por uma requisição GET, analise método, status (ex: 200), cabeçalhos (Content-Type: text/html) e confirme stateless simulando múltiplas requisições sem estado persistente.",
                              "finalVerifications": [
                                "Explicar corretamente o modelo cliente-servidor stateless com diagrama.",
                                "Listar e diferenciar GET, POST, PUT com exemplos reais.",
                                "Interpretar 5 códigos de status comuns e 4 cabeçalhos.",
                                "Comparar HTTP/1.1 vs HTTP/2 identificando pelo menos 3 diferenças.",
                                "Analisar uma requisição real do browser DevTools.",
                                "Discutir limitações do stateless e soluções como cookies."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas sem erros comuns).",
                                "Profundidade nos substeps (todos detalhados e acionáveis).",
                                "Capacidade de análise prática (exemplos de DevTools corretos).",
                                "Compreensão comparativa (HTTP/1.1 vs 2 com impactos).",
                                "Criatividade em verificações e conexões reais.",
                                "Clareza na comunicação (diagramas e tabelas legíveis)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Integração com HTTPS (TLS) para criptografia.",
                                "Desenvolvimento Web: Uso em APIs RESTful com JavaScript (fetch/Axios).",
                                "Matemática: Modelos probabilísticos em caching via cabeçalhos.",
                                "Linguagens: Parsing de texto HTTP em Python (requests library).",
                                "Negócios: Otimização de performance web para UX em e-commerce."
                              ],
                              "realWorldApplication": "No dia a dia, HTTP impulsiona navegação web, apps mobile (APIs como login no Instagram via POST), debugging de sites lentos (analisando status 429 Too Many Requests) e desenvolvimento de backends escaláveis com HTTP/2 para reduzir latência em serviços como Netflix."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Descrever o protocolo SMTP e e-mail",
                            "description": "Detalhar o Simple Mail Transfer Protocol (SMTP) para envio de e-mails, incluindo comandos (HELO, MAIL FROM, RCPT TO, DATA), o papel de servidores MTA e MDA, e integração com POP3/IMAP para recebimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Arquitetura do Sistema de E-mail e o Papel do SMTP",
                                  "subSteps": [
                                    "Pesquise e defina os termos MTA (Mail Transfer Agent), MDA (Mail Delivery Agent) e MUA (Mail User Agent).",
                                    "Desenhe um diagrama simples mostrando o fluxo de um e-mail de remetente para destinatário, destacando onde o SMTP atua.",
                                    "Explique como o SMTP opera na camada de aplicação do modelo TCP/IP.",
                                    "Identifique as portas padrão usadas pelo SMTP (porta 25) e por que ela é importante.",
                                    "Compare brevemente SMTP com outros protocolos de e-mail como POP3 e IMAP."
                                  ],
                                  "verification": "Crie um diagrama rotulado da arquitetura e recite as definições sem consultar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet para pesquisa (RFC 5321), papel e caneta para diagrama, Wireshark opcional"
                                  ],
                                  "tips": "Use analogias como 'correio postal' para visualizar MTA como transportadora e MDA como caixa de correio.",
                                  "learningObjective": "Compreender os componentes fundamentais e o contexto do SMTP no ecossistema de e-mail.",
                                  "commonMistakes": [
                                    "Confundir MTA com MDA; ignorar o papel do TCP/IP; assumir que SMTP lida com recebimento de e-mails."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar os Comandos de Inicialização e Endereçamento no SMTP",
                                  "subSteps": [
                                    "Estude o comando HELO/EHLO: explique sua função, sintaxe e respostas esperadas do servidor.",
                                    "Aprenda MAIL FROM: sintaxe, validação de remetente e tratamento de erros como 550.",
                                    "Pratique RCPT TO: múltiplos destinatários, distinção entre TO, CC e BCC no protocolo.",
                                    "Simule uma sessão interativa usando telnet para conectar a um servidor SMTP de teste.",
                                    "Registre respostas de erro comuns como 450 (temporário) vs 550 (permanente)."
                                  ],
                                  "verification": "Execute uma sessão telnet bem-sucedida até o comando RCPT TO e capture a saída.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Telnet ou netcat, servidor SMTP de teste como smtp.ethereal.email, editor de texto para logs"
                                  ],
                                  "tips": "Sempre termine comandos com CRLF (\\r\\n); teste em servidores de sandbox para evitar spam.",
                                  "learningObjective": "Executar e compreender os comandos iniciais para estabelecer uma conversa SMTP válida.",
                                  "commonMistakes": [
                                    "Esquecer CRLF nos comandos; usar EHLO sem suporte; não lidar com códigos de resposta SMTP (2xx, 4xx, 5xx)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Enviar o Corpo da Mensagem com o Comando DATA",
                                  "subSteps": [
                                    "Analise a sintaxe do comando DATA: início após RCPT TO, fim com linha vazia após ponto (.).",
                                    "Estruture uma mensagem e-mail completa: headers (From, To, Subject) e body (texto ou MIME).",
                                    "Implemente escape de caracteres especiais, como linhas começando com ponto.",
                                    "Teste o envio completo de uma mensagem simples via telnet.",
                                    "Verifique logs do servidor ou use ferramentas como swaks para validar."
                                  ],
                                  "verification": "Envie uma mensagem de teste que chegue ao destinatário e confirme recebimento.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Telnet/netcat, ferramenta swaks (opcional), conta de e-mail de teste"
                                  ],
                                  "tips": "Copie exemplos de RFC 5321; use MIME para anexos em testes avançados.",
                                  "learningObjective": "Montar e transmitir uma mensagem e-mail completa via SMTP.",
                                  "commonMistakes": [
                                    "Não finalizar DATA com . sozinho; headers malformados; ignorar limite de tamanho de mensagem."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar SMTP com Protocolos de Recebimento e Verificações Finais",
                                  "subSteps": [
                                    "Descreva como POP3 (porta 110/995) e IMAP (porta 143/993) recuperam e-mails entregues pelo MDA.",
                                    "Compare POP3 (download e delete) vs IMAP (sincronização em múltiplos dispositivos).",
                                    "Trace o fluxo completo: MUA -> MTA (SMTP) -> MDA -> MUA (POP3/IMAP).",
                                    "Discuta extensões modernas como STARTTLS para segurança no SMTP.",
                                    "Crie um fluxograma unificado do ciclo de vida de um e-mail."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o fluxo completo e diferenças POP3/IMAP.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "RFC 5321, RFC 1939 (POP3), RFC 3501 (IMAP), ferramenta de diagrama como draw.io"
                                  ],
                                  "tips": "Lembre que SMTP é só para envio; recebedores usam MX records no DNS.",
                                  "learningObjective": "Conectar SMTP ao ciclo completo de e-mail, incluindo recebimento.",
                                  "commonMistakes": [
                                    "Achar que SMTP baixa e-mails; confundir portas SSL/TLS; ignorar DNS MX."
                                  ]
                                }
                              ],
                              "practicalExample": "Use telnet para conectar a smtp.ethereal.email:25, execute HELO meuhost, MAIL FROM:<seuemail@teste.com>, RCPT TO:<destino@teste.com>, DATA, adicione headers e body, finalize com ., e verifique recebimento via webmail.",
                              "finalVerifications": [
                                "Liste e explique os 4 comandos principais do SMTP (HELO, MAIL FROM, RCPT TO, DATA).",
                                "Desenhe o fluxo MTA -> MDA e integre com POP3/IMAP.",
                                "Simule uma sessão SMTP sem erros via telnet.",
                                "Identifique 3 códigos de resposta SMTP e seus significados.",
                                "Explique por que SMTP usa TCP porta 25 e como DNS MX é resolvido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de comandos e arquitetura (sem erros factuais).",
                                "Completude: cobre todos elementos (MTA/MDA, comandos, integração POP3/IMAP).",
                                "Profundidade: inclui exemplos práticos e tratamento de erros.",
                                "Clareza na explicação de fluxos e diagramas.",
                                "Demonstração prática via simulação telnet.",
                                "Conexão com conceitos TCP/IP e DNS."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Integração com STARTTLS/DKIM/SPF para autenticação.",
                                "Programação: Implementação de cliente SMTP em Python (smtplib).",
                                "Redes: Resolução DNS MX e roteamento TCP/IP.",
                                "Matemática/Algoritmos: Parsing de protocolos e codificação MIME base64."
                              ],
                              "realWorldApplication": "Configurar servidores de e-mail corporativos, desenvolver apps de envio automatizado (newsletters, alertas), depurar falhas de entrega em helpdesks de TI, ou entender spams/phishing via análise de cabeçalhos SMTP."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Entender o protocolo FTP",
                            "description": "Explicar o File Transfer Protocol (FTP), modos ativo e passivo, comandos (USER, PASS, RETR, STOR), canais de controle e dados, e sua operação sobre TCP para transferência confiável de arquivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceitos básicos do protocolo FTP",
                                  "subSteps": [
                                    "Pesquise a definição de FTP como protocolo da camada de aplicação para transferência de arquivos.",
                                    "Identifique o propósito principal: transferência confiável de arquivos entre cliente e servidor.",
                                    "Estude a estrutura cliente-servidor do FTP.",
                                    "Analise o diagrama de funcionamento básico do FTP.",
                                    "Compare FTP com outros protocolos de transferência como HTTP."
                                  ],
                                  "verification": "Resuma em 3 frases o que é FTP e seu papel no modelo TCP/IP.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 959 do FTP",
                                    "Vídeo introdutório sobre FTP no YouTube",
                                    "Diagrama TCP/IP"
                                  ],
                                  "tips": "Use analogias como 'FTP é como enviar uma encomenda por correio registrado'.",
                                  "learningObjective": "Compreender o propósito e a arquitetura básica do FTP.",
                                  "commonMistakes": [
                                    "Confundir FTP com HTTP",
                                    "Ignorar que FTP usa TCP para confiabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Canais de controle e dados no FTP",
                                  "subSteps": [
                                    "Explique o canal de controle: porta 21 TCP para comandos e respostas.",
                                    "Descreva o canal de dados: portas dinâmicas para transferência de arquivos.",
                                    "Diferencie os dois canais em termos de função e portas usadas.",
                                    "Desenhe um diagrama mostrando cliente-servidor com ambos os canais.",
                                    "Simule uma sessão básica identificando quando cada canal é usado."
                                  ],
                                  "verification": "Crie um fluxograma simples dos canais de controle e dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark para capturar tráfego FTP",
                                    "Diagramas de canais FTP online"
                                  ],
                                  "tips": "Lembre-se: controle é 'conversa', dados é 'envio de arquivos'.",
                                  "learningObjective": "Diferenciar e ilustrar os canais de controle e dados.",
                                  "commonMistakes": [
                                    "Confundir portas: controle sempre 21, dados variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modos ativo e passivo de conexão",
                                  "subSteps": [
                                    "Estude o modo ativo: servidor inicia conexão de dados para cliente (porta >1023).",
                                    "Analise o modo passivo: cliente inicia conexão de dados para servidor (porta EPSV).",
                                    "Compare vantagens/desvantagens: firewalls, NAT (passivo mais comum hoje).",
                                    "Identifique comandos: PORT (ativo), PASV (passivo).",
                                    "Simule diferenças com diagramas de rede."
                                  ],
                                  "verification": "Explique por que o modo passivo é preferido em redes modernas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Artigos sobre FTP active vs passive"
                                  ],
                                  "tips": "Pense em firewalls: ativo pode ser bloqueado por eles.",
                                  "learningObjective": "Dominar as diferenças entre modos ativo e passivo.",
                                  "commonMistakes": [
                                    "Invertir quem inicia a conexão de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comandos principais do FTP",
                                  "subSteps": [
                                    "Liste e explique USER e PASS para autenticação.",
                                    "Descreva RETR (download) e STOR (upload) para transferência.",
                                    "Estude outros: LIST (diretórios), CWD (mudar diretório), QUIT (sair).",
                                    "Pratique comandos em um cliente FTP ou terminal.",
                                    "Registre respostas típicas do servidor para cada comando."
                                  ],
                                  "verification": "Execute uma sequência de comandos em um servidor FTP teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cliente FTP como FileZilla ou linha de comando ftp",
                                    "Servidor FTP local (ex: vsftpd)"
                                  ],
                                  "tips": "Sempre teste em ambiente controlado para evitar erros de segurança.",
                                  "learningObjective": "Conhecer e aplicar comandos essenciais do FTP.",
                                  "commonMistakes": [
                                    "Esquecer autenticação antes de comandos de transferência"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Operação do FTP sobre TCP e transferência confiável",
                                  "subSteps": [
                                    "Explique como FTP usa TCP para garantia de entrega e ordem dos pacotes.",
                                    "Analise ACKs e retransmissões nos canais de controle e dados.",
                                    "Discuta limitações: FTP não é criptografado (use FTPS/SFTP).",
                                    "Capture tráfego com Wireshark e identifique pacotes TCP do FTP.",
                                    "Resuma o ciclo completo de uma transferência FTP."
                                  ],
                                  "verification": "Analise um capture Wireshark e identifique canais TCP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Servidor FTP para teste"
                                  ],
                                  "tips": "Foque em 'confiável' = TCP, não UDP como TFTP.",
                                  "learningObjective": "Entender a integração do FTP com TCP para confiabilidade.",
                                  "commonMistakes": [
                                    "Confundir com TFTP (UDP, não confiável)"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando FileZilla, conecte a um servidor FTP público (ex: demo.test.rebex.net), autentique com USER/PASS, liste arquivos (LIST), baixe um arquivo (RETR) no modo passivo, observando canais no Wireshark.",
                              "finalVerifications": [
                                "Explique a diferença entre canais de controle e dados com portas.",
                                "Descreva o handshake de um modo passivo.",
                                "Liste 4 comandos FTP e suas funções.",
                                "Justifique por que FTP usa TCP.",
                                "Simule uma sessão FTP completa verbalmente.",
                                "Identifique problemas comuns em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de modos ativo/passivo (80% correto).",
                                "Correta identificação de comandos e respostas.",
                                "Compreensão clara dos canais TCP e sua função.",
                                "Uso correto de terminologia técnica (ex: RFC 959).",
                                "Capacidade de diagramar fluxos de conexão.",
                                "Análise de captures Wireshark com pelo menos 3 observações."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Comparação com SFTP/FTPS para criptografia.",
                                "Matemática: Cálculo de portas dinâmicas e endereços IP em comandos PORT.",
                                "História da Computação: Evolução de protocolos de arquivo desde 1971.",
                                "Desenvolvimento de Software: Integração FTP em scripts Python (ftplib)."
                              ],
                              "realWorldApplication": "FTP é usado para upload de sites em hospedagens compartilhadas, sincronização de backups em servidores remotos e distribuição de software em repositórios acadêmicos/industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.4",
                            "name": "Comparar protocolos de serviços com suporte",
                            "description": "Diferenciar protocolos de serviços (HTTP, SMTP, FTP) dos de suporte (DNS, DHCP), enfatizando que os primeiros fornecem interfaces de aplicação ao usuário enquanto os segundos habilitam o acesso à rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar Protocolos de Serviços (HTTP, SMTP, FTP)",
                                  "subSteps": [
                                    "Pesquise a definição e função principal do HTTP (HyperText Transfer Protocol).",
                                    "Analise o SMTP (Simple Mail Transfer Protocol) e como ele envia e-mails.",
                                    "Examine o FTP (File Transfer Protocol) para transferência de arquivos.",
                                    "Identifique exemplos de uso diário: acessar sites (HTTP), enviar e-mails (SMTP), baixar arquivos (FTP).",
                                    "Registre que esses protocolos fornecem interfaces diretas de aplicação ao usuário final."
                                  ],
                                  "verification": "Crie uma lista com função, porta padrão e exemplo de uso para cada protocolo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 2616 (HTTP)",
                                    "RFC 5321 (SMTP)",
                                    "RFC 959 (FTP)",
                                    "Navegador web para demonstrações"
                                  ],
                                  "tips": "Use ferramentas como curl para testar comandos HTTP simples no terminal.",
                                  "learningObjective": "Compreender o papel dos protocolos de serviços em fornecer funcionalidades diretas ao usuário.",
                                  "commonMistakes": "Confundir HTTP com HTTPS (versão segura) ou ignorar que FTP é inseguro por padrão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Protocolos de Suporte (DNS, DHCP)",
                                  "subSteps": [
                                    "Pesquise o DNS (Domain Name System) e seu papel em resolver nomes de domínio para endereços IP.",
                                    "Analise o DHCP (Dynamic Host Configuration Protocol) para alocação dinâmica de IPs e configurações de rede.",
                                    "Identifique como eles operam 'nos bastidores' sem interação direta do usuário.",
                                    "Examine fluxos: DNS consulta hierárquica; DHCP handshake (Discover, Offer, Request, ACK).",
                                    "Registre que esses protocolos habilitam o acesso à rede, mas não entregam conteúdo de aplicação."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando o processo de resolução DNS e alocação DHCP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 1035 (DNS)",
                                    "RFC 2131 (DHCP)",
                                    "Ferramenta nslookup ou dig para testes DNS"
                                  ],
                                  "tips": "Teste DNS no seu computador com 'nslookup google.com' para ver resolução em ação.",
                                  "learningObjective": "Reconhecer como protocolos de suporte facilitam a conectividade de rede subjacente.",
                                  "commonMistakes": "Achar que DNS é só para sites (ele resolve qualquer serviço) ou confundir DHCP com IP estático."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Diferenciar os Protocolos",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para Nome, Função, Interação com Usuário, Camada de Suporte.",
                                    "Enfatize: Serviços (HTTP/SMTP/FTP) = interfaces de app; Suporte (DNS/DHCP) = habilitam acesso rede.",
                                    "Discuta dependências: ex., HTTP precisa de DNS para resolver hostnames.",
                                    "Analise cenários de falha: site não carrega por DNS falho vs. servidor HTTP down.",
                                    "Resuma diferenças chave em bullet points: visibilidade ao usuário, foco funcional."
                                  ],
                                  "verification": "Preencha e valide a tabela comparativa com pelo menos 5 diferenças claras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Wireshark para capturar tráfego de rede opcional"
                                  ],
                                  "tips": "Use Wireshark para filtrar pacotes DNS vs. HTTP e visualizar diferenças em tempo real.",
                                  "learningObjective": "Diferenciar precisamente protocolos de serviços de suporte com base em função e interação.",
                                  "commonMistakes": "Classificar DNS como serviço porque 'usuários digitam domínios' – ele é suporte invisível."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Conhecimento em Cenários Práticos",
                                  "subSteps": [
                                    "Simule um troubleshooting: 'Site não abre' – cheque DNS primeiro (suporte), depois HTTP (serviço).",
                                    "Crie um fluxograma de rede: usuário → DHCP (IP) → DNS (resolve) → HTTP (conteúdo).",
                                    "Debata: por que protocolos de suporte são pré-requisitos para serviços?",
                                    "Pesquise um caso real de falha (ex.: outage DNS global).",
                                    "Autoavalie: explique a diferença para um 'leigo' em 1 minuto."
                                  ],
                                  "verification": "Grave ou escreva uma explicação oral/escrita de 1-2 minutos comparando os protocolos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas de rede como ping, tracert",
                                    "Vídeos tutoriais sobre Wireshark"
                                  ],
                                  "tips": "Desative temporariamente DNS no roteador para sentir o impacto nos serviços.",
                                  "learningObjective": "Aplicar a comparação em contextos reais de rede e troubleshooting.",
                                  "commonMistakes": "Ignorar hierarquia TCP/IP: suporte na base, serviços no topo."
                                }
                              ],
                              "practicalExample": "Ao acessar 'www.exemplo.com' por HTTP: DNS (suporte) resolve o domínio para IP; DHCP (suporte) forneceu seu IP local; só então HTTP (serviço) entrega a página web. Sem suporte, o serviço falha.",
                              "finalVerifications": [
                                "Lista correta funções e portas de HTTP, SMTP, FTP, DNS, DHCP.",
                                "Tabela comparativa destaca 'interface usuário' vs. 'habilitar rede'.",
                                "Explica dependência: suporte precede serviços.",
                                "Identifica erro comum em troubleshooting de rede.",
                                "Desenha fluxograma preciso de interação entre protocolos.",
                                "Resume diferenças em 3 pontos chave sem hesitação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de cada protocolo (90% correto).",
                                "Clareza na distinção serviços vs. suporte (ênfase em função).",
                                "Uso de exemplos reais e diagramas visuais.",
                                "Profundidade em dependências e cenários de falha.",
                                "Capacidade de explicar oralmente sem erros conceituais.",
                                "Criatividade em aplicações práticas ou troubleshooting."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: HTTPS vs. DNSSEC para proteção.",
                                "Matemática: Endereços IP como notação decimal/binária em DHCP/DNS.",
                                "Programação: Implementar sockets para HTTP vs. queries DNS em Python.",
                                "História da Computação: Evolução de ARPANET para protocolos modernos."
                              ],
                              "realWorldApplication": "Administradores de rede usam essa distinção para diagnosticar falhas: priorizam DNS/DHCP em outages (80% dos casos), otimizam HTTP/SMTP para performance de apps, essencial em data centers e suporte técnico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1",
                              "10.1.2.3.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Camada de Transporte: TCP e UDP",
                    "description": "Introduz os protocolos TCP e UDP, incluindo controle de congestionamento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Protocolo UDP",
                        "description": "O User Datagram Protocol (UDP) é um protocolo de camada de transporte sem conexão, não orientado a conexão, que oferece comunicação de datagramas não confiável, sem garantia de entrega, ordem ou controle de fluxo, ideal para aplicações que priorizam baixa latência sobre confiabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar as principais características do UDP",
                            "description": "Diferenciar UDP de protocolos orientados a conexão, destacando ausência de handshake, ACKs, controle de fluxo e congestionamento, e sua natureza 'best-effort'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o contexto e definição básica do UDP",
                                  "subSteps": [
                                    "Pesquise a definição de UDP como User Datagram Protocol na camada de transporte do modelo TCP/IP.",
                                    "Identifique que UDP é um protocolo sem conexão (connectionless).",
                                    "Compare brevemente com TCP, notando que UDP não estabelece conexão antes de enviar dados.",
                                    "Leia sobre o cabeçalho UDP: source port, destination port, length e checksum.",
                                    "Anote as portas de origem e destino como principais campos visíveis."
                                  ],
                                  "verification": "Liste corretamente a definição de UDP e seus 4 campos de cabeçalho principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 768 do UDP",
                                    "Diagrama do modelo TCP/IP",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use diagramas visuais para memorizar o cabeçalho UDP, que é minimalista (apenas 8 bytes).",
                                  "learningObjective": "Compreender o papel fundamental do UDP na camada de transporte e sua estrutura simples.",
                                  "commonMistakes": [
                                    "Confundir UDP com TCP achando que ambos são sem conexão",
                                    "Ignorar o checksum como campo de verificação básica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar UDP de protocolos orientados a conexão como TCP",
                                  "subSteps": [
                                    "Estude o conceito de 'handshake' de três vias no TCP (SYN, SYN-ACK, ACK).",
                                    "Note que UDP envia datagramas imediatamente sem handshake.",
                                    "Compare ACKs: TCP usa confirmações, UDP não.",
                                    "Discuta controle de fluxo: TCP ajusta janela, UDP não implementa.",
                                    "Analise controle de congestionamento: TCP tem algoritmos como Tahoe/Reno, UDP envia sem restrições."
                                  ],
                                  "verification": "Crie uma tabela comparativa UDP vs TCP destacando 4 diferenças principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela comparativa TCP vs UDP (template online)",
                                    "Vídeo explicativo sobre handshake TCP",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Lembre-se: UDP é 'fire and forget' – envia e esquece, sem garantias.",
                                  "learningObjective": "Distinguir claramente as características de protocolos connectionless (UDP) vs connection-oriented (TCP).",
                                  "commonMistakes": [
                                    "Achar que UDP tem ACKs opcionais",
                                    "Confundir controle de fluxo com checksum"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a ausência de mecanismos de confiabilidade no UDP",
                                  "subSteps": [
                                    "Liste as ausências: sem handshake, sem ACKs, sem controle de fluxo, sem controle de congestionamento.",
                                    "Entenda implicações: perda de pacotes possível, duplicatas não detectadas, ordem não garantida.",
                                    "Simule envio de datagramas UDP: cada um é independente.",
                                    "Compare com envio de cartas sem número de rastreio ou confirmação de entrega.",
                                    "Registre cenários onde essas ausências são aceitáveis (ex: vídeo streaming)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que UDP não garante entrega de dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Exemplos de aplicações UDP",
                                    "Papel e caneta para analogias"
                                  ],
                                  "tips": "Use analogia postal: UDP é como jogar cartas pela janela – pode chegar ou não.",
                                  "learningObjective": "Identificar e explicar as principais omissões de confiabilidade no UDP.",
                                  "commonMistakes": [
                                    "Pensar que UDP ignora completamente erros (ele tem checksum básico)",
                                    "Subestimar impacto da falta de ordenação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender a natureza 'best-effort' do UDP e suas vantagens",
                                  "subSteps": [
                                    "Defina 'best-effort': faz o melhor possível sem garantias de entrega ou ordem.",
                                    "Discuta vantagens: baixa latência, overhead mínimo, alta velocidade.",
                                    "Identifique usos comuns: DNS, DHCP, VoIP, streaming, jogos multiplayer.",
                                    "Calcule overhead: UDP ~8 bytes vs TCP ~20+ bytes.",
                                    "Conclua quando escolher UDP sobre TCP."
                                  ],
                                  "verification": "Descreva 3 aplicações reais do UDP e justifique pela natureza best-effort.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de portas IANA para serviços UDP",
                                    "Exemplos de tráfego Wireshark UDP",
                                    "Vídeos de aplicações como DNS query"
                                  ],
                                  "tips": "Teste um comando 'dig' para DNS (UDP por padrão) para ver em ação.",
                                  "learningObjective": "Explicar o conceito best-effort e suas implicações práticas no UDP.",
                                  "commonMistakes": [
                                    "Confundir best-effort com 'inútil'",
                                    "Ignorar que aplicações podem adicionar confiabilidade sobre UDP"
                                  ]
                                }
                              ],
                              "practicalExample": "Use Wireshark para capturar tráfego DNS (UDP porta 53): observe datagramas enviados sem ACKs ou handshake, confirmando best-effort ao ver pacotes perdidos em rede instável simulada.",
                              "finalVerifications": [
                                "Liste corretamente as 4 principais ausências do UDP (handshake, ACKs, controle de fluxo, congestionamento).",
                                "Diferencie UDP de TCP em uma tabela com pelo menos 5 colunas.",
                                "Explique 'best-effort' com um exemplo de aplicação real.",
                                "Identifique o cabeçalho UDP e seus campos.",
                                "Justifique por que UDP é usado em streaming de vídeo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação das características principais (sem confundir com TCP).",
                                "Profundidade na explicação de ausências e implicações.",
                                "Uso correto de terminologia técnica (connectionless, best-effort, datagram).",
                                "Capacidade de fornecer exemplos práticos e analogias.",
                                "Clareza na tabela comparativa e verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade de perda de pacotes e modelagem estatística de redes.",
                                "Física: Transmissão de sinais digitais e latência em meios físicos.",
                                "Inglês: Leitura e resumo de RFCs técnicas como RFC 768.",
                                "Desenvolvimento de Software: Implementação de sockets UDP em Python/Java."
                              ],
                              "realWorldApplication": "Em jogos online multiplayer como Fortnite, UDP é usado para atualizações de posição em tempo real, priorizando baixa latência sobre confiabilidade, pois pacotes perdidos são substituídos pelos próximos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Descrever o formato do cabeçalho UDP",
                            "description": "Explicar os campos do cabeçalho UDP: porta de origem (16 bits), porta de destino (16 bits), comprimento (16 bits) e checksum (16 bits), incluindo seu propósito e tamanho total de 8 bytes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral e o tamanho do cabeçalho UDP",
                                  "subSteps": [
                                    "Acesse a RFC 768 (padrão oficial do UDP) e leia a seção sobre o cabeçalho.",
                                    "Identifique que o cabeçalho UDP é fixo e possui exatamente 8 bytes (64 bits).",
                                    "Liste os quatro campos principais: porta de origem, porta de destino, comprimento e checksum.",
                                    "Desenhe um diagrama linear representando os 8 bytes divididos em campos de 16 bits cada.",
                                    "Explique o propósito geral: fornecer informações mínimas para entrega de datagramas sem conexão."
                                  ],
                                  "verification": "Desenhar e rotular corretamente um diagrama do cabeçalho com tamanhos exatos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 768 (disponível online)",
                                    "Papel e caneta ou ferramenta de desenho digital"
                                  ],
                                  "tips": "Visualize o cabeçalho como uma linha reta de 64 bits para facilitar a memorização.",
                                  "learningObjective": "Entender a composição fixa e o tamanho total do cabeçalho UDP.",
                                  "commonMistakes": [
                                    "Confundir o tamanho com o do TCP (20 bytes mínimo)",
                                    "Esquecer que é fixo e sem opções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os campos de porta de origem e destino",
                                  "subSteps": [
                                    "Defina porta de origem: campo de 16 bits que identifica o processo/aplicação remetente no host origem.",
                                    "Defina porta de destino: campo de 16 bits que indica o processo/aplicação destinatária no host destino.",
                                    "Estude exemplos de portas comuns: 53 (DNS), 123 (NTP), 67/68 (DHCP).",
                                    "Explique como as portas permitem multiplexação/demultiplexação na camada de transporte.",
                                    "Registre em um quadro comparativo: tamanho, posição (bytes 0-1 origem, 2-3 destino) e propósito."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o papel das portas com exemplos reais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de portas IANA (online)",
                                    "Quadro ou planilha para comparação"
                                  ],
                                  "tips": "Lembre-se: portas efêmeras são atribuídas dinamicamente acima de 1024.",
                                  "learningObjective": "Dominar o funcionamento e posicionamento das portas no cabeçalho.",
                                  "commonMistakes": [
                                    "Invertir origem e destino",
                                    "Confundir portas UDP com endereços IP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o campo de comprimento do datagrama",
                                  "subSteps": [
                                    "Identifique o campo de comprimento: 16 bits nos bytes 4-5, indicando o tamanho total (header + dados) em bytes.",
                                    "Note o valor mínimo: 8 bytes (header sem dados).",
                                    "Calcule exemplos: header + 100 bytes de dados = 108 bytes.",
                                    "Explique a importância: permite ao receptor saber quantos bytes processar e descartar padding.",
                                    "Compare com TCP (onde comprimento é implícito pelo MSS)."
                                  ],
                                  "verification": "Calcular corretamente o comprimento para 3 cenários diferentes de dados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou simulador online de pacotes UDP",
                                    "Exemplos de datagramas"
                                  ],
                                  "tips": "Sempre inclua o header nos cálculos para evitar subestimação.",
                                  "learningObjective": "Compreender como o comprimento facilita o processamento de datagramas.",
                                  "commonMistakes": [
                                    "Excluir o header do cálculo",
                                    "Confundir com MTU da camada de enlace"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o campo de checksum e síntese final",
                                  "subSteps": [
                                    "Defina checksum: 16 bits nos bytes 6-7, calculado sobre header, dados e pseudo-header IP (opcional no IPv4, obrigatório no IPv6).",
                                    "Entenda o propósito: detectar erros de transmissão (não garante entrega).",
                                    "Aprenda o algoritmo básico: soma de 16 bits com carry-over (one's complement).",
                                    "Sintetize o cabeçalho completo: 8 bytes, sequência lógica para simplicidade UDP.",
                                    "Crie um fluxograma mostrando como os campos se integram em uma transmissão UDP."
                                  ],
                                  "verification": "Gerar um checksum simples para um datagrama exemplo e validar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de cálculo de checksum UDP",
                                    "Pseudo-código do algoritmo"
                                  ],
                                  "tips": "Zero no checksum significa 'não usar'; configure adequadamente em testes.",
                                  "learningObjective": "Mestre o checksum e integrar todos os campos do cabeçalho.",
                                  "commonMistakes": [
                                    "Achar checksum obrigatório em IPv4",
                                    "Ignorar pseudo-header IP no cálculo"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture um pacote DNS (porta 53 UDP) de uma consulta real. Identifique no hex dump: bytes 0-1 (porta origem efêmera), 2-3 (porta 53 destino), 4-5 (comprimento total), 6-7 (checksum). Anote valores e valide propósitos.",
                              "finalVerifications": [
                                "Listar os 4 campos com tamanhos exatos (todos 16 bits) e posições em bytes.",
                                "Explicar o propósito de cada campo sem erros.",
                                "Desenhar diagrama preciso do cabeçalho UDP de 8 bytes.",
                                "Calcular comprimento e checksum para um exemplo simples.",
                                "Diferenciar UDP header de TCP header em tamanho e campos.",
                                "Identificar campos em um dump Wireshark real."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos tamanhos e posições dos campos (100% correto).",
                                "Clareza na explicação dos propósitos (sem ambiguidades).",
                                "Uso correto de terminologia técnica (ex: 'datagrama', 'multiplexação').",
                                "Capacidade de aplicar em exemplos reais (Wireshark ou cálculos).",
                                "Síntese integrada: visão holística do cabeçalho como unidade mínima.",
                                "Ausência de confusões com outros protocolos (TCP/IP)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos binários, soma em complemento de 1 para checksum.",
                                "Física: Transmissão de bits em redes, detecção de erros por ruído.",
                                "Segurança da Informação: Limitações do checksum UDP vs. criptografia.",
                                "Programação: Uso de sockets UDP em linguagens como Python (biblioteca socket)."
                              ],
                              "realWorldApplication": "O cabeçalho UDP é essencial em aplicações de baixa latência como streaming de vídeo (Netflix/YouTube), jogos multiplayer online (Fortnite), consultas DNS e VoIP (Zoom), priorizando velocidade sobre confiabilidade total."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Reconhecer cenários de uso do UDP",
                            "description": "Identificar aplicações como DNS, DHCP, streaming de vídeo e jogos online onde a baixa sobrecarga e tolerância a perdas justificam o uso de UDP em vez de TCP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar diferenças fundamentais entre TCP e UDP",
                                  "subSteps": [
                                    "Leia a definição de TCP: protocolo orientado a conexão com garantia de entrega, controle de fluxo e retransmissão.",
                                    "Leia a definição de UDP: protocolo sem conexão, sem garantia de entrega, baixa sobrecarga.",
                                    "Compare overhead: TCP tem headers maiores e handshakes; UDP é minimalista.",
                                    "Anote quando TCP é preferível (ex: transferências de arquivos) vs. UDP (ex: tempo real).",
                                    "Crie uma tabela comparativa com colunas: Conexão, Confiabilidade, Overhead, Uso típico."
                                  ],
                                  "verification": "Tabela comparativa completa com pelo menos 5 diferenças chave listadas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 768 (UDP), RFC 793 (TCP)",
                                    "Vídeo introdutório sobre TCP vs UDP no YouTube (ex: canal NetworkChuck)"
                                  ],
                                  "tips": "Use analogias: TCP como correio registrado, UDP como jogar cartas no vento.",
                                  "learningObjective": "Compreender as características técnicas que distinguem TCP de UDP.",
                                  "commonMistakes": [
                                    "Confundir UDP com TCP em termos de confiabilidade",
                                    "Ignorar o impacto do overhead em redes lentas",
                                    "Achar que UDP é sempre mais rápido sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar vantagens específicas do UDP",
                                  "subSteps": [
                                    "Liste as vantagens: baixa latência, menor uso de banda, tolerância a perdas de pacotes.",
                                    "Explique baixa sobrecarga: header UDP de 8 bytes vs. TCP variável até 60+ bytes.",
                                    "Discuta tolerância a perdas: em apps tempo-real, pacotes perdidos são irrelevantes se novos chegam rápido.",
                                    "Calcule exemplo simples: tempo de envio UDP vs TCP em rede com 10% perda.",
                                    "Registre cenários onde velocidade > confiabilidade."
                                  ],
                                  "verification": "Lista de 4 vantagens do UDP com explicações breves e um cálculo de exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta online Wireshark para ver headers",
                                    "Artigo 'TCP vs UDP' no site Cloudflare Learning"
                                  ],
                                  "tips": "Pense em velocidade vs. perfeição: UDP sacrifica perfeição por velocidade.",
                                  "learningObjective": "Reconhecer quando baixa sobrecarga e tolerância a perdas tornam UDP ideal.",
                                  "commonMistakes": [
                                    "Subestimar perdas em UDP como sempre problemáticas",
                                    "Confundir latência com throughput",
                                    "Ignorar que UDP não tem controle de congestionamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar cenários específicos de uso do UDP",
                                  "subSteps": [
                                    "Estude DNS: consultas rápidas, perdas raras, retransmissão via app layer.",
                                    "Estude DHCP: broadcasts iniciais toleram perdas, baixa frequência.",
                                    "Estude streaming de vídeo (ex: Netflix): frames perdidos não param o vídeo.",
                                    "Estude jogos online (ex: Fortnite): posições atualizadas frequentemente, perda ok.",
                                    "Para cada um, justifique por que não TCP: latência alta mataria a experiência."
                                  ],
                                  "verification": "Resumo de 4 cenários com justificativa UDP vs TCP para cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos Wireshark de tráfego DNS/DHCP",
                                    "Vídeos de análise de pacotes em jogos (ex: canal Low Level Learning)"
                                  ],
                                  "tips": "Capture tráfego real com Wireshark para ver UDP em ação.",
                                  "learningObjective": "Associar cenários concretos às vantagens do UDP.",
                                  "commonMistakes": [
                                    "Achar DNS usa TCP sempre (só em respostas longas)",
                                    "Confundir DHCP com TCP para leases",
                                    "Pensar streaming precisa 100% entrega"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e justificação em novos cenários",
                                  "subSteps": [
                                    "Liste 3 cenários adicionais: VoIP (Zoom), SNMP, NTP.",
                                    "Para cada, decida UDP ou TCP e justifique (ex: VoIP precisa baixa latência).",
                                    "Crie fluxograma: Dado app, pergunta 'Tempo real? Perdas ok?' -> UDP.",
                                    "Debata contra-argumentos: quando adicionar confiabilidade sobre UDP.",
                                    "Teste com quiz online sobre protocolos."
                                  ],
                                  "verification": "Fluxograma funcional e respostas corretas para 3 cenários novos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quiz interativo TCP/UDP no site GeeksforGeeks",
                                    "Ferramenta draw.io para fluxogramas"
                                  ],
                                  "tips": "Sempre pergunte: 'Retransmissão vale a espera?'",
                                  "learningObjective": "Aplicar conhecimento para reconhecer UDP em contextos variados.",
                                  "commonMistakes": [
                                    "Forçar TCP em tudo por 'confiabilidade'",
                                    "Ignorar hybrid apps (QUIC usa UDP com fiabilidade)",
                                    "Não considerar escala de rede"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um jogo multiplayer como Counter-Strike, posições de jogadores são enviadas via UDP a cada 20ms. Um pacote perdido significa só um 'pulo' no movimento, mas TCP causaria lag de 100ms+ por retransmissão, tornando o jogo injogável.",
                              "finalVerifications": [
                                "Lista corretamente 4+ cenários UDP padrão (DNS, DHCP, streaming, jogos).",
                                "Explica baixa sobrecarga e tolerância a perdas em termos simples.",
                                "Distingue quando TCP é obrigatório vs. UDP viável.",
                                "Cria tabela ou fluxograma de decisão UDP/TCP.",
                                "Identifica corretamente UDP em captura Wireshark simulada.",
                                "Justifica escolhas sem erros comuns como 'UDP é inseguro'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários (90%+ corretos).",
                                "Profundidade de justificativas (menciona latência/perdas/overhead).",
                                "Criatividade em exemplos reais ou novos cenários.",
                                "Clareza na comunicação (tabelas/fluxogramas bem estruturados).",
                                "Ausência de confusões TCP/UDP fundamentais.",
                                "Aplicação prática via análise de tráfego ou quizzes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidades de perda de pacotes e estatísticas de rede.",
                                "Física: Analogia com transmissão de ondas/sinais em tempo real.",
                                "Engenharia: Design de sistemas tolerantes a falhas.",
                                "Negócios: Impacto de latência em serviços online (e-commerce, games).",
                                "Segurança: Vulnerabilidades de UDP (amplificação DDoS)."
                              ],
                              "realWorldApplication": "Profissionais de TI usam isso para otimizar redes: configurar roteadores para priorizar UDP em VoIP/gaming, diagnosticar lentidão em streaming como problema TCP desnecessário, ou desenvolver apps IoT onde bateria importa mais que perfeição."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Protocolo TCP",
                        "description": "O Transmission Control Protocol (TCP) é um protocolo de camada de transporte orientado a conexão, confiável, que garante entrega ordenada, controle de fluxo via janela deslizante e mecanismos de recuperação de erros.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Explicar o estabelecimento de conexão TCP (three-way handshake)",
                            "description": "Descrever o processo SYN, SYN-ACK, ACK para inicializar uma conexão TCP, incluindo gerenciamento de números de sequência e ACK para sincronização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais do TCP e o Necessário para o Handshake",
                                  "subSteps": [
                                    "Estude o que é o TCP: protocolo orientado a conexão na camada de transporte.",
                                    "Identifique os estados iniciais: CLOSED para cliente e servidor.",
                                    "Aprenda sobre os flags TCP: SYN, ACK, FIN, RST.",
                                    "Entenda o propósito do three-way handshake: sincronizar números de sequência.",
                                    "Revise a RFC 793 para base teórica."
                                  ],
                                  "verification": "Desenhe um diagrama simples dos estados iniciais e liste os flags principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 793 (TCP Specification)",
                                    "Diagramas de estados TCP (online ou livro de redes)"
                                  ],
                                  "tips": "Use analogia de telefone: discar, tocar, atender para entender sincronização.",
                                  "learningObjective": "Dominar os pré-requisitos teóricos do TCP e flags para o handshake.",
                                  "commonMistakes": [
                                    "Confundir TCP com UDP (sem conexão)",
                                    "Ignorar estados como LISTEN no servidor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o Primeiro Passo: Envio do Pacote SYN pelo Cliente",
                                  "subSteps": [
                                    "Cliente transita de CLOSED para SYN-SENT.",
                                    "Gere um número de sequência inicial aleatório (ISN).",
                                    "Envie pacote com flag SYN=1 e SEQ=ISN.",
                                    "Explique que o SYN solicita sincronização sem dados.",
                                    "Simule o pacote em diagrama: cabeçalho com SYN e SEQ."
                                  ],
                                  "verification": "Escreva a representação do pacote SYN e explique o SEQ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io",
                                    "Exemplos de pacotes Wireshark"
                                  ],
                                  "tips": "Lembre: SYN não carrega dados de aplicação, só controle.",
                                  "learningObjective": "Descrever precisamente o pacote SYN e seu papel na iniciação.",
                                  "commonMistakes": [
                                    "Achar que SYN carrega dados",
                                    "Esquecer transição de estado SYN-SENT"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Resposta: Pacote SYN-ACK do Servidor",
                                  "subSteps": [
                                    "Servidor em LISTEN recebe SYN e transita para SYN-RECEIVED.",
                                    "Gere ISN do servidor e defina ACK = SEQ_cliente + 1.",
                                    "Envie pacote com SYN=1, ACK=1, SEQ=ISN_servidor, ACK=valor calculado.",
                                    "Explique confirmação do SEQ cliente e proposta do SEQ servidor.",
                                    "Desenhe fluxo bidirecional no diagrama."
                                  ],
                                  "verification": "Calcule ACK para um SEQ exemplo (ex: SEQ=1000, ACK=1001).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para números de sequência",
                                    "Capturas Wireshark de handshakes reais"
                                  ],
                                  "tips": "ACK sempre confirma o próximo byte esperado.",
                                  "learningObjective": "Entender a sincronização mútua no SYN-ACK.",
                                  "commonMistakes": [
                                    "Confundir SEQ e ACK",
                                    "Não somar +1 no ACK para SYN"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar com ACK do Cliente e Gerenciamento de Sequências",
                                  "subSteps": [
                                    "Cliente recebe SYN-ACK e transita para ESTABLISHED.",
                                    "Envie ACK=1, SEQ=SEQ_cliente + 1, ACK=SEQ_servidor + 1.",
                                    "Servidor recebe ACK e vai para ESTABLISHED: conexão ativa.",
                                    "Revise wrap-around de 32-bit SEQ (2^32 -1).",
                                    "Explique detecção de perda via ACKs subsequentes."
                                  ],
                                  "verification": "Complete diagrama full handshake com SEQ/ACK numéricos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Simulador TCP online"
                                  ],
                                  "tips": "Teste com números: Cliente ISN=1000, Servidor=2000; trace ACKs.",
                                  "learningObjective": "Compreender fechamento do handshake e persistência de SEQ/ACK.",
                                  "commonMistakes": [
                                    "Pular +1 no SEQ final",
                                    "Ignorar estados ESTABLISHED"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Resumir o Processo Completo e Aplicações Práticas",
                                  "subSteps": [
                                    "Monte o fluxo completo: SYN → SYN-ACK → ACK.",
                                    "Discuta ataques como SYN flood (mitigação).",
                                    "Compare com UDP (sem handshake).",
                                    "Pratique explicação oral ou escrita.",
                                    "Registre diferenças em conexões ativas vs passivas."
                                  ],
                                  "verification": "Explique o handshake em 1 minuto para um par.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Vídeo tutorial TCP handshake (YouTube)",
                                    "Quiz online sobre TCP"
                                  ],
                                  "tips": "Use setas coloridas em diagramas para clareza.",
                                  "learningObjective": "Sintetizar o three-way handshake holisticamente.",
                                  "commonMistakes": [
                                    "Reverter ordem cliente-servidor",
                                    "Omitir gerenciamento de SEQ"
                                  ]
                                }
                              ],
                              "practicalExample": "Abra o Wireshark, acesse google.com:80 via telnet ou browser. Filtre 'tcp.handshake' e analise os 3 pacotes: identifique flags SYN/SYN-ACK/ACK e valores SEQ/ACK em uma conexão real.",
                              "finalVerifications": [
                                "Diagramar corretamente o fluxo de 3 pacotes com estados e flags.",
                                "Calcular SEQ/ACK para cenários hipotéticos.",
                                "Explicar por que 3-way (não 2-way) é necessário para sincronização bilateral.",
                                "Identificar pacotes de handshake em captura Wireshark.",
                                "Descrever transições de estados TCP.",
                                "Diferenciar SYN de outros flags."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência SYN → SYN-ACK → ACK (100%).",
                                "Correto cálculo e explicação de números SEQ/ACK.",
                                "Uso adequado de terminologia (flags, estados, RFC).",
                                "Clareza em diagramas e exemplos práticos.",
                                "Compreensão de propósitos de confiabilidade e sincronização.",
                                "Identificação de erros comuns como SYN flood."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e números de 32 bits (overflow SEQ).",
                                "Física: Analogia com sinais eletromagnéticos e latência em redes.",
                                "Segurança da Informação: Vulnerabilidades como SYN flood e mitigação.",
                                "Programação: Implementação em sockets Python (socket.connect()).",
                                "Estatística: Probabilidade de perda de pacotes e retransmissão."
                              ],
                              "realWorldApplication": "Todo site acessado (HTTP/HTTPS), email (SMTP), streaming (Netflix) inicia com TCP three-way handshake para garantir entrega ordenada e confiável de dados na internet."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Descrever o formato do cabeçalho TCP",
                            "description": "Detalhar os campos principais: portas (16 bits cada), sequência e ACK (32 bits cada), offset, flags (SYN, ACK, FIN, RST), janela (16 bits), checksum e opções, com tamanho variável de 20-60 bytes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral e tamanho do cabeçalho TCP",
                                  "subSteps": [
                                    "Estude o diagrama padrão do cabeçalho TCP, identificando as seções fixas (20 bytes) e variáveis (opções).",
                                    "Memorize que o cabeçalho varia de 20 a 60 bytes devido ao campo de opções e padding.",
                                    "Analise o campo Data Offset (4 bits) que indica o tamanho total em palavras de 32 bits.",
                                    "Compare com cabeçalho UDP para destacar diferenças no tamanho e complexidade.",
                                    "Anote os offsets de bytes para cada campo principal."
                                  ],
                                  "verification": "Desenhe o layout do cabeçalho e explique verbalmente o tamanho mínimo e máximo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do cabeçalho TCP (RFC 793 ou site como Wireshark wiki)",
                                    "Papel e caneta para esboço"
                                  ],
                                  "tips": "Use cores diferentes para campos fixos vs. variáveis para visualização clara.",
                                  "learningObjective": "Entender a composição e variabilidade do cabeçalho TCP.",
                                  "commonMistakes": [
                                    "Confundir tamanho mínimo com IP (20 bytes igual, mas campos diferentes)",
                                    "Ignorar que opções podem adicionar até 40 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever os campos de portas e numeração de sequência/ACK",
                                  "subSteps": [
                                    "Descreva Port Source (16 bits): identifica a aplicação cliente.",
                                    "Descreva Port Destination (16 bits): identifica o servidor ou aplicação destino.",
                                    "Explique Sequence Number (32 bits): número da sequência do primeiro byte de dados.",
                                    "Detalhe Acknowledgment Number (32 bits): confirma recebimento até esse byte.",
                                    "Pratique convertendo números decimais para hexadecimais para esses campos."
                                  ],
                                  "verification": "Liste os 4 campos com tamanhos e funções, dando um exemplo numérico para seq e ACK.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de conversão binário/hex (ex: RapidTables)",
                                    "Exemplos de pacotes TCP capturados"
                                  ],
                                  "tips": "Lembre que portas são como 'números de telefone' para apps em uma máquina.",
                                  "learningObjective": "Dominar campos iniciais responsáveis por endereçamento e controle de fluxo básico.",
                                  "commonMistakes": [
                                    "Trocar source por destination",
                                    "Confundir seq com ACK (seq é envio, ACK é confirmação)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar campos de controle: offset, flags e janela",
                                  "subSteps": [
                                    "Estude Data Offset (4 bits no Header Length): multiplique por 4 para bytes totais.",
                                    "Liste flags principais: SYN (inicia conexão), ACK (confirma), FIN (fecha), RST (reseta).",
                                    "Descreva Reserved (3 bits, geralmente 0), outros flags como URG/PSH.",
                                    "Explique Window Size (16 bits): anuncia quanta dados pode receber.",
                                    "Simule uma troca de handshake com flags SYN, SYN-ACK, ACK."
                                  ],
                                  "verification": "Crie uma tabela com todas as flags, seus bits e usos em 3-way handshake.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de flags TCP (Wikipedia ou livro Tanenbaum)",
                                    "Simulador online de TCP handshake"
                                  ],
                                  "tips": "Flags são como botões de controle: visualize como uma conexão de telefone sendo ligada/desligada.",
                                  "learningObjective": "Compreender mecanismos de controle de conexão e fluxo.",
                                  "commonMistakes": [
                                    "Esquecer que offset inclui opções",
                                    "Confundir window com MTU"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar campos de integridade, opções e síntese",
                                  "subSteps": [
                                    "Descreva Checksum (16 bits): verifica integridade do cabeçalho + dados + pseudo-header IP.",
                                    "Explique Urgent Pointer (16 bits): aponta byte urgente se URG flag setado.",
                                    "Detalhe Opções (0-40 bytes): tipos como MSS, Window Scale, SACK; padding para múltiplo de 32 bits.",
                                    "Sintetize todo cabeçalho: recite ordem e tamanhos de origem a fim.",
                                    "Compare versões (RFC 793 vs. extensões modernas)."
                                  ],
                                  "verification": "Explique como calcular checksum pseudo e liste 3 opções comuns com propósitos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 793 PDF",
                                    "Wireshark para ver opções reais"
                                  ],
                                  "tips": "Checksum é calculado com ones' complement; pratique com calculadora online.",
                                  "learningObjective": "Integrar todos os campos e entender extensibilidade via opções.",
                                  "commonMistakes": [
                                    "Ignorar pseudo-header no checksum",
                                    "Pensar opções como obrigatórias"
                                  ]
                                }
                              ],
                              "practicalExample": "Use Wireshark para capturar tráfego HTTPS (porta 443): filtre 'tcp', selecione um SYN packet, expanda TCP header e anote valores reais de portas (ex: 54321 -> 443), seq=0, flags=SYN, window=65535, opções=MSS=1460. Descreva em um relatório.",
                              "finalVerifications": [
                                "Pode desenhar o cabeçalho TCP completo com labels e tamanhos exatos?",
                                "Explica corretamente o papel de cada campo principal em uma conexão TCP?",
                                "Identifica opções comuns em um dump Wireshark?",
                                "Calcula data offset a partir de um valor de 5 (20 bytes)?",
                                "Lista e descreve todas as 6 flags principais?",
                                "Diferencia seq/ACK em um 3-way handshake?"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos tamanhos de bits/bytes de todos os campos (100% correto).",
                                "Correta descrição funcional de pelo menos 90% dos campos.",
                                "Uso apropriado de terminologia (ex: 'sequence number' não 'seq num').",
                                "Capacidade de ligar campos a mecanismos TCP (handshake, fluxo, integridade).",
                                "Exemplo prático com Wireshark ou similar demonstra compreensão aplicada.",
                                "Identificação de erros comuns evitados na descrição."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão binário/decimal/hex e aritmética modular para checksum.",
                                "Física: Transmissão de bits em cabos/fibra, impacto de ruído no checksum.",
                                "Segurança da Informação: Flags como RST para ataques de reset.",
                                "Engenharia de Software: Portas em desenvolvimento de sockets cliente-servidor.",
                                "História da Computação: Evolução do TCP desde ARPANET."
                              ],
                              "realWorldApplication": "Compreender o cabeçalho TCP permite debugar lentidão em conexões web (ex: analisar window size em Wireshark), otimizar data centers reduzindo overhead de opções desnecessárias, desenvolver protocolos customizados ou ferramentas de segurança como firewalls que inspecionam flags SYN/FIN."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Entender o controle de fluxo no TCP",
                            "description": "Explicar o mecanismo de janela deslizante, onde o receptor anuncia o tamanho da janela disponível para evitar sobrecarga, ajustando dinamicamente o fluxo de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Controle de Fluxo",
                                  "subSteps": [
                                    "Defina controle de fluxo como o mecanismo para regular a taxa de transmissão de dados entre remetente e receptor.",
                                    "Explique a importância de evitar sobrecarga no buffer do receptor.",
                                    "Diferencie controle de fluxo de controle de congestão.",
                                    "Estude o papel dos buffers em protocolos de rede.",
                                    "Revise o cabeçalho TCP básico, focando no campo de janela."
                                  ],
                                  "verification": "Resuma os conceitos em um parágrafo e identifique pelo menos 3 diferenças entre controle de fluxo e congestão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação RFC 793 (TCP)",
                                    "Vídeo introdutório sobre TCP (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use analogias como tráfego em uma estrada para visualizar buffers.",
                                  "learningObjective": "Identificar os fundamentos e componentes chave do controle de fluxo no TCP.",
                                  "commonMistakes": "Confundir controle de fluxo com controle de erro ou assumindo que é só sobre velocidade fixa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Mecanismo de Janela Deslizante",
                                  "subSteps": [
                                    "Descreva a janela deslizante como um conjunto de bytes que o remetente pode transmitir sem ACK.",
                                    "Entenda os conceitos de janela de envio (sender window) e janela de recebimento (receiver window).",
                                    "Aprenda como a janela 'desliza' à medida que ACKs são recebidos.",
                                    "Calcule exemplos simples: se janela=4, sequência=1-4 enviados, ACK=3 desliza para 5-8.",
                                    "Visualize com diagramas de sequência de pacotes."
                                  ],
                                  "verification": "Desenhe um diagrama de janela deslizante antes e depois de um ACK.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io",
                                    "Simulador TCP online (ex: TCP Window Simulator)"
                                  ],
                                  "tips": "Pense na janela como uma 'fila móvel' de pacotes permitidos.",
                                  "learningObjective": "Modelar visualmente o funcionamento da janela deslizante no TCP.",
                                  "commonMistakes": "Ignorar que a janela pode encolher, não só expandir."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Anúncio da Janela pelo Receptor",
                                  "subSteps": [
                                    "Estude o campo 'Window' no cabeçalho TCP, que indica bytes disponíveis no buffer do receptor.",
                                    "Explique como o receptor envia ACKs com o tamanho da janela atualizada.",
                                    "Simule cenários onde o buffer enche e a janela vai para zero (zero window).",
                                    "Aprenda sobre probing de janela zero para detectar quando buffer libera.",
                                    "Discuta opções TCP como Window Scale para janelas maiores."
                                  ],
                                  "verification": "Crie um fluxograma mostrando o receptor anunciando janela em um ACK.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wireshark para capturar tráfego TCP real",
                                    "RFC 793 seção sobre window"
                                  ],
                                  "tips": "Capture tráfego HTTP com Wireshark e filtre por TCP window.",
                                  "learningObjective": "Explicar como o receptor controla o fluxo via anúncios de janela.",
                                  "commonMistakes": "Achar que o remetente define a janela, em vez do receptor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Ajustes Dinâmicos e Prevenção de Sobrecarga",
                                  "subSteps": [
                                    "Simule uma transferência onde buffer receptor varia (ex: 50% cheio -> janela reduz).",
                                    "Teste cenários de recuperação: buffer libera -> janela aumenta.",
                                    "Implemente um script simples em Python com sockets para observar controle de fluxo.",
                                    "Analise impactos em throughput e latência.",
                                    "Compare com UDP, que não tem controle de fluxo."
                                  ],
                                  "verification": "Execute simulação e registre mudanças na janela em 3 cenários diferentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com biblioteca socket",
                                    "Simulador ns-3 ou Cisco Packet Tracer"
                                  ],
                                  "tips": "Use print statements para logar tamanhos de janela em código socket.",
                                  "learningObjective": "Demonstrar ajustes dinâmicos da janela em prática.",
                                  "commonMistakes": "Não considerar delays de ACK afetando o deslize da janela."
                                }
                              ],
                              "practicalExample": "Em um download de vídeo de 10MB via HTTP/TCP, se o buffer do receptor (seu navegador) encher devido a processamento lento, ele anuncia janela=0, pausando o envio do servidor até o buffer liberar espaço, evitando perda de pacotes e retransmissões desnecessárias.",
                              "finalVerifications": [
                                "Explique o mecanismo de janela deslizante em suas próprias palavras.",
                                "Desenhe e rotule um diagrama de uma sessão TCP com variações de janela.",
                                "Simule em Wireshark ou código um caso de zero window e recuperação.",
                                "Compare controle de fluxo TCP vs. ausência em UDP.",
                                "Responda: 'Por que o receptor controla a janela?' com exemplo.",
                                "Calcule throughput baseado em tamanho de janela e RTT."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do anúncio de janela (90% correto).",
                                "Qualidade e correção de diagramas/simulações (clareza visual).",
                                "Profundidade na distinção entre conceitos relacionados (fluxo vs. congestão).",
                                "Capacidade de aplicar em exemplos reais (relevância).",
                                "Identificação de erros comuns e soluções.",
                                "Completude das verificações finais (todas atendidas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências aritméticas para números de sequência e janelas.",
                                "Sistemas Operacionais: Gerenciamento de buffers e filas.",
                                "Programação: Uso de sockets em linguagens como Python/C para TCP.",
                                "Física: Analogia com fluxo de fluidos e capacidade de tubulações."
                              ],
                              "realWorldApplication": "Em serviços de streaming como Netflix, o controle de fluxo TCP ajusta dinamicamente a taxa de envio de vídeo baseado no buffer do player, prevenindo buffering excessivo ou interrupções, otimizando a experiência do usuário em conexões variáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.4",
                            "name": "Descrever a confiabilidade no TCP",
                            "description": "Explicar timeouts, retransmissões baseadas em ACKs perdidos, detecção de duplicatas via números de sequência e ordenação de segmentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos da Confiabilidade no TCP",
                                  "subSteps": [
                                    "Estude o que significa 'confiabilidade' em protocolos de transporte: entrega garantida, ordenada e sem duplicatas.",
                                    "Revise o modelo TCP/IP e o papel da camada de transporte.",
                                    "Identifique os principais mecanismos: timeouts, ACKs, números de sequência e retransmissões.",
                                    "Assista a um vídeo introdutório sobre TCP vs UDP para contrastar confiabilidade.",
                                    "Anote definições chave: segmento TCP, porta, conexão de fim a fim."
                                  ],
                                  "verification": "Resuma em 3 frases os pilares da confiabilidade TCP e compare com UDP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Vídeo Khan Academy sobre TCP/IP",
                                    "Diagrama do modelo TCP/IP",
                                    "Notas em papel ou digital"
                                  ],
                                  "tips": "Use analogias como 'correio certificado' para visualizar entrega garantida.",
                                  "learningObjective": "Compreender o conceito geral de confiabilidade e seus componentes básicos no TCP.",
                                  "commonMistakes": "Confundir TCP com IP (TCP é transporte, IP é rede); ignorar que UDP não é confiável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Timeouts e Mecanismos de Retransmissão",
                                  "subSteps": [
                                    "Aprenda como o TCP usa timers para detectar perdas: RTT (Round Trip Time) estimado.",
                                    "Estude o algoritmo de retransmissão: após timeout, reenvia o segmento mais antigo não ACK.",
                                    "Simule um cenário de perda de pacote com diagrama: envia SYN, timeout, retransmite.",
                                    "Discuta backoff exponencial para evitar congestionamento.",
                                    "Calcule um exemplo simples de RTT: envie 100ms, ACK em 200ms total."
                                  ],
                                  "verification": "Desenhe um diagrama de timeout e retransmissão para um handshake de 3 vias.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulador TCP online (ex: TCPtimer.com)",
                                    "Papel para diagramas",
                                    "Artigo RFC 793 sobre TCP"
                                  ],
                                  "tips": "Lembre-se: timeout é último recurso; ACKs são preferidos para eficiência.",
                                  "learningObjective": "Dominar como timeouts detectam perdas e acionam retransmissões.",
                                  "commonMistakes": "Achar que timeout é fixo (é adaptativo baseado em RTT); ignorar impacto no throughput."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar ACKs e Detecção de ACKs Perdidos",
                                  "subSteps": [
                                    "Explique ACKs cumulativos: ACK n confirma todos segmentos até n-1.",
                                    "Estude retransmissão seletiva (SACK) vs go-back-N para ACKs perdidos.",
                                    "Simule perda de ACK: receptor reenvia ACK duplicado ao receber segmento posterior.",
                                    "Discuta Fast Retransmit: 3 ACKs duplicados trigger retransmissão sem timeout.",
                                    "Compare ACKs positivos vs negativos (NAK)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como 3 ACKs duplicados evitam timeout.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Wireshark para capturar tráfego TCP real",
                                    "Tutorial Wireshark TCP",
                                    "Exemplos de captura de pacotes"
                                  ],
                                  "tips": "Capture tráfego web real para ver ACKs em ação.",
                                  "learningObjective": "Entender como ACKs detectam perdas e acionam retransmissões rápidas.",
                                  "commonMistakes": "Confundir ACK cumulativo com individual; subestimar ACKs duplicados como mecanismo proativo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar Números de Sequência para Duplicatas e Ordenação",
                                  "subSteps": [
                                    "Aprenda geração de números de sequência (seq num) iniciais aleatórios.",
                                    "Explique detecção de duplicatas: receptor descarta se seq num já recebido.",
                                    "Estude buffer de reorder: TCP reordena segmentos fora de ordem antes de entregar.",
                                    "Simule cenário: segmentos chegam 1,3,2; TCP segura 3 até 2 chegar.",
                                    "Discuta janela deslizante para fluxo controlado."
                                  ],
                                  "verification": "Crie um diagrama de chegada desordenada e como TCP ordena/detecta duplicata.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramenta de simulação TCP (ex: ns-3 ou Cisco Packet Tracer)",
                                    "Diagramas de seq num",
                                    "RFC 5681 TCP Congestion"
                                  ],
                                  "tips": "Pense em seq nums como 'números de página' em um livro para evitar duplicatas.",
                                  "learningObjective": "Compreender o uso de seq nums para ordenação e eliminação de duplicatas.",
                                  "commonMistakes": "Ignorar que seq nums são de 32 bits e wrap-around possível; confundir com ACK nums."
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture uma transferência de arquivo HTTP via TCP. Induza perda artificial (netem no Linux) e observe: timeouts, retransmissões por ACK duplicados, reorder de segmentos via seq nums, e detecção de duplicata se reenvio prematuro ocorrer.",
                              "finalVerifications": [
                                "Pode diagramar um ciclo completo de perda, ACK duplicado e retransmissão?",
                                "Explica corretamente como seq nums detectam duplicatas?",
                                "Identifica quando timeout vs fast retransmit é usado?",
                                "Descreve ordenação de segmentos fora de ordem?",
                                "Compara confiabilidade TCP com UDP em um exemplo?",
                                "Simula RTT e calcula timeout aproximado?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de timeouts e RTT (90% correto).",
                                "Clareza no diagrama de ACKs duplicados e fast retransmit.",
                                "Correta descrição de seq nums para duplicatas e reorder (com exemplo).",
                                "Integração de todos mecanismos em uma narrativa coesa.",
                                "Uso de analogias ou simulações para demonstrar entendimento.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de médias exponenciais ponderadas para RTT.",
                                "Física: Analogia com propagação de sinais e latência em redes.",
                                "Estatística: Probabilidades de perda de pacotes e modelagem de congestionamento.",
                                "Programação: Implementação de sockets TCP em Python para testar mecanismos."
                              ],
                              "realWorldApplication": "No streaming de vídeo (Netflix), TCP garante que frames perdidos sejam retransmitidos sem duplicatas, mantendo ordem para playback suave; em transferências de arquivos (FTP/HTTP), assegura integridade total de dados em redes instáveis como Wi-Fi público."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.2",
                              "10.1.2.4.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Controle de Congestionamento no TCP",
                        "description": "Mecanismos no TCP para evitar congestionamento na rede, ajustando dinamicamente a taxa de envio com base em feedback implícito ou explícito da rede, como perda de pacotes.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Explicar os princípios básicos de controle de congestionamento",
                            "description": "Descrever o problema de congestionamento (fila de roteadores lotada), detecção via timeouts ou ACKs duplicados, e a taxa de congestionamento (cwnd) como variável chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Problema de Congestionamento em Redes",
                                  "subSteps": [
                                    "Defina congestionamento como o acúmulo excessivo de pacotes em filas de roteadores, levando a atrasos e perdas.",
                                    "Explique como o tráfego intenso causa lotação de buffers em roteadores.",
                                    "Discuta impactos: aumento de latência, perda de pacotes e redução de throughput.",
                                    "Compare com engarrafamento de trânsito em estradas.",
                                    "Identifique causas principais: mais pacotes enviados do que a rede pode processar."
                                  ],
                                  "verification": "Desenhe um diagrama simples de um roteador com fila lotada e anote os impactos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Vídeo introdutório sobre redes TCP (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias cotidianas como filas em supermercados para fixar o conceito.",
                                  "learningObjective": "Compreender a causa raiz e consequências do congestionamento em redes.",
                                  "commonMistakes": [
                                    "Confundir com perda de pacotes por erros de transmissão",
                                    "Ignorar o papel dos buffers finitos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Métodos de Detecção de Congestionamento",
                                  "subSteps": [
                                    "Descreva detecção por timeout: receptor não recebe ACK no prazo esperado.",
                                    "Explique detecção por ACKs duplicados: receptor envia múltiplos ACKs para o mesmo pacote perdido.",
                                    "Compare os dois métodos: timeout é mais lento, ACKs duplicados são mais rápidos.",
                                    "Estude o papel do RTT (Round Trip Time) na detecção por timeout.",
                                    "Simule cenários onde cada método é acionado."
                                  ],
                                  "verification": "Liste 3 diferenças entre timeout e ACKs duplicados com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas de TCP sequence numbers",
                                    "Ferramenta Wireshark para capturar pacotes reais"
                                  ],
                                  "tips": "Monitore uma conexão real com Wireshark para ver ACKs duplicados em ação.",
                                  "learningObjective": "Identificar e diferenciar sinais de congestionamento detectados pelo TCP.",
                                  "commonMistakes": [
                                    "Achar que ACKs duplicados indicam erro de bit, não perda por congestionamento",
                                    "Subestimar variabilidade do RTT"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a Congestion Window (cwnd) como Variável Chave",
                                  "subSteps": [
                                    "Defina cwnd como o limite de dados não confirmados que o remetente pode enviar.",
                                    "Explique como cwnd controla a taxa de envio: bytes no ar ≤ cwnd.",
                                    "Discuta interação com receiver window (rwnd): effective window = min(cwnd, rwnd).",
                                    "Ilustre com exemplo numérico: cwnd=10 pacotes permite envio de 10 sem ACK.",
                                    "Descreva inicialização: cwnd começa pequeno (ex: 1 MSS)."
                                  ],
                                  "verification": "Calcule effective window em um cenário com cwnd=20 e rwnd=15.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou planilha para simulações",
                                    "Artigo RFC 5681 sobre TCP congestion control"
                                  ],
                                  "tips": "Pense em cwnd como o tamanho da 'janela deslizante' para congestionamento.",
                                  "learningObjective": "Dominar o papel da cwnd no controle dinâmico da taxa de transmissão.",
                                  "commonMistakes": [
                                    "Confundir cwnd com rwnd",
                                    "Ignorar que cwnd é ajustada apenas pelo remetente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Princípios de Ajuste da cwnd",
                                  "subSteps": [
                                    "Descreva Slow Start: cwnd dobra a cada RTT até threshold.",
                                    "Explique Congestion Avoidance: cwnd aumenta linearmente (1/cwnd por ACK).",
                                    "Detalhe reação a detecção: halve cwnd em ACKs duplicados, reset em timeout.",
                                    "Compare fases: exponencial no início, linear para estabilidade.",
                                    "Simule uma transferência com perdas para ver ajustes."
                                  ],
                                  "verification": "Trace mudanças na cwnd durante 5 RTTs em slow start e congestion avoidance.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Simulador TCP online (ex: TCP Congestion Control Simulator)",
                                    "Gráficos de evolução de cwnd"
                                  ],
                                  "tips": "Desenhe gráficos de cwnd vs tempo para visualizar as fases.",
                                  "learningObjective": "Aplicar algoritmos básicos de ajuste para manter estabilidade na rede.",
                                  "commonMistakes": [
                                    "Achar que slow start é sempre usado",
                                    "Confundir multiplicative decrease com additive increase"
                                  ]
                                }
                              ],
                              "practicalExample": "Use o Wireshark para capturar tráfego HTTP durante download de um grande arquivo; identifique ACKs duplicados, timeouts e observe como o throughput cai e recupera, correlacionando com ajustes na cwnd.",
                              "finalVerifications": [
                                "Explicar verbalmente o ciclo completo: detecção → ajuste cwnd → recuperação.",
                                "Desenhar diagrama de rede com filas lotadas e sinalizar detecção.",
                                "Simular em ferramenta online uma perda de pacote e verificar halving da cwnd.",
                                "Calcular throughput aproximado baseado em cwnd e RTT.",
                                "Diferenciar congestionamento de outros problemas de rede.",
                                "Listar 3 benefícios do controle de congestionamento para a internet."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do problema de congestionamento (fila lotada).",
                                "Correta distinção entre timeout e ACKs duplicados.",
                                "Compreensão clara do papel e ajuste da cwnd.",
                                "Uso correto de termos como slow start e congestion avoidance.",
                                "Capacidade de simular ou diagramar cenários práticos.",
                                "Identificação de erros comuns e soluções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos exponenciais e lineares no crescimento da cwnd.",
                                "Física: Analogia com fluxo de fluidos e gargalos em tubulações.",
                                "Economia: Otimização de recursos em redes compartilhadas.",
                                "Estatística: Análise de variabilidade em RTT e perdas de pacotes."
                              ],
                              "realWorldApplication": "No dia a dia, o controle de congestionamento TCP garante que vídeos no YouTube ou downloads não travem a internet inteira, equilibrando tráfego em backbone global para bilhões de usuários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Descrever o algoritmo AIMD (Additive Increase Multiplicative Decrease)",
                            "description": "Explicar o aumento linear da janela (1 MSS por RTT) em fase de congestion avoidance e redução multiplicativa (metade) em caso de perda.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais do Controle de Congestionamento no TCP",
                                  "subSteps": [
                                    "Defina janela de congestionamento (cwnd) como o limite de dados não confirmados que o remetente pode enviar.",
                                    "Explique RTT (Round-Trip Time) como o tempo para um pacote ir e voltar.",
                                    "Descreva MSS (Maximum Segment Size) como o tamanho máximo de um segmento TCP.",
                                    "Identifique as fases do TCP: slow start, congestion avoidance e recovery.",
                                    "Discuta por que o controle de congestionamento é necessário para evitar colapso da rede."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando cwnd, RTT e MSS em uma conexão TCP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama do modelo TCP (RFC 5681)",
                                    "Vídeo introdutório sobre TCP congestion control (Khan Academy ou YouTube)"
                                  ],
                                  "tips": "Use analogias como 'tráfego em uma estrada' para visualizar congestionamento.",
                                  "learningObjective": "Compreender os termos básicos que formam a base do algoritmo AIMD.",
                                  "commonMistakes": "Confundir cwnd com receive window (rwnd); cwnd é para controle de congestionamento, rwnd para buffer do receptor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o Aumento Aditivo (Additive Increase) na Fase de Congestion Avoidance",
                                  "subSteps": [
                                    "Explique que na fase de congestion avoidance, cwnd aumenta linearmente: cwnd += 1 MSS por RTT completo.",
                                    "Calcule um exemplo: se cwnd = 10 MSS e RTT passa sem perda, novo cwnd = 11 MSS.",
                                    "Discuta como isso probeia a capacidade da rede de forma conservadora.",
                                    "Compare com slow start (aumento exponencial: cwnd *= 2 por RTT).",
                                    "Desenhe um gráfico mostrando o crescimento linear de cwnd ao longo do tempo."
                                  ],
                                  "verification": "Simule 5 RTTs com aumento aditivo inicial em cwnd=10 e liste os valores de cwnd.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de simulação TCP como ns-3 ou papel e lápis para gráficos",
                                    "RFC 5681 seção sobre congestion avoidance"
                                  ],
                                  "tips": "Pense no aumento como 'adicionar uma faixa a mais na estrada a cada ciclo completo'.",
                                  "learningObjective": "Dominar o mecanismo de aumento linear e sua implementação no TCP.",
                                  "commonMistakes": "Aumentar por ACK individual em vez de por RTT completo; o aumento é por RTT."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Redução Multiplicativa (Multiplicative Decrease) em Caso de Perda",
                                  "subSteps": [
                                    "Descreva detecção de perda: timeout (RTO) ou 3 ACKs duplicados.",
                                    "Explique a redução: cwnd = cwnd / 2 (metade do valor atual).",
                                    "Diferencie: para 3 dup ACKs, fast recovery (cwnd = ssthresh + 3 MSS); para timeout, slow start restart.",
                                    "Calcule exemplo: cwnd=20 MSS, perda detectada → novo cwnd=10 MSS.",
                                    "Ilustre com gráfico 'sawtooth' mostrando picos e quedas abruptas."
                                  ],
                                  "verification": "Desenhe o padrão sawtooth para 10 RTTs com perdas em RTT 4 e 8.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos de Wireshark capturando tráfego TCP real",
                                    "Simulador online de TCP congestion (como tcp-congestion-sim)"
                                  ],
                                  "tips": "Lembre: multiplicativo garante convergência rápida para taxa justa.",
                                  "learningObjective": "Entender como e quando a redução multiplicativa é aplicada para recuperação de congestionamento.",
                                  "commonMistakes": "Reduzir para 1 MSS em todas perdas; depende do tipo de detecção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Propriedades e Equilíbrio do Algoritmo AIMD",
                                  "subSteps": [
                                    "Discuta fairness: múltiplos fluxos convergem para shares iguais da largura de banda.",
                                    "Explique estabilidade: equilíbrio entre probe (aumento) e retreat (redução).",
                                    "Compare AIMD com outros (ex: MIMD) e por que AIMD é TCP Reno padrão.",
                                    "Simule dois fluxos competindo e mostre convergência.",
                                    "Resuma o ciclo completo: avoidance → perda → recovery → avoidance."
                                  ],
                                  "verification": "Explique em 3 frases por que AIMD garante 'max-min fairness'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo 'Congestion Avoidance and Control' de Van Jacobson (1988)",
                                    "Ferramenta de simulação multi-fluxo"
                                  ],
                                  "tips": "Visualize como leilão: todos aumentam devagar, quem perde corta pela metade.",
                                  "learningObjective": "Compreender as propriedades matemáticas e práticas que tornam AIMD eficaz.",
                                  "commonMistakes": "Ignorar que AIMD assume perdas por congestionamento, não por bit error."
                                }
                              ],
                              "practicalExample": "Em uma conexão TCP baixando um arquivo de 1MB em uma rede com 100ms RTT e largura de banda disponível de 10Mbps: cwnd inicia em 10 MSS (1460 bytes), aumenta 1 MSS/RTT até ~70 MSS (perda simulada), cai para 35 MSS, repete formando sawtooth, estabilizando em ~50 MSS para throughput ~7Mbps sem colapso.",
                              "finalVerifications": [
                                "Desenhar e rotular gráfico sawtooth de cwnd vs tempo com 3 ciclos.",
                                "Calcular throughput aproximado: throughput = cwnd / RTT.",
                                "Explicar diferença entre timeout e 3 dup ACKs no AIMD.",
                                "Simular manualmente 10 RTTs com uma perda e listar cwnd.",
                                "Identificar fase atual do TCP dado cwnd e ssthresh."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do aumento (1 MSS/RTT) e redução (/2): 30%",
                                "Uso correto de termos (cwnd, RTT, MSS, fases TCP): 20%",
                                "Capacidade de ilustrar com gráficos ou simulações: 20%",
                                "Explicação de fairness e estabilidade: 15%",
                                "Exemplos numéricos corretos e verificáveis: 15%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências aritméticas (aumento aditivo) e geométricas (redução multiplicativa).",
                                "Física: Modelos de fluxo e equilíbrio dinâmico em sistemas (ex: vazão em tubos).",
                                "Economia: Alocação de recursos escassos e convergência para equilíbrio Nash.",
                                "Estatística: Modelagem probabilística de perdas e médias móveis em RTT."
                              ],
                              "realWorldApplication": "O AIMD é o coração do TCP usado em toda internet para downloads (Netflix, Zoom), garantindo que milhões de conexões compartilhem banda sem colapsar redes, como em data centers da AWS ou backbone da Google."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Comparar variantes TCP Tahoe e Reno",
                            "description": "Diferenciar Tahoe (slow start + fast recovery após timeout ou 3 ACKs dup.) de Reno (fast retransmit e recovery parcial com 3 ACKs dup.), destacando melhorias em throughput.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Controle de Congestionamento no TCP",
                                  "subSteps": [
                                    "Explicar o conceito de congestionamento em redes e suas consequências (perda de pacotes, atrasos).",
                                    "Descrever as fases principais: slow start, congestion avoidance, fast retransmit e timeout.",
                                    "Identificar variáveis chave: congestion window (cwnd), slow start threshold (ssthresh) e ACKs duplicados.",
                                    "Exemplificar o impacto de perdas de pacotes por timeout vs. ACKs duplicados.",
                                    "Listar eventos de detecção de perda: timeout ou 3 ACKs duplicados."
                                  ],
                                  "verification": "Listar e explicar corretamente as 4 fases principais do TCP e suas variáveis chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de fases do TCP congestion control",
                                    "Vídeo introdutório sobre TCP (YouTube ou Khan Academy)",
                                    "Notas de aula sobre modelo TCP/IP"
                                  ],
                                  "tips": "Use diagramas para visualizar mudanças em cwnd e ssthresh.",
                                  "learningObjective": "Compreender as bases comuns compartilhadas por Tahoe e Reno.",
                                  "commonMistakes": [
                                    "Confundir fast retransmit (retransmissão) com fast recovery (ajuste de cwnd)",
                                    "Ignorar a distinção entre timeout e ACKs duplicados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Algoritmo TCP Tahoe em Detalhe",
                                  "subSteps": [
                                    "Descrever o comportamento no slow start e congestion avoidance.",
                                    "Explicar reação a timeout: resetar cwnd para 1 MSS, ssthresh para metade do voo.",
                                    "Detalhar reação a 3 ACKs duplicados: tratar como timeout (mesmo reset).",
                                    "Simular gráfico de evolução de cwnd para Tahoe em cenário de perda.",
                                    "Calcular throughput aproximado em uma rede com perdas aleatórias."
                                  ],
                                  "verification": "Desenhar gráfico de cwnd mostrando reset total após 3 ACKs dup ou timeout.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io para gráficos de cwnd",
                                    "Pseudocódigo do Tahoe",
                                    "Simulador simples online de TCP (ex: TCPcongest.io)"
                                  ],
                                  "tips": "Compare com diagrama genérico do TCP para destacar o reset agressivo.",
                                  "learningObjective": "Dominar o mecanismo conservador do Tahoe e suas limitações.",
                                  "commonMistakes": [
                                    "Achar que Tahoe usa fast recovery",
                                    "Não notar que 3 ACKs dup causam slow start completo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Algoritmo TCP Reno em Detalhe",
                                  "subSteps": [
                                    "Revisar herança do Tahoe e introdução do fast recovery.",
                                    "Explicar fast retransmit: retransmitir após 3 ACKs dup sem timeout.",
                                    "Detalhar fast recovery parcial: inflar cwnd para ssthresh + 3 MSS, deflar após ACKs novos.",
                                    "Comparar reação a timeout (igual ao Tahoe).",
                                    "Simular gráfico de cwnd para Reno mostrando recuperação mais rápida."
                                  ],
                                  "verification": "Desenhar gráfico de cwnd ilustrando inflação e deflação no fast recovery.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Pseudocódigo do Reno",
                                    "Gráficos comparativos Tahoe vs Reno (RFC 5681)",
                                    "Simulador ns-3 ou Mininet (opcional)"
                                  ],
                                  "tips": "Foque na 'janela fantasma' criada pelos ACKs dup para entender inflação.",
                                  "learningObjective": "Entender as otimizações do Reno para perdas não-congestionais.",
                                  "commonMistakes": [
                                    "Confundir Reno com NewReno (que lida com ACKs parciais)",
                                    "Esquecer que timeout ainda causa reset total"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Variantes Tahoe e Reno e Avaliar Melhorias",
                                  "subSteps": [
                                    "Tabelar diferenças: reação a 3 ACKs dup (reset Tahoe vs. recovery Reno).",
                                    "Calcular ganho de throughput: Reno evita slow start desnecessário.",
                                    "Discutir cenários: perdas por corrupção vs. congestionamento.",
                                    "Analisar limitações do Reno (ex: múltiplas perdas).",
                                    "Resumir melhorias: maior throughput em redes com perdas aleatórias."
                                  ],
                                  "verification": "Criar tabela comparativa com pelo menos 5 diferenças chave e gráfico de throughput.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela e gráficos",
                                    "RFC 2001 (Tahoe) e RFC 2581 (Reno)",
                                    "Artigo sobre evolução do TCP"
                                  ],
                                  "tips": "Use cenários numéricos: rede com 1% perda para quantificar throughput.",
                                  "learningObjective": "Diferenciar precisamente e quantificar vantagens do Reno sobre Tahoe.",
                                  "commonMistakes": [
                                    "Superestimar Reno em todos cenários (falha em perdas múltiplas)",
                                    "Ignorar que ambas usam multiplicative decrease"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark em uma rede local com iperf: configure perda artificial de pacotes (tc qdisc), capture tráfego TCP, identifique ACKs dup e observe evolução de cwnd para Tahoe (via patch custom) vs Reno padrão, medindo throughput antes/depois perda.",
                              "finalVerifications": [
                                "Explicar diferença exata no tratamento de 3 ACKs duplicados entre Tahoe e Reno.",
                                "Desenhar gráficos precisos de cwnd para ambos em perda por ACKs dup.",
                                "Calcular qualitativamente maior throughput do Reno em rede com 2% perda.",
                                "Identificar quando Tahoe é preferível (raros casos de congestionamento severo).",
                                "Listar 3 limitações do Reno que levaram a variantes posteriores.",
                                "Simular verbalmente fast recovery parcial com números (cwnd=20, perda, ACKs dup)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas descrições de algoritmos (sem confusões entre fases).",
                                "Profundidade na comparação quantitativa (throughput, gráficos).",
                                "Clareza na distinção de eventos de perda (timeout vs. dup ACKs).",
                                "Uso correto de terminologia (fast retransmit, recovery parcial, inflação).",
                                "Capacidade de contextualizar melhorias em cenários reais de rede.",
                                "Criatividade em exemplos práticos ou simulações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos estocásticos de perda de pacotes e análise de throughput (equações de janela).",
                                "Física: Analogia com fluxo de tráfego em rodovias (congestionamento, backpressure).",
                                "Estatística: Probabilidades de ACKs duplicados vs. timeouts em redes ruidosas.",
                                "Economia: Otimização de recursos compartilhados em redes (fairness e eficiência)."
                              ],
                              "realWorldApplication": "O Reno melhorou drasticamente o desempenho da internet inicial (anos 90), permitindo maior throughput em links WAN com perdas por ruído (ex: satélite, wireless antigo), impactando web browsing, email e precursors de streaming; ainda base para TCP moderno em data centers e CDN."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.2",
                              "10.1.2.4.2.4"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Camada de Rede: Protocolo IP",
                    "description": "Aborda o protocolo IP, plano de dados e elementos iniciais de roteamento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Plano de Dados na Camada de Rede",
                        "description": "Explica o papel do plano de dados na camada de rede, focando na entrega de datagramas de forma não confiável e sem conexão, incluindo encapsulamento e forwarding.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Identificar funções do plano de dados",
                            "description": "Diferenciar o plano de dados (forwarding de pacotes) do plano de controle na camada de rede, com ênfase no roteador como dispositivo chave para encaminhamento baseado em tabelas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Plano de Dados e Plano de Controle",
                                  "subSteps": [
                                    "Leia definições oficiais: Plano de Dados gerencia o forwarding de pacotes baseado em headers, Plano de Controle configura rotas e políticas.",
                                    "Estude diagramas da camada de rede mostrando separação lógica dos planos em um roteador.",
                                    "Anote diferenças chave: forwarding reativo vs configuração proativa.",
                                    "Revise exemplos iniciais de pacotes IP sendo processados.",
                                    "Compare com camadas inferiores (enlace) para contextualizar."
                                  ],
                                  "verification": "Resuma em 3 frases as diferenças principais e valide com uma fonte confiável como RFCs ou Cisco docs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama de roteador SDN",
                                    "Documentação Cisco sobre planos de dados/controle",
                                    "Vídeo introdutório sobre camada de rede (5-10 min)"
                                  ],
                                  "tips": [
                                    "Use analogia: Plano de Dados é o 'carteiro' entregando cartas, Plano de Controle é o 'gerente' definindo rotas."
                                  ],
                                  "learningObjective": "Diferenciar conceitualmente os dois planos na camada de rede.",
                                  "commonMistakes": [
                                    "Confundir com planos de outros protocolos (ex: MPLS)",
                                    "Ignorar separação lógica em roteadores tradicionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Funções Específicas do Plano de Dados",
                                  "subSteps": [
                                    "Liste funções: lookup em tabela de roteamento, matching de prefixo IP, determinação de next-hop e saída de porta.",
                                    "Simule forwarding: Dado um pacote IP destino 192.168.1.1, trace o processo de decisão.",
                                    "Estude Longest Prefix Match (LPM) como algoritmo chave.",
                                    "Pratique com ferramentas online de simulação de roteamento.",
                                    "Registre métricas de performance: milhões de pacotes/segundo sem intervenção."
                                  ],
                                  "verification": "Descreva o fluxo de um pacote através do plano de dados em um fluxograma simples.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador Packet Tracer ou GNS3",
                                    "Tabela de roteamento exemplo",
                                    "Tutorial sobre LPM"
                                  ],
                                  "tips": [
                                    "Foquem em hardware acceleration: ASICs para forwarding rápido."
                                  ],
                                  "learningObjective": "Identificar e descrever funções operacionais do forwarding de pacotes.",
                                  "commonMistakes": [
                                    "Achar que plano de dados gerencia rotas (isso é controle)",
                                    "Subestimar velocidade: não é software loop"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Roteador como Dispositivo Chave no Plano de Dados",
                                  "subSteps": [
                                    "Desmonte arquitetura de roteador: datapath (forwarding engine) vs control plane (CPU/Routing protocols).",
                                    "Configure uma tabela de roteamento estática em simulador e teste forwarding.",
                                    "Observe impacto: adicione rota e veja pacotes fluírem.",
                                    "Compare roteador vs switch L2: ênfase em IP routing.",
                                    "Explore forwarding tables: FIB (Forwarding Information Base) vs RIB (Routing Information Base)."
                                  ],
                                  "verification": "Configure um roteador virtual e envie 10 pacotes, confirmando encaminhamento correto via logs.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Cisco Packet Tracer gratuito",
                                    "Roteador virtual em EVE-NG",
                                    "Guia de comandos roteador básicos"
                                  ],
                                  "tips": [
                                    "Use 'show ip route' para visualizar tabela e correlacionar com forwarding."
                                  ],
                                  "learningObjective": "Compreender o roteador como executor principal do plano de dados.",
                                  "commonMistakes": [
                                    "Confundir roteador com hub/switch genérico",
                                    "Ignorar offloading para hardware"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e Integrar Planos de Dados e Controle",
                                  "subSteps": [
                                    "Crie tabela comparativa: Funções, velocidade, exemplos de protocolos (BGP/OSPF no controle).",
                                    "Simule falha: remova rota no controle e observe impacto no dados.",
                                    "Discuta SDN: separação física para escalabilidade.",
                                    "Aplique a cenários: datacenter vs WAN.",
                                    "Teste conhecimento com quiz sobre identificação de funções."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como um pacote usa ambos planos em uma rede.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Tabela comparativa template",
                                    "Quiz online sobre planos de roteador",
                                    "Artigo SDN intro"
                                  ],
                                  "tips": [
                                    "Lembre: Controle atualiza tabela, Dados consulta-a em tempo real."
                                  ],
                                  "learningObjective": "Integrar conhecimentos para identificar funções do plano de dados em contexto.",
                                  "commonMistakes": [
                                    "Achar planos inseparáveis em roteadores legacy",
                                    "Inverter responsabilidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa, um pacote de e-mail de um laptop (10.0.0.5) para servidor nuvem (8.8.8.8) chega ao roteador edge. O plano de dados consulta a tabela de roteamento, matches o prefixo /24 mais longo para next-hop ISP, e encaminha pela porta Gigabit0/1 em <1μs. O plano de controle, rodando OSPF, atualizou essa tabela 5min antes via exchange com vizinhos.",
                              "finalVerifications": [
                                "Defina precisamente funções do plano de dados vs controle.",
                                "Trace um pacote IP através de 3 roteadores, identificando uso do plano de dados.",
                                "Identifique em diagrama qual componente é datapath.",
                                "Explique por que roteadores priorizam hardware para forwarding.",
                                "Diferencie FIB de RIB com exemplo.",
                                "Simule falha de controle e prediga impacto no dados."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 90% acerto em definições chave.",
                                "Exemplos práticos: Pelo menos 2 cenários reais corretos.",
                                "Uso de terminologia: LPM, FIB, next-hop empregados corretamente.",
                                "Compreensão integrada: Explicação clara de interação entre planos.",
                                "Aplicação hands-on: Configuração/simulação bem-sucedida.",
                                "Análise de erros: Identificação de 3+ pitfalls comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos de busca em tabelas (trie para LPM).",
                                "Física: Processamento de sinais em ASICs para alta velocidade.",
                                "Segurança da Informação: ACLs filtradas no datapath.",
                                "Engenharia de Software: Abstrações em SDN controllers.",
                                "Economia: Otimização de custo em data centers via separação de planos."
                              ],
                              "realWorldApplication": "Em provedores de internet como Google ou AWS, roteadores backbone usam plano de dados acelerado por hardware para encaminhar trilhões de pacotes/dia, enquanto controladores centralizados (plano de controle) otimizam rotas globalmente via BGP, garantindo baixa latência e alta disponibilidade em serviços como YouTube ou Cloud Storage."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Descrever o processo de encapsulamento IP",
                            "description": "Explicar como um segmento de transporte é encapsulado em um datagrama IP, incluindo adição de header IP e passagem para a camada de enlace.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Segmento de Transporte Recebido",
                                  "subSteps": [
                                    "Identifique o segmento de transporte (TCP ou UDP) gerado pela camada de transporte, contendo dados do aplicativo e header de transporte.",
                                    "Verifique os campos principais do header de transporte: portas de origem e destino, sequência (para TCP), checksum de transporte.",
                                    "Confirme que o segmento está pronto para encapsulamento, sem erros iniciais nos dados do usuário."
                                  ],
                                  "verification": "Desenhe ou liste os componentes do segmento de transporte em um diagrama simples e confirme com uma referência padrão como RFC 793 (TCP).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Diagrama de camadas OSI/TCP/IP",
                                    "Referência RFC 793 ou 768 (UDP)"
                                  ],
                                  "tips": "Use Wireshark para capturar um segmento real e visualizar seus campos.",
                                  "learningObjective": "Entender a estrutura e o papel do segmento de transporte antes da encapsulamento IP.",
                                  "commonMistakes": "Confundir segmento TCP com datagrama UDP; ignorar que ambos podem ser encapsulados em IP."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Cabeçalho IP",
                                  "subSteps": [
                                    "Defina o comprimento do cabeçalho IP (geralmente 20 bytes para IPv4 básico).",
                                    "Preencha campos obrigatórios: versão (4 para IPv4), IHL, tipo de serviço, comprimento total, ID de identificação, flags, offset de fragmento, TTL, protocolo (6 para TCP, 17 para UDP), header checksum.",
                                    "Adicione endereços IP de origem e destino obtidos da tabela de roteamento.",
                                    "Calcule o checksum do header IP usando soma de palavras de 16 bits com complemento de 1.",
                                    "Marque opções se necessário (ex: timestamp), mas foque no cabeçalho mínimo."
                                  ],
                                  "verification": "Gere um header IP fictício em papel ou ferramenta online e valide o checksum com calculadora hexadecimal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal",
                                    "Ferramenta online de gerador de pacotes IP (ex: Packet Generator)",
                                    "RFC 791 para IPv4"
                                  ],
                                  "tips": "Lembre-se: checksum é calculado apenas no header IP, não nos dados.",
                                  "learningObjective": "Dominar a construção precisa dos campos do cabeçalho IP.",
                                  "commonMistakes": "Esquecer de atualizar comprimento total após adicionar header; erro no cálculo de checksum por overflow incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Anexar Cabeçalho ao Segmento para Formar Datagrama IP",
                                  "subSteps": [
                                    "Posicione o cabeçalho IP imediatamente antes do segmento de transporte.",
                                    "Atualize o campo 'comprimento total' no header IP para somar header + segmento.",
                                    "Recalcule e atualize o checksum do header IP se houver mudanças.",
                                    "Valide a integridade: o datagrama agora tem estrutura IP Header | Transport Header | Dados.",
                                    "Considere fragmentação se o MTU da rede for menor que o datagrama."
                                  ],
                                  "verification": "Crie um diagrama visual do datagrama completo e compare com captura Wireshark de tráfego real.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Wireshark para captura de pacotes",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Visualize como um envelope: header IP é o endereço externo, segmento é a carta interna.",
                                  "learningObjective": "Compreender como o datagrama IP é formado pela concatenação.",
                                  "commonMistakes": "Colocar dados após header de transporte incorretamente; ignorar MTU levando a fragmentação desnecessária."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Passar o Datagrama para a Camada de Enlace",
                                  "subSteps": [
                                    "Consulte a tabela de roteamento para determinar a interface de saída e next-hop.",
                                    "Passe o datagrama completo para a camada de enlace (ex: Ethernet).",
                                    "A camada de enlace adicionará seu próprio header e trailer (ex: MAC origem/destino, CRC).",
                                    "Transmita o frame resultante pela mídia física.",
                                    "Registre logs ou métricas para depuração (ex: TTL decrementado)."
                                  ],
                                  "verification": "Simule em ferramenta como Cisco Packet Tracer e observe o frame saindo para a rede.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Cisco Packet Tracer ou GNS3",
                                    "Diagrama de modelo TCP/IP"
                                  ],
                                  "tips": "TTL previne loops infinitos; decrementado a cada hop.",
                                  "learningObjective": "Entender a transição da camada de rede para enlace.",
                                  "commonMistakes": "Confundir endereços IP com MAC; esquecer que IP não cuida de entrega local."
                                }
                              ],
                              "practicalExample": "Ao enviar um pacote HTTP (TCP porta 80) de seu computador para google.com, o segmento TCP é encapsulado em um datagrama IP com seu IP origem (ex: 192.168.1.10) e destino (142.250.190.14), header IP adicionado, checksum calculado, e passado para Ethernet frame com MAC do roteador gateway.",
                              "finalVerifications": [
                                "Descrever verbalmente ou por escrito a sequência: segmento -> +header IP -> datagrama -> camada enlace.",
                                "Listar e explicar 5 campos principais do header IP com valores exemplo.",
                                "Calcular corretamente checksum de um header IP simples.",
                                "Desenhar diagrama preciso do encapsulamento.",
                                "Explicar impacto de TTL=1 em um datagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos campos IP e ordem de adição (90% correto).",
                                "Correção no cálculo de checksum e comprimento total.",
                                "Clareza no diagrama visual do processo.",
                                "Compreensão de transição para camada de enlace sem confusões.",
                                "Uso correto de terminologia (datagrama vs segmento vs frame)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de checksum com aritmética modular e soma em complemento de 1.",
                                "Física: Transmissão de bits pela mídia física após encapsulamento.",
                                "Segurança da Informação: Campos como TTL e protocolo para mitigar ataques.",
                                "Programação: Uso de sockets em Python (socket.AF_INET) para observar encapsulamento."
                              ],
                              "realWorldApplication": "Todo tráfego IPv4 na internet, como streaming Netflix ou chamadas Zoom, depende do encapsulamento IP para rotear pacotes globalmente, garantindo entrega confiável de dados de uma rede para outra."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Analisar o forwarding em roteadores",
                            "description": "Detalhar o processo de lookup em tabela de roteamento de longa duração (longest prefix matching) para determinar a saída de um datagrama IP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Datagrama IP de Entrada",
                                  "subSteps": [
                                    "Receba o datagrama IP na interface de entrada do roteador.",
                                    "Extraia o cabeçalho IP do datagrama.",
                                    "Identifique o campo de endereço IP de destino (32 bits para IPv4).",
                                    "Converta o endereço de destino para representação binária.",
                                    "Verifique campos relacionados como TTL para descartes iniciais."
                                  ],
                                  "verification": "Confirme a extração correta do endereço de destino e sua conversão binária, comparando com um exemplo conhecido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo de datagrama IP (ferramenta como Wireshark ou diagrama)",
                                    "Conversor IP para binário (online ou calculadora)"
                                  ],
                                  "tips": "Trabalhe sempre em binário desde o início para evitar erros de matching posterior.",
                                  "learningObjective": "Extrair e preparar o endereço IP de destino para o processo de lookup na tabela de roteamento.",
                                  "commonMistakes": [
                                    "Confundir endereço de origem (source) com destino (destination)",
                                    "Ignorar a necessidade de conversão binária, usando decimal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar e Preparar a Tabela de Roteamento",
                                  "subSteps": [
                                    "Liste todas as entradas da tabela de roteamento: prefixo de rede, length do prefixo, máscara, next-hop e interface de saída.",
                                    "Converta cada prefixo de rede para representação binária.",
                                    "Calcule ou confirme a máscara de rede correspondente para cada entrada (ex: /24 = 255.255.255.0).",
                                    "Identifique entradas especiais como rota default (0.0.0.0/0).",
                                    "Ordene as entradas por comprimento de prefixo decrescente para facilitar o matching."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito a tabela completa em formato binário, destacando prefix lengths.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo de tabela de roteamento (Cisco IOS show ip route ou tabela simulada)",
                                    "Ferramenta de conversão IP/binário",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Mantenha a tabela organizada em uma tabela visual para visualização rápida de prefix lengths.",
                                  "learningObjective": "Compreender a estrutura e preparação da tabela de roteamento para longest prefix matching.",
                                  "commonMistakes": [
                                    "Esquecer de converter prefixos para binário",
                                    "Ignorar a rota default como fallback"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Longest Prefix Matching (LPM)",
                                  "subSteps": [
                                    "Para cada entrada da tabela (começando pelo maior prefix length), aplique operação bitwise AND entre o destino e a máscara do prefixo.",
                                    "Verifique se o resultado do AND coincide exatamente com o prefixo da entrada.",
                                    "Registre todos os matches válidos e selecione o de maior prefix length.",
                                    "Se múltiplos matches com mesmo length, use critérios de tie-breaker (ex: administrative distance).",
                                    "Caso nenhum match, selecione a rota default."
                                  ],
                                  "verification": "Justifique o match selecionado, mostrando cálculos AND e comparando prefix lengths.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora bitwise ou simulador (Packet Tracer, GNS3)",
                                    "Tabela de roteamento preparada do step 2"
                                  ],
                                  "tips": "Comece sempre pelo prefixo mais longo (/32) para eficiência simulada.",
                                  "learningObjective": "Aplicar o algoritmo de longest prefix matching para identificar a melhor rota.",
                                  "commonMistakes": [
                                    "Selecionar match incorreto por erro no AND bitwise",
                                    "Parar no primeiro match sem verificar longer prefixes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar e Simular o Forwarding Final",
                                  "subSteps": [
                                    "Identifique o next-hop IP e a interface de saída baseada no match LPM.",
                                    "Decrementar o campo TTL no cabeçalho IP (se >1).",
                                    "Atualize o cabeçalho IP se necessário (ex: recalcular checksum).",
                                    "Reencapsule o datagrama e envie pela interface de saída determinada.",
                                    "Registre o resultado: next-hop, interface e motivo da escolha."
                                  ],
                                  "verification": "Simule o forwarding completo e produza um log ou diagrama mostrando o caminho de saída.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Simulador de rede (Cisco Packet Tracer ou GNS3)",
                                    "Diagrama de rede topológica"
                                  ],
                                  "tips": "Lembre-se: roteadores não modificam o endereço de destino, apenas encaminham.",
                                  "learningObjective": "Concluir o processo de forwarding com base no resultado do LPM.",
                                  "commonMistakes": [
                                    "Esquecer de decrementar TTL",
                                    "Confundir next-hop com interface de saída"
                                  ]
                                }
                              ],
                              "practicalExample": "Datagrama destino: 192.168.1.100 (bin: 11000000.10101000.00000001.01100100). Tabela: 192.168.1.0/24 (máscara 255.255.255.0) -> next-hop 192.168.1.1 int0; 192.168.0.0/16 (255.255.0.0) -> next-hop 192.168.0.1 int1; 0.0.0.0/0 -> default. AND /24 matches prefixo exatamente (maior length), saída int0.",
                              "finalVerifications": [
                                "Explicar o processo de LPM em suas próprias palavras.",
                                "Resolver corretamente um exemplo com tabela de 5 entradas.",
                                "Identificar quando usar rota default.",
                                "Simular forwarding para 3 datagramas diferentes na mesma tabela.",
                                "Diferenciar LPM de exact match."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos bitwise AND (100% correto).",
                                "Seleção correta do longest prefix (justificada).",
                                "Compreensão de tie-breakers e default route.",
                                "Clareza na descrição do forwarding final.",
                                "Eficiência na simulação (tempo e recursos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise (AND) e representação binária.",
                                "Algoritmos e Estruturas de Dados: Uso de Trie ou Patricia Trie para LPM eficiente em hardware.",
                                "Segurança da Informação: Vulnerabilidades como BGP hijacking afetando tabelas de roteamento.",
                                "Física: Propagação de sinais em links de rede durante forwarding."
                              ],
                              "realWorldApplication": "Em roteadores da internet (ex: Cisco ASR na backbone da Internet), o LPM permite encaminhar trilhões de pacotes por dia escalavelmente, determinando rotas otimizadas para serviços como streaming Netflix ou navegação web global."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Estrutura do Protocolo IP",
                        "description": "Aborda a versão IPv4, estrutura do header IP, campos principais e mecanismos como TTL e fragmentação.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Listar campos do header IPv4",
                            "description": "Identificar e descrever os campos principais do header IPv4: versão, comprimento do header, tipo de serviço, comprimento total, ID, flags, offset de fragmento, TTL, protocolo, checksum, endereços IP origem e destino.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Visualizar e compreender a estrutura geral do header IPv4",
                                  "subSteps": [
                                    "Pesquise o diagrama padrão do header IPv4 no RFC 791 ou Wireshark documentation.",
                                    "Desenhe o header à mão, marcando os 20 bytes e dividindo em campos de 4 bits, 8 bits, 16 bits e 32 bits.",
                                    "Identifique o número total de campos principais (12) e seus tamanhos em bits.",
                                    "Compare com header IPv6 para destacar diferenças básicas.",
                                    "Anote a ordem de leitura: da esquerda para direita, topo para baixo."
                                  ],
                                  "verification": "Você pode desenhar o header completo com todos os campos rotulados corretamente sem consultar referências.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso à internet para RFC 791",
                                    "Ferramenta de desenho digital opcional como Draw.io"
                                  ],
                                  "tips": [
                                    "Use cores diferentes para grupos de campos (controle, fragmentação, endereços).",
                                    "Memorize que o header mínimo é 20 bytes (IHL=5)."
                                  ],
                                  "learningObjective": "Entender o layout físico e a organização dos 20 bytes do header IPv4.",
                                  "commonMistakes": [
                                    "Confundir ordem dos campos.",
                                    "Esquecer que alguns campos são opções e afetam o IHL."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever os campos iniciais de controle: Versão, IHL, Tipo de Serviço e Comprimento Total",
                                  "subSteps": [
                                    "Versão (4 bits): Estude valores (4 para IPv4) e como indica a versão do protocolo.",
                                    "IHL (4 bits): Aprenda que indica comprimento do header em palavras de 32 bits (mínimo 5=20 bytes).",
                                    "Tipo de Serviço/DSCP/ECN (8 bits): Descreva priorização e controle de congestão.",
                                    "Comprimento Total (16 bits): Entenda que inclui header + dados (máx 65.535 bytes).",
                                    "Crie uma tabela com tamanho, posição e função de cada um."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a função e tamanho de cada campo sem erros.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Tabela em Excel ou papel",
                                    "Documentação IPv4 de sites como Cisco ou Wikipedia"
                                  ],
                                  "tips": [
                                    "Lembre: IHL conta palavras de 32 bits, não bytes.",
                                    "Pratique convertendo IHL de decimal para bytes (ex: 5*4=20)."
                                  ],
                                  "learningObjective": "Dominar os 4 primeiros campos e sua importância no processamento inicial do pacote.",
                                  "commonMistakes": [
                                    "Confundir ToS com QoS moderno (é predecessor do DSCP).",
                                    "Achar que Comprimento Total é só dados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar campos de fragmentação e controle de rota: ID, Flags, Offset, TTL e Protocolo",
                                  "subSteps": [
                                    "ID (16 bits): Entenda uso para reassembly de fragmentos.",
                                    "Flags (3 bits): Descreva Reserved, DF (Don't Fragment), MF (More Fragments).",
                                    "Offset de Fragmento (13 bits): Aprenda cálculo em unidades de 8 bytes.",
                                    "TTL (8 bits): Estude decremento por roteador para evitar loops.",
                                    "Protocolo (8 bits): Liste valores comuns (1=ICMP, 6=TCP, 17=UDP)."
                                  ],
                                  "verification": "Simule um cenário de fragmentação e liste valores corretos para cada campo.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Calculadora para offset",
                                    "Lista de números de protocolo IANA"
                                  ],
                                  "tips": [
                                    "Offset é múltiplo de 8 bytes; teste com exemplos numéricos.",
                                    "TTL inicia em 64 ou 128 tipicamente."
                                  ],
                                  "learningObjective": "Compreender mecanismos de fragmentação, roteamento e identificação de payload.",
                                  "commonMistakes": [
                                    "Ignorar que flags + offset = 16 bits (3+13).",
                                    "Confundir Protocolo com porta (é protocolo de camada superior)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar campos de integridade e endereçamento: Checksum, IP Origem e Destino",
                                  "subSteps": [
                                    "Checksum (16 bits): Aprenda algoritmo de soma de complemento de 1 (apenas header).",
                                    "Endereço IP Origem (32 bits): Descreva formato IPv4 dotted decimal.",
                                    "Endereço IP Destino (32 bits): Entenda uso para roteamento final.",
                                    "Calcule manualmente um checksum simples de exemplo.",
                                    "Diferencie origem/destino em cenários de roteamento."
                                  ],
                                  "verification": "Calcule checksum de um header de exemplo e liste endereços corretamente.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal",
                                    "Ferramenta online de checksum IPv4 para verificação"
                                  ],
                                  "tips": [
                                    "Checksum é recalculado em cada hop.",
                                    "Pratique conversão IP binário-decimal."
                                  ],
                                  "learningObjective": "Mestre os campos finais para verificação de integridade e entrega.",
                                  "commonMistakes": [
                                    "Incluir dados no checksum.",
                                    "Confundir origem com destino em fluxos unidirecionais."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture tráfego ping (ICMP): filtre 'ip', expanda o header IPv4 e rotule cada campo (ex: Version=4, TTL=64, Protocol=1, Source=192.168.1.1, Dest=8.8.8.8), explicando valores observados.",
                              "finalVerifications": [
                                "Liste os 12 campos principais com tamanhos exatos em bits.",
                                "Descreva a função de cada campo em uma frase.",
                                "Desenhe o header completo com labels.",
                                "Explique como TTL previne loops infinitos.",
                                "Calcule offset de fragmento para um pacote dividido.",
                                "Identifique protocolo de um campo de 8 bits (ex: 6=TCP)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os campos e tamanhos (100% correto).",
                                "Correção nas descrições funcionais (sem omissões chave).",
                                "Capacidade de aplicar conceitos em exemplos reais (Wireshark).",
                                "Compreensão de interdependências (ex: IHL e opções).",
                                "Habilidade em cálculos manuais (checksum, offset).",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações binárias, soma de 16 bits e conversões hex/dec/bin para checksum e offsets.",
                                "Segurança da Informação: Importância do checksum para detecção de erros e TTL contra ataques de loop.",
                                "Programação: Parsing de headers em linguagens como Python (scapy) ou C para análise de pacotes.",
                                "Física: Transmissão de bits em redes físicas e impacto do tamanho de pacote na latência.",
                                "Lógica e Algoritmos: Lógica de fragmentação e reassembly como problema de divisão/conjunção."
                              ],
                              "realWorldApplication": "Roteadores leem Destination IP e decrementam TTL para encaminhar pacotes eficientemente; firewalls inspecionam Protocolo e Flags para bloquear fragmentos maliciosos; ferramentas como traceroute usam TTL para mapear caminhos de rede."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Explicar mecanismo de TTL",
                            "description": "Descrever o campo Time To Live (TTL) e seu papel na prevenção de loops infinitos em roteamento, decrementando em cada hop.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a localização e definição do campo TTL no cabeçalho IP",
                                  "subSteps": [
                                    "Analise o cabeçalho IPv4, identificando os 20 bytes iniciais e a posição do campo TTL (byte 8).",
                                    "Leia a RFC 791 para confirmar que TTL é um campo de 8 bits (0-255).",
                                    "Entenda que TTL significa 'Time To Live', originalmente em segundos, mas agora em hops.",
                                    "Visualize o cabeçalho IP usando uma ferramenta como Wireshark em um pacote real.",
                                    "Anote o valor inicial típico definido pelo SO (ex: 64 no Linux, 128 no Windows)."
                                  ],
                                  "verification": "Capture um pacote com Wireshark e confirme a localização e valor inicial do TTL.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 791 (IPv4)",
                                    "Wireshark ou tcpdump",
                                    "Diagrama do cabeçalho IP"
                                  ],
                                  "tips": "Use diagramas coloridos para destacar o campo TTL no cabeçalho.",
                                  "learningObjective": "Identificar precisamente o campo TTL no cabeçalho IP e seu propósito inicial.",
                                  "commonMistakes": [
                                    "Confundir TTL com outros campos como Identification ou Flags.",
                                    "Achar que TTL é sempre em segundos em vez de hops."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o mecanismo de decremento do TTL em cada hop",
                                  "subSteps": [
                                    "Simule um roteador recebendo um pacote: leia TTL atual e decremente em 1 antes de encaminhar.",
                                    "Teste com comando 'ping' entre hosts e observe TTL decrescendo em traceroute.",
                                    "Entenda que cada roteador (hop) executa: if TTL > 0 then TTL--, forward; else discard.",
                                    "Registre valores de TTL em uma rota com 3-4 hops usando traceroute.",
                                    "Compare valores iniciais de diferentes SOs e como afetam o alcance máximo (255 hops)."
                                  ],
                                  "verification": "Execute traceroute e liste os valores de TTL decrescentes em pelo menos 3 hops.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Comando traceroute ou tracert",
                                    "Rede local ou internet para testes",
                                    "Terminal de comando"
                                  ],
                                  "tips": "Use traceroute com opções verbose para ver TTL explicitamente.",
                                  "learningObjective": "Descrever o processo de decremento passo a passo em roteadores.",
                                  "commonMistakes": [
                                    "Pensar que TTL é decrementado pelo host de origem.",
                                    "Ignorar que switches L2 não afetam TTL, só roteadores L3."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o tratamento quando TTL atinge zero",
                                  "subSteps": [
                                    "Simule pacote chegando com TTL=0: roteador descarta e envia ICMP Time Exceeded (Type 11, Code 0).",
                                    "Capture o ICMP com Wireshark para verificar a mensagem de erro.",
                                    "Entenda que isso previne pacotes 'zumbis' circulando indefinidamente.",
                                    "Teste forçando TTL baixo (ex: ping -h 1) e observe o ICMP de volta.",
                                    "Discuta impacto: perda de pacote, mas notificação ao remetente."
                                  ],
                                  "verification": "Capture e analise um pacote ICMP Time Exceeded após TTL=0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Comando ping com opção TTL baixa (ex: ping -t 1 no Windows)"
                                  ],
                                  "tips": "Filtre Wireshark por 'icmp.type == 11' para isolar mensagens TTL.",
                                  "learningObjective": "Explicar o protocolo de erro ICMP gerado por TTL expirado.",
                                  "commonMistakes": [
                                    "Confundir com ICMP Destination Unreachable.",
                                    "Achar que pacote é reenviado com TTL=0."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o papel do TTL na prevenção de loops de roteamento",
                                  "subSteps": [
                                    "Desenhe um diagrama de loop (A->B->C->A) sem TTL: pacotes circulam para sempre.",
                                    "Adicione TTL: pacote morre após hops = valor inicial, quebrando o loop.",
                                    "Compare com protocolos como RIP que usam TTL similarmente.",
                                    "Discuta cenários reais: falha de roteador criando loop temporário.",
                                    "Crie uma simulação simples em ferramenta como Cisco Packet Tracer."
                                  ],
                                  "verification": "Desenhe e explique um diagrama de loop prevenido por TTL.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Cisco Packet Tracer ou GNS3",
                                    "Papel e caneta para diagrama",
                                    "Exemplos de topologias de rede"
                                  ],
                                  "tips": "Simule loop em Packet Tracer configurando rotas circulares.",
                                  "learningObjective": "Demonstrar como TTL garante terminação de pacotes em loops.",
                                  "commonMistakes": [
                                    "Subestimar necessidade: achar que protocolos detectam loops automaticamente.",
                                    "Confundir com mecanismos de OSPF/BGP como split horizon."
                                  ]
                                }
                              ],
                              "practicalExample": "Execute 'traceroute google.com' e observe TTL decrescendo de 64 para 1 em cada hop; quando um roteador recebe TTL=1, decrementa para 0, descarta e envia ICMP, visível como '*' ou tempo alto na saída.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo de um pacote IP com TTL em uma rota de 5 hops.",
                                "Desenhar diagrama do cabeçalho IP destacando TTL e simular decremento.",
                                "Executar traceroute e interpretar saída, identificando TTL em pelo menos 3 hops.",
                                "Simular loop em Packet Tracer e mostrar pacote morrendo por TTL.",
                                "Analisar captura Wireshark de ICMP Time Exceeded.",
                                "Comparar TTL em IPv4 vs IPv6 (Hop Limit)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do campo TTL (posição, tamanho, unidades).",
                                "Correta explicação do decremento e geração de ICMP.",
                                "Demonstração clara da prevenção de loops com exemplo visual.",
                                "Uso correto de ferramentas como Wireshark/traceroute.",
                                "Completude: cobrir todos os aspectos (definição, mecanismo, erro, importância).",
                                "Clareza na comunicação, sem jargões desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Contadores decrescentes e limites finitos (aritmética modular).",
                                "Segurança da Informação: Mecanismos de proteção contra falhas de rede.",
                                "Física: Analogia com decaimento de partículas ou sinal atenuando.",
                                "Programação: Implementar TTL em sockets Python (setsockopt).",
                                "Gestão de Projetos: Importância de safeguards em sistemas distribuídos."
                              ],
                              "realWorldApplication": "Em data centers, TTL previne blackholes em falhas de roteamento; administradores usam traceroute para diagnosticar caminhos e timeouts causados por TTL baixo em rotas longas internacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Entender fragmentação IP",
                            "description": "Explicar quando e como ocorre a fragmentação de datagramas IP em roteadores ou hosts, incluindo reassembly no destino final.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceitos Básicos de Fragmentação IP",
                                  "subSteps": [
                                    "Estude o que é um datagrama IP e seu tamanho máximo típico (65.535 bytes).",
                                    "Aprenda sobre MTU (Maximum Transmission Unit) e como ela varia por link de rede (ex: Ethernet 1500 bytes).",
                                    "Identifique quando a fragmentação ocorre: datagrama maior que MTU em roteadores ou hosts.",
                                    "Entenda o papel dos roteadores na fragmentação intermediária e hosts no envio inicial.",
                                    "Diferencie fragmentação IP de segmentação TCP (camadas diferentes)."
                                  ],
                                  "verification": "Resuma em 3 frases por que e quando fragmentação é necessária.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 791 (IP)",
                                    "Diagramas de MTU online"
                                  ],
                                  "tips": "Sempre relacione MTU ao link físico para contextualizar.",
                                  "learningObjective": "Compreender triggers e necessidade de fragmentação IP.",
                                  "commonMistakes": "Confundir fragmentação com encapsulamento ou assumir que hosts nunca fragmentam."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Campos do Cabeçalho IP para Fragmentação",
                                  "subSteps": [
                                    "Analise o campo Total Length (16 bits) no cabeçalho IP.",
                                    "Estude Identification (16 bits) para agrupar fragmentos.",
                                    "Aprenda Flags: DF (Don't Fragment), MF (More Fragments) e Reserved.",
                                    "Entenda Fragment Offset (13 bits) para posição do fragmento em unidades de 8 bytes.",
                                    "Revise Header Checksum e como ele é recalculado por fragmento."
                                  ],
                                  "verification": "Desenhe o cabeçalho IP destacando os 4 campos de fragmentação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark para capturar pacotes",
                                    "RFC 791 seção 3.1"
                                  ],
                                  "tips": "Lembre: Offset é em múltiplos de 8 bytes para economizar bits.",
                                  "learningObjective": "Identificar e explicar campos IP cruciais para fragmentação.",
                                  "commonMistakes": "Ignorar que DF bloqueia fragmentação ou confundir MF com fim de fragmentos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processo de Fragmentação",
                                  "subSteps": [
                                    "Simule cálculo: Divida datagrama em fragmentos respeitando MTU (cabeçalho incluso).",
                                    "Configure primeiro fragmento: Offset=0, MF=1 (se mais fragmentos).",
                                    "Configure fragmentos intermediários: Offset calculado, MF=1.",
                                    "Último fragmento: MF=0, ajuste Total Length.",
                                    "Verifique reenvio de cada fragmento independentemente."
                                  ],
                                  "verification": "Calcule fragmentos para datagrama de 4000 bytes em MTU 1500.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora binária",
                                    "Ferramenta online de fragmentação IP"
                                  ],
                                  "tips": "Garanta que soma de offsets *8 + lengths = tamanho original.",
                                  "learningObjective": "Executar fragmentação passo a passo com cálculos precisos.",
                                  "commonMistakes": "Esquecer cabeçalho IP (20 bytes) no cálculo de payload por fragmento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reassembly e Tratamento de Erros",
                                  "subSteps": [
                                    "Explique reassembly no destino: Buffer por Identification + origem/destino.",
                                    "Ordene fragmentos por Offset e verifique MF=0 no último.",
                                    "Recalcule checksum final e monte datagrama original.",
                                    "Discuta timeouts para fragmentos perdidos e ICMP 'Fragment Reassembly Time Exceeded'.",
                                    "Entenda que reassembly é só no destino final, não intermediários."
                                  ],
                                  "verification": "Descreva fluxo de reassembly com exemplo numérico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Exemplos Wireshark"
                                  ],
                                  "tips": "Use timers para evitar buffers eternos em hosts.",
                                  "learningObjective": "Dominar montagem de fragmentos e detecção de falhas.",
                                  "commonMistakes": "Achar que roteadores fazem reassembly ou ignorar perdas de fragmentos."
                                }
                              ],
                              "practicalExample": "Envie um ping com tamanho 4000 bytes (-s 3980 para cabeçalho) via rede com MTU 1500. Capture no Wireshark: veja 3 fragmentos com Identification igual, offsets 0/1852/3704 (em bytes/8), MF=1 nos primeiros e MF=0 no último. No destino, reasseemble para ping original.",
                              "finalVerifications": [
                                "Explicar corretamente triggers de fragmentação (MTU < datagrama).",
                                "Identificar e decodificar flags MF/DF e offset em captura Wireshark.",
                                "Calcular fragmentos exatos para exemplo dado.",
                                "Descrever reassembly sem erros de ordenação ou checksum.",
                                "Diferenciar fragmentação IP de outros mecanismos de divisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos campos IP (flags, offset, ID) - 25%.",
                                "Cálculos corretos de fragmentação/reassembly - 30%.",
                                "Explicação clara de quando/onde ocorre - 20%.",
                                "Tratamento de erros (perdas, DF) - 15%.",
                                "Exemplo prático demonstrado - 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações binárias e divisão modular para offsets.",
                                "Física: Limites de sinal em cabos/rede (MTU relacionado a hardware).",
                                "Segurança da Informação: Ataques de fragmentação (Teardrop).",
                                "Estatística: Probabilidade de perda de fragmentos em redes reais."
                              ],
                              "realWorldApplication": "Na Internet, datagramas grandes (ex: vídeos) são fragmentados em links de baixa MTU (ex: túneis VPN ou satélites), permitindo interoperabilidade entre Ethernet, Wi-Fi e fibra, com reassembly garantindo apps como streaming funcionem sem conhecimento da fragmentação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Elementos Iniciais de Roteamento",
                        "description": "Introduz conceitos básicos de roteamento na camada IP, incluindo tabelas de roteamento e introdução ao plano de controle.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Interpretar tabela de roteamento IP",
                            "description": "Analisar uma tabela de roteamento simples, entendendo colunas como destino, máscara, next hop e interface de saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Tabela de Roteamento",
                                  "subSteps": [
                                    "Defina o que é uma tabela de roteamento: uma estrutura de dados que um roteador usa para decidir para onde encaminhar pacotes IP.",
                                    "Explique o propósito: mapear endereços de destino para o próximo salto (next hop) ou interface de saída.",
                                    "Identifique componentes principais: rotas aprendidas via protocolos dinâmicos ou configuradas estaticamente.",
                                    "Diferencie rota padrão (default route) de rotas específicas.",
                                    "Revise conceitos de rede IP: endereços IP, sub-redes e máscaras."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é uma tabela de roteamento e seus componentes principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de roteador simples",
                                    "Glossário de termos de roteamento IP"
                                  ],
                                  "tips": "Use analogias como um mapa de estradas onde destinos são cidades e next hops são interseções.",
                                  "learningObjective": "Compreender o papel e estrutura geral de uma tabela de roteamento IP.",
                                  "commonMistakes": [
                                    "Confundir tabela de roteamento com tabela ARP",
                                    "Ignorar a importância da rota padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar as Colunas Principais da Tabela",
                                  "subSteps": [
                                    "Analise a coluna 'Destino' (Destination): rede ou host de destino em notação CIDR ou com máscara.",
                                    "Entenda 'Máscara' (Netmask): bits que definem a porção de rede no endereço IP (ex: /24 ou 255.255.255.0).",
                                    "Examine 'Next Hop': endereço IP do roteador seguinte ou 'directly connected' para interfaces locais.",
                                    "Identifique 'Interface de Saída' (Exit Interface): porta física ou lógica usada para enviar o pacote.",
                                    "Compare rotas: a mais específica (maior máscara) tem precedência."
                                  ],
                                  "verification": "Descreva o significado de cada coluna usando uma tabela de exemplo vazia.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de tabela de roteamento em texto ou imagem",
                                    "Calculadora de sub-redes online"
                                  ],
                                  "tips": "Converta máscaras para binário para visualizar melhor a especificidade.",
                                  "learningObjective": "Dominar o significado e interpretação de cada coluna chave.",
                                  "commonMistakes": [
                                    "Confundir next hop com destino final",
                                    "Ignorar a precedência de rotas mais específicas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar uma Tabela de Roteamento Exemplo",
                                  "subSteps": [
                                    "Obtenha uma tabela de exemplo: ex. Destination 192.168.1.0/24 Next Hop 10.0.0.2 Interface Gig0/0.",
                                    "Liste todas as rotas e classifique-as (conectada, estática, dinâmica).",
                                    "Para um IP destino dado (ex: 192.168.1.10), encontre a melhor rota comparando máscaras.",
                                    "Trace o caminho: determine next hop e interface para múltiplos destinos.",
                                    "Identifique a rota padrão (0.0.0.0/0)."
                                  ],
                                  "verification": "Preencha uma tabela de roteamento com anotações explicando cada rota.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador como Packet Tracer ou tabela impressa",
                                    "Lista de IPs de teste"
                                  ],
                                  "tips": "Sempre comece pela rota mais longa (maior número de bits de máscara).",
                                  "learningObjective": "Aplicar interpretação em uma tabela realista.",
                                  "commonMistakes": [
                                    "Escolher rota errada por não comparar máscaras corretamente",
                                    "Esquecer rotas conectadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Interpretação com Cenários de Encaminhamento",
                                  "subSteps": [
                                    "Simule encaminhamento de pacotes: dado IP origem/destino, encontre next hop.",
                                    "Resolva ambiguidades: múltiplas rotas candidatas e escolha a correta.",
                                    "Analise impacto de adicionar/remover rotas.",
                                    "Compare tabelas antes/depois de mudanças de configuração.",
                                    "Teste com roteamento floating ou backup."
                                  ],
                                  "verification": "Resolva 5 cenários de encaminhamento corretamente em um quiz.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta Cisco Packet Tracer ou GNS3",
                                    "Worksheets com cenários"
                                  ],
                                  "tips": "Pense como o roteador: 'Qual a rota mais específica que combina?'",
                                  "learningObjective": "Resolver problemas práticos de interpretação de roteamento.",
                                  "commonMistakes": [
                                    "Não considerar rotas administrativamente distantes",
                                    "Confundir interface com next hop em redes ponto-a-ponto"
                                  ]
                                }
                              ],
                              "practicalExample": "Tabela exemplo: \nDestino | Máscara | Next Hop | Interface\n192.168.1.0 | 255.255.255.0 | - | Fa0/0\n10.0.0.0 | 255.255.255.0 | - | Fa0/1\n0.0.0.0 | 0.0.0.0 | 10.0.0.2 | Fa0/1\nPara pacote destino 192.168.1.10: usa rota conectada Fa0/0 (mais específica). Para 172.16.1.1: usa default next hop 10.0.0.2 via Fa0/1.",
                              "finalVerifications": [
                                "Explicar corretamente todas as colunas de uma tabela fornecida.",
                                "Identificar a melhor rota para 3 IPs de destino diferentes.",
                                "Diferenciar rotas conectadas, estáticas e dinâmicas.",
                                "Converter máscara /24 para notação decimal e vice-versa.",
                                "Simular encaminhamento de pacote passo a passo.",
                                "Detectar e corrigir erros em uma tabela mal interpretada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de colunas e seus significados (30%)",
                                "Correta seleção da melhor rota baseada em especificidade (30%)",
                                "Capacidade de traçar caminhos de encaminhamento (20%)",
                                "Uso correto de terminologia de roteamento IP (10%)",
                                "Análise de cenários práticos sem erros (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações binárias para máscaras de sub-rede e longest prefix matching.",
                                "Lógica e Algoritmos: Processos de decisão sequencial semelhantes a árvores de decisão.",
                                "Física: Analogia com sinais elétricos em interfaces de rede.",
                                "Segurança da Informação: Interpretação de rotas em contextos de firewalls e ACLs."
                              ],
                              "realWorldApplication": "Em data centers e ISPs, administradores usam 'show ip route' no Cisco IOS para diagnosticar falhas de conectividade, otimizar tráfego e configurar redundância, garantindo que pacotes cheguem ao destino correto na internet global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Diferenciar roteamento estático e dinâmico",
                            "description": "Comparar roteamento estático (configurado manualmente) com dinâmico (protocolos como RIP ou OSPF), focando no contexto IP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Roteamento Estático",
                                  "subSteps": [
                                    "Defina roteamento estático como rotas configuradas manualmente pelo administrador de rede.",
                                    "Explique que as rotas estáticas não mudam automaticamente e requerem intervenção humana para atualizações.",
                                    "Liste as vantagens: simplicidade, baixo uso de CPU e memória, maior controle de segurança.",
                                    "Liste as desvantagens: não escalável para grandes redes, falha em detectar mudanças topológicas automaticamente.",
                                    "Identifique cenários ideais: redes pequenas e estáveis."
                                  ],
                                  "verification": "Crie um diagrama simples de uma rede com rotas estáticas e explique cada rota.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação oficial do protocolo IP (RFCs)",
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias como 'mapa fixo' para visualizar a rigidez do roteamento estático.",
                                  "learningObjective": "Dominar a definição, configuração e trade-offs do roteamento estático no contexto IP.",
                                  "commonMistakes": [
                                    "Confundir com rotas padrão (default route)",
                                    "Ignorar o impacto em redes com topologia em mudança",
                                    "Esquecer de configurar rotas de retorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os Conceitos Básicos de Roteamento Dinâmico",
                                  "subSteps": [
                                    "Defina roteamento dinâmico como rotas aprendidas e atualizadas automaticamente via protocolos como RIP, OSPF ou BGP.",
                                    "Descreva o funcionamento: roteadores trocam informações de tabela de roteamento periodicamente.",
                                    "Liste vantagens: escalabilidade, adaptação automática a falhas, convergência rápida.",
                                    "Liste desvantagens: maior uso de recursos (CPU, banda), complexidade de configuração e potenciais loops.",
                                    "Compare brevemente protocolos: RIP (distância-vetor simples), OSPF (estado de link avançado)."
                                  ],
                                  "verification": "Desenhe um fluxograma do processo de troca de mensagens em um protocolo dinâmico como RIP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tutoriais de RIP/OSPF no site Cisco Networking Academy",
                                    "Packet Tracer com roteadores pré-configurados",
                                    "Vídeos explicativos sobre protocolos de roteamento"
                                  ],
                                  "tips": "Pense em roteamento dinâmico como 'GPS que se atualiza sozinho' para contrastar com estático.",
                                  "learningObjective": "Entender o mecanismo, protocolos e trade-offs do roteamento dinâmico.",
                                  "commonMistakes": [
                                    "Confundir todos os protocolos dinâmicos como iguais",
                                    "Subestimar o overhead de tráfego gerado",
                                    "Ignorar configurações mínimas como autenticação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Contrastar Roteamento Estático e Dinâmico",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: configuração, escalabilidade, convergência, uso de recursos, segurança.",
                                    "Analise métricas: custo (hop count em RIP vs. largura de banda em OSPF).",
                                    "Discuta cenários híbridos: usar estático para rotas críticas e dinâmico para o resto.",
                                    "Avalie impacto no protocolo IP: ambos operam na camada de rede, mas dinâmico usa pacotes de atualização.",
                                    "Simule uma falha: compare tempo de recuperação em cada tipo."
                                  ],
                                  "verification": "Preencha e explique uma tabela de comparação com pelo menos 6 critérios.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabela",
                                    "Packet Tracer para simulação de falha",
                                    "Artigos comparativos sobre roteamento"
                                  ],
                                  "tips": "Use cores na tabela para destacar prós (verde) e contras (vermelho) visualmente.",
                                  "learningObjective": "Capacitar a diferenciação clara entre os dois tipos de roteamento.",
                                  "commonMistakes": [
                                    "Focar só em vantagens sem contras equilibrados",
                                    "Não considerar tamanho da rede no contexto",
                                    "Confundir roteamento dinâmico com balanceamento de carga"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Conhecimento em um Cenário Prático",
                                  "subSteps": [
                                    "Configure roteamento estático em uma topologia simples de 3 roteadores.",
                                    "Substitua por roteamento dinâmico (ex: RIP) e observe diferenças.",
                                    "Teste falha de link e compare recuperação.",
                                    "Documente observações: tempo de ping, uso de CPU no simulador.",
                                    "Conclua com recomendação baseada no cenário."
                                  ],
                                  "verification": "Grave um vídeo curto ou tire screenshots mostrando ping bem-sucedido antes/depois da mudança.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Cisco Packet Tracer (versão gratuita)",
                                    "Guia de configuração rápida RIP/OSPF",
                                    "Captura de tela tool"
                                  ],
                                  "tips": "Comece com topologia linear para simplicidade, depois adicione loops.",
                                  "learningObjective": "Consolidar a diferenciação através de prática hands-on.",
                                  "commonMistakes": [
                                    "Não limpar configurações entre testes",
                                    "Esquecer máscaras de sub-rede",
                                    "Ignorar comandos de debug para verificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório Cisco Packet Tracer, configure dois roteadores conectados via rede IP 192.168.1.0/24. Adicione uma terceira rede remota (10.0.0.0/24). Primeiro, use 'ip route 10.0.0.0 255.255.255.0 192.168.1.2' para roteamento estático. Teste com ping. Em seguida, ative RIP com 'router rip' e 'network 192.168.1.0', observe a tabela 'show ip route' atualizando dinamicamente e compare tempos de convergência após desligar um link.",
                              "finalVerifications": [
                                "Explique verbalmente as diferenças principais sem consultar notas.",
                                "Crie uma tabela comparativa precisa com 6+ critérios.",
                                "Simule uma falha em Packet Tracer e descreva o comportamento de cada tipo.",
                                "Liste 3 cenários reais para cada tipo de roteamento.",
                                "Responda a perguntas como: 'Por que OSPF é preferido sobre RIP em grandes redes?'",
                                "Identifique riscos de segurança em cada abordagem."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem erros comuns (90%+ acurácia).",
                                "Completude da comparação: cobertura equilibrada de prós/contras e cenários.",
                                "Profundidade prática: evidências de simulação com screenshots ou logs.",
                                "Clareza na comunicação: tabelas/diagramas legíveis e explicações concisas.",
                                "Aplicação contextual: ligação ao modelo TCP/IP e camada de rede.",
                                "Criatividade: uso de analogias ou cenários originais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para modelar topologias e algoritmos de caminho mais curto (ex: Dijkstra em OSPF).",
                                "Segurança da Informação: Análise de vulnerabilidades em protocolos dinâmicos vs. controle manual estático.",
                                "Programação: Scripting de configurações com Python Netmiko para automação híbrida.",
                                "Física: Compreensão de latência e propagação de sinal em redes reais.",
                                "Gestão de Projetos: Avaliação de custo-benefício para escalabilidade de redes."
                              ],
                              "realWorldApplication": "Em redes corporativas pequenas, roteamento estático é usado para links WAN dedicados por simplicidade e segurança; em data centers ou ISPs, roteamento dinâmico como OSPF/BGP gerencia milhares de rotas, adaptando-se a falhas em tempo real, como em outages globais de provedores como o da AWS ou Verizon."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Introduzir plano de controle com SDN",
                            "description": "Descrever o plano de controle na camada de rede, contrastando com tradicional e introduzindo conceitos básicos de Software-Defined Networking (SDN) para computação de rotas centralizada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Roteamento Tradicional na Camada de Rede",
                                  "subSteps": [
                                    "Explicar o funcionamento do roteamento IP distribuído, onde cada roteador mantém tabelas de roteamento independentes.",
                                    "Descrever protocolos de roteamento como OSPF e BGP, destacando a troca de informações entre roteadores vizinhos.",
                                    "Ilustrar como decisões de encaminhamento são tomadas localmente em cada dispositivo.",
                                    "Discutir o modelo de plano de controle integrado ao plano de dados nos roteadores tradicionais.",
                                    "Analisar um exemplo simples de rede com 3 roteadores trocando rotas."
                                  ],
                                  "verification": "Criar um diagrama manual de uma rede tradicional com tabelas de roteamento preenchidas corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Vídeo tutorial sobre OSPF (YouTube)",
                                    "Simulador Cisco Packet Tracer (gratuito)"
                                  ],
                                  "tips": "Use setas para representar fluxos de controle e dados no diagrama para visualizar a integração.",
                                  "learningObjective": "Compreender os fundamentos do roteamento distribuído e sua arquitetura integrada.",
                                  "commonMistakes": [
                                    "Confundir roteamento com switching (camada 2)",
                                    "Ignorar o overhead de protocolos de sinalização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Limitações do Roteamento Tradicional",
                                  "subSteps": [
                                    "Listar problemas de escalabilidade em redes grandes, como convergência lenta após falhas.",
                                    "Explicar ineficiências em gerenciamento centralizado, como configuração manual de políticas.",
                                    "Discutir dificuldades em inovação, pois o software de roteadores é proprietário e rígido.",
                                    "Analisar casos reais de falhas, como blackouts em ISPs devido a loops de roteamento.",
                                    "Comparar métricas: tempo de configuração vs. SDN em cenários hipotéticos."
                                  ],
                                  "verification": "Escrever um relatório curto (200 palavras) listando 5 limitações com exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo 'Why SDN?' da ONF (opennetworking.org)",
                                    "Planilha para tabela comparativa"
                                  ],
                                  "tips": "Priorize limitações relacionadas a centralização para preparar o contraste com SDN.",
                                  "learningObjective": "Reconhecer os desafios que motivam a adoção de SDN.",
                                  "commonMistakes": [
                                    "Superestimar a robustez dos protocolos tradicionais",
                                    "Não diferenciar limitações técnicas de operacionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Conceitos Básicos de Software-Defined Networking (SDN)",
                                  "subSteps": [
                                    "Definir SDN como paradigma que separa plano de controle (lógica de rede) do plano de dados (encaminhamento).",
                                    "Explicar componentes chave: switches OpenFlow, controlador SDN e protocolo de comunicação.",
                                    "Descrever o fluxo: controlador programa regras nos switches via southbound API.",
                                    "Ilustrar arquitetura em camadas: Application, Control, Data.",
                                    "Comparar visualmente SDN vs. tradicional usando diagramas lado a lado."
                                  ],
                                  "verification": "Montar um diagrama de arquitetura SDN com labels para cada plano e API.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tutorial SDN da Cisco DevNet",
                                    "Ferramenta de desenho online como Draw.io",
                                    "Vídeo 'SDN Explained' (5 min)"
                                  ],
                                  "tips": "Use cores diferentes para planos de controle (azul) e dados (verde) nos diagramas.",
                                  "learningObjective": "Dominar a definição e arquitetura fundamental do SDN.",
                                  "commonMistakes": [
                                    "Confundir controlador com servidor de roteamento tradicional",
                                    "Ignorar o papel das APIs northbound/southbound"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o Plano de Controle em SDN e Computação Centralizada de Rotas",
                                  "subSteps": [
                                    "Detalhar o plano de controle: software centralizado que computa rotas globais e instala fluxos nos switches.",
                                    "Explicar computação centralizada: visão global da topologia via LLDP, algoritmos como Dijkstra otimizados.",
                                    "Descrever instalação de regras via OpenFlow: match-action tables nos switches.",
                                    "Contrastar com tradicional: central vs. distribuído, programável vs. estático.",
                                    "Simular um cenário: falha de link detectada e rota recalculada centralmente em segundos."
                                  ],
                                  "verification": "Simular em Mininet uma rede SDN com controlador Ryu alterando rotas dinamicamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Mininet (instalação via VM ou Docker)",
                                    "Controlador Ryu (Python-based)",
                                    "Tutorial Mininet SDN (github.com/mininet)"
                                  ],
                                  "tips": "Comece com topologia linear simples para testar ping antes/depois da mudança de rota.",
                                  "learningObjective": "Aplicar conceitos de plano de controle para roteamento centralizado em SDN.",
                                  "commonMistakes": [
                                    "Não instalar fluxos corretamente levando a blackholing",
                                    "Confundir estado global com estado local nos switches"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 10 switches, use Mininet e Ryu para simular tráfego de vídeo. Ao detectar congestionamento, o controlador SDN recalcula rotas centralmente via algoritmo de caminho mais curto, instalando novas regras OpenFlow nos switches, reduzindo latência de 200ms para 50ms sem intervenção manual.",
                              "finalVerifications": [
                                "Diagramar corretamente SDN vs. roteamento tradicional.",
                                "Explicar verbalmente a separação de planos em 1 minuto.",
                                "Executar simulação Mininet com mudança de rota bem-sucedida.",
                                "Listar 3 benefícios do plano de controle centralizado.",
                                "Identificar OpenFlow como protocolo southbound.",
                                "Comparar convergência: SDN (segundos) vs. OSPF (minutos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de SDN e planos (30%)",
                                "Clareza em diagramas e explicações (25%)",
                                "Profundidade na comparação tradicional vs. SDN (20%)",
                                "Sucesso na simulação prática (15%)",
                                "Identificação de limitações e benefícios (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos de grafos (Dijkstra) para computação de rotas.",
                                "Programação: Desenvolvimento de controladores em Python (Ryu/POX).",
                                "Segurança da Informação: Políticas de segurança centralizadas via SDN.",
                                "Administração de Sistemas: Automação de configuração de redes."
                              ],
                              "realWorldApplication": "Em data centers do Google (projeto B4), SDN centraliza controle para otimizar tráfego global, permitindo balanceamento dinâmico de cargas e recuperação rápida de falhas em redes de petabytes/segundo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Nível de Aplicação",
                "description": "Aborda protocolos de suporte e de serviços no nível de aplicação.",
                "totalSkills": 54,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Protocolos de Suporte no Nível de Aplicação",
                    "description": "Protocolos que fornecem serviços auxiliares, como resolução de nomes de domínio (ex: DNS).",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Sistema de Nomes de Domínio (DNS)",
                        "description": "Protocolo essencial para resolução de nomes de domínio legíveis por humanos em endereços IP numéricos, permitindo a navegação na internet sem memorizar endereços IP.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Identificar o propósito e funcionamento básico do DNS",
                            "description": "Explicar como o DNS traduz nomes de domínio (ex: www.exemplo.com) em endereços IP usando uma hierarquia de servidores distribuídos globalmente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o propósito do DNS",
                                  "subSteps": [
                                    "Explicar o problema dos endereços IP numéricos para humanos (ex: 192.0.2.1 é difícil de lembrar).",
                                    "Definir nomes de domínio como www.exemplo.com e sua importância para usabilidade.",
                                    "Descrever o DNS como um 'catálogo telefônico da internet' que traduz domínios em IPs.",
                                    "Listar benefícios: facilidade de uso, portabilidade de IPs e escalabilidade global.",
                                    "Comparar mundo sem DNS (memorizar IPs) vs. com DNS."
                                  ],
                                  "verification": "Escrever uma definição em 3 frases do propósito do DNS e dar um exemplo pessoal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": [
                                    "Use analogia de agenda telefônica para fixar o conceito."
                                  ],
                                  "learningObjective": "Identificar o problema resolvido pelo DNS e seus principais benefícios.",
                                  "commonMistakes": [
                                    "Confundir DNS com roteamento IP.",
                                    "Achar que DNS armazena IPs localmente no navegador."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a hierarquia de servidores DNS",
                                  "subSteps": [
                                    "Identificar os tipos de servidores: Root, TLD (Top-Level Domain) e Authoritative.",
                                    "Desenhar um diagrama simples da hierarquia: Root → TLD (.com) → Authoritative (exemplo.com).",
                                    "Explicar o papel de cada: Root aponta para TLD, TLD para Authoritative, que tem o IP final.",
                                    "Discutir distribuição global para redundância e velocidade.",
                                    "Pesquisar um exemplo de servidor root (ex: a.root-servers.net)."
                                  ],
                                  "verification": "Desenhar e rotular um fluxograma da hierarquia DNS com 3 níveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho online (ex: draw.io)",
                                    "Internet para pesquisa rápida"
                                  ],
                                  "tips": [
                                    "Lembre-se: é como uma árvore genealógica invertida, do geral ao específico."
                                  ],
                                  "learningObjective": "Mapear a estrutura distribuída de servidores DNS.",
                                  "commonMistakes": [
                                    "Invertir a ordem da hierarquia.",
                                    "Pensar que há um único servidor central."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender o processo de resolução de nomes (DNS Lookup)",
                                  "subSteps": [
                                    "Descrever o início: navegador envia query para DNS resolver local (stub resolver).",
                                    "Explicar encaminhamento iterativo/recursivo: local → root → TLD → authoritative.",
                                    "Detalhar resposta: IP retornado e cache local para queries futuras.",
                                    "Mencionar tipos de records: A (IPv4), AAAA (IPv6), CNAME, MX.",
                                    "Simular verbalmente uma resolução completa para www.exemplo.com."
                                  ],
                                  "verification": "Narrar o processo de resolução para um domínio fictício em 5 etapas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Internet",
                                    "Terminal ou prompt de comando para testes futuros"
                                  ],
                                  "tips": [
                                    "Pense em uma consulta postal: começa ampla e afunila até o endereço exato."
                                  ],
                                  "learningObjective": "Sequenciar o fluxo completo de uma resolução DNS.",
                                  "commonMistakes": [
                                    "Ignorar cache local.",
                                    "Confundir recursivo com iterativo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e verificar o funcionamento do DNS",
                                  "subSteps": [
                                    "Executar comando 'nslookup www.google.com' ou 'dig www.google.com' no terminal.",
                                    "Analisar saída: identificar servidor usado, IP retornado e tempo de resposta.",
                                    "Testar falha: digitar domínio inválido e observar erro NXDOMAIN.",
                                    "Limpar cache DNS (ipconfig /flushdns no Windows) e testar novamente.",
                                    "Pesquisar um WHOIS para ver authoritative servers de um domínio."
                                  ],
                                  "verification": "Registrar saídas de 3 comandos nslookup e explicar diferenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Computador com terminal (Windows: cmd, Linux/Mac: terminal)",
                                    "Conexão à internet"
                                  ],
                                  "tips": [
                                    "Use dig se disponível; é mais detalhado que nslookup."
                                  ],
                                  "learningObjective": "Aplicar conhecimento prático para observar DNS em ação.",
                                  "commonMistakes": [
                                    "Não interpretar flags como 'Non-authoritative answer'.",
                                    "Confundir IP público com local."
                                  ]
                                }
                              ],
                              "practicalExample": "Abra o terminal e digite 'nslookup www.exemplo.com'. Observe a query ir para o servidor DNS do seu provedor, consultar root/TLD/authoritative e retornar o IP 93.184.216.34. Isso simula o processo real usado ao acessar qualquer site.",
                              "finalVerifications": [
                                "Explicar o propósito do DNS em 2 minutos sem consultar notas.",
                                "Desenhar hierarquia DNS com labels corretos.",
                                "Narrar resolução completa de um domínio real.",
                                "Interpretar saída de nslookup/dig corretamente.",
                                "Identificar 3 tipos de records DNS.",
                                "Diferenciar DNS de outros protocolos como DHCP."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (propósito e hierarquia: 30%)",
                                "Compreensão do fluxo de resolução (40%)",
                                "Habilidade prática com ferramentas (20%)",
                                "Uso de exemplos e analogias claras (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas hierárquicas e árvores de decisão.",
                                "História: Evolução da Internet (RFC 1034/1035 de 1987).",
                                "Língua Portuguesa: Construção de analogias para conceitos abstratos.",
                                "Segurança da Informação: Vulnerabilidades como DNS spoofing."
                              ],
                              "realWorldApplication": "Todo clique em um link web inicia uma resolução DNS; falhas causam erros como 'Host não encontrado'. Profissionais de TI usam DNS para configuração de redes empresariais, e ataques como DDoS visam servidores DNS para derrubar sites globais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Descrever a hierarquia de servidores DNS",
                            "description": "Detalhar os tipos de servidores DNS (raiz, TLD, autoritativos) e o processo de resolução de nomes de domínio de forma recursiva ou iterativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os tipos principais de servidores DNS",
                                  "subSteps": [
                                    "Estude a definição de servidor DNS raiz: servidores que conhecem as localizações dos servidores TLD.",
                                    "Aprenda sobre servidores TLD (Top-Level Domain): gerenciam domínios como .com, .org, .br.",
                                    "Compreenda servidores DNS autoritativos: detêm os registros DNS definitivos para um domínio específico.",
                                    "Diferencie servidores stub, recursivos e de cache forwarding como complementares.",
                                    "Memorize exemplos reais: raiz (a.root-servers.net), TLD (a.gtld-servers.net para .com)."
                                  ],
                                  "verification": "Liste os três tipos principais de servidores DNS com uma breve descrição de cada um.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de hierarquia DNS (RFC 1034/1035)",
                                    "Site IANA root servers list"
                                  ],
                                  "tips": "Use mnemônicos: Raiz (Roots), TLD (Top), Autoritativos (Authoritative Answers).",
                                  "learningObjective": "Classificar corretamente os tipos de servidores DNS e suas funções básicas.",
                                  "commonMistakes": "Confundir TLD com autoritativos; achar que raiz resolve domínios finais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear a hierarquia de servidores DNS",
                                  "subSteps": [
                                    "Desenhe um diagrama da hierarquia: cliente -> recursivo -> raiz -> TLD -> autoritativo.",
                                    "Explique o papel da raiz: responde com IP do servidor TLD para o TLD solicitado.",
                                    "Detalhe TLD: responde com IP do servidor autoritativo para o domínio.",
                                    "Descreva autoritativo: fornece o registro A/AAAA, CNAME, MX etc. para o hostname.",
                                    "Inclua delegação via NS records em cada nível."
                                  ],
                                  "verification": "Crie um fluxograma simples da hierarquia para um domínio exemplo como example.com.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como draw.io",
                                    "Documentação RFC 1035 sobre zona files"
                                  ],
                                  "tips": "Pense como uma árvore: raiz no topo, folhas nos autoritativos.",
                                  "learningObjective": "Visualizar e explicar a estrutura hierárquica distribuída do DNS.",
                                  "commonMistakes": "Ignorar a delegação NS; assumir consulta direta à raiz para qualquer domínio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender resolução recursiva de nomes",
                                  "subSteps": [
                                    "Defina resolução recursiva: resolvedor faz todas as consultas em nome do cliente.",
                                    "Simule passo a passo: resolvedor consulta raiz, recebe TLD, consulta TLD, recebe autoritativo, obtém resposta final.",
                                    "Discuta cache: resolvedor armazena respostas intermediárias para TTL.",
                                    "Compare com iteração: recursivo lida com redirecionamentos.",
                                    "Teste com dig +trace example.com para ver recursão."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os passos recursivos para resolver www.google.com.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Comando dig/nslookup no terminal",
                                    "Tutorial Wireshark para capturar DNS"
                                  ],
                                  "tips": "Use 'dig +trace' para visualizar o processo real em tempo real.",
                                  "learningObjective": "Descrever o fluxo completo de resolução recursiva com exemplos.",
                                  "commonMistakes": "Confundir recursivo com iterativo; esquecer cache e TTL."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender resolução iterativa de nomes",
                                  "subSteps": [
                                    "Defina resolução iterativa: resolvedor consulta raiz e segue referências sozinho.",
                                    "Simule: cliente/resolvor consulta raiz (recebe TLD), consulta TLD (recebe NS autoritativo), consulta autoritativo (resposta final).",
                                    "Destaque diferença: resolvedor itera, não delega para outro servidor.",
                                    "Exemplo prático: dig @a.root-servers.net google.com para iterativo manual.",
                                    "Discuta quando usar: stub resolvers ou ferramentas de debug."
                                  ],
                                  "verification": "Execute uma resolução iterativa manual usando dig e documente os passos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Terminal com dig instalado",
                                    "Lista de root servers (iana.org/domains/root/servers)"
                                  ],
                                  "tips": "Comece sempre pela raiz para prática iterativa autêntica.",
                                  "learningObjective": "Diferenciar e demonstrar resolução iterativa versus recursiva.",
                                  "commonMistakes": "Achar que iterativa é mais lenta sempre; misturar cliente com resolvedor."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e comparar processos de resolução DNS",
                                  "subSteps": [
                                    "Compare recursiva vs iterativa: recursiva offload para resolvedor, iterativa para debug.",
                                    "Descreva fluxo completo end-to-end para um hostname FQDN.",
                                    "Aborde erros comuns: NXDOMAIN, SERVFAIL, timeouts.",
                                    "Integre hierarquia com resolução: como tipos de servidores suportam ambos modos.",
                                    "Crie um resumo em tabela: tipo servidor, função, modo de resolução."
                                  ],
                                  "verification": "Responda a perguntas de quiz sobre hierarquia e resoluções com 90% acerto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quiz online sobre DNS (ex: dnsstuff.com)",
                                    "Vídeo Khan Academy ou Cisco Networking Academy"
                                  ],
                                  "tips": "Faça analogia com telefone: recursivo é secretaria que pesquisa por você.",
                                  "learningObjective": "Integrar hierarquia DNS com mecanismos de resolução para descrição completa.",
                                  "commonMistakes": "Omitir cache/TTL; não diferenciar recursivo de forwarding."
                                }
                              ],
                              "practicalExample": "Para resolver 'www.example.com': 1) Cliente consulta resolvedor local recursivo. 2) Recursivo sem cache consulta raiz (a.root-servers.net), recebe NS para .com (a.gtld-servers.net). 3) Consulta TLD .com, recebe NS para example.com (ns1.example.com). 4) Consulta autoritativo example.com, obtém IP de www (93.184.216.34). Resposta cacheada por 3600s.",
                              "finalVerifications": [
                                "Liste e descreva raiz, TLD e autoritativos com exemplos reais.",
                                "Desenhe hierarquia para um domínio como google.com.",
                                "Explique diferença recursiva vs iterativa com diagrama.",
                                "Execute dig +trace e interprete saída.",
                                "Identifique erros em um log de resolução DNS falha.",
                                "Resuma processo completo em 1 minuto verbalmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação dos três tipos de servidores (100% correto).",
                                "Diagrama hierárquico claro e sequencial (sem omissões).",
                                "Explicação correta de recursiva vs iterativa (diferenciações chave).",
                                "Demonstração prática com dig/nslookup sem erros.",
                                "Integração de cache, TTL e delegação NS.",
                                "Capacidade de troubleshooting básico em cenários hipotéticos."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: DNSSEC para autenticação hierárquica.",
                                "Programação: Implementar resolvedor DNS em Python (socket library).",
                                "Matemática: Árvores e grafos para modelar hierarquia.",
                                "História da Computação: Evolução do DNS desde ARPANET (RFC 882)."
                              ],
                              "realWorldApplication": "Diagnosticar lentidão de internet (flush DNS cache), configurar domínios próprios (registrar NS autoritativos), mitigar DDoS em resolvers recursivos públicos como 8.8.8.8, ou desenvolver apps que usam APIs DNS para validação de domínios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Reconhecer tipos de registros DNS",
                            "description": "Listar e explicar registros comuns como A (IPv4), AAAA (IPv6), MX (e-mail), CNAME (alias) e NS (servidores de nomes), com exemplos práticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos básicos de registros DNS",
                                  "subSteps": [
                                    "Defina o que é o Sistema de Nomes de Domínio (DNS) e sua função principal.",
                                    "Explique a estrutura de uma zona DNS e onde os registros são armazenados.",
                                    "Identifique a sintaxe básica de um registro DNS: nome, tipo, valor e TTL.",
                                    "Diferencie registros DNS de endereços IP diretos.",
                                    "Pesquise exemplos reais de zonas DNS públicas."
                                  ],
                                  "verification": "Escreva uma definição curta de registros DNS e liste sua estrutura básica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use analogias como 'uma agenda telefônica da internet' para fixar o conceito.",
                                  "learningObjective": "Compreender o papel e a estrutura fundamental dos registros DNS.",
                                  "commonMistakes": [
                                    "Confundir DNS com DHCP",
                                    "Ignorar o TTL na sintaxe"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar registros de endereço: A e AAAA",
                                  "subSteps": [
                                    "Descreva o registro A: mapeia nomes de domínio para endereços IPv4.",
                                    "Forneça exemplos: example.com A 192.0.2.1.",
                                    "Explique o registro AAAA: similar ao A, mas para IPv6 (ex: 2001:db8::1).",
                                    "Compare diferenças entre IPv4 e IPv6 em registros.",
                                    "Identifique cenários de uso: websites acessíveis via IPv4/IPv6."
                                  ],
                                  "verification": "Crie exemplos fictícios de registros A e AAAA para um domínio.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação RFC 1035",
                                    "Ferramenta online de lookup DNS"
                                  ],
                                  "tips": "Lembre-se: A é para o 'velho' IPv4 (32 bits), AAAA para IPv6 (128 bits).",
                                  "learningObjective": "Diferenciar e exemplificar registros A e AAAA com precisão.",
                                  "commonMistakes": [
                                    "Usar IPv6 em registro A",
                                    "Confundir com registros de texto (TXT)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar registros de serviço: MX, CNAME e NS",
                                  "subSteps": [
                                    "Defina MX: aponta para servidores de e-mail (prioridade incluída).",
                                    "Exemplo: example.com MX 10 mail.example.com.",
                                    "Descreva CNAME: alias para outro nome de domínio.",
                                    "Exemplo: www.example.com CNAME example.com.",
                                    "Explique NS: delega autoridade para servidores de nomes.",
                                    "Exemplo: example.com NS ns1.example.com."
                                  ],
                                  "verification": "Liste e explique cada um com um exemplo prático.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Comandos dig ou nslookup",
                                    "Sites como dns.google"
                                  ],
                                  "tips": "Prioridade no MX é crucial: menor número = maior prioridade.",
                                  "learningObjective": "Reconhecer e diferenciar MX, CNAME e NS com exemplos.",
                                  "commonMistakes": [
                                    "Usar CNAME na raiz do domínio (apex)",
                                    "Ignorar prioridade no MX"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar consulta e análise de registros DNS reais",
                                  "subSteps": [
                                    "Instale ou acesse ferramentas como dig ou nslookup.",
                                    "Consulte registros A, AAAA, MX, CNAME e NS para domínios reais (ex: google.com).",
                                    "Analise os resultados e identifique cada tipo.",
                                    "Crie um diagrama simples relacionando registros a funções.",
                                    "Simule um erro comum, como falha em MX, e corrija."
                                  ],
                                  "verification": "Registre saídas de consultas para 3 domínios e anote os tipos encontrados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Terminal com dig/nslookup",
                                    "Domínios de teste públicos"
                                  ],
                                  "tips": "Use 'dig example.com ANY' para ver todos os registros de uma vez.",
                                  "learningObjective": "Aplicar conhecimento na consulta e interpretação prática de registros.",
                                  "commonMistakes": [
                                    "Interpretar TTL como prioridade",
                                    "Não verificar múltiplos NS"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um domínio teste no seu provedor (ex: Cloudflare) e adicione registros: A para IP do servidor web, MX para e-mail, CNAME para subdomínio www e NS para nameservers. Use dig para consultar e verificar.",
                              "finalVerifications": [
                                "Liste corretamente os 5 tipos de registros com suas funções principais.",
                                "Forneça exemplos válidos para cada tipo.",
                                "Explique diferenças entre A/AAAA e MX/CNAME/NS.",
                                "Realize consultas reais e interprete resultados.",
                                "Identifique erros comuns em configurações de registros.",
                                "Desenhe um mapa de registros para um domínio fictício."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e exemplos (90% correto).",
                                "Capacidade de diferenciar tipos sem confusões.",
                                "Uso correto de ferramentas de consulta DNS.",
                                "Profundidade nos sub-passos e verificações.",
                                "Criatividade em exemplos práticos e aplicações.",
                                "Identificação de erros comuns e soluções."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Vulnerabilidades como DNS spoofing e poisoning.",
                                "Programação: Uso de bibliotecas como dns-python para queries automatizadas.",
                                "Redes: Integração com protocolos TCP/IP e roteamento.",
                                "Administração de Sistemas: Configuração de servidores DNS (BIND).",
                                "Desenvolvimento Web: Resolução de domínios em aplicações full-stack."
                              ],
                              "realWorldApplication": "No cotidiano, registros DNS permitem acessar sites (A/AAAA), enviar e-mails (MX), criar aliases (CNAME) e delegar domínios (NS), sustentando a internet global como em serviços como Google, Netflix e e-mails corporativos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.1.4",
                            "name": "Analisar mecanismos de cache e resolução DNS",
                            "description": "Explicar como o cache em resolvers e servidores reduz latência, incluindo TTL (Time To Live) e problemas como envenenamento de cache.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Processo Básico de Resolução DNS Sem Cache",
                                  "subSteps": [
                                    "Estude o fluxo de resolução DNS: do stub resolver ao root server, TLD e authoritative server.",
                                    "Identifique os tipos de consultas: recursiva, iterativa e não-recursiva.",
                                    "Desenhe um diagrama do caminho de resolução DNS completo.",
                                    "Meça a latência simulada de uma resolução sem cache usando ferramentas como 'dig'.",
                                    "Compare latências reais de domínios diferentes."
                                  ],
                                  "verification": "Desenhar e explicar corretamente o diagrama de resolução DNS em uma apresentação ou relatório.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta 'dig' ou 'nslookup', papel e caneta para diagrama, Wireshark para captura de pacotes.",
                                  "tips": "Use 'dig +trace example.com' para visualizar o caminho completo de resolução.",
                                  "learningObjective": "Entender o overhead de latência em resoluções DNS sem cache.",
                                  "commonMistakes": "Confundir stub resolver com recursive resolver; ignorar o papel dos root servers."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Cache em Resolvers Locais",
                                  "subSteps": [
                                    "Instale e configure um resolver local como unbound ou dnsmasq.",
                                    "Realize múltiplas consultas ao mesmo domínio e observe respostas mais rápidas na segunda consulta.",
                                    "Capture tráfego com Wireshark para ver flags 'AA' e ausência de consultas upstream.",
                                    "Analise logs do resolver para entradas de cache hit/miss.",
                                    "Teste flush de cache com comandos como 'rndc flush'."
                                  ],
                                  "verification": "Demonstrar cache hit em logs ou Wireshark, com latência <10ms na segunda consulta.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software unbound/dnsmasq, Wireshark, terminal Linux/Windows.",
                                  "tips": "Monitore com 'unbound-control stats' para métricas de cache.",
                                  "learningObjective": "Identificar como cache local reduz latência eliminando consultas recursivas.",
                                  "commonMistakes": "Não limpar cache antes de testes; confundir cache do OS com resolver cache."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Cache em Servidores DNS Recursivos e Autoritativos",
                                  "subSteps": [
                                    "Estude hierarquia: cache em recursive resolvers (ex: Google 8.8.8.8) e authoritative servers.",
                                    "Simule cache em servidor autoritativo usando BIND e observe TTL em respostas.",
                                    "Compare latência com cache populado vs vazio em cenários multi-região.",
                                    "Discuta compartilhamento de cache em pools de servidores.",
                                    "Teste com domínios reais como google.com via public DNS."
                                  ],
                                  "verification": "Explicar diferenças de cache entre recursive e authoritative em um diagrama anotado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "BIND software, documentação RFC 1035, ferramentas online como dnsviz.net.",
                                  "tips": "Use 'dig @8.8.8.8 +trace' para ver cache em recursive public.",
                                  "learningObjective": "Diferenciar impactos de cache em diferentes níveis da hierarquia DNS.",
                                  "commonMistakes": "Assumir que authoritative servers não cacheiam; ignorar cache negativo (NXDOMAIN)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender TTL e Gerenciamento de Cache",
                                  "subSteps": [
                                    "Defina TTL e seu papel em expiração de cache.",
                                    "Analise cabeçalhos SOA para TTL mínimo e configure TTL baixo/alto em zona DNS.",
                                    "Simule expiração: consulte domínio, espere TTL, consulte novamente e meça latência.",
                                    "Discuta estratégias de TTL: baixo para alta disponibilidade, alto para performance.",
                                    "Calcule impacto: tempo médio de resolução com TTL variando."
                                  ],
                                  "verification": "Prever e demonstrar latência pós-expiração de TTL em teste prático.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de zona DNS (BIND), calculadora para simulações de latência.",
                                  "tips": "TTL=1 para testes rápidos; monitore com 'dig +ttl'.",
                                  "learningObjective": "Calcular e otimizar TTL para balancear latência e consistência.",
                                  "commonMistakes": "Confundir TTL de registro com TTL de resposta; ignorar TTL=0 para não-cachear."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Investigar Problemas de Cache, Foco em Envenenamento",
                                  "subSteps": [
                                    "Explique cache poisoning: ataques Kaminsky e birthday attacks.",
                                    "Simule detecção com DNSSEC validação usando 'dig +dnssec'.",
                                    "Configure validação DNSSEC em resolver local.",
                                    "Analise impactos: downtime, redirecionamentos maliciosos.",
                                    "Discuta mitigações: randomização de porta, DNSSEC, rate limiting."
                                  ],
                                  "verification": "Identificar e mitigar um cenário simulado de poisoning em lab.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Ferramentas DNSSEC (ldns-testns), documentação RFC 4033/6891.",
                                  "tips": "Teste com domínios DNSSEC como nic.cz.",
                                  "learningObjective": "Reconhecer vulnerabilidades de cache e implementar proteções básicas.",
                                  "commonMistakes": "Subestimar off-path attacks; não validar chains de confiança DNSSEC."
                                }
                              ],
                              "practicalExample": "Configure um resolver local com unbound, resolva 'example.com' 10 vezes consecutivas. Primeira consulta: 200ms (cache miss, vai ao root). Consultas 2-10: <5ms (cache hit). Altere TTL para 10s, observe expiração e nova consulta full após 10s. Simule poisoning injetando resposta falsa e detecte com DNSSEC.",
                              "finalVerifications": [
                                "Explicar fluxo DNS com cache em diagrama preciso.",
                                "Medir e comparar latências cache hit vs miss.",
                                "Calcular TTL impacto em 80% de consultas cached.",
                                "Identificar poisoning em Wireshark capture.",
                                "Configurar resolver com DNSSEC e validar.",
                                "Discutir trade-offs TTL baixo vs alto."
                              ],
                              "assessmentCriteria": [
                                "Precisão no diagrama de resolução com cache (90% cobertura).",
                                "Demonstração prática de cache hit/miss com métricas (<10% erro).",
                                "Explicação clara de TTL e poisoning (sem conceitos errados).",
                                "Uso correto de ferramentas (dig, Wireshark, unbound).",
                                "Análise de mitigações de segurança (pelo menos 3 mencionadas).",
                                "Conexão com latência real-world (exemplos quantificados)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança de Redes: Integra com DNSSEC e criptografia TLS.",
                                "Sistemas Operacionais: Cache de OS (ex: nscd) e kernel resolver.",
                                "Desempenho de Sistemas: Otimização de latência em CDNs.",
                                "Matemática: Modelos probabilísticos de cache hit rate."
                              ],
                              "realWorldApplication": "Em CDNs como Cloudflare, cache DNS reduz TTFB de sites globais de 500ms para 20ms; administradores usam TTL baixo para failover rápido em outages, e DNSSEC previne hijacking em bancos online."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Protocolo de Configuração Dinâmica de Host (DHCP)",
                        "description": "Protocolo que automatiza a atribuição de endereços IP e configurações de rede (máscara, gateway, DNS) para dispositivos em uma rede local.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Compreender o papel do DHCP no suporte à rede",
                            "description": "Descrever como o DHCP elimina a necessidade de configuração manual de IP, usando um servidor central para gerenciar pools de endereços.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a configuração manual de endereços IP e suas limitações",
                                  "subSteps": [
                                    "Explicar o que é um endereço IP e sua importância em redes.",
                                    "Descrever o processo de configuração estática (manual) de IP em um dispositivo.",
                                    "Identificar problemas como conflitos de IP, erros humanos e escalabilidade em redes grandes.",
                                    "Comparar com cenários reais de redes pequenas vs. grandes.",
                                    "Listar exemplos de falhas comuns em configurações manuais."
                                  ],
                                  "verification": "Resumir em um parágrafo as desvantagens da configuração manual e listar 3 exemplos de problemas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de IP (RFC 791), simulador de rede como Packet Tracer.",
                                  "tips": "Use diagramas para visualizar conflitos de IP.",
                                  "learningObjective": "Compreender por que a configuração manual é ineficiente em redes modernas.",
                                  "commonMistakes": "Confundir IP público com privado ou ignorar sub-redes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito e componentes do DHCP",
                                  "subSteps": [
                                    "Definir DHCP como Dynamic Host Configuration Protocol.",
                                    "Explicar os papéis: Cliente DHCP, Servidor DHCP e Relay Agent.",
                                    "Descrever o escopo: pools de endereços, máscaras de sub-rede, gateway padrão e DNS.",
                                    "Diferenciar DHCP de BOOTP.",
                                    "Visualizar a arquitetura em um diagrama simples."
                                  ],
                                  "verification": "Desenhar um diagrama com cliente, servidor e componentes principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Vídeo tutorial sobre DHCP (YouTube ou Cisco Networking Academy), RFC 2131.",
                                  "tips": "Lembre-se: DHCP é 'plug and play' para IPs.",
                                  "learningObjective": "Identificar os componentes essenciais do DHCP e seu propósito centralizado.",
                                  "commonMistakes": "Confundir servidor DHCP com roteador ou ignorar o relay em redes segmentadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender o processo DORA de alocação de IP",
                                  "subSteps": [
                                    "Explicar Discover: Cliente envia broadcast UDP 67/68.",
                                    "Detalhar Offer: Servidor responde com IP disponível.",
                                    "Descrever Request: Cliente pede o IP oferecido.",
                                    "Finalizar com Acknowledge: Servidor confirma e aluga o IP por um lease time.",
                                    "Simular o fluxo em um tool de rede."
                                  ],
                                  "verification": "Simular o processo DORA em um Wireshark ou simulador e capturar os pacotes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Wireshark, Cisco Packet Tracer ou GNS3 para simulação.",
                                  "tips": "Use portas UDP 67 (servidor) e 68 (cliente) como mnemônico.",
                                  "learningObjective": "Mapear o fluxo DORA e eliminar a necessidade de configuração manual.",
                                  "commonMistakes": "Invertar as etapas ou esquecer broadcasts na fase Discover."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar benefícios e gerenciamento de pools de endereços",
                                  "subSteps": [
                                    "Explicar pools de IP: ranges reservados e lease time.",
                                    "Discutir automação: renovação automática e redução de erros.",
                                    "Comparar eficiência: tempo economizado em grandes redes.",
                                    "Abordar segurança básica: DHCP snooping.",
                                    "Planejar um pool simples para uma rede de 50 dispositivos."
                                  ],
                                  "verification": "Criar um plano de pool DHCP para uma rede exemplo e calcular eficiência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora de sub-redes online, exemplos de configs de roteadores.",
                                  "tips": "Lease time curto para redes dinâmicas, longo para estáticas.",
                                  "learningObjective": "Avaliar como o DHCP gerencia centralmente endereços para suporte eficiente.",
                                  "commonMistakes": "Definir pools muito pequenos ou ignorar overlap com IPs estáticos."
                                }
                              ],
                              "practicalExample": "Em uma rede doméstica com roteador TP-Link, ative o servidor DHCP: configure pool de 192.168.1.100-192.168.1.200, gateway 192.168.1.1, DNS 8.8.8.8. Conecte um novo laptop e verifique via 'ipconfig /renew' que recebe IP automaticamente sem configuração manual.",
                              "finalVerifications": [
                                "Explicar verbalmente o processo DORA sem erros.",
                                "Identificar limitações da configuração manual em uma rede de 100 dispositivos.",
                                "Configurar um pool DHCP básico em simulador.",
                                "Diferenciar DHCP de IP estático com exemplos.",
                                "Listar 3 benefícios para suporte de rede.",
                                "Simular falha de DHCP e solução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do papel centralizado do DHCP (90%+ correto).",
                                "Compreensão clara do processo DORA com diagrama.",
                                "Identificação correta de pelo menos 4 limitações da config manual.",
                                "Exemplo prático viável e relacionado ao mundo real.",
                                "Uso correto de terminologia (pools, lease, DORA).",
                                "Capacidade de planejar pool para cenário dado."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Sistemas: Configuração de servidores Windows/Linux DHCP.",
                                "Segurança da Informação: Proteção contra rogue DHCP servers.",
                                "Matemática: Cálculo de sub-redes e tamanhos de pool.",
                                "Gestão de Projetos: Planejamento de infraestrutura de rede escalável."
                              ],
                              "realWorldApplication": "Em empresas como Google ou redes Wi-Fi públicas (cafés, aeroportos), o DHCP permite que milhares de dispositivos se conectem automaticamente, reduzindo tempo de suporte de TI de horas para minutos e evitando downtime por erros de IP."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Explicar o processo DORA do DHCP",
                            "description": "Detalhar as etapas Discover, Offer, Request e Acknowledgment (DORA) no protocolo DHCP, incluindo mensagens UDP usadas (portas 67/68).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Visão Geral do Processo DORA no DHCP",
                                  "subSteps": [
                                    "Explicar o propósito do DHCP: alocação dinâmica de endereços IP, máscara de sub-rede, gateway e DNS.",
                                    "Introduzir as fases DORA: Discover (D), Offer (O), Request (R) e Acknowledgment (A).",
                                    "Descrever as portas UDP envolvidas: servidor (67), cliente (68).",
                                    "Explicar que todas as mensagens são broadcasts inicialmente, exceto ACK.",
                                    "Discutir o formato básico das mensagens DHCP (opções, campos obrigatórios)."
                                  ],
                                  "verification": "Desenhar um diagrama simples do fluxo DORA e rotular as portas UDP corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 2131 do DHCP",
                                    "Diagrama de rede em branco",
                                    "Vídeo introdutório sobre DHCP (YouTube)"
                                  ],
                                  "tips": "Use analogia de um restaurante: cliente pede mesa (Discover), restaurante oferece (Offer), cliente aceita (Request), restaurante confirma (ACK).",
                                  "learningObjective": "Compreender o fluxo completo DORA e seu papel na configuração de rede.",
                                  "commonMistakes": [
                                    "Confundir portas 67/68 (servidor/cliente)",
                                    "Achar que DORA usa TCP em vez de UDP",
                                    "Ignorar broadcasts nas fases iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Fase Discover (D): Cliente Inicia a Descoberta",
                                  "subSteps": [
                                    "Cliente envia mensagem DHCPDISCOVER (broadcast) para porta 67 do servidor.",
                                    "Mensagem inclui endereço MAC do cliente e transação ID (xid).",
                                    "Cliente preenche campos como 'secs' (tempo decorrido) e opções solicitadas.",
                                    "Analisar formato: opcode (1=BOOTREQUEST), htype (1=Ethernet), chaddr (MAC).",
                                    "Simular em ferramenta: usar dhclient ou Wireshark para capturar."
                                  ],
                                  "verification": "Identificar uma mensagem DHCPDISCOVER em captura Wireshark e listar seus campos principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Máquina virtual com Linux para dhclient",
                                    "RFC 2131 seção 2"
                                  ],
                                  "tips": "Ative promiscuous mode no Wireshark para capturar broadcasts.",
                                  "learningObjective": "Dominar a mensagem inicial do cliente e seu formato broadcast.",
                                  "commonMistakes": [
                                    "Esquecer que é broadcast (255.255.255.255)",
                                    "Confundir xid com endereço IP",
                                    "Não notar porta de origem 68"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Fase Offer (O): Servidor Oferece Configurações",
                                  "subSteps": [
                                    "Servidor responde com DHCPOFFER (unicast para MAC ou broadcast) na porta 68 do cliente.",
                                    "Inclui IP proposto (yiaddr), tempo de lease, máscara, gateway e DNS nas opções.",
                                    "Múltiplos servidores podem oferecer; cliente escolhe um.",
                                    "Analisar campos: opcode (2=BOOTREPLY), siaddr (IP do servidor).",
                                    "Comparar ofertas múltiplas em simulação."
                                  ],
                                  "verification": "Em Wireshark, destacar DHCPOFFER e listar IPs e opções oferecidas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Servidor DHCP simples (isc-dhcp-server em VM)",
                                    "Wireshark",
                                    "Configuração de rede virtual (VirtualBox)"
                                  ],
                                  "tips": "Configure dois servidores DHCP para ver múltiplas ofertas.",
                                  "learningObjective": "Entender como servidores competem e fornecem configurações.",
                                  "commonMistakes": [
                                    "Achar que oferta é sempre unicast",
                                    "Ignorar lease time nas opções",
                                    "Confundir yiaddr com siaddr"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Fase Request (R): Cliente Solicita o IP Escolhido",
                                  "subSteps": [
                                    "Cliente envia DHCPREQUEST (broadcast) confirmando o IP desejado (opção 50).",
                                    "Inclui servidor escolhido (opção 54) para rejeitar outras ofertas.",
                                    "Atualiza 'secs' se demorado; usa mesmo xid.",
                                    "Servidores não escolhidos enviam DHCPNAK se necessário.",
                                    "Capturar e analisar em Wireshark."
                                  ],
                                  "verification": "Identificar DHCPREQUEST com opção 50 e 54 corretas em captura.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Cliente DHCP em VM",
                                    "Documentação de opções DHCP"
                                  ],
                                  "tips": "Note o broadcast para notificar outros servidores.",
                                  "learningObjective": "Compreender a seleção e confirmação pelo cliente.",
                                  "commonMistakes": [
                                    "Pensar que REQUEST é unicast",
                                    "Esquecer opção 54 (servidor IP)",
                                    "Não associar ao xid original"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Fase Acknowledgment (A): Servidor Confirma a Alocação",
                                  "subSteps": [
                                    "Servidor envia DHCPACK (unicast para IP do cliente) confirmando lease.",
                                    "Cliente configura interface com dados do ACK.",
                                    "Se falha, reinicia DORA; inclui opções finais.",
                                    "Discutir RENEW/REBIND após lease.",
                                    "Verificar configuração final com ipconfig/ifconfig."
                                  ],
                                  "verification": "Executar 'ipconfig /all' ou 'ifconfig' e confirmar dados do DHCP.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Comando ipconfig/ifconfig",
                                    "VM com cliente real"
                                  ],
                                  "tips": "Teste desconectando para forçar novo DORA.",
                                  "learningObjective": "Finalizar o ciclo e entender configuração efetiva.",
                                  "commonMistakes": [
                                    "Confundir ACK com NAK",
                                    "Achar que ACK é broadcast",
                                    "Ignorar renovação de lease"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um servidor DHCP em uma VM Ubuntu (isc-dhcp-server) e um cliente Windows/Linux. Capture o tráfego com Wireshark durante a inicialização da interface de rede do cliente. Identifique e rotule cada mensagem DORA, anotando portas, broadcasts e opções principais.",
                              "finalVerifications": [
                                "Desenhar e explicar o diagrama DORA completo com setas e mensagens.",
                                "Listar portas UDP 67/68 e diferenciar cliente/servidor.",
                                "Simular DORA em Wireshark e nomear todas as mensagens corretamente.",
                                "Explicar o que acontece com múltiplos servidores (ofertas concorrentes).",
                                "Configurar interface manualmente simulando DHCPACK e comparar.",
                                "Identificar xid consistente ao longo do processo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência e nomes das 4 fases DORA (100% correto).",
                                "Correta identificação de tipos de mensagem e broadcasts/unicasts.",
                                "Compreensão das portas UDP e opções chave (50,54, lease time).",
                                "Capacidade de analisar captura Wireshark com detalhes.",
                                "Explicação clara de erros comuns como NAK ou falhas.",
                                "Uso correto de terminologia da RFC 2131."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de endereços IP, máscaras de sub-rede e ranges de lease.",
                                "Segurança da Informação: Vulnerabilidades DHCP (rogue servers, spoofing).",
                                "Programação: Implementar cliente/servidor DHCP em Python (scapy).",
                                "Física: Propagação de sinais em redes Ethernet (broadcasts).",
                                "Administração: Gerenciamento de pools de IP em empresas."
                              ],
                              "realWorldApplication": "Em redes domésticas (roteadores Wi-Fi alocam IPs automaticamente), empresas (servidores centralizados evitam conflitos de IP) e data centers (gerenciamento dinâmico de milhares de VMs), o DORA garante configuração plug-and-play sem intervenção manual."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Identificar opções e leases no DHCP",
                            "description": "Explicar opções DHCP como endereço de servidor DNS, gateway padrão e tempo de lease, além de renovação automática antes do vencimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura das mensagens DHCP e localização das opções",
                                  "subSteps": [
                                    "Estude o formato da mensagem DHCP (Discover, Offer, Request, ACK).",
                                    "Identifique a seção 'Options' no final da mensagem DHCP.",
                                    "Aprenda o formato de opções: código (1 byte), comprimento (1 byte), valor (variável).",
                                    "Revise opções obrigatórias como Message Type (opção 53).",
                                    "Pratique lendo diagramas de mensagens DHCP em documentações RFC 2131 e 2132."
                                  ],
                                  "verification": "Desenhe ou anote a estrutura de uma mensagem DHCP destacando a seção de opções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 2131 e 2132 (disponíveis online)",
                                    "Diagramas de mensagens DHCP de sites como Cisco ou Wireshark docs"
                                  ],
                                  "tips": "Use ferramentas visuais como Wireshark dissecação para visualizar a estrutura.",
                                  "learningObjective": "Entender onde e como as opções DHCP são codificadas nas mensagens.",
                                  "commonMistakes": [
                                    "Confundir opções com campos fixos da mensagem.",
                                    "Ignorar o formato variável das opções."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e explicar opções DHCP comuns",
                                  "subSteps": [
                                    "Estude opção 3 (Router/Default Gateway): fornece o IP do gateway padrão.",
                                    "Aprenda opção 6 (DNS Servers): lista de servidores DNS primários e secundários.",
                                    "Revise opção 51 (IP Address Lease Time): duração do lease em segundos.",
                                    "Liste outras opções relevantes como 1 (Subnet Mask) e 15 (Domain Name).",
                                    "Memorize pelo menos 5 opções comuns e seus propósitos."
                                  ],
                                  "verification": "Crie uma tabela listando código, nome e propósito de 5 opções DHCP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de opções DHCP da IANA (iana.org/assignments/bootp-dhcp-parameters)",
                                    "Documentação de servidores DHCP como ISC DHCP"
                                  ],
                                  "tips": "Agrupe opções por categoria: rede (3,1), serviços (6), tempo (51).",
                                  "learningObjective": "Reconhecer e descrever o papel de opções específicas como DNS, gateway e lease time.",
                                  "commonMistakes": [
                                    "Confundir lease time com T1/T2 timers.",
                                    "Achar que todas as opções são obrigatórias."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar o conceito de leases DHCP e renovação automática",
                                  "subSteps": [
                                    "Defina lease: período de alocação temporária de IP para um cliente.",
                                    "Aprenda cálculo de renovação: T1 (50% do lease) para unicast ao servidor, T2 (87.5%) para broadcast.",
                                    "Estude processo: cliente envia REQUEST em T1; se falha, em T2; se ainda falha, reinicia DISCOVER.",
                                    "Simule cronogramas de lease com exemplos numéricos (ex: lease 24h, T1=12h, T2=21h).",
                                    "Revise impactos de leases curtos vs longos em redes."
                                  ],
                                  "verification": "Calcule T1 e T2 para um lease de 3600 segundos e descreva o fluxo de renovação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "RFC 2131 seção sobre lease renewal",
                                    "Simulador online de DHCP ou calculadora de timers"
                                  ],
                                  "tips": "Use uma planilha para calcular porcentagens e timers.",
                                  "learningObjective": "Explicar como leases funcionam e por que a renovação ocorre antes do vencimento.",
                                  "commonMistakes": [
                                    "Confundir T1 com metade exata sem considerar arredondamentos.",
                                    "Pensar que renovação é sempre broadcast."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação de opções e leases em cenários reais",
                                  "subSteps": [
                                    "Instale Wireshark e capture tráfego DHCP em uma rede local.",
                                    "Analise pacotes DHCPOFFER/DHCPACK para extrair opções (3,6,51).",
                                    "Identifique o lease time e calcule T1/T2 do valor observado.",
                                    "Configure um servidor DHCP simples (ex: em Linux com isc-dhcp-server) e teste opções.",
                                    "Compare com logs do servidor para validar renovações automáticas."
                                  ],
                                  "verification": "Capture e anote um exemplo real de opções e lease de um pacote DHCP.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark (gratuito)",
                                    "Máquina virtual com servidor DHCP (ex: Ubuntu + isc-dhcp-server)",
                                    "Rede local ou VM para teste"
                                  ],
                                  "tips": "Filtre por 'bootp' no Wireshark para focar em DHCP.",
                                  "learningObjective": "Aplicar conhecimento para identificar opções e leases em tráfego real.",
                                  "commonMistakes": [
                                    "Não filtrar corretamente pacotes DHCP.",
                                    "Ignorar opções em pacotes REQUEST do cliente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede doméstica, configure um roteador como servidor DHCP com lease de 24 horas, DNS do Google (8.8.8.8) e gateway 192.168.1.1. Use Wireshark no cliente para capturar o DHCPOFFER, identifique opção 51 (lease=86400s), opção 6 (DNS) e opção 3 (gateway), então monitore a renovação em T1 (12h) via logs.",
                              "finalVerifications": [
                                "Liste e explique pelo menos 4 opções DHCP comuns incluindo DNS, gateway e lease time.",
                                "Calcule corretamente T1 e T2 para um lease dado.",
                                "Analise um pacote DHCP capturado e extraia valores de opções.",
                                "Descreva o fluxo completo de renovação automática de lease.",
                                "Identifique diferenças entre configurações de lease curto e longo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de códigos e valores de opções DHCP (90% correto).",
                                "Explicação clara do mecanismo de renovação com timers T1/T2.",
                                "Análise prática de captura de pacotes sem erros de interpretação.",
                                "Uso correto de terminologia técnica (ex: DHCPOFFER, lease time).",
                                "Demonstração de aplicação em cenário real via simulação ou captura.",
                                "Compreensão de impactos de opções em configuração de rede."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos percentuais para timers T1 (50%) e T2 (87.5%).",
                                "Segurança da Informação: Riscos de spoofing de opções DHCP maliciosas.",
                                "Administração de Sistemas: Configuração de servidores DHCP em Linux/Windows.",
                                "Programação: Scripts em Python para parsing de pacotes DHCP com Scapy."
                              ],
                              "realWorldApplication": "Em ambientes corporativos, administradores de rede usam esse conhecimento para configurar DHCP em roteadores/switches, garantindo IPs dinâmicos corretos com DNS e gateways apropriados, evitando falhas de conectividade por expiração de leases; em ISPs, gerencia alocações massivas de IPs para clientes residenciais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Protocolo DNS (Domain Name System)",
                    "description": "Sistema para tradução de nomes de domínio em endereços IP.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Funcionamento Básico do DNS",
                        "description": "Conceito fundamental sobre o propósito e a operação inicial do Domain Name System como protocolo de aplicação que resolve nomes de domínio legíveis por humanos em endereços IP numéricos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Explicar a necessidade do DNS no modelo TCP/IP",
                            "description": "Descrever por que o DNS é essencial no nível de aplicação do modelo TCP/IP, destacando a dificuldade de memorizar endereços IP e a preferência por nomes de domínio, com exemplos como 'www.exemplo.com' para 192.0.2.1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Modelo TCP/IP e seus Níveis",
                                  "subSteps": [
                                    "Estude a estrutura do modelo TCP/IP, identificando os quatro níveis principais: Aplicação, Transporte, Internet e Enlace.",
                                    "Foque no nível de Aplicação, onde protocolos como HTTP, FTP e DNS operam para fornecer serviços de rede ao usuário.",
                                    "Compare o modelo TCP/IP com o OSI para contextualizar, destacando que TCP/IP é mais prático e amplamente usado.",
                                    "Anote exemplos de protocolos em cada nível para fixar a hierarquia.",
                                    "Desenhe um diagrama simples do modelo TCP/IP."
                                  ],
                                  "verification": "Crie um diagrama do modelo TCP/IP e liste pelo menos 3 protocolos do nível de Aplicação, incluindo DNS.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Recursos online sobre modelo TCP/IP (ex: Wikipedia ou Khan Academy)"
                                  ],
                                  "tips": "Use analogias como 'camadas de uma cebola' para visualizar os níveis.",
                                  "learningObjective": "Identificar a posição do nível de Aplicação no modelo TCP/IP e listar protocolos associados.",
                                  "commonMistakes": [
                                    "Confundir TCP/IP com OSI (lembre: TCP/IP tem 4 camadas), ignorar que DNS é aplicação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar as Limitações dos Endereços IP",
                                  "subSteps": [
                                    "Explique o que são endereços IP (IPv4 e IPv6) e seu papel como identificadores numéricos únicos na rede.",
                                    "Discuta a dificuldade humana de memorizar sequências numéricas longas, como 192.0.2.1 ou 2001:db8::1.",
                                    "Simule acessando um site apenas com IP no navegador para demonstrar viabilidade técnica mas inconveniência.",
                                    "Liste cenários onde IPs mudam (DHCP, mobilidade), tornando memorização impraticável.",
                                    "Compare com endereços postais numéricos vs. nomes de ruas."
                                  ],
                                  "verification": "Escreva 3 razões pelas quais endereços IP são difíceis de usar diretamente e teste acessando um site por IP.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Navegador web",
                                    "Lista de IPs públicos de sites conhecidos (ex: Google: 142.250.190.78)"
                                  ],
                                  "tips": "Teste IPs reais em um navegador para vivenciar a experiência.",
                                  "learningObjective": "Reconhecer as limitações ergonômicas e práticas dos endereços IP puros.",
                                  "commonMistakes": [
                                    "Achar que IPs são permanentes (muitos são dinâmicos), confundir IP com MAC."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Nomes de Domínio e a Necessidade de Tradução",
                                  "subSteps": [
                                    "Defina nomes de domínio hierárquicos (ex: www.exemplo.com) como mnemônicos fáceis de lembrar.",
                                    "Explique a estrutura: subdomínio.host.dominio.tld (ex: www.google.com).",
                                    "Discuta preferência humana por nomes legíveis vs. números, com exemplos cotidianos como emails e URLs.",
                                    "Ilustre o problema: sem tradução, usuários precisariam saber IPs exatos, o que é inviável em escala.",
                                    "Pesquise exemplos de domínios famosos e seus IPs correspondentes."
                                  ],
                                  "verification": "Traduza manualmente 3 domínios para IPs usando ferramentas como nslookup e explique a preferência por nomes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Comando nslookup ou site como whatismyipaddress.com",
                                    "Lista de domínios comuns"
                                  ],
                                  "tips": "Use 'ping www.exemplo.com' no terminal para ver resolução automática.",
                                  "learningObjective": "Entender nomes de domínio como interface amigável e necessidade de resolução para IPs.",
                                  "commonMistakes": [
                                    "Confundir domínio com URL completa, achar que domínios são IPs disfarçados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Posicionar o DNS no Nível de Aplicação do TCP/IP",
                                  "subSteps": [
                                    "Descreva o DNS como o 'catálogo telefônico da internet' que mapeia domínios para IPs no nível de Aplicação.",
                                    "Explique como DNS opera sobre UDP/TCP (porta 53), integrando-se ao modelo TCP/IP.",
                                    "Destaque benefícios: escalabilidade, descentralização e facilidade de uso para aplicações como web e email.",
                                    "Simule fluxo: digitar domínio → consulta DNS → obter IP → conectar via TCP/IP.",
                                    "Resuma por que DNS é essencial: resolve abstração de rede para usuários finais."
                                  ],
                                  "verification": "Explique em 1 parágrafo o papel do DNS no TCP/IP, usando o exemplo www.exemplo.com → 192.0.2.1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal ou Wireshark para capturar tráfego DNS",
                                    "Diagramas de fluxo DNS"
                                  ],
                                  "tips": "Visualize com fluxogramas: Usuário → DNS Resolver → Servidor DNS → IP.",
                                  "learningObjective": "Articular a essencialidade do DNS como ponte entre nomes humanos e IPs na rede TCP/IP.",
                                  "commonMistakes": [
                                    "Colocar DNS em nível errado (não é Transporte), subestimar sua ubiquidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Ao digitar 'www.google.com' no navegador, o sistema consulta o DNS para resolver para um IP como 142.250.190.78, permitindo conexão TCP sem que o usuário memorize o número; sem DNS, navegação seria impossível na prática.",
                              "finalVerifications": [
                                "Explicar verbalmente por que memorizar IPs é impraticável.",
                                "Mapear www.exemplo.com para 192.0.2.1 e vice-versa.",
                                "Identificar DNS como protocolo de Aplicação no TCP/IP.",
                                "Simular falha DNS (ex: editar hosts file) e restaurar.",
                                "Listar 3 aplicações que dependem de DNS (web, email, streaming)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do modelo TCP/IP e posição do DNS.",
                                "Clareza nas limitações de IPs vs. facilidade de domínios.",
                                "Uso correto de exemplos concretos como 'www.exemplo.com'.",
                                "Compreensão da tradução nome-IP como função essencial.",
                                "Capacidade de relacionar DNS à usabilidade cotidiana da internet."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Hierarquia de nomes de domínio como gramática natural.",
                                "História: Evolução da internet desde ARPANET até DNS em 1983.",
                                "Segurança da Informação: Vulnerabilidades DNS como spoofing.",
                                "Matemática: Endereçamento binário em IPs e máscaras de sub-rede."
                              ],
                              "realWorldApplication": "No dia a dia, DNS permite acessar sites, apps e serviços cloud sem conhecimento técnico de IPs, facilitando e-commerce, redes sociais e trabalho remoto; falhas DNS causam outages globais, como em 2021 com Fastly."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Identificar o uso de UDP e TCP no DNS",
                            "description": "Explicar como o DNS utiliza principalmente UDP na porta 53 para consultas rápidas e TCP para transferências de zona ou respostas grandes, relacionando ao nível de transporte do modelo TCP/IP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de TCP e UDP no modelo TCP/IP",
                                  "subSteps": [
                                    "Estudar as características principais do UDP: protocolo sem conexão, leve, rápido, sem garantia de entrega ou ordem de pacotes.",
                                    "Analisar as características do TCP: protocolo com conexão, confiável, com controle de fluxo, retransmissão de pacotes perdidos e ordenação.",
                                    "Comparar UDP vs TCP em termos de overhead (cabeçalho UDP: 8 bytes; TCP: 20 bytes mínimo) e uso típico (UDP para streaming/multicast; TCP para web/email).",
                                    "Relacionar ambos ao nível de transporte (camada 4) do modelo TCP/IP.",
                                    "Identificar a porta padrão 53 usada por ambos no contexto de DNS."
                                  ],
                                  "verification": "Resumir em uma tabela comparativa as diferenças entre TCP e UDP, incluindo exemplos de uso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação RFC 768 (UDP) e RFC 793 (TCP)",
                                    "Vídeo introdutório sobre modelo TCP/IP (Khan Academy ou similar)",
                                    "Ferramenta de desenho como Draw.io para tabela"
                                  ],
                                  "tips": "Foquem nas trade-offs: velocidade vs confiabilidade para entender escolhas no DNS.",
                                  "learningObjective": "Compreender as diferenças fundamentais entre UDP e TCP para contextualizar seu uso no DNS.",
                                  "commonMistakes": [
                                    "Confundir UDP como 'não confiável' com 'inútil'; ignorar que TCP tem handshake de 3 vias que adiciona latência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o funcionamento geral do DNS e suas mensagens",
                                  "subSteps": [
                                    "Explicar o papel do DNS: resolução de nomes de domínio (ex: www.exemplo.com → IP).",
                                    "Descrever tipos de mensagens DNS: consultas (queries) e respostas (responses), com tamanho típico de até 512 bytes para UDP.",
                                    "Analisar a estrutura básica de uma mensagem DNS: header (12 bytes), questions, answers, authority, additional.",
                                    "Identificar cenários onde mensagens excedem 512 bytes (muitos registros ou truncamento).",
                                    "Relacionar DNS à camada de aplicação, mas transportado por UDP/TCP na camada de transporte."
                                  ],
                                  "verification": "Desenhar o formato de uma mensagem DNS simples e rotular os campos principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 1035 (DNS)",
                                    "Ferramenta Wireshark para capturar tráfego DNS real",
                                    "Simulador online de DNS como dnsviz.net"
                                  ],
                                  "tips": "Use Wireshark para capturar uma query real e observar o tamanho da resposta.",
                                  "learningObjective": "Dominar a estrutura das mensagens DNS para prever quando UDP é suficiente.",
                                  "commonMistakes": [
                                    "Achar que DNS só usa UDP; ignorar que header DNS + dados podem truncar em UDP."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o uso predominante de UDP no DNS",
                                  "subSteps": [
                                    "Explicar por que UDP/53 é padrão para consultas: baixa latência, sem overhead de conexão, ideal para 99% das queries curtas.",
                                    "Demonstrar com exemplo: dig www.google.com → resposta UDP rápida.",
                                    "Discutir limitações: se resposta >512 bytes, flag TC (truncated) é setada, forçando retry via TCP.",
                                    "Testar em prática: usar nslookup ou dig com +short para queries UDP simples.",
                                    "Verificar em Wireshark: protocolo UDP, porta 53 src/dst."
                                  ],
                                  "verification": "Executar uma query DNS via terminal e confirmar uso de UDP via netstat ou Wireshark.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Comandos: dig, nslookup",
                                    "Wireshark instalado",
                                    "Servidor DNS público como 8.8.8.8"
                                  ],
                                  "tips": "Force UDP com dig @8.8.8.8 +udp exemplo.com para prática controlada.",
                                  "learningObjective": "Identificar cenários onde UDP é escolhido no DNS por eficiência.",
                                  "commonMistakes": [
                                    "Não perceber truncamento em respostas grandes; confundir com falha de rede."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o uso de TCP no DNS e critérios de alternância",
                                  "subSteps": [
                                    "Descrever usos de TCP/53: transferências de zona (AXFR/IXFR entre servidores primários/secundários), queries com EDNS0 (extensões para tamanhos maiores).",
                                    "Explicar fallback: cliente detecta TC flag em UDP e reconecta via TCP.",
                                    "Demonstrar: dig @8.8.8.8 +tcp exemplo.com ou zone transfer (se autorizado).",
                                    "Analisar overhead: TCP útil para grandes respostas (DNSSEC, muitos TXT records).",
                                    "Relacionar ao modelo TCP/IP: transporte confiável para dados críticos."
                                  ],
                                  "verification": "Forçar uma query TCP e comparar tempo/latência com UDP equivalente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Comandos dig +tcp",
                                    "Wireshark para comparar pacotes UDP vs TCP",
                                    "Documentação EDNS(0) RFC 6891"
                                  ],
                                  "tips": "Use domínios com muitos records (ex: com DNSSEC) para forçar TCP naturalmente.",
                                  "learningObjective": "Reconhecer quando e por que DNS alterna para TCP.",
                                  "commonMistakes": [
                                    "Achar TCP 'lento demais' para DNS; ignorar zone transfers como caso principal."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e relacionar UDP/TCP ao contexto DNS no TCP/IP",
                                  "subSteps": [
                                    "Criar fluxograma: query DNS → UDP → se TC → TCP.",
                                    "Explicar decisão de design: otimizar para queries comuns (UDP) vs raros grandes (TCP).",
                                    "Discutir impacto na performance: latência UDP ~1 RTT vs TCP ~3 RTTs iniciais.",
                                    "Relacionar à camada transporte: DNS/app sobre UDP/TCP.",
                                    "Testar troubleshooting: bloquear UDP/53 e observar fallback TCP."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o fluxograma completo de seleção UDP/TCP.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma (Lucidchart ou papel)",
                                    "Firewall local para simular bloqueio UDP"
                                  ],
                                  "tips": "Simule rede lenta para destacar diferenças de latência.",
                                  "learningObjective": "Integrar conhecimento em uma visão holística do uso de protocolos no DNS.",
                                  "commonMistakes": [
                                    "Generalizar UDP como sempre melhor; esquecer contexto de zona transfers."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture tráfego durante 'dig www.cloudflare.com TXT' (grande resposta com DNSSEC): observe query UDP inicial, truncamento (flag TC), retry automático via TCP, confirmando o mecanismo de fallback.",
                              "finalVerifications": [
                                "Explicar corretamente por que DNS prefere UDP para consultas rápidas.",
                                "Identificar cenários de uso de TCP (zone transfer, respostas >512 bytes).",
                                "Demonstrar com Wireshark ou dig a diferença entre UDP e TCP em queries.",
                                "Desenhar fluxograma preciso de seleção de protocolo no DNS.",
                                "Relacionar ao nível de transporte TCP/IP sem erros.",
                                "Prever comportamento em rede com UDP/53 bloqueado (fallback TCP)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de características UDP vs TCP (90% acerto).",
                                "Correta identificação de porta 53 e mecanismos de truncamento/fallback.",
                                "Uso prático de ferramentas (dig/Wireshark) com evidências capturadas.",
                                "Fluxograma ou tabela comparativa clara e completa.",
                                "Explicação integrada ao modelo TCP/IP e contexto DNS.",
                                "Ausência de confusões comuns (ex: TCP só para web)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de overhead de pacotes e latência (RTT).",
                                "Física: Analogia com transmissão de sinais (UDP como rádio unidirecional).",
                                "Segurança da Informação: Impacto em DNSSEC (requer TCP para grandes assinaturas).",
                                "Desenvolvimento de Software: Implementação de resolvers DNS em código (bibliotecas como dns-python)."
                              ],
                              "realWorldApplication": "Em troubleshooting de rede lenta, identificar se bloqueio de UDP/53 causa fallback TCP (aumenta latência de sites); administradores de DNS usam isso para zone transfers seguras entre servidores; CDNs como Cloudflare otimizam queries UDP para carregamento rápido de páginas web."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Diferenciar resolução recursiva e iterativa",
                            "description": "Comparar os modos de resolução de nomes no DNS: recursiva (resolvida completamente pelo servidor consultado) e iterativa (cliente recebe referências sucessivas até o servidor autoritativo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o funcionamento da resolução recursiva no DNS",
                                  "subSteps": [
                                    "Estude a definição: na resolução recursiva, o servidor DNS consultado assume a responsabilidade total de resolver o nome até encontrar a resposta final.",
                                    "Analise o fluxo: cliente envia query ao resolver local, que consulta root server, recebe delegação para TLD server e continua recursivamente até o authoritative server.",
                                    "Desenhe um diagrama simples mostrando as queries e responses encadeadas de volta ao cliente.",
                                    "Identifique vantagens: simplicidade para o cliente, mas alto load nos servidores upstream.",
                                    "Registre exemplos de servidores que usam recursiva por padrão (ex: ISPs)."
                                  ],
                                  "verification": "Desenhe e explique o diagrama recursivo para um domínio como www.example.com sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 1034/1035 sobre DNS",
                                    "Ferramenta de desenho como Draw.io",
                                    "Vídeo tutorial sobre DNS recursion"
                                  ],
                                  "tips": [
                                    "Use setas bidirecionais no diagrama para mostrar queries forward e responses backward.",
                                    "Comece do cliente e vá subindo a hierarquia DNS.",
                                    "Teste com nslookup em modo debug para observar."
                                  ],
                                  "learningObjective": "Explicar o processo recursivo passo a passo, identificando responsabilidades dos servidores.",
                                  "commonMistakes": [
                                    "Confundir recursiva com iterativa achando que cliente faz múltiplas queries.",
                                    "Ignorar o retorno da resposta completa pelo servidor recursivo.",
                                    "Esquecer o papel do cache no resolver local."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o funcionamento da resolução iterativa no DNS",
                                  "subSteps": [
                                    "Defina iterativa: o servidor consultado responde com a melhor informação disponível (referência ou erro), e o cliente (ou resolver) faz a próxima query.",
                                    "Mapeie o fluxo: cliente query root -> recebe TLD NS -> query TLD -> recebe authoritative NS -> query authoritative -> IP final.",
                                    "Crie um diagrama mostrando múltiplas queries iniciadas pelo cliente/resolver.",
                                    "Discuta vantagens: distribui load, útil para resolvers stub em aplicações.",
                                    "Compare com comandos como dig +trace para visualizar iteração."
                                  ],
                                  "verification": "Simule verbalmente ou no diagrama a resolução iterativa para o mesmo domínio, listando cada referral.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Comando dig ou nslookup no terminal",
                                    "RFC 1034 seção sobre iterative queries",
                                    "Ferramenta de desenho"
                                  ],
                                  "tips": [
                                    "Execute 'dig example.com +trace' para ver iteração real.",
                                    "Note que cada resposta é parcial, forçando nova query.",
                                    "Destaque referrals (NS records) como chaves."
                                  ],
                                  "learningObjective": "Descrever o processo iterativo, enfatizando referrals sucessivos e responsabilidade do cliente.",
                                  "commonMistakes": [
                                    "Pensar que servidor faz todo o trabalho como na recursiva.",
                                    "Confundir com forwarders que ainda são recursivos.",
                                    "Subestimar o número de round-trips necessários."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar diferenças chave entre resolução recursiva e iterativa",
                                  "subSteps": [
                                    "Liste diferenças: recursiva (servidor resolve tudo, 1 query do cliente); iterativa (cliente faz múltiplas queries, referrals).",
                                    "Compare em tabela: load (recursiva sobrecarrega upstream; iterativa distribui), latência (recursiva pode ser mais lenta para servidor, mas 1 RTT para cliente), uso (recursiva em resolvers locais; iterativa em apps).",
                                    "Analise cenários: quando usar cada (ex: recursiva para usuários finais, iterativa para debugging).",
                                    "Discuta trade-offs: segurança (recursiva mais suscetível a cache poisoning), performance.",
                                    "Crie uma tabela comparativa com 5-7 critérios."
                                  ],
                                  "verification": "Apresente a tabela comparativa e explique 3 diferenças principais com exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Exemplos de traces dig/nslookup"
                                  ],
                                  "tips": [
                                    "Use critérios como: número de queries, quem inicia, tipo de resposta.",
                                    "Teste ambos modos com ferramentas para validar.",
                                    "Pense em escalabilidade de servidores root."
                                  ],
                                  "learningObjective": "Identificar e justificar diferenças, trade-offs e usos apropriados de cada método.",
                                  "commonMistakes": [
                                    "Ignorar latência de rede em iteração.",
                                    "Achar que recursiva é sempre melhor sem considerar load.",
                                    "Confundir com recursive vs caching-only servers."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e validar as resoluções em um ambiente prático",
                                  "subSteps": [
                                    "Configure ambiente: use dig ou nslookup para simular recursiva (padrão) e iterativa (+trace ou manual).",
                                    "Execute simulações: resolva um domínio real em ambos modos, capture outputs.",
                                    "Analise logs: conte queries, identifique referrals vs respostas finais.",
                                    "Discuta impactos: tempo total, falhas potenciais (ex: timeout em iteração longa).",
                                    "Documente conclusões em um relatório curto."
                                  ],
                                  "verification": "Compartilhe logs de simulação mostrando diferenças claras nos outputs.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Terminal com dig/nslookup instalado",
                                    "Domínios de teste como google.com",
                                    "Editor de texto para logs"
                                  ],
                                  "tips": [
                                    "Use 'dig @8.8.8.8 domain +norecurse' para forçar iteração.",
                                    "Compare tempos com 'dig +stats'.",
                                    "Teste com falha intencional (domínio inválido)."
                                  ],
                                  "learningObjective": "Aplicar conceitos em prática, validando diferenças através de experimentos reais.",
                                  "commonMistakes": [
                                    "Não habilitar debug/trace, perdendo visibilidade.",
                                    "Usar apenas cache local sem flush.",
                                    "Interpretar erroneamente referrals como erros."
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver 'www.google.com': Na recursiva, seu resolver local (ex: 8.8.8.8) consulta root (.), recebe delegação para .com NS, consulta .com NS recursivamente até google.com authoritative, retorna IP completo em uma resposta. Na iterativa, resolver faz: query root -> NS .com; query .com NS -> NS google.com; query google.com NS -> IP; múltiplas respostas parciais.",
                              "finalVerifications": [
                                "Explicar recursiva: servidor resolve tudo, cliente recebe resposta final única.",
                                "Explicar iterativa: cliente recebe referrals, faz queries sucessivas.",
                                "Listar 3 diferenças chave (load, latência, uso).",
                                "Simular fluxograma para ambos em um domínio dado.",
                                "Identificar quando um ISP usaria recursiva vs app usando iterativa.",
                                "Analisar trace de dig mostrando iteração."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%)",
                                "Profundidade comparativa: tabela ou lista com trade-offs claros (25%)",
                                "Evidências práticas: logs ou diagramas de simulações (20%)",
                                "Clareza explicativa: linguagem simples e exemplos concretos (15%)",
                                "Compreensão de impactos: load, performance, segurança (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com recursão (funções chamando a si) vs iteração (loops).",
                                "Programação: Implementar DNS resolver recursivo vs iterativo em Python.",
                                "Segurança da Informação: Vulnerabilidades como DNS cache poisoning em recursiva.",
                                "Administração de Redes: Configuração de BIND servers (recursion yes/no).",
                                "Engenharia de Software: Design de sistemas distribuídos e escalabilidade."
                              ],
                              "realWorldApplication": "Em redes reais, resolvers públicos como 8.8.8.8 usam recursiva para simplicidade do usuário final, reduzindo latência percebida; desenvolvedores usam iterativa em ferramentas como dig +trace para debugging e monitoramento, evitando sobrecarga em servidores root durante outages ou análises de propagação DNS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Hierarquia e Servidores DNS",
                        "description": "Estrutura distribuída e hierárquica do DNS, incluindo servidores raiz, de topo de domínio (TLD) e autoritativos, para escalabilidade global.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Descrever a hierarquia de servidores DNS",
                            "description": "Mapear a pirâmide DNS: servidores raiz (13 grupos mundiais), servidores TLD (.com, .br), servidores autoritativos de domínios e servidores stub/resolvers locais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral da hierarquia DNS",
                                  "subSteps": [
                                    "Explicar o papel do DNS como sistema de tradução de nomes para IPs",
                                    "Identificar os quatro níveis principais da pirâmide: raiz, TLD, autoritativo e resolver local",
                                    "Desenhar um diagrama simples da pirâmide hierárquica",
                                    "Comparar com uma árvore genealógica para visualizar a delegação",
                                    "Listar as vantagens da hierarquia (escalabilidade e distribuição)"
                                  ],
                                  "verification": "Desenhar e explicar corretamente o diagrama da pirâmide com os 4 níveis",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a um diagrama DNS online (ex: Wikipedia DNS hierarchy)"
                                  ],
                                  "tips": "Use cores diferentes para cada nível no diagrama para facilitar a memorização",
                                  "learningObjective": "Dominar o conceito fundamental da arquitetura hierárquica do DNS",
                                  "commonMistakes": [
                                    "Confundir hierarquia com rede peer-to-peer",
                                    "Omitir o nível dos resolvers locais",
                                    "Achar que todos os servidores são centrais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar os servidores raiz (Root Servers)",
                                  "subSteps": [
                                    "Memorizar que existem 13 grupos de servidores raiz mundiais (letras A a M)",
                                    "Explicar sua localização (distribuídos globalmente com anycast)",
                                    "Entender que respondem com referências para servidores TLD",
                                    "Pesquisar exemplos de IPs raiz (ex: 198.41.0.4 para a.root-servers.net)",
                                    "Simular uma consulta raiz para um TLD como .com"
                                  ],
                                  "verification": "Listar pelo menos 5 root servers e descrever sua função principal",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista oficial de root servers (iana.org/domains/root/servers)",
                                    "Ferramenta dig ou nslookup"
                                  ],
                                  "tips": "Use o comando 'dig . NS' para ver root hints na prática",
                                  "learningObjective": "Compreender o papel inicial dos root servers na resolução DNS",
                                  "commonMistakes": [
                                    "Achar que há apenas 13 servidores físicos (são grupos anycast)",
                                    "Confundir com TLD",
                                    "Ignorar a redundância global"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar os servidores TLD (Top-Level Domain)",
                                  "subSteps": [
                                    "Classificar TLDs em genéricos (.com, .org) e patrocinados (.br, .gov)",
                                    "Explicar como root servers delegam para TLDs",
                                    "Identificar autoridades TLD (ex: Verisign para .com, NIC.br para .br)",
                                    "Descrever a resposta TLD: referral para servidores de domínio específico",
                                    "Pesquisar quantidade aproximada de TLDs (mais de 1500)"
                                  ],
                                  "verification": "Mapear a cadeia: root -> TLD para um exemplo como example.com.br",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Site IANA TLD list (iana.org/domains/root/db)",
                                    "Comando 'dig com NS'"
                                  ],
                                  "tips": "Pratique com domínios nacionais e internacionais para ver diferenças",
                                  "learningObjective": "Dominar o nível intermediário de delegação TLD",
                                  "commonMistakes": [
                                    "Confundir TLD com domínios de segundo nível",
                                    "Achar que TLDs resolvem IPs finais",
                                    "Ignorar ccTLDs como .br"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar servidores autoritativos e resolvers locais",
                                  "subSteps": [
                                    "Definir servidores autoritativos: hospedam zonas DNS de domínios específicos",
                                    "Explicar stub resolvers (em hosts locais) e recursive resolvers (ISP)",
                                    "Mapear o fluxo completo: local -> raiz -> TLD -> autoritativo",
                                    "Discutir cache em resolvers para otimização",
                                    "Simular resolução completa com ferramenta"
                                  ],
                                  "verification": "Traçar o caminho completo de resolução para www.exemplo.com.br",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta nslookup ou dig",
                                    "Wireshark para capturar tráfego DNS (opcional)"
                                  ],
                                  "tips": "Ative trace no dig: 'dig +trace www.example.com' para visualizar a hierarquia real",
                                  "learningObjective": "Integrar todos os níveis e entender o processo de resolução end-to-end",
                                  "commonMistakes": [
                                    "Confundir autoritativo com recursivo",
                                    "Omitir o papel do cache local",
                                    "Achar que resolvers são sempre stub"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver 'www.gov.br': 1) Resolver local consulta raiz; 2) Raiz indica TLD .br (NIC.br); 3) TLD .br indica autoritativo de gov.br; 4) Autoritativo retorna IP de www.gov.br. Use 'dig +trace www.gov.br' para ver na prática.",
                              "finalVerifications": [
                                "Desenhar a pirâmide DNS completa com exemplos de cada nível",
                                "Executar e interpretar 'dig +trace' para um domínio real",
                                "Explicar verbalmente o fluxo de resolução de um domínio ccTLD como .br",
                                "Listar 13 root servers e funções de TLD/autoritativos",
                                "Identificar diferenças entre stub resolver e servidor autoritativo",
                                "Simular falha em um nível e prever impacto"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e sequência dos 4 níveis da hierarquia",
                                "Correta descrição de funções e delegações entre servidores",
                                "Capacidade de mapear resolução real com ferramentas como dig",
                                "Uso de exemplos concretos (root, TLD .br, autoritativo)",
                                "Compreensão de conceitos como anycast, cache e recursão",
                                "Clareza no diagrama e explicação oral/escrita"
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Vulnerabilidades como DNS cache poisoning e hijacking",
                                "Programação: Implementar consultas DNS com bibliotecas como dns-python",
                                "Redes de Computadores: Integração com UDP/TCP e protocolos de roteamento",
                                "História da Computação: Evolução do DNS desde 1983 (RFC 882)",
                                "Gestão de Projetos: Escalabilidade em sistemas distribuídos globais"
                              ],
                              "realWorldApplication": "Diagnosticar falhas de conectividade (ex: 'site não resolve'), configurar domínios em provedores como Cloudflare, mitigar ataques DDoS via anycast root servers, ou desenvolver apps que usam APIs DNS para monitoramento de disponibilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Exemplificar o processo de resolução de um nome",
                            "description": "Simular passo a passo a resolução de 'www.exemplo.com': consulta ao stub resolver, root, TLD .com, autoritativo exemplo.com, até obter o IP do registro A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Iniciar a consulta via Stub Resolver",
                                  "subSteps": [
                                    "Identifique o nome de domínio a resolver: 'www.exemplo.com'.",
                                    "O aplicativo (ex: navegador) chama a API do sistema operacional (stub resolver).",
                                    "O stub resolver verifica cache local primeiro.",
                                    "Se não em cache, prepara consulta recursiva ou iterativa para o root.",
                                    "Envie a consulta DNS padrão (tipo A para IPv4)."
                                  ],
                                  "verification": "Execute 'nslookup www.exemplo.com' e confirme que a consulta inicial é gerada sem erro imediato.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Comando nslookup ou dig no terminal; diagrama de stub resolver.",
                                  "tips": "Use modo debug no nslookup (+trace) para visualizar o processo completo.",
                                  "learningObjective": "Compreender o papel inicial do stub resolver na resolução DNS.",
                                  "commonMistakes": "Confundir stub resolver com root servers; ignorar verificação de cache local."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Consulta aos Root Name Servers",
                                  "subSteps": [
                                    "Stub resolver envia consulta para um root server (ex: a.root-servers.net).",
                                    "Root server responde com NS records para TLD .com.",
                                    "Inclui glue records com IPs dos TLD servers.",
                                    "Stub resolver armazena no cache e prossegue para TLD.",
                                    "Confirme resposta com código NOERROR."
                                  ],
                                  "verification": "No trace do nslookup, verifique resposta do root apontando para TLD .com servers.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ferramenta dig com 'dig +trace www.exemplo.com'; lista de root servers.",
                                  "tips": "Lembre que há 13 root servers lógicos; escolha um próximo geograficamente.",
                                  "learningObjective": "Explicar como root servers direcionam para hierarquia TLD.",
                                  "commonMistakes": "Achar que root resolve o nome final; ignorar glue records."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Consulta aos TLD Name Servers (.com)",
                                  "subSteps": [
                                    "Stub resolver consulta TLD server para .com (ex: a.gtld-servers.net).",
                                    "TLD responde com NS records para domínio 'exemplo.com'.",
                                    "Inclui glue records com IPs dos authoritative NS de exemplo.com.",
                                    "Armazene no cache e avance para authoritative servers.",
                                    "Verifique autoridade na resposta (AA flag)."
                                  ],
                                  "verification": "No trace, confirme TLD resposta listando NS para exemplo.com.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama hierarquia DNS; ferramenta dig com servidor específico.",
                                  "tips": "TLD servers só sabem sobre domínios sob sua zona, não resolvem final.",
                                  "learningObjective": "Diferenciar responsabilidades de TLD vs authoritative servers.",
                                  "commonMistakes": "Confundir TLD com SLD; pular glue records na simulação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Consulta aos Authoritative Name Servers",
                                  "subSteps": [
                                    "Consulta NS de exemplo.com (ex: ns1.exemplo.com).",
                                    "Authoritative server retorna registro A para 'www.exemplo.com' com IP (ex: 93.184.216.34).",
                                    "Resposta tem flag AA (Authoritative Answer).",
                                    "Stub resolver cacheia o IP e retorna ao aplicativo.",
                                    "Conclua com resolução bem-sucedida."
                                  ],
                                  "verification": "Trace mostra IP final de www.exemplo.com com AA flag.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplo real via dig; whois para NS de exemplo.com.",
                                  "tips": "Exemplo.com é mantido pela IANA para demos; use IPs reais.",
                                  "learningObjective": "Identificar resposta final authoritative e tipos de registros.",
                                  "commonMistakes": "Parar no NS sem buscar A record; confundir CNAME com A."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificação e Cache da Resolução Completa",
                                  "subSteps": [
                                    "Revise todos os steps: stub -> root -> TLD -> authoritative.",
                                    "Confirme cache em cada nível reduz tempos futuros.",
                                    "Teste resolução repetida para ver cache hit.",
                                    "Discuta TTL em cada resposta.",
                                    "Documente o caminho completo."
                                  ],
                                  "verification": "Resolução segunda vez é instantânea via cache; liste TTLs observados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Log do nslookup/dig; ferramenta para flush cache (ipconfig /flushdns).",
                                  "tips": "TTL varia: root longo, A curto; afeta frequência de reconsulta.",
                                  "learningObjective": "Entender impacto de cache e TTL na eficiência DNS.",
                                  "commonMistakes": "Ignorar TTL; achar cache é só local."
                                }
                              ],
                              "practicalExample": "Usando terminal: dig +trace www.exemplo.com. Observe: stub consulta root (a.root-servers.net), root aponta TLD (a.gtld-servers.net), TLD aponta ns1.exemplo.com, authoritative retorna 93.184.216.34 (A record).",
                              "finalVerifications": [
                                "Descreva verbalmente os 4 níveis hierárquicos sem erros.",
                                "Execute dig +trace e identifique cada servidor no log.",
                                "Explique glue records em pelo menos um step.",
                                "Simule falha em TLD e prediga impacto.",
                                "Liste tipos de registros envolvidos (NS, A, glue).",
                                "Confirme cache com segunda consulta rápida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência hierárquica (100% dos steps corretos).",
                                "Detalhe em substeps e verificações (mínimo 4 por step).",
                                "Uso correto de ferramentas (trace/debug flags).",
                                "Compreensão de cache/TTL/glue (explicação clara).",
                                "Identificação de flags DNS (NOERROR, AA).",
                                "Aplicação a exemplo real sem desvios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores hierárquicas e grafos de dependência.",
                                "Segurança da Informação: DNSSEC para validação de respostas.",
                                "Redes: Protocolo UDP/TCP no DNS (porta 53).",
                                "Programação: Implementar resolver simples em Python (socket).",
                                "História da Computação: Evolução do DNS desde 1983."
                              ],
                              "realWorldApplication": "Todo acesso web (HTTPS, email) inicia com DNS resolution; falhas causam 'site não encontrado'; administradores usam para troubleshooting de lentidão ou hijacking em redes empresariais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Reconhecer tipos de servidores DNS",
                            "description": "Classificar servidores como: raiz (root), TLD, autoritativo (name servers), resolver (local ou forwarding) e caching-only.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a hierarquia geral do DNS",
                                  "subSteps": [
                                    "Ler sobre o funcionamento básico do Domain Name System (DNS) e sua estrutura hierárquica em árvore.",
                                    "Identificar os níveis principais: raiz, domínios de topo (TLD), domínios autoritativos e resolvers.",
                                    "Visualizar diagramas da hierarquia DNS para fixar a sequência de consultas.",
                                    "Explicar em suas palavras como uma consulta DNS viaja pela hierarquia.",
                                    "Comparar DNS com um diretório telefônico distribuído."
                                  ],
                                  "verification": "Desenhar ou descrever um diagrama simples da hierarquia DNS com pelo menos 4 níveis corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Diagramas de hierarquia DNS (ex: Wikipedia ou RFC 1034)",
                                    "Papel e caneta para esboço"
                                  ],
                                  "tips": "Comece pelo topo da hierarquia (raiz) e desça gradualmente para evitar confusão.",
                                  "learningObjective": "Entender a estrutura hierárquica do DNS como base para classificar servidores.",
                                  "commonMistakes": [
                                    "Confundir hierarquia com infraestrutura física de servidores",
                                    "Ignorar o papel recursivo dos resolvers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e classificar servidores raiz (root)",
                                  "subSteps": [
                                    "Estudar a função dos servidores raiz: respondem com referências para servidores TLD.",
                                    "Memorizar que há 13 grupos de servidores raiz IP (letras A-M) gerenciados pela IANA.",
                                    "Ler exemplos de consultas para root servers (ex: dig . NS).",
                                    "Listar características únicas: IPs fixos, alta redundância global.",
                                    "Explicar por que root servers não resolvem domínios finais."
                                  ],
                                  "verification": "Executar 'dig . NS' e identificar pelo menos 3 root servers na resposta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta dig ou nslookup instalada",
                                    "Documentação IANA root servers"
                                  ],
                                  "tips": "Use terminais online se não tiver dig instalado localmente.",
                                  "learningObjective": "Reconhecer root servers como o primeiro nível de referência na hierarquia.",
                                  "commonMistakes": [
                                    "Pensar que root servers resolvem domínios como google.com",
                                    "Confundir com TLD"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar servidores TLD e autoritativos",
                                  "subSteps": [
                                    "Aprender sobre TLD servers: gerenciam domínios de topo como .com, .br (ex: gerenciados por Verisign).",
                                    "Estudar name servers autoritativos: detêm registros SOA e respondem com IPs finais de domínios específicos.",
                                    "Comparar: TLD delega para autoritativos via NS records.",
                                    "Executar consultas: 'dig com. NS' para TLD e 'dig example.com NS' para autoritativos.",
                                    "Anotar diferenças em uma tabela comparativa."
                                  ],
                                  "verification": "Classificar corretamente 2 TLD e 2 name servers autoritativos em uma consulta real.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Comando dig/nslookup",
                                    "Lista de TLDs da IANA"
                                  ],
                                  "tips": "Foque em NS records nas respostas para identificar delegações.",
                                  "learningObjective": "Distinguir TLD de autoritativos pela função de delegação e resolução final.",
                                  "commonMistakes": [
                                    "Confundir TLD com registrars como GoDaddy",
                                    "Achar que autoritativos são só para domínios grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar resolvers e caching-only servers",
                                  "subSteps": [
                                    "Definir resolvers: locais (stub/resolver no cliente) ou forwarding (encaminham para upstream).",
                                    "Explicar caching-only: armazenam respostas mas não são autoritativos nem encaminham novas consultas.",
                                    "Comparar tipos: local resolve recursivamente, forwarding delega, caching otimiza repetições.",
                                    "Simular com 'dig @8.8.8.8 example.com' (resolver público Google).",
                                    "Criar fluxograma de como um resolver interage com a hierarquia."
                                  ],
                                  "verification": "Descrever diferenças entre resolver local, forwarding e caching-only com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação BIND ou Unbound",
                                    "Ferramentas de teste DNS"
                                  ],
                                  "tips": "Teste com resolvers diferentes para ver velocidades e caches.",
                                  "learningObjective": "Reconhecer resolvers como o elo cliente-hierarquia e caching como otimizador.",
                                  "commonMistakes": [
                                    "Confundir resolver com autoritativo",
                                    "Ignorar que caching-only não responde recursivamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Execute 'dig www.example.com +trace' no terminal. Analise o trace: identifique root servers (primeira resposta), TLD (.com NS), autoritativos (example.com NS), e note como seu resolver local inicia o processo.",
                              "finalVerifications": [
                                "Classificar corretamente os 5 tipos de servidores DNS em uma lista aleatória.",
                                "Explicar o papel de cada tipo em uma resolução DNS completa.",
                                "Identificar tipos em uma saída real de 'dig +trace'.",
                                "Diferenciar resolver de caching-only em cenários práticos.",
                                "Listar pelo menos 2 exemplos reais de cada tipo (ex: a.root-servers.net para root)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação: 100% correto nos 5 tipos.",
                                "Compreensão funcional: explicação clara do fluxo hierárquico.",
                                "Aplicação prática: análise correta de traces DNS.",
                                "Diferenciação: distinção sem confusões entre tipos semelhantes.",
                                "Profundidade: inclusão de exemplos reais e características únicas.",
                                "Clareza na comunicação: fluxogramas ou tabelas bem estruturados."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Vulnerabilidades como DNS cache poisoning em caching-only.",
                                "Administração de Sistemas: Configuração de resolvers em BIND para redes empresariais.",
                                "Desenvolvimento Web: Integração de DNS em aplicações (ex: APIs de resolução).",
                                "Redes de Computadores: Relação com protocolos como UDP/TCP no transporte DNS.",
                                "Matemática: Árvores e grafos na modelagem da hierarquia DNS."
                              ],
                              "realWorldApplication": "Em uma empresa de TI, configurar um resolver forwarding local para otimizar consultas DNS, reduzindo latência e tráfego para root/TLD, enquanto usa caching-only para acelerar acessos repetidos a sites internos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Recursos Avançados e Gerenciamento DNS",
                        "description": "Mecanismos de cache, TTL, registros DNS e questões de segurança no protocolo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Explicar cache e TTL no DNS",
                            "description": "Detalhar como o cache de resolvers armazena respostas com Time To Live (TTL) para reduzir tráfego, e impactos de expiração no desempenho da rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Cache no DNS",
                                  "subSteps": [
                                    "Defina cache como uma cópia temporária de dados para acesso rápido.",
                                    "Explique o problema de resolução DNS sem cache: consultas repetidas ao servidor raiz causam latência e tráfego excessivo.",
                                    "Identifique os tipos de resolvers DNS: stub, recursive e root.",
                                    "Descreva o fluxo básico de uma consulta DNS: cliente -> stub -> recursive resolver.",
                                    "Discuta benefícios do cache: redução de latência e economia de banda."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando uma consulta DNS com e sem cache, destacando o número de hops.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação RFC 1034/1035 sobre DNS",
                                    "Ferramenta de desenho como Draw.io ou papel e caneta"
                                  ],
                                  "tips": "Use analogias como 'cache é como anotar um número de telefone para não discar toda vez'.",
                                  "learningObjective": "Entender o papel fundamental do cache na otimização de consultas DNS.",
                                  "commonMistakes": [
                                    "Confundir cache de resolver com cache do navegador",
                                    "Ignorar que cache é distribuído em múltiplos níveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Funcionamento do Cache em Resolvers DNS",
                                  "subSteps": [
                                    "Descreva como o recursive resolver armazena respostas positivas e negativas no cache.",
                                    "Explique a estrutura de um registro DNS: NAME, TYPE, CLASS, TTL, RDLENGTH, RDATA.",
                                    "Simule o armazenamento: ao receber resposta, resolver salva com TTL atual.",
                                    "Discuta cache hierárquico: authoritative servers também cacheiam subdomínios.",
                                    "Teste com ferramenta: use 'dig example.com' e observe se resposta vem de cache local."
                                  ],
                                  "verification": "Execute 'dig @8.8.8.8 example.com' duas vezes consecutivas e compare tempos de resposta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Comando dig ou nslookup instalado",
                                    "Terminal ou Wireshark para captura de pacotes"
                                  ],
                                  "tips": "Repita a consulta imediatamente para ver 'cache hit' (QUERY: 0, ANSWER: >0).",
                                  "learningObjective": "Dominar como resolvers armazenam e reutilizam respostas DNS.",
                                  "commonMistakes": [
                                    "Achar que TTL é fixo para todos registros",
                                    "Não diferenciar cache recursivo de forwarding"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Mecanismo de Time To Live (TTL)",
                                  "subSteps": [
                                    "Defina TTL como o tempo de validade de um registro DNS em segundos.",
                                    "Explique origem: definido pelo authoritative server no campo TTL do recurso.",
                                    "Descreva contagem regressiva: resolver decrementa TTL a cada consulta ou timer.",
                                    "Discuta valores típicos: 300s para A records dinâmicos, 86400s para estáticos.",
                                    "Simule expiração: configure TTL baixo em zona de teste e observe invalidação."
                                  ],
                                  "verification": "Use 'dig +trace example.com' e anote TTLs variados em diferentes servidores.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Servidor DNS local como BIND para testes",
                                    "Documentação sobre zona files"
                                  ],
                                  "tips": "TTL baixo = flexibilidade alta, mas mais tráfego; alto = estabilidade, risco de dados obsoletos.",
                                  "learningObjective": "Compreender como TTL controla a frescura e reutilização do cache.",
                                  "commonMistakes": [
                                    "Confundir TTL de DNS com TTL de IP",
                                    "Ignorar que TTL é por registro, não por domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Impactos da Expiração do Cache e Desempenho",
                                  "subSteps": [
                                    "Descreva o que ocorre na expiração: registro marcado inválido, próxima consulta gera nova query recursiva.",
                                    "Quantifique impacto: aumento súbito de tráfego se muitos registros expiram juntos (thundering herd).",
                                    "Discuta estratégias de mitigação: TTL escalonado, pre-fetching em resolvers modernos.",
                                    "Analise cenários: falha de servidor raiz causa 'cache stampede' em expirações em massa.",
                                    "Meça desempenho: compare latência com TTL baixo vs alto usando ferramentas de benchmark."
                                  ],
                                  "verification": "Crie um relatório curto com métricas: tráfego sem cache vs com TTL=3600s.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramentas como dnsperf ou resperf",
                                    "Gráficos de latência via ping ou dig"
                                  ],
                                  "tips": "Em produção, monitore logs de resolver para padrões de cache miss.",
                                  "learningObjective": "Avaliar trade-offs de cache e TTL no desempenho de rede.",
                                  "commonMistakes": [
                                    "Subestimar latência em redes WAN",
                                    "Não considerar cache negativo para NXDOMAIN"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um servidor DNS local com zona 'meudominio.com' com A record TTL=60s. Faça 10 consultas com 'dig' a cada 30s, observe cache hits nos primeiros e misses após expiração, medindo tempo e tráfego com Wireshark. Simule pico alterando IP e veja propagação lenta devido a TTL baixo.",
                              "finalVerifications": [
                                "Explique verbalmente ou por escrito o fluxo completo de cache + TTL em uma consulta DNS.",
                                "Desenhe um diagrama de sequência mostrando hit, miss e expiração.",
                                "Preveja comportamento: o que acontece se TTL=0? (Não cacheável).",
                                "Identifique em uma saída de 'dig +trace' os valores de TTL e interprete.",
                                "Simule cenário: rede com 1000 clientes, TTL expira - calcule aumento de queries.",
                                "Diferencie cache de resolver vs browser DNS cache."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de cache, resolver e TTL (30%)",
                                "Profundidade técnica: inclusão de RFCs, estruturas de pacotes e exemplos práticos (25%)",
                                "Análise de impactos: discussão clara de trade-offs desempenho vs frescura (20%)",
                                "Evidências práticas: demonstrações com ferramentas e métricas (15%)",
                                "Clareza e estrutura: explicação lógica, diagramas e verificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Analogia com page cache e LRU eviction policies.",
                                "Bancos de Dados: Cache de queries com TTL similar a Redis EXPIRE.",
                                "Desenvolvimento Web: Otimização de performance em CDNs como Cloudflare DNS cache.",
                                "Matemática: Modelagem probabilística de cache hit ratio = 1 - (1/hit_rate)^queries.",
                                "Segurança da Informação: Impacto de cache poisoning (DNSSEC mitiga)."
                              ],
                              "realWorldApplication": "Em grandes provedores como Google DNS (8.8.8.8), cache com TTL otimiza bilhões de queries diárias, reduzindo latência global de 200ms para <50ms; durante DDoS ou falhas, expiração sincronizada pode sobrecarregar roots, como visto no outage do Facebook em 2021 onde DNS cache falhou."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Listar e descrever tipos de registros DNS",
                            "description": "Identificar registros principais: A (IPv4), AAAA (IPv6), CNAME (alias), MX (mail), NS (name server), TXT (texto), e seu papel na zona DNS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos Registros DNS",
                                  "subSteps": [
                                    "Defina o que é um registro DNS e sua localização em uma zona DNS.",
                                    "Explique o papel dos registros na resolução de nomes de domínio.",
                                    "Identifique ferramentas comuns para consultar registros DNS, como dig e nslookup.",
                                    "Diferencie registros de zona (autorativos) de cache.",
                                    "Revise a estrutura básica de uma zona DNS (SOA, registros)."
                                  ],
                                  "verification": "Crie um diagrama simples da zona DNS com locais para registros e liste 3 ferramentas de consulta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação RFC 1035 sobre DNS",
                                    "Terminal com comandos dig ou nslookup",
                                    "Site whois ou dnsdumpster.com para exemplos reais"
                                  ],
                                  "tips": "Sempre comece consultando registros reais de domínios conhecidos como google.com para contextualizar.",
                                  "learningObjective": "Entender o conceito e estrutura de registros DNS em uma zona.",
                                  "commonMistakes": [
                                    "Confundir registros DNS com entradas de hosts locais (/etc/hosts).",
                                    "Ignorar a importância da zona DNS como contêiner autoritativo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Registros de Endereço: A e AAAA",
                                  "subSteps": [
                                    "Descreva o registro A: mapeia nome de domínio para IPv4 (ex: 192.0.2.1).",
                                    "Descreva o registro AAAA: mapeia para IPv6 (ex: 2001:db8::1).",
                                    "Compare diferenças: formato de IP, uso em redes modernas.",
                                    "Consulte exemplos reais usando dig google.com A e dig google.com AAAA.",
                                    "Explique cenários de uso: web servers IPv4 vs IPv6."
                                  ],
                                  "verification": "Execute consultas dig para A e AAAA em 2 domínios e anote os IPs retornados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Comando dig no terminal",
                                    "Documentação IANA: https://www.iana.org/assignments/dns-parameters",
                                    "Exemplos de domínios: google.com, ipv6.google.com"
                                  ],
                                  "tips": "Use +short no dig para saídas limpas: dig +short example.com A.",
                                  "learningObjective": "Dominar registros A e AAAA e suas consultas práticas.",
                                  "commonMistakes": [
                                    "Confundir A com AAAA em ambientes só IPv4.",
                                    "Não testar IPv6 se disponível na rede local."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Registros de Alias e Servidores: CNAME e NS",
                                  "subSteps": [
                                    "Descreva CNAME: alias para outro nome de domínio (não IP direto).",
                                    "Descreva NS: delega subdomínios para name servers específicos.",
                                    "Consulte exemplos: dig www.google.com CNAME e dig google.com NS.",
                                    "Explique regras: CNAME não pode coexistir com outros registros no mesmo nome.",
                                    "Discuta hierarquia: NS para subdomínios como mail.example.com."
                                  ],
                                  "verification": "Liste 3 domínios com CNAME e NS, consultando e descrevendo chain de resolução.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Comando dig ou nslookup",
                                    "Ferramenta online como dnsviz.net para visualização",
                                    "Domínios exemplo: github.com (CNAME), cloudflare.com (NS)"
                                  ],
                                  "tips": "Siga chains CNAME com dig +trace para ver resolução completa.",
                                  "learningObjective": "Compreender CNAME para aliases e NS para autoridade.",
                                  "commonMistakes": [
                                    "Usar CNAME para root domain (não permitido).",
                                    "Confundir NS com glue records em delegações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Registros de Mail e Texto: MX e TXT",
                                  "subSteps": [
                                    "Descreva MX: prioriza servidores de email (ex: 10 mail.example.com).",
                                    "Descreva TXT: armazena texto arbitrário (SPF, DKIM, verificações).",
                                    "Consulte: dig gmail.com MX e dig google.com TXT.",
                                    "Explique prioridades em MX (menor número = maior prioridade).",
                                    "Pratique interpretando TXT para autenticação email."
                                  ],
                                  "verification": "Interprete saídas de MX e TXT de 2 provedores email, notando prioridades e SPF.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Comando dig MX e TXT",
                                    "Documentação SPF: https://dmarc.org",
                                    "Domínios: outlook.com, fastmail.com"
                                  ],
                                  "tips": "Ordene MX por prioridade manualmente para entender failover.",
                                  "learningObjective": "Mestre MX para roteamento email e TXT para metadados.",
                                  "commonMistakes": [
                                    "Ignorar prioridades em MX, causando confusão em roteamento.",
                                    "Não reconhecer TXT além de 'texto genérico' (ex: security records)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Praticar Todos os Registros",
                                  "subSteps": [
                                    "Liste todos os 6 registros com uma frase descritiva cada.",
                                    "Crie uma tabela comparativa: propósito, formato, exemplo.",
                                    "Simule uma zona DNS com todos os tipos para example.com.",
                                    "Resolva cenários: 'Por que email falha?' (MX errado).",
                                    "Teste em playground DNS como dnsmadeeasy demo."
                                  ],
                                  "verification": "Escreva um resumo de 1 página listando e descrevendo todos, com exemplos consultados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de texto para tabela",
                                    "Playground online: https://dns.google/resolve",
                                    "Todos comandos dig anteriores"
                                  ],
                                  "tips": "Use whois domain.com para ver registrar e inferir NS/MX.",
                                  "learningObjective": "Integrar conhecimento de todos registros em cenários reais.",
                                  "commonMistakes": [
                                    "Listar registros incompletos (esquecer AAAA ou TXT).",
                                    "Descrições vagas sem exemplos concretos."
                                  ]
                                }
                              ],
                              "practicalExample": "Configure uma zona DNS fictícia para 'meusite.com': A (198.51.100.1), AAAA (2001:db8::1), CNAME www -> meusite.com, MX 10 mail.meusite.com, NS ns1.host.com, TXT 'v=spf1 include:_spf.google.com'. Use dig para consultar cada um e ver resolução.",
                              "finalVerifications": [
                                "Liste corretamente os 6 registros principais sem omissões.",
                                "Descreva o propósito único de cada um com exemplo de IP/nome.",
                                "Execute dig para todos tipos em um domínio real e interprete saídas.",
                                "Explique diferença A vs AAAA e CNAME vs A.",
                                "Identifique uso de MX prioridades e TXT para SPF.",
                                "Crie diagrama de zona DNS com todos registros."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas descrições: 100% correto para propósitos (4/4 pts).",
                                "Exemplos práticos: Pelo menos 1 consulta dig válida por registro (3/3 pts).",
                                "Compreensão comparativa: Diferencia corretamente tipos semelhantes (3/3 pts).",
                                "Aplicação: Resolve cenários reais como falha MX (4/4 pts).",
                                "Completude: Todos campos de steps preenchidos com detalhes (3/3 pts).",
                                "Clareza: Linguagem acionável, sem jargão não explicado (3/3 pts)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: TXT para SPF/DKIM/DMARC anti-spam.",
                                "Desenvolvimento Web: CNAME para load balancing/CDNs como Cloudflare.",
                                "Administração de Sistemas: NS/MX para gerenciamento de infra cloud (AWS Route53).",
                                "Redes: Integração com IPv6 (AAAA) em IoT e 5G.",
                                "Programação: Uso de bibliotecas como dns.resolve() em Node.js/Python."
                              ],
                              "realWorldApplication": "Em uma empresa, configurar MX garante emails cheguem ao servidor correto com alta disponibilidade via prioridades; TXT previne spoofing email; A/AAAA/CNAME habilitam sites acessíveis globalmente, enquanto NS delega subdomínios para equipes, otimizando resolução DNS para performance e segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Identificar vulnerabilidades básicas do DNS",
                            "description": "Discutir ataques como DNS spoofing, amplification DDoS e a necessidade de DNSSEC para autenticação, relacionando à bibliografia de Tanenbaum e Kurose.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Protocolo DNS",
                                  "subSteps": [
                                    "Leia as seções relevantes sobre DNS nos livros de Tanenbaum (Capítulo 5) e Kurose (Capítulo 9), focando na resolução de nomes e hierarquia de servidores.",
                                    "Explique o processo de resolução DNS iterativa e recursiva, identificando os tipos de registros (A, NS, CNAME).",
                                    "Desenhe um diagrama ilustrando o fluxo de uma query DNS de um cliente a um root server, incluindo caching.",
                                    "Identifique por que o DNS usa UDP por padrão e as implicações para segurança.",
                                    "Anote a ausência de autenticação nativa no protocolo DNS."
                                  ],
                                  "verification": "Crie e explique um diagrama hand-drawn ou digital do fluxo de resolução DNS, destacando pontos de vulnerabilidade potenciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Computer Networks' de Tanenbaum",
                                    "Livro 'Computer Networking' de Kurose",
                                    "Papel e caneta ou ferramenta como draw.io"
                                  ],
                                  "tips": [
                                    "Compare resoluções iterativa e recursiva para melhor compreensão.",
                                    "Use comandos como 'dig example.com' para visualizar respostas reais."
                                  ],
                                  "learningObjective": "Dominar o funcionamento básico do DNS e reconhecer sua falta de mecanismos de autenticação inerentes.",
                                  "commonMistakes": [
                                    "Confundir DNS com DHCP ou roteamento IP.",
                                    "Ignorar o papel do caching na amplificação de ataques.",
                                    "Assumir que DNS é sempre criptografado."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Ataque de DNS Spoofing (Cache Poisoning)",
                                  "subSteps": [
                                    "Estude a descrição de DNS spoofing em Tanenbaum (seção sobre segurança em redes) e Kurose, focando em Kaminsky attack.",
                                    "Explique como um atacante prevê IDs de transação e injeta respostas falsas para envenenar o cache de um resolver.",
                                    "Simule conceitualmente o ataque listando os passos: envio de queries maliciosas, falsificação de fonte IP, matching de IDs.",
                                    "Discuta mitigações básicas como randomização de ports e source port randomization.",
                                    "Relacione com exemplos reais como o ataque ao Debian OpenSSL em 2008."
                                  ],
                                  "verification": "Descreva em 200 palavras como um atacante realiza DNS spoofing e proponha 3 defesas preventivas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Livros de Tanenbaum e Kurose",
                                    "Artigo sobre Kaminsky DNS vulnerability (online)",
                                    "Ferramenta de simulação como Scapy (opcional)"
                                  ],
                                  "tips": [
                                    "Lembre-se: UDP é connectionless, facilitando spoofing de IP.",
                                    "Pratique com 'dig +short' para ver IDs de query."
                                  ],
                                  "learningObjective": "Identificar mecanismos e impactos do DNS spoofing, relacionando à literatura de referência.",
                                  "commonMistakes": [
                                    "Subestimar a importância da randomização de ports.",
                                    "Confundir spoofing com poisoning de ARP.",
                                    "Ignorar evoluções como DNS over HTTPS (DoH)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar o Ataque de Amplification DDoS via DNS",
                                  "subSteps": [
                                    "Revise em Kurose (Capítulo 8 sobre segurança) como queries DNS ANY ou EDNS(0) geram respostas grandes.",
                                    "Calcule ratios de amplificação: explique como uma query de 60 bytes gera respostas de 4000+ bytes.",
                                    "Descreva o fluxo: botnet envia queries spoofadas com IP da vítima como source, servidores DNS refletem tráfego amplificado.",
                                    "Analise exemplos reais como o ataque ao Spamhaus em 2013 (300 Gbps).",
                                    "Discuta rate limiting e BCP 38 como mitigações."
                                  ],
                                  "verification": "Calcule manualmente um ratio de amplificação para uma query DNS EDNS e descreva o impacto em uma vítima.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Livros de Tanenbaum e Kurose",
                                    "Relatórios de DDoS da Cloudflare ou Akamai (online)",
                                    "Calculadora para simular tamanhos de pacotes"
                                  ],
                                  "tips": [
                                    "Foque em payloads grandes como TXT records para máxima amplificação.",
                                    "Use Wireshark para capturar queries reais e medir tamanhos."
                                  ],
                                  "learningObjective": "Compreender como o DNS é explorado em DDoS de reflexão/amplificação.",
                                  "commonMistakes": [
                                    "Confundir amplification com volumentric floods simples.",
                                    "Ignorar filtros de ingress (BCP 38).",
                                    "Subestimar o papel de anycast DNS."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar DNSSEC como Mitigação e Autenticação",
                                  "subSteps": [
                                    "Estude DNSSEC em Tanenbaum e Kurose, cobrindo RRSIG, DNSKEY e DS records para chain of trust.",
                                    "Explique o processo de validação: assinatura digital de respostas para prevenir spoofing.",
                                    "Compare DNSSEC com DNS tradicional, notando overhead e adoção limitada.",
                                    "Simule validação com 'dig +dnssec example.com' em domínios assinados.",
                                    "Discuta limitações como falta de confidencialidade e ataques de zona enumeration."
                                  ],
                                  "verification": "Valide uma zona DNSSEC usando dig e explique a chain of trust em um diagrama.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Livros de referência",
                                    "Comando 'dig' instalado",
                                    "Site dnssec-tools.org ou icann.org/dnssec"
                                  ],
                                  "tips": [
                                    "Verifique flags como DO (DNSSEC OK) em queries.",
                                    "Teste domíios como nic.se para prática."
                                  ],
                                  "learningObjective": "Avaliar DNSSEC como solução para vulnerabilidades básicas do DNS.",
                                  "commonMistakes": [
                                    "Confundir DNSSEC com DoT/DoH (que adicionam privacidade).",
                                    "Ignorar key rollover e zone signing.",
                                    "Assumir 100% adoção global."
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um ambiente local com dnsmasq como servidor DNS vulnerável. Use Scapy para enviar uma query spoofada com ID previsível, injetando um registro falso (ex: redirecione google.com para um IP malicioso). Observe o cache poisoning via 'nslookup' repetido, então habilite source port randomization e repita para verificar mitigação.",
                              "finalVerifications": [
                                "Explique com precisão o fluxo de um ataque DNS spoofing, citando Tanenbaum/Kurose.",
                                "Calcule e justifique um ratio de amplificação DDoS realista (>50x).",
                                "Valide uma zona DNSSEC real usando dig +dnssec e interprete os resultados.",
                                "Identifique 3 limitações do DNSSEC em contextos práticos.",
                                "Relacione vulnerabilidades DNS a ataques históricos como Spamhaus DDoS.",
                                "Desenhe um diagrama completo de resolução DNS destacando pontos de ataque."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de spoofing, amplification e DNSSEC (80%+ acurácia).",
                                "Uso correto de referências bibliográficas (Tanenbaum e Kurose).",
                                "Capacidade de simular ou calcular exemplos quantitativos (ex: ratios de amplificação).",
                                "Identificação clara de mitigações e limitações.",
                                "Clareza em diagramas e explicações acionáveis.",
                                "Compreensão interdisciplinar (ex: impacto em criptografia e redes)."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: DNSSEC usa assinaturas digitais RSA/DN S (conexão com SC-20 Criptografia).",
                                "Segurança da Informação: Relaciona a ataques de rede e defesas (SC-35 Segurança em Redes).",
                                "Redes de Computadores: Protocolos UDP/TCP e roteamento (SC-35 Nível de Transporte).",
                                "Ética em Computação: Implicações de ataques DDoS em infraestrutura crítica."
                              ],
                              "realWorldApplication": "Em uma empresa gerenciando domínios críticos (ex: banco online), identifique spoofing via monitoramento de logs DNS e implemente DNSSEC para autenticar respostas, prevenindo redirecionamentos maliciosos que poderiam expor dados de clientes a phishing; configure rate limiting para mitigar amplification DDoS, garantindo disponibilidade de serviços web."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Protocolos de Serviços no Nível de Aplicação",
                    "description": "Protocolos que oferecem serviços diretamente ao usuário, como transferência de arquivos e e-mail.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Protocolo FTP (File Transfer Protocol)",
                        "description": "Protocolo de aplicação que fornece serviços de transferência de arquivos entre clientes e servidores na rede, operando sobre TCP para garantir confiabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Descrever o funcionamento básico do FTP",
                            "description": "Explicar a arquitetura cliente-servidor do FTP, incluindo comandos de controle (porta 21) e transferência de dados (porta 20 ou dinâmica), e os modos de operação ativa e passiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Arquitetura Cliente-Servidor do FTP",
                                  "subSteps": [
                                    "Pesquisar a definição de FTP e seu modelo cliente-servidor.",
                                    "Identificar o cliente como iniciador de conexões e o servidor como respondedor.",
                                    "Desenhar um diagrama básico mostrando cliente e servidor com canais de controle e dados.",
                                    "Explicar a necessidade de canais separados para comandos e dados.",
                                    "Comparar brevemente com protocolos como HTTP."
                                  ],
                                  "verification": "Criar e rotular um diagrama da arquitetura FTP, explicando verbalmente para si mesmo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou draw.io",
                                    "Documentação RFC 959 do FTP"
                                  ],
                                  "tips": "Use setas no diagrama para mostrar direção das conexões iniciais.",
                                  "learningObjective": "Compreender os papéis e estrutura fundamental da arquitetura FTP cliente-servidor.",
                                  "commonMistakes": [
                                    "Confundir cliente com servidor",
                                    "Omitir a separação de canais de controle e dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Canal de Controle na Porta 21",
                                  "subSteps": [
                                    "Listar comandos principais: USER, PASS, LIST, RETR, STOR, QUIT.",
                                    "Entender que o canal de controle usa TCP na porta 21 para comandos em texto ASCII.",
                                    "Simular uma sessão de autenticação com comandos sequenciais.",
                                    "Identificar que este canal permanece aberto durante a sessão.",
                                    "Testar comandos básicos em um cliente FTP como linha de comando (ftp.exe)."
                                  ],
                                  "verification": "Executar uma sessão de login simulada e listar os comandos usados em ordem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Cliente FTP de linha de comando (ftp no Windows/Linux)",
                                    "Servidor FTP teste como FileZilla Server"
                                  ],
                                  "tips": "Comandos são case-insensitive, mas use maiúsculas por convenção.",
                                  "learningObjective": "Dominar o funcionamento e comandos do canal de controle TCP porta 21.",
                                  "commonMistakes": [
                                    "Usar porta errada para controle",
                                    "Esquecer autenticação antes de comandos de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender o Modo Ativo e a Porta 20 para Dados",
                                  "subSteps": [
                                    "Descrever o modo ativo: cliente informa porta (>1023), servidor conecta da porta 20.",
                                    "Diagramar o fluxo: comando PORT do cliente, servidor inicia conexão de dados.",
                                    "Explicar problemas com firewalls (servidor atrás de NAT).",
                                    "Simular com ferramenta que mostre portas usadas.",
                                    "Comparar velocidade e confiabilidade com outros modos."
                                  ],
                                  "verification": "Desenhar diagrama do handshake de dados no modo ativo e identificar portas envolvidas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark para capturar tráfego",
                                    "Cliente FTP com logs (ex: lftp)"
                                  ],
                                  "tips": "No modo ativo, servidor é o cliente na conexão de dados – isso é contraintuitivo.",
                                  "learningObjective": "Explicar precisamente o mecanismo de negociação e transferência no modo ativo.",
                                  "commonMistakes": [
                                    "Inverter papéis na conexão de dados",
                                    "Confundir PORT com PASV"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Modo Passivo para Transferência de Dados",
                                  "subSteps": [
                                    "Descrever modo passivo: cliente usa PASV, servidor abre porta dinâmica (>1023).",
                                    "Diagramar fluxo: servidor informa IP/porta, cliente conecta para dados.",
                                    "Explicar vantagens para clientes atrás de firewalls.",
                                    "Testar alternância entre modos ativo e passivo em um cliente.",
                                    "Discutir EPSV para IPv6."
                                  ],
                                  "verification": "Criar diagramas comparativos ativo vs. passivo e testar em prática.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "FileZilla Client",
                                    "Servidor FTP público de teste (ex: ftp.dlptest.com)"
                                  ],
                                  "tips": "Modo passivo é padrão hoje devido a NAT/firewalls comuns.",
                                  "learningObjective": "Diferenciar e aplicar modos passivo e ativo na transferência de dados.",
                                  "commonMistakes": [
                                    "Confundir quem abre a porta no passivo",
                                    "Ignorar portas dinâmicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando FileZilla, conecte a um servidor FTP público (ftp.dlptest.com), alterne entre modos ativo e passivo nas configurações, transfira um arquivo pequeno e analise o log para identificar portas 21 (controle), 20 (ativo dados) ou dinâmica (passivo).",
                              "finalVerifications": [
                                "Diagramar arquitetura FTP com canais e portas corretas.",
                                "Listar e ordenar 5 comandos de controle comuns.",
                                "Explicar diferenças entre modos ativo e passivo com fluxogramas.",
                                "Simular uma sessão FTP completa verbalmente.",
                                "Identificar problemas de firewall em cada modo.",
                                "Comparar FTP com SFTP em termos de portas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de portas (21 controle, 20/dinâmica dados).",
                                "Correta descrição dos fluxos cliente-servidor em ambos modos.",
                                "Uso correto de terminologia (PORT, PASV, RETR, etc.).",
                                "Capacidade de diagramar conexões TCP sem erros.",
                                "Explicação clara de motivos para modos passivo/ativo.",
                                "Demonstração prática via ferramenta ou simulação."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Evolução para FTPS/SFTP com criptografia.",
                                "Programação: Implementar cliente FTP usando sockets em Python (biblioteca ftplib).",
                                "Redes Fundamentais: Aplicação do modelo TCP/IP e handshakes de conexão.",
                                "Administração de Sistemas: Configuração de servidores FTP em Linux (vsftpd)."
                              ],
                              "realWorldApplication": "FTP é usado para upload de sites em hospedagens web, sincronização de backups em data centers, compartilhamento de grandes arquivos em empresas e distribuição de software/open-source, embora substituído por SFTP em cenários seguros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Identificar comandos e respostas FTP",
                            "description": "Listar e descrever comandos comuns como USER, PASS, RETR, STOR, LIST, e códigos de resposta como 200, 331, 550, com exemplos de sessões de FTP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Aprender Comandos de Autenticação e Conexão FTP (USER e PASS)",
                                  "subSteps": [
                                    "Ler a seção de autenticação no RFC 959 para entender USER e PASS",
                                    "Identificar que USER envia o nome de usuário após conexão no porto 21",
                                    "Explicar que PASS segue USER para autenticação da senha em texto plano",
                                    "Anotar exemplos: USER anonymous e PASS guest@",
                                    "Comparar com telnet para simular conexão inicial"
                                  ],
                                  "verification": "Escrever uma sequência correta de comandos USER/PASS e explicar seu fluxo sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 959 (disponível online)",
                                    "Cliente telnet ou nc (netcat)",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Sempre use USER antes de PASS; teste em ambiente simulado para evitar bloqueios reais.",
                                  "learningObjective": "Compreender o processo de autenticação inicial no protocolo FTP.",
                                  "commonMistakes": [
                                    "Enviar PASS sem USER prévio",
                                    "Confundir FTP com protocolos criptografados como SFTP",
                                    "Ignorar que credenciais são enviadas em claro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Comandos de Transferência e Listagem (RETR, STOR, LIST)",
                                  "subSteps": [
                                    "Definir RETR como comando para download (retrieve) de arquivo remoto",
                                    "Descrever STOR para upload (store) de arquivo local para remoto",
                                    "Explicar LIST para listar conteúdos de diretório remoto",
                                    "Simular comandos em sequência: LIST após autenticação, então RETR arquivo.txt",
                                    "Notar que modo ativo/passivo afeta transferência, mas focar em comandos básicos"
                                  ],
                                  "verification": "Listar e descrever corretamente RETR, STOR e LIST com um exemplo de uso cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação FTP MDN ou Wireshark para captura",
                                    "Cliente FTP como FileZilla em modo log",
                                    "Papel para diagramas"
                                  ],
                                  "tips": "Use LIST para verificar arquivos antes de RETR/STOR; especifique caminhos completos para evitar erros.",
                                  "learningObjective": "Dominar comandos essenciais para manipulação de arquivos via FTP.",
                                  "commonMistakes": [
                                    "Confundir RETR (download) com STOR (upload)",
                                    "Esquecer que LIST requer conexão de dados separada",
                                    "Ignorar permissões de diretório antes de STOR"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Memorizar e Interpretar Códigos de Resposta FTP (200, 331, 550)",
                                  "subSteps": [
                                    "Classificar códigos: 200 (sucesso), 331 (usuário ok, senha necessária), 550 (permissão negada)",
                                    "Associar 200 a comandos bem-sucedidos como LIST concluído",
                                    "Explicar 331 após USER, esperando PASS",
                                    "Entender 550 para arquivo não encontrado ou sem permissão",
                                    "Criar tabela de referência com mensagens típicas"
                                  ],
                                  "verification": "Dado um código, explicar seu significado e contexto de uso em 100% dos casos testados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de códigos FTP (RFC 959 Appendix)",
                                    "Flashcards online (Anki)",
                                    "Simulador FTP online"
                                  ],
                                  "tips": "Primeiro dígito indica categoria: 2xx sucesso, 3xx continue, 5xx erro; memorize padrões.",
                                  "learningObjective": "Identificar e interpretar respostas do servidor FTP para depuração.",
                                  "commonMistakes": [
                                    "Confundir 331 (precisa senha) com 200 (completo)",
                                    "Ignorar subtipo do código (ex: 550 vs 553)",
                                    "Não diferenciar erros de cliente vs servidor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Sessões FTP Completas e Praticar Identificação",
                                  "subSteps": [
                                    "Ler uma sessão de log exemplo: conexão, USER/PASS, LIST, RETR",
                                    "Identificar comandos e respostas correspondentes passo a passo",
                                    "Simular depuração: dado erro 550 em RETR, sugerir soluções",
                                    "Criar própria sessão simulada com 5 comandos e respostas",
                                    "Testar com ferramenta real ou Wireshark para validar"
                                  ],
                                  "verification": "Analisar uma sessão FTP fornecida e listar todos comandos/respostas corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Logs de sessão FTP exemplo (online)",
                                    "Wireshark ou tcpdump",
                                    "Cliente FTP com logging ativado"
                                  ],
                                  "tips": "Sempre leia respostas após cada comando; use modo passivo para firewalls comuns.",
                                  "learningObjective": "Aplicar conhecimento para interpretar e troubleshoot sessões FTP reais.",
                                  "commonMistakes": [
                                    "Pular verificação de código após comando",
                                    "Não notar canais de controle/dados separados",
                                    "Assumir sucesso sem código 2xx"
                                  ]
                                }
                              ],
                              "practicalExample": "Sessão FTP simulada: \n220 Servidor pronto.\nUSER anonymous\n331 Senha necessária.\nPASS guest@\n230 Logado.\nLIST\n200 Abrindo canal de dados.\n150 Lista ok.\n226 Transferido.\nRETR file.txt\n150 Abrindo canal.\n226 Transferido.\nQUIT\n221 Bye.",
                              "finalVerifications": [
                                "Listar e descrever USER, PASS, RETR, STOR, LIST corretamente",
                                "Explicar códigos 200, 331, 550 com exemplos",
                                "Analisar uma sessão FTP completa sem erros",
                                "Simular depuração de erro comum como 550",
                                "Criar tabela de 10 comandos/respostas FTP",
                                "Identificar vulnerabilidades em sessão insegura"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de comandos (90-100%)",
                                "Correta interpretação de pelo menos 5 códigos de resposta",
                                "Análise completa de sessão com todos elementos identificados",
                                "Uso correto de terminologia FTP (RFC-compliant)",
                                "Demonstração prática via simulação ou log real",
                                "Identificação de erros comuns e soluções"
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Vulnerabilidades de FTP plano vs SFTP/FTPS",
                                "Programação: Implementar cliente FTP em Python com ftplib",
                                "Redes: Comparação de protocolos TCP no nível aplicação (FTP vs HTTP)",
                                "História da Computação: Evolução de FTP desde ARPANET",
                                "Ética Digital: Implicações de credenciais em texto plano"
                              ],
                              "realWorldApplication": "Gerenciar uploads/downloads em servidores web hospedados, automatizar backups remotos em data centers, transferir arquivos em ambientes legados de empresas, ou depurar conexões FTP em suporte técnico de TI."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Comparar modos ativo e passivo do FTP",
                            "description": "Analisar as diferenças entre modo ativo (servidor inicia conexão de dados) e passivo (cliente inicia), incluindo vantagens em cenários com firewalls e NAT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Modo Ativo do FTP",
                                  "subSteps": [
                                    "Ler a seção relevante da RFC 959 sobre modo ativo.",
                                    "Identificar as portas padrão: 21 para controle (cliente para servidor) e 20 para dados (servidor para cliente).",
                                    "Desenhar o fluxo: cliente envia comando PORT com sua porta de dados, servidor conecta de volta.",
                                    "Simular mentalmente o handshake TCP para ambas as conexões.",
                                    "Testar com um cliente FTP local configurado em modo ativo."
                                  ],
                                  "verification": "Desenhar e rotular corretamente um diagrama do fluxo de conexões no modo ativo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 959 (disponível online)",
                                    "Ferramenta de diagrama (Draw.io ou papel e caneta)",
                                    "Cliente FTP como FileZilla"
                                  ],
                                  "tips": [
                                    "Visualize o servidor 'ligando de volta' para o cliente.",
                                    "Use comandos como PORT para entender o anúncio de porta.",
                                    "Registre o IP e porta enviados no comando PORT."
                                  ],
                                  "learningObjective": "Explicar precisamente o mecanismo de conexão de dados no modo ativo do FTP.",
                                  "commonMistakes": [
                                    "Confundir direção da conexão de dados (pensar que cliente inicia)",
                                    "Esquecer que servidor usa porta 20 fixa",
                                    "Ignorar o comando PORT do cliente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Modo Passivo do FTP",
                                  "subSteps": [
                                    "Ler a extensão PASV na RFC 959 e RFC 2228.",
                                    "Identificar portas: 21 controle, servidor abre porta dinâmica (>1023) para dados.",
                                    "Desenhar o fluxo: cliente envia PASV, servidor responde com IP:porta, cliente conecta.",
                                    "Comparar handshake TCP: cliente inicia ambas as conexões.",
                                    "Testar com cliente FTP em modo passivo."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama do fluxo de conexões no modo passivo, destacando o comando PASV.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 959 e RFC 2228",
                                    "Ferramenta de diagrama",
                                    "Servidor FTP local como vsftpd"
                                  ],
                                  "tips": [
                                    "Cliente sempre inicia conexões no passivo.",
                                    "Porta do servidor é dinâmica, anunciada na resposta PASV.",
                                    "Use EPSV para IPv6."
                                  ],
                                  "learningObjective": "Descrever o mecanismo de conexão de dados no modo passivo do FTP.",
                                  "commonMistakes": [
                                    "Pensar que servidor inicia data connection",
                                    "Confundir PASV com PORT",
                                    "Esquecer portas dinâmicas do servidor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças entre Modos Ativo e Passivo",
                                  "subSteps": [
                                    "Listar diferenças chave: direção de data connection, comandos (PORT vs PASV), portas usadas.",
                                    "Criar uma tabela comparativa: quem inicia, portas fixas/dinâmicas, fluxos de comando.",
                                    "Analisar overhead de rede e complexidade de implementação.",
                                    "Discutir compatibilidade com IPv4/IPv6 (EPSV/EPRT).",
                                    "Executar capturas de pacotes com Wireshark para ambos os modos."
                                  ],
                                  "verification": "Produzir uma tabela comparativa precisa com pelo menos 5 diferenças principais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark para captura de pacotes",
                                    "Planilha ou documento para tabela",
                                    "Cliente e servidor FTP"
                                  ],
                                  "tips": [
                                    "Foque em direção da conexão como diferença central.",
                                    "Capture tráfego real para validação visual.",
                                    "Inclua exemplos de respostas PASV (formato 227)."
                                  ],
                                  "learningObjective": "Identificar e articular diferenças técnicas entre modos ativo e passivo.",
                                  "commonMistakes": [
                                    "Ignorar diferenças em comandos de controle",
                                    "Confundir responsabilidades de cliente/servidor",
                                    "Subestimar impacto de portas dinâmicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens em Cenários com Firewalls e NAT",
                                  "subSteps": [
                                    "Explicar problemas do modo ativo com firewalls/NAT no cliente (servidor não alcança porta alta).",
                                    "Mostrar como passivo resolve: cliente inicia todas as conexões (permitido por NAT/firewall).",
                                    "Discutir cenários: cliente residencial (NAT), servidor corporativo (firewall rígido).",
                                    "Listar desvantagens: servidor precisa abrir portas dinâmicas (risco de segurança).",
                                    "Recomendar modo passivo como padrão moderno e testar em ambiente NAT."
                                  ],
                                  "verification": "Escrever um parágrafo explicando por que passivo é preferido em NAT/firewalls, com exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de firewalls comuns (iptables, pfSense)",
                                    "Ambiente de teste com NAT (roteador doméstico)",
                                    "Artigo sobre FTP e NAT"
                                  ],
                                  "tips": [
                                    "Lembre: NAT traduz portas outbound, mas não inbound.",
                                    "Teste falha no ativo atrás de NAT.",
                                    "Considere FTPS/SFTP como alternativas seguras."
                                  ],
                                  "learningObjective": "Avaliar impactos práticos dos modos em redes reais com restrições.",
                                  "commonMistakes": [
                                    "Pensar que ativo funciona bem com NAT cliente",
                                    "Ignorar riscos de portas dinâmicas no servidor",
                                    "Não considerar configurações de firewall stateful"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um servidor FTP (vsftpd) em uma VM e use FileZilla de um laptop atrás de NAT doméstico. Tente transferir um arquivo primeiro em modo ativo (falhará devido a NAT/firewall), depois mude para passivo (sucesso). Capture com Wireshark para visualizar comandos PORT/PASV e conexões.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito as diferenças em direção de conexões e comandos.",
                                "Desenhar diagramas precisos para ambos os modos.",
                                "Identificar corretamente cenários onde passivo é superior (ex: cliente NAT).",
                                "Listar pelo menos 3 vantagens/desvantagens de cada modo.",
                                "Demonstrar configuração e teste bem-sucedido em modo passivo com Wireshark.",
                                "Comparar com protocolos modernos como SFTP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de portas, comandos e fluxos (90% correto).",
                                "Compreensão clara de impactos de firewalls/NAT.",
                                "Tabela/diagrama comparativo completo e visualmente claro.",
                                "Exemplos práticos relevantes e testados.",
                                "Identificação correta de erros comuns e soluções.",
                                "Explicação de quando usar cada modo em contextos reais."
                              ],
                              "crossCurricularConnections": [
                                "Segurança de Redes: Configuração de firewalls para FTP (stateful inspection).",
                                "Protocolos de Transporte: Comportamento TCP em conexões ativas/passivas.",
                                "Arquitetura de Redes: Conceitos de NAT, PAT e traversais.",
                                "Programação de Redes: Implementação de sockets cliente/servidor semelhantes.",
                                "Sistemas Operacionais: Configuração de serviços FTP em Linux/Windows."
                              ],
                              "realWorldApplication": "Em ambientes corporativos ou residenciais, o modo passivo permite uploads/downloads FTP de clientes atrás de NAT/firewalls sem reconfigurações complexas, comum em hospedagem web, backups remotos e compartilhamento de arquivos em redes restritas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Protocolo SMTP (Simple Mail Transfer Protocol)",
                        "description": "Protocolo de aplicação responsável pelo envio de e-mails entre servidores de correio, utilizando TCP na porta 25 (ou 587 para submissão segura).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Explicar o processo de envio de e-mail via SMTP",
                            "description": "Descrever o fluxo de uma sessão SMTP: conexão, identificação HELO/EHLO, MAIL FROM, RCPT TO, DATA, QUIT, e tratamento de erros como relay denied.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer Conexão TCP e Saudação Inicial (HELO/EHLO)",
                                  "subSteps": [
                                    "Conecte ao servidor SMTP na porta 25 usando TCP (ex: telnet smtp.example.com 25).",
                                    "Envie o comando HELO ou EHLO seguido do nome do domínio do cliente (ex: EHLO meucliente.com).",
                                    "Analise a resposta do servidor: código 250 indica sucesso, com lista de extensões se EHLO.",
                                    "Identifique diferenças: HELO é básico, EHLO suporta ESMTP com AUTH, STARTTLS, etc.",
                                    "Registre o banner inicial do servidor (ex: 220 smtp.example.com ESMTP)."
                                  ],
                                  "verification": "Simule a conexão com telnet e confirme resposta 250 OK após EHLO.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Telnet ou netcat, documentação RFC 5321, Wireshark para captura de pacotes",
                                  "tips": "Use EHLO preferencialmente para servidores modernos; capture tráfego com Wireshark para visualização.",
                                  "learningObjective": "Compreender a inicialização da sessão SMTP e negociação de capacidades.",
                                  "commonMistakes": "Confundir portas (use 25 para SMTP, 587 para submission); ignorar respostas de erro como 421 (serviço indisponível)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar Remetente com MAIL FROM",
                                  "subSteps": [
                                    "Envie MAIL FROM:<email@dominio.com> após saudação bem-sucedida.",
                                    "Inclua endereço reverso path se necessário (ex: MAIL FROM:<<>user@dominio.com>).",
                                    "Verifique resposta: 250 OK indica aceitação do remetente.",
                                    "Entenda que o servidor valida o domínio do remetente contra SPF/DKIM em cenários reais.",
                                    "Note que múltiplos MAIL FROM reiniciam a transação."
                                  ],
                                  "verification": "Execute comando MAIL FROM em sessão telnet e confirme código 250 2.1.0 OK.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Cliente telnet/netcat, RFC 5321 seção 3.6",
                                  "tips": "Teste com endereço inválido para ver erros como 550 relay not permitted.",
                                  "learningObjective": "Dominar o comando que inicia a envelope do email com remetente.",
                                  "commonMistakes": "Esquecer os < > ao redor do endereço; enviar antes de EHLO."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar Destinatário(s) com RCPT TO",
                                  "subSteps": [
                                    "Envie RCPT TO:<destinatario@dominio.com> para cada destinatário.",
                                    "Repita para múltiplos destinatários (até limite do servidor).",
                                    "Confirme 250 OK para cada; 550 indica rejeição (ex: caixa cheia).",
                                    "Compreenda relay denied: servidor recusa se não autorizado para domínio.",
                                    "Use RCPT TO:<<>> para BCC simulação."
                                  ],
                                  "verification": "Adicione RCPT TO em sessão ativa e liste respostas de aceitação/rejeição.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Telnet, lista de servidores SMTP de teste (ex: mxtoolbox.com)",
                                  "tips": "Teste relay denied conectando a servidores públicos sem autenticação.",
                                  "learningObjective": "Aprender a definir destinatários e lidar com rejeições precoces.",
                                  "commonMistakes": "Enviar RCPT antes de MAIL FROM; ignorar códigos 5xx como relay denied."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enviar Conteúdo da Mensagem com DATA",
                                  "subSteps": [
                                    "Após RCPT(s) aceitos, envie DATA para iniciar corpo da mensagem.",
                                    "Escreva headers (From, To, Subject) e corpo, terminando com . (ponto sozinho na linha).",
                                    "Confirme 250 OK após envio completo.",
                                    "Inclua linhas vazias corretamente; escape . no início de linha com ..",
                                    "Valide formato MIME para anexos complexos."
                                  ],
                                  "verification": "Envie mensagem completa via telnet e receba 250 2.0.0 OK: queued as XYZ.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto para mensagem modelo, RFC 5322 para formato de email",
                                  "tips": "Copie uma mensagem real e teste; use Wireshark para inspecionar payload.",
                                  "learningObjective": "Construir e transmitir o conteúdo da mensagem SMTP.",
                                  "commonMistakes": "Não terminar com . sozinho; exceder limites de tamanho (ex: 552 too big)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Finalizar Sessão com QUIT e Tratar Erros",
                                  "subSteps": [
                                    "Envie QUIT para encerrar graciosamente (resposta 221 Bye).",
                                    "Identifique erros comuns: 450/550 relay denied, 421 service unavailable.",
                                    "Implemente retry logic para erros transitórios (4xx).",
                                    "Registre logs de toda sessão para depuração.",
                                    "Feche conexão TCP após QUIT."
                                  ],
                                  "verification": "Complete ciclo com QUIT e analise logs para erros simulados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Scripts Python com smtplib para automação, logs de Wireshark",
                                  "tips": "Simule erros desconectando abruptamente vs. QUIT limpo.",
                                  "learningObjective": "Gerenciar fechamento de sessão e resiliência a falhas.",
                                  "commonMistakes": "Não tratar 5xx permanent errors; deixar sessões abertas."
                                }
                              ],
                              "practicalExample": "Usando telnet: telnet smtp.gmail.com 25 (use servidor de teste real como mail-tester.com). EHLO test.com -> MAIL FROM:<test@test.com> -> RCPT TO:<seuemail@example.com> -> DATA -> Subject: Test\n\nBody. -> . -> QUIT. Observe relay denied se não autenticado.",
                              "finalVerifications": [
                                "Descreva o fluxo completo: conexão -> EHLO -> MAIL -> RCPT -> DATA -> QUIT.",
                                "Explique diferenças HELO vs EHLO com exemplos de respostas.",
                                "Simule relay denied e proponha soluções (autenticação, relay autorizado).",
                                "Capture uma sessão Wireshark e identifique cada comando/resposta.",
                                "Diferencie envelope (MAIL/RCPT) de headers (From/To no DATA).",
                                "Liste 3 erros comuns e suas respostas SMTP (ex: 550 5.1.1 User unknown)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de comandos SMTP (ordem exata).",
                                "Compreensão de códigos de resposta (2xx/4xx/5xx).",
                                "Capacidade de simular sessão completa sem erros.",
                                "Explicação clara de relay denied e tratamento.",
                                "Uso correto de ferramentas como telnet/Wireshark.",
                                "Identificação de extensões ESMTP em respostas EHLO."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Integração com STARTTLS, SPF/DKIM para prevenir spoofing.",
                                "Programação: Implementação de cliente SMTP em Python (smtplib) ou Node.js.",
                                "Redes: Análise de pacotes TCP no Wireshark, compreensão de portas e handshakes.",
                                "Sistemas Operacionais: Configuração de postfix/sendmail como relay.",
                                "Ética Digital: Discussão sobre spam e conformidade com CAN-SPAM."
                              ],
                              "realWorldApplication": "Entender SMTP permite depurar falhas de email (ex: bounces por relay denied), desenvolver ferramentas anti-spam, configurar servidores de email corporativos, ou criar automações de envio em apps como newsletters e alertas de sistemas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Identificar extensões ESMTP",
                            "description": "Discutir comandos estendidos como AUTH para autenticação, STARTTLS para criptografia, e SIZE para limitação de mensagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do ESMTP",
                                  "subSteps": [
                                    "Ler a definição de ESMTP como extensão do SMTP via EHLO em vez de HELO (RFC 5321).",
                                    "Identificar que ESMTP anuncia capacidades via resposta ao comando EHLO.",
                                    "Revisar exemplos de respostas EHLO que listam extensões como AUTH, STARTTLS e SIZE.",
                                    "Diferenciar SMTP básico de ESMTP estendido."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre HELO e EHLO e liste pelo menos 3 extensões comuns.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 5321 (SMTP)",
                                    "Ferramenta de terminal como telnet ou nc (netcat)",
                                    "Documentação online de ESMTP"
                                  ],
                                  "tips": "Sempre use EHLO em testes para ver todas as extensões suportadas pelo servidor.",
                                  "learningObjective": "Entender como ESMTP expande o protocolo SMTP básico através de negociações de capacidades.",
                                  "commonMistakes": "Confundir ESMTP com SMTP; assumir que todos os servidores usam HELO."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Comando AUTH para Autenticação",
                                  "subSteps": [
                                    "Estudar RFC 4954 para detalhes do AUTH: mecanismos como PLAIN, LOGIN, CRAM-MD5.",
                                    "Simular fluxo: cliente envia AUTH <mecanismo>, servidor responde com challenge se necessário.",
                                    "Testar AUTH em um servidor de teste usando telnet (ex: AUTH LOGIN).",
                                    "Discutir benefícios: previne relay aberto e autentica remetentes."
                                  ],
                                  "verification": "Execute um comando AUTH bem-sucedido em uma sessão telnet e capture a resposta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 4954 (SMTP AUTH)",
                                    "Servidor SMTP de teste (ex: maildev ou localhost com Postfix)",
                                    "Telnet ou OpenSSL s_client"
                                  ],
                                  "tips": "Use credenciais de teste; nunca exponha senhas em claro em produção.",
                                  "learningObjective": "Dominar o uso do AUTH para autenticação segura em transferências de email.",
                                  "commonMistakes": "Esquecer de codificar base64 para credenciais; ignorar mecanismos seguros como CRAM-MD5."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar STARTTLS para Criptografia",
                                  "subSteps": [
                                    "Revisar RFC 3207: STARTTLS inicia TLS/SSL após negociação SMTP.",
                                    "Entender o fluxo: EHLO → STARTTLS → 220 response → upgrade para TLS → EHLO novamente.",
                                    "Testar em servidor real (ex: gmail-smtp-in.l.google.com:587).",
                                    "Explicar como protege contra eavesdropping em trânsito."
                                  ],
                                  "verification": "Capture uma sessão com STARTTLS usando Wireshark ou logs, confirmando handshake TLS.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "RFC 3207 (SMTP STARTTLS)",
                                    "Wireshark para captura de pacotes",
                                    "openssl s_client -connect smtp.gmail.com:587"
                                  ],
                                  "tips": "Verifique o certificado TLS após upgrade; use port 587 para submission.",
                                  "learningObjective": "Identificar e implementar STARTTLS para encriptar sessões SMTP.",
                                  "commonMistakes": "Tentar STARTTLS antes de EHLO; não reconectar EHLO após TLS."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar SIZE e Sintetizar Identificação de Extensões",
                                  "subSteps": [
                                    "Analisar RFC 3030: SIZE anuncia limite máximo de mensagem (ex: SIZE 52428800).",
                                    "Simular: Cliente verifica SIZE na resposta EHLO e ajusta MAIL FROM SIZE=...",
                                    "Comparar AUTH, STARTTLS e SIZE em uma tabela de propósitos e comandos.",
                                    "Praticar identificação: Analise logs ou respostas EHLO para spotting essas extensões."
                                  ],
                                  "verification": "Crie uma tabela resumindo as 3 extensões com comandos, RFCs e usos; teste SIZE em sessão real.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 3030 (SMTP SIZE)",
                                    "Exemplos de logs SMTP de ferramentas como Swaks",
                                    "Tabela comparativa em Markdown ou Excel"
                                  ],
                                  "tips": "SIZE previne abusos; sempre respeite o valor anunciado para evitar rejeições.",
                                  "learningObjective": "Sintetizar conhecimento para identificar e discutir AUTH, STARTTLS e SIZE em contextos ESMTP.",
                                  "commonMistakes": "Confundir SIZE com limites de anexos; subestimar impacto na segurança geral."
                                }
                              ],
                              "practicalExample": "Conecte via telnet a smtp.example.com:25, envie EHLO meucliente.com; observe resposta: 250-AUTH LOGIN PLAIN\r\n250-STARTTLS\r\n250-SIZE 10240000. Em seguida, negocie AUTH LOGIN com base64(user:pass), inicie STARTTLS e teste MAIL FROM com SIZE menor que o anunciado.",
                              "finalVerifications": [
                                "Lista corretamente AUTH, STARTTLS e SIZE como extensões ESMTP.",
                                "Explica o propósito e RFC de cada extensão.",
                                "Simula ou captura uma sessão EHLO mostrando essas extensões.",
                                "Diferencia corretamente fluxos de uso para autenticação, cripto e tamanho.",
                                "Identifica benefícios de segurança e prevenção de abuso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de comandos e RFCs (90-100% correto).",
                                "Profundidade na explicação de fluxos (inclui subpassos e exemplos).",
                                "Capacidade de simulação prática sem erros comuns.",
                                "Clareza na tabela comparativa ou síntese.",
                                "Compreensão de impactos reais (segurança, relay, spam)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Autenticação e criptografia (AUTH/STARTTLS).",
                                "Matemática: Codificação Base64 e chaves criptográficas.",
                                "Desenvolvimento de Software: Integração de bibliotecas SMTP em apps (ex: Nodemailer).",
                                "Ética e Privacidade: Proteção de dados em trânsito."
                              ],
                              "realWorldApplication": "Em servidores como Gmail ou Outlook, AUTH+STARTTLS previne roubo de credenciais e eavesdropping; SIZE limita spam gigante, essencial para admins de email gerenciarem tráfego e conformidade com leis anti-spam como CAN-SPAM."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Analisar problemas comuns em SMTP",
                            "description": "Explicar bounce messages, greylisting, SPF, DKIM e DMARC como mecanismos de segurança e prevenção de spam no SMTP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Bounce Messages em SMTP",
                                  "subSteps": [
                                    "Ler a definição de bounce message conforme RFC 5321.",
                                    "Identificar tipos: hard bounce (permanente) e soft bounce (temporário).",
                                    "Analisar estrutura de um bounce: headers, corpo com código de erro (ex: 550, 450).",
                                    "Estudar causas comuns: caixa cheia, domínio inexistente, rejeição por política.",
                                    "Praticar lendo headers de emails bounce reais."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença entre hard e soft bounce usando um exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 5321",
                                    "Exemplos de emails bounce de sites como mxtoolbox.com",
                                    "Ferramenta de visualização de headers como Gmail ou Thunderbird"
                                  ],
                                  "tips": "Sempre examine os códigos SMTP nos headers para diagnosticar precisamente.",
                                  "learningObjective": "Dominar os conceitos e tipos de bounce messages e sua análise.",
                                  "commonMistakes": [
                                    "Confundir soft bounce com falha permanente",
                                    "Ignorar delays de rede como bounces"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Greylisting como Mecanismo Anti-Spam",
                                  "subSteps": [
                                    "Definir greylisting: atraso temporário na primeira conexão de um remetente desconhecido.",
                                    "Entender o fluxo: tripla (IP, envelope sender, recipient) registrada e rejeitada com 4xx temporário.",
                                    "Explicar reapresentação: servidor legitimo tenta novamente após 5-30 min e é aceito.",
                                    "Discutir vantagens (simples, sem listas) e desvantagens (atrasa emails legítimos).",
                                    "Simular greylisting usando ferramentas como postfix com greylisting ativado."
                                  ],
                                  "verification": "Desenhar o fluxo de greylisting em um diagrama e prever comportamento para um email novo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação Postfix Greylisting",
                                    "Ferramenta online como greylisting.org simulator",
                                    "Diagrama em papel ou draw.io"
                                  ],
                                  "tips": "Teste com seu próprio servidor de email para ver o atraso na prática.",
                                  "learningObjective": "Explicar o funcionamento e impactos do greylisting em SMTP.",
                                  "commonMistakes": [
                                    "Achar que greylisting bloqueia permanentemente",
                                    "Não considerar MUA que não reapresentam"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar SPF para Autenticação de Remetente",
                                  "subSteps": [
                                    "Aprender SPF: registro DNS TXT que lista IPs autorizados para enviar emails pelo domínio.",
                                    "Analisar sintaxe: v=spf1 ip4:192.0.2.0 include:_spf.google.com -all.",
                                    "Entender mecanismos: pass, softfail, fail, neutral, none.",
                                    "Verificar SPF usando ferramentas como mxtoolbox.com/spf.",
                                    "Diagnosticar falhas: alinhamento envelope/headers e limites de lookups."
                                  ],
                                  "verification": "Validar SPF de um domínio real e interpretar o resultado (ex: pass/fail).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "RFC 7208",
                                    "Mxtoolbox SPF checker",
                                    "dig ou nslookup para consultas DNS"
                                  ],
                                  "tips": "Use +all apenas em testes; prefira -all para produção.",
                                  "learningObjective": "Configurar e validar registros SPF corretamente.",
                                  "commonMistakes": [
                                    "Exceder 10 lookups DNS",
                                    "Não alinhar com DKIM para DMARC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar DKIM para Assinatura Digital",
                                  "subSteps": [
                                    "Definir DKIM: assinatura criptográfica no header para verificar integridade e origem.",
                                    "Estudar chaves: pública em DNS TXT (selector._domainkey), privada no servidor.",
                                    "Analisar processo: assinatura com SHA256/RSA, verificação pelo receptor.",
                                    "Verificar headers: DKIM-Signature e Authentication-Results.",
                                    "Testar assinatura e verificação com ferramentas como dkimvalidator.com."
                                  ],
                                  "verification": "Gerar uma assinatura DKIM simples e validar em um email teste.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "RFC 6376",
                                    "OpenDKIM ou dkimpy para testes",
                                    "dkimvalidator.com"
                                  ],
                                  "tips": "Escolha selectors únicos por serviço para rotação de chaves.",
                                  "learningObjective": "Implementar e validar assinaturas DKIM em emails SMTP.",
                                  "commonMistakes": [
                                    "Chaves fracas ou expiradas",
                                    "Modificar body após assinatura"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar DMARC para Política de Relatórios",
                                  "subSteps": [
                                    "Explicar DMARC: política baseada em SPF+DKIM com relatórios.",
                                    "Analisar registro: v=DMARC1; p=quarantine; rua=mailto:reports@exemplo.com.",
                                    "Entender políticas: none, quarantine, reject e alinhamento.",
                                    "Estudar relatórios: aggregate (RUA) e forensic (RUF).",
                                    "Configurar DMARC em um subdomínio teste e analisar relatórios."
                                  ],
                                  "verification": "Interpretar um relatório DMARC agregado e recomendar ações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "RFC 7489",
                                    "DMARC analyzer tools como dmarcian.com",
                                    "Postmark DMARC checker"
                                  ],
                                  "tips": "Comece com p=none para monitorar antes de endurecer.",
                                  "learningObjective": "Aplicar DMARC para fortalecer autenticação SMTP.",
                                  "commonMistakes": [
                                    "Ignorar relatórios",
                                    "Configurar reject sem testes prévios"
                                  ]
                                }
                              ],
                              "practicalExample": "Receba um email marcado como spam, analise headers para identificar falha em SPF (fail), DKIM (none) e DMARC (reject), explique o bounce gerado e como greylisting poderia ter atrasado a entrega inicial, propondo correções no registro DNS do remetente.",
                              "finalVerifications": [
                                "Explicar com precisão os 5 mecanismos e suas interações.",
                                "Diagnosticar um problema real de email usando headers.",
                                "Simular falha em SPF/DKIM e prever resultado DMARC.",
                                "Interpretar um relatório DMARC agregado.",
                                "Diferenciar impactos de greylisting vs bounce em deliverability.",
                                "Propor configurações seguras para um domínio novo."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas definições e fluxos (90%+ correto).",
                                "Capacidade de análise prática em cenários reais.",
                                "Uso correto de terminologia (bounce types, SPF mechanisms, etc.).",
                                "Integração de conceitos (ex: como DMARC usa SPF/DKIM).",
                                "Criatividade em soluções para problemas comuns.",
                                "Clareza na comunicação de verificações e relatórios."
                              ],
                              "crossCurricularConnections": [
                                "Cibersegurança: Integração com detecção de phishing e malware em emails.",
                                "Redes de Computadores: DNS queries e protocolos TCP para SMTP.",
                                "Programação: Scripts Python para validação SPF/DKIM usando dns.resolver.",
                                "Administração de Sistemas: Configuração em servidores como Postfix/Exim.",
                                "Ética Digital: Políticas de privacidade em relatórios DMARC."
                              ],
                              "realWorldApplication": "Administradores de TI configuram SPF/DKIM/DMARC para melhorar a taxa de entrega de emails corporativos (acima de 99%), reduzem spam/phishing e recebem relatórios diários para mitigar abusos, essencial em e-commerce e serviços SaaS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Protocolos POP3 e IMAP para recebimento de e-mail",
                        "description": "Protocolos de aplicação para recuperação de e-mails do servidor: POP3 (download e remoção) na porta 110/995, e IMAP (acesso remoto sincronizado) na porta 143/993.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Descrever o funcionamento do POP3",
                            "description": "Explicar fases de POP3: autorização (USER/PASS), transação (LIST, RETR, DELE), e atualização, com ênfase em download único e remoção local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos do protocolo POP3",
                                  "subSteps": [
                                    "Estudar a definição de POP3 como protocolo de pull para recebimento de e-mails no nível de aplicação",
                                    "Identificar a porta padrão (110 TCP) e a versão mais comum (POP3v3, RFC 1939)",
                                    "Explicar o modelo cliente-servidor e o princípio de download único com remoção opcional do servidor",
                                    "Diferenciar POP3 de IMAP (POP3 baixa e remove localmente)",
                                    "Revisar o fluxo geral: autorização, transação e atualização"
                                  ],
                                  "verification": "Resumir em um diagrama as características principais do POP3",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 1939 (POP3 specification)",
                                    "Diagramas de protocolos de e-mail"
                                  ],
                                  "tips": "Use analogias como 'retirada de correspondência em uma caixa postal' para fixar o conceito de download único",
                                  "learningObjective": "Entender o propósito e as bases arquiteturais do POP3",
                                  "commonMistakes": [
                                    "Confundir POP3 com SMTP (envio) ou IMAP (sincronização)",
                                    "Ignorar que POP3 usa TCP para conexão confiável"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a fase de Autorização",
                                  "subSteps": [
                                    "Descrever o início da conexão TCP na porta 110 e saudação do servidor (+OK)",
                                    "Explicar o comando USER <username> para identificação",
                                    "Detalhar o comando PASS <password> para autenticação",
                                    "Discutir falhas de autenticação (-ERR) e transição para fase de transação após sucesso",
                                    "Mencionar extensões como APOP para autenticação sem senha em claro"
                                  ],
                                  "verification": "Simular verbalmente ou diagramar a troca de comandos USER/PASS",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta telnet ou netcat",
                                    "Servidor POP3 de teste (ex: dovecot)"
                                  ],
                                  "tips": "Sempre teste em ambiente controlado para evitar exposição de senhas reais",
                                  "learningObjective": "Dominar o processo de autenticação inicial no POP3",
                                  "commonMistakes": [
                                    "Esquecer que senhas são enviadas em texto plano (risco de segurança)",
                                    "Confundir ordem: USER antes de PASS"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a fase de Transação",
                                  "subSteps": [
                                    "Listar comandos principais: LIST (lista mensagens), RETR <n> (recupera mensagem n), DELE <n> (marca para deleção)",
                                    "Explicar STAT (status: total e tamanho) e NOOP (sem operação)",
                                    "Demonstrar como RETR baixa o conteúdo completo (headers + body)",
                                    "Discutir o princípio de download único: mensagens são processadas sequencialmente",
                                    "Explorar RSET para resetar estado e UIDL para IDs únicos"
                                  ],
                                  "verification": "Executar uma sessão simulada listando e retrievendo uma mensagem fictícia",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Telnet para simulação",
                                    "Wireshark para captura de pacotes",
                                    "Exemplos de logs POP3"
                                  ],
                                  "tips": "Registre os tamanhos retornados por LIST para entender formatação",
                                  "learningObjective": "Compreender as operações de manipulação de mensagens durante a transação",
                                  "commonMistakes": [
                                    "Acreditar que DELE remove imediatamente (apenas marca)",
                                    "Ignorar que RETR fecha conexão se mensagem grande sem TOP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender a fase de Atualização e Encerramento",
                                  "subSteps": [
                                    "Descrever o comando QUIT para finalizar: deleções efetivadas e conexão fechada",
                                    "Explicar que sem QUIT, mudanças são descartadas (rollback)",
                                    "Enfatizar remoção local após download único",
                                    "Discutir limitações: sem pastas ou busca avançada",
                                    "Revisar segurança: uso de POP3S (porta 995 com SSL/TLS)"
                                  ],
                                  "verification": "Explicar o que acontece em cenários com e sem QUIT",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de clientes como Thunderbird configurado em POP3"
                                  ],
                                  "tips": "Compare com IMAP para reforçar diferenças no encerramento",
                                  "learningObjective": "Mestre o ciclo completo e implicações práticas do POP3",
                                  "commonMistakes": [
                                    "Pensar que emails são sempre deletados (depende de DELE + QUIT)",
                                    "Confundir com push protocols"
                                  ]
                                }
                              ],
                              "practicalExample": "Conecte via telnet a um servidor POP3 de teste (ex: telnet mail.example.com 110). Envie: USER usuario, PASS senha, LIST (veja lista), RETR 1 (baixe primeira msg), DELE 1, QUIT. Observe remoção após QUIT via LIST posterior.",
                              "finalVerifications": [
                                "Descrever corretamente as três fases: autorização, transação e atualização",
                                "Listar e explicar pelo menos 5 comandos POP3 principais",
                                "Explicar o impacto do download único e DELE/QUIT",
                                "Diferenciar POP3 de IMAP em 3 pontos chave",
                                "Simular uma sessão completa sem erros",
                                "Identificar riscos de segurança (senha em claro)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de fases e comandos (90% correto)",
                                "Profundidade nos subcomandos e respostas do servidor (+OK/-ERR)",
                                "Correta ênfase em download único e remoção local",
                                "Uso de exemplos práticos ou diagramas",
                                "Identificação de limitações e comparações com outros protocolos",
                                "Clareza na explicação de autenticação e encerramento"
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Autenticação e criptografia (POP3S/SSL)",
                                "Redes de Computadores: Protocolos TCP e captura com Wireshark",
                                "Desenvolvimento de Software: Implementação de cliente POP3 em Python",
                                "Administração de Sistemas: Configuração de servidores Dovecot/Postfix"
                              ],
                              "realWorldApplication": "Configurar clientes de e-mail como Outlook ou Thunderbird em modo POP3 para baixar e remover e-mails do servidor em dispositivos móveis ou backups locais, otimizando espaço no servidor compartilhado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Descrever o funcionamento do IMAP",
                            "description": "Detalhar recursos do IMAP como pastas, flags, busca remota (SEARCH), sincronização entre múltiplos clientes, e suporte a namespaces.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do Protocolo IMAP",
                                  "subSteps": [
                                    "Estude a definição do IMAP (Internet Message Access Protocol) como protocolo para acesso remoto a mensagens de email armazenadas no servidor.",
                                    "Compare IMAP com POP3, destacando que IMAP mantém emails no servidor para acesso multi-dispositivo.",
                                    "Identifique a porta padrão (143 para não-criptografada, 993 para IMAPS com SSL/TLS).",
                                    "Revise o formato de comandos IMAP: tag + comando + parâmetros (ex: A001 LOGIN user pass).",
                                    "Analise a estrutura de respostas do servidor: * status + tag resposta."
                                  ],
                                  "verification": "Liste 5 diferenças chave entre IMAP e POP3 e explique um comando de login IMAP com exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 3501 (IMAP4rev1)",
                                    "Ferramenta telnet ou netcat para testar conexões IMAP"
                                  ],
                                  "tips": "Use um cliente de terminal como telnet para conectar a um servidor IMAP público e observar respostas iniciais.",
                                  "learningObjective": "Compreender os princípios básicos e a arquitetura do IMAP para acesso centralizado a emails.",
                                  "commonMistakes": [
                                    "Confundir portas IMAP com SMTP",
                                    "Ignorar a necessidade de criptografia em produção",
                                    "Esquecer que IMAP é stateful"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Gerenciamento de Pastas e Hierarquia",
                                  "subSteps": [
                                    "Aprenda comandos LIST e LSUB para listar pastas disponíveis e ativas.",
                                    "Estude CREATE, DELETE e RENAME para manipular pastas no servidor.",
                                    "Compreenda a hierarquia de pastas com separadores (ex: / ou .) e suporte a subpastas.",
                                    "Examine SELECT e EXAMINE para abrir pastas em modo leitura/escrita ou somente leitura.",
                                    "Pratique STATUS para obter metadados de pastas sem selecioná-las (ex: mensagens, unseen)."
                                  ],
                                  "verification": "Execute comandos para listar, criar e selecionar uma pasta em um servidor de teste e capture a saída.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Cliente IMAP como Thunderbird ou ferramenta como imapsync",
                                    "Servidor de email de teste (ex: Dovecot)"
                                  ],
                                  "tips": "Sempre use STATUS antes de SELECT para evitar locks desnecessários em pastas grandes.",
                                  "learningObjective": "Dominar o sistema de pastas hierárquico do IMAP para organização de emails.",
                                  "commonMistakes": [
                                    "Não especificar separador de hierarquia corretamente",
                                    "Tentar deletar pastas em uso",
                                    "Confundir LSUB com LIST"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender Flags e Estados de Mensagens",
                                  "subSteps": [
                                    "Identifique flags padrão: \\Seen, \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent.",
                                    "Aprenda STORE e +FLAGS/-FLAGS para adicionar/remover flags permanentemente.",
                                    "Estude FETCH com FLAGS para recuperar estados de mensagens.",
                                    "Compreenda EXPUNGE para remover mensagens marcadas como \\Deleted.",
                                    "Explore CLOSE para descartar mudanças pendentes e flags."
                                  ],
                                  "verification": "Marque uma mensagem como lida e deletada via comandos IMAP e verifique com FETCH.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "RFC 3501 seção de flags",
                                    "Cliente de email com debug de IMAP ativado"
                                  ],
                                  "tips": "Flags são case-insensitive, mas use convenções padrão para consistência.",
                                  "learningObjective": "Gerenciar metadados e estados de emails usando flags do IMAP.",
                                  "commonMistakes": [
                                    "Usar EXPUNGE sem intenção de deletar permanentemente",
                                    "Esquecer CLOSE após STORE",
                                    "Confundir flags permanentes com session-only"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar Busca Remota com SEARCH",
                                  "subSteps": [
                                    "Estude sintaxe SEARCH: critérios como ALL, FROM, SUBJECT, BODY, SINCE, BEFORE.",
                                    "Aprenda critérios avançados: OR, AND, NOT, UID, SEQUENCE.",
                                    "Compreenda SEARCH com charset para buscas em textos codificados.",
                                    "Use FETCH com IDs retornados por SEARCH para recuperar mensagens.",
                                    "Explore limites como MAX para grandes resultados."
                                  ],
                                  "verification": "Realize buscas por remetente e data em uma pasta e liste os UIDs resultantes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação SEARCH do RFC 3501",
                                    "Servidor IMAP com inbox populada"
                                  ],
                                  "tips": "Sempre use UID em vez de sequence numbers para buscas confiáveis em sessões multi-cliente.",
                                  "learningObjective": "Efetuar buscas eficientes no servidor sem download completo de emails.",
                                  "commonMistakes": [
                                    "Esquecer charset em emails internacionais",
                                    "Usar critérios inválidos sem [modificado]",
                                    "Ignorar limites de performance em inboxes grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Sincronização, Namespaces e Múltiplos Clientes",
                                  "subSteps": [
                                    "Compreenda sincronização via IDLE para notificações push de mudanças.",
                                    "Estude NAMESPACE para descobrir separadores e namespaces pessoais/compartilhados.",
                                    "Aprenda sobre UIDVALIDITY e UIDNEXT para detecção de mudanças entre sessões.",
                                    "Simule multi-cliente: abra a mesma conta em dois clientes e observe sincronização de flags/pastas.",
                                    "Revise extensões como CONDSTORE para otimizações de sincronização."
                                  ],
                                  "verification": "Configure dois clientes IMAP na mesma conta, altere uma flag em um e confirme no outro.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Dois clientes email (ex: Outlook e webmail)",
                                    "Servidor Dovecot ou Gmail com IMAP ativado"
                                  ],
                                  "tips": "Ative IMAP IDLE para sincronização em tempo real e reduza polling.",
                                  "learningObjective": "Garantir consistência de dados em cenários multi-dispositivo com IMAP.",
                                  "commonMistakes": [
                                    "Ignorar UIDVALIDITY changes que invalidam UIDs",
                                    "Não lidar com namespaces compartilhados",
                                    "Subestimar overhead de IDLE"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure uma conta Gmail com IMAP ativada em dois dispositivos (PC com Thunderbird e smartphone com app nativo). Crie uma pasta 'Projetos', mova emails para ela, marque alguns como flagged e deletados, realize busca por 'projeto' na pasta, e observe a sincronização automática em ambos os clientes sem perda de dados.",
                              "finalVerifications": [
                                "Explique verbalmente ou por escrito as diferenças entre flags permanentes e session flags.",
                                "Liste e demonstre 3 comandos para gerenciamento de pastas.",
                                "Realize uma busca SEARCH complexa (ex: OR FROM:boss SINCE 2023-01-01) e interprete resultados.",
                                "Descreva como UIDVALIDITY garante sincronização segura entre clientes.",
                                "Identifique e explique o suporte a namespaces em um servidor real.",
                                "Simule falha de sincronização e corrija usando CLOSE/EXPUNGE."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de comandos IMAP (sem erros factuais).",
                                "Capacidade de demonstrar fluxos completos (login a logout) via simulação.",
                                "Compreensão profunda de sincronização multi-cliente com exemplos corretos.",
                                "Uso correto de termos técnicos (UID, flags, namespace).",
                                "Identificação proativa de erros comuns e soluções.",
                                "Eficiência nas buscas e gerenciamento sem sobrecarga no servidor."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Integração com STARTTLS/SSL para IMAPS.",
                                "Programação: Implementação de cliente IMAP em Python com bibliotecas como imaplib.",
                                "Redes: Análise de tráfego IMAP com Wireshark para depuração.",
                                "Banco de Dados: Paralelos com consultas SQL em pastas como tabelas.",
                                "Sistemas Operacionais: Configuração de servidores Dovecot/Cyrus para IMAP."
                              ],
                              "realWorldApplication": "No ambiente corporativo, administradores usam IMAP para permitir que equipes acessem emails de múltiplos dispositivos (desktop, mobile, web) com sincronização em tempo real de pastas compartilhadas, flags de prioridade e buscas remotas eficientes, reduzindo dependência de downloads locais e facilitando migrações de servidores sem perda de metadados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Comparar POP3 e IMAP",
                            "description": "Analisar diferenças em termos de armazenamento (local vs. servidor), suporte multi-dispositivo, consumo de banda, e cenários de uso ideais para cada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de POP3 e IMAP",
                                  "subSteps": [
                                    "Pesquise a definição e propósito de POP3 (Post Office Protocol version 3).",
                                    "Pesquise a definição e propósito de IMAP (Internet Message Access Protocol).",
                                    "Identifique o papel de cada protocolo no fluxo de recebimento de e-mails.",
                                    "Anote as portas padrão: POP3 (porta 110/995) e IMAP (porta 143/993).",
                                    "Compare brevemente o modelo cliente-servidor para ambos."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando o fluxo básico de cada protocolo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet para documentação RFC 1939 (POP3) e RFC 3501 (IMAP)",
                                    "Bloco de notas ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Use fontes oficiais como IETF RFCs para precisão.",
                                  "learningObjective": "Diferenciar os conceitos básicos e históricos de POP3 e IMAP.",
                                  "commonMistakes": [
                                    "Confundir POP3 com SMTP (envio) em vez de recebimento.",
                                    "Ignorar as versões seguras (POP3S e IMAPS)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Diferenças em Armazenamento e Sincronização",
                                  "subSteps": [
                                    "Descreva como POP3 baixa e remove e-mails do servidor por padrão (armazenamento local).",
                                    "Descreva como IMAP mantém e-mails no servidor com sincronização (armazenamento servidor).",
                                    "Simule cenários: o que acontece ao deletar um e-mail local no POP3 vs. IMAP.",
                                    "Discuta opções de configuração, como 'Leave a copy on server' no POP3.",
                                    "Crie uma tabela comparativa de armazenamento."
                                  ],
                                  "verification": "Preencha uma tabela com colunas: Protocolo, Localização de Armazenamento, Comportamento de Deleção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou tabela em Markdown/Google Sheets",
                                    "Documentação de clientes de e-mail como Outlook/Thunderbird"
                                  ],
                                  "tips": "Teste configurações em um cliente de e-mail demo se possível.",
                                  "learningObjective": "Explicar impactos do armazenamento local vs. servidor na gestão de e-mails.",
                                  "commonMistakes": [
                                    "Assumir que POP3 sempre deleta imediatamente sem opções.",
                                    "Subestimar perda de dados em POP3 sem backups locais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Suporte Multi-Dispositivo e Consumo de Banda",
                                  "subSteps": [
                                    "Avalie suporte multi-dispositivo: POP3 (limitado, requer re-download) vs. IMAP (sincronizado).",
                                    "Calcule consumo de banda: POP3 (baixa após download inicial) vs. IMAP (alta com sincronizações frequentes).",
                                    "Considere fatores como pastas, flags (lido/não lido) e busca em IMAP.",
                                    "Crie cenários hipotéticos para um usuário com 3 dispositivos.",
                                    "Meça diferenças qualitativamente em uma escala."
                                  ],
                                  "verification": "Desenvolva um fluxograma mostrando acesso simultâneo em múltiplos dispositivos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma",
                                    "Calculadora para estimar tráfego de dados (ex: 1MB e-mail x 10 acessos)"
                                  ],
                                  "tips": "Pense em usuários móveis onde banda é limitada.",
                                  "learningObjective": "Quantificar trade-offs entre conveniência multi-dispositivo e eficiência de banda.",
                                  "commonMistakes": [
                                    "Ignorar que IMAP pode ser configurado para download parcial.",
                                    "Superestimar economia de banda do POP3 em grandes caixas de entrada."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Cenários de Uso Ideais e Resumir Diferenças",
                                  "subSteps": [
                                    "Liste cenários ideais para POP3: conexão lenta única, armazenamento local prioritário.",
                                    "Liste cenários ideais para IMAP: múltiplos dispositivos, acesso remoto frequente.",
                                    "Resuma prós e contras em uma matriz SWOT-like.",
                                    "Discuta migrações modernas (IMAP predominante).",
                                    "Crie um guia de recomendação baseado em necessidades do usuário."
                                  ],
                                  "verification": "Escreva um parágrafo recomendando um protocolo para um caso hipotético (ex: executivo viajante).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Modelo de matriz comparativa",
                                    "Exemplos reais de políticas de TI empresariais"
                                  ],
                                  "tips": "Considere conformidade GDPR para armazenamento servidor.",
                                  "learningObjective": "Aplicar comparações a decisões práticas de configuração de e-mail.",
                                  "commonMistakes": [
                                    "Recomendar POP3 universalmente por 'economia de banda' sem contexto.",
                                    "Esquecer limitações de armazenamento servidor em IMAP."
                                  ]
                                }
                              ],
                              "practicalExample": "Configure uma conta de e-mail de teste (ex: Gmail com POP3/IMAP ativado) no Thunderbird. Baixe 5 e-mails via POP3 em um PC (observe remoção do servidor), depois mude para IMAP em um smartphone e veja sincronização em tempo real, medindo tempo de sincronização e uso de dados via ferramentas de rede como Wireshark.",
                              "finalVerifications": [
                                "Pode listar pelo menos 5 diferenças chave entre POP3 e IMAP sem consultar notas?",
                                "Explica corretamente o impacto de deletar um e-mail em cada protocolo?",
                                "Identifica cenários onde POP3 é preferível (ex: banda limitada)?",
                                "Descreve suporte a pastas e flags em IMAP vs. POP3?",
                                "Compara consumo de banda com exemplos numéricos simples?",
                                "Recomenda o protocolo certo para um usuário com múltiplos dispositivos?"
                              ],
                              "assessmentCriteria": [
                                "Precisão factual nas diferenças de armazenamento e sincronização (80%+ correto).",
                                "Profundidade na análise de multi-dispositivo e banda (inclui exemplos quantitativos).",
                                "Clareza em cenários de uso, com justificativas lógicas.",
                                "Uso de tabelas/diagramas para visualização de comparações.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Capacidade de aplicar a contextos reais (ex: corporativo vs. pessoal)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Comparar TLS/SSL em POP3S vs. IMAPS.",
                                "Administração de Sistemas: Configuração de servidores de e-mail (Postfix/Dovecot).",
                                "Desenvolvimento de Software: Implementação de clientes de e-mail em Python (smtplib/imaplib).",
                                "Análise de Redes: Captura de pacotes com Wireshark para protocolos.",
                                "Gestão de Projetos: Avaliação de trade-offs em infraestrutura de TI."
                              ],
                              "realWorldApplication": "Em ambientes corporativos, administradores de TI usam IMAP para equipes remotas com múltiplos dispositivos, enquanto provedores de internet em áreas rurais recomendam POP3 para usuários com conexões instáveis, otimizando armazenamento e reduzindo custos de tráfego de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Protocolo HTTP (HyperText Transfer Protocol)",
                    "description": "Protocolo para transferência de páginas web e conteúdo hipertexto.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Fundamentos do Protocolo HTTP",
                        "description": "Conceitos básicos sobre o HTTP como protocolo de aplicação no modelo TCP/IP, sua função na transferência de hipertexto e páginas web, características como stateless e client-server.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Definir o HTTP e seu papel no modelo TCP/IP",
                            "description": "Explicar o HTTP como protocolo de camada de aplicação que opera sobre TCP para transferência de recursos web, identificando sua porta padrão (80 para HTTP, 443 para HTTPS) e modelo request-response.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Modelo TCP/IP",
                                  "subSteps": [
                                    "Estude as quatro camadas principais do modelo TCP/IP: Aplicação, Transporte, Internet (Rede) e Acesso à Rede (Enlace).",
                                    "Identifique a camada de Transporte como responsável pelo TCP, que garante entrega confiável de dados.",
                                    "Analise como protocolos da camada de Aplicação operam sobre TCP ou UDP para comunicação entre aplicações.",
                                    "Compare brevemente com o modelo OSI para destacar diferenças (TCP/IP é mais prático e condensado).",
                                    "Crie um diagrama simples das camadas com setas indicando fluxo de dados."
                                  ],
                                  "verification": "Desenhar e rotular corretamente um diagrama das camadas TCP/IP, posicionando TCP na camada de Transporte.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Recursos online sobre modelo TCP/IP (ex: Wikipedia ou Khan Academy)"
                                  ],
                                  "tips": "Visualize as camadas como uma pilha de pratos: cada uma suporta a de cima.",
                                  "learningObjective": "Dominar a estrutura hierárquica do modelo TCP/IP e o posicionamento do TCP.",
                                  "commonMistakes": [
                                    "Confundir TCP/IP com OSI (7 camadas)",
                                    "Achar que TCP é da camada de Aplicação",
                                    "Ignorar que TCP garante confiabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Camada de Aplicação",
                                  "subSteps": [
                                    "Defina a camada de Aplicação como a mais alta, responsável por protocolos que interagem diretamente com o usuário.",
                                    "Liste exemplos de protocolos de aplicação: HTTP, FTP, SMTP, DNS.",
                                    "Entenda que esses protocolos usam TCP (ou UDP) da camada inferior para transporte de dados.",
                                    "Discuta encapsulamento: dados da aplicação são embrulhados em segmentos TCP.",
                                    "Pesquise como a camada de Aplicação abstrai complexidades das camadas inferiores."
                                  ],
                                  "verification": "Listar 3 protocolos de aplicação e explicar como eles dependem do TCP.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas sobre protocolos de rede",
                                    "Vídeo tutorial sobre camadas TCP/IP (ex: YouTube - freeCodeCamp)"
                                  ],
                                  "tips": "Pense na camada de Aplicação como o 'aplicativo' que você usa, como um navegador.",
                                  "learningObjective": "Identificar o papel da camada de Aplicação e sua dependência de protocolos de transporte como TCP.",
                                  "commonMistakes": [
                                    "Confundir camada de Aplicação com Transporte",
                                    "Achar que HTTP gerencia conexões TCP",
                                    "Esquecer exemplos concretos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o HTTP e suas Características Principais",
                                  "subSteps": [
                                    "Defina HTTP como HyperText Transfer Protocol, protocolo de camada de Aplicação para transferência de recursos web (HTML, imagens, etc.).",
                                    "Explique que opera sobre TCP para garantir entrega ordenada e sem erros.",
                                    "Identifique portas padrão: 80 para HTTP (não criptografado) e 443 para HTTPS (criptografado com TLS/SSL).",
                                    "Descreva HTTP como stateless: cada request é independente.",
                                    "Diferencie HTTP de outros protocolos: focado em web, request-response."
                                  ],
                                  "verification": "Escrever uma definição precisa do HTTP, incluindo portas e dependência de TCP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação oficial IETF RFC 9110 para HTTP",
                                    "Ferramenta Wireshark para observar tráfego (opcional)"
                                  ],
                                  "tips": "Lembre-se: HTTP é o 'idioma' dos navegadores para pedir páginas ao servidor.",
                                  "learningObjective": "Definir HTTP com precisão, destacando portas e relação com TCP.",
                                  "commonMistakes": [
                                    "Confundir porta 80 com HTTPS",
                                    "Achar HTTP gerencia criptografia (isso é HTTPS)",
                                    "Pensar HTTP como camada de Transporte"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Modelo Request-Response do HTTP",
                                  "subSteps": [
                                    "Descreva o fluxo: Cliente envia REQUEST (método GET/POST, headers, body), servidor responde com RESPONSE (status code, headers, body).",
                                    "Exemplo: GET /index.html -> 200 OK com conteúdo HTML.",
                                    "Explique como TCP estabelece conexão (handshake 3-way) antes do request.",
                                    "Discuta status codes comuns: 200 (OK), 404 (Not Found), 500 (Server Error).",
                                    "Simule um request-response usando ferramentas como curl."
                                  ],
                                  "verification": "Executar um request HTTP via curl e interpretar a response completa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal com curl instalado",
                                    "Site de teste como http://httpbin.org/get"
                                  ],
                                  "tips": "Use 'curl -v' para ver detalhes verbosos, incluindo headers TCP.",
                                  "learningObjective": "Compreender e demonstrar o ciclo request-response no contexto TCP/IP.",
                                  "commonMistakes": [
                                    "Ignorar headers na request/response",
                                    "Confundir método GET com POST",
                                    "Esquecer o handshake TCP"
                                  ]
                                }
                              ],
                              "practicalExample": "Abra o terminal e execute 'curl -v http://example.com'. Observe o handshake TCP na camada de Transporte, o request GET na porta 80 (camada Aplicação), e a response com status 200 e headers. Isso demonstra HTTP operando sobre TCP no modelo TCP/IP.",
                              "finalVerifications": [
                                "Diagramar o modelo TCP/IP com HTTP posicionado corretamente na camada de Aplicação sobre TCP.",
                                "Explicar verbalmente as portas 80/443 e diferença HTTP/HTTPS.",
                                "Simular um request-response HTTP e identificar componentes.",
                                "Diferenciar HTTP de protocolos de outras camadas.",
                                "Listar 3 aplicações reais de HTTP no dia a dia.",
                                "Identificar erros em uma descrição incorreta do HTTP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de HTTP como protocolo de aplicação sobre TCP (pontos plenos se correto).",
                                "Correta identificação de portas padrão e modelo request-response.",
                                "Compreensão clara da dependência hierárquica no TCP/IP.",
                                "Uso de exemplos práticos e diagramas para ilustrar conceitos.",
                                "Capacidade de evitar confusões comuns (ex: camadas, stateless).",
                                "Demonstração via ferramenta como curl."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos em camadas semelhantes a funções compostas e abstrações modulares.",
                                "Física: Analogia com transmissão de sinais em camadas (onda transportadora + modulação).",
                                "História: Evolução da web desde Tim Berners-Lee (1989) e padronização HTTP pela IETF.",
                                "Língua Portuguesa: Análise de estruturas textuais em requests/responses (headers como metadados)."
                              ],
                              "realWorldApplication": "HTTP é essencial para navegação web (acesso a sites via browsers), APIs RESTful (apps mobile se comunicando com servidores), downloads de arquivos e streaming de mídia, sempre sobre TCP para confiabilidade em redes globais como a Internet."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Identificar características principais do HTTP",
                            "description": "Descrever propriedades como stateless (sem manutenção de estado entre requisições), texto-based, extensível via headers e suporte a cache.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de Stateless no HTTP",
                                  "subSteps": [
                                    "Leia a definição oficial de stateless: cada requisição HTTP é independente e não mantém estado entre elas.",
                                    "Compare com protocolos stateful como FTP, destacando que o servidor não armazena contexto do cliente.",
                                    "Analise um diagrama de request-response mostrando independência.",
                                    "Identifique como cookies e sessions mitigam statelessness.",
                                    "Pratique explicando com um exemplo de login em um site."
                                  ],
                                  "verification": "Explique em suas palavras o que significa stateless e dê um exemplo de impacto em uma aplicação web.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre HTTP",
                                    "Diagrama de request-response HTTP",
                                    "Browser com DevTools"
                                  ],
                                  "tips": "Lembre-se: stateless facilita escalabilidade, mas requer mecanismos como tokens para estado.",
                                  "learningObjective": "Definir e exemplificar statelessness no contexto HTTP.",
                                  "commonMistakes": [
                                    "Confundir stateless com sessionless (sessions podem existir via cookies)",
                                    "Achar que stateless significa sem autenticação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o formato baseado em texto do HTTP",
                                  "subSteps": [
                                    "Examine a estrutura de uma mensagem HTTP: linha de request/status, headers e body em texto ASCII.",
                                    "Use um editor de texto para criar e visualizar uma requisição HTTP manual via telnet ou curl.",
                                    "Compare com protocolos binários como HTTPS (ainda texto no nível app).",
                                    "Identifique vantagens: legibilidade humana e facilidade de depuração.",
                                    "Teste enviando uma requisição simples e lendo a resposta em texto plano."
                                  ],
                                  "verification": "Construa uma requisição GET manual em texto e explique sua legibilidade.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Ferramenta curl ou telnet",
                                    "Editor de texto",
                                    "Servidor HTTP local como http-server"
                                  ],
                                  "tips": "Sempre termine headers com CRLF (\\r\\n) para simulações manuais.",
                                  "learningObjective": "Descrever e demonstrar o formato texto-based do HTTP.",
                                  "commonMistakes": [
                                    "Confundir com codificação binária (HTTP é texto, payloads podem ser binários)",
                                    "Ignorar que HTTP/2 é binário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a extensibilidade via headers HTTP",
                                  "subSteps": [
                                    "Liste headers comuns: Content-Type, Authorization, User-Agent.",
                                    "Estude como headers personalizados (X-) permitem extensões sem quebrar compatibilidade.",
                                    "Inspecione headers em DevTools durante navegação em sites reais.",
                                    "Crie uma requisição com header customizado usando Postman ou curl.",
                                    "Discuta evolução: HTTP/1.1 adicionou extensões como Host header."
                                  ],
                                  "verification": "Identifique e explique 3 headers em uma requisição real e proponha um header customizado.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Postman ou Insomnia",
                                    "Browser DevTools (Network tab)",
                                    "Lista de headers HTTP na RFC 9110"
                                  ],
                                  "tips": "Headers são case-insensitive; use-os para metadados sem alterar o core do protocolo.",
                                  "learningObjective": "Explicar como headers tornam o HTTP extensível.",
                                  "commonMistakes": [
                                    "Achar que headers alteram o corpo da mensagem",
                                    "Usar headers sem validar compatibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar o suporte a cache no HTTP",
                                  "subSteps": [
                                    "Aprenda headers de cache: Cache-Control, ETag, Last-Modified.",
                                    "Simule cache hit/miss usando DevTools e reload forçado (Ctrl+F5).",
                                    "Configure um servidor simples para enviar headers de cache.",
                                    "Compare cache público vs privado e impactos em performance.",
                                    "Teste desabilitando cache no browser e observe diferenças."
                                  ],
                                  "verification": "Explique como Cache-Control: max-age=3600 funciona e demonstre em uma requisição.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Browser DevTools (Application > Cache)",
                                    "Node.js com express para servidor",
                                    "RFC 9111 sobre caching"
                                  ],
                                  "tips": "Cache reduz latência; sempre valide com ETag para conteúdo dinâmico.",
                                  "learningObjective": "Descrever mecanismos de cache HTTP e seu propósito.",
                                  "commonMistakes": [
                                    "Confundir cache do browser com proxy cache",
                                    "Ignorar que cache é opcional e controlado por headers"
                                  ]
                                }
                              ],
                              "practicalExample": "Abra o DevTools do Chrome (F12 > Network), acesse um site como google.com, filtre por uma requisição e identifique: método stateless (GET independente), headers texto-based (Content-Type: text/html), extensibilidade (User-Agent custom), cache (Cache-Control presente). Descreva cada característica observada.",
                              "finalVerifications": [
                                "Explique stateless com um exemplo de múltiplas requisições sem contexto.",
                                "Mostre uma mensagem HTTP em texto plano e destaque sua legibilidade.",
                                "Liste 3 headers e explique sua função extensível.",
                                "Descreva como ETag suporta cache e evite re-download desnecessário.",
                                "Integre todas as características em uma explicação coesa do HTTP."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições das 4 características principais (stateless, text-based, headers, cache).",
                                "Uso de exemplos concretos e demonstrações práticas.",
                                "Compreensão de vantagens e limitações de cada feature.",
                                "Capacidade de relacionar características em cenários reais.",
                                "Ausência de confusões comuns como stateless vs stateful.",
                                "Demonstração via ferramentas como DevTools ou curl."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Uso em fetch() JavaScript com headers customizados.",
                                "Segurança da Informação: HTTPS estende HTTP com TLS para criptografia.",
                                "Desenvolvimento de Software: APIs REST stateless baseadas em HTTP.",
                                "Análise de Redes: Inspeção de tráfego HTTP com Wireshark."
                              ],
                              "realWorldApplication": "No dia a dia, todo carregamento de página web usa HTTP stateless para escalabilidade (milhões de users simultâneos), texto-based para depuração fácil por devs, headers para autenticação (JWT) e cache para performance (CDNs como Cloudflare reduzem latência em 50-80%)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Diferenciar HTTP/1.1 de versões anteriores e posteriores",
                            "description": "Comparar HTTP/1.0 (conexões não persistentes) com HTTP/1.1 (persistente, pipelining) e introduzir conceitos de HTTP/2 (multiplexing) e HTTP/3 (sobre QUIC).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do HTTP/1.0",
                                  "subSteps": [
                                    "Pesquise a especificação do HTTP/1.0 (RFC 1945).",
                                    "Identifique que usa conexões não persistentes (uma por request/response).",
                                    "Note limitações como ausência de cabeçalhos Host obrigatórios e sem pipelining.",
                                    "Analise exemplos de requests HTTP/1.0 simples.",
                                    "Registre as principais desvantagens em termos de performance."
                                  ],
                                  "verification": "Crie um diagrama mostrando uma conexão HTTP/1.0 com múltiplos requests e confirme que cada um abre uma nova TCP connection.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 1945 (disponível online)",
                                    "Ferramenta de diagramação como Draw.io",
                                    "Browser dev tools"
                                  ],
                                  "tips": "Foquem em como cada request requer um novo handshake TCP, impactando latência.",
                                  "learningObjective": "Compreender as limitações básicas do HTTP/1.0, especialmente conexões não persistentes.",
                                  "commonMistakes": [
                                    "Confundir com HTTP/1.1 persistente",
                                    "Ignorar a falta de cabeçalho Host",
                                    "Subestimar overhead de novas conexões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Melhorias no HTTP/1.1",
                                  "subSteps": [
                                    "Estude RFC 2616/7230 para HTTP/1.1.",
                                    "Aprenda sobre conexões persistentes (keep-alive via Connection: keep-alive).",
                                    "Entenda pipelining: envio de múltiplos requests sem esperar responses.",
                                    "Identifique adições como cabeçalho Host obrigatório e chunked transfer encoding.",
                                    "Teste com curl para ver diferenças."
                                  ],
                                  "verification": "Execute comandos curl para um site HTTP/1.1 e observe reutilização de conexões no log de rede.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "RFC 2616/7230",
                                    "curl ou Postman",
                                    "Wireshark para captura de pacotes"
                                  ],
                                  "tips": "Use --http1.1 no curl para forçar versão e compare com HTTP/1.0.",
                                  "learningObjective": "Dominar as inovações do HTTP/1.1 que melhoram eficiência sobre 1.0.",
                                  "commonMistakes": [
                                    "Achar que pipelining é sempre usado (muitos browsers desabilitam)",
                                    "Confundir persistente com multiplexing",
                                    "Ignorar problemas de HOL blocking no pipelining"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar HTTP/2 e suas Inovações",
                                  "subSteps": [
                                    "Revise RFC 7540 para HTTP/2.",
                                    "Aprenda multiplexing: múltiplos streams sobre uma conexão TCP.",
                                    "Estude binary framing, header compression (HPACK) e server push.",
                                    "Compare com HTTP/1.1: sem HOL blocking em streams independentes.",
                                    "Teste suporte em browsers modernos."
                                  ],
                                  "verification": "Use dev tools do Chrome para carregar um site HTTP/2 e identifique frames multiplexados na aba Network.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "RFC 7540",
                                    "Chrome DevTools",
                                    "Site de teste como http2.pro"
                                  ],
                                  "tips": "Ative Protocolo HTTP/2 no nginx/apache para testes locais.",
                                  "learningObjective": "Compreender como HTTP/2 resolve limitações de 1.1 com multiplexing.",
                                  "commonMistakes": [
                                    "Confundir HTTP/2 com SPDY (predecessor)",
                                    "Pensar que elimina TCP completamente",
                                    "Subestimar necessidade de TLS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir HTTP/3 e Comparar Todas as Versões",
                                  "subSteps": [
                                    "Estude RFC 9114 para HTTP/3 sobre QUIC (RFC 9000).",
                                    "Aprenda que QUIC usa UDP, com multiplexing nativo e migração de conexões.",
                                    "Compare: HTTP/1.x (TCP), HTTP/2 (TCP), HTTP/3 (QUIC/UDP).",
                                    "Crie uma tabela comparativa de features: persistência, pipelining, multiplexing, transporte.",
                                    "Discuta trade-offs como perda de head-of-line blocking e segurança integrada."
                                  ],
                                  "verification": "Monte uma tabela comparativa e explique verbalmente ou por escrito as diferenças chave para um par.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 9114 e 9000",
                                    "Google Sheets ou Markdown para tabela",
                                    "http3check.net para teste"
                                  ],
                                  "tips": "Foque em QUIC resolvendo problemas de TCP loss em redes móveis.",
                                  "learningObjective": "Diferenciar HTTP/3 das anteriores e sintetizar evoluções do protocolo.",
                                  "commonMistakes": [
                                    "Achar HTTP/3 desnecessário",
                                    "Confundir QUIC com TCP over UDP simples",
                                    "Ignorar maturidade ainda em evolução"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando curl, faça requests sequenciais para um site: primeiro force HTTP/1.0 (--http1.0), observe novas conexões por request; depois HTTP/1.1 (--http1.1), veja keep-alive; ative HTTP/2/3 em um servidor local e compare tempos de carregamento de múltiplas imagens, notando multiplexing em dev tools.",
                              "finalVerifications": [
                                "Explique por que HTTP/1.0 é ineficiente para sites modernos.",
                                "Descreva como pipelining do 1.1 difere de multiplexing do 2.",
                                "Liste 3 vantagens do QUIC no HTTP/3.",
                                "Crie um diagrama de fluxo comparando conexões em cada versão.",
                                "Identifique um site real usando HTTP/3 via browser dev tools.",
                                "Discuta cenários onde HTTP/1.1 ainda é preferido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de conexões persistentes vs não persistentes (80%+ correto).",
                                "Compreensão clara de multiplexing vs pipelining com exemplos.",
                                "Correta identificação de RFCs e features chave por versão.",
                                "Tabela comparativa completa e organizada.",
                                "Explicação de impactos em performance/latência.",
                                "Uso correto de ferramentas para verificação prática."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Integração de TLS 1.3 obrigatória no HTTP/2/3.",
                                "Desenvolvimento Web: Otimização de performance em frameworks como React/Node.js.",
                                "Matemática/Algoritmos: Análise de complexidade em header compression (HPACK).",
                                "Engenharia de Software: Evolução de protocolos em design de sistemas distribuídos.",
                                "Redes: Comparação TCP vs UDP/QUIC em fundamentos de transporte."
                              ],
                              "realWorldApplication": "Em desenvolvimento web, escolher HTTP/2/3 reduz latência em sites com muitos recursos (ex: Google, Netflix), melhorando UX em conexões lentas; DevOps usa para configurar CDNs como Cloudflare, otimizando global load times e resiliência em redes instáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Estrutura de uma Requisição HTTP",
                        "description": "Componentes de uma mensagem de requisição HTTP: request line, headers e body, com exemplos práticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Analisar a request line em uma requisição HTTP",
                            "description": "Identificar e interpretar método (ex: GET), URI (ex: /index.html), versão HTTP (ex: HTTP/1.1) em uma requisição exemplo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral da request line em uma requisição HTTP",
                                  "subSteps": [
                                    "Leia a definição oficial da request line no RFC 2616 ou documentação HTTP/1.1.",
                                    "Identifique que a request line é a primeira linha de uma requisição HTTP, composta por método, URI e versão HTTP, separados por espaços.",
                                    "Estude exemplos básicos de requisições HTTP completas para contextualizar a request line.",
                                    "Anote a sintaxe exata: <método> <URI> <versão HTTP>.",
                                    "Compare com response line para diferenciar."
                                  ],
                                  "verification": "Escreva um resumo da estrutura da request line e identifique-a corretamente em uma requisição de exemplo fornecida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 2616 (seção 5.1)",
                                    "Exemplos de requisições HTTP em sites como MDN Web Docs"
                                  ],
                                  "tips": "Sempre lembre que os componentes são separados por um único espaço (SP) e terminam com CRLF (\\r\\n).",
                                  "learningObjective": "Entender a composição exata da request line e sua posição na requisição HTTP.",
                                  "commonMistakes": [
                                    "Confundir request line com header lines.",
                                    "Ignorar separadores de espaço ou fim de linha."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e interpretar o método HTTP",
                                  "subSteps": [
                                    "Liste os métodos comuns HTTP: GET, POST, PUT, DELETE, HEAD, OPTIONS.",
                                    "Analise o propósito de cada método (ex: GET para leitura, POST para criação).",
                                    "Localize o método na request line: sempre o primeiro token antes do primeiro espaço.",
                                    "Pratique identificando em exemplos variados.",
                                    "Explique diferenças semânticas entre métodos idempotentes e não-idempotentes."
                                  ],
                                  "verification": "Dado uma request line, extraia e explique o método corretamente em pelo menos 5 exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de métodos HTTP do MDN",
                                    "Ferramenta como curl para gerar requisições reais"
                                  ],
                                  "tips": "Métodos são case-sensitive e em maiúsculas por convenção.",
                                  "learningObjective": "Reconhecer e descrever o método HTTP e seu significado semântico.",
                                  "commonMistakes": [
                                    "Confundir método com URI.",
                                    "Ignorar métodos menos comuns como PATCH."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a URI (Uniform Resource Identifier)",
                                  "subSteps": [
                                    "Defina URI: caminho absoluto ou relativo para o recurso solicitado.",
                                    "Identifique a posição: segundo token entre os dois primeiros espaços.",
                                    "Diferencie path, query string (ex: /user?id=123) e fragmento (#section).",
                                    "URL-decode caracteres especiais (ex: %20 para espaço).",
                                    "Pratique com URIs complexas incluindo parâmetros."
                                  ],
                                  "verification": "Parse uma URI de exemplo, identificando path, query params e decodificando adequadamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação URI do MDN",
                                    "Ferramenta online de URL parser"
                                  ],
                                  "tips": "Sempre considere query strings como parte da URI na request line.",
                                  "learningObjective": "Extrair e interpretar componentes da URI corretamente.",
                                  "commonMistakes": [
                                    "Misturar URI com host (que está no Host header).",
                                    "Não decodificar % encodings."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar a versão do protocolo HTTP e validar a request line completa",
                                  "subSteps": [
                                    "Liste versões comuns: HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3.",
                                    "Localize a versão: terceiro token após o último espaço.",
                                    "Valide a request line inteira: verifique separadores, ausência de extras.",
                                    "Compare com exemplos inválidos para detectar erros.",
                                    "Integre todos componentes em uma análise holística."
                                  ],
                                  "verification": "Analise uma request line completa, rotulando cada parte e confirmando validade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de requisições Wireshark ou Fiddler",
                                    "Validador HTTP online"
                                  ],
                                  "tips": "Versão determina features como chunked transfer encoding.",
                                  "learningObjective": "Completar a análise da request line identificando versão e validando estrutura.",
                                  "commonMistakes": [
                                    "Confundir versão com status code (que é na response).",
                                    "Permitir múltiplos espaços."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise a request line: \"GET /api/users?id=123&name=John HTTP/1.1\"\n- Método: GET (requisição de leitura idempotente)\n- URI: /api/users?id=123&name=John (path: /api/users, query: id=123&name=John)\n- Versão: HTTP/1.1 (suporta keep-alive e host headers obrigatórios)",
                              "finalVerifications": [
                                "Identifica corretamente método, URI e versão em uma request line fornecida.",
                                "Explica o propósito semântico do método.",
                                "Parse query parameters da URI.",
                                "Valida a estrutura sintática (separadores, fim de linha).",
                                "Diferencia request line de headers.",
                                "Detecta e corrige erros comuns em exemplos inválidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cada componente (100% correto).",
                                "Profundidade na explicação semântica (método e URI).",
                                "Capacidade de lidar com URIs complexas (query strings, encoding).",
                                "Validação sintática completa.",
                                "Tempo de análise eficiente (<2 min por exemplo).",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar parsers HTTP em linguagens como Python (requests library).",
                                "Segurança da Informação: Analisar métodos para vulnerabilidades (ex: POST sem CSRF).",
                                "Desenvolvimento Web: Debug de requisições em DevTools do browser.",
                                "Matemática: Parsing de strings como expressões regulares."
                              ],
                              "realWorldApplication": "Desenvolvedores web usam essa análise para debugar APIs REST, proxies reversos (ex: Nginx logs), ferramentas de monitoramento como Wireshark ou ELK Stack, e conformidade com especificações em servidores como Apache."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Interpretar headers de requisição HTTP",
                            "description": "Explicar headers comuns como Host, User-Agent, Accept, Content-Type e Authorization, com exemplos de uso em requisições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral dos headers HTTP",
                                  "subSteps": [
                                    "Estude o formato de uma requisição HTTP: linha de requisição, headers e body.",
                                    "Identifique que headers são pares chave-valor separados por dois pontos (:).",
                                    "Aprenda sobre headers de requisição (client-to-server) versus response headers.",
                                    "Revise a sintaxe: nome do header em maiúsculas/minúsculas insensível, seguido de valor.",
                                    "Entenda que headers terminam com CRLF (\\r\\n)."
                                  ],
                                  "verification": "Liste os componentes principais de uma requisição HTTP e descreva o papel dos headers.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial do HTTP/1.1 (RFC 7230)",
                                    "Ferramentas de desenvolvedor do navegador (F12)"
                                  ],
                                  "tips": "Use o inspetor de rede no Chrome para visualizar headers reais em tempo real.",
                                  "learningObjective": "Entender a anatomia e sintaxe básica dos headers HTTP.",
                                  "commonMistakes": [
                                    "Confundir headers com o corpo da requisição (body)",
                                    "Ignorar a insensibilidade a maiúsculas/minúsculas nos nomes dos headers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar headers comuns: Host, User-Agent, Accept e Content-Type",
                                  "subSteps": [
                                    "Analise o header Host: indica o domínio do servidor (obrigatório em HTTP/1.1).",
                                    "Estude User-Agent: identifica o cliente (navegador, bot, etc.).",
                                    "Explore Accept: especifica tipos de mídia aceitos pelo cliente (ex: application/json).",
                                    "Compreenda Content-Type: define o tipo de conteúdo no body (ex: text/html, application/json).",
                                    "Discuta exemplos de valores típicos para cada header."
                                  ],
                                  "verification": "Explique o propósito e dê um exemplo de valor para cada um dos quatro headers.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de headers HTTP no MDN Web Docs",
                                    "Exemplos de requisições via curl ou Postman"
                                  ],
                                  "tips": "Memorize os headers por categoria: identificação (Host, User-Agent), negociação (Accept), conteúdo (Content-Type).",
                                  "learningObjective": "Dominar o significado e uso dos headers Host, User-Agent, Accept e Content-Type.",
                                  "commonMistakes": [
                                    "Achar que Host é opcional (é obrigatório em HTTP/1.1)",
                                    "Confundir Accept com Content-Type"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o header Authorization e exemplos integrados",
                                  "subSteps": [
                                    "Aprenda sobre Authorization: usado para autenticação (Basic, Bearer token).",
                                    "Estude esquemas comuns: Basic (base64(user:pass)), Bearer (JWT tokens).",
                                    "Analise uma requisição completa com múltiplos headers.",
                                    "Compare headers em requisições GET vs POST.",
                                    "Identifique como headers afetam o processamento do servidor."
                                  ],
                                  "verification": "Descreva como o header Authorization é formatado em um token Bearer e seu risco de segurança.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação OAuth 2.0",
                                    "Ferramenta Postman para simular requisições autenticadas"
                                  ],
                                  "tips": "Nunca exponha credenciais em logs; use tokens em produção.",
                                  "learningObjective": "Compreender autenticação via headers e integração com outros headers.",
                                  "commonMistakes": [
                                    "Expor credenciais em User-Agent ou outros headers",
                                    "Usar Authorization sem HTTPS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar análise e interpretação de headers reais",
                                  "subSteps": [
                                    "Capture uma requisição HTTP real usando dev tools do navegador.",
                                    "Identifique e interprete cada header listado na habilidade.",
                                    "Simule uma requisição com curl incluindo todos os headers.",
                                    "Modifique um header e observe o impacto na resposta do servidor.",
                                    "Documente suas observações em um relatório simples."
                                  ],
                                  "verification": "Analise uma requisição capturada e explique o papel de 5 headers presentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Comando curl no terminal",
                                    "Postman ou Insomnia",
                                    "Site de teste como httpbin.org"
                                  ],
                                  "tips": "Use httpbin.org/headers para ver headers enviados de volta.",
                                  "learningObjective": "Aplicar o conhecimento para interpretar headers em cenários reais.",
                                  "commonMistakes": [
                                    "Não limpar cache do navegador ao testar",
                                    "Ignorar headers personalizados (X-*)"
                                  ]
                                }
                              ],
                              "practicalExample": "Requisição curl: curl -H 'Host: api.example.com' -H 'User-Agent: MeuApp/1.0' -H 'Accept: application/json' -H 'Content-Type: application/json' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...' -X POST -d '{\"key\":\"value\"}' https://httpbin.org/post\nInterpretação: Host direciona ao servidor; User-Agent identifica o app; Accept pede JSON; Content-Type declara JSON no body; Authorization autentica com token JWT.",
                              "finalVerifications": [
                                "Liste e explique os 5 headers principais com exemplos reais.",
                                "Capture e interprete uma requisição HTTP completa de um site real.",
                                "Simule uma requisição falha removendo o header Host e explique o erro.",
                                "Diferencie headers de requisição de response headers.",
                                "Crie uma requisição curl com Authorization Bearer válida.",
                                "Identifique o tipo de conteúdo de uma resposta baseada no Accept."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de cada header (100% correto).",
                                "Capacidade de identificar headers em ferramentas reais (dev tools, curl).",
                                "Uso correto de exemplos com sintaxe válida.",
                                "Compreensão de impactos de segurança (ex: Authorization).",
                                "Análise integrada de múltiplos headers em uma requisição.",
                                "Detecção e correção de erros comuns em headers."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Autenticação e autorização via headers.",
                                "Desenvolvimento de Software: Integração em APIs RESTful.",
                                "Análise de Dados: Monitoramento de tráfego de rede.",
                                "Programação Web: Manipulação de headers em JavaScript (fetch).",
                                "Ética Digital: Privacidade em User-Agent e tokens."
                              ],
                              "realWorldApplication": "No desenvolvimento de APIs web, debugging de erros 4xx/5xx (ex: 401 Unauthorized por falta de Authorization), análise de logs de servidores para otimizar performance, e testes de segurança em aplicações como e-commerces ou apps mobile que consomem serviços backend."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Construir uma requisição HTTP simples",
                            "description": "Montar uma requisição HTTP completa usando ferramentas como curl ou manualmente, incluindo body para métodos como POST.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura básica de uma requisição HTTP",
                                  "subSteps": [
                                    "Estude os componentes principais: linha de requisição (método + URI + versão HTTP), headers e body (opcional).",
                                    "Identifique métodos comuns: GET (sem body), POST (com body).",
                                    "Liste headers essenciais: Host, User-Agent, Content-Type, Content-Length.",
                                    "Analise exemplos de requisições em documentações como MDN ou RFC 9110.",
                                    "Diferencie requisição de resposta HTTP."
                                  ],
                                  "verification": "Escreva um diagrama ou lista dos 3 componentes principais com exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MDN Web Docs: HTTP Requests",
                                    "RFC 9110 - HTTP Semantics",
                                    "Editor de texto"
                                  ],
                                  "tips": "Sempre comece pela linha de requisição; ela define o método e destino.",
                                  "learningObjective": "Compreender os componentes fundamentais de uma requisição HTTP e suas funções.",
                                  "commonMistakes": [
                                    "Confundir headers com body",
                                    "Esquecer a versão HTTP/1.1",
                                    "Ignorar o header Host obrigatório"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir uma requisição GET simples manualmente",
                                  "subSteps": [
                                    "Escreva a linha de requisição: GET / HTTP/1.1",
                                    "Adicione header Host: example.com",
                                    "Inclua headers opcionais como User-Agent: curl/7.68.0",
                                    "Salve o conteúdo em um arquivo .http (ex: req_get.http).",
                                    "Visualize o arquivo para confirmar formatação (linhas vazias separam headers de body)."
                                  ],
                                  "verification": "Crie e valide o arquivo .http abrindo em um editor; deve ter linha de req + headers + linha vazia.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code, Notepad++)",
                                    "Documentação curl"
                                  ],
                                  "tips": "Use CRLF (\\r\\n) para quebras de linha em ambientes Windows; teste com ferramenta online como reqbin.com.",
                                  "learningObjective": "Montar manualmente uma requisição GET válida sem ferramentas.",
                                  "commonMistakes": [
                                    "Falta de linha vazia após headers",
                                    "URI absoluta em vez de relativa",
                                    "Headers sem dois pontos (:)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir uma requisição POST com body usando curl",
                                  "subSteps": [
                                    "Defina método POST e URI: POST /posts HTTP/1.1",
                                    "Adicione headers: Host, Content-Type: application/json, Content-Length.",
                                    "Crie body JSON: {\"title\":\"foo\",\"body\":\"bar\",\"userId\":1}",
                                    "Monte comando curl: curl -X POST -H \"Content-Type: application/json\" -d '{\"title\":\"foo\"}' https://jsonplaceholder.typicode.com/posts",
                                    "Execute e observe a resposta."
                                  ],
                                  "verification": "Execute o curl e confirme status 201 Created com resposta JSON.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal com curl instalado",
                                    "API de teste: jsonplaceholder.typicode.com",
                                    "JSON validator online"
                                  ],
                                  "tips": "Use -v para verbose mode no curl para ver req e resp completas.",
                                  "learningObjective": "Criar e enviar requisição POST com body JSON via curl.",
                                  "commonMistakes": [
                                    "Body sem Content-Length",
                                    "JSON malformado sem aspas duplas",
                                    "Método errado (usar GET com body)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e verificar a requisição",
                                  "subSteps": [
                                    "Envie a requisição com curl -v e analise headers enviados.",
                                    "Simule erros: remova Host, mude Content-Type, envie body inválido.",
                                    "Compare com Wireshark ou tcpdump para tráfego real (opcional).",
                                    "Registre diferenças entre manual e curl.",
                                    "Otimize: adicione Authorization header básico."
                                  ],
                                  "verification": "Corrija 3 erros intencionais e obtenha resposta 200/201.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "curl",
                                    "Postman ou ReqBin para comparação",
                                    "Wireshark (opcional)"
                                  ],
                                  "tips": "Sempre verifique logs de erro do servidor para depuração.",
                                  "learningObjective": "Depurar e validar requisições HTTP completas.",
                                  "commonMistakes": [
                                    "Ignorar case-sensitivity em headers",
                                    "Não escapar caracteres especiais no body",
                                    "Confundir status codes"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando curl, envie uma POST para https://jsonplaceholder.typicode.com/posts: curl -X POST -H 'Content-Type: application/json' -d '{\"title\":\"Meu Post\",\"body\":\"Conteúdo teste\",\"userId\":1}' https://jsonplaceholder.typicode.com/posts -v. Verifique resposta com id gerado e status 201.",
                              "finalVerifications": [
                                "Construa e envie manualmente uma GET para httpbin.org/get via netcat ou arquivo.",
                                "Envie POST com body JSON válido e receba 2xx status.",
                                "Identifique e corrija erro ao remover Content-Type.",
                                "Liste 5 headers obrigatórios/opcionais em uma req HTTP/1.1.",
                                "Compare req curl vs manual em ferramenta como httpie.",
                                "Simule autenticação básica com header Authorization."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta da linha de requisição (método, URI, versão).",
                                "Headers apropriados e completos (Host, Content-Type, Content-Length).",
                                "Body formatado corretamente para POST (JSON válido).",
                                "Execução bem-sucedida com resposta HTTP válida (2xx/201).",
                                "Capacidade de depuração de erros comuns (ex: 400 Bad Request).",
                                "Uso correto de ferramentas como curl com opções -v, -H, -d."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Integração com APIs REST em Python (requests) ou JavaScript (fetch).",
                                "Segurança da Informação: Uso de HTTPS, headers de segurança (CORS, CSP).",
                                "Redes de Computadores: Camada de aplicação sobre TCP/IP.",
                                "Matemática: Codificação de dados (Base64 em auth básica).",
                                "Desenvolvimento Web: Construção de frontends que consomem APIs."
                              ],
                              "realWorldApplication": "Desenvolver scripts de automação para testes de APIs, integrar serviços web em apps mobile/desktop, depurar integrações em microsserviços, ou criar ferramentas CLI para monitoramento de endpoints em DevOps."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1",
                              "10.1.3.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Estrutura de Resposta e Códigos de Status HTTP",
                        "description": "Componentes de resposta HTTP e principais códigos de status para comunicação servidor-cliente.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Descrever a estrutura de uma resposta HTTP",
                            "description": "Analisar status line (versão, código, reason phrase), headers (ex: Content-Length, Set-Cookie) e body em uma resposta exemplo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral de uma Resposta HTTP",
                                  "subSteps": [
                                    "Estudar o formato básico de uma resposta HTTP: Status Line, seguida por Headers (zero ou mais linhas), uma linha vazia (CRLF) e o Body (opcional)",
                                    "Identificar os separadores: CRLF (\\r\\n) no final de cada linha de header e uma linha vazia antes do body",
                                    "Comparar com estrutura de request HTTP para destacar diferenças (request tem method, response tem status code)",
                                    "Ler seção relevante do RFC 7230 sobre mensagens HTTP",
                                    "Esboçar um diagrama textual da estrutura"
                                  ],
                                  "verification": "Criar um diagrama simples da estrutura geral e rotulá-lo corretamente",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 7230 (Hypertext Transfer Protocol - Message Syntax)",
                                    "Ferramenta de diagramação como Draw.io ou papel e caneta",
                                    "Exemplo de resposta HTTP de documentação online"
                                  ],
                                  "tips": [
                                    "Use um editor de texto com visualização de caracteres invisíveis para ver CRLFs",
                                    "Lembre-se: respostas são sempre iniciadas pelo servidor"
                                  ],
                                  "learningObjective": "Identificar e descrever os três componentes principais de uma resposta HTTP e seus separadores",
                                  "commonMistakes": [
                                    "Confundir ordem: status line sempre primeiro",
                                    "Ignorar a linha vazia entre headers e body",
                                    "Achar que body é sempre presente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Status Line",
                                  "subSteps": [
                                    "Quebrar a status line em partes: versão HTTP (ex: HTTP/1.1), código de status numérico (ex: 200), reason phrase (ex: OK)",
                                    "Explicar o significado da versão (compatibilidade com cliente)",
                                    "Listar exemplos de códigos: 2xx (sucesso), 4xx (erro cliente), 5xx (erro servidor)",
                                    "Verificar sintaxe: espaço após versão, espaço após código",
                                    "Praticar parsing manual de 3 exemplos de status lines"
                                  ],
                                  "verification": "Parsear uma status line exemplo e identificar cada parte corretamente por escrito",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de códigos de status HTTP (MDN Web Docs)",
                                    "Exemplos de respostas HTTP de ferramentas como httpbin.org",
                                    "Editor de texto"
                                  ],
                                  "tips": [
                                    "Reason phrase é humana-legível, mas código é o que importa para lógica",
                                    "Versões: HTTP/1.1 comum, HTTP/2 binário (não texto)"
                                  ],
                                  "learningObjective": "Dissecar e explicar cada elemento da status line com exemplos",
                                  "commonMistakes": [
                                    "Trocar versão por método (é de request)",
                                    "Esquecer que reason phrase pode variar (ex: OK ou Okay)",
                                    "Usar códigos errados (ex: 200 como erro)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar os Headers da Resposta",
                                  "subSteps": [
                                    "Entender headers como pares nome:valor (ex: Content-Length: 123, Set-Cookie: session=abc)",
                                    "Classificar headers: gerais (Date, Server), entidade (Content-Type), resposta (Location)",
                                    "Analisar exemplos chave: Content-Length (tamanho body), Content-Type (MIME type), Set-Cookie (cookies)",
                                    "Identificar case-insensitivity dos nomes de headers",
                                    "Listar 5 headers comuns em respostas e seus propósitos"
                                  ],
                                  "verification": "Identificar e explicar 4 headers em uma resposta exemplo",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação MDN HTTP Headers",
                                    "Ferramenta como curl ou Postman para gerar respostas",
                                    "Lista de headers HTTP"
                                  ],
                                  "tips": [
                                    "Headers terminam com CRLF; último header seguido por linha vazia",
                                    "Use DevTools do browser para inspecionar headers reais"
                                  ],
                                  "learningObjective": "Classificar e descrever o papel de headers comuns em respostas HTTP",
                                  "commonMistakes": [
                                    "Confundir headers de request (ex: User-Agent) com response",
                                    "Esquecer vírgula em valores múltiplos",
                                    "Achar headers ordenados (não são)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar o Body e Análise Integrada",
                                  "subSteps": [
                                    "Definir body como payload opcional (ex: HTML, JSON, imagem)",
                                    "Relacionar com headers: Content-Length indica tamanho, Transfer-Encoding para chunked",
                                    "Analisar uma resposta completa: combinar status line, headers e body",
                                    "Praticar com ferramenta: capturar e dissecar uma resposta real",
                                    "Explicar quando body é vazio (ex: 204 No Content)"
                                  ],
                                  "verification": "Dissecar uma resposta HTTP completa em suas partes e reconstruí-la",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Browser DevTools (Network tab)",
                                    "curl comando: curl -v http://httpbin.org/get",
                                    "Editor de texto para colar resposta"
                                  ],
                                  "tips": [
                                    "Body só após linha vazia; sem ela, parsing falha",
                                    "Para binário (imagens), headers como Content-Type são cruciais"
                                  ],
                                  "learningObjective": "Integrar todos os componentes em uma análise completa de resposta HTTP",
                                  "commonMistakes": [
                                    "Ler body sem checar Content-Length (risco de overflow)",
                                    "Ignorar chunked encoding em HTTP/1.1",
                                    "Confundir body com headers"
                                  ]
                                }
                              ],
                              "practicalExample": "HTTP/1.1 200 OK\\r\\nContent-Type: text/html; charset=UTF-8\\r\\nContent-Length: 136\\r\\nSet-Cookie: sessionId=abc123; Path=/\\r\\nServer: Apache/2.4\\r\\n\\r\\n<!DOCTYPE html>\\r\\n<html><head><title>Hello</title></head><body><h1>Hello World!</h1></body></html>",
                              "finalVerifications": [
                                "Descrever verbalmente ou por escrito a estrutura de uma resposta HTTP exemplo",
                                "Identificar corretamente status line, 3 headers e conteúdo do body em uma resposta dada",
                                "Explicar o propósito de Content-Length e Content-Type",
                                "Reconstruir uma resposta HTTP simples a partir de componentes isolados",
                                "Diferenciar resposta de request HTTP",
                                "Listar 3 códigos de status e suas reason phrases"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de status line (versão, código, reason)",
                                "Completude na descrição de headers e exemplos relevantes",
                                "Correta relação entre headers e body (ex: tamanho, tipo)",
                                "Uso de terminologia técnica exata (CRLF, MIME type)",
                                "Capacidade de análise integrada de exemplo real",
                                "Ausência de confusões com requests HTTP"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Parsing em JavaScript (fetch API) ou Python (requests library)",
                                "Segurança da Informação: Análise de headers como CORS, Security headers",
                                "Desenvolvimento Web: Integração com HTML/CSS/JS via DevTools",
                                "Redes: Conexão TCP subjacente e Wireshark para captura",
                                "Banco de Dados: Headers como ETag para cache e versionamento"
                              ],
                              "realWorldApplication": "No desenvolvimento web, debug de APIs com ferramentas como Chrome DevTools ou Postman; análise de tráfego de rede com Wireshark para troubleshooting; implementação de servidores web (Node.js/Express) gerando respostas corretas; conformidade em testes de segurança (OWASP) verificando headers ausentes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Classificar códigos de status HTTP",
                            "description": "Memorizar e exemplificar famílias 1xx (informativo), 2xx (sucesso, ex: 200 OK), 3xx (redirecionamento, ex: 301), 4xx (erro cliente, ex: 404 Not Found), 5xx (erro servidor, ex: 500).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Famílias de Códigos de Status HTTP",
                                  "subSteps": [
                                    "Leia a definição oficial de cada família: 1xx (informativo), 2xx (sucesso), 3xx (redirecionamento), 4xx (erro do cliente), 5xx (erro do servidor).",
                                    "Anote o primeiro dígito e seu significado geral em uma tabela.",
                                    "Compare com exemplos iniciais: 100 Continue (1xx), 200 OK (2xx), 301 Moved Permanently (3xx), 404 Not Found (4xx), 500 Internal Server Error (5xx).",
                                    "Crie mnemônicos pessoais, como '2xx = tudo bem', '4xx = falha sua', '5xx = falha deles'.",
                                    "Revise a estrutura de um código HTTP: três dígitos, onde o primeiro indica a família."
                                  ],
                                  "verification": "Crie uma tabela resumindo as 5 famílias com um exemplo cada e defina corretamente sem consultar fontes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial HTTP/1.1 (RFC 7231)",
                                    "Papel e caneta ou editor de texto",
                                    "Navegador web para RFCs"
                                  ],
                                  "tips": "Associe o primeiro dígito a emoções: 2xx feliz, 4xx frustrado pelo usuário, 5xx servidor irritado.",
                                  "learningObjective": "Identificar o significado geral de cada família de códigos de status HTTP pelo primeiro dígito.",
                                  "commonMistakes": [
                                    "Confundir 3xx como sucesso em vez de redirecionamento.",
                                    "Ignorar 1xx como irrelevante.",
                                    "Misturar 4xx e 5xx achando que ambos são 'erros' genéricos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar Códigos Comuns em Cada Família",
                                  "subSteps": [
                                    "Liste 3-5 códigos chave por família: 1xx (100, 101); 2xx (200, 201, 204); 3xx (301, 302, 304); 4xx (400, 401, 403, 404, 429); 5xx (500, 502, 503, 504).",
                                    "Use flashcards: frente com código, verso com família e descrição.",
                                    "Repita em voz alta associando a cenários reais, como 404 para página não encontrada.",
                                    "Teste-se cobrindo a lista e reescrevendo de memória.",
                                    "Agrupe por similaridade, como redirecionamentos permanentes vs temporários em 3xx."
                                  ],
                                  "verification": "Acertar 90% em um quiz de 20 códigos aleatórios da lista memorizada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "App de flashcards como Anki",
                                    "Lista impressa de códigos HTTP comuns",
                                    "Timer para sessões de repetição espaçada"
                                  ],
                                  "tips": "Use repetição espaçada: revise após 1min, 10min, 1h para fixação longa.",
                                  "learningObjective": "Recordar pelo menos 15 códigos comuns e sua família correspondente.",
                                  "commonMistakes": [
                                    "Memorizar só o número sem contexto, como 200 sem saber que é sucesso.",
                                    "Confundir 401 Unauthorized com 403 Forbidden.",
                                    "Esquecer códigos de rate limiting como 429."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Exemplificar e Classificar Códigos em Cenários",
                                  "subSteps": [
                                    "Simule respostas HTTP em um editor de texto ou ferramenta online, escrevendo headers como 'HTTP/1.1 404 Not Found'.",
                                    "Para cada família, crie 2 exemplos: ex. 301 para mudança de URL permanente.",
                                    "Classifique 10 códigos misturados em uma tabela: código > família > descrição > exemplo.",
                                    "Analise logs reais de um site (use dev tools do browser).",
                                    "Explique diferenças sutis, como 301 vs 302 em redirecionamentos."
                                  ],
                                  "verification": "Classifique corretamente 10 códigos em cenários descritos, com explicação breve para cada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "DevTools do navegador (F12 > Network tab)",
                                    "Ferramenta online como httpstatus.io",
                                    "Editor de texto para simular respostas"
                                  ],
                                  "tips": "Acesse sites conhecidos e force erros (ex: URL inválida para 404) para ver na prática.",
                                  "learningObjective": "Aplicar classificação de códigos a exemplos concretos e cenários web reais.",
                                  "commonMistakes": [
                                    "Classificar 304 como erro em vez de 'Not Modified' (sucesso condicional).",
                                    "Ignorar contexto de cache em 3xx.",
                                    "Confundir 502 (bad gateway) com 500 (interno)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Classificação e Troubleshooting",
                                  "subSteps": [
                                    "Faça um quiz interativo com 25 códigos aleatórios misturados.",
                                    "Simule debugging: dado um erro como '503 Service Unavailable', classifique e sugira ações.",
                                    "Compare respostas HTTP reais de APIs públicas (ex: JSONPlaceholder).",
                                    "Crie fluxogramas para decisões baseadas em famílias (ex: 5xx > retry).",
                                    "Autoavalie e revise erros com explicações detalhadas."
                                  ],
                                  "verification": "Completar quiz com 95% de acerto e explicar 3 troubleshooting para códigos errados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quiz online como HTTP Cat ou custom em Quizlet",
                                    "Postman ou curl para testar APIs",
                                    "Logs de rede capturados"
                                  ],
                                  "tips": "Integre com ferramentas dev: filtre por status no Network tab para prática diária.",
                                  "learningObjective": "Classificar fluentemente códigos HTTP e associar a ações de resolução.",
                                  "commonMistakes": [
                                    "Tratar todos 5xx como 'servidor caiu' sem diferenciar.",
                                    "Não considerar idempotência em redirecionamentos.",
                                    "Subestimar 1xx em protocolos persistentes."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Postman, envie uma requisição GET para uma URL inexistente em jsonplaceholder.typicode.com/invalid. Receba '404 Not Found'. Classifique como 4xx (erro cliente), explique que o recurso não existe no servidor, e teste uma válida como /posts/1 para obter 200 OK (2xx sucesso).",
                              "finalVerifications": [
                                "Classificar corretamente todas as 5 famílias sem hesitação.",
                                "Listar 3 códigos exemplo por família com descrições precisas.",
                                "Explicar diferença entre 4xx e 5xx em um cenário de API falha.",
                                "Identificar e exemplificar um código 3xx de redirecionamento permanente.",
                                "Simular uma resposta 500 e propor passos de debug.",
                                "Acertar quiz de 20 códigos misturados em menos de 5 minutos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação: 95%+ acerto em códigos e famílias.",
                                "Profundidade de explicação: Incluir contexto e exemplo para cada código.",
                                "Velocidade de recall: Classificar 10 códigos em <2 minutos.",
                                "Aplicação prática: Demonstrar uso em dev tools ou API testing.",
                                "Compreensão de nuances: Diferenciar subtipos dentro de famílias (ex: 301 vs 302).",
                                "Criatividade em mnemônicos: Explicar método pessoal de memorização."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Implementar handlers para status em APIs REST (JavaScript/Node.js).",
                                "Segurança da Informação: Interpretar 401/403 em autenticação OAuth.",
                                "Redes de Computadores: Comportamento de proxies com 304 cache.",
                                "Desenvolvimento de Software: Logging e monitoring com ferramentas como ELK Stack.",
                                "Análise de Dados: Processar logs HTTP para métricas de erro (4xx/5xx rates)."
                              ],
                              "realWorldApplication": "Desenvolvedores web e DevOps usam classificação de códigos HTTP diariamente para debugar aplicações, monitorar performance (ex: alto rate de 5xx indica falha infraestrutura), otimizar caches via 3xx, e melhorar UX lidando com 4xx em frontend com mensagens amigáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Interpretar headers de resposta comuns",
                            "description": "Explicar headers como Location (redirecionamento), Cache-Control, Server e ETag para controle de cache e segurança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura e Propósito Geral dos Headers de Resposta HTTP",
                                  "subSteps": [
                                    "Estudar a definição de headers HTTP como metadados na resposta do servidor.",
                                    "Identificar a posição dos headers após a linha de status na resposta HTTP.",
                                    "Revisar exemplos de headers comuns e seu formato chave:valor.",
                                    "Diferenciar headers de request dos de response.",
                                    "Explorar ferramentas para visualizar headers reais."
                                  ],
                                  "verification": "Descrever corretamente a estrutura de uma resposta HTTP e listar onde os headers aparecem, com um exemplo capturado de DevTools.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 7231 (HTTP/1.1 Semantics)",
                                    "Browser Developer Tools (Chrome/Firefox)",
                                    "Ferramenta curl"
                                  ],
                                  "tips": "Ative sempre o modo Network nas DevTools para capturar tráfego HTTP ao recarregar uma página.",
                                  "learningObjective": "Dominar o conceito e localização dos headers de resposta para contextualizar os específicos.",
                                  "commonMistakes": [
                                    "Confundir headers de requisição com resposta.",
                                    "Ignorar que headers são case-insensitive."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o Header Location para Redirecionamentos",
                                  "subSteps": [
                                    "Explicar o propósito do Location: URL para onde redirecionar o cliente.",
                                    "Analisar cenários de uso com status 3xx (ex: 301, 302).",
                                    "Identificar em respostas reais usando DevTools ou curl.",
                                    "Testar um redirecionamento prático e verificar o header.",
                                    "Discutir implicações para navegação e SEO."
                                  ],
                                  "verification": "Interpretar uma resposta com Location: https://example.com/new e explicar o redirecionamento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "curl comando: curl -I -L https://httpbin.org/redirect/1",
                                    "Browser DevTools"
                                  ],
                                  "tips": "Use -L no curl para seguir redirecionamentos e ver múltiplos Locations.",
                                  "learningObjective": "Saber identificar e explicar redirecionamentos via Location.",
                                  "commonMistakes": [
                                    "Assumir que Location só aparece em 200 OK.",
                                    "Não validar a URL absoluta no header."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Headers de Cache: Cache-Control e ETag",
                                  "subSteps": [
                                    "Estudar Cache-Control: diretivas como max-age, no-cache, public/private.",
                                    "Explicar ETag: identificador único para validação de cache.",
                                    "Comparar como funcionam juntos para controle eficiente de cache.",
                                    "Capturar exemplos em sites reais (ex: CDN).",
                                    "Simular If-None-Match em requests condicionais."
                                  ],
                                  "verification": "Explicar Cache-Control: max-age=3600, must-revalidate e como ETag \"abc123\" valida cache.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs - HTTP Caching",
                                    "curl -I https://httpbin.org/cache",
                                    "Postman para requests condicionais"
                                  ],
                                  "tips": "Teste cache desabilitando no browser para forçar headers frescos.",
                                  "learningObjective": "Compreender mecanismos de cache para otimização de performance.",
                                  "commonMistakes": [
                                    "Confundir max-age com expires.",
                                    "Ignorar ETag em caches condicionais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o Header Server e Implicações de Segurança",
                                  "subSteps": [
                                    "Descrever Server: identifica software servidor (ex: Apache/2.4).",
                                    "Discutir riscos de fingerprinting e ataques direcionados.",
                                    "Verificar em respostas reais e comparar com headers ocultos.",
                                    "Explorar boas práticas: remover ou ofuscar Server.",
                                    "Analisar impacto em segurança (ex: versão vulnerável exposta)."
                                  ],
                                  "verification": "Analisar Server: nginx/1.18.0 e listar 3 riscos de segurança associados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "curl -I https://httpbin.org/headers",
                                    "OWASP Cheat Sheet - HTTP Headers"
                                  ],
                                  "tips": "Use headers como X-Powered-By para exemplos semelhantes de exposição.",
                                  "learningObjective": "Reconhecer Server para avaliações de segurança.",
                                  "commonMistakes": [
                                    "Achar Server inofensivo.",
                                    "Não considerar fingerprinting."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Interpretação Integrada de Headers em Respostas Completas",
                                  "subSteps": [
                                    "Capturar uma resposta HTTP completa com todos os headers alvo.",
                                    "Interpretar interações: Location com cache, Server com ETag.",
                                    "Criar um relatório resumindo cada header encontrado.",
                                    "Simular cenários de erro (ex: cache inválido).",
                                    "Debugar uma resposta problemática."
                                  ],
                                  "verification": "Fornecer uma resposta HTTP sample e explicar todos os 4 headers com implicações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "curl -v https://example.com",
                                    "Wireshark (opcional)",
                                    "httpbin.org para testes"
                                  ],
                                  "tips": "Combine curl com grep para filtrar headers: curl -I | grep -i location.",
                                  "learningObjective": "Aplicar conhecimento integrado para análise real.",
                                  "commonMistakes": [
                                    "Interpretar headers isoladamente sem contexto.",
                                    "Omitir verificações de segurança."
                                  ]
                                }
                              ],
                              "practicalExample": "Execute `curl -I https://httpbin.org/get` e analise: Location (se redirecionado), Cache-Control: no-cache, Server: nginx, ETag: \\\"abc123\\\". Explique como Cache-Control impede cache indevido e Server revela stack tecnológico, impactando segurança.",
                              "finalVerifications": [
                                "Explicar Location em contexto de 302 Found.",
                                "Interpretar Cache-Control: private, max-age=0.",
                                "Descrever uso de ETag em validação condicional.",
                                "Identificar riscos do Server: Apache/2.2.15.",
                                "Analisar uma resposta completa com todos os headers.",
                                "Diferenciar cache público vs privado."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas definições (100% correto).",
                                "Exemplos práticos e relevantes fornecidos.",
                                "Cobertura completa dos 4 headers e interações.",
                                "Identificação correta de implicações de segurança e cache.",
                                "Uso apropriado de terminologia HTTP.",
                                "Capacidade de debugar headers em cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Fingerprinting via Server (SC-12).",
                                "Desenvolvimento Web: Otimização de APIs com ETag/Cache-Control.",
                                "Redes de Computadores: Protocolos de camada aplicação (HTTP).",
                                "Administração de Sistemas: Configuração de servidores web."
                              ],
                              "realWorldApplication": "Em desenvolvimento full-stack, interpretar esses headers otimiza performance via cache (ETag/Cache-Control), gerencia fluxos de login (Location), e mitiga ataques reconnaissance (Server), essencial para DevOps, debugging de APIs e auditorias de segurança em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.4",
                            "name": "Simular fluxo request-response HTTP",
                            "description": "Usar ferramentas como Wireshark ou browser devtools para capturar e analisar um ciclo completo de requisição-resposta HTTP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e ferramentas de captura",
                                  "subSteps": [
                                    "Instale ou abra as DevTools do navegador (Chrome ou Firefox: F12).",
                                    "Navegue até a aba 'Network' ou 'Rede'.",
                                    "Opcionalmente, instale e configure o Wireshark para captura em interface de rede.",
                                    "Limpe o histórico de rede para iniciar captura limpa.",
                                    "Habilite filtros para HTTP/HTTPS se necessário."
                                  ],
                                  "verification": "Verifique se a aba Network está visível e vazia, pronta para capturar tráfego.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Navegador web (Chrome/Firefox), Wireshark (opcional), computador com internet",
                                  "tips": "Use modo incógnito para evitar interferência de cache ou extensões.",
                                  "learningObjective": "Preparar ferramentas para capturar tráfego HTTP de forma eficiente.",
                                  "commonMistakes": "Esquecer de limpar o histórico, causando confusão com requisições antigas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar e capturar uma requisição HTTP",
                                  "subSteps": [
                                    "Digite um URL simples como 'http://httpbin.org/get' na barra de endereço.",
                                    "Pressione Enter para enviar a requisição GET.",
                                    "Observe a captura automática na aba Network.",
                                    "Registre o tempo de início e identifique a primeira linha da requisição.",
                                    "Pause ou pare a captura após a resposta carregar."
                                  ],
                                  "verification": "Confirme que pelo menos uma entrada de requisição aparece na lista Network com status '200' ou similar.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Navegador configurado, site de teste como httpbin.org",
                                  "tips": "Use sites de teste como httpbin.org para respostas previsíveis e seguras.",
                                  "learningObjective": "Executar uma requisição real e capturá-la integralmente.",
                                  "commonMistakes": "Usar HTTPS por engano; force HTTP para simplicidade inicial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a estrutura da requisição HTTP",
                                  "subSteps": [
                                    "Clique na requisição capturada e examine os 'Headers' da Request.",
                                    "Identifique método (GET), URL, versão HTTP (1.1).",
                                    "Liste headers como Host, User-Agent, Accept.",
                                    "Verifique query parameters se presentes.",
                                    "Anote o tamanho da requisição e timestamp."
                                  ],
                                  "verification": "Documente em um bloco de notas: método, headers principais e URL completa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Captura na aba Network, bloco de notas ou editor de texto",
                                  "tips": "Expanda seções colapsadas nos headers para ver todos os detalhes.",
                                  "learningObjective": "Dissecar componentes de uma requisição HTTP.",
                                  "commonMistakes": "Confundir headers de request com response."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a resposta HTTP e o ciclo completo",
                                  "subSteps": [
                                    "Examine os 'Headers' da Response: status code (ex: 200 OK), Content-Type.",
                                    "Analise o corpo da resposta (Response tab).",
                                    "Compare request e response para identificar o fluxo bidirecional.",
                                    "Verifique códigos de status e headers como Content-Length, Server.",
                                    "Simule um erro recarregando uma página inexistente (404)."
                                  ],
                                  "verification": "Crie um diagrama simples do fluxo: Request → Response, com pelo menos 3 headers cada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Captura anterior, ferramenta de desenho simples (Draw.io ou papel)",
                                  "tips": "Procure por redirects (301/302) para entender fluxos múltiplos.",
                                  "learningObjective": "Compreender o ciclo completo request-response e variações.",
                                  "commonMistakes": "Ignorar o corpo da resposta ou status codes não-200."
                                }
                              ],
                              "practicalExample": "Abra as DevTools no Chrome (F12), vá para Network, digite 'http://httpbin.org/get', pressione Enter. Clique na requisição: veja GET /get HTTP/1.1 na request, e na response: HTTP/1.1 200 OK com JSON ecoando seus headers.",
                              "finalVerifications": [
                                "Identificar corretamente método HTTP, URL e versão na request.",
                                "Listar pelo menos 5 headers da request e 5 da response.",
                                "Explicar o status code e seu significado.",
                                "Desenhar o fluxo bidirecional com timestamps.",
                                "Simular e capturar um erro HTTP (ex: 404).",
                                "Comparar captura com Wireshark vs DevTools."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes HTTP (90% correto).",
                                "Profundidade da análise de headers e body.",
                                "Capacidade de simular cenários variados (sucesso/erro).",
                                "Clareza no diagrama do fluxo request-response.",
                                "Uso correto de ferramentas sem erros de configuração.",
                                "Explicação verbal ou escrita do ciclo completo."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Implementar requests com fetch() ou Axios baseados na análise.",
                                "Segurança da Informação: Diferenciar HTTP vs HTTPS e capturar certificados.",
                                "Desenvolvimento de Software: Debug de APIs em aplicações full-stack.",
                                "Matemática: Calcular latência e throughput do tráfego capturado."
                              ],
                              "realWorldApplication": "Em desenvolvimento web para debugar falhas em APIs (ex: identificar headers CORS ausentes); em administração de redes para monitorar tráfego suspeito ou otimizar performance de sites; em cibersegurança para analisar ataques como injection via requests maliciosas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.3",
                              "10.1.3.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Protocolo FTP (File Transfer Protocol)",
                    "description": "Protocolo para upload e download de arquivos entre clientes e servidores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Arquitetura do Protocolo FTP",
                        "description": "O FTP é baseado em uma arquitetura cliente-servidor que utiliza duas conexões TCP separadas: a conexão de controle (porta 21) para comandos e respostas, e a conexão de dados (porta negociada) para transferência de arquivos, garantindo separação entre controle e transferência de dados.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Identificar as conexões de controle e dados no FTP",
                            "description": "Explicar a função da conexão de controle na porta TCP 21 para autenticação, comandos como USER, PASS e negociação de portas, e da conexão de dados para upload/download de arquivos, destacando como o TCP garante confiabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a arquitetura básica do protocolo FTP",
                                  "subSteps": [
                                    "Pesquisar a definição e propósito do FTP como protocolo de camada de aplicação para transferência de arquivos.",
                                    "Identificar que o FTP utiliza duas conexões principais: controle e dados.",
                                    "Ler sobre o modelo cliente-servidor no FTP.",
                                    "Visualizar um diagrama simples da arquitetura FTP.",
                                    "Anotar as portas padrão envolvidas (21 para controle)."
                                  ],
                                  "verification": "Criar um diagrama esquemático das duas conexões e suas funções principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação RFC 959 do FTP",
                                    "Diagramaas online de arquitetura FTP",
                                    "Editor de imagens simples como Draw.io"
                                  ],
                                  "tips": [
                                    "Comece pelo geral para o específico; use diagramas para fixar conceitos visuais."
                                  ],
                                  "learningObjective": "Reconhecer a estrutura de duas conexões separadas no FTP e seu propósito.",
                                  "commonMistakes": [
                                    "Confundir FTP com protocolos HTTP ou SFTP",
                                    "Achar que usa uma única conexão",
                                    "Ignorar o modelo cliente-servidor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a conexão de controle (porta TCP 21)",
                                  "subSteps": [
                                    "Explicar o papel da conexão de controle: autenticação e comandos.",
                                    "Estudar comandos principais: USER, PASS, PORT, PASV, LIST, RETR.",
                                    "Simular o fluxo: cliente conecta na porta 21, envia USER/PASS para login.",
                                    "Entender a negociação de portas para dados via comandos como PORT ou PASV.",
                                    "Verificar como a conexão permanece aberta durante a sessão."
                                  ],
                                  "verification": "Listar 5 comandos de controle e descrever o fluxo de autenticação em uma sequência numerada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de simulação como Wireshark (modo demo)",
                                    "Lista de comandos FTP da RFC 959",
                                    "Cliente FTP como FileZilla para logs"
                                  ],
                                  "tips": [
                                    "Registre logs de uma conexão real para ver comandos em ação; foque na persistência da conexão."
                                  ],
                                  "learningObjective": "Descrever com precisão a função, porta e comandos da conexão de controle.",
                                  "commonMistakes": [
                                    "Pensar que autenticação ocorre na conexão de dados",
                                    "Confundir PORT (ativa) com PASV (passiva)",
                                    "Subestimar riscos de segurança em USER/PASS"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a conexão de dados para transferência de arquivos",
                                  "subSteps": [
                                    "Diferenciar a conexão de dados da controle: dedicada a upload/download.",
                                    "Estudar modos: ativo (servidor inicia) vs passivo (cliente inicia).",
                                    "Simular transferência: após comando LIST ou RETR, abre conexão em porta negociada (20 ou dinâmica).",
                                    "Explicar como TCP garante confiabilidade (ACKs, retransmissões).",
                                    "Comparar tamanhos de dados e tipos suportados (ASCII/binário)."
                                  ],
                                  "verification": "Desenhar o fluxo de uma transferência de arquivo, indicando portas origem/destino.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Cliente FTP como WinSCP",
                                    "Servidor FTP local (ex: FileZilla Server)",
                                    "Captura de tráfego com Wireshark"
                                  ],
                                  "tips": [
                                    "Teste modos ativo/passivo em firewall para ver diferenças; sempre especifique modo binário para arquivos."
                                  ],
                                  "learningObjective": "Identificar origens, portas e mecanismos de confiabilidade da conexão de dados.",
                                  "commonMistakes": [
                                    "Achar que dados fluem pela porta 21",
                                    "Ignorar negociação prévia de portas",
                                    "Confundir com UDP (FTP é TCP puro)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar conexões e verificar compreensão",
                                  "subSteps": [
                                    "Mapear interação: controle negocia, dados transfere, controle gerencia erros.",
                                    "Analisar diagrama completo de sessão FTP.",
                                    "Simular erro: falha em autenticação bloqueia dados.",
                                    "Discutir por que separação melhora eficiência e escalabilidade.",
                                    "Testar em ferramenta real e anotar observações."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito uma sessão FTP completa, do login ao download.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "FileZilla Client e Server",
                                    "Vídeos tutoriais de FTP",
                                    "Folha de anotações"
                                  ],
                                  "tips": [
                                    "Use firewalls para forçar modo passivo e observar; revise RFC para precisão."
                                  ],
                                  "learningObjective": "Sintetizar como controle e dados interagem sob TCP para transferências confiáveis.",
                                  "commonMistakes": [
                                    "Isolar conexões sem ver dependência",
                                    "Esquecer fechamento de conexões de dados",
                                    "Não relacionar com camadas TCP/IP"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao usar o FileZilla para conectar a um servidor FTP (ex: ftp.example.com:21), observe no log: primeiro, conexão TCP na porta 21 com comandos USER 'seuuser', PASS 'suasenha', PASV (negociação passiva porta 50000); em seguida, conexão de dados na porta 50000 para comando LIST, listando arquivos com ACKs TCP garantindo entrega.",
                              "finalVerifications": [
                                "Diagramar corretamente as portas 21 (controle) e dinâmica (dados).",
                                "Listar e explicar comandos USER, PASS e PASV/PORT.",
                                "Descrever fluxo de uma transferência de arquivo (RETR).",
                                "Explicar como TCP assegura confiabilidade nas duas conexões.",
                                "Diferenciar modos ativo e passivo com exemplos.",
                                "Identificar por que controle permanece aberta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de portas e funções (controle: comandos/autenticação; dados: transferência).",
                                "Correta descrição de negociação de portas (PORT/PASV).",
                                "Compreensão da confiabilidade TCP (sequenciamento, ACKs).",
                                "Capacidade de diagramar interações cliente-servidor.",
                                "Uso correto de terminologia (ex: conexão persistente de controle).",
                                "Identificação de erros comuns em cenários reais (firewalls)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Vulnerabilidades em autenticação plaintext (leva a FTPS/SFTP).",
                                "Programação: Implementação de sockets TCP para cliente FTP em Python (biblioteca ftplib).",
                                "Redes de Computadores: Camadas TCP/IP (aplicação sobre transporte).",
                                "Sistemas Operacionais: Gerenciamento de portas efêmeras e NAT.",
                                "Matemática: Modelagem de fluxos de dados como grafos direcionados."
                              ],
                              "realWorldApplication": "Em hospedagem web, upload de sites via FTP (controle para comandos, dados para arquivos); backups automatizados em data centers; transferência de logs em IoT; migração de arquivos em empresas, sempre com TCP para evitar perdas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Descrever o estabelecimento de uma sessão FTP",
                            "description": "Detalhar o fluxo inicial de uma sessão FTP: conexão TCP na porta 21, autenticação com USER e PASS, comando PORT ou PASV para negociação de dados, e fechamento com QUIT, incluindo exemplos de respostas numéricas como 220, 331 e 230.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer a Conexão de Controle TCP na Porta 21",
                                  "subSteps": [
                                    "Abra um cliente de terminal ou ferramenta como telnet/netcat para conectar ao servidor FTP na porta 21.",
                                    "Inicie a conexão TCP usando o comando 'telnet ftp.example.com 21' ou equivalente.",
                                    "Aguarde e interprete a mensagem de saudação do servidor, que começa com o código 220 (ex: '220 Welcome to FTP Service').",
                                    "Registre o banner do servidor para fins de identificação e segurança.",
                                    "Confirme que a conexão está ativa verificando o prompt de comando do servidor."
                                  ],
                                  "verification": "Verifique se recebeu o código de resposta 220 no terminal, indicando conexão bem-sucedida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Cliente telnet ou netcat",
                                    "Servidor FTP acessível (ex: ftp.example.com)",
                                    "Documentação RFC 959"
                                  ],
                                  "tips": "Use verbose mode no telnet para ver todos os detalhes da conexão; evite portas não padrão inicialmente.",
                                  "learningObjective": "Compreender o handshake inicial TCP e o papel da porta 21 no protocolo FTP de controle.",
                                  "commonMistakes": [
                                    "Conectar na porta errada (ex: 20 em vez de 21)",
                                    "Ignorar firewalls bloqueando a porta",
                                    "Não registrar o código 220"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Autenticação com Comandos USER e PASS",
                                  "subSteps": [
                                    "Envie o comando 'USER username' e aguarde resposta 331 (ex: '331 Please specify the password').",
                                    "Envie o comando 'PASS password' imediatamente após, recebendo 230 (ex: '230 User logged in').",
                                    "Trate erros comuns como 530 (Login incorrect) para depuração.",
                                    "Anote as diferenças entre autenticação anônima (USER anonymous) e autenticada.",
                                    "Confirme login listando diretórios com 'PWD' ou 'LIST' para validar acesso."
                                  ],
                                  "verification": "Sucesso indicado por código 230 e capacidade de executar comandos pós-login como 'PWD'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cliente FTP ou telnet",
                                    "Credenciais de teste de um servidor FTP público",
                                    "Lista de códigos de erro FTP"
                                  ],
                                  "tips": "Sempre teste com conta anônima primeiro; mascare senhas em logs para segurança.",
                                  "learningObjective": "Dominar o fluxo de autenticação FTP e interpretar respostas 331/230/530.",
                                  "commonMistakes": [
                                    "Enviar PASS antes de USER",
                                    "Expor senhas em claro em ambientes não seguros",
                                    "Confundir ordem dos comandos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Negociar o Canal de Dados com PORT ou PASV",
                                  "subSteps": [
                                    "Escolha modo ativo: Envie 'PORT a1,a2,a3,a4,p1,p2' para especificar endereço/IP e porta do cliente.",
                                    "Ou modo passivo: Envie 'PASV' e parse resposta 227 '(h1,h2,h3,h4,p1,p2)' para conectar ao servidor.",
                                    "Inicie uma transferência de teste como 'LIST' ou 'RETR file.txt' para validar o canal.",
                                    "Compare diferenças entre PORT (ativo, cliente abre porta) e PASV (passivo, servidor abre).",
                                    "Registre códigos 200 (PORT ok) ou 227 (PASV ok) para confirmação."
                                  ],
                                  "verification": "Canal de dados funcional comprovado por listagem de arquivos via 'LIST' sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark para capturar tráfego",
                                    "Servidor FTP suportando ambos modos",
                                    "Calculadora para converter portas em IP/porta"
                                  ],
                                  "tips": "Prefira PASV em redes com NAT/firewalls; use Wireshark para visualizar canais separados.",
                                  "learningObjective": "Explicar e implementar negociação de dados ativa/passiva no FTP.",
                                  "commonMistakes": [
                                    "Erro de parsing em PASV (ignorar parênteses)",
                                    "Usar PORT em redes NAT sem configuração",
                                    "Confundir canais de controle e dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Encerrar a Sessão com QUIT",
                                  "subSteps": [
                                    "Após operações, envie 'QUIT' para sinalizar fechamento graceful.",
                                    "Interprete resposta 221 (ex: '221 Goodbye') confirmando encerramento.",
                                    "Feche o socket TCP manualmente se usando cliente customizado.",
                                    "Verifique logs do servidor para confirmação de logout limpo.",
                                    "Compare com ABOR (abortar) para cenários de emergência."
                                  ],
                                  "verification": "Recepção do código 221 e desconexão sem erros pendentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Cliente telnet",
                                    "Logs de sessão anterior"
                                  ],
                                  "tips": "Sempre use QUIT em vez de Ctrl+C para evitar sessões órfãs no servidor.",
                                  "learningObjective": "Entender o fechamento limpo de sessões FTP e código 221.",
                                  "commonMistakes": [
                                    "Fechar conexão abruptamente sem QUIT",
                                    "Ignorar resposta 221",
                                    "Deixar sessões abertas indefinidamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo de sessão FTP via telnet ftp.example.com 21:\n220 Welcome...\nUSER anonymous\n331 Guest login...\nPASS guest@\n230 Guest login...\nPASV\n227 Entering Passive Mode (192,168,1,1,14,8)\nLIST\n150 Opening data...\n226 Transfer complete.\nQUIT\n221 Goodbye.",
                              "finalVerifications": [
                                "Liste corretamente a sequência: Conexão(220) → USER(331) → PASS(230) → PORT/PASV → QUIT(221).",
                                "Explique diferença entre canais de controle (porta 21) e dados (PORT/PASV).",
                                "Identifique 3 códigos de erro comuns (ex: 530, 425, 421).",
                                "Simule uma sessão completa em telnet sem erros.",
                                "Capture tráfego com Wireshark mostrando canais separados.",
                                "Descreva por que PASV é preferido em firewalls modernos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na ordem e códigos de resposta dos comandos (90% correto).",
                                "Inclusão de exemplos numéricos (220,331,230,227,221) em descrições.",
                                "Explicação clara de modos ativo/passivo com prós/contras.",
                                "Demonstração prática via simulação ou Wireshark.",
                                "Identificação de pelo menos 2 erros comuns e prevenções.",
                                "Conexão com RFC 959 para referências autênticas."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Vulnerabilidades de autenticação em claro e migração para FTPS/SFTP.",
                                "Programação de Redes: Implementação de cliente FTP em Python (socket library).",
                                "Matemática Discreta: Parsing de endereços IP/porta em formato comma-separated.",
                                "História da Computação: Evolução de protocolos de transferência de arquivos (FTP vs. HTTP).",
                                "Administração de Sistemas: Configuração de servidores FTP em Linux (vsftpd)."
                              ],
                              "realWorldApplication": "Configurar scripts de automação para backups noturnos de sites web via FTP, upload de arquivos para hosting compartilhado, ou migração de dados entre servidores legados em ambientes empresariais onde FTP ainda é usado por compatibilidade."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Comparar FTP com outros protocolos de aplicação",
                            "description": "Analisar como o FTP se diferencia de HTTP ou SMTP no modelo TCP/IP, enfatizando sua orientação para transferência binária/ASCII e uso de múltiplas conexões, com referência ao nível de aplicação no modelo TCP/IP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Modelo TCP/IP e o Nível de Aplicação",
                                  "subSteps": [
                                    "Estude a estrutura em camadas do modelo TCP/IP (Aplicação, Transporte, Rede, Enlace).",
                                    "Identifique protocolos no nível de Aplicação: FTP, HTTP, SMTP, DNS, etc.",
                                    "Anote as responsabilidades gerais do nível de Aplicação (interface usuário-processo, formatos de dados).",
                                    "Desenhe um diagrama simples do modelo TCP/IP destacando o nível de Aplicação.",
                                    "Compare brevemente com o modelo OSI para contextualizar."
                                  ],
                                  "verification": "Diagrama completo do modelo TCP/IP com protocolos de aplicação listados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama em branco ou ferramenta como Draw.io",
                                    "Documentação RFC do TCP/IP ou Khan Academy vídeo sobre camadas de rede"
                                  ],
                                  "tips": "Use cores diferentes para cada camada para visualização melhor.",
                                  "learningObjective": "Compreender a posição e função do nível de Aplicação no modelo TCP/IP.",
                                  "commonMistakes": [
                                    "Confundir TCP/IP com OSI (TCP/IP tem 4 camadas principais)",
                                    "Ignorar que protocolos de aplicação dependem de camadas inferiores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Características Detalhadas do FTP",
                                  "subSteps": [
                                    "Descreva o propósito do FTP: transferência de arquivos entre cliente e servidor.",
                                    "Explique modos de transferência: binário (preserva bytes exatos) vs. ASCII (conversão de texto).",
                                    "Detalhe arquitetura: conexão de controle (porta 21) e conexão de dados (porta 20 ou passiva).",
                                    "Liste comandos comuns: USER, PASS, RETR, STOR, LIST.",
                                    "Note stateless nature e uso de múltiplas conexões TCP."
                                  ],
                                  "verification": "Lista de 5 características chave do FTP com exemplos de comandos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 959 (FTP specification)",
                                    "Ferramenta de terminal como ftp command line"
                                  ],
                                  "tips": "Teste um comando FTP local para ver conexões em ação com netstat.",
                                  "learningObjective": "Dominar as peculiaridades do FTP no nível de aplicação.",
                                  "commonMistakes": [
                                    "Confundir modo binário com texto (binário para imagens/executáveis)",
                                    "Esquecer múltiplas conexões (controle + dados)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Características do HTTP",
                                  "subSteps": [
                                    "Descreva o HTTP: protocolo para transferência de hipertexto/web.",
                                    "Explique stateless e request-response (métodos GET, POST, etc.).",
                                    "Detalhe uso de uma única conexão TCP por transação (HTTP/1.1 persistente).",
                                    "Compare formato: headers texto + body (HTML, JSON, etc.).",
                                    "Mencione HTTPS como extensão segura."
                                  ],
                                  "verification": "Tabela comparativa inicial FTP vs. HTTP com 4 diferenças.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 2616 (HTTP/1.1)",
                                    "Browser dev tools (F12) para inspecionar requests"
                                  ],
                                  "tips": "Abra dev tools e recarregue uma página para ver headers HTTP.",
                                  "learningObjective": "Entender o foco do HTTP em conteúdo web request-response.",
                                  "commonMistakes": [
                                    "Pensar HTTP como bidirecional como FTP",
                                    "Ignorar stateless (cada request independente)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Características do SMTP",
                                  "subSteps": [
                                    "Descreva SMTP: Simple Mail Transfer Protocol para envio de emails.",
                                    "Explique fluxo: cliente-servidor, comandos como HELO, MAIL FROM, RCPT TO, DATA.",
                                    "Note texto puro ASCII, uma conexão TCP por sessão de email.",
                                    "Detalhe relay entre MTAs (Mail Transfer Agents).",
                                    "Compare com POP/IMAP (recebimento)."
                                  ],
                                  "verification": "Diagrama de fluxo SMTP com comandos principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 5321 (SMTP)",
                                    "Telnet para simular SMTP em servidor de teste"
                                  ],
                                  "tips": "Use telnet localhost 25 para testar comandos SMTP básicos.",
                                  "learningObjective": "Compreender o SMTP como protocolo de push de mensagens texto.",
                                  "commonMistakes": [
                                    "Confundir SMTP com POP/IMAP (SMTP é envio)",
                                    "Esquecer que é texto-only sem binário nativo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e Contrastar FTP, HTTP e SMTP",
                                  "subSteps": [
                                    "Crie tabela: colunas para protocolo, tipo de dados (binário/ASCII), conexões, propósito, comandos.",
                                    "Destaque FTP: binário/ASCII, múltiplas conexões, arquivos genéricos.",
                                    "Contraste HTTP: texto/HTML, request-response única conexão, web.",
                                    "Contraste SMTP: ASCII texto, sessão única, email push.",
                                    "Discuta implicações de segurança e eficiência no TCP/IP."
                                  ],
                                  "verification": "Tabela de comparação completa com pelo menos 6 diferenças chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Diagramas de rede Wireshark para captura opcional"
                                  ],
                                  "tips": "Use Wireshark para capturar tráfego real e validar diferenças.",
                                  "learningObjective": "Sintetizar diferenças e semelhanças entre os protocolos.",
                                  "commonMistakes": [
                                    "Generalizar todos como 'transferência de dados' sem nuances",
                                    "Ignorar dependência no TCP para confiabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture tráfego de uma sessão FTP (upload binário), um GET HTTP e um envio SMTP. Compare os pacotes: note portas, múltiplas streams no FTP, headers no HTTP e envelope no SMTP.",
                              "finalVerifications": [
                                "Pode listar 5 diferenças chave entre FTP, HTTP e SMTP.",
                                "Explica corretamente modos binário/ASCII do FTP vs. texto dos outros.",
                                "Desenha arquitetura de conexões para cada protocolo.",
                                "Identifica propósitos distintos no contexto TCP/IP.",
                                "Discute por que FTP usa múltiplas conexões e outros não.",
                                "Compara segurança inerente (nenhum tem criptografia nativa)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas descrições de cada protocolo (90% correto).",
                                "Profundidade na comparação (cobertura de dados, conexões, comandos).",
                                "Uso correto de terminologia TCP/IP e RFCs.",
                                "Clareza em tabelas/diagramas visuais.",
                                "Evidência de verificação prática (ex: screenshots Wireshark).",
                                "Análise de implicações reais (ex: por que FTP é obsoleto para web)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em estados de conexão (ativo/passivo).",
                                "História: Evolução de protocolos (FTP 1971 vs. HTTP 1990s).",
                                "Segurança da Informação: Vulnerabilidades como clear-text em FTP/SMTP.",
                                "Linguagens: Parsing de comandos texto em programação de rede.",
                                "Ética: Privacidade em protocolos não-criptografados."
                              ],
                              "realWorldApplication": "Em administração de sistemas, escolher FTP para backups binários em legacy systems, HTTP para APIs web, SMTP para automação de emails em DevOps; análise ajuda em troubleshooting de falhas de rede ou migrações para SFTP/HTTPS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Modos de Transferência de Dados",
                        "description": "O FTP suporta modos ativo e passivo para lidar com firewalls e NAT, onde o modo ativo inicia a conexão de dados do servidor para o cliente, e o passivo do cliente para o servidor, adaptando-se a cenários de rede modernos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Explicar o modo ativo de transferência FTP",
                            "description": "Descrever o processo no modo ativo: cliente envia PORT com IP e porta, servidor conecta de volta na porta 20 para dados; discutir problemas com firewalls que bloqueiam conexões inbound e exemplos de comandos como PORT 192,168,1,1,100,200.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Conexão de Controle FTP e Introdução ao Modo Ativo",
                                  "subSteps": [
                                    "Estude a RFC 959 para compreender o protocolo FTP básico.",
                                    "Identifique que a conexão de controle é iniciada pelo cliente na porta 21 TCP do servidor.",
                                    "Diferencie o modo ativo (servidor inicia conexão de dados) do passivo (cliente inicia).",
                                    "Visualize o diagrama de fluxo: cliente -> servidor:21 (controle).",
                                    "Anote as portas padrão: 21 controle, 20 dados no servidor."
                                  ],
                                  "verification": "Desenhe um diagrama simples da conexão de controle e explique verbalmente a diferença entre modos ativo e passivo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "RFC 959 (disponível online)",
                                    "Diagrama de rede básico (papel ou ferramenta como draw.io)"
                                  ],
                                  "tips": "Sempre comece pelo controle antes de dados; memorize 'ativo = servidor conecta de volta'.",
                                  "learningObjective": "Compreender o estabelecimento da conexão de controle e o conceito fundamental do modo ativo FTP.",
                                  "commonMistakes": [
                                    "Confundir portas 20 e 21",
                                    "Achar que cliente sempre inicia todas as conexões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o Comando PORT e sua Sintaxe",
                                  "subSteps": [
                                    "Analise a sintaxe: PORT h1,h2,h3,h4,p1,p2 onde IP = h1.h2.h3.h4 e porta = p1*256 + p2.",
                                    "Exemplo: PORT 192,168,1,1,100,200 → IP 192.168.1.1, porta 100*256 + 200 = 25760.",
                                    "Pratique decodificando 3 exemplos de comandos PORT.",
                                    "Simule envio após login no cliente FTP.",
                                    "Registre que PORT é enviado sobre a conexão de controle."
                                  ],
                                  "verification": "Converta corretamente 2 comandos PORT em IP:porta e vice-versa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou script Python simples para conversão",
                                    "Cliente FTP CLI como ftp no Linux/Windows"
                                  ],
                                  "tips": "Use vírgulas para separar octetos; calcule porta como (p1 << 8) | p2.",
                                  "learningObjective": "Dominar a codificação e decodificação do comando PORT para especificar endereço de dados do cliente.",
                                  "commonMistakes": [
                                    "Erro no cálculo da porta (ex: somar em vez de multiplicar por 256)",
                                    "Usar pontos em vez de vírgulas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o Processo de Transferência de Dados no Modo Ativo",
                                  "subSteps": [
                                    "Após PORT, cliente envia comando de transferência (ex: RETR file.txt).",
                                    "Servidor abre conexão outbound da porta 20 para a porta/IP especificada no PORT.",
                                    "Dados fluem: servidor -> cliente na nova conexão TCP.",
                                    "Conexão de dados é fechada após transferência.",
                                    "Compare com modo passivo (servidor abre porta >1023, cliente conecta)."
                                  ],
                                  "verification": "Explique o fluxo completo em uma sequência numerada de 5-7 eventos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark para capturar tráfego FTP (opcional)",
                                    "Diagramas de sequência UML"
                                  ],
                                  "tips": "Pense 'ativo: servidor ativo na conexão de dados'; use tcpdump para observar.",
                                  "learningObjective": "Mapear o fluxo exato de conexões e comandos durante transferência ativa.",
                                  "commonMistakes": [
                                    "Inverter quem conecta: servidor conecta AO cliente",
                                    "Esquecer fechamento da conexão de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Problemas com Firewalls e Exemplos Práticos",
                                  "subSteps": [
                                    "Identifique que firewalls/NAT bloqueiam conexões inbound ao cliente (porta 25760).",
                                    "Discuta soluções: usar modo passivo ou túneis (ex: FTPS, SFTP).",
                                    "Teste comando: ftp> port 127,0,0,1,40,1; ftp> get test.txt.",
                                    "Registre cenários: redes corporativas com firewalls estritos.",
                                    "Compare com aplicações modernas que evitam FTP ativo."
                                  ],
                                  "verification": "Liste 3 problemas e 2 soluções, simulando um comando PORT bem-sucedido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Servidor FTP local (ex: vsftpd ou FileZilla Server)",
                                    "Cliente FTP CLI"
                                  ],
                                  "tips": "Teste em localhost primeiro; modo passivo é padrão hoje por compatibilidade firewall.",
                                  "learningObjective": "Reconhecer limitações reais do modo ativo e propor alternativas.",
                                  "commonMistakes": [
                                    "Ignorar NAT em redes domésticas",
                                    "Confundir com problemas de autenticação"
                                  ]
                                }
                              ],
                              "practicalExample": "No terminal: `ftp localhost`, login como user/pass, `binary`, `port 127,0,0,1,40,1` (porta 10241), `retr /path/to/file.txt`. Observe logs do servidor mostrando conexão de 20 para 10241; transfira arquivo e verifique com `ls -la`.",
                              "finalVerifications": [
                                "Desenhe e rotule diagrama de conexões (controle 21, dados 20->cliente_porta).",
                                "Decodifique PORT 192,168,1,100,50,60 corretamente (IP e porta).",
                                "Explique por que firewalls bloqueiam modo ativo em 30 segundos.",
                                "Liste diferenças chave vs. modo passivo.",
                                "Simule verbalmente fluxo RETR com PORT.",
                                "Identifique 2 comandos FTP relacionados (PASV, LIST)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe e cálculo do comando PORT (100% correto).",
                                "Correta descrição do fluxo de conexões (quem inicia o quê).",
                                "Identificação clara de problemas de firewall/NAT com exemplos.",
                                "Uso de terminologia técnica exata (ex: outbound/inbound).",
                                "Capacidade de fornecer exemplo prático executável.",
                                "Diferenciação robusta entre modos ativo e passivo."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Configuração de firewalls e regras de NAT/PAT.",
                                "Programação de Redes: Implementação de sockets TCP em Python/Java para FTP client.",
                                "Matemática: Conversão de números em rede (octetos para porta binária).",
                                "História da Computação: Evolução de protocolos cliente-servidor (FTP → HTTP/3).",
                                "Administração de Sistemas: Configuração de servidores FTP (vsftpd, ProFTPD)."
                              ],
                              "realWorldApplication": "Em sistemas legados industriais ou mainframes onde FTP ativo ainda roda; conceitos aplicados em depuração de protocolos P2P ou VoIP atrás de firewalls; base para entender falhas em conexões reversas em apps IoT ou cloud services como AWS S3 transfers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Explicar o modo passivo de transferência FTP",
                            "description": "Detalhar o modo passivo (PASV): servidor abre porta aleatória e responde com 227 Entering Passive Mode (h1,h2,h3,h4,p1,p2), cliente conecta para dados; destacar vantagens em redes com NAT e firewalls outbound.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Contexto e Problemas do Modo Ativo FTP",
                                  "subSteps": [
                                    "Revise o modo ativo FTP: cliente envia PORT, servidor inicia conexão de dados para cliente na porta especificada.",
                                    "Identifique limitações: firewalls/NAT bloqueiam conexões inbound do servidor para cliente.",
                                    "Compare com cenários comuns: redes residenciais com roteadores NAT.",
                                    "Anote diferenças chave entre controle (porta 21) e dados (porta dinâmica).",
                                    "Desenhe um diagrama simples de falha no modo ativo."
                                  ],
                                  "verification": "Crie um diagrama ou lista de 3 problemas do modo ativo e explique verbalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama em papel ou ferramenta como draw.io",
                                    "Documentação RFC 959 FTP"
                                  ],
                                  "tips": "Foquem em fluxos de conexão: quem inicia o quê.",
                                  "learningObjective": "Compreender por que o modo passivo foi criado.",
                                  "commonMistakes": [
                                    "Confundir portas de controle e dados",
                                    "Ignorar NAT como bloqueador inbound"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o Comando PASV e Resposta do Servidor",
                                  "subSteps": [
                                    "Estude o comando PASV: cliente envia 'PASV' após login.",
                                    "Analise resposta 227: 'Entering Passive Mode (h1,h2,h3,h4,p1,p2)'.",
                                    "Decodifique: h1-h4 = IP do servidor (ex: 192,168,1,100), p1*256 + p2 = porta de dados.",
                                    "Simule decodificação: para (127,0,0,1,14,178) calcule porta 3702.",
                                    "Liste sequência: controle -> PASV -> 227 -> cliente conecta na porta calculada."
                                  ],
                                  "verification": "Decodifique uma resposta 227 exemplo e calcule a porta corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de logs FTP",
                                    "Calculadora para porta: p1*256 + p2"
                                  ],
                                  "tips": "Sempre converta vírgulas para pontos no IP; pratique com IPs reais.",
                                  "learningObjective": "Dominar o formato da resposta PASV.",
                                  "commonMistakes": [
                                    "Erro no cálculo da porta (usar soma simples)",
                                    "Confundir IP cliente/servidor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Fluxo de Transferência no Modo Passivo",
                                  "subSteps": [
                                    "Descreva fluxo completo: login -> PASV -> 227 -> RETR/STOR -> dados via nova conexão outbound do cliente.",
                                    "Compare com ativo: cliente sempre inicia conexão de dados.",
                                    "Teste conceitualmente: cliente atrás de NAT conecta ao servidor público.",
                                    "Identifique quando usar: após PASV, comandos como LIST ou GET.",
                                    "Registre diferenças em firewalls: permite outbound de qualquer porta."
                                  ],
                                  "verification": "Desenhe fluxo de 5 passos do PASV e simule com pseudocódigo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Lucidchart ou papel)",
                                    "Wireshark para capturas FTP (opcional)"
                                  ],
                                  "tips": "Lembre: controle é sempre 21/TCP, dados é efêmera outbound.",
                                  "learningObjective": "Mapear o handshake passo a passo.",
                                  "commonMistakes": [
                                    "Achar que servidor conecta de volta",
                                    "Esquecer conexão de controle persistente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens e Cenários Práticos",
                                  "subSteps": [
                                    "Liste vantagens: compatível com NAT/firewalls outbound-only.",
                                    "Discuta desvantagens: servidor precisa escutar portas efêmeras (segurança).",
                                    "Cenários: upload de sites via FTP de casa, servidores web atrás NAT.",
                                    "Compare com FTPS/SFTP: PASV ainda usado em FTP seguro.",
                                    "Resuma: quando preferir PASV vs. ativo/EPSV."
                                  ],
                                  "verification": "Escreva parágrafo explicando vantagem em NAT e 2 cenários reais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Artigos sobre FTP em NAT (StackOverflow)",
                                    "Glossário de termos: NAT, PAT"
                                  ],
                                  "tips": "Pense em seu roteador doméstico: permite saída, bloqueia entrada.",
                                  "learningObjective": "Aplicar conhecimento a problemas reais de rede.",
                                  "commonMistakes": [
                                    "Superestimar segurança do FTP",
                                    "Ignorar EPSV para IPv6"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando telnet: telnet ftp.example.com 21; USER anonymous; PASS guest; PASV; interprete 227 (192,0,2,5,14,178) -> IP 192.0.2.5 porta 3710; telnet 192.0.2.5 3710; envie RETR file.txt para transferir dados.",
                              "finalVerifications": [
                                "Explicar corretamente o formato 227 e decodificar um exemplo.",
                                "Desenhar diagrama comparando ativo vs. passivo.",
                                "Identificar 3 vantagens do PASV em NAT/firewalls.",
                                "Simular fluxo completo verbalmente sem erros.",
                                "Diferenciar PASV de EPSV/EPRT."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de porta e formato 227 (100% correto).",
                                "Clareza no diagrama de fluxo (todos passos visíveis).",
                                "Profundidade nas vantagens (citar NAT/firewall specifics).",
                                "Exemplo prático viável e testável.",
                                "Ausência de confusões com modo ativo."
                              ],
                              "crossCurricularConnections": [
                                "Segurança de Redes: Firewalls e NAT traversal.",
                                "Programação: Implementar cliente FTP com sockets Python.",
                                "Matemática: Cálculo de portas (multiplicação/base 256).",
                                "Sistemas Operacionais: Gerenciamento de portas efêmeras."
                              ],
                              "realWorldApplication": "Configurar uploads FTP em servidores domésticos ou VPS atrás de roteadores NAT, comum em hospedagem web compartilhada, automação de backups via scripts cron, e troubleshooting de erros 'connection refused' em clientes FTP como FileZilla."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Escolher modo adequado baseado em cenário de rede",
                            "description": "Analisar cenários: modo ativo para cliente sem firewall restritivo, passivo para servidores atrás de NAT; simular escolhas com ferramentas como FileZilla e capturas Wireshark para validar conexões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos dos modos ativo e passivo no FTP",
                                  "subSteps": [
                                    "Estude a diferença: no modo ativo, o servidor inicia a conexão de dados para o cliente (porta 20 para porta aleatória do cliente); no modo passivo, o cliente inicia a conexão para o servidor (porta aleatória do servidor).",
                                    "Revise diagramas de fluxo de conexão para cada modo usando recursos online como RFC 959.",
                                    "Identifique quando firewalls no cliente bloqueiam conexões entrantes (favorável a passivo) vs. NAT no servidor (favorável a passivo).",
                                    "Anote prós e contras: ativo é simples mas problemático com firewalls; passivo resolve NAT mas expõe portas no servidor.",
                                    "Compare com exemplos visuais de handshakes TCP."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo as diferenças e cenários ideais para cada modo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação FTP (RFC 959), diagramas online de modos FTP.",
                                  "tips": "Use imagens ou desenhos para visualizar fluxos de conexão.",
                                  "learningObjective": "Diferenciar tecnicamente os modos ativo e passivo e seus impactos em firewalls/NAT.",
                                  "commonMistakes": "Confundir quem inicia a conexão de dados (servidor no ativo, cliente no passivo)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar cenários de rede comuns",
                                  "subSteps": [
                                    "Liste cenários: cliente sem firewall restritivo (use ativo); servidor atrás de NAT/firewall (use passivo).",
                                    "Simule mentalmente: cliente corporativo com firewall outbound-only (ativo falha); servidor doméstico com roteador NAT (passivo necessário).",
                                    "Considere portas: ativo usa porta 20 do servidor; passivo usa faixa EPSV (20-21+).",
                                    "Avalie riscos: passivo pode expor mais portas no servidor; ativo bloqueado por firewalls client-side.",
                                    "Crie uma tabela de decisão: colunas para cenário, modo recomendado, razão."
                                  ],
                                  "verification": "Crie e preencha uma tabela de 4-5 cenários com modos recomendados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel ou planilha (Google Sheets), documentação de firewalls comuns (ex: Windows Firewall, pfSense).",
                                  "tips": "Priorize cenários reais como 'usuário doméstico acessando servidor cloud'.",
                                  "learningObjective": "Mapear cenários de rede a modos FTP ótimos.",
                                  "commonMistakes": "Ignorar NAT no cliente vs. servidor; assumir todos os firewalls são iguais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e testar modos com FileZilla",
                                  "subSteps": [
                                    "Instale FileZilla Client e configure um servidor FTP teste (use FileZilla Server ou online como ftptest.net).",
                                    "Teste modo ativo: defina 'Ativo' nas configurações de site, tente transferir arquivo e observe falhas/sucessos.",
                                    "Mude para passivo: ative 'Passivo' e repita, simulando NAT no servidor (use VM com NAT).",
                                    "Registre logs: capture mensagens de erro como 'ECONNREFUSED' no ativo devido a firewall.",
                                    "Teste cenários: desative firewall no cliente para ativo; habilite NAT para passivo."
                                  ],
                                  "verification": "Registre screenshots de conexões bem-sucedidas/falhas em ambos os modos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "FileZilla Client/Server, VM (VirtualBox) para simular NAT, ftptest.net.",
                                  "tips": "Use modo 'Passivo com fallback para ativo' inicialmente para testes híbridos.",
                                  "learningObjective": "Praticar configuração e troubleshooting prático de modos FTP.",
                                  "commonMistakes": "Esquecer de reiniciar cliente após mudar modo; não verificar configurações de firewall."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar escolhas com análise Wireshark",
                                  "subSteps": [
                                    "Instale Wireshark e capture tráfego durante transferências FTP em FileZilla.",
                                    "Filtre por 'ftp' ou portas 20-21: identifique PORT/EPRT comandos no ativo vs. PASV/EPSV no passivo.",
                                    "Analise handshakes: no ativo, SYN do servidor para cliente; no passivo, SYN do cliente para servidor.",
                                    "Compare capturas: valide se modo escolhido evita rejeições (RST packets).",
                                    "Decida baseado em evidências: escolha modo sem erros de conexão."
                                  ],
                                  "verification": "Gere relatório com capturas Wireshark destacando comandos e fluxos bem-sucedidos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Wireshark, FileZilla em execução, servidor FTP teste.",
                                  "tips": "Use filtro 'ftp.data' para focar em conexões de dados.",
                                  "learningObjective": "Usar análise de pacotes para validar decisões de modo FTP.",
                                  "commonMistakes": "Não filtrar corretamente tráfego; confundir controle (21) com dados (20+)."
                                }
                              ],
                              "practicalExample": "Em um cenário onde um servidor web hospedado em casa (atrás de roteador NAT) precisa receber uploads de um cliente corporativo com firewall restritivo: escolha modo passivo. Configure FileZilla para PASV, capture Wireshark mostrando cliente conectando à porta 50250 do servidor sem RSTs, transferindo um arquivo de 10MB com sucesso.",
                              "finalVerifications": [
                                "Conseguiu conectar e transferir arquivos em modo ativo sem firewall no cliente.",
                                "Falha no ativo com firewall/NAT simulada, sucesso no passivo.",
                                "Identificou comandos PORT/PASV corretamente em logs FileZilla.",
                                "Wireshark mostra fluxos de dados corretos sem pacotes rejeitados.",
                                "Tabela de decisão cobre 4 cenários comuns com justificativas.",
                                "Explicou verbalmente ou por escrito por que passivo é padrão moderno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre modos ativo/passivo (100% correta).",
                                "Tabela de cenários completa e lógica (todos cenários mapeados corretamente).",
                                "Testes FileZilla documentados com screenshots/logs (mínimo 4 testes).",
                                "Análise Wireshark identifica comandos e handshakes chave.",
                                "Decisão final justificada por evidências práticas, não memorização.",
                                "Tempo total dentro de 2 horas, demonstrando eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Segurança de Redes: Impacto de firewalls/NAT em protocolos legados.",
                                "Análise de Protocolos: Leitura de RFCs e análise de pacotes (Wireshark).",
                                "Administração de Sistemas: Configuração de servidores FTP em ambientes reais.",
                                "Troubleshooting: Diagnóstico baseado em logs e capturas."
                              ],
                              "realWorldApplication": "Administradores de TI escolhem modo passivo para uploads em servidores cloud (AWS S3 FTP-like) atrás de NAT, evitando falhas em clientes corporativos; desenvolvedores testam com Wireshark para depurar integrações FTP em apps de backup automatizado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1",
                              "10.1.3.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Comandos, Respostas e Modos de Arquivo",
                        "description": "O FTP define comandos padronizados (RFC 959) como RETR, STOR, LIST e respostas de 3 dígitos para controle de sessão, além de modos ASCII/binário para transferência correta de arquivos texto ou binários.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Listar e descrever comandos principais do FTP",
                            "description": "Memorizar e exemplificar comandos: USER/PASS (autenticação), CWD/RETR/STOR (navegação/upload/download), TYPE A/I (ASCII/binário), SYST/FEAT (informações do sistema); incluir respostas como 200 OK, 550 File not found.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Comandos de Autenticação (USER e PASS)",
                                  "subSteps": [
                                    "Ler a documentação RFC 959 sobre autenticação FTP.",
                                    "Memorizar sintaxe: USER <username> e resposta esperada 331 User name okay, need password.",
                                    "Praticar comando PASS <password> e resposta 230 User logged in successfully.",
                                    "Entender falhas comuns como 530 Not logged in.",
                                    "Testar em cliente FTP simulado."
                                  ],
                                  "verification": "Recitar comandos, sintaxe e respostas de autenticação sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 959 (Protocolo FTP)",
                                    "Cliente FTP como ncftp ou FileZilla",
                                    "Servidor FTP simulado (ex: vsftpd local)"
                                  ],
                                  "tips": [
                                    "Use credenciais anônimas em servidores públicos para testes.",
                                    "Sempre envie PASS após USER."
                                  ],
                                  "learningObjective": "Dominar autenticação inicial no FTP.",
                                  "commonMistakes": [
                                    "Enviar PASS antes de USER",
                                    "Ignorar sensibilidade a maiúsculas em senhas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comandos de Navegação e Transferência (CWD, RETR, STOR)",
                                  "subSteps": [
                                    "Estudar CWD <diretório> para mudar diretório, resposta 250 Directory changed.",
                                    "Aprender RETR <arquivo> para download, resposta 226 Transfer complete.",
                                    "Praticar STOR <arquivo> para upload, resposta 226 Transfer complete.",
                                    "Listar sequência: login > CWD > RETR.",
                                    "Simular erro 550 File not found."
                                  ],
                                  "verification": "Executar sequência de navegação e transferência em simulador e listar respostas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador FTP online (ex: ftp.codeby.net)",
                                    "Documentação comandos FTP",
                                    "Terminal com ftp command"
                                  ],
                                  "tips": [
                                    "Use PWD para verificar diretório atual após CWD.",
                                    "Confirme modo TYPE antes de RETR/STOR."
                                  ],
                                  "learningObjective": "Executar operações básicas de navegação e transferência de arquivos.",
                                  "commonMistakes": [
                                    "Esquecer barra em caminhos CWD /dir",
                                    "Usar STOR sem permissões de escrita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comandos de Modo de Transferência e Informações (TYPE A/I, SYST, FEAT)",
                                  "subSteps": [
                                    "Diferenciar TYPE A (ASCII, texto) e TYPE I (Image, binário), resposta 200 Switching to Binary mode.",
                                    "Testar SYST para info do sistema, resposta ex: 215 UNIX Type: L8.",
                                    "Explorar FEAT para features suportadas, resposta 211-Features.",
                                    "Praticar mudança de modo antes de transferências.",
                                    "Comparar usos: A para scripts, I para executáveis."
                                  ],
                                  "verification": "Descrever diferenças entre modos e listar output de SYST/FEAT de um servidor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cliente FTP com log verbose",
                                    "Servidores FTP públicos (ftp.gnu.org)",
                                    "RFC 959 seções de TYPE"
                                  ],
                                  "tips": [
                                    "Sempre use TYPE I para arquivos binários para evitar corrupção.",
                                    "FEAT ajuda a saber se PASV é suportado."
                                  ],
                                  "learningObjective": "Configurar modos corretos e obter informações do servidor.",
                                  "commonMistakes": [
                                    "Transferir binários em modo A (corrompe arquivos)",
                                    "Ignorar FEAT em clientes modernos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Respostas do Servidor e Memorização Geral",
                                  "subSteps": [
                                    "Memorizar códigos: 200 OK/Command okay, 550 File not found/Permission denied.",
                                    "Categorizar: 2xx sucesso, 5xx erro permanente.",
                                    "Criar tabela de comandos vs respostas esperadas.",
                                    "Quiz si mesmo: listar 8 comandos e 3 respostas.",
                                    "Revisar todos comandos em sequência completa."
                                  ],
                                  "verification": "Passar quiz listando todos comandos principais com descrições e exemplos de respostas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Flashcards Anki para comandos FTP",
                                    "Tabela impressa de códigos de resposta",
                                    "Simulador FTP"
                                  ],
                                  "tips": [
                                    "Agrupe comandos por função para memorizar melhor.",
                                    "Associe 550 a 'arquivo não encontrado' como erros HTTP 404."
                                  ],
                                  "learningObjective": "Identificar e interpretar respostas do servidor FTP.",
                                  "commonMistakes": [
                                    "Confundir 4xx (temporário) com 5xx (permanente)",
                                    "Esquecer 220 Welcome message inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Prática Integrada e Exemplificação",
                                  "subSteps": [
                                    "Simular sessão FTP completa: USER/PASS/CWD/TYPE/RETR.",
                                    "Registrar logs com respostas reais.",
                                    "Descrever cada comando em parágrafo curto.",
                                    "Comparar com SFTP moderno.",
                                    "Aplicar em cenário real ou simulado."
                                  ],
                                  "verification": "Gravar vídeo ou log de sessão FTP explicando cada comando usado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Servidor FTP local (Python ftplib ou vsftpd)",
                                    "Gravador de tela",
                                    "Arquivos de teste texto/binário"
                                  ],
                                  "tips": [
                                    "Use verbose mode no cliente ftp para ver todas respostas.",
                                    "Teste erros intencionalmente para aprender códigos."
                                  ],
                                  "learningObjective": "Aplicar todos comandos em fluxo completo.",
                                  "commonMistakes": [
                                    "Pular verificação de modo TYPE",
                                    "Não logar sessão para revisão"
                                  ]
                                }
                              ],
                              "practicalExample": "Conecte ao servidor ftp.debian.org: USER anonymous, PASS seu@email.com (resposta 230), CWD /debian (250), TYPE I (200), RETR README.txt (226 Transfer complete), SYST (215 UNIX), FEAT (211), STOR test.bin (550 Permission denied em anônimo).",
                              "finalVerifications": [
                                "Listar 8 comandos principais sem erros.",
                                "Descrever função e sintaxe de USER, CWD, RETR, TYPE.",
                                "Exemplificar respostas 200, 230, 550 com contextos.",
                                "Diferenciar TYPE A vs I com exemplos de uso.",
                                "Executar sessão FTP simulada com logs corretos.",
                                "Explicar SYST e FEAT em uma frase cada.",
                                "Identificar erro comum em upload/download."
                              ],
                              "assessmentCriteria": [
                                "Precisão de 100% nos comandos e funções descritas.",
                                "Correta associação de 5+ respostas com cenários.",
                                "Exemplos práticos viáveis e concretos.",
                                "Compreensão de modos TYPE com justificativa.",
                                "Sequência lógica de comandos em prática.",
                                "Uso correto de termos técnicos (RFC-compliant)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Vulnerabilidades em autenticação FTP.",
                                "Programação: Automatização via scripts Python ftplib.",
                                "Redes: Integração com modelo TCP/IP camada aplicação.",
                                "Sistemas Operacionais: Comandos shell ftp em Linux/Windows.",
                                "Administração de Sistemas: Gerenciamento de servidores FTP."
                              ],
                              "realWorldApplication": "Usado por webmasters para upload de sites em hosting compartilhado, sysadmins para backups remotos, desenvolvedores para distribuição de software em repositórios mirror como GNU/ Debian."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Interpretar códigos de resposta FTP",
                            "description": "Classificar respostas: 1xx preliminares, 2xx sucesso, 3xx continua, 4xx erro temporário, 5xx erro permanente; praticar decodificação de logs como 331 Password required, 226 Transfer complete.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura geral dos códigos de resposta FTP",
                                  "subSteps": [
                                    "Estude a composição de um código FTP: três dígitos (XYZ), onde X indica a categoria, Y o estágio e Z detalhes específicos.",
                                    "Identifique o primeiro dígito: 1xx (preliminares), 2xx (sucesso), 3xx (intermediário/continua), 4xx (erro temporário), 5xx (erro permanente).",
                                    "Aprenda o formato de respostas: código seguido de mensagem textual, como '331 Password required'.",
                                    "Revise a RFC 959 para padrões oficiais de FTP.",
                                    "Anote exemplos iniciais de cada categoria em um caderno."
                                  ],
                                  "verification": "Crie um diagrama resumindo as 5 categorias principais e liste 2 exemplos por categoria; verifique se cobre todos os primeiros dígitos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 959 PDF",
                                    "Caderno e caneta",
                                    "Site oficial IETF para FTP"
                                  ],
                                  "tips": "Use mnemônicos: 1=preparo, 2=OK, 3=continue, 4=tente de novo, 5=problema fixo.",
                                  "learningObjective": "Compreender a hierarquia e significado do primeiro dígito nos códigos FTP.",
                                  "commonMistakes": [
                                    "Confundir 3xx com sucesso completo (é intermediário)",
                                    "Ignorar o segundo e terceiro dígitos inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar e memorizar categorias de códigos FTP",
                                  "subSteps": [
                                    "Liste e memorize definições: 1xx (respostas preliminares, ex: 110 Restart marker), 2xx (sucesso, ex: 226 Transfer complete).",
                                    "Para 3xx: respostas que requerem ação adicional (ex: 331 User name okay, need password).",
                                    "4xx: erros transitórios resolvíveis (ex: 421 Service not available).",
                                    "5xx: erros permanentes (ex: 500 Syntax error).",
                                    "Crie flashcards com 10 códigos por categoria para revisão ativa."
                                  ],
                                  "verification": "Classifique corretamente 20 códigos aleatórios em suas categorias sem consultar notas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Flashcards (app como Anki)",
                                    "Tabela de códigos FTP impressa"
                                  ],
                                  "tips": "Agrupe por categoria em uma tabela colorida para visualização rápida.",
                                  "learningObjective": "Classificar instantaneamente qualquer código FTP pela categoria baseada no primeiro dígito.",
                                  "commonMistakes": [
                                    "Misturar 4xx e 5xx (transitório vs permanente)",
                                    "Esquecer que 3xx não é erro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decodificar códigos específicos e mensagens",
                                  "subSteps": [
                                    "Analise códigos comuns: 331 (precisa senha), 230 (login OK), 226 (transferência completa), 550 (arquivo não encontrado).",
                                    "Pratique decodificação: identifique categoria, subcategoria e ação necessária.",
                                    "Simule cenários: para 421, sugira 'tente conectar mais tarde'.",
                                    "Use ferramentas online para gerar códigos FTP simulados.",
                                    "Registre 15 decodificações em um log pessoal com explicações."
                                  ],
                                  "verification": "Decodifique 15 códigos com mensagens e explique ações corretas em 90% dos casos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Simulador FTP online (ex: ftptest.net)",
                                    "Lista de 50 códigos FTP comuns"
                                  ],
                                  "tips": "Leia a mensagem textual sempre, pois complementa o código.",
                                  "learningObjective": "Interpretar o significado completo de um código FTP, incluindo ação recomendada.",
                                  "commonMistakes": [
                                    "Focar só no código numérico, ignorando texto",
                                    "Confundir 550 (permanente) com 450 (temporário)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar interpretação em logs reais de FTP",
                                  "subSteps": [
                                    "Baixe ou gere logs de sessões FTP reais (ex: de FileZilla ou Wireshark).",
                                    "Identifique sequências de códigos em um log: ex: 220->331->230->226.",
                                    "Classifique erros e sugira troubleshooting: 4xx=retry, 5xx=verificar config.",
                                    "Simule troubleshooting completo para um log com falhas.",
                                    "Crie um relatório resumindo 3 logs analisados."
                                  ],
                                  "verification": "Analise 3 logs FTP e produza relatórios precisos sem erros de classificação.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "FileZilla ou WinSCP para gerar logs",
                                    "Exemplos de logs FTP públicos",
                                    "Wireshark (opcional)"
                                  ],
                                  "tips": "Procure padrões: sucessos seguem 220-331-230, erros interrompem.",
                                  "learningObjective": "Aplicar conhecimento para diagnosticar problemas em logs FTP reais.",
                                  "commonMistakes": [
                                    "Não considerar contexto sequencial dos códigos",
                                    "Interpretar isoladamente sem fluxo da sessão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um log FTP: '220 Welcome', '331 Password required', '230 User logged in', '226 Transfer complete'. Interpretação: Conexão preliminar (220/1xx), autenticação intermediária (331/3xx), sucesso login (230/2xx), transferência OK (226/2xx). Se falhar em 331, verifique credenciais.",
                              "finalVerifications": [
                                "Classificar corretamente 25 códigos FTP aleatórios em <2 minutos.",
                                "Decodificar um log completo de 20 linhas com 100% de precisão.",
                                "Explicar ações para 10 erros comuns (4xx/5xx).",
                                "Identificar 5 sequências típicas de login/transferência bem-sucedida.",
                                "Simular troubleshooting para um cenário de erro fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação por categoria (90%+ correto).",
                                "Capacidade de decodificar código + mensagem + ação (completo).",
                                "Velocidade de interpretação em logs reais (<1 min por log curto).",
                                "Compreensão contextual (sequências vs isolado).",
                                "Aplicação prática em troubleshooting simulado.",
                                "Ausência de confusões entre categorias semelhantes (ex: 3xx vs 2xx)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Identificar vazamentos via códigos de erro (ex: 530 falha login).",
                                "Programação: Implementar parsers de logs FTP em scripts Python/Node.js.",
                                "Administração de Sistemas: Monitoramento e automação de transfers via cron jobs.",
                                "Análise de Dados: Processar logs para métricas de performance de rede."
                              ],
                              "realWorldApplication": "Em TI, administradores usam isso para diagnosticar falhas em uploads/downloads automatizados, como em backups diários para servidores remotos ou deployments CI/CD, evitando downtime ao retry em 4xx ou corrigir configs em 5xx."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Configurar modos de transferência de arquivos",
                            "description": "Diferenciar TYPE A (texto, com conversão de fim de linha) e I (binário, sem alteração); demonstrar impactos em arquivos como scripts shell ou imagens JPEG usando comandos TYPE e verificação com MD5.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de modos de transferência TYPE A e TYPE I",
                                  "subSteps": [
                                    "Estude a definição de modo TYPE A (ASCII): transferência de texto com conversão automática de fins de linha (CRLF para LF ou vice-versa).",
                                    "Estude a definição de modo TYPE I (Image/Binário): transferência sem alterações, byte a byte, para arquivos como imagens ou executáveis.",
                                    "Identifique cenários de uso: texto/scripts para A, binários/imagens para I.",
                                    "Revise comandos FTP: 'TYPE A' para ativar ASCII, 'TYPE I' para binário, e 'TYPE' para verificar o modo atual.",
                                    "Leia documentação RFC 959 sobre modos de FTP."
                                  ],
                                  "verification": "Resuma por escrito as diferenças entre TYPE A e I, incluindo exemplos de arquivos afetados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação FTP (RFC 959)",
                                    "Cliente FTP de linha de comando (ftp)"
                                  ],
                                  "tips": "Lembre-se: modo A é para texto legível; modo I preserva dados exatos.",
                                  "learningObjective": "Diferenciar conceitualmente os modos de transferência e seus impactos em diferentes tipos de arquivos.",
                                  "commonMistakes": [
                                    "Confundir TYPE A com binário",
                                    "Ignorar diferenças de sistemas operacionais em fins de linha"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e testar modo TYPE A com arquivo de texto (script shell)",
                                  "subSteps": [
                                    "Prepare um script shell simples (ex: echo 'Hello' > teste.sh) em um sistema Windows (com CRLF).",
                                    "Conecte ao servidor FTP via cliente: ftp <servidor>.",
                                    "Execute 'TYPE A' para ativar modo ASCII e confirme com 'TYPE'.",
                                    "Envie o arquivo: 'put teste.sh' e baixe de volta: 'get teste.sh remoto.sh'.",
                                    "Verifique o arquivo baixado com 'cat -A remoto.sh' para confirmar fins de linha LF."
                                  ],
                                  "verification": "O script shell baixado executa corretamente em Linux (sem erros de ^M).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cliente FTP",
                                    "Servidor FTP ativo",
                                    "Editor de texto",
                                    "Script shell de teste"
                                  ],
                                  "tips": "Use 'binary' como sinônimo de TYPE I em alguns clientes, mas prefira 'TYPE I'.",
                                  "learningObjective": "Aplicar modo TYPE A corretamente para transferência de arquivos texto e observar conversão de fins de linha.",
                                  "commonMistakes": [
                                    "Esquecer de ativar TYPE A antes do PUT",
                                    "Não verificar fins de linha após download"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e testar modo TYPE I com arquivo binário (imagem JPEG)",
                                  "subSteps": [
                                    "Prepare uma imagem JPEG de teste (ex: foto.jpg).",
                                    "Conecte ao FTP e execute 'TYPE I' para modo binário, confirme com 'TYPE'.",
                                    "Envie: 'put foto.jpg' e baixe: 'get foto.jpg remoto.jpg'.",
                                    "Calcule MD5 antes e depois: 'md5sum foto.jpg' e 'md5sum remoto.jpg'.",
                                    "Abra a imagem baixada para confirmar integridade visual."
                                  ],
                                  "verification": "Hashes MD5 dos arquivos original e baixado são idênticos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Imagem JPEG de teste",
                                    "Comando md5sum ou equivalente",
                                    "Visualizador de imagens"
                                  ],
                                  "tips": "Sempre use MD5 para binários; visuais podem falhar se corrompido.",
                                  "learningObjective": "Demonstrar preservação exata de dados em modo TYPE I usando verificação de hash.",
                                  "commonMistakes": [
                                    "Usar modo A para binários, alterando bytes",
                                    "Não comparar MD5 corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar impactos e demonstrar erros comuns",
                                  "subSteps": [
                                    "Repita transferência do script shell em modo I e observe falha (CRLF causa erro em Linux).",
                                    "Repita imagem JPEG em modo A e verifique MD5 diferente (corrupção).",
                                    "Documente diferenças: fins de linha vs. integridade de bytes.",
                                    "Crie um checklist para escolha de modo baseada no tipo de arquivo.",
                                    "Teste 'TYPE' em sessões múltiplas para reforçar verificação."
                                  ],
                                  "verification": "Relatório escrito comparando resultados de transferências corretas vs. incorretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Arquivos de teste anteriores",
                                    "md5sum",
                                    "Ambiente Linux/Windows"
                                  ],
                                  "tips": "Default do FTP é ASCII em muitos clientes; mude explicitamente para I.",
                                  "learningObjective": "Analisar impactos de modos errados e estabelecer práticas seguras de transferência.",
                                  "commonMistakes": [
                                    "Assumir modo atual sem verificar com 'TYPE'",
                                    "Ignorar contexto SO do receptor"
                                  ]
                                }
                              ],
                              "practicalExample": "Transferindo um script shell de um desenvolvedor Windows para servidor Linux: em modo A, CRLF vira LF e executa perfeitamente; em modo I, ^M causa 'bad interpreter' error. Para logo JPEG do site, modo I mantém MD5 igual e imagem intacta; modo A corrompe pixels.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença entre TYPE A e I com exemplos.",
                                "Transferir script shell em A e executá-lo sem erros.",
                                "Transferir JPEG em I com MD5 idênticos antes/depois.",
                                "Identificar modo atual com 'TYPE' em sessão FTP.",
                                "Demonstrar corrupção ao usar modo errado em ambos os casos.",
                                "Criar checklist para escolha de modo por tipo de arquivo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de comandos TYPE A/I (100% correto).",
                                "Verificação efetiva com MD5 para binários e cat -A para texto.",
                                "Análise correta de impactos em arquivos específicos.",
                                "Checklist completo para práticas seguras.",
                                "Tempo de execução dentro do estimado com zero erros graves.",
                                "Relatório claro comparando cenários corretos/incorretos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Impacto de fins de linha em scripts multiplataforma.",
                                "Segurança da Informação: Verificação de integridade com hashes MD5.",
                                "Sistemas Operacionais: Diferenças Windows (CRLF) vs. Unix (LF).",
                                "Administração de Redes: Práticas seguras em protocolos legados como FTP.",
                                "Desenvolvimento Web: Transferência de assets binários para hospedagem."
                              ],
                              "realWorldApplication": "Em administração de servidores, transferir configurações texto (modo A) ou backups binários (modo I) sem corrupção; desenvolvedores web enviam imagens/sites intactos; suporte técnico corrige falhas em uploads de clientes via FTP."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.4",
                            "name": "Discutir limitações de segurança do FTP",
                            "description": "Explicar vulnerabilidades: credenciais em claro, sem criptografia; introduzir FTPS (FTP sobre SSL/TLS) e SFTP (SSH File Transfer); comparar com referências bibliográficas como Tanenbaum e Kurose.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o funcionamento básico do FTP e identificar limitações iniciais",
                                  "subSteps": [
                                    "Estude o protocolo FTP: controle (porta 21) e dados (porta 20) em texto plano.",
                                    "Analise o processo de autenticação: usuário e senha enviados sem criptografia.",
                                    "Identifique ausência de mecanismos de integridade e confidencialidade.",
                                    "Registre exemplos de comandos FTP como USER, PASS e LIST.",
                                    "Anote por que o FTP foi projetado antes das preocupações modernas de segurança."
                                  ],
                                  "verification": "Crie um diagrama simples do fluxo FTP e liste 3 limitações iniciais observadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 959 do FTP",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use Wireshark para capturar tráfego FTP local e visualizar texto plano.",
                                  "learningObjective": "Compreender a arquitetura do FTP e suas premissas de segurança obsoletas.",
                                  "commonMistakes": [
                                    "Confundir FTP com TFTP",
                                    "Ignorar separação de canais de controle e dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar vulnerabilidades específicas do FTP",
                                  "subSteps": [
                                    "Descreva credenciais em claro: sniffers capturam USER/PASS facilmente.",
                                    "Explique falta de criptografia: dados expostos a eavesdropping em redes não confiáveis.",
                                    "Discuta ataques como man-in-the-middle (MITM) e replay attacks.",
                                    "Aborde ausência de verificação de integridade: arquivos podem ser alterados sem detecção.",
                                    "Liste impactos: roubo de dados sensíveis, violação de compliance (ex: GDPR)."
                                  ],
                                  "verification": "Escreva um parágrafo explicando uma vulnerabilidade com exemplo de ataque hipotético.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark para demo de captura",
                                    "Artigos sobre ataques FTP"
                                  ],
                                  "tips": "Simule com tcpdump: tcpdump -i any -w ftp.pcap port 21",
                                  "learningObjective": "Identificar e articular as principais vulnerabilidades de segurança do FTP.",
                                  "commonMistakes": [
                                    "Subestimar riscos em redes Wi-Fi públicas",
                                    "Confundir com problemas de performance"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir alternativas seguras: FTPS e SFTP",
                                  "subSteps": [
                                    "Defina FTPS: FTP sobre SSL/TLS, com modos explícito (AUTH) e implícito (porta 990).",
                                    "Explique SFTP: Subsistema SSH para transferência segura, porta 22, criptografia end-to-end.",
                                    "Compare autenticação: FTPS usa certificados/ senhas; SFTP usa chaves SSH.",
                                    "Descreva benefícios: criptografia, integridade via hashes, suporte a firewall.",
                                    "Instale e teste um cliente como FileZilla com FTPS/SFTP."
                                  ],
                                  "verification": "Configure uma conexão FTPS/SFTP e capture tráfego para confirmar criptografia.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Cliente FileZilla",
                                    "Servidor SFTP local (OpenSSH)",
                                    "Certificado SSL autoassinado"
                                  ],
                                  "tips": "Use 'sftp user@host' no terminal para prática rápida.",
                                  "learningObjective": "Diferenciar FTPS e SFTP das limitações do FTP tradicional.",
                                  "commonMistakes": [
                                    "Confundir FTPS com HTTPS",
                                    "Ignorar configuração de chaves SSH"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar protocolos e referenciar bibliografia",
                                  "subSteps": [
                                    "Crie tabela comparativa: FTP vs FTPS vs SFTP (criptografia, portas, autenticação).",
                                    "Analise Tanenbaum (Redes de Computadores): capítulo sobre protocolos de aplicação.",
                                    "Consulte Kurose (Redes de Computadores): seções sobre segurança em camadas de aplicação.",
                                    "Discuta quando usar cada: SFTP para simplicidade, FTPS para compatibilidade legacy.",
                                    "Conclua com recomendação: evitar FTP puro em produção."
                                  ],
                                  "verification": "Produza tabela comparativa e cite 2 trechos bibliográficos relevantes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livros: Tanenbaum 5ª ed., Kurose 7ª ed.",
                                    "Ferramenta Markdown para tabela"
                                  ],
                                  "tips": "Busque PDFs ou resumos online dos livros para citações precisas.",
                                  "learningObjective": "Comparar protocolos com base em evidências bibliográficas acadêmicas.",
                                  "commonMistakes": [
                                    "Citar fontes incorretas",
                                    "Omitir diferenças de performance"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um cenário de desenvolvimento web, transfira um arquivo de configuração sensível (com chaves API) usando FTP em uma rede Wi-Fi pública: credenciais são capturadas via Wireshark. Repita com SFTP: tráfego criptografado, impossível ler senhas ou conteúdo.",
                              "finalVerifications": [
                                "Liste e explique 4 vulnerabilidades principais do FTP.",
                                "Descreva diferenças chave entre FTPS e SFTP.",
                                "Forneça tabela comparativa com 5 critérios.",
                                "Cite referências de Tanenbaum e Kurose com páginas aproximadas.",
                                "Explique por que FTP não é recomendado em 2024.",
                                "Demonstre configuração básica de SFTP."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: vulnerabilidades corretamente identificadas (80%+).",
                                "Profundidade: explicações com exemplos e referências (4+ subdetalhes).",
                                "Clareza: linguagem acessível, sem jargões não explicados.",
                                "Completude: todos protocolos comparados com tabela/diagrama.",
                                "Aplicação prática: demo ou simulação funcional.",
                                "Referenciação: citações bibliográficas válidas e relevantes."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia (Segurança da Informação): conceitos de SSL/TLS e SSH.",
                                "Redes de Computadores: camadas OSI/TCP-IP, protocolos de aplicação.",
                                "Ética e Compliance: impactos de breaches em regulamentações como LGPD/GDPR.",
                                "Programação: scripts para automação de transferências seguras (Python paramiko)."
                              ],
                              "realWorldApplication": "Em empresas de TI, substituir FTP por SFTP/FTPS em pipelines CI/CD (ex: Jenkins) previne vazamentos de credenciais, como no caso Equifax breach onde protocolos inseguros facilitaram ataques."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.1",
                              "10.1.3.5.1.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.6",
                    "name": "Protocolo SMTP (Simple Mail Transfer Protocol)",
                    "description": "Protocolo para envio de e-mails entre servidores de correio.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.6.1",
                        "name": "Introdução ao Protocolo SMTP",
                        "description": "Conceitos fundamentais sobre o SMTP, incluindo sua definição, propósito e posicionamento no modelo TCP/IP como protocolo de aplicação para transferência de e-mails entre servidores.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.1.1",
                            "name": "Definir o SMTP e seu propósito principal",
                            "description": "Explicar que o SMTP (Simple Mail Transfer Protocol) é um protocolo de camada de aplicação responsável pelo envio de e-mails de um servidor de correio para outro, operando sobre TCP na porta 25 (ou 587 para submissão).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Protocolos de Camada de Aplicação",
                                  "subSteps": [
                                    "Estude o modelo TCP/IP e identifique a camada de aplicação.",
                                    "Liste exemplos de protocolos de aplicação como HTTP, FTP e SMTP.",
                                    "Explique como protocolos de aplicação dependem de TCP para transporte confiável.",
                                    "Pesquise o papel geral dos protocolos na comunicação de rede.",
                                    "Anote diferenças entre camadas de aplicação e transporte."
                                  ],
                                  "verification": "Escreva uma lista de 3 protocolos de aplicação com suas funções breves e confirme que SMTP é um deles.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Documentação TCP/IP básica (Wikipedia ou Khan Academy)"
                                  ],
                                  "tips": "Use diagramas do modelo TCP/IP para visualizar a posição da camada de aplicação.",
                                  "learningObjective": "Entender o contexto da camada de aplicação onde o SMTP opera.",
                                  "commonMistakes": [
                                    "Confundir protocolos de aplicação com protocolos de transporte como TCP ou UDP.",
                                    "Achar que SMTP lida com recebimento de emails."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o SMTP Formalmente",
                                  "subSteps": [
                                    "Pesquise fontes oficiais como RFC 5321 para a definição exata.",
                                    "Expanda o acrônimo: Simple Mail Transfer Protocol.",
                                    "Registre que é um protocolo padrão para transferência de mensagens de email.",
                                    "Identifique a autoridade: IETF (Internet Engineering Task Force).",
                                    "Escreva uma definição concisa em suas próprias palavras."
                                  ],
                                  "verification": "Recite ou escreva a definição completa do SMTP, incluindo acrônimo e RFC.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "RFC 5321 (disponível online)",
                                    "Site IETF ou Wikipedia página SMTP"
                                  ],
                                  "tips": "Sempre cite a RFC para credibilidade em definições técnicas.",
                                  "learningObjective": "Memorizar e articular a definição precisa do SMTP.",
                                  "commonMistakes": [
                                    "Escrever incorretamente o acrônimo como 'Simple Mail Transport Protocol'.",
                                    "Confundir com protocolos mais novos como SMTPUTF8."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Propósito Principal do SMTP",
                                  "subSteps": [
                                    "Descreva o fluxo: envio de email de um servidor MTA para outro.",
                                    "Destaque que SMTP é usado exclusivamente para submissão e relay entre servidores.",
                                    "Compare com IMAP/POP3: SMTP envia, eles recebem.",
                                    "Analise um diagrama de fluxo de email mostrando SMTP em ação.",
                                    "Explique por que é chamado de 'Transfer Protocol'."
                                  ],
                                  "verification": "Desenhe ou descreva verbalmente o fluxo de envio de um email usando SMTP entre dois servidores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas de fluxo de email (online)",
                                    "Ferramenta de desenho simples como Draw.io"
                                  ],
                                  "tips": "Pense em emails reais: seu provedor usa SMTP para entregar ao destinatário.",
                                  "learningObjective": "Compreender o papel específico do SMTP no ecossistema de email.",
                                  "commonMistakes": [
                                    "Acreditar que SMTP gerencia caixas de entrada ou leitura de emails.",
                                    "Ignorar que é server-to-server only."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Detalhes Técnicos Operacionais do SMTP",
                                  "subSteps": [
                                    "Confirme operação sobre TCP para confiabilidade.",
                                    "Memorize portas: 25 (relay padrão), 587 (submissão com autenticação).",
                                    "Liste comandos básicos: HELO/EHLO, MAIL FROM, RCPT TO, DATA, QUIT.",
                                    "Entenda diferenças: porta 25 sem auth, 587 com TLS/auth.",
                                    "Simule uma sessão SMTP simples em texto."
                                  ],
                                  "verification": "Liste as portas SMTP, explique diferenças e recite 5 comandos básicos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de comandos SMTP",
                                    "Simulador online de SMTP (telnet localhost 25)"
                                  ],
                                  "tips": "Use telnet para testar uma conexão real em um servidor local se possível.",
                                  "learningObjective": "Dominar os aspectos técnicos chave para uso prático do SMTP.",
                                  "commonMistakes": [
                                    "Confundir porta 25 com 465 (SMTPS obsoleto).",
                                    "Esquecer que opera exclusivamente sobre TCP."
                                  ]
                                }
                              ],
                              "practicalExample": "Ao enviar um email do Outlook (servidor Microsoft) para um Gmail, o servidor Outlook estabelece uma conexão TCP na porta 25 do servidor Gmail via SMTP, envia HELO seu-dominio.com, MAIL FROM:seu@email.com, RCPT TO:destino@gmail.com, o conteúdo no bloco DATA, e termina com QUIT, garantindo entrega server-to-server.",
                              "finalVerifications": [
                                "Define SMTP como Simple Mail Transfer Protocol (RFC 5321).",
                                "Explica propósito: envio de emails entre servidores MTA.",
                                "Identifica operação sobre TCP nas portas 25/587.",
                                "Diferencia SMTP de IMAP/POP3 corretamente.",
                                "Descreve fluxo básico de uma transação SMTP.",
                                "Menciona comandos essenciais como MAIL FROM e RCPT TO."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: 100% alinhado com RFC 5321.",
                                "Completude: cobre definição, propósito, portas e fluxo.",
                                "Clareza e concisão na explicação verbal ou escrita.",
                                "Uso correto de terminologia técnica (MTA, relay, submission).",
                                "Capacidade de diferenciar SMTP de outros protocolos de email.",
                                "Demonstração prática via diagrama ou simulação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática/Informática: Cálculo de endereços IP e portas numéricas em redes.",
                                "Segurança da Informação: Integração com STARTTLS/OPPORTUNISTIC TLS para criptografia.",
                                "Programação: Implementação de clientes SMTP em linguagens como Python (smtplib).",
                                "História da Computação: Evolução do SMTP desde RFC 821 (1982) na era ARPANET.",
                                "Linguística: Análise de comandos em inglês padronizado (HELO, QUIT)."
                              ],
                              "realWorldApplication": "SMTP é o backbone de todos os sistemas de email globais, permitindo que bilhões de emails sejam enviados diariamente entre provedores como Gmail, Outlook e servidores corporativos, suportando comunicação essencial em negócios, educação e vida pessoal."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.2",
                            "name": "Identificar o posicionamento do SMTP no modelo TCP/IP",
                            "description": "Descrever como o SMTP reside na camada de aplicação do modelo TCP/IP, utilizando o TCP (porta 25) para transporte confiável, diferenciando-o de protocolos como POP3/IMAP que são para recebimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as camadas do modelo TCP/IP",
                                  "subSteps": [
                                    "Liste as 4 camadas principais do modelo TCP/IP: Aplicação, Transporte, Internet e Enlace/Rede.",
                                    "Descreva brevemente a função de cada camada: Aplicação (protocolos de usuário), Transporte (comunicação fim-a-fim), Internet (roteamento), Enlace (transmissão física).",
                                    "Desenhe um diagrama simples das camadas em uma folha de papel ou ferramenta digital.",
                                    "Identifique exemplos de protocolos em cada camada (ex: HTTP na Aplicação, TCP/UDP no Transporte).",
                                    "Explique por que o modelo TCP/IP é usado em vez do OSI em redes modernas."
                                  ],
                                  "verification": "Confirme que o diagrama está correto comparando com uma referência padrão do modelo TCP/IP.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta como Draw.io/Lucidchart",
                                    "Referência: diagrama TCP/IP online (ex: Wikipedia)"
                                  ],
                                  "tips": "Use cores diferentes para cada camada para facilitar a visualização.",
                                  "learningObjective": "Compreender a estrutura hierárquica do modelo TCP/IP.",
                                  "commonMistakes": [
                                    "Confundir TCP/IP com OSI (lembre: TCP/IP tem 4 camadas), ignorar a camada de Transporte."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a camada de Aplicação e protocolos de email",
                                  "subSteps": [
                                    "Defina a camada de Aplicação: responsável por protocolos que interagem diretamente com o usuário.",
                                    "Liste protocolos comuns na camada de Aplicação: HTTP, FTP, SMTP, DNS.",
                                    "Pesquise especificamente o SMTP: Simple Mail Transfer Protocol, usado para envio de emails.",
                                    "Note que SMTP opera sobre TCP para garantir entrega confiável.",
                                    "Registre a porta padrão do SMTP: porta 25."
                                  ],
                                  "verification": "Escreva uma frase resumindo: 'SMTP está na camada de Aplicação e usa TCP porta 25'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Navegador web para pesquisa rápida (ex: RFC 5321 para SMTP)",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Use sites como IANA.org para confirmar portas de protocolos.",
                                  "learningObjective": "Associar SMTP à camada de Aplicação e seu uso no envio de emails.",
                                  "commonMistakes": [
                                    "Confundir SMTP com protocolos de recebimento como POP3/IMAP, achar que SMTP usa UDP."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Posicionar SMTP no modelo TCP/IP com diagrama",
                                  "subSteps": [
                                    "No diagrama da Etapa 1, marque SMTP na camada de Aplicação.",
                                    "Abaixo dela, marque TCP na camada de Transporte, com seta indicando que SMTP usa TCP.",
                                    "Adicione a porta 25 na seta entre Aplicação e Transporte.",
                                    "Explique o fluxo: Aplicação (SMTP) encapsula dados e passa para Transporte (TCP) para envio confiável.",
                                    "Teste verbalizando o posicionamento para si mesmo ou gravando áudio."
                                  ],
                                  "verification": "Compartilhe o diagrama atualizado e explique em 1 minuto onde SMTP reside.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama da Etapa 1",
                                    "Ferramenta de desenho digital opcional"
                                  ],
                                  "tips": "Use setas para mostrar dependências entre camadas.",
                                  "learningObjective": "Visualizar e posicionar SMTP hierarquicamente no modelo TCP/IP.",
                                  "commonMistakes": [
                                    "Colocar SMTP na camada de Transporte, esquecer a dependência do TCP."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar SMTP de POP3/IMAP",
                                  "subSteps": [
                                    "Descreva POP3/IMAP: protocolos para recebimento/retrieval de emails, também na camada de Aplicação.",
                                    "Compare: SMTP (envio, push), POP3/IMAP (recebimento, pull).",
                                    "Note portas: POP3 (110), IMAP (143), ambas sobre TCP.",
                                    "Atualize o diagrama adicionando POP3/IMAP na camada de Aplicação para contraste.",
                                    "Escreva uma tabela comparativa: Colunas - Protocolo, Função, Porta."
                                  ],
                                  "verification": "Responda: 'SMTP envia emails na porta 25; POP3/IMAP recebem.' Sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama atualizado",
                                    "Tabela em papel ou Excel"
                                  ],
                                  "tips": "Lembre: Todos usam TCP para confiabilidade, mas funções diferem.",
                                  "learningObjective": "Distinguir SMTP de outros protocolos de email no mesmo contexto de camadas.",
                                  "commonMistakes": [
                                    "Achar que POP3/IMAP são para envio, confundir portas."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um diagrama TCP/IP e simule o envio de um email: no Wireshark ou ferramenta similar, capture tráfego SMTP na porta 25, identificando pacotes na camada Aplicação sobre TCP (Transporte).",
                              "finalVerifications": [
                                "Pode desenhar corretamente o modelo TCP/IP com SMTP na camada Aplicação?",
                                "Explica verbalmente que SMTP usa TCP porta 25 para transporte confiável?",
                                "Diferencia SMTP (envio) de POP3/IMAP (recebimento)?",
                                "Identifica dependências entre camadas no fluxo de email?",
                                "Responde a perguntas como: 'Onde SMTP reside e por quê?' sem hesitação.",
                                "Cria um diagrama personalizado com marcações precisas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no posicionamento: SMTP exclusivamente na Aplicação sobre TCP.",
                                "Correta menção à porta 25 e uso de TCP para confiabilidade.",
                                "Diferenciação clara de POP3/IMAP com exemplos.",
                                "Diagrama visual completo e legível.",
                                "Explicação fluida e sem confusões entre modelos TCP/IP e OSI.",
                                "Uso de terminologia técnica apropriada (camadas, encapsulamento)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Entender SMTP para discutir vulnerabilidades como spam/open relay.",
                                "Programação: Implementar cliente SMTP em Python (smtplib) para automação de emails.",
                                "Matemática: Modelos em grafos para representar hierarquias de protocolos.",
                                "História da Computação: Evolução do email desde ARPANET."
                              ],
                              "realWorldApplication": "Em administração de servidores, configurar MTA (Mail Transfer Agent) como Postfix usando SMTP na porta 25 para roteamento de emails em empresas; diagnosticar falhas de entrega verificando camadas TCP/IP em ferramentas como tcpdump."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.3",
                            "name": "Explicar a necessidade de protocolos como SMTP em redes",
                            "description": "Relacionar o SMTP com a necessidade de padronização na camada de aplicação para interoperabilidade entre servidores de e-mail heterogêneos, conforme descrito em livros como Tanenbaum e Kurose.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de interoperabilidade em redes de computadores",
                                  "subSteps": [
                                    "Definir interoperabilidade como a capacidade de sistemas heterogêneos se comunicarem sem problemas.",
                                    "Explicar que redes modernas conectam dispositivos de diferentes fabricantes e sistemas operacionais.",
                                    "Discutir exemplos iniciais de redes proprietárias que falhavam em interoperar.",
                                    "Relacionar com o contexto histórico das redes antes da padronização.",
                                    "Identificar a importância da comunicação fluida em escala global."
                                  ],
                                  "verification": "O aluno resume em 3 frases o que é interoperabilidade e dá um exemplo de rede heterogênea.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Redes de Computadores' de Tanenbaum (capítulo 1)",
                                    "Livro 'Redes de Computadores e a Internet' de Kurose (introdução)",
                                    "Vídeo introdutório sobre história das redes (YouTube)"
                                  ],
                                  "tips": "Use analogias cotidianas, como telefones de diferentes marcas se conectando via rede pública.",
                                  "learningObjective": "Entender o problema fundamental de comunicação entre sistemas diferentes.",
                                  "commonMistakes": [
                                    "Confundir interoperabilidade com performance",
                                    "Ignorar o aspecto heterogêneo dos sistemas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar problemas causados pela ausência de padronização na comunicação",
                                  "subSteps": [
                                    "Descrever cenários onde servidores de email proprietários não se comunicam (ex: sistema A não lê email de B).",
                                    "Analisar impactos: perda de mensagens, retrabalho manual, ineficiência econômica.",
                                    "Comparar com comunicação humana sem idioma comum (barreiras linguísticas).",
                                    "Listar consequências em larga escala: fragmentação da internet.",
                                    "Referenciar exemplos históricos de protocolos proprietários falhando."
                                  ],
                                  "verification": "Criar um diagrama simples mostrando falha de comunicação sem padronização.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Trechos de Tanenbaum sobre evolução de protocolos",
                                    "Simulador online de redes (ex: Cisco Packet Tracer)"
                                  ],
                                  "tips": "Desenhe fluxogramas para visualizar o caos sem padrões.",
                                  "learningObjective": "Reconhecer as limitações práticas da falta de protocolos comuns.",
                                  "commonMistakes": [
                                    "Focar apenas em hardware, ignorando software/aplicação",
                                    "Subestimar impactos econômicos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o modelo OSI/TCP-IP e o papel da camada de aplicação",
                                  "subSteps": [
                                    "Revisar brevemente as camadas do modelo OSI, enfatizando a camada 7 (Aplicação).",
                                    "Explicar como protocolos de aplicação como SMTP atuam nessa camada para serviços específicos.",
                                    "Diferenciar camadas inferiores (transporte, rede) que lidam com bits, da aplicação que lida com dados semânticos.",
                                    "Mostrar como padronização em cada camada garante interoperabilidade end-to-end.",
                                    "Citar Tanenbaum e Kurose sobre a necessidade de abstrações padronizadas."
                                  ],
                                  "verification": "Montar um mapa mental das camadas OSI destacando a aplicação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama OSI impresso ou digital",
                                    "Capítulos relevantes de Tanenbaum e Kurose",
                                    "Ferramenta de mindmap (ex: MindMeister gratuito)"
                                  ],
                                  "tips": "Associe cada camada a uma analogia postal (ex: aplicação = conteúdo da carta).",
                                  "learningObjective": "Posicionar a necessidade de protocolos como SMTP no contexto arquitetural.",
                                  "commonMistakes": [
                                    "Confundir camadas de aplicação com transporte",
                                    "Memorizar sem entender abstrações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o SMTP como exemplo de protocolo padronizado para interoperabilidade",
                                  "subSteps": [
                                    "Descrever o SMTP: protocolo para transferência de emails entre servidores (RFC 5321).",
                                    "Explicar comandos básicos (HELO, MAIL FROM, RCPT TO, DATA) e respostas padronizadas.",
                                    "Simular fluxo SMTP entre dois servidores heterogêneos.",
                                    "Comparar com alternativas não padronizadas e mostrar vantagens.",
                                    "Discutir evoluções (ESMTP) mantendo compatibilidade."
                                  ],
                                  "verification": "Escrever um script simples de comandos SMTP e explicar seu fluxo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Documentação RFC 5321 (ietf.org)",
                                    "Ferramenta telnet para testar SMTP real",
                                    "Exemplos de Tanenbaum/Kurose sobre email"
                                  ],
                                  "tips": "Teste SMTP real com telnet gmail-smtp-in.l.google.com 25 (cuidado com spam).",
                                  "learningObjective": "Aplicar o conceito geral ao caso concreto do SMTP.",
                                  "commonMistakes": [
                                    "Confundir SMTP com protocolos de recebimento (POP/IMAP)",
                                    "Ignorar respostas de erro padronizadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o envio de um email de um servidor Gmail para um servidor Outlook. Sem SMTP, cada provedor precisaria de código customizado para o outro, causando falhas. Com SMTP, o email é transferido automaticamente via comandos padronizados, permitindo interoperabilidade global.",
                              "finalVerifications": [
                                "Explicar interoperabilidade em redes heterogêneas com exemplo.",
                                "Listar 3 problemas sem padronização na camada de aplicação.",
                                "Desenhar o fluxo SMTP básico entre dois servidores.",
                                "Relacionar SMTP ao modelo OSI/TCP-IP.",
                                "Citar referências de Tanenbaum ou Kurose sobre protocolos.",
                                "Diferenciar SMTP de POP/IMAP."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação de interoperabilidade (0-20%)",
                                "Uso correto de exemplos concretos e diagramas (0-20%)",
                                "Precisão no modelo de camadas e posicionamento do SMTP (0-20%)",
                                "Profundidade na análise de problemas sem padronização (0-20%)",
                                "Referências bibliográficas adequadas (0-10%)",
                                "Capacidade de simular/verificar fluxo SMTP (0-10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica formal e autômatos em protocolos de comunicação.",
                                "Língua Portuguesa: Analogias com padronização linguística para clareza.",
                                "História: Evolução da internet e padronização pela IETF.",
                                "Física: Transmissão de sinais em redes como base para aplicação.",
                                "Educação Financeira: Impacto econômico da interoperabilidade em negócios."
                              ],
                              "realWorldApplication": "Todo email enviado entre diferentes provedores (Gmail para Yahoo) usa SMTP para garantir entrega, suportando o ecossistema global de comunicação digital essencial para trabalho remoto, e-commerce e serviços online."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.2",
                        "name": "Comandos e Respostas do SMTP",
                        "description": "Principais comandos utilizados no protocolo SMTP e os códigos de resposta correspondentes para o handshake e transferência de mensagens.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.2.1",
                            "name": "Listar e descrever comandos iniciais de conexão SMTP",
                            "description": "Detalhar comandos como HELO/EHLO (identificação do cliente), MAIL FROM (remetente), RCPT TO (destinatário) e como eles iniciam a sessão de transferência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o contexto e fluxo inicial do protocolo SMTP",
                                  "subSteps": [
                                    "Leia a RFC 5321 para visão geral do SMTP.",
                                    "Identifique as fases de uma sessão SMTP: conexão, identificação, envelope e dados.",
                                    "Desenhe um diagrama simples do fluxo: cliente conecta ao servidor na porta 25.",
                                    "Note que comandos iniciais ocorrem após TCP handshake.",
                                    "Liste os comandos iniciais: HELO/EHLO, MAIL FROM, RCPT TO."
                                  ],
                                  "verification": "Desenhe e explique o diagrama do fluxo inicial para um parceiro de estudo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 5321 (disponível online)",
                                    "Papel e caneta para diagrama",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use ferramentas como draw.io para diagramas digitais se preferir visual.",
                                  "learningObjective": "Compreender o papel dos comandos iniciais na estabelecimento da sessão SMTP.",
                                  "commonMistakes": [
                                    "Confundir SMTP com HTTP",
                                    "Ignorar a distinção entre envelope e cabeçalhos de mensagem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o comando HELO/EHLO para identificação do cliente",
                                  "subSteps": [
                                    "Compare HELO (RFC 821, simples) vs EHLO (RFC 5321, extensões ESMTP).",
                                    "Aprenda sintaxe: HELO <domain> ou EHLO <domain>.",
                                    "Entenda resposta do servidor: 250 OK com lista de extensões para EHLO.",
                                    "Pratique escrevendo exemplos de comandos e respostas esperadas.",
                                    "Note que EHLO é preferido em servidores modernos."
                                  ],
                                  "verification": "Escreva 3 exemplos de HELO/EHLO com respostas simuladas e valide contra RFC.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação RFC 5321 seção 4.1.1-4.1.2",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Lembre-se: domínio deve ser FQDN válido para evitar rejeições.",
                                  "learningObjective": "Descrever precisamente o propósito e sintaxe de HELO/EHLO.",
                                  "commonMistakes": [
                                    "Usar IP em vez de domínio",
                                    "Confundir com autenticação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar o comando MAIL FROM para especificar o remetente",
                                  "subSteps": [
                                    "Estude sintaxe: MAIL FROM:<reverse-path> [SP <params>].",
                                    "Entenda que reverse-path é usado para bounces, não cabeçalho From.",
                                    "Aprenda parâmetros opcionais como SIZE, AUTH.",
                                    "Veja respostas: 250 OK ou erros como 552 quota exceeded.",
                                    "Escreva exemplos com e sem parâmetros."
                                  ],
                                  "verification": "Simule uma interação MAIL FROM em papel, incluindo cenários de erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 5321 seção 4.1.1.3",
                                    "Exemplos de logs SMTP online"
                                  ],
                                  "tips": "Teste com email reverso vazio <> para anonimato em alguns casos.",
                                  "learningObjective": "Explicar como MAIL FROM inicia o envelope do remetente.",
                                  "commonMistakes": [
                                    "Confundir com cabeçalho From:",
                                    "Omitir < > nos endereços"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o comando RCPT TO para destinatários",
                                  "subSteps": [
                                    "Aprenda sintaxe: RCPT TO:<forward-path> [SP <params>].",
                                    "Note que múltiplos RCPT TO podem ser usados por mensagem.",
                                    "Entenda respostas: 250 OK, 550 não encontrado, etc.",
                                    "Discuta parâmetros como ORCPT para aliasing.",
                                    "Pratique sequenciando com MAIL FROM."
                                  ],
                                  "verification": "Liste 5 cenários de RCPT TO com respostas corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 5321 seção 4.1.1.4",
                                    "Ferramenta de simulação SMTP online"
                                  ],
                                  "tips": "Sempre após MAIL FROM; servidor rejeita se fora de ordem.",
                                  "learningObjective": "Identificar como RCPT TO define destinatários no envelope.",
                                  "commonMistakes": [
                                    "Usar antes de MAIL FROM",
                                    "Esquecer de lidar com múltiplos recipients"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simular e integrar a sequência completa de comandos iniciais",
                                  "subSteps": [
                                    "Monte a sequência: EHLO -> MAIL FROM -> RCPT TO.",
                                    "Use telnet para conectar a um servidor SMTP de teste (ex: mail-tester.com).",
                                    "Registre respostas reais do servidor.",
                                    "Analise erros comuns em logs reais.",
                                    "Documente a sessão completa em um arquivo."
                                  ],
                                  "verification": "Execute uma sessão telnet bem-sucedida até RCPT TO e capture screenshot/log.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Telnet ou netcat",
                                    "Servidor SMTP de teste (smtp.gmail.com:587 com TLS off para simulação)",
                                    "Editor de texto para logs"
                                  ],
                                  "tips": "Use porta 25 para servidores públicos; respeite termos de uso.",
                                  "learningObjective": "Executar e documentar uma sessão SMTP inicial completa.",
                                  "commonMistakes": [
                                    "Não QUIT após teste",
                                    "Ignorar greylisting delays"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando telnet: telnet smtp.example.com 25; EHLO mydomain.com (recebe 250-EXTENSIONS); MAIL FROM:<user@mydomain.com> (250 OK); RCPT TO:<recipient@example.com> (250 OK). Isso inicia o envelope para envio de email sem corpo ainda.",
                              "finalVerifications": [
                                "Liste corretamente HELO/EHLO, MAIL FROM e RCPT TO com sintaxes exatas.",
                                "Explique diferenças entre HELO e EHLO com exemplos de respostas.",
                                "Simule uma sessão completa sem erros de sequência.",
                                "Identifique 3 respostas de erro comuns para cada comando.",
                                "Descreva o propósito do envelope vs. cabeçalhos da mensagem.",
                                "Execute telnet em um servidor real e capture log válido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de sintaxe e propósitos (90%+ correto).",
                                "Capacidade de simular fluxos com respostas adequadas.",
                                "Identificação correta de erros comuns e prevenções.",
                                "Integração de comandos em sequência lógica.",
                                "Uso prático via telnet com evidências (logs/screenshots).",
                                "Explicação clara de RFC referências."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Autenticação e prevenção de spam via comandos estendidos.",
                                "Matemática/Algoritmos: Lógica sequencial e estados finitos no protocolo.",
                                "Linguagens de Programação: Implementação em bibliotecas como Python smtplib.",
                                "Redes: Integração com TCP/IP e DNS MX records.",
                                "Ética: Responsabilidade no uso de servidores SMTP públicos."
                              ],
                              "realWorldApplication": "Esses comandos são fundamentais para qualquer sistema de email, como servidores Postfix/Exim, bibliotecas de programação para automação de envios (alertas, newsletters), depuração de falhas de entrega e desenvolvimento de ferramentas anti-spam."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.1"
                            ]
                          },
                          {
                            "id": "10.1.3.6.2.2",
                            "name": "Descrever o comando DATA e encerramento",
                            "description": "Explicar o comando DATA para envio do corpo da mensagem (terminado por linha dupla ponto), e QUIT para fechamento da conexão, incluindo formato da mensagem RFC 5322.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o propósito e sintaxe do comando DATA",
                                  "subSteps": [
                                    "Ler a definição do comando DATA no RFC 5321 (SMTP).",
                                    "Identificar que DATA inicia o envio do corpo da mensagem após cabeçalhos.",
                                    "Analisar exemplos de respostas do servidor (ex: 354 Start mail input).",
                                    "Estudar o terminador: linha com ponto único (.) em uma linha própria.",
                                    "Diferenciar DATA de outros comandos como HELO ou MAIL FROM."
                                  ],
                                  "verification": "Escrever uma descrição curta do DATA e confirmar com RFC.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "RFC 5321 (seção 4.1.4), editor de texto",
                                  "tips": "Sempre verifique o código de resposta 354 antes de enviar dados.",
                                  "learningObjective": "Explicar o papel do DATA no fluxo SMTP.",
                                  "commonMistakes": "Confundir DATA com RCPT TO; DATA vem após MAIL FROM e RCPT TO."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o formato da mensagem de email (RFC 5322)",
                                  "subSteps": [
                                    "Analisar estrutura: cabeçalhos (From, To, Subject) seguidos por corpo vazio ou texto.",
                                    "Ler RFC 5322 para regras de linhas longas (folding) e codificação.",
                                    "Praticar montagem de uma mensagem simples com cabeçalhos e corpo.",
                                    "Verificar terminador: linha dupla ponto (.) para sinalizar fim.",
                                    "Testar formatação em um editor para evitar quebras inválidas."
                                  ],
                                  "verification": "Montar e validar uma mensagem modelo contra exemplos RFC.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "RFC 5322, exemplos de mensagens SMTP online",
                                  "tips": "Use CRLF (\\r\\n) para fins de linha, não apenas LF.",
                                  "learningObjective": "Construir uma mensagem válida conforme RFC 5322.",
                                  "commonMistakes": "Esquecer CRLF ou usar ponto no corpo da mensagem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o procedimento de envio com DATA e verificação",
                                  "subSteps": [
                                    "Simular sessão SMTP via Telnet: conectar em porta 25.",
                                    "Enviar HELO, MAIL FROM, RCPT TO, então DATA.",
                                    "Digitar mensagem completa e terminar com linha de ponto único.",
                                    "Observar resposta 250 OK após envio bem-sucedido.",
                                    "Diagnosticar erros comuns como 554 rejeição."
                                  ],
                                  "verification": "Realizar simulação Telnet e capturar log de sucesso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Cliente Telnet/netcat, servidor SMTP de teste (ex: mail-tester.com)",
                                  "tips": "Copie a mensagem para clipboard para envio rápido.",
                                  "learningObjective": "Executar fluxo completo de envio com DATA.",
                                  "commonMistakes": "Enviar ponto sem linha vazia antes; causa truncamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar o comando QUIT e encerramento da conexão",
                                  "subSteps": [
                                    "Ler definição de QUIT no RFC 5321: fecha conexão graciosamente.",
                                    "Simular após DATA: servidor responde 221 Bye e fecha.",
                                    "Comparar com fechamento abrupto (RST) vs. graceful (FIN).",
                                    "Analisar logs de sessões reais para padrões de QUIT.",
                                    "Testar em ferramenta: enviar QUIT e verificar desconexão."
                                  ],
                                  "verification": "Completar sessão Telnet com QUIT e log de 221.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "RFC 5321 (seção 4.1.5), Wireshark para captura opcional",
                                  "tips": "QUIT é educado; evite timeouts forçando fechamento.",
                                  "learningObjective": "Descrever e executar encerramento SMTP.",
                                  "commonMistakes": "Usar QUIT antes de dados pendentes; causa erro 503."
                                }
                              ],
                              "practicalExample": "Conecte via telnet smtp.example.com 25. Envie: HELO client; MAIL FROM:<user@ex.com>; RCPT TO:<dest@ex.com>; DATA; From: User; Subject: Teste; Corpo do email aqui.; (ponto único para fim); QUIT. Servidor responde 250 OK e 221 Bye.",
                              "finalVerifications": [
                                "Descreva o fluxo exato: comandos antes/depois de DATA.",
                                "Monte uma mensagem RFC 5322 válida manualmente.",
                                "Simule Telnet com DATA e QUIT sem erros.",
                                "Explique terminador de linha dupla ponto.",
                                "Identifique respostas esperadas (354, 250, 221).",
                                "Compare DATA com formato MIME para anexos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do comando DATA e terminador (100%).",
                                "Completude do formato RFC 5322 nos exemplos (90%+).",
                                "Correta execução de simulação prática sem erros.",
                                "Explicação clara de QUIT vs. outros fechamentos.",
                                "Uso correto de CRLF e folding de linhas.",
                                "Identificação de 3+ erros comuns e soluções."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Vulnerabilidades como relay open em SMTP.",
                                "Programação: Implementar cliente SMTP em Python (smtplib).",
                                "Matemática: Criptografia em TLS para SMTP seguro (STARTTLS)."
                              ],
                              "realWorldApplication": "Configurar scripts de automação para envio de emails transacionais em e-commerces, como confirmações de pedidos, integrando com servidores como Gmail ou AWS SES."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.6.2.3",
                            "name": "Interpretar códigos de resposta SMTP",
                            "description": "Reconhecer códigos como 220 (serviço pronto), 250 (OK), 550 (usuário desconhecido) e 3xx (ações pendentes), conforme especificação RFC 5321.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o formato e categorias dos códigos de resposta SMTP",
                                  "subSteps": [
                                    "Ler a seção relevante da RFC 5321 sobre respostas SMTP (seção 4.2).",
                                    "Identificar que os códigos são compostos por três dígitos: o primeiro indica a categoria (2xx sucesso, 3xx pendente, 4xx temporário, 5xx permanente).",
                                    "Analisar o segundo e terceiro dígitos para subcategorias específicas.",
                                    "Estudar exemplos de texto de resposta associado aos códigos.",
                                    "Mapear as quatro categorias principais em uma tabela própria."
                                  ],
                                  "verification": "Criar uma tabela resumindo as 4 categorias principais com exemplos e confirmar com RFC.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 5321 (disponível em ietf.org/rfc/rfc5321.txt)",
                                    "Bloco de notas ou planilha para tabela"
                                  ],
                                  "tips": "Foque no primeiro dígito como 'nível de severidade'; ignore detalhes avançados inicialmente.",
                                  "learningObjective": "Entender a estrutura hierárquica dos códigos SMTP e suas categorias principais.",
                                  "commonMistakes": [
                                    "Confundir 4xx (temporário) com 5xx (permanente)",
                                    "Ignorar o texto explicativo após o código"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e interpretar códigos específicos chave",
                                  "subSteps": [
                                    "Estudar código 220: Serviço pronto (início da sessão SMTP).",
                                    "Analisar 250: Ação bem-sucedida (ex: OK após MAIL FROM ou RCPT TO).",
                                    "Examinar 550: Erro permanente (ex: usuário desconhecido).",
                                    "Revisar família 3xx: Ações pendentes (ex: 354 para dados).",
                                    "Associar cada código a um cenário típico de fluxo SMTP."
                                  ],
                                  "verification": "Listar os 4 códigos mencionados com suas descrições exatas sem consultar notas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 5321 seções 4.2.1-4.2.4",
                                    "Flashcards ou app como Anki"
                                  ],
                                  "tips": "Use mnemônicos: '2=sucesso, 5=stop (permanente), 3=mais um passo'.",
                                  "learningObjective": "Reconhecer e explicar precisamente os significados dos códigos 220, 250, 550 e 3xx.",
                                  "commonMistakes": [
                                    "Confundir 250 OK com 220 pronto",
                                    "Achar que 3xx é sempre erro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar interpretação em cenários simulados de SMTP",
                                  "subSteps": [
                                    "Simular uma sessão SMTP usando telnet em um servidor público (ex: telnet smtp.gmail.com 25).",
                                    "Registrar respostas recebidas e classificá-las por categoria.",
                                    "Interpretar um log de erro com 550 e propor solução.",
                                    "Criar 5 cenários fictícios com códigos mistos e resolvê-los.",
                                    "Comparar interpretações com documentação oficial."
                                  ],
                                  "verification": "Executar uma simulação real e documentar 3 respostas interpretadas corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Cliente telnet ou netcat",
                                    "Servidor SMTP de teste (ex: smtp.ethereal.email)",
                                    "Editor de texto para logs"
                                  ],
                                  "tips": "Sempre digite 'QUIT' para encerrar graciosamente; capture saídas com script simples.",
                                  "learningObjective": "Aplicar conhecimento para interpretar códigos em fluxos reais ou simulados SMTP.",
                                  "commonMistakes": [
                                    "Não aguardar texto completo após código",
                                    "Ignorar contexto do comando anterior"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em troubleshooting e verificação avançada",
                                  "subSteps": [
                                    "Analisar um log real de falha SMTP (ex: de postfix ou logs de email).",
                                    "Diagnosticar problemas baseados em sequências de códigos (ex: 250 seguido de 550).",
                                    "Pesquisar variações de 3xx em RFC e exemplos.",
                                    "Testar envios com ferramentas como swaks para gerar respostas.",
                                    "Documentar um relatório de troubleshooting com códigos interpretados."
                                  ],
                                  "verification": "Produzir um relatório de 1 página diagnosticando um problema simulado com códigos SMTP.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta swaks (instalar via apt/brew)",
                                    "Logs de exemplo de servidores SMTP",
                                    "RFC 5321"
                                  ],
                                  "tips": "Busque padrões: falhas em RCPT TO geralmente são 550; use --server para testar remotos.",
                                  "learningObjective": "Usar códigos SMTP para diagnosticar e resolver problemas de entrega de email.",
                                  "commonMistakes": [
                                    "Atribuir erro ao código errado na sequência",
                                    "Não considerar autenticação em servidores modernos"
                                  ]
                                }
                              ],
                              "practicalExample": "Conecte via telnet a um servidor SMTP: 'telnet smtp.example.com 25'. Receba '220 example.com ESMTP ready'. Envie 'HELO test', receba '250 OK'. Tente 'RCPT TO invalid@domain.com', receba '550 User unknown'. Interprete: servidor pronto (220), saudação OK (250), mas usuário inexistente (550) – problema de destinatário.",
                              "finalVerifications": [
                                "Explicar corretamente o significado de 220, 250, 550 e um 3xx exemplo.",
                                "Classificar 5 códigos aleatórios em suas categorias (2xx/3xx/4xx/5xx).",
                                "Simular uma sessão SMTP e listar todas respostas com interpretações.",
                                "Diagnosticar um log com erro 550 propondo correção.",
                                "Diferenciar erros temporários (4xx) de permanentes (5xx) com exemplos.",
                                "Recitar o primeiro dígito de cada categoria sem hesitação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de categorias (100% correto).",
                                "Correta interpretação de códigos específicos (220, 250, 550, 3xx).",
                                "Capacidade de contextualizar códigos em fluxos SMTP.",
                                "Qualidade da simulação prática e documentação.",
                                "Profundidade no troubleshooting de logs reais.",
                                "Uso correto de RFC 5321 como referência."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Integração com TCP/IP e portas 25/587.",
                                "Programação: Implementação de clientes SMTP em Python (smtplib).",
                                "Segurança da Informação: Detecção de falhas de autenticação via códigos 5xx.",
                                "Administração de Sistemas: Análise de logs em postfix/sendmail.",
                                "Comunicações Digitais: Entendimento de protocolos de aplicação."
                              ],
                              "realWorldApplication": "Em equipes de suporte técnico de TI ou DevOps, interpretar códigos SMTP em logs de email para diagnosticar falhas de entrega, como contas inexistentes (550) ou servidores sobrecarregados (4xx), otimizando fluxos de comunicação corporativa e reduzindo tempo de resolução de tickets."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.3",
                        "name": "Processo de Transferência e Funcionamento SMTP",
                        "description": "Fluxo completo de envio de e-mail via SMTP, incluindo relay entre servidores e tratamento de erros.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.3.1",
                            "name": "Desenhar o fluxo de uma sessão SMTP completa",
                            "description": "Representar o handshake (EHLO, MAIL FROM, RCPT TO), envio DATA, resposta positiva e QUIT, ilustrando comunicação cliente-servidor e servidor-servidor (relay).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar comandos e estrutura básica de uma sessão SMTP",
                                  "subSteps": [
                                    "Consulte a RFC 5321 para listar comandos essenciais: EHLO/HELO, MAIL FROM, RCPT TO, DATA e QUIT.",
                                    "Anote respostas típicas do servidor: 220 Greeting, 250 OK, 354 Start mail input, 250 2.0.0 OK.",
                                    "Identifique atores: cliente (MUA/MSA), servidor MTA e relay MTA.",
                                    "Diferencie comunicação cliente-servidor e servidor-servidor (relay).",
                                    "Crie um glossário simples com 5-10 termos chave como envelope vs. headers."
                                  ],
                                  "verification": "Lista completa de comandos, respostas e atores documentada em uma tabela ou notas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 5321 (disponível online)",
                                    "Bloco de notas ou editor de texto",
                                    "Ferramenta de diagramação como draw.io ou Lucidchart"
                                  ],
                                  "tips": "Use cores diferentes para comandos do cliente (azul) e respostas do servidor (verde).",
                                  "learningObjective": "Compreender os comandos fundamentais e o fluxo lógico de uma sessão SMTP.",
                                  "commonMistakes": [
                                    "Confundir envelope SMTP (MAIL FROM/RCPT TO) com cabeçalhos da mensagem (From:).",
                                    "Ignorar o greeting inicial 220.",
                                    "Esquecer diferenças entre HELO e EHLO (ESMTP)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar o handshake inicial (Conexão TCP e EHLO)",
                                  "subSteps": [
                                    "Desenhe a conexão TCP: cliente conecta na porta 25 do servidor.",
                                    "Adicione seta do servidor: '220 server.example.com ESMTP'.",
                                    "Desenhe seta do cliente: 'EHLO client.example.com' e resposta '250-server.example.com'.",
                                    "Inclua capacidades opcionais como AUTH ou STARTTLS se relevante.",
                                    "Verifique setas bidirecionais para handshake completo."
                                  ],
                                  "verification": "Diagrama parcial mostra conexão, greeting e EHLO com respostas corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (draw.io)",
                                    "Referência RFC 5321 seção 4.1"
                                  ],
                                  "tips": "Use setas com labels para comandos e respostas; inclua timestamps fictícios para realismo.",
                                  "learningObjective": "Representar visualmente o estabelecimento da sessão SMTP inicial.",
                                  "commonMistakes": [
                                    "Usar porta errada (é 25 para SMTP, 587 para submission).",
                                    "Omitir greeting 220.",
                                    "Confundir ordem: greeting vem antes de EHLO."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar o envelope e envio de dados (MAIL FROM, RCPT TO, DATA)",
                                  "subSteps": [
                                    "Adicione 'MAIL FROM:<sender@domain.com>' e resposta '250 OK'.",
                                    "Desenhe 'RCPT TO:<recipient@domain.com>' e resposta '250 Accepted'.",
                                    "Inclua 'DATA', resposta '354 Start mail input', corpo da mensagem e término com linha única '.'.",
                                    "Mostre resposta final '250 2.0.0 OK ID xyz'.",
                                    "Marque o envelope separadamente do corpo da mensagem."
                                  ],
                                  "verification": "Seção do diagrama inclui envelope completo, DATA com exemplo de mensagem e ponto finalizador.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação",
                                    "Exemplo de email real capturado com Wireshark"
                                  ],
                                  "tips": "Represente o corpo da mensagem como caixa com headers e texto; use aspas para o '.' final.",
                                  "learningObjective": "Ilustrar o envio seguro do remetente, destinatário e conteúdo da mensagem.",
                                  "commonMistakes": [
                                    "Esquecer o ponto sozinho na linha para finalizar DATA.",
                                    "Usar múltiplos RCPT TO sem loops.",
                                    "Confundir RCPT TO com endereços BCC (não visíveis no envelope SMTP)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenhar o término da sessão e fluxo de relay",
                                  "subSteps": [
                                    "Adicione 'QUIT' do cliente e resposta '221 Bye'.",
                                    "Crie ramificação para relay: servidor1 repete MAIL FROM/RCPT TO/DATA para servidor2.",
                                    "Mostre setas cliente -> servidor1 -> servidor2 com mesmos comandos.",
                                    "Inclua erros potenciais como 550 User unknown em RCPT TO.",
                                    "Conecte todas as partes em um fluxo linear com ramificações."
                                  ],
                                  "verification": "Diagrama completo inclui QUIT, relay bidirecional e tratamento básico de erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação",
                                    "Diagrama de exemplo de relay SMTP online"
                                  ],
                                  "tips": "Use linhas tracejadas para relay e caixas para servidores distintos.",
                                  "learningObjective": "Visualizar o ciclo completo incluindo relay e fechamento gracioso.",
                                  "commonMistakes": [
                                    "Omitir QUIT (sessão pode ficar aberta).",
                                    "Mostrar relay como unidirecional.",
                                    "Ignorar que relay preserva envelope original."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar, anotar e validar o diagrama final",
                                  "subSteps": [
                                    "Adicione legendas, cores e numeração sequencial aos comandos.",
                                    "Inclua notas sobre timeouts ou erros comuns (ex: 421 Service unavailable).",
                                    "Compare com fluxogramas padrão de SMTP (ex: Wireshark capture).",
                                    "Teste legibilidade: imprima ou compartilhe para revisão.",
                                    "Salve em formato editável e exporte como PNG/PDF."
                                  ],
                                  "verification": "Diagrama final é claro, completo e validado contra RFC.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação",
                                    "Capture Wireshark de sessão SMTP real"
                                  ],
                                  "tips": "Use swimlanes para cliente/servidor1/servidor2 para clareza em relays.",
                                  "learningObjective": "Produzir um diagrama profissional e verificável de fluxo SMTP.",
                                  "commonMistakes": [
                                    "Diagrama overcrowdado sem zoom/legendas.",
                                    "Inconsistências em códigos de resposta (use 250 sempre que positivo).",
                                    "Esquecer contexto relay no título."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenhe o fluxo onde client.example.com (porta 25) envia email de alice@client.com para bob@remote.com via relay.server.com: cliente faz EHLO -> relay aceita MAIL FROM:<alice@client.com> RCPT TO:<bob@remote.com> DATA (mensagem com Subject: Hello) . -> relay repete para remote.com -> QUIT em ambos.",
                              "finalVerifications": [
                                "Todos comandos essenciais (EHLO, MAIL FROM, RCPT TO, DATA, QUIT) e respostas (220, 250, 354, 221) presentes.",
                                "Fluxo bidirecional com setas claras cliente-servidor e relay servidor-servidor.",
                                "Envelope distinguido do corpo da mensagem; ponto finalizador em DATA visível.",
                                "Tratamento básico de relay com ramificação correta.",
                                "Diagrama legível com legendas, cores e numeração sequencial.",
                                "Sem erros factuais comparado à RFC 5321."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: comandos e respostas SMTP corretos (40%).",
                                "Clareza visual: uso efetivo de setas, swimlanes e cores (25%).",
                                "Completude: inclusão de handshake, envelope, dados, término e relay (20%).",
                                "Detalhes adicionais: erros comuns, legendas e anotações (10%).",
                                "Profissionalismo: legibilidade e formato exportável (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos e Fluxogramas (Matemática/Computação): representação de processos sequenciais.",
                                "Comunicação e Protocolos (Linguística): estrutura de diálogos cliente-servidor como conversa.",
                                "Física/Eletrônica: modelagem de sinais e handshakes em redes.",
                                "Segurança da Informação: análise de envelopes para detecção de spam/phishing."
                              ],
                              "realWorldApplication": "Administradores de sistemas usam diagramas SMTP para diagnosticar falhas de entrega de emails, desenvolvedores implementam clientes/relays compatíveis, e analistas de segurança investigam abusos em tráfego email global."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.1",
                              "10.1.3.6.2"
                            ]
                          },
                          {
                            "id": "10.1.3.6.3.2",
                            "name": "Explicar relay e roteamento de e-mails SMTP",
                            "description": "Descrever como servidores MTA (Mail Transfer Agents) usam MX records DNS para rotear e-mails entre domínios, com retry em falhas e store-and-forward.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de MTA e Relay SMTP",
                                  "subSteps": [
                                    "Defina MTA (Mail Transfer Agent) como o servidor responsável por aceitar, rotear e entregar e-mails.",
                                    "Explique o conceito de relay SMTP: um MTA aceita e-mails de um cliente ou outro MTA e os encaminha para o destino.",
                                    "Diferencie relay inbound (recebendo e-mails) de outbound (enviando e-mails).",
                                    "Descreva o protocolo SMTP básico: comandos como HELO/EHLO, MAIL FROM, RCPT TO e DATA.",
                                    "Identifique que relays são essenciais para conectar domínios diferentes."
                                  ],
                                  "verification": "Liste os 4 comandos principais do SMTP e explique o papel de um MTA em um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 5321 (SMTP)",
                                    "Diagrama de fluxo SMTP básico"
                                  ],
                                  "tips": "Use analogia de correio postal: MTA é como um posto de correio que encaminha cartas.",
                                  "learningObjective": "Compreender o papel central dos MTAs no relay de e-mails SMTP.",
                                  "commonMistakes": [
                                    "Confundir MTA com MUA (Mail User Agent, como Outlook)",
                                    "Ignorar que SMTP é apenas para transferência, não armazenamento final"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar DNS MX Records para Roteamento",
                                  "subSteps": [
                                    "Explique que MX (Mail Exchange) records no DNS indicam o servidor MTA responsável por um domínio.",
                                    "Descreva a consulta DNS: para enviar para user@exemplo.com, resolva MX para exemplo.com.",
                                    "Priorize MX records por 'preference' (menor número = maior prioridade).",
                                    "Mostre formato: exemplo.com. 3600 IN MX 10 mail.exemplo.com.",
                                    "Integre com A/AAAA records para resolver o IP do MX."
                                  ],
                                  "verification": "Simule uma consulta dig mx gmail.com e interprete os resultados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta dig ou nslookup",
                                    "Documentação DNS RFC 1035"
                                  ],
                                  "tips": "Sempre verifique múltiplos MX para redundância; teste com domínios reais.",
                                  "learningObjective": "Dominar como MX records direcionam o roteamento inicial de e-mails.",
                                  "commonMistakes": [
                                    "Confundir MX com A records (MX aponta para hostnames, não IPs)",
                                    "Ignorar prioridade de MX"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o Processo de Relay e Store-and-Forward",
                                  "subSteps": [
                                    "Explique store-and-forward: MTA armazena e-mail temporariamente se destino não acessível.",
                                    "Detalhe relay entre domínios: MTA origem consulta MX destino, conecta via SMTP e transfere.",
                                    "Descreva handshake SMTP: EHLO, autenticação, MAIL FROM/RCPT TO, transmissão DATA.",
                                    "Aborde relay chains: e-mail pode passar por múltiplos MTAs (ex: seu ISP -> destino MX).",
                                    "Mencione queue management: e-mails enfileirados em spools para retry."
                                  ],
                                  "verification": "Desenhe um diagrama de relay de user@a.com para user@b.com via 2 MTAs.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta telnet para simular SMTP",
                                    "Exemplos de logs Postfix/Exim"
                                  ],
                                  "tips": "Visualize como uma cadeia de 'passa-para-frente' em um jogo de telefone sem fio.",
                                  "learningObjective": "Explicar o fluxo completo de relay interdomínios com store-and-forward.",
                                  "commonMistakes": [
                                    "Pensar que e-mail vai direto origem-destino (ignora relays)",
                                    "Confundir store-and-forward com MDA (Mail Delivery Agent)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Mecanismos de Retry e Falhas",
                                  "subSteps": [
                                    "Descreva retry: MTA tenta reenviar após falhas (ex: 4XX temporário) com backoff exponencial.",
                                    "Explique timeouts: tentativas em intervalos crescentes (5min, 30min, horas).",
                                    "Detalhe falhas permanentes (5XX): bounce message gerado e enviado de volta.",
                                    "Mencione limites: após N tentativas, e-mail é rejeitado ou devolvido.",
                                    "Discuta configurações: queue lifetime em MTAs como Postfix (default 5 dias)."
                                  ],
                                  "verification": "Interprete um log de retry SMTP e preveja o próximo passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Logs de servidor SMTP reais ou simulados",
                                    "RFC 5321 seção de erros"
                                  ],
                                  "tips": "Backoff exponencial previne sobrecarga; monitore queues para problemas.",
                                  "learningObjective": "Compreender resiliência no roteamento via retries.",
                                  "commonMistakes": [
                                    "Confundir 4XX (retry) com 5XX (falha permanente)",
                                    "Subestimar impacto de queues cheias"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule envio de email de usuario@seudominio.com para contato@gmail.com: 1) MTA origem consulta MX gmail.com (prioridade 1: gmail-smtp-in.l.google.com). 2) Conecta via SMTP, envia MAIL FROM e RCPT TO. 3) Se falha temporária, armazena e retry a cada 15min. 4) Sucesso: forwarded para MX interno do Google.",
                              "finalVerifications": [
                                "Explica corretamente o uso de MX records para roteamento inicial.",
                                "Descreve store-and-forward com exemplo de queue.",
                                "Diferencia relays inbound/outbound e chains multi-MTA.",
                                "Identifica comandos SMTP chave no processo de relay.",
                                "Explica retry backoff e distinção 4XX/5XX.",
                                "Desenha diagrama completo de fluxo interdomínios."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de MX records e prioridades (80%+ correto).",
                                "Clareza no fluxo store-and-forward e relay chains.",
                                "Correta distinção de erros SMTP e mecanismos de retry.",
                                "Uso de exemplos reais ou simulados para ilustrar conceitos.",
                                "Capacidade de troubleshooting básico (ex: por que email bounce?).",
                                "Integração de DNS com SMTP em explicação coesa."
                              ],
                              "crossCurricularConnections": [
                                "DNS e Resolução de Nomes (Redes de Computadores).",
                                "Segurança em E-mails (SPF/DKIM para prevenir relay abuse).",
                                "Programação de Redes (Implementar cliente SMTP em Python com smtplib).",
                                "Administração de Sistemas (Configurar Postfix como MTA).",
                                "Análise de Logs e Debugging (Ferramentas como tcpdump para SMTP)."
                              ],
                              "realWorldApplication": "Diagnosticar falhas de entrega de e-mails (bounces, delays), configurar servidores de email corporativos, desenvolver apps que enviam notificações via SMTP relays (ex: newsletters, alerts de sistemas), e otimizar infraestrutura para alta disponibilidade em serviços como Gmail ou AWS SES."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.6.3.3",
                            "name": "Identificar limitações e extensões do SMTP",
                            "description": "Discutir limitações como falta de autenticação nativa (usar STARTTLS/SMTP AUTH) e extensões ESMTP (EHLO), referenciando evoluções em SDN e protocolos modernos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o funcionamento básico do SMTP e identificar limitações fundamentais",
                                  "subSteps": [
                                    "Ler a RFC 5321 para entender o protocolo SMTP original (relay aberto por padrão).",
                                    "Identificar limitações como ausência de autenticação nativa e suporte a texto plano.",
                                    "Analisar riscos de relay aberto levando a spam e abusos.",
                                    "Documentar limitações em tamanho de mensagem (máx. 1MB originalmente) e falta de criptografia.",
                                    "Comparar com requisitos modernos de segurança."
                                  ],
                                  "verification": "Criar uma tabela com pelo menos 4 limitações fundamentais listadas com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 5321 (Simple Mail Transfer Protocol)",
                                    "Documentação oficial do IETF sobre SMTP",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Foquem em limitações de design original; evitem confundir com extensões posteriores.",
                                  "learningObjective": "Compreender as limitações inerentes do SMTP básico para contextualizar extensões.",
                                  "commonMistakes": [
                                    "Confundir SMTP com protocolos posteriores como SMTPS.",
                                    "Ignorar o relay aberto como principal vulnerabilidade.",
                                    "Não referenciar RFCs corretas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar mecanismos de autenticação e segurança adicionados (STARTTLS e SMTP AUTH)",
                                  "subSteps": [
                                    "Explicar SMTP AUTH (RFC 4954) como extensão para autenticação via LOGIN, PLAIN, etc.",
                                    "Descrever STARTTLS (RFC 3207) para upgrade de conexão para TLS.",
                                    "Simular uma sessão com telnet e observar falha sem AUTH.",
                                    "Analisar limitações persistentes, como dependência de extensões não obrigatórias.",
                                    "Testar com ferramenta como swaks para verificar AUTH."
                                  ],
                                  "verification": "Executar uma simulação de sessão SMTP com STARTTLS e AUTH, registrando logs de sucesso/falha.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta swaks ou telnet",
                                    "RFC 4954 (SMTP Service Extension for Authentication)",
                                    "RFC 3207 (SMTP Service Extension for Secure SMTP)",
                                    "Servidor SMTP de teste local (Postfix)"
                                  ],
                                  "tips": "Sempre use EHLO antes de AUTH; teste em ambiente isolado para evitar spam real.",
                                  "learningObjective": "Dominar como mitigar falta de autenticação nativa via extensões.",
                                  "commonMistakes": [
                                    "Usar HELO em vez de EHLO.",
                                    "Ignorar que STARTTLS é opcional e pode falhar.",
                                    "Confundir autenticação com criptografia end-to-end."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar extensões ESMTP via comando EHLO",
                                  "subSteps": [
                                    "Diferenciar HELO (SMTP básico) de EHLO (ESMTP com extensões).",
                                    "Listar extensões comuns: AUTH, STARTTLS, SIZE, 8BITMIME (RFCs correspondentes).",
                                    "Capturar tráfego com Wireshark para observar negociação de extensões.",
                                    "Avaliar limitações: extensões opcionais, incompatibilidades entre servidores.",
                                    "Documentar como EHLO habilita funcionalidades como PIPELINING (RFC 2920)."
                                  ],
                                  "verification": "Captura Wireshark mostrando EHLO response com pelo menos 5 extensões listadas e explicadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "RFC 5321 (seção ESMTP)",
                                    "Servidor SMTP acessível para teste",
                                    "Lista de RFCs ESMTP"
                                  ],
                                  "tips": "Filtre por porta 25 no Wireshark; compare respostas de diferentes servidores.",
                                  "learningObjective": "Identificar e explicar o papel das extensões ESMTP na evolução do protocolo.",
                                  "commonMistakes": [
                                    "Achar que todas as extensões são obrigatórias.",
                                    "Não diferenciar HELO de EHLO corretamente.",
                                    "Omitir RFCs específicas para cada extensão."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar evoluções modernas e alternativas ao SMTP (SDN e protocolos atuais)",
                                  "subSteps": [
                                    "Discutir limitações não resolvidas: falta de suporte nativo a IPv6 pleno, DKIM/SPF como add-ons.",
                                    "Explorar SDN (Software-Defined Networking) para gerenciamento dinâmico de relays SMTP.",
                                    "Comparar SMTP com protocolos modernos como HTTP/2 para email (ex: JMAP).",
                                    "Avaliar migrações para DMARC e impacto em ecossistemas legados.",
                                    "Prever tendências: substituição gradual por APIs baseadas em nuvem."
                                  ],
                                  "verification": "Escrever um relatório comparativo de 1 página destacando 3 evoluções modernas vs. SMTP.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação SDN (ex: OpenDaylight)",
                                    "RFC 7489 (DMARC)",
                                    "Artigos sobre JMAP (RFC 8620)",
                                    "Pesquisa sobre protocolos email modernos"
                                  ],
                                  "tips": "Use fontes recentes (pós-2020) para evoluções; foque em interoperabilidade.",
                                  "learningObjective": "Contextualizar SMTP em redes modernas e identificar caminhos de evolução.",
                                  "commonMistakes": [
                                    "Superestimar obsolescência do SMTP.",
                                    "Confundir SDN com substituição direta do SMTP.",
                                    "Ignorar adoção ampla de extensões em produção."
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um servidor Postfix local, use telnet para conectar via porta 25, envie email sem AUTH (relay rejeitado), ative STARTTLS/AUTH via config, capture com Wireshark e observe EHLO listando extensões; compare com falha em SDN simulado sem políticas dinâmicas.",
                              "finalVerifications": [
                                "Lista completa de 5+ limitações do SMTP básico com RFCs.",
                                "Demonstração prática de STARTTLS e SMTP AUTH funcionando.",
                                "Análise de pelo menos 4 extensões ESMTP via EHLO em Wireshark.",
                                "Relatório comparando SMTP com SDN e protocolos modernos.",
                                "Identificação correta de erros comuns em sessões SMTP simuladas.",
                                "Explicação de como extensões mitigam, mas não eliminam, limitações."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Referências RFC corretas e fatos verificáveis (40%).",
                                "Profundidade: Substeps detalhados e exemplos práticos (25%).",
                                "Prática: Evidências de simulações (Wireshark, swaks) (20%).",
                                "Análise crítica: Discussão de limitações persistentes e evoluções (10%).",
                                "Clareza: Estrutura organizada e linguagem acessível (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Integração com TLS, DKIM e prevenção de spam.",
                                "Redes de Computadores: Camada de aplicação e SDN para gerenciamento.",
                                "Programação: Scripts em Python para automação SMTP (smtplib).",
                                "Ética e Sociedade: Impacto de relay aberto em privacidade e abusos online."
                              ],
                              "realWorldApplication": "Em empresas, administradores usam esse conhecimento para configurar relays seguros em Postfix/Exchange, mitigar spam via AUTH+STARTTLS, integrar com SDN para roteamento dinâmico de emails, e planejar migrações para serviços como Gmail API, evitando downtime e conformidade com GDPR."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Nível de Transporte",
                "description": "Estuda os protocolos TCP e UDP, além do controle de congestionamento.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Protocolo UDP",
                    "description": "Protocolo de transporte sem conexão, não confiável, baseado em datagramas, com suporte a multiplexação via portas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Características Fundamentais do UDP",
                        "description": "O UDP é um protocolo de transporte sem conexão, não confiável e baseado em datagramas, projetado para aplicações que priorizam baixa latência sobre garantia de entrega.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Identificar o UDP como protocolo sem conexão",
                            "description": "Explicar que o UDP não estabelece conexão antes da transmissão de dados, enviando datagramas independentes sem handshakes como SYN-ACK do TCP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar protocolos de transporte e conceito de conexão",
                                  "subSteps": [
                                    "Estude a camada de transporte no modelo TCP/IP.",
                                    "Defina 'protocolo orientado a conexão' com exemplos como TCP.",
                                    "Descreva o processo de handshake de três vias (SYN, SYN-ACK, ACK).",
                                    "Liste vantagens (confiabilidade) e desvantagens (overhead e latência) de conexões.",
                                    "Anote diferenças em relação a protocolos sem conexão."
                                  ],
                                  "verification": "Crie um diagrama simples do handshake TCP e explique verbalmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação RFC 793 (TCP)",
                                    "Vídeo tutorial sobre TCP handshake",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Pense no TCP como uma 'ligação telefônica' que confirma antes de falar.",
                                  "learningObjective": "Compreender o que significa um protocolo orientado a conexão.",
                                  "commonMistakes": [
                                    "Confundir handshake com autenticação",
                                    "Ignorar o impacto na latência",
                                    "Achar que todos os protocolos usam conexão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar as características básicas do UDP",
                                  "subSteps": [
                                    "Leia a definição do UDP na RFC 768.",
                                    "Identifique que UDP usa datagramas independentes.",
                                    "Explique o cabeçalho UDP (portas origem/destino, comprimento, checksum).",
                                    "Note a ausência de sequenciamento, controle de fluxo ou confirmações.",
                                    "Registre que cada datagrama é enviado sem estado prévio."
                                  ],
                                  "verification": "Liste 4 campos do cabeçalho UDP e explique por que não há campos de conexão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 768 (UDP)",
                                    "Ferramenta Wireshark para visualizar pacotes UDP",
                                    "Notas de aula sobre camadas OSI"
                                  ],
                                  "tips": "Compare datagramas UDP a 'cartas enviadas sem aviso de recebimento'.",
                                  "learningObjective": "Memorizar as características principais do UDP.",
                                  "commonMistakes": [
                                    "Confundir UDP com TCP pelo nome similar",
                                    "Pensar que UDP tem checksum obrigatório",
                                    "Achar que UDP garante entrega"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar UDP e TCP especificamente no aspecto de conexão",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: conexão (TCP: sim; UDP: não), handshake (TCP: SYN-ACK; UDP: ausente).",
                                    "Explique por que UDP envia datagramas independentes sem estabelecimento de sessão.",
                                    "Discuta cenários onde ausência de conexão é vantajosa (baixa latência).",
                                    "Simule mentalmente envio de 3 datagramas UDP vs TCP.",
                                    "Identifique riscos do UDP (perda, duplicação, desordem)."
                                  ],
                                  "verification": "Preencha e discuta a tabela comparativa com um colega ou gravando áudio.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela em Excel ou papel",
                                    "Diagramas TCP vs UDP de sites educativos",
                                    "Simulador de rede online como Cisco Packet Tracer"
                                  ],
                                  "tips": "Use analogia: TCP é correio registrado; UDP é correio normal.",
                                  "learningObjective": "Diferenciar claramente UDP como protocolo sem conexão.",
                                  "commonMistakes": [
                                    "Achar que UDP usa handshakes leves",
                                    "Subestimar riscos da falta de conexão",
                                    "Misturar com outros protocolos como ICMP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e aplicar o conceito em exemplos práticos",
                                  "subSteps": [
                                    "Capture tráfego de rede com Wireshark filtrando UDP (ex: DNS).",
                                    "Observe ausência de pacotes SYN-ACK antes dos datagramas UDP.",
                                    "Envie datagramas UDP simples usando ferramenta como netcat.",
                                    "Analise logs para confirmar independência dos pacotes.",
                                    "Resuma em uma frase: 'UDP é sem conexão porque...'"
                                  ],
                                  "verification": "Capture e anote 5 pacotes UDP mostrando falta de handshake.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "netcat (nc) no terminal",
                                    "Servidor DNS local ou público"
                                  ],
                                  "tips": "Filtre Wireshark com 'udp' para focar no essencial.",
                                  "learningObjective": "Aplicar o conceito em observação real de tráfego.",
                                  "commonMistakes": [
                                    "Interpretar checksum como confirmação",
                                    "Confundir portas com conexões",
                                    "Não filtrar corretamente no Wireshark"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao consultar um domínio DNS (ex: dig google.com), o cliente envia um datagrama UDP para o servidor DNS sem qualquer handshake prévio; o servidor responde independentemente, demonstrando datagramas autônomos sem estado de conexão.",
                              "finalVerifications": [
                                "Explique em 1 frase por que UDP é sem conexão.",
                                "Desenhe fluxo UDP vs TCP para 2 pacotes.",
                                "Identifique 3 riscos da ausência de conexão.",
                                "Cite 2 aplicações reais de UDP.",
                                "Compare overhead de cabeçalho UDP (8 bytes) vs TCP (20+ bytes)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de 'sem conexão' (sem handshakes ou estado).",
                                "Correta comparação com TCP (handshake vs datagramas independentes).",
                                "Uso de exemplos concretos como DNS ou streaming.",
                                "Identificação de vantagens (velocidade) e desvantagens (não confiável).",
                                "Capacidade de visualizar em ferramentas como Wireshark."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de probabilidade de perda de datagramas em redes.",
                                "Física: Analogia com transmissão de ondas de rádio sem confirmação.",
                                "Segurança da Informação: Implicações de spoofing em protocolos sem autenticação.",
                                "Estatística: Análise de latência e throughput em testes de rede."
                              ],
                              "realWorldApplication": "Em jogos online multiplayer (ex: Fortnite), UDP transmite posições de jogadores em tempo real sem conexão, priorizando baixa latência sobre garantia de entrega, permitindo jogabilidade fluida mesmo com perdas ocasionais de pacotes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Descrever o UDP como não confiável",
                            "description": "Detalhar que o UDP não oferece garantia de entrega, ordenação de pacotes ou controle de erros além de um checksum opcional, diferentemente do TCP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as garantias de confiabilidade do TCP",
                                  "subSteps": [
                                    "Estude o handshake de 3 vias (SYN, SYN-ACK, ACK) para estabelecimento de conexão.",
                                    "Analise o uso de ACKs para confirmação de recebimento e retransmissão de pacotes perdidos.",
                                    "Examine números de sequência para ordenação correta dos pacotes.",
                                    "Discuta mecanismos de controle de fluxo (janela deslizante) e controle de congestão."
                                  ],
                                  "verification": "Liste verbalmente ou por escrito as 4 principais garantias do TCP (entrega, ordenação, integridade, fluxo).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama do handshake TCP",
                                    "RFC 793 (TCP)",
                                    "Vídeo explicativo sobre TCP"
                                  ],
                                  "tips": "Pense no TCP como um correio com rastreamento e confirmação de entrega.",
                                  "learningObjective": "Compreender as características que tornam o TCP confiável.",
                                  "commonMistakes": "Confundir controle de erros do TCP com o checksum simples do UDP."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a estrutura básica do UDP",
                                  "subSteps": [
                                    "Examine o cabeçalho UDP: campos de origem/destino (16 bits), comprimento (16 bits) e checksum (16 bits, opcional).",
                                    "Note a ausência de campos para controle de conexão ou sequência.",
                                    "Compare o tamanho mínimo do cabeçalho UDP (8 bytes) com TCP (20 bytes).",
                                    "Entenda que UDP é connectionless: envia datagramas sem setup prévio.",
                                    "Simule envio de um datagrama UDP sem confirmações."
                                  ],
                                  "verification": "Desenhe o cabeçalho UDP e destaque os campos ausentes em relação ao TCP.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Diagrama do cabeçalho UDP",
                                    "Ferramenta Wireshark para captura de pacotes UDP",
                                    "RFC 768 (UDP)"
                                  ],
                                  "tips": "UDP é 'fire and forget': envie e esqueça, sem espera por resposta.",
                                  "learningObjective": "Identificar a simplicidade minimalista do UDP.",
                                  "commonMistakes": "Achar que checksum garante integridade total (é opcional e básico)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar as limitações de confiabilidade do UDP",
                                  "subSteps": [
                                    "Explique ausência de garantia de entrega: pacotes podem ser perdidos sem retransmissão.",
                                    "Descreva falta de ordenação: pacotes chegam fora de ordem sem números de sequência.",
                                    "Analise controle de erros limitado: apenas checksum opcional para detecção básica de erros.",
                                    "Discuta duplicatas possíveis sem mecanismos de detecção.",
                                    "Simule cenários de perda/ordenação errada em uma rede instável."
                                  ],
                                  "verification": "Explique em 3 frases por que UDP é chamado de 'não confiável'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Simulador de rede (ex: Cisco Packet Tracer)",
                                    "Exemplos de tráfego UDP capturado"
                                  ],
                                  "tips": "Lembre: UDP prioriza velocidade sobre confiabilidade.",
                                  "learningObjective": "Articular precisamente as 3 principais limitações do UDP.",
                                  "commonMistakes": "Atribuir ao UDP recursos como ACKs, que são exclusivos do TCP."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar UDP com TCP e discutir implicações",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: entrega, ordenação, erros, overhead.",
                                    "Discuta trade-offs: UDP é mais rápido e leve, mas arriscado.",
                                    "Identifique aplicações UDP: onde perda é tolerável (streaming, jogos).",
                                    "Explique por que UDP é 'best-effort' delivery.",
                                    "Debata cenários onde usar UDP vs TCP."
                                  ],
                                  "verification": "Preencha uma tabela de comparação UDP/TCP corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela modelo UDP vs TCP",
                                    "Casos de estudo: VoIP vs FTP"
                                  ],
                                  "tips": "Use analogias: UDP é carta comum, TCP é encomenda com seguro.",
                                  "learningObjective": "Diferenciar contextos de uso baseados em confiabilidade.",
                                  "commonMistakes": "Recomendar UDP para transferências críticas de dados."
                                }
                              ],
                              "practicalExample": "Em um jogo multiplayer online como Fortnite, pacotes UDP transmitem posições de jogadores; se um pacote se perde, o jogo continua sem travar, interpolando movimentos, diferentemente de um download de arquivo via TCP que pararia até retransmissão.",
                              "finalVerifications": [
                                "Descreva sem garantia de entrega do UDP com exemplo.",
                                "Explique falta de ordenação e impacto.",
                                "Liste diferenças no controle de erros UDP vs TCP.",
                                "Identifique 3 aplicações reais de UDP.",
                                "Compare overhead de cabeçalho UDP/TCP.",
                                "Simule perda de pacote UDP em ferramenta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação das 3 limitações principais (entrega, ordenação, erros).",
                                "Uso correto de terminologia técnica (checksum opcional, connectionless).",
                                "Capacidade de comparar com TCP sem confusões.",
                                "Exemplos práticos relevantes e corretos.",
                                "Tabela ou diagrama comparativo claro e completo.",
                                "Entendimento de trade-offs (velocidade vs confiabilidade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de probabilidades de perda de pacotes em redes.",
                                "Física: Analogia com transmissão de ondas de rádio sem correção.",
                                "Segurança da Informação: Vulnerabilidades de UDP em ataques de amplificação DDoS.",
                                "Estatística: Análise de latência e jitter em tráfego UDP."
                              ],
                              "realWorldApplication": "UDP é essencial em VoIP (ex: WhatsApp chamadas), streaming de vídeo (Netflix), DNS queries e jogos online, onde baixa latência é crítica e perdas ocasionais são toleráveis, evitando o overhead do TCP."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Explicar o modelo baseado em datagramas",
                            "description": "Analisar como o UDP trata cada mensagem como um datagrama independente, sem fragmentação ou reordenação automática, ideal para transmissão best-effort.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de datagrama",
                                  "subSteps": [
                                    "Defina datagrama como uma unidade independente de dados enviada pela rede.",
                                    "Explique que datagramas não mantêm estado de conexão entre envios.",
                                    "Diferencie de streams de bytes, onde dados são contínuos e ordenados.",
                                    "Identifique componentes principais: cabeçalho UDP (8 bytes) e payload.",
                                    "Desenhe um diagrama simples de um datagrama UDP."
                                  ],
                                  "verification": "Crie um diagrama rotulado de um datagrama UDP e explique seus componentes em voz alta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Documentação RFC 768 do UDP"
                                  ],
                                  "tips": "Use analogia de cartas postais: cada uma é independente, pode se perder sem afetar outras.",
                                  "learningObjective": "Entender datagrama como mensagem autônoma sem dependências.",
                                  "commonMistakes": [
                                    "Confundir com pacotes TCP, que requerem ACKs",
                                    "Ignorar que datagramas podem chegar fora de ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o tratamento de mensagens no UDP",
                                  "subSteps": [
                                    "Descreva como UDP encapsula cada mensagem em um datagrama separado.",
                                    "Explique ausência de fragmentação: UDP envia como está, IP pode fragmentar.",
                                    "Discuta falta de reordenação: receptor deve lidar com ordem se necessário.",
                                    "Simule envio de múltiplos datagramas com Wireshark ou ferramenta similar.",
                                    "Observe checksum para detecção de erros, mas sem retransmissão."
                                  ],
                                  "verification": "Capture tráfego UDP e identifique datagramas independentes em uma ferramenta de rede.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Servidor local para testes UDP (ex: netcat)"
                                  ],
                                  "tips": "Teste enviando datagramas desordenados para ver chegada fora de sequência.",
                                  "learningObjective": "Dominar independência e best-effort do UDP.",
                                  "commonMistakes": [
                                    "Achar que UDP garante entrega",
                                    "Confundir fragmentação UDP com IP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar modelo de datagramas com alternativas",
                                  "subSteps": [
                                    "Compare UDP (datagrama, sem conexão) vs TCP (stream, orientado a conexão).",
                                    "Liste cenários onde best-effort é ideal: baixa latência sobre confiabilidade.",
                                    "Explique overhead mínimo do UDP: apenas 8 bytes de cabeçalho.",
                                    "Discuta implicações: duplicatas possíveis, perdas sem recuperação.",
                                    "Crie tabela comparativa UDP vs TCP."
                                  ],
                                  "verification": "Preencha tabela comparativa e justifique 3 cenários de uso UDP.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Referências de protocolos de transporte"
                                  ],
                                  "tips": "Lembre: UDP para 'fire and forget', TCP para 'garantido'.",
                                  "learningObjective": "Diferenciar modelos e escolher uso apropriado.",
                                  "commonMistakes": [
                                    "Superestimar confiabilidade UDP",
                                    "Ignorar checksum como única proteção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar compreensão do modelo",
                                  "subSteps": [
                                    "Implemente cliente/servidor UDP simples em Python.",
                                    "Envie mensagens fora de ordem e observe no receptor.",
                                    "Meça latência vs TCP no mesmo cenário.",
                                    "Analise logs para perdas e duplicatas.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Execute código e produza relatório com capturas de tela de datagramas independentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com socket library",
                                    "Ambiente de teste local"
                                  ],
                                  "tips": "Use timestamps nos datagramas para rastrear ordem.",
                                  "learningObjective": "Aplicar teoricamente em prática hands-on.",
                                  "commonMistakes": [
                                    "Não randomizar ordem/portas",
                                    "Usar TCP por engano"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um jogo online multiplayer, posições de jogadores são enviadas via UDP como datagramas independentes. Se um datagrama se perde (jogador pula frame), o próximo corrige visualmente sem parar o jogo, priorizando fluidez sobre perfeição.",
                              "finalVerifications": [
                                "Explique verbalmente 3 diferenças chave entre datagrama UDP e stream TCP.",
                                "Desenhe e rotule estrutura de um datagrama UDP.",
                                "Identifique 2 cenários onde modelo best-effort é preferível.",
                                "Simule perda de datagrama e descreva impacto no receptor.",
                                "Compare overhead de cabeçalho UDP vs TCP.",
                                "Liste limitações do modelo de datagramas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de datagrama independente (sem estado).",
                                "Correta descrição de ausência de reordenação/fragmentação automática.",
                                "Uso de analogias ou diagramas claros para ilustrar best-effort.",
                                "Identificação precisa de vantagens (baixa latência) e desvantagens (perdas).",
                                "Aplicação prática via simulação ou código demonstrável.",
                                "Diferenciação clara de TCP em comparação.",
                                "Compreensão de checksum como única verificação básica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade de perda de pacotes em redes não confiáveis.",
                                "Física: Analogia com propagação de ondas/partículas independentes.",
                                "Programação: Implementação de sockets em linguagens como Python/C.",
                                "Estatística: Análise de latência e throughput em testes.",
                                "Segurança: Implicações de best-effort em ataques de negação de serviço."
                              ],
                              "realWorldApplication": "UDP é usado em VoIP (ex: Zoom chamadas), streaming de vídeo (Netflix), consultas DNS e jogos online (Fortnite), onde latência baixa é crítica e perdas ocasionais são toleráveis, permitindo transmissão em tempo real sem overhead de reconexão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Estrutura do Cabeçalho UDP",
                        "description": "O cabeçalho UDP é compacto com 8 bytes, contendo campos essenciais para identificação e verificação básica de integridade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Descrever os campos do cabeçalho UDP",
                            "description": "Listar e explicar os 4 campos: porta de origem (16 bits), porta de destino (16 bits), comprimento (16 bits) e checksum (16 bits).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura geral do cabeçalho UDP",
                                  "subSteps": [
                                    "Pesquise o RFC 768 para ler a definição oficial do protocolo UDP.",
                                    "Identifique que o cabeçalho UDP tem exatamente 8 bytes (64 bits) fixos.",
                                    "Visualize um diagrama do cabeçalho mostrando os 4 campos em sequência.",
                                    "Anote o tamanho total e a ausência de opções variáveis, diferentemente do TCP.",
                                    "Compare brevemente com o cabeçalho TCP para destacar diferenças."
                                  ],
                                  "verification": "Desenhe ou anote um diagrama simples do cabeçalho UDP com tamanhos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "RFC 768 (disponível online), diagramas de cabeçalho UDP em sites como Wireshark wiki ou tutorials de redes.",
                                  "tips": "Use um editor de imagens ou papel para esboçar o diagrama; memorize que UDP é 'header-only' sem flags.",
                                  "learningObjective": "Compreender a composição fixa de 8 bytes do cabeçalho UDP e sua simplicidade.",
                                  "commonMistakes": "Confundir o tamanho do cabeçalho UDP (8 bytes) com TCP (20+ bytes); assumir campos variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever os campos de porta de origem e destino",
                                  "subSteps": [
                                    "Explique que ambos são campos de 16 bits (0-65535), representando portas lógicas.",
                                    "Detalhe a porta de origem: identifica o processo/app remetente no host de origem.",
                                    "Detalhe a porta de destino: indica o processo/app receptor no host destino.",
                                    "Estude exemplos: porta 53 para DNS, 123 para NTP.",
                                    "Pratique convertendo portas decimais para hex/binário para visualização em pacotes."
                                  ],
                                  "verification": "Liste 3 exemplos de portas comuns UDP e explique origem vs destino em uma frase cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Lista de portas IANA (iana.org/assignments/service-names-port-numbers), calculadora binária online.",
                                  "tips": "Lembre: portas <1024 são privilegiadas; use 'source port' para replies em cenários client-server.",
                                  "learningObjective": "Diferenciar e explicar funções das portas de origem e destino no roteamento de dados UDP.",
                                  "commonMistakes": "Confundir origem/destino (origem é do remetente); achar que portas são IPs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o campo de comprimento",
                                  "subSteps": [
                                    "Identifique que é um campo de 16 bits indicando o tamanho total do datagrama UDP em bytes (header + data).",
                                    "Calcule exemplos: header 8 bytes + 20 bytes data = comprimento 28.",
                                    "Note o mínimo: 8 bytes (sem dados); máximo: 65535 bytes.",
                                    "Diferencie de TCP: UDP inclui header no comprimento.",
                                    "Pratique com cenários: DNS query típica tem comprimento ~40 bytes."
                                  ],
                                  "verification": "Calcule o comprimento para um datagrama com 100 bytes de dados e verifique (108).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora, exemplos de pacotes UDP de Wireshark captures.",
                                  "tips": "Sempre inclua os 8 bytes do header; útil para detectar truncamentos em rede.",
                                  "learningObjective": "Calcular e interpretar o campo comprimento para validar integridade do datagrama.",
                                  "commonMistakes": "Excluir header do cálculo; confundir com tamanho de payload apenas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o campo checksum",
                                  "subSteps": [
                                    "Descreva como campo de 16 bits opcional para verificação de erros (pode ser zero).",
                                    "Entenda o cálculo: soma de palavras de 16 bits do header + data + pseudo-header IP, com wrap-around.",
                                    "Saiba que é checksum de fim-a-fim, mas UDP permite ignorar (zero).",
                                    "Compare com TCP: UDP checksum é fraco, sem sequência/ACK.",
                                    "Pratique: identifique checksum em um capture Wireshark e valide manualmente um simples."
                                  ],
                                  "verification": "Explique em 2 frases por que o checksum UDP é opcional e liste componentes do pseudo-header.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Wireshark para captures UDP, RFC 768 seção sobre checksum, calculadora de checksum UDP online.",
                                  "tips": "Ative checksum em Wireshark para ver validações; lembre pseudo-header inclui IPs origem/destino.",
                                  "learningObjective": "Compreender o mecanismo e opcionalidade do checksum UDP para detecção de erros.",
                                  "commonMistakes": "Achar checksum obrigatório; ignorar pseudo-header no cálculo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e visualizar todos os campos do cabeçalho",
                                  "subSteps": [
                                    "Monte uma tabela com campo, bits, função e exemplo para os 4 campos.",
                                    "Capture ou baixe um pacote UDP real (ex: DNS query) e rotule cada campo.",
                                    "Crie um diagrama completo com valores hexadecimais de um exemplo.",
                                    "Explique fluxo: como campos são usados em envio/recepção UDP.",
                                    "Teste conhecimento respondendo perguntas sobre cada campo."
                                  ],
                                  "verification": "Produza uma tabela/diagrama rotulado de um cabeçalho UDP exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Wireshark, papel/caneta ou ferramenta como draw.io, exemplo de pacote UDP hex dump.",
                                  "tips": "Use nslookup para gerar tráfego DNS UDP real; foque em ordem: src port, dst port, len, checksum.",
                                  "learningObjective": "Sintetizar descrição completa dos 4 campos em contexto prático.",
                                  "commonMistakes": "Ordem errada dos campos; omitir unidades (bits/bytes)."
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture uma consulta DNS (UDP porta 53): identifique porta origem (ephemara, ex: 54321), destino (53), comprimento (ex: 42 bytes), checksum (ex: 0x1234). Explique cada campo baseado nos valores reais.",
                              "finalVerifications": [
                                "Liste os 4 campos com tamanhos exatos em bits.",
                                "Explique função da porta origem vs destino com exemplo.",
                                "Calcule comprimento para header + 50 bytes data.",
                                "Descreva quando checksum pode ser zero e por quê.",
                                "Desenhe diagrama linear dos 8 bytes do cabeçalho.",
                                "Diferencie UDP header de TCP em 3 pontos chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tamanhos (16 bits cada campo).",
                                "Correção nas funções: portas para mux/demux, len para tamanho total, checksum para erro.",
                                "Uso de exemplos reais/concretos (portas IANA, cálculos numéricos).",
                                "Clareza em diagramas/tabelas com ordem e rótulos corretos.",
                                "Compreensão de opcionalidade e diferenças com TCP.",
                                "Capacidade de aplicar em capture Wireshark."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão decimal-hex-binário para portas e cálculos de soma/checksum.",
                                "Física: Transmissão de dados em redes como ondas eletromagnéticas com detecção de erros.",
                                "Inglês: Leitura de RFCs técnicos e terminologia padrão (source port, checksum).",
                                "Segurança da Informação: Entender limitações do checksum UDP em cibersegurança."
                              ],
                              "realWorldApplication": "Em aplicações como jogos multiplayer (ex: Fortnite usa UDP para baixa latência), VoIP (Zoom chamadas), ou DNS queries rápidas, onde descrever o cabeçalho UDP ajuda em troubleshooting de rede, análise de tráfego com Wireshark, ou desenvolvimento de apps cliente-servidor leves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Interpretar portas de origem e destino",
                            "description": "Explicar como as portas (números de 0 a 65535) identificam processos específicos em hosts fonte e destino para comunicação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Portas de Rede",
                                  "subSteps": [
                                    "Defina o que é uma porta de rede: um número de 16 bits (0-65535) usado para identificar processos ou aplicações em um host.",
                                    "Explique a diferença entre portas bem-conhecidas (0-1023), registradas (1024-49151) e efêmeras (49152-65535).",
                                    "Discuta como portas permitem multiplexação: múltiplas conexões simultâneas em um único IP.",
                                    "Identifique exemplos comuns: porta 53 para DNS, 123 para NTP (ambos UDP).",
                                    "Visualize portas como 'apartamentos' em um 'prédio' (endereço IP)."
                                  ],
                                  "verification": "Resuma em uma frase o papel das portas e liste 3 exemplos de portas UDP comuns.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama de camadas TCP/IP, tabela de portas IANA (iana.org/assignments/service-names-port-numbers).",
                                  "tips": "Use analogias cotidianas como portas de casas para fixar o conceito.",
                                  "learningObjective": "Entender portas como identificadores de processos em hosts de rede.",
                                  "commonMistakes": "Confundir portas com endereços IP; portas identificam processos, não hosts."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Estrutura do Cabeçalho UDP",
                                  "subSteps": [
                                    "Descreva o cabeçalho UDP: 8 bytes com Fonte Port (16 bits), Destino Port (16 bits), Length (16 bits), Checksum (16 bits).",
                                    "Localize as portas: bytes 0-1 (origem), bytes 2-3 (destino).",
                                    "Converta números decimais para hex e binário para visualizar (ex: 53 decimal = 0x0035).",
                                    "Explique ordem dos campos: origem primeiro, depois destino.",
                                    "Compare com TCP: estrutura similar, mas UDP sem flags de controle."
                                  ],
                                  "verification": "Desenhe o cabeçalho UDP e rotule as posições das portas origem e destino.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama do cabeçalho UDP (RFC 768), calculadora binária/hexadecimal online.",
                                  "tips": "Memorize: 'Origem fala primeiro, destino escuta depois'.",
                                  "learningObjective": "Identificar e descrever a posição exata das portas no cabeçalho UDP.",
                                  "commonMistakes": "Inverter ordem das portas; origem é sempre a primeira no cabeçalho."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Portas Origem e Destino em Comunicação",
                                  "subSteps": [
                                    "Explique porta origem: identifica processo no host remetente (geralmente efêmera para cliente).",
                                    "Explique porta destino: identifica serviço no host receptor (geralmente bem-conhecida).",
                                    "Descreva fluxo: cliente envia de porta efêmera para porta serviço; resposta inverte.",
                                    "Discuta stateless UDP: sem conexão, portas guiam datagramas independentes.",
                                    "Analise impacto: porta errada = pacote descartado no receptor."
                                  ],
                                  "verification": "Dada uma descrição de tráfego, identifique qual porta é origem/destino e seu tipo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de fluxos UDP (DNS query/response), vídeo explicativo sobre UDP (Khan Academy ou Cisco Networking Academy).",
                                  "tips": "Pense em conversa: origem é 'quem fala', destino é 'para quem'.",
                                  "learningObjective": "Diferenciar funções de portas origem e destino na comunicação UDP.",
                                  "commonMistakes": "Achar que origem é sempre fixa; em clientes, é dinâmica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Interpretação com Análise de Pacotes",
                                  "subSteps": [
                                    "Capture tráfego UDP real ou simule com Wireshark/tshark.",
                                    "Identifique portas em um pacote DNS: origem efêmera (ex: 54321), destino 53.",
                                    "Trace resposta: origem 53, destino efêmera original.",
                                    "Calcule tamanhos: confirme 16 bits por porta.",
                                    "Registre observações em tabela: pacote #, origem, destino, serviço."
                                  ],
                                  "verification": "Analise 3 pacotes UDP e explique interpretação das portas em relatório curto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Wireshark (gratuito), arquivo pcap de tráfego DNS/UDP (ex: samplecaptures.com).",
                                  "tips": "Filtre 'udp.port == 53' no Wireshark para foco.",
                                  "learningObjective": "Aplicar conhecimento para interpretar portas em pacotes reais UDP.",
                                  "commonMistakes": "Ignorar endianness; Wireshark mostra big-endian corretamente."
                                }
                              ],
                              "practicalExample": "Em uma consulta DNS UDP: cliente (192.168.1.10:49152) envia para servidor (8.8.8.8:53). Cabeçalho UDP mostra origem 49152 (efêmera), destino 53 (DNS). Resposta: origem 53, destino 49152, garantindo entrega ao processo correto.",
                              "finalVerifications": [
                                "Explica corretamente o range 0-65535 e tipos de portas.",
                                "Desenha e rotula cabeçalho UDP com posições das portas.",
                                "Diferencia origem (remetente/processo cliente) de destino (serviço/receptor).",
                                "Analisa exemplo real de pacote UDP identificando portas.",
                                "Descreve impacto de porta incorreta na comunicação.",
                                "Lista 3 serviços UDP e suas portas padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do range e estrutura das portas (16 bits cada).",
                                "Correta diferenciação entre portas origem e destino com exemplos.",
                                "Uso correto de terminologia (multiplexação, efêmera, bem-conhecida).",
                                "Análise prática de pacotes demonstrando interpretação.",
                                "Explicação clara do fluxo bidirecional em UDP stateless.",
                                "Identificação de erros comuns evitados na resposta."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão decimal-hex-binário para portas (sistemas numéricos).",
                                "Física: Analogia com multiplexação de sinais em ondas de rádio.",
                                "Inglês: Vocabulário técnico (source port, destination port, demultiplexing).",
                                "Segurança da Informação: Portas em firewalls e scanning (ex: nmap)."
                              ],
                              "realWorldApplication": "Em streaming de vídeo (ex: VoIP via UDP porta 5004) ou jogos online (QUIC/UDP 443), portas origem/destino roteiam dados em tempo real para apps corretos, evitando atrasos em redes com múltiplos dispositivos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Calcular e verificar o checksum UDP",
                            "description": "Demonstrar o cálculo do checksum usando soma de palavras de 16 bits no cabeçalho, dados e pseudo-cabeçalho IP, com complemento de 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir o Pseudo-Cabeçalho IP",
                                  "subSteps": [
                                    "Identifique os campos necessários: endereço IP de origem (32 bits), IP de destino (32 bits), zero (8 bits), protocolo (UDP=17, 8 bits), comprimento UDP (16 bits).",
                                    "Converta os endereços IP para hexadecimal (ex: 192.168.1.1 = C0A80101).",
                                    "Monte o pseudo-cabeçalho como uma sequência de 12 bytes: srcIP (4B), dstIP (4B), zero+protocolo (2B), UDP length (2B).",
                                    "Verifique se o comprimento UDP inclui cabeçalho (8 bytes) + dados.",
                                    "Anote em papel ou ferramenta para visualização."
                                  ],
                                  "verification": "Confirme que o pseudo-cabeçalho tem exatamente 96 bits (12 bytes) e todos os campos estão corretos em hex.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora hexadecimal",
                                    "Diagrama de pseudo-cabeçalho UDP"
                                  ],
                                  "tips": "Sempre defina checksum UDP como 0000 inicialmente para cálculo.",
                                  "learningObjective": "Compreender e montar corretamente o pseudo-cabeçalho IP usado no checksum UDP.",
                                  "commonMistakes": [
                                    "Esquecer de padronizar para little-endian se aplicável",
                                    "Erro na conversão IP para hex",
                                    "Incluir checksum UDP no pseudo-cabeçalho"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Cabeçalho UDP e Dados",
                                  "subSteps": [
                                    "Liste os campos do cabeçalho UDP: porta origem (16 bits), porta destino (16 bits), comprimento (16 bits), checksum (defina como 0000).",
                                    "Converta portas e comprimento para hex (ex: porta 12345 = 3039).",
                                    "Adicione os dados do payload, padding com zeros se necessário para múltiplo de 2 bytes.",
                                    "Concatene cabeçalho UDP (8 bytes) + dados.",
                                    "Verifique o comprimento total UDP para matching com pseudo-cabeçalho."
                                  ],
                                  "verification": "O cabeçalho UDP tem 8 bytes com checksum=0000, e dados padded corretamente para words pares.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor hex como HxD ou online tool",
                                    "Exemplo de pacote UDP"
                                  ],
                                  "tips": "Use comprimento UDP = 8 + tamanho dados; pad com 0 se ímpar.",
                                  "learningObjective": "Preparar com precisão o cabeçalho UDP e dados para inclusão no checksum.",
                                  "commonMistakes": [
                                    "Definir checksum diferente de 0000",
                                    "Não padding dados para bytes pares",
                                    "Erro em portas hex"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Concatenar e Dividir em Palavras de 16 Bits",
                                  "subSteps": [
                                    "Concatene: pseudo-cabeçalho (12B) + cabeçalho UDP (8B) + dados (N B).",
                                    "Divida a sequência total em palavras de 16 bits (2 bytes cada), da esquerda para direita.",
                                    "Se último word incompleto, pad com 0 à direita.",
                                    "Liste todas as words em hex (ex: 4500, 0037, etc.).",
                                    "Conte o número total de words."
                                  ],
                                  "verification": "Sequência concatenada dividida corretamente em words de 16 bits sem overlap ou gaps.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para soma hex",
                                    "Ferramenta online Wireshark para validar"
                                  ],
                                  "tips": "Trabalhe sempre em hexadecimal para somas de 16 bits.",
                                  "learningObjective": "Formar a lista completa de words de 16 bits para soma.",
                                  "commonMistakes": [
                                    "Ordem errada de concatenação",
                                    "Padding errado no final",
                                    "Misturar bytes high/low"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Soma e Checksum Final",
                                  "subSteps": [
                                    "Some todas as words de 16 bits em hexadecimal.",
                                    "Adicione carry-over: some o carry (parte alta > FFFF) à soma low.",
                                    "Repita soma até uma única word de 16 bits.",
                                    "Calcule checksum = ~soma (one's complement: inverta bits).",
                                    "Para verificação: some todas words incluindo checksum recebido; resultado deve ser FFFF."
                                  ],
                                  "verification": "Soma final + checksum = FFFF (verificação perfeita).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora programável ou Python snippet para soma hex",
                                    "Tabela de one's complement"
                                  ],
                                  "tips": "Use soma modular: soma % 0x10000 + carry.",
                                  "learningObjective": "Executar cálculo preciso do checksum UDP com verificação.",
                                  "commonMistakes": [
                                    "Esquecer carry-over",
                                    "Erro no one's complement (~ em vez de -1)",
                                    "Não verificar soma final"
                                  ]
                                }
                              ],
                              "practicalExample": "Para pacote UDP: Src IP 192.168.1.100 (C0A80164), Dst 8.8.8.8 (08080808), Protocol 17, UDP Len 28 (001C). UDP: Src Port 12345 (3039), Dst 53 (0035), Len 28 (001C), Checksum 0000, Dados 'PING' (50494E4700). Concat: pseudo + UDP + data → words: C0A8,0164,0808,0808,0000,1100,1C30,3930,3500,1C00,0000,5049,4E47,0000. Soma com carry: 9B0F → Checksum = 64F0. Verificação: soma + 64F0 = FFFF.",
                              "finalVerifications": [
                                "Todas words somam corretamente com carry-over para uma word única.",
                                "Checksum calculado é o one's complement exato da soma.",
                                "Verificação: soma incluindo checksum proposto resulta em 0xFFFF.",
                                "Comprimentos e endereços IP matching no pseudo-cabeçalho.",
                                "Dados padded corretamente para words pares.",
                                "Conversões hex sem erros em portas/IP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na soma hexadecimal com carry (90% correto).",
                                "Checksum final matches valor esperado em exemplo padrão.",
                                "Explicação clara do processo de one's complement.",
                                "Identificação correta de erros comuns em verificação.",
                                "Uso adequado de pseudo-cabeçalho sem omissões.",
                                "Tempo de execução dentro do estimado com acurácia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e operações bitwise (one's complement).",
                                "Segurança da Informação: Detecção de erros de transmissão e integridade de dados.",
                                "Física: Transmissão de sinais digitais e ruído em redes.",
                                "Programação: Implementação em código (Python sockets ou C).",
                                "Matemática Discreta: Somas em anel Z/65536Z."
                              ],
                              "realWorldApplication": "Em roteadores e hosts para validar pacotes UDP recebidos, detectando corrupção por ruído em cabos/WiFi; usado em DNS (port 53), DHCP, VoIP (ex: Zoom), streaming (Netflix UDP), evitando retransmissões desnecessárias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Multiplexação e Demultiplexação via Portas",
                        "description": "O UDP utiliza portas para permitir que múltiplas aplicações compartilhem o transporte em um único host.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Explicar multiplexação no UDP",
                            "description": "Descrever como o remetente adiciona portas no cabeçalho para multiplexar datagramas de diferentes sockets em um fluxo IP único.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de sockets e portas em UDP",
                                  "subSteps": [
                                    "Definir o que é um socket em redes: combinação de IP e porta.",
                                    "Explicar que portas são identificadores numéricos de 16 bits (0-65535).",
                                    "Diferenciar portas efêmeras (clientes) de portas bem-conhecidas (servidores).",
                                    "Entender que UDP é sem conexão, permitindo datagramas independentes.",
                                    "Discutir por que portas são essenciais para identificar aplicações."
                                  ],
                                  "verification": "Desenhar um diagrama simples mostrando IP + porta para dois sockets diferentes no mesmo host.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Documentação UDP da RFC 768"
                                  ],
                                  "tips": [
                                    "Use exemplos reais de portas: 53 para DNS, 123 para NTP.",
                                    "Lembre-se: portas evitam confusão em hosts com múltiplas aplicações."
                                  ],
                                  "learningObjective": "Identificar o papel das portas como multiplexadores de aplicações sobre IP.",
                                  "commonMistakes": [
                                    "Confundir socket com conexão TCP.",
                                    "Achar que portas são exclusivas por IP globalmente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a estrutura do cabeçalho UDP",
                                  "subSteps": [
                                    "Descrever os 8 bytes do cabeçalho: porta fonte (2 bytes), porta destino (2 bytes), comprimento (2 bytes), checksum (2 bytes).",
                                    "Explicar que portas fonte e destino são adicionadas pelo remetente.",
                                    "Mostrar um exemplo de cabeçalho em hexadecimal ou binário.",
                                    "Destacar que sem portas, todos datagramas seriam indistinguíveis no IP.",
                                    "Comparar brevemente com IP header (sem portas de aplicação)."
                                  ],
                                  "verification": "Montar um cabeçalho UDP fictício com portas específicas e calcular o comprimento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark para capturar pacotes UDP",
                                    "Editor de texto para simular headers"
                                  ],
                                  "tips": [
                                    "Porta fonte é escolhida dinamicamente pelo SO; destino é fixa para o serviço.",
                                    "Checksum protege integridade, mas não ordem."
                                  ],
                                  "learningObjective": "Mapear campos do cabeçalho UDP e seu papel na multiplexação.",
                                  "commonMistakes": [
                                    "Omitir porta fonte (essencial para resposta).",
                                    "Confundir comprimento com checksum."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o processo de multiplexação no remetente",
                                  "subSteps": [
                                    "Descrever como aplicação cria socket UDP com bind() para porta específica.",
                                    "Explicar que ao enviar, o SO adiciona porta fonte e destino no header UDP.",
                                    "Mostrar como múltiplos sockets no mesmo host usam o mesmo IP mas portas diferentes, criando fluxo único IP.",
                                    "Ilustrar com dois sockets: socket A (porta 5000) e B (porta 5001) enviando para servidor porta 53.",
                                    "Enfatizar que IP entrega ao destino correto, ignorando multiplexação interna UDP."
                                  ],
                                  "verification": "Simular em pseudocódigo o envio de dois datagramas de sockets diferentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo ou Python socket library docs",
                                    "Ferramenta como netcat para testes UDP"
                                  ],
                                  "tips": [
                                    "Multiplexação é 'one-to-many': um IP carrega muitos fluxos via portas.",
                                    "Teste com netcat: nc -u -p 5000 host 53."
                                  ],
                                  "learningObjective": "Descrever mecanicamente como portas habilitam multiplexação de datagramas.",
                                  "commonMistakes": [
                                    "Pensar que UDP estabelece conexão (não, é datagrama).",
                                    "Ignorar que portas são no layer transporte."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar compreensão com demultiplexação complementar",
                                  "subSteps": [
                                    "Explicar brevemente demultiplexação no receptor: usa porta destino para rotear ao socket correto.",
                                    "Mostrar ciclo completo: multiplex no sender -> IP -> demultiplex no receiver.",
                                    "Discutir conflitos de porta e uso de SO para alocação.",
                                    "Simular perda de pacote e por que UDP não garante entrega.",
                                    "Reforçar que multiplexação permite eficiência sem overhead de conexão."
                                  ],
                                  "verification": "Explicar oralmente ou por escrito o fluxo completo de dois datagramas multiplexados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de fluxo sender-receiver",
                                    "Vídeo tutorial Wireshark UDP"
                                  ],
                                  "tips": [
                                    "Demultiplex usa tupla (IP destino, porta destino).",
                                    "Portas efêmeras evitam colisões."
                                  ],
                                  "learningObjective": "Integrar multiplexação com demultiplexação para visão completa UDP.",
                                  "commonMistakes": [
                                    "Confundir UDP com TCP multiplexing (TCP usa 4-tupla).",
                                    "Achar que receptor não precisa de portas fonte."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor DNS (porta 53), múltiplos clientes enviam queries UDP de portas efêmeras diferentes (ex: cliente1 porta 49152, cliente2 porta 49153). O servidor recebe datagramas no mesmo IP/53, mas usa porta destino 53 e IP origem + porta fonte para demultiplexar e responder corretamente a cada um.",
                              "finalVerifications": [
                                "Desenhar e rotular um cabeçalho UDP com portas fonte/destino destacadas.",
                                "Explicar verbalmente como dois sockets multiplexam em um IP.",
                                "Identificar portas em um Wireshark capture de tráfego UDP.",
                                "Simular envio UDP com netcat usando portas específicas.",
                                "Diferenciar multiplexação UDP de IP.",
                                "Prever comportamento se porta fonte for omitida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos campos de porta no header UDP.",
                                "Clareza na explicação do processo de adição de portas pelo remetente.",
                                "Uso correto de terminologia (socket, datagrama, multiplexação).",
                                "Capacidade de ilustrar com diagramas ou exemplos concretos.",
                                "Compreensão da independência de datagramas UDP.",
                                "Identificação de limitações (sem garantia de entrega)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação binária de portas (16 bits, 2^16 valores).",
                                "Programação: Implementação de sockets UDP em linguagens como Python ou C.",
                                "Física: Analogia com multiplexação de sinais em telecomunicações.",
                                "Segurança: Vulnerabilidades como spoofing de portas UDP."
                              ],
                              "realWorldApplication": "Na transmissão de vídeo streaming (ex: QUIC sobre UDP) ou jogos online, multiplexação permite que múltiplos fluxos de usuários sejam enviados sobre um único endereço IP, otimizando largura de banda e reduzindo latência em aplicações sem conexão confiável."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Descrever demultiplexação no receptor",
                            "description": "Explicar como o receptor usa a porta de destino para entregar o datagrama ao socket/processo correto, sem estado de conexão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura do cabeçalho UDP e o conceito de datagrama",
                                  "subSteps": [
                                    "Identifique os campos principais do cabeçalho UDP: porta de origem (source port), porta de destino (destination port), comprimento e checksum.",
                                    "Explique que um datagrama UDP é uma unidade de dados sem conexão, contendo apenas endereço IP de origem/destino e portas.",
                                    "Desenhe ou visualize um diagrama simples do cabeçalho UDP destacando as portas.",
                                    "Compare brevemente com TCP para notar a ausência de estado de conexão.",
                                    "Liste exemplos de aplicações UDP que usam datagramas (ex: DNS, DHCP)."
                                  ],
                                  "verification": "Desenhe o cabeçalho UDP corretamente e explique verbalmente o papel das portas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama de cabeçalho UDP (de livro ou online), Wireshark para captura de pacotes UDP.",
                                  "tips": "Use Wireshark para capturar um pacote DNS real e inspecione as portas.",
                                  "learningObjective": "Compreender a composição do datagrama UDP e o papel das portas de origem e destino.",
                                  "commonMistakes": "Confundir portas UDP com endereços IP; achar que UDP tem handshake como TCP."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o fluxo de chegada do datagrama no receptor",
                                  "subSteps": [
                                    "Descreva como o datagrama chega à interface de rede e é processado pela pilha IP.",
                                    "Explique que a camada IP remove o cabeçalho IP, expondo o cabeçalho UDP.",
                                    "Detalhe o papel do kernel do SO na entrega do datagrama para a camada de transporte.",
                                    "Identifique que o receptor não mantém estado de conexão, diferentemente do TCP.",
                                    "Simule o fluxo com um diagrama: NIC -> IP -> UDP -> Socket."
                                  ],
                                  "verification": "Crie um fluxograma do caminho do datagrama do hardware até o processo de aplicação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta para fluxograma, tutorial online sobre pilha TCP/IP.",
                                  "tips": "Pense no kernel como um 'porteiro' que lê o endereço no envelope (porta destino).",
                                  "learningObjective": "Mapear o caminho do datagrama UDP desde a recepção até a camada de aplicação.",
                                  "commonMistakes": "Ignorar o papel da camada IP na entrega inicial; assumir verificação de ACKs em UDP."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o mecanismo de demultiplexação usando a porta de destino",
                                  "subSteps": [
                                    "Defina demultiplexação: processo de rotear o datagrama para o socket correto baseado na porta destino.",
                                    "Descreva como sockets são 'bindados' a portas específicas (ex: bind(porta 53) para DNS server).",
                                    "Explique que o kernel mantém uma tabela de sockets ativos mapeados por (IP destino, porta destino).",
                                    "Discuta o que acontece se múltiplos processos escutam na mesma porta (geralmente um só bind por porta/IP).",
                                    "Ilustre com pseudocódigo: if (destination_port == socket.port) deliver_to(socket)."
                                  ],
                                  "verification": "Escreva um parágrafo descrevendo o algoritmo de demultiplexação e teste com um cenário hipotético.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Pseudocódigo de sockets UDP (ex: Python socket library docs), tabela de sockets exemplo.",
                                  "tips": "Lembre: porta destino é como o número do apartamento em um prédio (IP é o prédio).",
                                  "learningObjective": "Dominar como a porta destino permite entrega precisa sem estado de conexão.",
                                  "commonMistakes": "Confundir multiplexação (envio) com demultiplexação (recepção); ignorar binding de sockets."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar cenários e exceções na demultiplexação UDP",
                                  "subSteps": [
                                    "Analise um cenário: servidor UDP em porta 12345 recebe datagrama para porta 54321 (drop ou ICMP).",
                                    "Discuta wildcard binding (porta 0 ou INADDR_ANY) e como afeta demultiplexação.",
                                    "Explique tratamento de erros: checksum falho leva a discard silencioso.",
                                    "Compare com broadcast/multicast UDP e demultiplexação para múltiplos receptores.",
                                    "Teste conceitualmente: múltiplos clientes enviando para mesma porta servidor."
                                  ],
                                  "verification": "Resolva 3 cenários hipotéticos de entrega ou falha de datagramas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de código UDP server/client (Python ou C), documentação RFC 768 (UDP).",
                                  "tips": "Use ferramentas como netcat (nc -u) para testar envios UDP reais.",
                                  "learningObjective": "Aplicar o conceito de demultiplexação em cenários reais e edge cases.",
                                  "commonMistakes": "Achar que UDP garante entrega (best-effort); confundir com roteamento IP."
                                }
                              ],
                              "practicalExample": "Em um servidor DNS UDP (porta 53), um datagrama chega com IP destino do servidor e porta 53. O kernel verifica sockets bindados à porta 53, entrega os dados DNS ao processo 'named', que responde sem rastrear conexões individuais, permitindo milhares de queries simultâneas de clientes diferentes.",
                              "finalVerifications": [
                                "Desenhe e explique o fluxograma completo de demultiplexação UDP.",
                                "Diferencie corretamente multiplexação no transmissor vs. demultiplexação no receptor.",
                                "Descreva verbalmente o papel da porta destino em 30 segundos.",
                                "Resolva um cenário: o que acontece se porta destino não matcha nenhum socket?",
                                "Compare UDP demultiplexação com TCP (sequência numbers vs. portas).",
                                "Capture e analise um pacote UDP real com Wireshark, identificando portas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do uso da porta destino para roteamento (90% correto).",
                                "Clareza no fluxograma ou diagrama de demultiplexação (todos passos visíveis).",
                                "Correta distinção entre UDP sem estado e TCP com conexão.",
                                "Inclusão de exemplos práticos como DNS ou DHCP.",
                                "Identificação de pelo menos 3 edge cases (ex: porta não bindada, checksum erro).",
                                "Uso correto de terminologia (datagrama, socket, binding)."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Sockets: Implementação prática em linguagens como Python/C (bibliotecas socket).",
                                "Sistemas Operacionais: Gerenciamento de tabelas de sockets no kernel.",
                                "Matemática Discreta: Mapeamento de funções (porta -> socket) como hash tables.",
                                "Segurança da Informação: Vulnerabilidades em portas UDP (ex: amplificação DDoS)."
                              ],
                              "realWorldApplication": "Em serviços como DNS (resolução de nomes), DHCP (atribuição de IPs) e VoIP (chamadas de voz), a demultiplexação UDP permite que um servidor gerencie milhares de clientes simultâneos sem overhead de conexões, essencial para baixa latência em redes IoT e jogos online."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Identificar aplicações que usam portas UDP",
                            "description": "Citar exemplos como DNS (porta 53), DHCP (67/68), SNMP (161/162) e explicar por que UDP é adequado para elas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de portas UDP e multiplexação",
                                  "subSteps": [
                                    "Explique o papel das portas UDP na multiplexação e demultiplexação de pacotes.",
                                    "Diferencie portas efêmeras de portas bem-conhecidas (0-1023).",
                                    "Liste as características principais do UDP: sem conexão, baixa latência, sem garantia de entrega.",
                                    "Identifique o intervalo de portas UDP (0-65535).",
                                    "Descreva como um servidor UDP escuta em uma porta específica."
                                  ],
                                  "verification": "Resuma em 3 frases o que são portas UDP e seu propósito; confira com documentação oficial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "RFC 768 (UDP)",
                                    "Diagrama de multiplexação UDP (online ou impresso)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'portas de um prédio' para visualizar multiplexação.",
                                  "learningObjective": "Compreender o mecanismo fundamental de portas UDP para identificar aplicações.",
                                  "commonMistakes": "Confundir portas UDP com TCP; lembrar que portas são independentes por protocolo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e citar exemplos comuns de aplicações UDP",
                                  "subSteps": [
                                    "Estude DNS: porta 53, usado para resolução de nomes.",
                                    "Estude DHCP: portas 67 (servidor), 68 (cliente), para atribuição de IP dinâmica.",
                                    "Estude SNMP: portas 161 (polling), 162 (traps), para gerenciamento de rede.",
                                    "Liste outros exemplos opcionais como TFTP (69) ou NTP (123).",
                                    "Crie uma tabela com aplicação, porta(s) e função breve."
                                  ],
                                  "verification": "Recite verbalmente ou escreva 3 exemplos com portas corretas sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de portas IANA (iana.org/assignments/service-names-port-numbers)",
                                    "Tabela em branco para preencher"
                                  ],
                                  "tips": "Agrupe por função: resolução (DNS), configuração (DHCP), monitoramento (SNMP).",
                                  "learningObjective": "Associar aplicações específicas às suas portas UDP padrão.",
                                  "commonMistakes": "Trocar portas de DHCP (67/68); verificar sempre servidor/cliente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar por que UDP é adequado para essas aplicações",
                                  "subSteps": [
                                    "Para DNS: baixa latência para consultas rápidas; perda rara tolerável com retry.",
                                    "Para DHCP: transações curtas e não confiáveis; broadcast inicial não precisa TCP.",
                                    "Para SNMP: traps assíncronos e leves; polling simples prioriza velocidade.",
                                    "Compare com TCP: overhead desnecessário para mensagens pequenas e não interativas.",
                                    "Discuta cenários onde TCP seria inadequado (ex: alta latência em redes WAN)."
                                  ],
                                  "verification": "Escreva uma justificativa de 1 parágrafo para cada exemplo; valide com RFCs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 1035 (DNS)",
                                    "RFC 2131 (DHCP)",
                                    "RFC 1157 (SNMP)",
                                    "Comparação UDP vs TCP (artigo online)"
                                  ],
                                  "tips": "Foco em trade-offs: velocidade vs confiabilidade; UDP para 'fire-and-forget'.",
                                  "learningObjective": "Analisar escolhas de protocolo baseadas em requisitos da aplicação.",
                                  "commonMistakes": "Ignorar que algumas apps têm fallback TCP; UDP é preferido por performance."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação de aplicações via portas UDP",
                                  "subSteps": [
                                    "Use Wireshark para capturar tráfego e filtrar UDP porta 53 (DNS).",
                                    "Simule DHCP com ferramenta online ou VM; identifique portas 67/68.",
                                    "Configure SNMP trap simples e capture na porta 162.",
                                    "Crie quiz: dado tráfego UDP em porta X, identifique app e razão UDP.",
                                    "Registre 5 capturas com screenshots anotados."
                                  ],
                                  "verification": "Demonstre captura Wireshark mostrando app correta; explique tela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark (gratuito)",
                                    "VM ou rede local para simulação",
                                    "Tutoriais Wireshark UDP"
                                  ],
                                  "tips": "Filtre 'udp.port == 53' para isolar tráfego; pratique em rede real com cuidado.",
                                  "learningObjective": "Aplicar conhecimento para identificar apps em tráfego real.",
                                  "commonMistakes": "Confundir portas efêmeras com bem-conhecidas; focar apenas em portas destino."
                                }
                              ],
                              "practicalExample": "Usando Wireshark em uma rede doméstica, capture uma consulta DNS (UDP/53): filtre 'dns', observe pacote UDP sem ACK, explique rapidez para navegação web vs lentidão se fosse TCP.",
                              "finalVerifications": [
                                "Citar corretamente portas e apps: DNS(53), DHCP(67/68), SNMP(161/162).",
                                "Explicar 3 razões por app para uso de UDP (ex: latência baixa).",
                                "Identificar app a partir de log de tráfego UDP (ex: porta 53 = DNS).",
                                "Diferenciar de apps TCP comuns (ex: HTTP/80).",
                                "Listar 2 limitações do UDP nessas apps (ex: perda de pacotes).",
                                "Simular identificação em Wireshark com precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação de portas e apps (100% correto = excelente).",
                                "Profundidade na explicação de adequação UDP (razões técnicas claras).",
                                "Capacidade de prática hands-on (capturas Wireshark válidas).",
                                "Compreensão conceitual (multiplexação portas UDP).",
                                "Criatividade em exemplos adicionais (além dos listados).",
                                "Clareza na comunicação (tabelas/quizzes bem estruturados)."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Configuração de firewalls para portas UDP abertas.",
                                "Programação: Implementação de sockets UDP em Python para apps como DNS client.",
                                "Matemática: Cálculo de checksum UDP e análise probabilística de perdas.",
                                "Administração de Redes: Troubleshooting com netstat/ss para portas UDP ativas."
                              ],
                              "realWorldApplication": "Em TI corporativa, administradores de rede usam esse conhecimento para diagnosticar falhas em DNS/DHCP via logs de firewall, otimizar tráfego VoIP (UDP/RTP) e configurar regras de segurança sem bloquear serviços essenciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Protocolo TCP",
                    "description": "Protocolo de transporte orientado a conexão, confiável, com controle de fluxo, detecção de erros e garantia de entrega ordenada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Estabelecimento e Término de Conexões TCP",
                        "description": "Processo de criação e encerramento de conexões orientadas a conexão no protocolo TCP, incluindo o handshake de três vias e o fechamento de quatro vias.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Explicar o handshake de três vias",
                            "description": "Descrever os passos do SYN, SYN-ACK e ACK para estabelecer uma conexão TCP, incluindo os flags SYN e ACK no cabeçalho TCP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introdução ao Handshake de Três Vias no TCP",
                                  "subSteps": [
                                    "Explicar o que é o protocolo TCP e sua camada de transporte confiável.",
                                    "Descrever o propósito do handshake: sincronizar números de sequência e estabelecer conexão bidirecional.",
                                    "Apresentar a visão geral da sequência: SYN (cliente), SYN-ACK (servidor), ACK (cliente).",
                                    "Identificar os flags principais no cabeçalho TCP: SYN (sincronizar) e ACK (reconhecer).",
                                    "Discutir o papel dos números de sequência iniciais (ISN)."
                                  ],
                                  "verification": "Desenhar um diagrama simples da sequência geral e rotular os flags SYN e ACK.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de cabeçalho TCP impresso ou digital",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Use setas para representar o fluxo de pacotes entre cliente e servidor.",
                                  "learningObjective": "Compreender o propósito e a estrutura geral do handshake de três vias.",
                                  "commonMistakes": "Confundir TCP com UDP ou ignorar a bidirecionalidade da conexão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Passo 1: Cliente Envia Pacote SYN",
                                  "subSteps": [
                                    "Cliente gera um Número de Sequência Inicial (ISN) aleatório.",
                                    "Define o flag SYN como 1 no cabeçalho TCP e ACK como 0.",
                                    "Inclui opções como MSS (Maximum Segment Size) e Window Scale.",
                                    "Envia o pacote SYN para o servidor na porta destino (ex: 80 para HTTP).",
                                    "Cliente entra no estado SYN-SENT aguardando resposta."
                                  ],
                                  "verification": "Simular o pacote SYN em uma ferramenta como Wireshark ou Packet Tracer e confirmar flags.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark ou Cisco Packet Tracer",
                                    "Exemplo de captura de tráfego TCP"
                                  ],
                                  "tips": "Lembre-se: SYN sozinho inicia a sincronização unilateral.",
                                  "learningObjective": "Descrever com precisão o conteúdo e o estado do cliente após enviar SYN.",
                                  "commonMistakes": "Esquecer que o ACK no SYN é 0 ou confundir ISN com número de ACK."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Passo 2: Servidor Responde com SYN-ACK",
                                  "subSteps": [
                                    "Servidor recebe SYN e gera seu próprio ISN.",
                                    "Define flags SYN=1 e ACK=1, com número de ACK = ISN_cliente + 1.",
                                    "Inclui opções de negociação como SACK e Timestamps.",
                                    "Envia SYN-ACK de volta ao cliente.",
                                    "Servidor entra no estado SYN-RECEIVED."
                                  ],
                                  "verification": "Analisar uma captura de pacote SYN-ACK e verificar que ACK confirma o SYN recebido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Captura Wireshark de handshake real",
                                    "Calculadora para números de sequência"
                                  ],
                                  "tips": "O ACK no SYN-ACK sempre aponta para o próximo byte esperado.",
                                  "learningObjective": "Explicar como o servidor sincroniza e reconhece o SYN do cliente.",
                                  "commonMistakes": "Confundir a ordem dos flags ou o cálculo do número de ACK."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Passo 3: Cliente Envia ACK Final e Conexão Estabelecida",
                                  "subSteps": [
                                    "Cliente recebe SYN-ACK e verifica o ACK (deve ser ISN_cliente + 1).",
                                    "Define flag ACK=1, SYN=0, número de ACK = ISN_servidor + 1.",
                                    "Envia o pacote ACK (pode incluir dados iniciais).",
                                    "Cliente e servidor transitam para estado ESTABLISHED.",
                                    "Conexão agora permite troca de dados confiável."
                                  ],
                                  "verification": "Confirmar em simulação que ambos os lados estão em ESTABLISHED e fluxo de dados inicia.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Simulador de rede como Packet Tracer",
                                    "Tabela de estados TCP"
                                  ],
                                  "tips": "Pode haver dados piggybacked no ACK final para eficiência.",
                                  "learningObjective": "Completar a sequência e entender a transição para conexão estabelecida.",
                                  "commonMistakes": "Achar que SYN-ACK finaliza a conexão ou ignorar a confirmação mútua."
                                }
                              ],
                              "practicalExample": "Ao abrir um navegador e acessar 'http://example.com', o navegador (cliente) inicia o handshake TCP com o servidor web na porta 80: envia SYN com ISN=1000, servidor responde SYN-ACK com ACK=1001 e seu ISN=2000, navegador envia ACK=2001, estabelecendo a conexão para transferir a página HTML.",
                              "finalVerifications": [
                                "Desenhar e rotular corretamente o diagrama de fluxo com flags e números de sequência.",
                                "Simular o handshake em Wireshark ou Packet Tracer sem erros.",
                                "Explicar verbalmente a sequência em menos de 2 minutos.",
                                "Identificar estados TCP em cada passo: SYN-SENT, SYN-RECEIVED, ESTABLISHED.",
                                "Calcular números de ACK corretos dados ISNs exemplo.",
                                "Diferenciar handshake de término (four-way)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos flags SYN e ACK em cada pacote (100% correto).",
                                "Correção nos cálculos de números de sequência e ACK.",
                                "Clareza no diagrama ou simulação visual.",
                                "Compreensão dos estados de conexão TCP.",
                                "Capacidade de relacionar a ataques como SYN flood.",
                                "Explicação fluida sem confusões com UDP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Máquinas de estados finitos e sequências numéricas modulares.",
                                "Física: Analogia com sinais de rádio para sincronização de ondas.",
                                "Segurança da Informação: Vulnerabilidades como SYN flooding e mitigação.",
                                "Programação: Uso de sockets em Python (socket.connect()) para demonstrar handshake."
                              ],
                              "realWorldApplication": "Todo acesso à internet via HTTP/HTTPS, email (SMTP/IMAP), streaming (Netflix) ou downloads usa o handshake TCP para garantir conexões confiáveis, evitando perda de dados em redes instáveis como Wi-Fi público."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Descrever o processo de fechamento de conexão",
                            "description": "Explicar o mecanismo de fechamento TCP com FIN e ACK, incluindo o estado TIME_WAIT para evitar pacotes atrasados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a iniciação do fechamento pelo lado ativo (FIN inicial)",
                                  "subSteps": [
                                    "Revise os estados TCP atuais: o lado ativo está em ESTABLISHED e decide fechar.",
                                    "O lado ativo envia um segmento FIN (Finish) com SEQ atualizado.",
                                    "Mantenha temporizadores para retransmissão caso o ACK não chegue.",
                                    "Transite para o estado FIN-WAIT-1 após envio do FIN.",
                                    "Analise o cabeçalho TCP: flag FIN setada, sem dados pendentes."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando o envio do FIN inicial e confirme a transição de estado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama de estados TCP, Wireshark para captura de pacotes reais",
                                  "tips": "Lembre-se que FIN pode ser combinado com dados pendentes para eficiência.",
                                  "learningObjective": "Compreender como o lado ativo inicia o fechamento de forma ordenada.",
                                  "commonMistakes": "Confundir FIN com RST (que é abrupto e não ordenado)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resposta do lado passivo com ACK e preparação para seu FIN",
                                  "subSteps": [
                                    "O lado passivo recebe o FIN e responde com ACK (ACK = SEQ do FIN + 1).",
                                    "Transite para CLOSE-WAIT após ACK.",
                                    "O lado passivo continua processando dados recebidos, se houver.",
                                    "A aplicação no lado passivo é notificada para fechar o socket.",
                                    "Prepare o envio do FIN próprio quando a aplicação indicar fechamento."
                                  ],
                                  "verification": "Simule em um diagrama a troca FIN/ACK e liste os estados envolvidos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ferramenta de simulação TCP como Packet Tracer ou diagramas impressos",
                                  "tips": "No CLOSE-WAIT, o kernel espera a aplicação fechar; atrasos aqui causam 'half-open' connections.",
                                  "learningObjective": "Identificar o papel do ACK em confirmar o FIN recebido.",
                                  "commonMistakes": "Achar que o lado passivo fecha imediatamente; ele espera a app."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Envio do FIN pelo lado passivo e ACK final",
                                  "subSteps": [
                                    "Após fechamento da app, envie FIN do lado passivo (LAST-ACK estado).",
                                    "O lado ativo recebe FIN, envia ACK final e transita para TIME-WAIT.",
                                    "O lado passivo, ao receber ACK, vai para CLOSED.",
                                    "O ACK final confirma ambos os FINs.",
                                    "Mantenha contadores de sequência corretos em todos os segmentos."
                                  ],
                                  "verification": "Crie uma sequência temporal de mensagens e estados para os dois lados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Wireshark captura de uma conexão TCP real sendo fechada",
                                  "tips": "Use 'netstat' ou 'ss' para observar estados em conexões reais.",
                                  "learningObjective": "Descrever a simetria no fechamento de ambos os lados.",
                                  "commonMistakes": "Inverter quem entra em TIME-WAIT (sempre o lado que envia o último ACK)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender o estado TIME_WAIT e seu propósito",
                                  "subSteps": [
                                    "No TIME-WAIT (geralmente 2*MSL, ~2-4 minutos), absorva pacotes duplicados atrasados.",
                                    "Evite reutilização prematura do quadruplet (src IP, src port, dst IP, dst port).",
                                    "Após timer expirar, transite para CLOSED e libere recursos.",
                                    "Discuta impactos: alto uso de portas em servidores de alta carga.",
                                    "Explore soluções como TCP Fast Recycle (não padrão)."
                                  ],
                                  "verification": "Explique em voz alta por que TIME_WAIT previne problemas e calcule duração aproximada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentação RFC 793/1122 sobre TCP, calculadora para MSL",
                                  "tips": "MSL é Maximum Segment Lifetime; valor típico 30s-2min.",
                                  "learningObjective": "Explicar a importância do TIME_WAIT para robustez da rede.",
                                  "commonMistakes": "Achar TIME_WAIT desnecessário; ele previne 'old duplicate' SYN."
                                }
                              ],
                              "practicalExample": "Use netcat (nc) para criar uma conexão TCP: no servidor (nc -l 1234), cliente (nc localhost 1234), digite algo e feche com Ctrl+C. Capture com Wireshark filtrando 'tcp.port==1234' e observe a sequência FIN/ACK/FIN/ACK + TIME_WAIT via 'ss -tan state time-wait'.",
                              "finalVerifications": [
                                "Desenhar corretamente o diagrama 4-way handshake com estados.",
                                "Explicar o propósito de cada flag (FIN, ACK) em sequência.",
                                "Identificar TIME_WAIT em uma captura Wireshark real.",
                                "Calcular duração aproximada de TIME_WAIT baseado em MSL.",
                                "Diferenciar fechamento ordenado (FIN) de abrupto (RST).",
                                "Listar riscos sem TIME_WAIT (pacotes atrasados causam conexões erradas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de mensagens e transições de estado (90% correto).",
                                "Compreensão clara do TIME_WAIT e MSL (explicação sem erros).",
                                "Uso correto de terminologia TCP (FIN-WAIT, CLOSE-WAIT, etc.).",
                                "Capacidade de analisar captura Wireshark com anotações.",
                                "Identificação de erros comuns em cenários hipotéticos.",
                                "Integração com conceitos de sequência/ACK numbers."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Gerenciamento de sockets e timers no kernel.",
                                "Segurança de Redes: TIME_WAIT mitiga ataques de replay/duplicate packets.",
                                "Matemática: Cálculos de timeouts baseados em RTT e MSL.",
                                "Desenvolvimento de Software: Implementação de graceful shutdown em apps cliente/servidor."
                              ],
                              "realWorldApplication": "Em servidores web como Apache/Nginx, o TIME_WAIT previne falhas em conexões de alta frequência (ex: DDoS ou picos de tráfego), garantindo que requisições HTTP/HTTPS terminem sem perda de dados ou conexões órfãs, otimizando portas efêmeras em NATs residenciais."
                            },
                            "estimatedTime": "45 minutos",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Identificar estados da máquina de estados TCP",
                            "description": "Reconhecer os principais estados como LISTEN, SYN_SENT, ESTABLISHED e CLOSE_WAIT na máquina de estados finita do TCP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Máquina de Estados Finitos (FSM) no TCP",
                                  "subSteps": [
                                    "Estude o conceito de FSM: um modelo com estados discretos, transições e eventos de entrada.",
                                    "Identifique o papel da FSM no TCP para gerenciar conexões de forma confiável.",
                                    "Revise o diagrama geral da FSM TCP, focando nos estados iniciais e finais.",
                                    "Anote as diferenças entre estados de cliente e servidor.",
                                    "Compare FSM TCP com protocolos simples como UDP (sem estados)."
                                  ],
                                  "verification": "Desenhe um diagrama básico da FSM TCP com pelo menos 4 estados principais e explique verbalmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama FSM TCP (RFC 793 ou Wireshark docs)",
                                    "Vídeo tutorial sobre TCP FSM (YouTube/Khan Academy)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Comece pelo servidor (LISTEN) para contextualizar; use cores para diferenciar estados de abertura e fechamento.",
                                  "learningObjective": "Entender FSM como base para identificar estados TCP específicos.",
                                  "commonMistakes": [
                                    "Confundir FSM com fluxogramas lineares",
                                    "Ignorar eventos de transição como SYN/ACK",
                                    "Achar que TCP é stateless como UDP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e Descrever os Estados Iniciais: LISTEN e SYN_SENT",
                                  "subSteps": [
                                    "Defina LISTEN: estado passivo do servidor aguardando conexões SYN.",
                                    "Defina SYN_SENT: estado ativo do cliente após enviar SYN inicial.",
                                    "Estude transições: LISTEN -> SYN_RCVD (ao receber SYN), SYN_SENT -> SYN_RCVD/ESTABLISHED.",
                                    "Simule com exemplos: servidor web em LISTEN, browser em SYN_SENT.",
                                    "Liste triggers: SYN recebido, timeout de retransmissão."
                                  ],
                                  "verification": "Liste os dois estados, suas descrições e uma transição cada, sem consultar materiais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 793 seção 3.4",
                                    "Ferramenta online TCP FSM simulator (ex: tcpstate.net)"
                                  ],
                                  "tips": "Associe LISTEN a 'escutando na porta' e SYN_SENT a ' SYN enviado, aguardando resposta'.",
                                  "learningObjective": "Reconhecer e diferenciar estados de iniciação de conexão TCP.",
                                  "commonMistakes": [
                                    "Confundir LISTEN (servidor) com SYN_SENT (cliente)",
                                    "Esquecer que LISTEN é passivo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estados Estabelecidos e de Fechamento: ESTABLISHED e CLOSE_WAIT",
                                  "subSteps": [
                                    "Defina ESTABLISHED: conexão bidirecional ativa, dados fluindo.",
                                    "Defina CLOSE_WAIT: servidor recebeu FIN, mas não enviou ACK/FIN final.",
                                    "Trace transições: SYN_RCVD -> ESTABLISHED (3-way handshake), ESTABLISHED -> CLOSE_WAIT (FIN recebido).",
                                    "Compare com TIME_WAIT (cliente finaliza após LAST_ACK).",
                                    "Identifique problemas comuns: conexões presas em CLOSE_WAIT."
                                  ],
                                  "verification": "Explique a sequência de um handshake completo e por que CLOSE_WAIT ocorre após ESTABLISHED.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wireshark para capturar tráfego real",
                                    "Diagrama de estados TCP detalhado (Wikipedia TCP state)"
                                  ],
                                  "tips": "Pense em ESTABLISHED como 'conversa aberta' e CLOSE_WAIT como 'um lado disse adeus, outro ainda responde'.",
                                  "learningObjective": "Identificar estados durante operação e término de conexões TCP.",
                                  "commonMistakes": [
                                    "Achar ESTABLISHED permanente",
                                    "Confundir CLOSE_WAIT com FIN_WAIT (lado que inicia fechamento)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação com Ferramentas e Diagramas",
                                  "subSteps": [
                                    "Instale e use 'netstat -an' ou 'ss -tan' para listar sockets em estados reais.",
                                    "Capture tráfego com Wireshark e filtre por TCP states.",
                                    "Simule cenários: abra telnet a um servidor, observe mudanças de SYN_SENT para ESTABLISHED.",
                                    "Desenhe fluxos personalizados: falha no handshake (stuck em SYN_SENT).",
                                    "Teste quiz: dado um output de netstat, identifique o estado."
                                  ],
                                  "verification": "Capture uma conexão real e rotule screenshots dos 4 estados observados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Linux/Mac com netstat/ss",
                                    "Wireshark instalado",
                                    "Servidor telnet acessível (ex: towel.blinkenlights.nl)"
                                  ],
                                  "tips": "Filtre Wireshark por 'tcp.analysis' para ver states; pratique em VM para segurança.",
                                  "learningObjective": "Aplicar conhecimento para identificar estados em cenários reais.",
                                  "commonMistakes": [
                                    "Interpretar errado outputs de netstat (ex: LISTEN como conexão ativa)",
                                    "Não considerar firewalls bloqueando SYN"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao debugar uma aplicação web lenta, use 'ss -tan | grep ESTABLISHED' para contar conexões ativas e 'grep CLOSE_WAIT' para detectar vazamentos de sockets, permitindo otimizar o pool de conexões no servidor Apache/Nginx.",
                              "finalVerifications": [
                                "Liste e defina corretamente LISTEN, SYN_SENT, ESTABLISHED e CLOSE_WAIT.",
                                "Desenhe o caminho de transições entre esses estados em um handshake e fechamento.",
                                "Interprete um output de 'netstat -an' identificando pelo menos 3 estados.",
                                "Explique por que uma conexão fica em CLOSE_WAIT e como resolver.",
                                "Simule uma falha: o que acontece se SYN não for respondido?",
                                "Compare estados cliente vs servidor em um diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (100% correto para os 4 estados).",
                                "Compreensão de transições (corretas em 80% dos cenários simulados).",
                                "Habilidade prática: identificar estados em ferramentas reais sem erros.",
                                "Explicação clara de triggers e eventos (ex: SYN, FIN, ACK).",
                                "Aplicação contextual: ligar estados a problemas reais como timeouts.",
                                "Criatividade em diagramas: visual claro e completo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos Finitos e Teoria da Computação (estados/transições).",
                                "Programação: Implementar FSM em sockets Python (socket library states).",
                                "Segurança: Análise de ataques SYN flood afetando LISTEN/SYN_SENT.",
                                "Física: Analogia com sinais elétricos (handshake como sincronização de clocks)."
                              ],
                              "realWorldApplication": "Em operações de TI, administradores de rede usam esses estados para diagnosticar problemas de conectividade, como conexões pendentes em CLOSE_WAIT causando exaustão de portas efêmeras em servidores de alta carga, otimizando assim desempenho e escalabilidade de aplicações como bancos de dados ou APIs."
                            },
                            "estimatedTime": "30 minutos",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Mecanismos de Confiabilidade e Detecção de Erros",
                        "description": "Técnicas usadas pelo TCP para garantir entrega confiável, detecção de erros e retransmissão de segmentos perdidos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Explicar o uso de números de sequência e ACK",
                            "description": "Detalhar como os números de sequência (SEQ) e números de confirmação (ACK) garantem a ordem e a confiabilidade dos segmentos TCP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Números de Sequência (SEQ) em TCP",
                                  "subSteps": [
                                    "Estude a estrutura do cabeçalho TCP, focando no campo Sequence Number (32 bits).",
                                    "Aprenda que SEQ identifica o byte inicial de cada segmento de dados enviado.",
                                    "Entenda que SEQ inicia com um valor aleatório (ISN) no handshake de 3 vias para segurança.",
                                    "Simule o envio de um fluxo de bytes: por exemplo, bytes 0-999 com SEQ=1000.",
                                    "Revise como SEQ permite reordenação no receptor mesmo se pacotes chegarem fora de ordem."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito como um SEQ é atribuído a um segmento e por que ele é único por conexão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do cabeçalho TCP (RFC 793)",
                                    "Ferramenta Wireshark para capturar tráfego TCP",
                                    "Vídeo tutorial sobre handshake TCP"
                                  ],
                                  "tips": [
                                    "Lembre-se: SEQ conta BYTES, não segmentos.",
                                    "Use desenhos para visualizar o fluxo de bytes divididos em segmentos."
                                  ],
                                  "learningObjective": "Explicar o papel do SEQ na identificação precisa dos dados em uma conexão TCP.",
                                  "commonMistakes": [
                                    "Confundir SEQ com número de segmento em vez de byte offset.",
                                    "Ignorar o uso de ISN aleatório."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Mecanismo de Números de Confirmação (ACK)",
                                  "subSteps": [
                                    "Identifique o campo Acknowledgment Number no cabeçalho TCP (32 bits).",
                                    "Aprenda que ACK confirma o recebimento bem-sucedido até um SEQ específico.",
                                    "Estude que ACK é enviado apenas se o segmento anterior foi recebido corretamente (ACK cumulativo).",
                                    "Simule: Receptor recebe SEQ=1000 (bytes 1000-1999), envia ACK=2000 confirmando tudo até byte 1999.",
                                    "Diferencie ACK de 0 (sem dados confirmados) de ACKs válidos."
                                  ],
                                  "verification": "Crie um diagrama mostrando envio de segmento e resposta ACK correspondente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 793 - TCP Specification",
                                    "Simulador TCP online (ex: TCP Simulator tools)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "ACK sempre aponta para o próximo byte esperado.",
                                    "Pratique com exemplos numéricos simples para fixar."
                                  ],
                                  "learningObjective": "Descrever como ACKs garantem que o remetente saiba quais dados foram recebidos.",
                                  "commonMistakes": [
                                    "Achar que ACK confirma apenas o último segmento, ignorando cumulatividade.",
                                    "Confundir ACK com SEQ do próprio segmento enviado."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Interação entre SEQ e ACK para Confiabilidade e Ordem",
                                  "subSteps": [
                                    "Simule uma conexão TCP com perda de pacote: SEQ=1000 perdido, receptor envia ACK duplicado.",
                                    "Entenda retransmissão: Remetente retransmite após timeout ou ACKs duplicados (Fast Retransmit).",
                                    "Explore reordenação: Pacotes chegam fora de ordem; receptor armazena em buffer até SEQ contínuo.",
                                    "Estude wrap-around: Como 32 bits lidam com fluxos longos (modular 2^32).",
                                    "Revise fluxo normal: SEQ incremental, ACKs avançando conforme recebimento."
                                  ],
                                  "verification": "Explique em um parágrafo curto o que acontece se um pacote com SEQ=500 chega antes de SEQ=400.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark com filtro 'tcp.analysis.lost_segment'",
                                    "Animações TCP SEQ/ACK (Khan Academy ou YouTube)",
                                    "Exercícios de simulação em papel"
                                  ],
                                  "tips": [
                                    "Pense em SEQ/ACK como um 'livro de cheques': SEQ é o cheque emitido, ACK é o carimbo de recebido.",
                                    "Monitore tráfego real com Wireshark para ver na prática."
                                  ],
                                  "learningObjective": "Demonstrar como SEQ e ACK sincronizam remetente e receptor para entrega ordenada e confiável.",
                                  "commonMistakes": [
                                    "Subestimar buffers no receptor para reordenação.",
                                    "Confundir timeout com ACK duplicado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar SEQ e ACK em Cenários de Erro e Verificação Final",
                                  "subSteps": [
                                    "Simule cenário de reorder: Pacotes 1,3,2 chegam; explique buffer e ACK atrasado.",
                                    "Teste com ferramenta: Capture tráfego HTTP e analise SEQ/ACK em Wireshark.",
                                    "Discuta limitações: PAWS (Protection Against Wrapped Sequences) para conexões longas.",
                                    "Compare com UDP: Sem SEQ/ACK, daí perda de ordem/confiabilidade.",
                                    "Resuma benefícios: Detecção de duplicatas, perdas e garantia de ordem."
                                  ],
                                  "verification": "Analise um trace Wireshark e identifique SEQ/ACK em uma sessão TCP real.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Instalação Wireshark",
                                    "Trace de exemplo TCP com erros (disponível online)",
                                    "Checklist de análise TCP"
                                  ],
                                  "tips": [
                                    "Filtre por 'tcp.analysis' no Wireshark para erros automáticos.",
                                    "Pratique com conexões lentas para ver retransmissões."
                                  ],
                                  "learningObjective": "Aplicar conceitos de SEQ/ACK para diagnosticar problemas em tráfego de rede real.",
                                  "commonMistakes": [
                                    "Ignorar que ACKs são piggybacked em segmentos de dados.",
                                    "Achar que TCP garante entrega sem ACKs explícitos."
                                  ]
                                }
                              ],
                              "practicalExample": "Ao transferir um arquivo de 10KB via HTTP sobre TCP: O cliente divide em segmentos (ex: SEQ=1000 para primeiros 1460 bytes). Servidor recebe e envia ACK=2460. Se um segmento se perde, ACK duplicado=2460 triggera retransmissão, garantindo ordem e completude no download.",
                              "finalVerifications": [
                                "Explicar diferença entre SEQ e ACK com exemplo numérico.",
                                "Desenhar fluxo TCP com 3 segmentos, incluindo ACKs.",
                                "Identificar em Wireshark um caso de retransmissão por ACK duplicado.",
                                "Discutir por que SEQ inicia aleatório.",
                                "Comparar TCP SEQ/ACK vs. UDP (sem mecanismos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de SEQ (byte offset) e ACK (próximo esperado).",
                                "Compreensão de cumulatividade e reordenação via diagramas.",
                                "Capacidade de simular cenários de perda/reorder corretamente.",
                                "Uso correto de terminologia (ISN, Fast Retransmit, PAWS).",
                                "Aplicação prática via Wireshark ou simulação.",
                                "Identificação de erros comuns em fluxos TCP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular para wrap-around de 32 bits.",
                                "Física: Analogia com transmissão de sinais e detecção de ruído.",
                                "Programação: Implementação de sockets TCP em Python (seq/ack implícitos).",
                                "Segurança: SEQ aleatório previne spoofing (relacionado a criptografia)."
                              ],
                              "realWorldApplication": "Em streaming de vídeo (Netflix), SEQ/ACK garante que frames cheguem em ordem apesar de jitter na rede; em transferências FTP, detecta perdas para retransmissão automática, evitando corrupção de arquivos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Descrever detecção e correção de erros",
                            "description": "Explicar o checksum TCP, timers de retransmissão (RTT estimado) e o mecanismo de retransmissão rápida (fast retransmit).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Checksum TCP para Detecção de Erros",
                                  "subSteps": [
                                    "Estude a definição de checksum: um valor calculado a partir dos dados do segmento TCP para verificar integridade.",
                                    "Aprenda o algoritmo: some todos os 16-bit words do header + payload + pseudo-header (IP src/dst, protocol, length), depois complemente 1's.",
                                    "Analise como o receptor recalcula e compara: se não bater, descarta o segmento.",
                                    "Examine exemplos de erros detectados: bit flip em dados ou header.",
                                    "Pratique cálculo manual de um checksum simples com dados hexadecimais."
                                  ],
                                  "verification": "Calcule corretamente o checksum de um segmento TCP exemplo fornecido e explique por que um erro alteraria o valor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 793 (TCP spec)",
                                    "Ferramenta online de checksum TCP (ex: Wireshark ou calculadora online)",
                                    "Diagramas de pseudo-header TCP"
                                  ],
                                  "tips": "Sempre inclua o pseudo-header; esqueça e o cálculo falha.",
                                  "learningObjective": "Compreender e calcular o checksum TCP para detectar corrupção de dados.",
                                  "commonMistakes": "Ignorar o pseudo-header IP; somar em ordem errada; não fazer fold-back para 16 bits."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Timers de Retransmissão e Estimativa de RTT",
                                  "subSteps": [
                                    "Defina RTT: tempo round-trip de envio a ACK.",
                                    "Estude estimativa de RTT: use média suavizada (Smoothed RTT = (1-α)*old + α*measured), tipicamente α=0.125.",
                                    "Aprenda RTO (Retransmission Timeout): RTO = SRTT + 4*RTTvar, com backoff exponencial.",
                                    "Analise papel do timer: ao expirar, retransmita segmento não-ACKed.",
                                    "Simule variações: como delays afetam estimativas (Karn's algorithm para ambiguidades)."
                                  ],
                                  "verification": "Calcule SRTT e RTO para uma sequência de RTTs medida (ex: 100ms, 120ms, 80ms) e determine quando retransmitir.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "RFC 6298 (RTT estimativa)",
                                    "Simulador TCP (ex: ns-3 ou online TCP simulator)",
                                    "Gráficos de RTT vs RTO"
                                  ],
                                  "tips": "Use α baixo para suavizar variações; teste com ping para medir RTT real.",
                                  "learningObjective": "Dominar estimativa de RTT e cálculo de RTO para timeouts de retransmissão.",
                                  "commonMistakes": "Usar RTT raw sem suavização; ignorar RTTvar para variância; não aplicar backoff em RTO."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Mecanismo de Fast Retransmit",
                                  "subSteps": [
                                    "Descreva trigger: recepção de 3 ACKs duplicados indica perda de segmento.",
                                    "Explique DUPACK: ACK com mesmo seq# sinaliza gap na sequência.",
                                    "Aprenda ação: retransmita segmento perdido imediatamente, sem esperar RTO; ajuste congestion window.",
                                    "Diferencie de timeout: fast é proativo via feedback.",
                                    "Simule cenário: envie seg1,2,3; perca 2; receptor envia DUPACK para 1 três vezes."
                                  ],
                                  "verification": "Desenhe um diagrama de fluxo mostrando 3 DUPACKs levando a fast retransmit, com seq# corretos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "RFC 5681 (TCP Congestion)",
                                    "Wireshark capture de TCP com perdas",
                                    "Animações interativas de TCP (ex: Cisco networking academy)"
                                  ],
                                  "tips": "Conte DUPACKs precisamente; 3 é o threshold padrão.",
                                  "learningObjective": "Explicar como fast retransmit detecta e corrige perdas sem timers.",
                                  "commonMistakes": "Confundir DUPACK com ACK novo; achar que fast retransmit zera timer (não, ajusta)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Mecanismos na Detecção e Correção de Erros TCP",
                                  "subSteps": [
                                    "Mapeie fluxo: checksum detecta erro → discard; perda → DUPACKs → fast retransmit ou timeout.",
                                    "Compare mecanismos: checksum (bit errors), fast retransmit (packet loss), RTO (atrasos extremos).",
                                    "Discuta limitações: checksum não corrige, só detecta; fast assume perdas isoladas.",
                                    "Analise sinergia: RTT alimenta RTO, DUPACKs aceleram recuperação.",
                                    "Crie resumo: tabela comparando detecção (checksum/DUPACK/timer) vs correção (retransmit)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como TCP corrige um pacote corrompido vs perdido, citando cada mecanismo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Resumo TCP reliability diagram",
                                    "Vídeos Khan Academy ou YouTube sobre TCP errors",
                                    "Folha de exercícios TCP scenarios"
                                  ],
                                  "tips": "Pense em camadas: L4 TCP usa feedback da L4 e timers.",
                                  "learningObjective": "Sintetizar como checksum, RTT/RTO e fast retransmit formam a confiabilidade TCP.",
                                  "commonMistakes": "Achar checksum corrige dados; confundir fast retransmit com SACK."
                                }
                              ],
                              "practicalExample": "Em uma transferência de arquivo HTTP via TCP (porta 80), um pacote com imagem tem bit flip (erro de transmissão): checksum falha no receptor, pacote descartado. Receptor envia ACK para último byte bom. Se perda total do próximo pacote, envia 3 DUPACKs; remetente faz fast retransmit após RTT estimado baixo, evitando timeout longo.",
                              "finalVerifications": [
                                "Calcule checksum TCP corretamente para um segmento exemplo.",
                                "Estime RTO a partir de múltiplos RTTs medidos.",
                                "Descreva sequência exata de eventos para fast retransmit com 3 DUPACKs.",
                                "Diferencie detecção de corrupção vs perda de pacote.",
                                "Explique por que TCP é confiável apesar de IP não ser.",
                                "Simule em Wireshark um capture com DUPACKs."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: checksum/RTT/fast retransmit explicados sem erros (40%)",
                                "Profundidade: subcomponentes (pseudo-header, α, DUPACK threshold) cobertos (20%)",
                                "Clareza: diagramas/fluxos usados para ilustrar (15%)",
                                "Integração: como mecanismos interagem mostrada (15%)",
                                "Exemplos práticos: cenários reais aplicados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos modulares e somas em checksum (aritmética de 16 bits).",
                                "Física: Modelagem de delays de propagação em RTT (ondas/propagação).",
                                "Probabilidade: Estimativa estatística de RTTvar e riscos de perda.",
                                "Engenharia: Design de sistemas tolerantes a falhas (redundância/feedback)."
                              ],
                              "realWorldApplication": "Em streaming Netflix ou chamadas Zoom, TCP usa esses mecanismos para retransmitir frames perdidos rapidamente via fast retransmit, estimando RTT para web global, e checksum para evitar exibir imagens corrompidas, garantindo qualidade apesar de WiFi instável ou fibra longa distância."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Analisar o cabeçalho TCP",
                            "description": "Identificar e interpretar campos chave do cabeçalho TCP, como porta origem/destino, SEQ, ACK, flags, janela e checksum.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral do Cabeçalho TCP",
                                  "subSteps": [
                                    "Ler a seção relevante da RFC 793 sobre o cabeçalho TCP.",
                                    "Visualizar e memorizar o diagrama de layout do cabeçalho (20 bytes fixos + opções).",
                                    "Identificar as posições em bytes de cada campo principal (ex: portas nos primeiros 4 bytes).",
                                    "Diferenciar cabeçalho fixo de campos opcionais no final."
                                  ],
                                  "verification": "Desenhar manualmente o diagrama do cabeçalho TCP indicando offsets de cada campo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 793 (seção 3.1)",
                                    "Diagrama do cabeçalho TCP (imagem ou Wireshark screenshot)"
                                  ],
                                  "tips": [
                                    "Use um editor hexadecimal para visualizar bytes reais.",
                                    "Lembre-se: cabeçalho mínimo é 20 bytes, alinhado em 32 bits."
                                  ],
                                  "learningObjective": "Entender o layout físico e a organização dos campos no cabeçalho TCP.",
                                  "commonMistakes": [
                                    "Confundir o cabeçalho TCP com o IP",
                                    "Ignorar o campo de comprimento do cabeçalho (data offset)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Campos de Endereçamento e Sequenciamento",
                                  "subSteps": [
                                    "Localizar e decodificar portas origem (bits 0-15) e destino (16-31).",
                                    "Interpretar o número de sequência (SEQ, 32 bits).",
                                    "Explicar o papel do número de reconhecimento (ACK, 32 bits) e quando é usado.",
                                    "Converter valores hexadecimais para decimais e contextualizar (ex: porta 80 = HTTP)."
                                  ],
                                  "verification": "Listar valores de portas, SEQ e ACK de um cabeçalho exemplo e explicar seu significado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark ou hex editor",
                                    "Exemplo de captura de pacote TCP"
                                  ],
                                  "tips": [
                                    "Portas <1024 são bem-conhecidas; >1024 efêmeras.",
                                    "SEQ inicia em 0 no SYN, mas é randomizado por segurança."
                                  ],
                                  "learningObjective": "Identificar e interpretar corretamente portas, SEQ e ACK em um cabeçalho.",
                                  "commonMistakes": [
                                    "Inverter origem e destino",
                                    "Confundir SEQ com ACK em handshakes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Flags de Controle, Janela e Checksum",
                                  "subSteps": [
                                    "Identificar os 6 flags (URG, ACK, PSH, RST, SYN, FIN) nos bits 96-101.",
                                    "Explicar o campo de janela de recebimento (16 bits, após flags).",
                                    "Calcular ou validar o checksum (16 bits, soma de complemento de 1).",
                                    "Analisar o data offset (4 bits) para determinar tamanho do cabeçalho."
                                  ],
                                  "verification": "Marcar flags ativas em um exemplo e calcular janela/checksum manualmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal ou script Python para checksum",
                                    "Lista de flags TCP"
                                  ],
                                  "tips": [
                                    "Flags SYN+ACK no handshake de 3 vias.",
                                    "Checksum inclui pseudo-header IP + payload."
                                  ],
                                  "learningObjective": "Dominar flags para estados de conexão e validar integridade via checksum.",
                                  "commonMistakes": [
                                    "Interpretar flags como binário único em vez de bits individuais",
                                    "Esquecer pseudo-header no checksum"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Análise Completa de um Cabeçalho TCP Real",
                                  "subSteps": [
                                    "Capturar ou carregar um pacote TCP em Wireshark/tcpdump.",
                                    "Preencher uma tabela com todos os campos chave (portas, SEQ, ACK, flags, janela, checksum).",
                                    "Interpretar o estado da conexão baseado nos campos (ex: SYN flood?).",
                                    "Comparar com documentação para validar interpretação."
                                  ],
                                  "verification": "Gerar relatório resumido da análise com interpretações corretas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Captura de tráfego de exemplo (ex: http.pcap)"
                                  ],
                                  "tips": [
                                    "Filtre por 'tcp' no Wireshark para focar.",
                                    "Salve análises em template reutilizável."
                                  ],
                                  "learningObjective": "Aplicar análise integrada de todos os campos em cenários reais.",
                                  "commonMistakes": [
                                    "Ignorar endianness (big-endian em rede)",
                                    "Sobrepor campos opcionais sem ler data offset"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Reforçar Conhecimento com Exercícios",
                                  "subSteps": [
                                    "Resolver 3 exercícios de decodificação de cabeçalhos hex.",
                                    "Simular erros (ex: checksum inválido) e diagnosticar.",
                                    "Discutir variações como MSS em opções.",
                                    "Testar em múltiplos pacotes de uma conexão."
                                  ],
                                  "verification": "Atingir 100% de acerto em quiz de 10 perguntas sobre cabeçalhos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quiz online ou PDF com cabeçalhos hex",
                                    "Exercícios práticos de rede"
                                  ],
                                  "tips": [
                                    "Use tcpdump -xx para dump hex.",
                                    "Pratique com pacotes de diferentes protocolos sobre TCP."
                                  ],
                                  "learningObjective": "Consolidar habilidades de análise através de prática iterativa.",
                                  "commonMistakes": [
                                    "Não considerar contexto da conexão (ex: SYN sem ACK)",
                                    "Erros de conversão hex-dec"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma captura Wireshark de uma conexão HTTP: Porta origem 54321 (efêmera), destino 80 (HTTP), SEQ=12345678, ACK=87654321, Flags=SYN|ACK, Janela=65535, Checksum=0xABCD. Interpretação: Handshake de resposta, cliente inicia com SEQ aleatório, servidor ACK + SYN.",
                              "finalVerifications": [
                                "Lista corretamente todos os campos chave e suas posições em bytes.",
                                "Interpreta flags para identificar estado da conexão (ex: SYN, FIN).",
                                "Calcula e valida checksum manualmente em pelo menos um exemplo.",
                                "Diferencia SEQ de ACK e explica seu uso em confiabilidade.",
                                "Identifica aplicações reais das portas origem/destino.",
                                "Descreve impacto de janela baixa em throughput.",
                                "Analisa um cabeçalho completo sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização e decodificação de cada campo (90%+ correto).",
                                "Correta interpretação semântica (ex: SYN indica início de conexão).",
                                "Habilidade em calcular checksum e janela numericamente.",
                                "Uso correto de ferramentas como Wireshark para validação.",
                                "Capacidade de diagnosticar anomalias (ex: flags inválidos).",
                                "Clareza na explicação escrita ou verbal da análise."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise, soma de checksum e conversões hex-dec.",
                                "Segurança da Informação: Detecção de pacotes maliciosos via flags anormais.",
                                "Programação: Implementação de sockets TCP em linguagens como Python.",
                                "Física: Analogia com sinais elétricos em transmissão de dados.",
                                "Estatística: Análise de tráfego para padrões de uso de portas."
                              ],
                              "realWorldApplication": "Troubleshooting de conexões lentas em redes corporativas, detecção de ataques DDoS como SYN flood analisando flags SEQ/ACK, desenvolvimento de firewalls que inspecionam cabeçalhos TCP para filtragem, e otimização de aplicações web medindo janelas de recepção."
                            },
                            "estimatedTime": "45 minutos",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Controle de Fluxo e Congestionamento",
                        "description": "Mecanismos do TCP para gerenciar a taxa de envio de dados, evitando sobrecarga do receptor e da rede.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Explicar o controle de fluxo com janela deslizante",
                            "description": "Descrever como o campo de janela de recepção (RWND) no cabeçalho TCP implementa o protocolo de janela deslizante para controle de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Controle de Fluxo",
                                  "subSteps": [
                                    "Defina controle de fluxo como mecanismo para evitar que o remetente envie dados mais rápido que o receptor pode processar.",
                                    "Compare com controle de congestionamento, destacando que fluxo foca no receptor e congestionamento na rede.",
                                    "Explique o problema de overflow de buffer no receptor sem controle.",
                                    "Discuta a necessidade de feedback do receptor para o remetente.",
                                    "Identifique o TCP como protocolo orientado a conexão que usa isso."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e diferencie de congestionamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama simples de buffer overflow (papel ou ferramenta como Draw.io)",
                                    "Artigo introdutório sobre TCP flow control"
                                  ],
                                  "tips": "Use analogia de mangueira e balde para visualizar fluxo.",
                                  "learningObjective": "Compreender a motivação e diferenças entre controle de fluxo e congestionamento.",
                                  "commonMistakes": "Confundir controle de fluxo (receptor) com controle de congestionamento (rede)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Cabeçalho TCP e o Campo RWND",
                                  "subSteps": [
                                    "Descreva a estrutura geral do cabeçalho TCP (20 bytes mínimos, campos como portas, sequência, ACK).",
                                    "Localize o campo Receive Window (RWND) nos bytes 14-15 (16 bits, tamanho em bytes).",
                                    "Explique que RWND indica o tamanho disponível no buffer de recepção do remetente.",
                                    "Note que RWND é enviado em todos os segmentos TCP (exceto SYN inicial).",
                                    "Calcule exemplo: RWND=65535 significa buffer cheio disponível."
                                  ],
                                  "verification": "Desenhe o cabeçalho TCP destacando RWND e anote seu propósito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama do cabeçalho TCP (RFC 793 ou Wireshark screenshot)",
                                    "Ferramenta de visualização de pacotes como Wireshark"
                                  ],
                                  "tips": "Memorize posição: após Acknowledgment Number.",
                                  "learningObjective": "Identificar e interpretar o campo RWND no cabeçalho TCP.",
                                  "commonMistakes": "Achar que RWND é fixo; é dinâmico por segmento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender o Protocolo de Janela Deslizante",
                                  "subSteps": [
                                    "Defina janela deslizante como técnica para enviar múltiplos segmentos sem ACK por cada um.",
                                    "Explique componentes: ponteiro de envio, janela do remetente (limitada por RWND e CWND), ponteiro de ACK.",
                                    "Descreva o 'slide': janela avança quando ACK recebido ou timeout.",
                                    "Ilustre com diagrama: segmentos numerados, ACK cumulativo.",
                                    "Discuta janela zero: para quando RWND=0, remetente para."
                                  ],
                                  "verification": "Crie um diagrama simples de janela deslizante com 4 segmentos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Simulador online de TCP sliding window (ex: TCP Window Simulator)"
                                  ],
                                  "tips": "Pense na janela como uma 'janela' literal que desliza sobre números de sequência.",
                                  "learningObjective": "Modelar o mecanismo de janela deslizante em TCP.",
                                  "commonMistakes": "Ignorar ACKs cumulativos; cada ACK libera toda a janela até o ACK."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar RWND no Controle de Fluxo com Janela Deslizante",
                                  "subSteps": [
                                    "Descreva como remetente usa RWND para definir tamanho da janela de envio (min(RWND, CWND)).",
                                    "Explique atualizações: receptor envia ACK com novo RWND atualizado.",
                                    "Simule fluxo: receptor lento reduz RWND, remetente throttling.",
                                    "Discuta zero window probe: quando RWND=0, sondas periódicas.",
                                    "Compare com outros protocolos (ex: UDP sem controle)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito um ciclo completo de RWND update.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark para capturar tráfego TCP real",
                                    "RFC 793 seção sobre window"
                                  ],
                                  "tips": "Capture tráfego HTTP para ver RWND variando.",
                                  "learningObjective": "Explicar como RWND implementa sliding window para flow control.",
                                  "commonMistakes": "Confundir RWND (flow) com CWND (congestion)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Verificar o Conceito",
                                  "subSteps": [
                                    "Simule cenário com ferramenta: envie dados e observe RWND.",
                                    "Analise captura Wireshark: identifique RWND em ACKs.",
                                    "Crie tabela: Sequência, ACK, RWND para 5 segmentos.",
                                    "Teste edge case: buffer cheio (RWND=0).",
                                    "Resuma vantagens: eficiência, prevenção de perda."
                                  ],
                                  "verification": "Produza uma captura Wireshark anotada mostrando RWND em ação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Servidor local para teste TCP (ex: netcat)"
                                  ],
                                  "tips": "Use loopback para testes rápidos sem rede.",
                                  "learningObjective": "Aplicar e validar o controle de fluxo em prática.",
                                  "commonMistakes": "Não escalar números de sequência (use bytes, não pacotes)."
                                }
                              ],
                              "practicalExample": "Em um download de arquivo grande via HTTP/TCP, o cliente com buffer de 64KB envia ACK com RWND=64000. O servidor envia até 64KB, aguarda ACK com novo RWND. Se o cliente processa devagar, RWND cai para 32000, forçando o servidor a pausar, evitando overflow.",
                              "finalVerifications": [
                                "Desenhar diagrama preciso de sliding window com RWND updates.",
                                "Explicar verbalmente o ciclo de um ACK com RWND reduzido.",
                                "Analisar Wireshark trace identificando RWND=0 e probe.",
                                "Diferenciar flow control de congestion control com exemplos.",
                                "Simular cenário escrito onde RWND previne perda de dados.",
                                "Listar 3 vantagens do mecanismo TCP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do campo RWND e sua posição.",
                                "Correta representação visual do sliding window.",
                                "Compreensão de ACK cumulativo e updates dinâmicos.",
                                "Diferenciação clara entre RWND e outros limites (CWND).",
                                "Uso correto de terminologia técnica (ex: zero window).",
                                "Aplicação prática via simulação ou análise de trace."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem com sequências aritméticas e janelas móveis.",
                                "Física: Analogia com fluxo de fluidos e capacidade de tubulações.",
                                "Engenharia de Software: Gerenciamento de buffers em aplicações.",
                                "Economia: Alocação eficiente de recursos limitados (banda/buffer)."
                              ],
                              "realWorldApplication": "Esse mecanismo é essencial em todas as conexões TCP na internet, como streaming Netflix (evita buffer overflow no cliente), downloads P2P (adapta a velocidades variáveis) e VoIP (mantém fluxo suave sem perdas), garantindo 90%+ do tráfego web eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Descrever algoritmos de controle de congestionamento",
                            "description": "Explicar slow start, congestion avoidance, fast retransmit e fast recovery no TCP Reno ou Cubic.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Congestionamento no TCP",
                                  "subSteps": [
                                    "Estude o que é congestionamento em redes: perda de pacotes devido a buffers cheios.",
                                    "Aprenda sobre variáveis chave: cwnd (congestion window), ssthresh (slow start threshold), RTT.",
                                    "Revise o diagrama de fases do TCP congestion control.",
                                    "Identifique triggers de congestionamento: timeout ou duplicate ACKs.",
                                    "Anote definições de AIMD (Additive Increase Multiplicative Decrease)."
                                  ],
                                  "verification": "Resuma em 3 frases os fundamentos e liste 4 variáveis chave com suas funções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 5681 (TCP Congestion Control)",
                                    "Vídeo Khan Academy sobre TCP",
                                    "Diagrama de fases TCP"
                                  ],
                                  "tips": "Desenhe um gráfico simples de cwnd vs tempo para visualizar mudanças.",
                                  "learningObjective": "Compreender os princípios básicos que precedem os algoritmos específicos.",
                                  "commonMistakes": "Confundir controle de fluxo (janela do receptor) com controle de congestionamento (rede)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Slow Start e Congestion Avoidance",
                                  "subSteps": [
                                    "Explique Slow Start: cwnd dobra a cada RTT até ssthresh.",
                                    "Descreva Congestion Avoidance: cwnd aumenta linearmente (1/cwnd por ACK).",
                                    "Simule uma sequência: inicie com cwnd=1, mostre evolução até perda.",
                                    "Calcule exemplos numéricos: RTT=100ms, perda no cwnd=16.",
                                    "Compare com Tahoe: reset para 1 após perda."
                                  ],
                                  "verification": "Crie uma tabela com 5 RTTS mostrando cwnd em Slow Start e Avoidance.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "RFC 2001 (TCP Slow Start)",
                                    "Simulador ns-3 ou Python script para TCP",
                                    "Gráficos de cwnd"
                                  ],
                                  "tips": "Use exponencial vs linear: pense em população bacteriana vs crescimento salarial.",
                                  "learningObjective": "Descrever precisamente como o TCP acelera e estabiliza o envio.",
                                  "commonMistakes": "Esquecer que Slow Start usa MSS inicial para cwnd."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender Fast Retransmit",
                                  "subSteps": [
                                    "Defina trigger: 3 duplicate ACKs indicam perda isolada.",
                                    "Explique retransmissão imediata do pacote perdido sem esperar timeout.",
                                    "Trace um exemplo: envie pacotes 1-10, perca 3, receba ACKs duplicados.",
                                    "Discuta por que 3 ACKs: equilíbrio entre falsos positivos e detecção rápida.",
                                    "Compare com timeout-based retransmit."
                                  ],
                                  "verification": "Desenhe sequência de pacotes e ACKs para um cenário de perda.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wireshark captura de TCP",
                                    "RFC 5681 Seção 3.2",
                                    "Animais interativos TCP"
                                  ],
                                  "tips": "Capture tráfego real com Wireshark para ver duplicate ACKs.",
                                  "learningObjective": "Identificar e explicar detecção rápida de perdas.",
                                  "commonMistakes": "Confundir 3 dupACKs com retransmit de todos pacotes não confirmados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Fast Recovery",
                                  "subSteps": [
                                    "Descreva Reno: após Fast Retransmit, cwnd = ssthresh + 3*MSS, infla/defla.",
                                    "Explique saída: novo ACK, cwnd = ssthresh, entra em Avoidance.",
                                    "Trace exemplo completo: perda em voo, dupACKs, recovery.",
                                    "Introduza Cubic: usa função cúbica para cwnd baseado em tempo desde última perda.",
                                    "Compare Reno (perda-based) vs Cubic (time-based)."
                                  ],
                                  "verification": "Escreva pseudocódigo para Fast Recovery em Reno e uma diferença chave do Cubic.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "RFC 3782 (Fast Recovery)",
                                    "RFC 5681 Reno",
                                    "Paper Cubic TCP",
                                    "Simulador Mininet"
                                  ],
                                  "tips": "Pense em Fast Recovery como 'pausa defensiva' no futebol após falta.",
                                  "learningObjective": "Diferenciar recovery mechanisms em variantes TCP.",
                                  "commonMistakes": "Ignorar inflação de cwnd durante dupACKs em Reno."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Comparar Algoritmos",
                                  "subSteps": [
                                    "Monte diagrama de estado completo: Slow Start -> Avoidance -> Loss -> Recovery.",
                                    "Compare Reno vs Cubic: Reno reage a perdas, Cubic otimiza para high-speed.",
                                    "Discuta métrica: throughput, fairness, RTT fairness.",
                                    "Simule cenários: bufferbloat, wireless losses.",
                                    "Resuma prós/contras em tabela."
                                  ],
                                  "verification": "Crie fluxograma dos 4 algoritmos interligados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta Draw.io para diagramas",
                                    "Comparação TCP flavors Wikipedia",
                                    "iperf para testes reais"
                                  ],
                                  "tips": "Teste com iperf3 em loopback para ver Cubic em ação.",
                                  "learningObjective": "Sintetizar descrição holística dos algoritmos.",
                                  "commonMistakes": "Subestimar impacto de Cubic em datacenters modernos."
                                }
                              ],
                              "practicalExample": "Use Wireshark para capturar tráfego HTTP em uma conexão congestionada (ex: baixe arquivo grande em rede lenta). Identifique fases: Slow Start (cwnd exponencial), duplicate ACKs trigger Fast Retransmit/Recovery, e observe cwnd drops. Analise com tcp.analysis.flags.",
                              "finalVerifications": [
                                "Descreva verbalmente o ciclo completo de um congestion event em TCP Reno.",
                                "Simule em papel uma perda de pacote e recovery com números exatos de cwnd.",
                                "Explique por que Fast Retransmit usa 3 dupACKs, não 2 ou 4.",
                                "Diferencie Reno de Cubic em um cenário de alta latência.",
                                "Capture e anote um trace Wireshark mostrando Slow Start.",
                                "Liste 3 melhorias do Cubic sobre Reno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de cada algoritmo (slow start exponencial, etc.).",
                                "Uso correto de terminologia (cwnd, ssthresh, dupACKs).",
                                "Capacidade de simular cenários numéricos ou diagramas.",
                                "Comparação clara entre Reno e Cubic.",
                                "Exemplos práticos com ferramentas como Wireshark.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções exponenciais/lineares e AIMD em otimização.",
                                "Física: Analogia com fluxo de tráfego e gargalos em tubulações.",
                                "Probabilidade: Modelagem de perdas de pacotes como eventos estocásticos.",
                                "Economia: Fairness em alocação de recursos de banda compartilhada."
                              ],
                              "realWorldApplication": "Esses algoritmos previnem colapso da internet durante picos de uso (ex: Netflix streams, Zoom calls), otimizando throughput em redes globais como WiFi doméstico ou data centers AWS, reduzindo latência em jogos online e downloads."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Diferenciar CWND e RWND",
                            "description": "Comparar a janela de congestão (CWND) para controle de rede e a janela de recepção (RWND) para controle de fluxo no emissor TCP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Controle de Fluxo e Congestionamento no TCP",
                                  "subSteps": [
                                    "Revise o modelo de camadas TCP/IP, focando na camada de transporte.",
                                    "Leia sobre controle de fluxo: mecanismo para evitar sobrecarga no receptor.",
                                    "Leia sobre controle de congestão: mecanismo para evitar sobrecarga na rede.",
                                    "Identifique que ambos usam 'janelas' para limitar dados enviados.",
                                    "Anote definições iniciais de RWND e CWND de uma fonte confiável como RFC 793."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo controle de fluxo vs. congestão, citando RWND e CWND.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 793 (TCP)",
                                    "Livro de Kurose & Ross - Redes de Computadores",
                                    "Notas em branco"
                                  ],
                                  "tips": "Use diagramas simples para visualizar fluxo de dados TCP.",
                                  "learningObjective": "Diferenciar controle de fluxo (receptor) de controle de congestão (rede).",
                                  "commonMistakes": [
                                    "Confundir fluxo com congestão desde o início.",
                                    "Ignorar que ambos afetam o emissor."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Janela de Recepção (RWND) em Detalhe",
                                  "subSteps": [
                                    "Estude como o receptor anuncia RWND no cabeçalho TCP (campo Window).",
                                    "Simule cenários: receptor lento reduz RWND; receptor rápido aumenta.",
                                    "Calcule exemplos: se buffer receptor=10KB, RWND=10 segmentos de 1KB.",
                                    "Observe que RWND é gerenciado pelo receptor e enviado para o emissor.",
                                    "Teste em ferramenta como Wireshark capturando tráfego TCP real."
                                  ],
                                  "verification": "Capture um pacote TCP em Wireshark e identifique o campo Window (RWND).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "RFC 793",
                                    "Conexão de rede local para teste"
                                  ],
                                  "tips": "Filtre por 'tcp.analysis' no Wireshark para ver variações de janela.",
                                  "learningObjective": "Compreender RWND como limite imposto pelo receptor para controle de fluxo.",
                                  "commonMistakes": [
                                    "Pensar que RWND é fixo; ele varia dinamicamente.",
                                    "Confundir com buffer do emissor."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Janela de Congestão (CWND) em Detalhe",
                                  "subSteps": [
                                    "Aprenda algoritmos de CWND: slow-start, congestion avoidance (AIMD).",
                                    "Estude triggers: ACKs aumentam CWND; perdas (timeout/duplicate ACK) reduzem.",
                                    "Calcule exemplo: CWND inicia 1 MSS, dobra por RTT até threshold.",
                                    "Compare ssthresh: limite entre slow-start e avoidance.",
                                    "Simule em ferramenta online como TCP Congestion Control Simulator."
                                  ],
                                  "verification": "Desenhe gráfico de CWND vs. tempo em slow-start e perda de pacote.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "RFC 5681 (Congestion Control)",
                                    "Simulador TCP online (ns-3 ou similar)",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Lembre: CWND é estimativa interna do emissor, não anunciada.",
                                  "learningObjective": "Dominar CWND como mecanismo proativo do emissor contra congestão.",
                                  "commonMistakes": [
                                    "Achar que CWND depende do receptor.",
                                    "Ignorar multiplicativo na redução por perda."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar CWND e RWND e Entender sua Interação",
                                  "subSteps": [
                                    "Liste diferenças: RWND (receptor, anunciado), CWND (emissor, inferido).",
                                    "Aprenda janela efetiva: min(CWND, RWND).",
                                    "Simule cenários: RWND pequeno domina; CWND pequeno em congestão.",
                                    "Analise impacto: RWND previne overflow receptor; CWND previne colapso rede.",
                                    "Crie tabela comparativa com colunas: Propósito, Gerenciado por, Ajuste, Exemplo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito 3 diferenças chave e 1 interação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela comparativa em Excel/Google Sheets",
                                    "Exemplos de tráfego Wireshark"
                                  ],
                                  "tips": "Sempre pergunte: 'Isso protege o receptor ou a rede?'",
                                  "learningObjective": "Diferenciar precisamente CWND e RWND e sua combinação no TCP.",
                                  "commonMistakes": [
                                    "Confundir qual é anunciado no cabeçalho.",
                                    "Esquecer min(CWND, RWND)."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture uma transferência HTTP durante download lento (simule rede ruim). Observe RWND caindo (receptor ocupado) e CWND sendo cortado por perdas (duplicate ACKs), resultando em throughput limitado pelo min dos dois.",
                              "finalVerifications": [
                                "Explique em 1 minuto as diferenças entre CWND e RWND para um colega.",
                                "Identifique corretamente RWND e CWND em um dump de pacotes Wireshark.",
                                "Descreva o que acontece se RWND=0 vs. CWND reduzido por congestão.",
                                "Crie tabela comparativa com 5 diferenças chave.",
                                "Simule janela efetiva com números: CWND=20, RWND=10 → efetiva=10."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições: RWND=controle fluxo receptor; CWND=controle congestão emissor.",
                                "Compreensão de interação: uso de min(CWND, RWND) como janela efetiva.",
                                "Exemplos concretos: cenários de rede lenta vs. receptor lento.",
                                "Identificação em ferramentas: localização correta em Wireshark/RFC.",
                                "Ausência de confusões comuns: não inverter gerenciadores ou propósitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos de crescimento exponencial (slow-start) e funções mínimas.",
                                "Física: Analogia com fluxo de tráfego (CWND=sinais de trânsito; RWND=capacidade da estrada).",
                                "Estatística: Análise de perdas de pacotes e médias móveis em algoritmos TCP.",
                                "Economia: Otimização de recursos compartilhados em redes (alocação justa)."
                              ],
                              "realWorldApplication": "Em data centers como Google Cloud, CWND previne colapsos em links saturados durante picos de tráfego, enquanto RWND protege servidores com buffers limitados de sobrecarga, garantindo streaming Netflix ou downloads estáveis sem interrupções."
                            },
                            "estimatedTime": "30 minutos",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Estabelecimento e Término de Conexões TCP",
                    "description": "Mecanismo de handshake de três vias para abertura e processo de fechamento de conexões TCP.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Estabelecimento de Conexão TCP via Handshake de Três Vias",
                        "description": "Mecanismo de abertura de conexões TCP utilizando a troca de três segmentos: SYN, SYN-ACK e ACK, garantindo sincronização de sequência e confirmação mútua antes da transmissão de dados.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Identificar os passos do Handshake de Três Vias",
                            "description": "Descrever sequencialmente os três passos do handshake TCP: envio do segmento SYN pelo cliente, resposta SYN-ACK pelo servidor e confirmação ACK pelo cliente, incluindo os números de sequência e confirmação iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Geral do Handshake de Três Vias TCP",
                                  "subSteps": [
                                    "Estude a definição: o handshake de três vias é o processo de estabelecimento de conexão TCP confiável entre cliente e servidor.",
                                    "Identifique o objetivo: sincronizar números de sequência e confirmação para comunicação bidirecional ordenada.",
                                    "Revise pré-requisitos: entenda segmentos TCP, campos de sequência (SEQ) e confirmação (ACK).",
                                    "Desenhe um diagrama básico de cliente-servidor com setas para os três pacotes.",
                                    "Memorize a sigla SYN-ACK para os tipos de flags usados."
                                  ],
                                  "verification": "Desenhe um fluxograma simples mostrando cliente e servidor com os três passos rotulados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama em branco",
                                    "Referência TCP/IP (RFC 793)",
                                    "Vídeo introdutório sobre TCP handshake"
                                  ],
                                  "tips": "Use cores diferentes para cliente (azul) e servidor (verde) no diagrama para visualização clara.",
                                  "learningObjective": "Explicar o propósito do handshake de três vias e seus componentes principais.",
                                  "commonMistakes": [
                                    "Confundir com UDP (sem conexão)",
                                    "Ignorar a necessidade de sincronização bidirecional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Primeiro Passo: Envio do SYN pelo Cliente",
                                  "subSteps": [
                                    "Descreva o pacote: cliente envia segmento TCP com flag SYN=1 e SEQ = valor inicial aleatório (ex: 1000).",
                                    "Explique ACK=0: sem confirmação ainda, pois é o início.",
                                    "Note opções: MSS (Maximum Segment Size) e janela de recepção.",
                                    "Simule: cliente em porta 80 para servidor na porta 443 (HTTPS).",
                                    "Registre: servidor recebe SYN e aloca recursos para conexão."
                                  ],
                                  "verification": "Escreva uma descrição textual ou capture o pacote em simulador mostrando SYN e SEQ inicial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Wireshark para captura real",
                                    "Papel para anotações"
                                  ],
                                  "tips": "Lembre-se: SEQ inicial é randômico para segurança contra replay attacks.",
                                  "learningObjective": "Identificar e descrever precisamente o conteúdo do primeiro segmento SYN.",
                                  "commonMistakes": [
                                    "Esquecer que ACK=0 no SYN inicial",
                                    "Confundir SEQ com porta de origem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Segundo Passo: Resposta SYN-ACK pelo Servidor",
                                  "subSteps": [
                                    "Descreva o pacote: servidor responde com SYN=1, ACK=1, SEQ= seu inicial (ex: 2000), ACK= SEQ_cliente +1 (1001).",
                                    "Explique sincronização: servidor confirma recebimento do SYN e inicia seu SEQ.",
                                    "Note estado: servidor entra em SYN-RECEIVED.",
                                    "Simule resposta: inclua opções como SACK permitida.",
                                    "Verifique dualidade: sincroniza ambos os sentidos."
                                  ],
                                  "verification": "Liste os valores exatos de flags, SEQ e ACK para um exemplo numérico dado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmos do step anterior",
                                    "Tabela de estados TCP"
                                  ],
                                  "tips": "Sempre ACK = SEQ_oposto +1 para confirmar um byte recebido.",
                                  "learningObjective": "Descrever o segmento SYN-ACK e calcular ACK correto.",
                                  "commonMistakes": [
                                    "Inverter SEQ e ACK",
                                    "Esquecer SYN=1 no ACK do servidor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Terceiro Passo: Confirmação ACK pelo Cliente e Conclusão",
                                  "subSteps": [
                                    "Descreva o pacote: cliente envia ACK=1, SEQ= SEQ_inicial +1 (1001), ACK= SEQ_servidor +1 (2001).",
                                    "Explique finalização: conexão estabelecida, ambos em ESTABLISHED.",
                                    "Note ausência de SYN: apenas confirmação final.",
                                    "Simule fluxo completo: trace os pacotes em sequência.",
                                    "Registre diferenças: este ACK pode carregar dados iniciais (HTTP request)."
                                  ],
                                  "verification": "Reconstrua a sequência completa com números SEQ/ACK corretos em um diagrama.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Simulador completo",
                                    "Checklist de flags TCP"
                                  ],
                                  "tips": "Pratique com exemplos numéricos variados para fixar a regra +1.",
                                  "learningObjective": "Completar a descrição do handshake identificando o ACK final e transição de estados.",
                                  "commonMistakes": [
                                    "Pensar que precisa SYN no último passo",
                                    "Não incrementar SEQ corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture um handshake TCP ao acessar google.com: filtre 'tcp.analysis.flag_syn' e 'tcp.analysis.ack_rwnd', anote SEQ/ACK em cada pacote e compare com o diagrama manual.",
                              "finalVerifications": [
                                "Liste os três passos em ordem exata: SYN, SYN-ACK, ACK.",
                                "Calcule SEQ/ACK corretos para SEQ_cliente=1000 e SEQ_servidor=500.",
                                "Desenhe diagrama com flags e valores numéricos precisos.",
                                "Explique por que três vias e não duas.",
                                "Identifique estados TCP em cada transição.",
                                "Diferencie de handshake de quatro vias no fechamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência e flags dos pacotes (100% correto).",
                                "Correção nos cálculos de SEQ e ACK (+1 regra aplicada).",
                                "Clareza no diagrama ou descrição textual.",
                                "Compreensão do propósito de sincronização bidirecional.",
                                "Identificação de estados TCP apropriados.",
                                "Exemplo prático viável com ferramenta real."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular em números de sequência (32-bit wrap-around).",
                                "Física: Analogia com sinais eletromagnéticos em transmissão de pacotes.",
                                "Segurança da Informação: Importância de SEQ randômico contra ataques.",
                                "Programação: Implementação em sockets Python (socket.connect())."
                              ],
                              "realWorldApplication": "Todo acesso web (HTTPS, HTTP) inicia com esse handshake; falhas causam 'Connection refused'; usado em apps como Zoom, email SMTP/IMAP para conexões confiáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Explicar o papel das flags SYN e ACK",
                            "description": "Detalhar o funcionamento das flags SYN (sincronização de sequência) e ACK (confirmação), incluindo como o SYN inicia o número de sequência ISN e o ACK confirma o recebimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos das Flags TCP",
                                  "subSteps": [
                                    "Estude a estrutura do cabeçalho TCP, focando no campo de flags (6 bits).",
                                    "Identifique as flags principais: SYN, ACK, FIN, RST, etc.",
                                    "Revise o que são números de sequência (sequence numbers) e números de confirmação (acknowledgment numbers).",
                                    "Analise um diagrama genérico do cabeçalho TCP.",
                                    "Anote definições chave: SYN para sincronização, ACK para confirmação."
                                  ],
                                  "verification": "Resuma em suas palavras o propósito das flags TCP e liste pelo menos 4 flags com suas funções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama do cabeçalho TCP (RFC 793), Wireshark para captura de pacotes reais.",
                                  "tips": "Use cores para destacar flags no diagrama para melhor memorização visual.",
                                  "learningObjective": "Entender a posição e o papel geral das flags no cabeçalho TCP.",
                                  "commonMistakes": "Confundir flags de controle com campos de porta ou confundir SYN com ACK."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Função da Flag SYN",
                                  "subSteps": [
                                    "Leia sobre o Initial Sequence Number (ISN) gerado aleatoriamente pelo cliente.",
                                    "Entenda que SYN=1 inicia a sincronização de sequência sem enviar dados.",
                                    "Simule o primeiro pacote: SYN=1, ACK=0, seq=X (ISN do cliente).",
                                    "Discuta por que o ISN é aleatório (segurança contra ataques de sequência previsível).",
                                    "Capture um pacote SYN real usando Wireshark."
                                  ],
                                  "verification": "Desenhe o primeiro pacote SYN e rotule seq, SYN e ACK flags.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta Wireshark, RFC 793 seção sobre conexão establishment.",
                                  "tips": "Lembre-se: SYN é como apertar a campainha para iniciar conversa sem dizer nada ainda.",
                                  "learningObjective": "Dominar como SYN inicia o handshake e define o ISN.",
                                  "commonMistakes": "Achar que SYN carrega dados ou que seq começa em 0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Função da Flag ACK",
                                  "subSteps": [
                                    "Aprenda que ACK=1 confirma o recebimento de dados ou sincronização.",
                                    "No segundo pacote: SYN=1, ACK=1, seq=Y (ISN servidor), ack=X+1 (confirma SYN cliente).",
                                    "No terceiro: ACK=1, seq=X+1, ack=Y+1 (cliente confirma servidor).",
                                    "Diferencie ACK de confirmação cumulativa vs. seletiva.",
                                    "Analise captura Wireshark de um handshake completo."
                                  ],
                                  "verification": "Explique a diferença nos valores de seq e ack entre os três pacotes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Wireshark captura de TCP SYN-ACK, diagramas animados de handshake TCP.",
                                  "tips": "Pense em ACK como 'recebido e pronto para próximo' – sempre ack = seq esperado +1 para SYN.",
                                  "learningObjective": "Compreender como ACK garante confiabilidade no handshake.",
                                  "commonMistakes": "Confundir o ack number com seq number ou ignorar o +1 para SYN."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar SYN e ACK no Three-Way Handshake",
                                  "subSteps": [
                                    "Monte o fluxo completo: 1. Cliente SYN, 2. Servidor SYN-ACK, 3. Cliente ACK.",
                                    "Simule falhas: o que acontece sem ACK final (timeout/retransmissão).",
                                    "Compare com UDP (sem handshake) para destacar TCP reliability.",
                                    "Crie um diagrama timeline dos pacotes.",
                                    "Teste com telnet ou curl para observar handshake."
                                  ],
                                  "verification": "Descreva os três pacotes com flags, seq e ack exatos em um exemplo numérico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas como tcpdump, Wireshark, simulador online de TCP (ex: Wireshark dissecação).",
                                  "tips": "Numere seq como 1000 para cliente, 2000 para servidor e trace os acks.",
                                  "learningObjective": "Sintetizar o papel conjunto de SYN e ACK na conexão TCP.",
                                  "commonMistakes": "Esquecer que SYN-ACK tem ambas flags setadas ou inverter cliente/servidor."
                                }
                              ],
                              "practicalExample": "Use Wireshark para capturar o handshake TCP ao acessar google.com:80. Identifique pacote 1 (SYN do seu PC, seq=123456, SYN=1), pacote 2 (SYN-ACK do Google, seq=789012, ack=123457), pacote 3 (ACK seu, seq=123457, ack=789013).",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo SYN -> SYN-ACK -> ACK com seq/ack numbers.",
                                "Desenhar diagrama correto do handshake sem erros em flags.",
                                "Identificar SYN e ACK em uma captura Wireshark real.",
                                "Diferenciar SYN (inicia seq) de ACK (confirma receipt).",
                                "Simular handshake com números específicos e validar acks.",
                                "Explicar por que ISN é randômico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de SYN como sincronizador de ISN.",
                                "Correta representação de ACK confirmando seq +1.",
                                "Compreensão integrada do three-way handshake.",
                                "Uso correto de terminologia (ISN, seq, ack).",
                                "Capacidade de analisar capturas Wireshark.",
                                "Identificação de erros comuns em handshakes falhos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências aritméticas nos números seq/ack (+1 por byte/SYN).",
                                "Segurança da Informação: Importância de ISN randômico contra TCP sequence prediction attacks.",
                                "Física: Analogia com sinais de handshake em comunicação analógica (sincronização de clocks).",
                                "Programação: Implementação em sockets Python (socket.SOCK_STREAM)."
                              ],
                              "realWorldApplication": "Em navegadores web, o TCP SYN-ACK garante que sites como YouTube carreguem dados confiavelmente sem perda durante streaming; falhas no handshake causam erros de conexão em apps como Zoom ou banking online."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Reconhecer o estado half-open",
                            "description": "Explicar o conceito de conexão half-open durante o handshake, onde o servidor está pronto mas aguarda o ACK final do cliente, e sua importância para evitar conexões inválidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Handshake TCP de Três Vias Normal",
                                  "subSteps": [
                                    "Estude o fluxo padrão: Cliente envia SYN, Servidor responde SYN-ACK, Cliente envia ACK.",
                                    "Desenhe um diagrama temporal mostrando as mensagens trocadas e os estados de cada lado.",
                                    "Identifique os estados TCP: CLOSED, SYN_SENT, SYN_RCVD, ESTABLISHED.",
                                    "Explique o papel de cada flag (SYN, ACK) nas mensagens.",
                                    "Simule mentalmente o que acontece se uma mensagem for perdida."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama do handshake completo sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como draw.io",
                                    "Documentação RFC 793 sobre TCP"
                                  ],
                                  "tips": "Use setas direcionais no diagrama para indicar o fluxo cliente-servidor.",
                                  "learningObjective": "Compreender a sequência normal de estabelecimento de conexão TCP.",
                                  "commonMistakes": [
                                    "Confundir SYN-ACK com ACK-SYN",
                                    "Ignorar estados intermediários como SYN_RCVD"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Conceito de Estado Half-Open",
                                  "subSteps": [
                                    "Defina half-open: Servidor em SYN_RCVD após enviar SYN-ACK, aguardando ACK do cliente.",
                                    "Compare com conexão fully open (ESTABLISHED após ACK recebido).",
                                    "Liste diferenças: Half-open não permite envio de dados, timeout se ACK não chegar.",
                                    "Analise logs ou diagramas onde o ACK é perdido ou atrasado.",
                                    "Explique por que o servidor mantém recursos alocados nesse estado."
                                  ],
                                  "verification": "Explique em 2-3 frases o que é half-open e aponte seu local no diagrama do Step 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama do Step 1",
                                    "Vídeo tutorial sobre estados TCP (ex: YouTube 'TCP Handshake')"
                                  ],
                                  "tips": "Lembre-se: 'Half-open' é do ponto de vista do servidor; cliente pode estar fechado.",
                                  "learningObjective": "Reconhecer precisamente quando e por que uma conexão entra em half-open.",
                                  "commonMistakes": [
                                    "Achar que half-open é após SYN do cliente",
                                    "Confundir com TIME_WAIT ou CLOSE_WAIT"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender a Importância para Evitar Conexões Inválidas",
                                  "subSteps": [
                                    "Discuta riscos: Ataques SYN flood exploram half-open para esgotar recursos do servidor.",
                                    "Explique timeouts: Servidor descarta half-open após retransmissões falhas.",
                                    "Descreva como ACK final valida a conexão legítima.",
                                    "Analise impacto: Half-open consome memória e portas sem conexão real.",
                                    "Pesquise mitigações como SYN cookies."
                                  ],
                                  "verification": "Liste 3 razões pelas quais half-open previne conexões inválidas e descreva um ataque relacionado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo sobre SYN flood (ex: Wikipedia ou Cisco docs)",
                                    "Ferramenta de simulação TCP como Packet Tracer"
                                  ],
                                  "tips": "Pense em half-open como 'prova de compromisso' do cliente via ACK.",
                                  "learningObjective": "Compreender o papel de segurança do estado half-open no TCP.",
                                  "commonMistakes": [
                                    "Subestimar consumo de recursos em half-open",
                                    "Confundir com ataques UDP flood"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Visualizar Estado Half-Open",
                                  "subSteps": [
                                    "Use Wireshark para capturar um handshake real e identifique SYN_RCVD.",
                                    "Simule half-open: Envie SYN, receba SYN-ACK, mas não envie ACK (use ferramenta como hping3).",
                                    "Monitore netstat/ss no servidor para ver estado SYN_RECV.",
                                    "Registre timeout e retransmissão do SYN-ACK.",
                                    "Compare captura com diagrama teórico."
                                  ],
                                  "verification": "Capture e anote uma conexão half-open com evidência de SYN_RECV no servidor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Dois computadores ou VMs",
                                    "Comando netstat/ss ou hping3"
                                  ],
                                  "tips": "Filtre Wireshark por 'tcp.flags.syn==1 and tcp.flags.ack==1' para SYN-ACK.",
                                  "learningObjective": "Aplicar conhecimento para detectar half-open em cenários reais.",
                                  "commonMistakes": [
                                    "Não filtrar tráfego corretamente",
                                    "Confundir SYN_RECV com ESTABLISHED"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor web Apache, ao receber um SYN flood, o netstat mostra milhares de entradas em SYN_RECV (half-open). Usando Wireshark, você vê SYN seguido de SYN-ACK sem ACK, consumindo slots de conexão até timeout de 60s, demonstrando como atacantes esgotam recursos sem completar o handshake.",
                              "finalVerifications": [
                                "Desenhe o diagrama do handshake destacando o half-open.",
                                "Explique verbalmente a diferença entre half-open e established.",
                                "Identifique SYN_RECV em uma saída de netstat simulada.",
                                "Descreva um cenário de ataque explorando half-open.",
                                "Liste mitigações para half-open excessivo."
                              ],
                              "assessmentCriteria": [
                                "Diagrama preciso com estados e flags corretos (80% acurácia).",
                                "Explicação clara de half-open sem confusão com outros estados.",
                                "Identificação correta em ferramentas como Wireshark/netstat.",
                                "Compreensão de implicações de segurança e timeouts.",
                                "Exemplo prático relevante e acionável."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: Mitigação de DDoS via SYN cookies.",
                                "Programação de Redes: Implementação de sockets em Python (socket.AF_INET, SOCK_STREAM).",
                                "Matemática: Modelos probabilísticos de timeouts e retransmissões.",
                                "Engenharia de Software: Gerenciamento de recursos em servidores escaláveis."
                              ],
                              "realWorldApplication": "Em data centers como AWS ou Google Cloud, monitoramento de half-open connections via ferramentas como tcpdump previne falhas por SYN floods, garantindo alta disponibilidade de serviços web e APIs sob carga pesada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.4",
                            "name": "Simular o handshake em diagrama",
                            "description": "Construir um diagrama temporal ilustrando a troca de segmentos SYN, SYN-ACK e ACK entre cliente e servidor, com valores exemplo de números de sequência e confirmação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais do Handshake TCP",
                                  "subSteps": [
                                    "Leia a definição do handshake de três vias: SYN do cliente inicia, SYN-ACK do servidor responde, ACK do cliente finaliza.",
                                    "Identifique os campos chave: Número de Sequência (SEQ), Número de Confirmação (ACK), flags SYN e ACK.",
                                    "Estude exemplos de valores iniciais: Cliente SEQ=1000, Servidor SEQ=2000.",
                                    "Anote as regras: ACK = SEQ recebido + 1.",
                                    "Desenhe esboços simples de cada segmento em um papel."
                                  ],
                                  "verification": "Liste corretamente os três segmentos e suas funções em uma folha de verificação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, caneta, acesso a documentação TCP (RFC 793 ou diagrama online).",
                                  "tips": "Use cores diferentes para cliente (azul) e servidor (verde) para visualizar melhor.",
                                  "learningObjective": "Compreender a sequência lógica e os campos essenciais do handshake TCP.",
                                  "commonMistakes": "Confundir SYN-ACK com ACK simples; ignorar que SYN inclui SEQ inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a Estrutura do Diagrama Temporal",
                                  "subSteps": [
                                    "Desenhe duas linhas paralelas horizontais: uma para Cliente (topo) e uma para Servidor (base).",
                                    "Marque pontos de tempo ao longo das linhas: T0 (início), T1 (SYN chega), T2 (SYN-ACK chega), T3 (ACK chega).",
                                    "Adicione setas direcionais entre as linhas para indicar fluxo: Cliente -> Servidor (SYN), Servidor -> Cliente (SYN-ACK e ACK).",
                                    "Rotule as setas com 'SYN', 'SYN-ACK', 'ACK'.",
                                    "Inclua legendas para SEQ e ACK em cada seta."
                                  ],
                                  "verification": "O diagrama mostra linhas paralelas com setas na ordem correta sem sobreposições erradas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado ou ferramenta digital como Draw.io ou Lucidchart.",
                                  "tips": "Mantenha espaçamento uniforme entre tempos para clareza visual.",
                                  "learningObjective": "Criar uma representação temporal precisa da comunicação cliente-servidor.",
                                  "commonMistakes": "Desenhar setas bidirecionais em vez de unidirecionais; inverter cliente/servidor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inserir Valores de Sequência e Confirmação",
                                  "subSteps": [
                                    "Atribua SEQ inicial ao cliente SYN: ex. SEQ=1000.",
                                    "No SYN-ACK do servidor: SEQ=2000, ACK=1001 (SEQ cliente +1).",
                                    "No ACK do cliente: SEQ=1001, ACK=2001 (SEQ servidor +1).",
                                    "Verifique aritmética: cada ACK confirma o próximo byte esperado.",
                                    "Adicione rótulos nos diagramas: 'SYN SEQ=1000', etc."
                                  ],
                                  "verification": "Calcule e confirme que ACKs correspondem corretamente aos SEQs anteriores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora para aritmética de sequência, ferramenta de diagrama.",
                                  "tips": "Use números pequenos e redondos para evitar erros de cálculo.",
                                  "learningObjective": "Aplicar regras de numeração SEQ/ACK no contexto do handshake.",
                                  "commonMistakes": "Esquecer +1 no ACK; usar mesmo SEQ em respostas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar e Anotar o Diagrama Completo",
                                  "subSteps": [
                                    "Adicione anotações explicativas para cada seta: função e valores.",
                                    "Inclua título: 'Handshake TCP de Três Vias - Exemplo com SEQ/ACK'.",
                                    "Desenhe caixas para estados: CLOSED -> SYN_SENT -> ESTABLISHED.",
                                    "Revise o diagrama contra um modelo padrão.",
                                    "Salve ou fotografe o diagrama final."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o fluxo completo usando o diagrama.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Ferramenta de diagrama para exportar imagem.",
                                  "tips": "Teste explicando para um 'parceiro imaginário' para garantir clareza.",
                                  "learningObjective": "Produzir um diagrama anotado pronto para apresentação ou estudo.",
                                  "commonMistakes": "Omitir estados de conexão; setas desalinhadas temporalmente."
                                }
                              ],
                              "practicalExample": "Em uma conexão HTTP para carregar uma página web: Cliente envia SYN (SEQ=1000) ao servidor Google; servidor responde SYN-ACK (SEQ=5000, ACK=1001); cliente finaliza com ACK (SEQ=1001, ACK=5001). Diagrama mostra isso em linhas paralelas com setas rotuladas.",
                              "finalVerifications": [
                                "Pode recriar o diagrama de memória com valores corretos?",
                                "Explica a importância do +1 nos ACKs?",
                                "Identifica erros em um diagrama fornecido com troca invertida?",
                                "Descreve o que acontece se um segmento for perdido?",
                                "Compara com handshake UDP (ausência de handshake)?",
                                "Aplica valores diferentes e verifica consistência?"
                              ],
                              "assessmentCriteria": [
                                "Ordem temporal dos segmentos SYN, SYN-ACK, ACK está correta (20%)",
                                "Valores de SEQ e ACK seguem regras aritméticas precisas (30%)",
                                "Diagrama visual é claro, com setas direcionais e rótulos legíveis (20%)",
                                "Estados de conexão (CLOSED, SYN_SENT, ESTABLISHED) incluídos (15%)",
                                "Anotações explicam flags e funções (10%)",
                                "Ausência de erros comuns como inversão de papéis (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e sequências numéricas em redes.",
                                "Física: Analogia com sinais eletromagnéticos em comunicação.",
                                "Linguagens: Protocolos como 'linguagem formal' entre máquinas.",
                                "História da Computação: Evolução de protocolos confiáveis desde ARPANET.",
                                "Artes: Design gráfico para diagramas de fluxo claros."
                              ],
                              "realWorldApplication": "Todo acesso à internet (HTTPS, email SMTP, streaming Netflix) inicia com esse handshake TCP para garantir conexão confiável, evitando perda de dados em redes instáveis como Wi-Fi público."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Término de Conexão TCP",
                        "description": "Processo de fechamento ordenado de conexões TCP utilizando flags FIN e ACK em quatro vias, permitindo que ambas as partes iniciem o encerramento de forma independente.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Descrever os passos do fechamento em quatro vias",
                            "description": "Explicar a sequência: FIN do lado ativo, ACK do passivo, FIN do passivo e ACK final do ativo, destacando o tempo de espera (2MSL) para evitar dados atrasados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "O lado ativo inicia o fechamento enviando o segmento FIN",
                                  "subSteps": [
                                    "Identifique o lado ativo como o que inicia o fechamento da conexão TCP.",
                                    "O lado ativo envia um segmento FIN (Finish) com seu número de sequência atual.",
                                    "Ao enviar o FIN, o lado ativo entra no estado FIN_WAIT_1.",
                                    "Explique que o FIN indica que não há mais dados a enviar do lado ativo.",
                                    "Registre o número de sequência do FIN para rastreamento futuro."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando o envio do FIN e a transição para FIN_WAIT_1, confirmando com um colega ou ferramenta de simulação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de estados TCP",
                                    "Ferramenta Wireshark ou simulador TCP (ex: Cisco Packet Tracer)",
                                    "Livro de redes como 'Computer Networking: A Top-Down Approach'"
                                  ],
                                  "tips": [
                                    "Visualize o FIN como um 'eu terminei de enviar dados' para fixar o conceito.",
                                    "Anote os números de sequência para evitar confusão posterior."
                                  ],
                                  "learningObjective": "Compreender o papel do lado ativo no início do processo de fechamento TCP.",
                                  "commonMistakes": [
                                    "Confundir FIN com SYN do handshake de abertura.",
                                    "Esquecer a transição imediata para o estado FIN_WAIT_1.",
                                    "Ignorar que o FIN inclui número de sequência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "O lado passivo responde com ACK ao FIN recebido",
                                  "subSteps": [
                                    "O lado passivo recebe o FIN e envia um ACK (Acknowledgment) com o próximo número de sequência esperado.",
                                    "Ao enviar o ACK, o lado passivo entra no estado CLOSE_WAIT.",
                                    "O lado ativo, ao receber o ACK, transita para o estado FIN_WAIT_2.",
                                    "Confirme que o ACK reconhece o FIN, mas a conexão ainda está semi-fechada.",
                                    "Discuta por que o passivo não fecha imediatamente."
                                  ],
                                  "verification": "Simule o tráfego em Wireshark e verifique o ACK correspondente ao FIN inicial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Captura de tráfego TCP real ou simulada",
                                    "Folha para anotar estados"
                                  ],
                                  "tips": [
                                    "Lembre-se: ACK confirma recebimento, mas não inicia fechamento.",
                                    "Use setas em diagramas para mostrar o fluxo bidirecional."
                                  ],
                                  "learningObjective": "Entender a confirmação do FIN pelo lado passivo e as transições de estado envolvidas.",
                                  "commonMistakes": [
                                    "Inverter os estados: confundir CLOSE_WAIT com FIN_WAIT_2.",
                                    "Pensar que o ACK fecha a conexão unilateralmente.",
                                    "Esquecer o número de ACK como seq+1."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "O lado passivo envia seu próprio FIN após finalizar envios",
                                  "subSteps": [
                                    "O lado passivo, no estado CLOSE_WAIT, finaliza seus dados pendentes.",
                                    "Envie o FIN do lado passivo com seu número de sequência.",
                                    "O lado passivo transita para o estado LAST_ACK após enviar o FIN.",
                                    "O lado ativo, ao receber este FIN, envia ACK e entra em TIME_WAIT.",
                                    "Explique que agora ambos os lados indicaram fim de envio."
                                  ],
                                  "verification": "Crie um diagrama completo até este ponto e explique verbalmente a sequência para verificação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Simulador TCP online",
                                    "Referência RFC 793 para TCP states"
                                  ],
                                  "tips": [
                                    "No CLOSE_WAIT, o app deve fechar o socket para prosseguir.",
                                    "Compare com o FIN inicial para simetria."
                                  ],
                                  "learningObjective": "Dominar o fechamento simétrico iniciado pelo lado passivo.",
                                  "commonMistakes": [
                                    "Confundir LAST_ACK com TIME_WAIT.",
                                    "Esquecer que o passivo pode enviar dados antes do FIN.",
                                    "Ignorar ACK imediato do ativo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "ACK final e estado TIME_WAIT com espera 2MSL",
                                  "subSteps": [
                                    "O lado ativo envia ACK para o FIN do passivo e entra em TIME_WAIT.",
                                    "O lado passivo, ao receber o ACK, transita para CLOSED.",
                                    "Explique o TIME_WAIT: espera 2MSL (2 * Maximum Segment Lifetime) para evitar dados atrasados.",
                                    "Discuta riscos de duplicatas sem 2MSL (ex: ACK perdido gera novo handshake com dados velhos).",
                                    "Após 2MSL, o ativo vai para CLOSED."
                                  ],
                                  "verification": "Explique o propósito do 2MSL em uma apresentação curta e teste com quiz sobre riscos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Cronômetro para simular 2MSL",
                                    "Artigo sobre TIME_WAIT issues",
                                    "Wireshark para observar TIME_WAIT"
                                  ],
                                  "tips": [
                                    "2MSL ≈ 2-4 minutos; evite reduzir em produção.",
                                    "TIME_WAIT protege contra 'fantasmas' de conexões antigas."
                                  ],
                                  "learningObjective": "Compreender a importância do TIME_WAIT e 2MSL para fechamento robusto.",
                                  "commonMistakes": [
                                    "Subestimar 2MSL como desnecessário.",
                                    "Confundir quem fica em TIME_WAIT (sempre o ativo).",
                                    "Ignorar que CLOSED é final só após ACK."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma sessão SSH: após digitar 'exit', o cliente (ativo) envia FIN; servidor ACK, envia dados finais, FIN; cliente ACK e espera 2MSL antes de reutilizar porta, evitando confusão com pacotes atrasados de sessões anteriores.",
                              "finalVerifications": [
                                "Desenhar e rotular corretamente o diagrama dos 4 passos com estados TCP.",
                                "Explicar verbalmente a sequência FIN-ACK-FIN-ACK sem erros.",
                                "Identificar o propósito do 2MSL e riscos sem ele.",
                                "Simular em Wireshark uma captura real de fechamento TCP.",
                                "Responder quiz com 90% de acerto sobre estados e sequência.",
                                "Comparar com abertura de conexão (3 vias)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência exata dos 4 segmentos (FIN, ACK, FIN, ACK).",
                                "Correta identificação de todos os estados TCP transitados.",
                                "Explicação clara do papel do TIME_WAIT e 2MSL.",
                                "Uso correto de terminologia (ativo/passivo, seq/ACK numbers).",
                                "Capacidade de diagramar fluxograma completo e legível.",
                                "Demonstração prática via simulação ou Wireshark.",
                                "Ausência de confusão com handshake de abertura SYN."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem como autômato finito com estados TCP.",
                                "Segurança da Informação: Prevenção de ataques de replay via TIME_WAIT.",
                                "Física: Analogia com fechamento de portas duplas em sistemas hidráulicos.",
                                "Programação: Implementação em sockets (ex: close() em C/Python).",
                                "Estatística: Análise de tráfego de rede para taxas de fechamento."
                              ],
                              "realWorldApplication": "Em servidores web como Apache/Nginx, o TIME_WAIT garante que portas sejam reutilizadas com segurança após milhões de conexões HTTP/S, evitando perda de dados atrasados em redes instáveis e melhorando a confiabilidade de serviços como streaming ou e-commerce."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Identificar o uso das flags FIN e ACK no fechamento",
                            "description": "Detalhar como a flag FIN solicita o encerramento gracioso e ACK confirma o recebimento, permitindo fechamento assimétrico onde cada lado gerencia seu próprio término.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Conceito de Fechamento Gracioso em TCP",
                                  "subSteps": [
                                    "Explique o que significa 'fechamento gracioso' em TCP e por que ele é necessário para evitar perda de dados.",
                                    "Descreva os estados envolvidos no término de conexão: FIN_WAIT_1, FIN_WAIT_2, TIME_WAIT.",
                                    "Compare fechamento gracioso com reset abrupto (RST flag).",
                                    "Identifique que o fechamento é assimétrico, permitindo que cada lado feche independentemente.",
                                    "Estude o diagrama padrão de 4 vias para término TCP."
                                  ],
                                  "verification": "Resuma em um parágrafo os motivos para fechamento gracioso e liste os estados principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama TCP state diagram (RFC 793), Wireshark para exemplos reais.",
                                  "tips": "Use animações interativas online para visualizar transições de estado.",
                                  "learningObjective": "Compreender o propósito e a necessidade do fechamento gracioso em TCP.",
                                  "commonMistakes": "Confundir fechamento TCP com UDP (sem conexão) ou ignorar o TIME_WAIT."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Flag FIN e Seu Papel no Início do Fechamento",
                                  "subSteps": [
                                    "Defina a flag FIN: Finaliza o envio de dados e solicita término da conexão.",
                                    "Explique como um host envia FIN quando não tem mais dados a enviar.",
                                    "Descreva a transição para FIN_WAIT_1 após envio de FIN.",
                                    "Analise o pacote: FIN=1, SEQ=próximo byte não enviado, ACK=confirmar dados recebidos.",
                                    "Simule o envio de FIN em uma ferramenta de captura de pacotes."
                                  ],
                                  "verification": "Desenhe um pacote TCP com FIN setado e rotule os campos SEQ e ACK.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta como tcpdump ou Wireshark, RFC 793 seção sobre FIN.",
                                  "tips": "Lembre-se: FIN não para o recebimento de dados; é half-close.",
                                  "learningObjective": "Identificar e descrever o uso da flag FIN para solicitar encerramento.",
                                  "commonMistakes": "Pensar que FIN para imediatamente a conexão em ambos os lados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Flag ACK na Confirmação do FIN",
                                  "subSteps": [
                                    "Defina ACK no contexto de fechamento: Confirma recebimento do FIN.",
                                    "Explique a resposta: Receptor envia ACK com ACK=SEQ do FIN +1.",
                                    "Descreva transição para CLOSE_WAIT no receptor.",
                                    "Mostre como ACK permite que o remetedor entre em FIN_WAIT_2.",
                                    "Diferencie ACK de FIN-ACK: ACK sozinho confirma, mas FIN pode vir junto."
                                  ],
                                  "verification": "Capture um fechamento real e destaque o pacote ACK respondendo ao FIN.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Wireshark com filtro 'tcp.flags.fin==1 or tcp.flags.ack==1', exemplos de tráfego HTTP.",
                                  "tips": "Filtre Wireshark por 'tcp.analysis.finack' para exemplos rápidos.",
                                  "learningObjective": "Explicar como ACK confirma FIN e habilita half-close.",
                                  "commonMistakes": "Confundir ACK de confirmação com ACKs normais de dados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Verificar o Fechamento Assimétrico Completo",
                                  "subSteps": [
                                    "Monte a sequência completa: A:FIN -> B:ACK -> B:FIN -> A:ACK.",
                                    "Explique por que 4 pacotes (dois half-closes).",
                                    "Simule em ferramenta como Packet Tracer ou código Python sockets.",
                                    "Analise TIME_WAIT para evitar reutilização de portas.",
                                    "Teste cenários onde um lado fecha primeiro."
                                  ],
                                  "verification": "Crie um diagrama de sequência com flags FIN/ACK rotuladas e estados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Cisco Packet Tracer, Python socket library, diagramas online TCP.",
                                  "tips": "Use netstat ou ss para ver estados TIME_WAIT em conexões reais.",
                                  "learningObjective": "Demonstrar o processo assimétrico usando FIN e ACK.",
                                  "commonMistakes": "Assumir fechamento simétrico como no SYN (3 vias)."
                                }
                              ],
                              "practicalExample": "Ao fechar uma conexão HTTP após carregar uma página web, o cliente envia FIN para o servidor (não mais dados a enviar), servidor responde ACK (confirma), servidor envia seu FIN (termina envio), cliente ACK. Capture com Wireshark em 'curl http://example.com' e filtre por tcp.flags.fin==1.",
                              "finalVerifications": [
                                "Explicar verbalmente a sequência FIN-ACK-FIN-ACK.",
                                "Identificar FIN e ACK em uma captura Wireshark real.",
                                "Desenhar diagrama de estados para fechamento assimétrico.",
                                "Diferenciar half-close de full-close.",
                                "Prever comportamento se ACK for perdido.",
                                "Listar vantagens do fechamento gracioso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das flags FIN e ACK (100% correto).",
                                "Completude da sequência de 4 vias com estados.",
                                "Uso correto de exemplos práticos como Wireshark.",
                                "Identificação de erros comuns evitados.",
                                "Clareza no diagrama ou simulação.",
                                "Compreensão de assimetria e TIME_WAIT."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos finitos modelando estados TCP.",
                                "Segurança: Análise de ataques como SYN flood no contexto de FIN.",
                                "Física: Analogia com sinais de parada em comunicação analógica.",
                                "Programação: Implementação em sockets Python/C."
                              ],
                              "realWorldApplication": "Em servidores web como Apache/Nginx, o fechamento TCP com FIN/ACK garante que emails sejam enviados completamente antes de encerrar sessões SMTP, evitando perda de dados em transações bancárias online ou streaming de vídeo onde um lado para de enviar mas continua recebendo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Explicar os estados FIN_WAIT e TIME_WAIT",
                            "description": "Descrever os estados TCP FIN_WAIT_1, FIN_WAIT_2, CLOSE_WAIT, LAST_ACK e TIME_WAIT, com ênfase no TIME_WAIT para lidar com pacotes duplicados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Processo Geral de Estabelecimento e Término de Conexões TCP",
                                  "subSteps": [
                                    "Estude o three-way handshake para entender o contexto de estabelecimento de conexão.",
                                    "Identifique as diferenças entre abertura e fechamento de conexões TCP (fechamento é assimétrico).",
                                    "Desenhe um diagrama simples do fluxo de término TCP com os estados principais.",
                                    "Leia a RFC 793 para referências oficiais sobre estados de conexão.",
                                    "Anote as transições iniciais: envio de FIN e recepção de ACK."
                                  ],
                                  "verification": "Você pode listar e diagramar os 4 passos básicos do término TCP sem consultar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 793 (TCP Specification)",
                                    "Diagramas de estados TCP (online ou livro de redes)"
                                  ],
                                  "tips": "Use ferramentas como draw.io para criar diagramas visuais e reforçar a memória.",
                                  "learningObjective": "Compreender o contexto geral do término de conexão TCP antes de mergulhar nos estados específicos.",
                                  "commonMistakes": [
                                    "Confundir o three-way handshake com o four-way terminate.",
                                    "Ignorar a assimetria do fechamento."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar os Estados FIN_WAIT_1 e FIN_WAIT_2",
                                  "subSteps": [
                                    "Descreva FIN_WAIT_1: estado após envio de FIN pelo lado ativo, aguardando ACK.",
                                    "Explique a transição para FIN_WAIT_2 após recepção do ACK do peer.",
                                    "Simule o fluxo: lado A envia FIN → FIN_WAIT_1 → recebe ACK → FIN_WAIT_2.",
                                    "Discuta timeouts associados a esses estados para evitar travamentos.",
                                    "Compare com o lado passivo que entra em CLOSE_WAIT ao receber FIN."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre FIN_WAIT_1 e FIN_WAIT_2 com um exemplo de sequência de pacotes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark para capturar tráfego real",
                                    "Livro 'TCP/IP Illustrated' Vol.1"
                                  ],
                                  "tips": "Capture uma conexão real com netcat ou telnet para observar esses estados.",
                                  "learningObjective": "Dominar as transições e papéis dos estados FIN_WAIT no lado que inicia o fechamento.",
                                  "commonMistakes": [
                                    "Confundir FIN_WAIT com estados do lado passivo.",
                                    "Esquecer que FIN_WAIT_2 persiste até receber FIN do peer."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever os Estados CLOSE_WAIT e LAST_ACK",
                                  "subSteps": [
                                    "Defina CLOSE_WAIT: estado no lado passivo após ACK de FIN recebido e antes de enviar seu FIN.",
                                    "Explique LAST_ACK: após envio de FIN pelo lado passivo, aguardando ACK final.",
                                    "Trace o fluxo completo: A em FIN_WAIT_2 recebe FIN de B → envia ACK → B em LAST_ACK.",
                                    "Identifique ações do aplicativo: em CLOSE_WAIT, app deve fechar socket para prosseguir.",
                                    "Note erros comuns como 'stuck in CLOSE_WAIT' devido a app não fechando socket."
                                  ],
                                  "verification": "Desenhe o diagrama completo mostrando CLOSE_WAIT e LAST_ACK no contexto de ambos os lados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (Lucidchart ou papel)",
                                    "Exemplos de código socket em Python/C"
                                  ],
                                  "tips": "Implemente um servidor simples que fecha conexão para observar CLOSE_WAIT.",
                                  "learningObjective": "Entender o comportamento do lado passivo durante o término.",
                                  "commonMistakes": [
                                    "Achar que CLOSE_WAIT é simétrico ao FIN_WAIT.",
                                    "Ignorar responsabilidade do app em CLOSE_WAIT."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aprofundar no Estado TIME_WAIT e Seu Propósito com Pacotes Duplicados",
                                  "subSteps": [
                                    "Descreva TIME_WAIT: estado final no lado ativo após ACK do FIN peer, dura 2x MSL (Maximum Segment Lifetime).",
                                    "Explique o propósito: absorver pacotes duplicados atrasados para evitar reutilização de conexão.",
                                    "Calcule duração típica: 2 minutos em implementações comuns (240 segundos).",
                                    "Discuta impactos: alto número de TIME_WAIT pode esgotar portas efêmeras (problema em servidores busy).",
                                    "Aprenda soluções: reuseport, fast recycle, ou TIME_WAIT assassination (com riscos)."
                                  ],
                                  "verification": "Explique por que TIME_WAIT previne problemas com duplicados e liste 3 soluções para excesso de TIME_WAIT.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "netstat/ss comandos para listar conexões TIME_WAIT",
                                    "Artigo 'TIME_WAIT Blackhole' de Bryan Cantrill"
                                  ],
                                  "tips": "Execute 'ss -tan state time-wait' em um sistema Linux para ver TIME_WAIT reais.",
                                  "learningObjective": "Mestre o estado TIME_WAIT, enfatizando seu papel crítico em robustez de rede.",
                                  "commonMistakes": [
                                    "Subestimar duração (não é fixa)",
                                    "Confundir com CLOSED (TIME_WAIT ainda aloca recursos)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Todos os Estados em um Fluxo Completo e Simular",
                                  "subSteps": [
                                    "Monte o diagrama completo: FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT e paralelos CLOSE_WAIT → LAST_ACK.",
                                    "Simule com código: crie cliente/servidor que fecha conexões e observe estados com ss/netstat.",
                                    "Analise captura Wireshark de término TCP real.",
                                    "Teste cenários de duplicados: use tcpreplay para simular pacotes atrasados.",
                                    "Documente diferenças em cenários simultâneos ou half-close."
                                  ],
                                  "verification": "Crie e apresente um diagrama interativo ou vídeo explicando o fluxo inteiro.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python socket library",
                                    "Wireshark",
                                    "tcpreplay ou similar"
                                  ],
                                  "tips": "Grave uma sessão de Wireshark analisando seu próprio tráfego TCP.",
                                  "learningObjective": "Sintetizar todos os estados em um entendimento holístico acionável.",
                                  "commonMistakes": [
                                    "Ignorar half-close (shutdown write)",
                                    "Não testar em rede real."
                                  ]
                                }
                              ],
                              "practicalExample": "Use Wireshark para capturar o término de uma conexão SSH: identifique pacotes FIN/ACK, observe o cliente entrar em TIME_WAIT (verifique com 'ss -tan state time-wait'), e explique como um pacote FIN duplicado seria descartado pelo TIME_WAIT.",
                              "finalVerifications": [
                                "Desenhar corretamente o diagrama de estados de término TCP com todas as transições.",
                                "Explicar verbalmente o papel de TIME_WAIT em lidar com duplicados.",
                                "Identificar estados em uma captura Wireshark real.",
                                "Listar causas e soluções para excesso de TIME_WAIT em produção.",
                                "Diferenciar comportamentos de lados ativo e passivo.",
                                "Simular o fluxo com código socket simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas descrições e transições de estados (sem erros factuais).",
                                "Profundidade na explicação de TIME_WAIT e duplicados.",
                                "Uso correto de terminologia TCP (FIN, ACK, MSL).",
                                "Capacidade de aplicar em cenários reais via ferramentas como Wireshark/ss.",
                                "Clareza em diagramas e exemplos práticos.",
                                "Identificação de erros comuns e prevenções."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Redes: Implementação de sockets em linguagens como Python/C.",
                                "Sistemas Operacionais: Gerenciamento de file descriptors e tabelas de conexões.",
                                "Segurança de Rede: Implicações de TIME_WAIT em ataques de DoS por esgotamento de portas.",
                                "Análise de Desempenho: Tuning de kernel para TIME_WAIT em servidores.",
                                "Matemática/Probabilidade: Cálculo de MSL e probabilidades de duplicados."
                              ],
                              "realWorldApplication": "Em servidores web como Nginx/Apache, excesso de TIME_WAIT causa 'Address already in use'; administradores usam sysctl net.ipv4.tcp_tw_reuse=1 para mitigar, prevenindo falhas em alta carga e garantindo robustez contra redes instáveis com atrasos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.4",
                            "name": "Comparar fechamento ativo e passivo",
                            "description": "Diferenciar o lado ativo (inicia com FIN) do passivo (responde primeiro com ACK), e discutir cenários de falha como RST para abortar conexões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Fechamento Ativo de Conexão TCP",
                                  "subSteps": [
                                    "Revise o handshake de três vias para contextualizar o término.",
                                    "Identifique que no fechamento ativo, o lado iniciador envia FIN primeiro.",
                                    "Analise a sequência: FIN -> ACK -> FIN -> ACK.",
                                    "Desenhe um diagrama de mensagens para o lado ativo.",
                                    "Simule o estado da conexão no lado ativo usando uma máquina de estados finita."
                                  ],
                                  "verification": "Desenhe e explique corretamente o diagrama de 4 mensagens para fechamento ativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama TCP state diagram",
                                    "Wireshark para captura de pacotes",
                                    "Referência RFC 793"
                                  ],
                                  "tips": "Lembre-se: o lado ativo é o que 'quer encerrar' primeiro, como um cliente fechando uma conexão.",
                                  "learningObjective": "Compreender a sequência exata e os estados de transição no fechamento ativo.",
                                  "commonMistakes": [
                                    "Confundir FIN com SYN do handshake inicial",
                                    "Esquecer o ACK final do lado passivo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Fechamento Passivo de Conexão TCP",
                                  "subSteps": [
                                    "Identifique que no fechamento passivo, o lado receptor responde com ACK ao FIN recebido.",
                                    "Analise a sequência: Recebe FIN -> Envia ACK -> Envia FIN próprio -> Recebe ACK.",
                                    "Compare os estados iniciais: o passivo está em ESTABLISHED quando recebe FIN.",
                                    "Desenhe o diagrama correspondente para o lado passivo.",
                                    "Simule como o passivo gerencia dados pendentes antes de enviar seu FIN."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença nos primeiros passos em relação ao ativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama TCP state diagram",
                                    "Wireshark",
                                    "Referência RFC 793"
                                  ],
                                  "tips": "O passivo 'responde primeiro' com ACK, permitindo graceful shutdown.",
                                  "learningObjective": "Dominar a perspectiva do lado que recebe o FIN inicial.",
                                  "commonMistakes": [
                                    "Achar que passivo envia FIN primeiro",
                                    "Ignorar o tempo de espera por dados no passivo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Fechamento Ativo e Passivo",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: iniciador de FIN, sequência de mensagens, estados principais.",
                                    "Discuta simetria: ambos terminam com TIME_WAIT no último ACK.",
                                    "Analise impactos em throughput e latência em cenários reais.",
                                    "Use Wireshark para capturar e rotular exemplos de cada tipo.",
                                    "Debata quando usar ativo vs. passivo (ex: cliente vs. servidor)."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 diferenças/similaridades corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark com tráfego TCP real",
                                    "Planilha ou papel para tabela",
                                    "RFC 793"
                                  ],
                                  "tips": "Foque em papéis: ativo = 'caller', passivo = 'callee' no shutdown.",
                                  "learningObjective": "Diferenciar claramente os dois modos e suas implicações.",
                                  "commonMistakes": [
                                    "Confundir quem entra em TIME_WAIT primeiro",
                                    "Ignorar half-close possibilities"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Cenários de Falha com RST",
                                  "subSteps": [
                                    "Explique RST como reset abrupto para abortar conexões inválidas.",
                                    "Compare RST vs. FIN: RST sem graceful, usado em erros ou rejeições.",
                                    "Simule falhas: RST em resposta a FIN inválido ou SYN inválido.",
                                    "Discuta cenários: timeout, port fechado, firewall drops.",
                                    "Capture e analise RST em Wireshark de uma conexão real falha."
                                  ],
                                  "verification": "Descreva 3 cenários onde RST é preferível a FIN e por quê.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Ferramenta como telnet/nc para gerar falhas",
                                    "RFC 793 seção de RST"
                                  ],
                                  "tips": "RST é 'panic button': rápido, mas perde dados pendentes.",
                                  "learningObjective": "Entender quando e por que falhas usam RST em vez de fechamento normal.",
                                  "commonMistakes": [
                                    "Usar RST para shutdown normal",
                                    "Confundir RST com FIN-ACK"
                                  ]
                                }
                              ],
                              "practicalExample": "Use Wireshark para capturar o fechamento de uma conexão HTTP: identifique se o cliente (ativo) envia FIN primeiro ou o servidor (passivo). Gere uma falha com telnet para localhost:porta inválida e observe RST.",
                              "finalVerifications": [
                                "Desenhar diagramas precisos de ativo e passivo.",
                                "Explicar sequência de mensagens sem erros.",
                                "Identificar corretamente exemplos em Wireshark.",
                                "Discutir 2 cenários de uso real para cada modo.",
                                "Diferenciar RST de fechamento graceful em 3 casos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de flags (FIN, ACK, RST).",
                                "Correta identificação de estados TCP (FIN_WAIT, CLOSE_WAIT).",
                                "Profundidade na comparação (tabela ou diagrama claro).",
                                "Análise válida de falhas com RST.",
                                "Aplicação prática via Wireshark ou simulação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem com máquinas de estados finitos (automata theory).",
                                "Segurança da Informação: Implicações de RST em ataques de negação de serviço.",
                                "Engenharia de Software: Design de APIs com graceful shutdown.",
                                "Física/Elétrica: Analogia com circuitos de controle on/off."
                              ],
                              "realWorldApplication": "Em servidores web como Apache/Nginx, o servidor frequentemente faz fechamento passivo ao receber FIN do cliente, garantindo entrega de respostas pendentes; RST é usado por firewalls para bloquear conexões maliciosas rapidamente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Controle de Congestionamento",
                    "description": "Algoritmos e estratégias no TCP para detectar, evitar e recuperar de congestionamento na rede, como janela de congestionamento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Detecção de Congestionamento",
                        "description": "Métodos e sinais utilizados pelo protocolo TCP para identificar congestionamento na rede, incluindo timeouts de retransmissão e ACKs duplicados.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Detecção por Timeout de Retransmissão",
                            "description": "Compreender como o TCP detecta perda de pacotes por meio de timeouts, calculando o Retransmission Timeout (RTO) baseado no RTT estimado e desvição, iniciando mecanismos de recuperação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de RTT e Perda de Pacotes no TCP",
                                  "subSteps": [
                                    "Defina RTT (Round-Trip Time) como o tempo total para um pacote ir e voltar.",
                                    "Explique causas de perda de pacotes: congestionamento, erros de transmissão ou buffer overflow.",
                                    "Descreva o papel do timer de retransmissão no TCP para detectar perdas.",
                                    "Diferencie detecção por timeout de detecção por ACK duplicados.",
                                    "Estude o cabeçalho TCP e campos relevantes como sequence number e ACK."
                                  ],
                                  "verification": "Resuma em um diagrama o ciclo de um pacote TCP com RTT medido e perda simulada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Redes de Computadores' de Kurose & Ross (cap. Transporte)",
                                    "Diagramas TCP online"
                                  ],
                                  "tips": "Visualize o RTT como um ping entre cliente e servidor para fixar o conceito.",
                                  "learningObjective": "Entender os fundamentos de RTT e como perdas são detectadas via timeout.",
                                  "commonMistakes": [
                                    "Confundir RTT com one-way delay",
                                    "Ignorar que RTT inclui tempo de processamento no receptor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o Algoritmo de Cálculo do RTO (Jacobson/Karels)",
                                  "subSteps": [
                                    "Estude SRTT (Smoothed RTT): SRTT = (1 - α) * SRTT + α * RTT, com α=0.125.",
                                    "Calcule RTTVAR (desvio): RTTVAR = (1 - β) * RTTVAR + β * |SRTT - RTT|, β=0.25.",
                                    "Formule RTO = SRTT + 4 * RTTVAR, com RTO mínimo de 1s e máximo de 60s.",
                                    "Simule cálculos com exemplos numéricos: RTTs = [100ms, 120ms, 90ms].",
                                    "Entenda adaptação contínua com cada ACK recebido."
                                  ],
                                  "verification": "Calcule SRTT, RTTVAR e RTO para 5 amostras de RTT fornecidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fórmulas RFC 6298",
                                    "Calculadora ou planilha Excel/Google Sheets"
                                  ],
                                  "tips": "Use α=1/8 e β=1/4 para simplificar cálculos manuais.",
                                  "learningObjective": "Dominar a fórmula exata e o raciocínio estatístico por trás do RTO.",
                                  "commonMistakes": [
                                    "Usar média simples em vez de exponencial suavizada",
                                    "Esquecer o multiplicador de 4 na variância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Detecção de Timeout e Retransmissão",
                                  "subSteps": [
                                    "Configure uma conexão TCP com perda artificial usando tc (Linux) ou netem.",
                                    "Envie dados e observe o timer expirar quando ACK não chega.",
                                    "Analise o tráfego com Wireshark: identifique retransmissões por timeout.",
                                    "Meça o RTO real observado e compare com cálculos teóricos.",
                                    "Teste variações de RTT para ver adaptação do RTO."
                                  ],
                                  "verification": "Capture e anote um log de Wireshark mostrando timeout e retransmissão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Ferramenta tc/netem no Linux ou VM",
                                    "Python socket para teste"
                                  ],
                                  "tips": "Inicie com perda baixa (1%) para observar timeouts claros.",
                                  "learningObjective": "Aplicar o conceito em simulação prática para ver timeout em ação.",
                                  "commonMistakes": [
                                    "Não sincronizar relógio para medir RTT preciso",
                                    "Confundir retransmissão fast com timeout"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Mecanismos de Recuperação Após Timeout",
                                  "subSteps": [
                                    "Descreva backoff exponencial: RTO *= 2 após cada timeout.",
                                    "Estude slow start após recuperação: cwnd = 1 MSS.",
                                    "Compare com recuperação por ACK duplicado (mais rápida).",
                                    "Discuta limites: máximo 12 retransmissões antes de abortar conexão.",
                                    "Analise impacto em throughput durante perdas prolongadas."
                                  ],
                                  "verification": "Desenhe um fluxograma do processo completo de timeout a recuperação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 5681 (TCP Congestion Control)",
                                    "Simulador ns-3 opcional"
                                  ],
                                  "tips": "Lembre-se: timeout é último recurso, prefira detecção rápida por ACKs.",
                                  "learningObjective": "Compreender as ações corretivas e conservadoras do TCP pós-timeout.",
                                  "commonMistakes": [
                                    "Achar que RTO não dobra após timeout",
                                    "Ignorar reset de congestion window"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um download de arquivo via HTTP/TCP com rede instável (ex: Wi-Fi congestionado), o TCP calcula RTO baseado em RTTs iniciais de 50ms. Após perda, timer expira em ~200ms (SRTT+4*VAR), retransmite o segmento perdido e dobra RTO para próxima tentativa, garantindo entrega sem intervenção do usuário.",
                              "finalVerifications": [
                                "Calcule RTO corretamente para sequência de 5 RTTs dados.",
                                "Explique em palavras o papel da variância no RTO.",
                                "Identifique timeout em captura Wireshark real.",
                                "Compare timeout vs. fast retransmit em cenário de perda.",
                                "Descreva backoff após 2 timeouts consecutivos.",
                                "Simule RTO adaptativo com código Python simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas SRTT/RTTVAR/RTO (100% correto).",
                                "Capacidade de simular e analisar tráfego com Wireshark.",
                                "Explicação clara de adaptação e backoff.",
                                "Uso correto de exemplos numéricos e diagramas.",
                                "Compreensão de trade-offs (conservadorismo vs. throughput).",
                                "Integração com conceitos maiores de congestionamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Médias móveis exponenciais e variância estatística.",
                                "Programação: Implementação de timers em sockets TCP personalizados.",
                                "Física: Analogia com propagação de sinais e delays variáveis.",
                                "Estatística: Confiança em estimativas de tempo sob incerteza."
                              ],
                              "realWorldApplication": "Garante confiabilidade em streaming de vídeo (Netflix), downloads P2P (BitTorrent) e navegação web sob redes móveis instáveis, retransmitindo pacotes perdidos automaticamente sem perda de dados, otimizando para bilhões de conexões diárias na internet."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Detecção por ACKs Duplicados",
                            "description": "Explicar o uso de três ACKs duplicados consecutivos como sinal de congestionamento parcial, permitindo Fast Retransmit sem aguardar timeout completo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender ACKs Normais e Cumulativos no TCP",
                                  "subSteps": [
                                    "Estude o conceito básico de ACK (Acknowledgment) como confirmação de recebimento de segmentos TCP.",
                                    "Aprenda sobre ACKs cumulativos, que confirmam todos os bytes até um número de sequência específico.",
                                    "Analise um diagrama de troca TCP normal sem perdas, identificando números de sequência e ACKs.",
                                    "Diferencie ACKs de outros flags TCP como SYN e FIN.",
                                    "Pratique mapeando uma sequência de pacotes com ACKs correspondentes."
                                  ],
                                  "verification": "Desenhe um diagrama de 5 pacotes trocados com ACKs corretos e explique verbalmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 793 (TCP Specification)",
                                    "Ferramenta de diagrama como Draw.io",
                                    "Vídeo tutorial sobre TCP handshake"
                                  ],
                                  "tips": "Sempre relacione ACKs aos números de sequência para evitar confusão.",
                                  "learningObjective": "Dominar o funcionamento padrão de ACKs cumulativos em conexões TCP sem erros.",
                                  "commonMistakes": [
                                    "Confundir ACK cumulativo com ACK individual por pacote",
                                    "Ignorar o papel dos números de sequência nos ACKs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular Perda de Pacote e Geração de ACKs Duplicados",
                                  "subSteps": [
                                    "Simule uma perda de pacote em uma conexão TCP usando um diagrama ou Wireshark.",
                                    "Observe como o receptor envia um ACK duplicado para o último byte recebido corretamente.",
                                    "Repita a simulação para 1 ou 2 ACKs duplicados e note que o remetente ainda não reage.",
                                    "Explique por que ACKs duplicados indicam possível perda ou reorderamento.",
                                    "Registre o comportamento do receptor ao receber pacotes subsequentes fora de ordem."
                                  ],
                                  "verification": "Crie um trace simulado mostrando 2 ACKs duplicados e descreva o estado do receptor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark ou tcpdump para captura de tráfego",
                                    "Simulador TCP como ns-3 ou Packet Tracer"
                                  ],
                                  "tips": "Use cores diferentes em diagramas para destacar pacotes perdidos e ACKs duplicados.",
                                  "learningObjective": "Identificar como perdas geram ACKs duplicados e seu significado inicial.",
                                  "commonMistakes": [
                                    "Achar que um ACK duplicado já indica perda definitiva",
                                    "Confundir duplicados com ACKs para pacotes corretos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Congestionamento via Três ACKs Duplicados Consecutivos",
                                  "subSteps": [
                                    "Defina o threshold de três ACKs duplicados como sinal de perda parcial.",
                                    "Explique o algoritmo: contar ACKs duplicados consecutivos para o mesmo segmento.",
                                    "Simule o cenário onde três ACKs chegam, sinalizando congestionamento parcial.",
                                    "Discuta por que isso detecta perda sem timeout completo.",
                                    "Compare com detecção por reorderamento benigno (menos de 3)."
                                  ],
                                  "verification": "Explique em voz alta ou escreva por que exatamente três ACKs acionam a detecção.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "RFC 5681 (TCP Congestion Control)",
                                    "Exemplos de traces Wireshark com ACKs duplicados"
                                  ],
                                  "tips": "Lembre-se: três é o número mágico para equilibrar falsos positivos e responsividade.",
                                  "learningObjective": "Entender o critério preciso de três ACKs duplicados como indício de congestionamento.",
                                  "commonMistakes": [
                                    "Usar menos ou mais de três como threshold",
                                    "Ignorar que ACKs devem ser consecutivos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Fast Retransmit em Resposta aos ACKs Duplicados",
                                  "subSteps": [
                                    "Descreva o Fast Retransmit: retransmitir o segmento perdido imediatamente após três ACKs.",
                                    "Integre com Fast Recovery para ajuste de janela de congestionamento.",
                                    "Simule o ciclo completo: perda → 3 ACKs → retransmit → recuperação.",
                                    "Calcule ganho de tempo vs. timeout (ex: 200ms vs. 3s).",
                                    "Teste em um simulador para validar o comportamento."
                                  ],
                                  "verification": "Execute uma simulação e confirme que Fast Retransmit ocorre sem timeout.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulador de rede como Mininet ou ns-3",
                                    "Código Python com Scapy para gerar tráfego TCP"
                                  ],
                                  "tips": "Monitore contadores de ACK duplicados no código fonte do TCP stack.",
                                  "learningObjective": "Aplicar detecção de ACKs para acionar Fast Retransmit eficientemente.",
                                  "commonMistakes": [
                                    "Confundir Fast Retransmit com Slow Start",
                                    "Atrasar retransmissão além dos três ACKs"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar Benefícios e Limitações da Detecção por ACKs Duplicados",
                                  "subSteps": [
                                    "Liste vantagens: redução de latência, melhor throughput em redes WAN.",
                                    "Discuta limitações: ineficaz em perdas múltiplas ou burst losses.",
                                    "Compare com RTO (Retransmission Timeout) em cenários reais.",
                                    "Analise métricas: RTT, throughput antes/depois.",
                                    "Proponha melhorias como SACK (Selective ACKs)."
                                  ],
                                  "verification": "Escreva um relatório curto comparando Fast Retransmit vs. timeout em 3 cenários.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de performance TCP de artigos IETF",
                                    "Ferramenta iperf para testes reais"
                                  ],
                                  "tips": "Use dados reais de Wireshark para quantificar melhorias.",
                                  "learningObjective": "Criticar e contextualizar a detecção em controle de congestionamento TCP.",
                                  "commonMistakes": [
                                    "Superestimar eficácia em redes com alta reorderação",
                                    "Ignorar evolução para algoritmos como TCP Reno/NewReno"
                                  ]
                                },
                                {
                                  "practicalExample": "Em uma transferência de arquivo HTTP via TCP, o pacote 5 é perdido devido a congestionamento na rede. O receptor recebe pacotes 6,7,8 e envia ACK 500 (para byte 500 do pacote 4) três vezes consecutivas. O servidor detecta isso, retransmite pacote 5 imediatamente (Fast Retransmit), evitando timeout de 3 segundos e completando a transferência 2x mais rápido, visível em Wireshark como 'Dup ACK' seguido de retransmissão."
                                },
                                {
                                  "finalVerifications": [
                                    "Explica com precisão o threshold de três ACKs duplicados consecutivos.",
                                    "Simula corretamente um cenário de perda com ACKs duplicados em diagrama ou ferramenta.",
                                    "Diferencia detecção por ACKs de timeout-based recovery.",
                                    "Calcula ganho de latência em um exemplo numérico.",
                                    "Identifica traces Wireshark mostrando Fast Retransmit acionado por Dup ACKs."
                                  ]
                                },
                                {
                                  "assessmentCriteria": [
                                    "Precisão conceitual: 100% correto sobre ACK cumulativos e threshold (30%)",
                                    "Profundidade prática: simulações/diagramas claros e acionáveis (25%)",
                                    "Análise comparativa: compara efetivamente com timeout (20%)",
                                    "Clareza de explicação: verbal/escrita sem ambiguidades (15%)",
                                    "Criatividade em exemplos: aplica a cenários reais como web browsing (10%)"
                                  ]
                                },
                                {
                                  "crossCurricularConnections": [
                                    "Matemática: Análise de sequências numéricas e contadores de duplicatas.",
                                    "Física: Modelagem de propagação de sinais em redes com perdas probabilísticas.",
                                    "Programação: Implementação de sockets TCP em linguagens como Python/C++ com monitoramento de ACKs.",
                                    "Estatística: Probabilidades de falsos positivos em detecção de perdas.",
                                    "Sistemas Operacionais: Integração com kernel TCP stacks como Linux."
                                  ]
                                },
                                {
                                  "realWorldApplication": "Na internet cotidiana, essa detecção acelera downloads de vídeos no YouTube ou Netflix, retransmitindo pacotes perdidos em links Wi-Fi congestionados em milissegundos ao invés de segundos, reduzindo buffering e melhorando QoE para bilhões de usuários diários."
                                }
                              ]
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Detecção por Fast Recovery",
                            "description": "Analisar como o TCP interpreta ACKs duplicados para entrar no estado Fast Recovery, ajustando temporariamente a janela sem reduzir drasticamente a taxa de envio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender ACKs Duplicados no TCP",
                                  "subSteps": [
                                    "Revise o mecanismo padrão de ACKs no TCP para confirmação de segmentos recebidos.",
                                    "Identifique o que acontece quando um segmento é perdido: receptor envia ACK duplicado para o último segmento recebido corretamente.",
                                    "Analise por que 3 ACKs duplicados consecutivos indicam perda provável sem timeout.",
                                    "Estude exemplos de traces de pacotes mostrando ACKs duplicados.",
                                    "Diferencie ACKs duplicados de ACKs normais em diagramas de sequência."
                                  ],
                                  "verification": "Desenhe um diagrama de sequência mostrando envio de dados, perda de um segmento e geração de 3 ACKs duplicados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 5681 sobre TCP Congestion Control",
                                    "Wireshark para análise de traces",
                                    "Diagramas de TCP state machine"
                                  ],
                                  "tips": "Use ferramentas como Wireshark para capturar tráfego real e filtrar por TCP ACKs.",
                                  "learningObjective": "Explicar o papel dos ACKs duplicados na detecção rápida de perdas.",
                                  "commonMistakes": [
                                    "Confundir ACKs duplicados com ACKs de fim de janela",
                                    "Ignorar que ACKs duplicados não confirmam novos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Trigger para Fast Retransmit e Entrada em Fast Recovery",
                                  "subSteps": [
                                    "Memorize a condição: recepção de 3 ACKs duplicados ativa Fast Retransmit.",
                                    "Descreva a retransmissão imediata do segmento perdido sem esperar RTO.",
                                    "Explique a transição para o estado Fast Recovery: ssthresh = cwnd/2, cwnd = ssthresh + 3*SMSS.",
                                    "Simule o ajuste inicial da janela de congestão para permitir ACKs de novos segmentos.",
                                    "Compare com o comportamento de Reno TCP."
                                  ],
                                  "verification": "Liste as ações exatas do TCP ao receber o 3º ACK duplicado, incluindo valores de cwnd e ssthresh.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 5681 seção sobre Fast Recovery",
                                    "Simulador de rede como ns-3 ou Mininet",
                                    "Pseudocódigo de implementação TCP"
                                  ],
                                  "tips": "Anote fórmulas: cwnd += SMSS para cada ACK duplicado adicional.",
                                  "learningObjective": "Identificar triggers precisos para entrada em Fast Recovery.",
                                  "commonMistakes": [
                                    "Retransmitir múltiplos segmentos prematuramente",
                                    "Não inflar cwnd corretamente no início"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciamento da Janela Durante Fast Recovery",
                                  "subSteps": [
                                    "Aprenda a inflação da cwnd: para cada ACK duplicado extra, cwnd += SMSS.",
                                    "Descreva como novos ACKs (não duplicados) deflacionam cwnd para ssthresh.",
                                    "Analise o ajuste temporário da janela para manter throughput sem slow start.",
                                    "Estude o impacto na taxa de envio: evita redução drástica comparado a timeout.",
                                    "Simule cenários com perdas múltiplas e observe comportamento."
                                  ],
                                  "verification": "Calcule cwnd em um exemplo com 4 ACKs duplicados e 2 novos ACKs.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora ou planilha para simular cwnd",
                                    "Vídeos sobre TCP Reno/NewReno",
                                    "Exercícios de simulação em Python"
                                  ],
                                  "tips": "Visualize cwnd como 'balões inflados' por ACKs duplicados, deflados por ACKs novos.",
                                  "learningObjective": "Dominar os ajustes dinâmicos de cwnd em Fast Recovery.",
                                  "commonMistakes": [
                                    "Confundir inflação com multiplicação em vez de adição",
                                    "Ignorar SMSS no cálculo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Saída do Fast Recovery e Verificações Finais",
                                  "subSteps": [
                                    "Identifique a condição de saída: ACK novo que cobre o highest sequence acknowledged.",
                                    "Descreva a transição para Congestion Avoidance com cwnd = ssthresh.",
                                    "Compare Fast Recovery com Slow Start após timeout.",
                                    "Analise traces reais para validar o ciclo completo.",
                                    "Discuta limitações como em perdas múltiplas (motivação para NewReno)."
                                  ],
                                  "verification": "Explique diferenças entre Fast Recovery e recuperação por timeout em termos de throughput.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Traces Wireshark de redes reais",
                                    "Comparação RFC 5681 vs RFC 2582",
                                    "Quiz interativo sobre TCP states"
                                  ],
                                  "tips": "Sempre verifique se o ACK de saída é 'new ACK' cobrindo o segmento retransmitido.",
                                  "learningObjective": "Compreender o ciclo completo e transições de estado.",
                                  "commonMistakes": [
                                    "Permanecer em Fast Recovery indefinidamente",
                                    "Reduzir cwnd para 1 SMSS na saída"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma transferência de arquivo HTTP sobre TCP em uma rede WiFi instável, um pacote de dados é perdido devido a interferência. O receptor envia 3 ACKs duplicados para seq=1000. O remetente retransmite seq=1000 imediatamente, infla cwnd de 10 para 13 MSS (ssthresh=5), continua enviando novos dados permitidos pela janela inflada. Ao receber ACK para seq=2000, defla cwnd para 5 MSS e entra em Congestion Avoidance, recuperando throughput rapidamente sem stall.",
                              "finalVerifications": [
                                "Desenhar diagrama completo de Fast Recovery com ACKs duplicados e ajustes de cwnd.",
                                "Analisar um trace Wireshark e identificar entrada/saída de Fast Recovery.",
                                "Calcular cwnd passo a passo em um cenário com 5 ACKs duplicados.",
                                "Explicar verbalmente por que Fast Recovery preserva throughput melhor que timeout.",
                                "Comparar com pseudocódigo de implementação em C ou Python.",
                                "Simular perda em Mininet e medir tempo de recuperação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de triggers (3+ ACKs duplicados).",
                                "Correção nos cálculos de inflação/deflação de cwnd.",
                                "Compreensão de transições de estado TCP.",
                                "Capacidade de analisar traces reais.",
                                "Identificação de limitações e melhorias (ex: NewReno).",
                                "Explicação clara de benefícios em throughput."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem probabilística de perdas e queues (distribuições Poisson).",
                                "Física: Analogia com fluxo de tráfego e detecção de engarrafamentos.",
                                "Programação: Implementação de sockets TCP em linguagens como Python ou C.",
                                "Estatística: Análise de performance via métricas de latência e throughput.",
                                "Economia: Otimização de recursos em redes compartilhadas."
                              ],
                              "realWorldApplication": "Em data centers como AWS ou Google Cloud, Fast Recovery minimiza latência em transferências de big data durante picos de tráfego, evitando timeouts que desperdiçariam bandwidth; essencial para streaming de vídeo (Netflix), VoIP (Zoom) e atualizações de software em larga escala."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Janela de Congestionamento",
                        "description": "Mecanismo central do TCP para controlar o número de pacotes não confirmados em trânsito, ajustando dinamicamente o tamanho da Congestion Window (cwnd) para evitar sobrecarga da rede.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Definição e Inicialização da cwnd",
                            "description": "Descrever a inicialização da janela de congestionamento em 1 MSS (Maximum Segment Size) e seu crescimento multiplicativo durante o Slow Start.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais: MSS e cwnd",
                                  "subSteps": [
                                    "Defina MSS (Maximum Segment Size) como o tamanho máximo de um segmento TCP sem headers de IP e TCP.",
                                    "Explique cwnd (Congestion Window) como a limite de dados não confirmados que o remetente pode enviar, controlando congestionamento.",
                                    "Diferencie cwnd de rwnd (Receive Window), focando no controle de congestionamento do remetente.",
                                    "Descreva o papel da cwnd no protocolo TCP para evitar sobrecarga na rede.",
                                    "Revise o diagrama de handshake TCP three-way para contextualizar quando a cwnd é inicializada."
                                  ],
                                  "verification": "Escreva definições curtas de MSS e cwnd e desenhe um diagrama simples mostrando seu relacionamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 5681 (TCP Congestion Control)",
                                    "Livro 'Computer Networking: A Top-Down Approach' de Kurose & Ross (Capítulo 3)",
                                    "Diagramas online de TCP congestion control"
                                  ],
                                  "tips": "Use analogias como 'cwnd é como o tamanho da sua cesta de compras em uma fila de supermercado para evitar congestionamento'.",
                                  "learningObjective": "Dominar as definições e papéis de MSS e cwnd no controle de congestionamento TCP.",
                                  "commonMistakes": "Confundir MSS com MTU (Maximum Transmission Unit) ou achar que cwnd é fixa desde o início."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicialização da Janela de Congestionamento (cwnd)",
                                  "subSteps": [
                                    "Identifique que, após o handshake TCP three-way, a cwnd é inicializada em 1 MSS (ou min(10 MSS, rwnd) em implementações modernas, mas foque no clássico).",
                                    "Explique que isso permite o envio de apenas 1 segmento inicial sem ACKs pendentes.",
                                    "Descreva o estado inicial como 'Slow Start' com ssthresh (slow start threshold) tipicamente em 64 KB ou ilimitado.",
                                    "Simule o envio: Envie 1 MSS, aguarde ACK antes de prosseguir.",
                                    "Registre o valor inicial da cwnd em um pseudocódigo ou tabela."
                                  ],
                                  "verification": "Crie uma tabela mostrando cwnd inicial = 1 MSS e confirme com uma simulação textual de 1 RTT.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 5681 Seção 3.1",
                                    "Ferramenta de simulação TCP como ns-3 ou Packet Tracer",
                                    "Wireshark para capturar handshakes reais"
                                  ],
                                  "tips": "Lembre-se: Inicialização conservadora previne 'thundering herd' em redes compartilhadas.",
                                  "learningObjective": "Explicar precisamente como e por que a cwnd é setada para 1 MSS no início de uma conexão TCP.",
                                  "commonMistakes": "Assumir que cwnd inicia em 0 ou ignora o impacto do MSS no cálculo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Crescimento Multiplicativo durante a Fase de Slow Start",
                                  "subSteps": [
                                    "Descreva o algoritmo: Para cada ACK recebido, aumente cwnd em 1 MSS (cwnd += MSS), efetivamente dobrando a cada RTT.",
                                    "Calcule exemplos: Após 1 ACK → cwnd=2 MSS; após mais 2 ACKs → cwnd=4 MSS; após 4 ACKs → cwnd=8 MSS.",
                                    "Explique o efeito exponencial: cwnd ≈ 2^t * MSS após t RTTs sem perdas.",
                                    "Defina transição: Slow Start continua até cwnd ≥ ssthresh, então muda para Congestion Avoidance.",
                                    "Implemente um loop simples em pseudocódigo para simular 5 RTTs."
                                  ],
                                  "verification": "Execute simulação e liste valores de cwnd por RTT; verifique se dobra corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo em Python para simulação TCP",
                                    "Gráficos de crescimento exponencial (Excel ou Desmos)",
                                    "Vídeos Khan Academy sobre TCP Slow Start"
                                  ],
                                  "tips": "Pense em termos de RTT (Round-Trip Time): Dobragem ocorre por ciclo de ACKs completos.",
                                  "learningObjective": "Modelar e calcular o crescimento exponencial da cwnd na fase inicial de Slow Start.",
                                  "commonMistakes": "Confundir aumento aditivo (Congestion Avoidance) com multiplicativo ou ignorar ACKs cumulativos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação e Aplicação Prática da Inicialização e Crescimento",
                                  "subSteps": [
                                    "Use Wireshark para capturar uma conexão real e medir cwnd inicial e crescimento.",
                                    "Compare com RFC: Confirme inicialização em ≤10 MSS e crescimento.",
                                    "Calcule throughput aproximado: Throughput ≈ cwnd / RTT.",
                                    "Discuta exceções: IW (Initial Window) moderna até 10 MSS.",
                                    "Documente um relatório resumindo a simulação."
                                  ],
                                  "verification": "Capture tráfego e anote valores de cwnd de logs ou cálculos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Servidor local para teste TCP (ex: iperf)",
                                    "RFC 6928 para IW moderno"
                                  ],
                                  "tips": "Teste em rede local para evitar interferências; foque em conexões novas.",
                                  "learningObjective": "Aplicar conceitos em ferramentas reais para validar comportamento da cwnd.",
                                  "commonMistakes": "Não considerar delayed ACKs que afetam o ritmo de dobragem."
                                }
                              ],
                              "practicalExample": "Em uma conexão TCP nova para download de um arquivo (ex: wget de um servidor), a cwnd inicia em 1 MSS (1460 bytes). Após o primeiro ACK (RTT=50ms), cwnd dobra para 2 MSS (envia 2 segmentos). Após ACKs dos 2, dobra para 4 MSS, e assim por diante: 1→2→4→8→16 MSS em 4 RTTs, alcançando ~90 KB em 200ms, acelerando o download inicial sem congestionar a rede.",
                              "finalVerifications": [
                                "Explicar verbalmente por que cwnd inicia em 1 MSS e não em valor maior.",
                                "Calcular cwnd após 3 RTTs sem perdas (resposta: 8 MSS).",
                                "Desenhar gráfico de crescimento exponencial da cwnd vs. RTT.",
                                "Identificar transição para Congestion Avoidance em ssthresh=64KB.",
                                "Simular em Wireshark e confirmar valores iniciais.",
                                "Diferenciar crescimento de Slow Start vs. Congestion Avoidance."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de MSS e inicialização de cwnd (90% correto).",
                                "Correção nos cálculos de crescimento multiplicativo (sem erros em exemplos).",
                                "Clareza no pseudocódigo ou simulação (executável e comentado).",
                                "Uso correto de terminologia TCP (ex: RTT, ACK cumulativo).",
                                "Demonstração prática via Wireshark ou ferramenta similar.",
                                "Compreensão de exceções modernas (IW ≤10 MSS)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos de crescimento exponencial (cwnd = MSS * 2^RTT).",
                                "Física: Analogia com fluxo de fluidos em tubulações (cwnd como diâmetro).",
                                "Estatística: Modelos de filas M/M/1 para análise de congestionamento.",
                                "Programação: Implementação em sockets TCP para medir cwnd."
                              ],
                              "realWorldApplication": "Na internet diária, isso permite que downloads (Netflix, YouTube) acelerem rapidamente de conexões lentas iniciais para throughput máximo, evitando colapsos de rede em Wi-Fi compartilhado ou data centers, otimizando bilhões de conexões TCP globais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Ajuste da cwnd em Estados de Congestionamento",
                            "description": "Explicar a redução da cwnd pela metade em casos de congestionamento detectado (multiplicativo) e manutenção em modo de avoidance (aditivo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de cwnd e Estados de Congestionamento",
                                  "subSteps": [
                                    "Defina o que é a congestion window (cwnd) no controle de congestionamento TCP.",
                                    "Identifique as fases principais: slow start, congestion avoidance, congestion occurred.",
                                    "Explique a diferença entre congestion avoidance (aditivo) e congestion occurred (multiplicativo).",
                                    "Revise o papel da cwnd em limitar o número de pacotes não confirmados.",
                                    "Estude diagramas de evolução da cwnd nas diferentes fases."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando cwnd crescendo aditivamente e depois sendo halved.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro 'Computer Networking: A Top-Down Approach' (Kurose & Ross), capítulos sobre TCP",
                                    "Diagramas online de TCP congestion control"
                                  ],
                                  "tips": "Use animações interativas como as do Wireshark ou ns-3 para visualizar o crescimento da cwnd.",
                                  "learningObjective": "Entender o papel fundamental da cwnd e os estados de congestionamento no TCP.",
                                  "commonMistakes": [
                                    "Confundir cwnd com rwnd (receive window)",
                                    "Ignorar que cwnd é estimada pelo remetente",
                                    "Achar que slow start é sempre usado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Detecção de Congestionamento",
                                  "subSteps": [
                                    "Aprenda sobre detecção por timeout de RTO (Retransmission Timeout).",
                                    "Descreva detecção por três duplicate ACKs (fast retransmit).",
                                    "Compare os impactos: timeout causa slow start completo, duplicate ACKs levam a fast recovery.",
                                    "Analise como essas detecções sinalizam congestionamento na rede.",
                                    "Liste condições que levam a perdas de pacotes (buffer overflow, etc.)."
                                  ],
                                  "verification": "Liste 3 cenários onde congestionamento é detectado e o que acontece com a cwnd em cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 5681 sobre TCP congestion control",
                                    "Vídeos explicativos no YouTube sobre TCP states"
                                  ],
                                  "tips": "Lembre-se: duplicate ACKs indicam perda isolada, timeout indica congestionamento severo.",
                                  "learningObjective": "Identificar precisamente como o TCP detecta congestionamento.",
                                  "commonMistakes": [
                                    "Confundir duplicate ACKs com ACKs normais",
                                    "Achar que todo timeout reseta cwnd para 1 MSS",
                                    "Ignorar Reno vs Cubic variantes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar o Ajuste Multiplicativo da cwnd",
                                  "subSteps": [
                                    "Explique a regra: ao detectar congestionamento (por timeout ou 3 dup ACKs), cwnd = cwnd / 2.",
                                    "Calcule exemplos numéricos: se cwnd=20, nova cwnd=10.",
                                    "Entenda que é multiplicativo (halve) para reduzir agressivamente a taxa de envio.",
                                    "Discuta ssthresh: ajustado para min(cwnd/2, flightSize).",
                                    "Simule em pseudocódigo o algoritmo de ajuste."
                                  ],
                                  "verification": "Resolva 3 exercícios: dado cwnd inicial e evento de perda, calcule nova cwnd e ssthresh.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador TCP online (como TCP Vegas simulator)",
                                    "Papel e caneta para cálculos"
                                  ],
                                  "tips": "Sempre arredonde para baixo e para múltiplo de MSS (Maximum Segment Size).",
                                  "learningObjective": "Aplicar corretamente o ajuste multiplicativo em cenários de congestionamento.",
                                  "commonMistakes": [
                                    "Dividir por 3 em vez de 2",
                                    "Não ajustar ssthresh",
                                    "Aplicar halve em slow start incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o Ajuste Aditivo em Congestion Avoidance",
                                  "subSteps": [
                                    "Descreva o aumento: cwnd += 1 MSS por RTT (Round Trip Time) completo.",
                                    "Explique por que aditivo: crescimento linear para probe cauteloso da banda disponível.",
                                    "Compare com multiplicativo: aditivo mantém estabilidade pós-congestionamento.",
                                    "Calcule exemplos: após halve para 10, em 5 RTTs vai para 15.",
                                    "Integre com ACKs: aumento só após RTT sem perdas."
                                  ],
                                  "verification": "Trace a evolução da cwnd por 10 RTTs alternando avoidance e congestionamento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de simulação como ns-3 ou Python com scapy",
                                    "Gráficos de referência de TCP sawtooth pattern"
                                  ],
                                  "tips": "Pense no 'sawtooth' pattern: sobe linear, cai abrupto, repete.",
                                  "learningObjective": "Diferenciar e calcular ajustes aditivos na fase de avoidance.",
                                  "commonMistakes": [
                                    "Aumentar por ACK individual em vez de RTT",
                                    "Confundir com slow start (exponencial)",
                                    "Ignorar que é após fast recovery"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Simular Ajustes Completos",
                                  "subSteps": [
                                    "Monte um ciclo completo: slow start -> avoidance -> congest -> halve -> avoidance.",
                                    "Simule com ferramentas: capture tráfego Wireshark e analise cwnd.",
                                    "Compare Reno, Cubic e BBR em ajustes.",
                                    "Discuta otimizações modernas.",
                                    "Crie um fluxograma pessoal do algoritmo."
                                  ],
                                  "verification": "Simule uma sessão TCP e anote mudanças na cwnd durante congestionamento.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Tutorial Wireshark TCP analysis"
                                  ],
                                  "tips": "Use iperf para gerar tráfego e capturar perdas.",
                                  "learningObjective": "Sintetizar o comportamento completo da cwnd em estados de congestionamento.",
                                  "commonMistakes": [
                                    "Não considerar flight size",
                                    "Esquecer fast recovery nuances",
                                    "Aplicar regras erradas em variantes TCP"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma conexão TCP baixando um vídeo via Netflix, se o buffer do roteador enche e pacotes são dropados (detectado por 3 dup ACKs), a cwnd cai de 64 para 32 MSS, reduzindo a taxa de envio pela metade. Após fast recovery, entra em congestion avoidance, aumentando 1 MSS por RTT até nova perda, formando o padrão 'sawtooth' que estabiliza a rede.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre ajuste multiplicativo e aditivo com exemplo numérico.",
                                "Desenhar gráfico de cwnd vs tempo mostrando halve e aumento linear.",
                                "Identificar em um trace Wireshark um evento de congestionamento e o ajuste da cwnd.",
                                "Calcular nova cwnd e ssthresh dado flightSize=50, dup ACKs detectados.",
                                "Comparar impacto de timeout vs dup ACKs na recuperação.",
                                "Simular 5 RTTs pós-congestionamento e listar valores de cwnd."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de ajuste (multiplicativo: /2, aditivo: +1/RTT).",
                                "Correta identificação de triggers de detecção (timeout vs dup ACKs).",
                                "Uso apropriado de terminologia (cwnd, ssthresh, RTT, MSS).",
                                "Capacidade de traçar ciclos completos em diagramas ou simulações.",
                                "Compreensão de porquê multiplicativo/aditivo previne oscilações.",
                                "Aplicação em cenários reais via ferramentas como Wireshark."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Crescimento exponencial (slow start) vs linear (aditivo) e divisão multiplicativa.",
                                "Física: Analogia com fluxo de tráfego em rodovias (controle de densidade para evitar engarrafamentos).",
                                "Economia: Alocação eficiente de recursos limitados (banda de rede como bem escasso).",
                                "Engenharia de Software: Algoritmos de feedback e controle adaptativo.",
                                "Estatística: Probabilística de perdas e médias móveis em RTT."
                              ],
                              "realWorldApplication": "Esse mecanismo é crucial para a estabilidade da Internet global, prevenindo 'congestion collapse' durante picos como lives de futebol ou downloads em massa, permitindo que milhões de conexões TCP coexistam sem colapsar roteadores, como visto em CDNs da Google ou AWS."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Interação com Janela de Recebimento",
                            "description": "Diferenciar e integrar a cwnd com a janela anunciada pelo receptor (rwnd), usando o mínimo dos dois para limitar envios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Individuais de cwnd e rwnd",
                                  "subSteps": [
                                    "Defina cwnd (Congestion Window) como a janela de congestionamento estimada pelo remetente baseada no feedback da rede.",
                                    "Defina rwnd (Receive Window) como a janela anunciada pelo receptor indicando espaço disponível no buffer.",
                                    "Estude o papel da cwnd no controle de congestionamento (evitar sobrecarga da rede).",
                                    "Estude o papel da rwnd no controle de fluxo (evitar overflow no receptor).",
                                    "Leia seções relevantes do RFC 5681 sobre variáveis de estado TCP."
                                  ],
                                  "verification": "Resuma em suas palavras as definições e papéis de cwnd e rwnd, comparando-as em uma tabela.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 5681 (TCP Congestion Control)",
                                    "Diagramas de TCP state variables de Khan Academy ou Cisco Networking Academy"
                                  ],
                                  "tips": "Use analogias: cwnd é como o tráfego na estrada, rwnd é o tamanho da garagem do receptor.",
                                  "learningObjective": "Compreender as definições e propósitos independentes de cwnd e rwnd.",
                                  "commonMistakes": "Confundir cwnd com rwnd, achando que ambas são controladas pelo receptor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar cwnd de rwnd em Contextos e Advertisements",
                                  "subSteps": [
                                    "Identifique que cwnd é inferida implicitamente via ACKs e ajustada por algoritmos (ex: Reno, Cubic).",
                                    "Identifique que rwnd é explicitamente anunciada no cabeçalho TCP (campo Window).",
                                    "Compare cenários: rede congestionada (cwnd limita) vs. receptor lento (rwnd limita).",
                                    "Analise capturas de pacotes Wireshark mostrando variações de cada uma.",
                                    "Crie um fluxograma mostrando quando cada uma é atualizada."
                                  ],
                                  "verification": "Crie um diagrama comparativo destacando diferenças em origem, atualização e propósito.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark para capturas TCP",
                                    "Tutoriais Wireshark TCP analysis",
                                    "Livro 'TCP/IP Illustrated' Vol.1"
                                  ],
                                  "tips": "Filtre por 'tcp.analysis.window_full' no Wireshark para ver rwnd em ação.",
                                  "learningObjective": "Diferenciar mecanismos de cálculo, sinalização e cenários de limitação de cwnd vs. rwnd.",
                                  "commonMistakes": "Ignorar que rwnd pode ser zero, pausando envios, enquanto cwnd raramente é zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar cwnd e rwnd Usando o Mínimo Eficaz",
                                  "subSteps": [
                                    "Aprenda a fórmula effective_window = min(cwnd, rwnd).",
                                    "Simule cálculos: se cwnd=10 MSS e rwnd=5 MSS, envie no máximo 5 MSS.",
                                    "Entenda que o remetente usa essa janela para decidir quantos segmentos enviar sem ACK.",
                                    "Discuta scaling: rwnd pode ser escalada (window scale option no TCP).",
                                    "Implemente um simulador simples em Python para variar cwnd/rwnd e plotar effective window."
                                  ],
                                  "verification": "Calcule effective_window em 3 cenários hipotéticos e justifique envios.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python com Matplotlib para simulação",
                                    "RFC 7323 (TCP Extensions for High Performance)",
                                    "ns-3 ou OMNeT++ simulator (opcional)"
                                  ],
                                  "tips": "Comece com valores pequenos de MSS (1460 bytes) para facilitar cálculos.",
                                  "learningObjective": "Aplicar a regra min(cwnd, rwnd) para determinar limite de envio.",
                                  "commonMistakes": "Esquecer de considerar flight size atual vs. effective window."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Simular Interações em Cenários Reais",
                                  "subSteps": [
                                    "Capture tráfego TCP real (ex: wget de arquivo grande) e analise cwnd/rwnd no Wireshark.",
                                    "Identifique momentos onde rwnd domina (receptor lento) vs. cwnd (perda de pacotes).",
                                    "Teste com netem para simular delays/losses afetando cwnd.",
                                    "Ajuste rwnd artificialmente em um servidor TCP e observe impacto.",
                                    "Documente um relatório com gráficos de evolução das janelas."
                                  ],
                                  "verification": "Produza um relatório com capturas mostrando pelo menos um caso de cada limitação.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "tc/netem no Linux para simulação de rede",
                                    "Servidor de teste com iperf"
                                  ],
                                  "tips": "Use 'ss -i' no Linux para ver janelas TCP em tempo real.",
                                  "learningObjective": "Observar e validar interação prática entre cwnd e rwnd.",
                                  "commonMistakes": "Não escalar janelas corretamente em conexões high-bandwidth."
                                }
                              ],
                              "practicalExample": "Durante o download de um vídeo de 100MB via HTTP/TCP, o buffer do receptor enche rapidamente (rwnd cai para 2 MSS), limitando envios apesar de cwnd=20 MSS. O servidor pausa até ACKs liberarem espaço, prevenindo perda de dados, enquanto congestionamento na rede reduziria cwnd posteriormente.",
                              "finalVerifications": [
                                "Explique verbalmente ou por escrito a diferença entre cwnd e rwnd.",
                                "Calcule corretamente effective_window em cenários mistos.",
                                "Identifique em uma captura Wireshark qual janela está limitando o throughput.",
                                "Simule um caso onde rwnd=0 força zero-window probing.",
                                "Descreva impactos se min(cwnd, rwnd) não fosse usado.",
                                "Compare com UDP (sem controle de fluxo/congestionamento)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e diferenciação (80%+ correto).",
                                "Correta aplicação da fórmula min(cwnd, rwnd) em simulações.",
                                "Análise qualitativa/quantitativa de capturas de tráfego.",
                                "Identificação correta de cenários de limitação em exemplos reais.",
                                "Criatividade e clareza em diagramas/relatórios.",
                                "Compreensão de extensões TCP (window scaling, zero-window)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações de mínimo e modelagem de funções de janela.",
                                "Física: Analogia com fluxo de fluidos (cwnd como gargalo de rede, rwnd como capacidade de tanque).",
                                "Programação: Implementação em sockets TCP (setsockopt para buffers).",
                                "Estatística: Análise de throughput e variância em simulações de rede."
                              ],
                              "realWorldApplication": "Em serviços como Netflix ou Zoom, a interação garante streaming suave: rwnd adapta ao buffer do player, cwnd ao congestionamento da ISP, maximizando throughput sem perdas ou delays excessivos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Algoritmos de Controle de Congestionamento",
                        "description": "Estratégias e fases do TCP para evitar e recuperar de congestionamento, incluindo Slow Start, Congestion Avoidance e variantes como Tahoe e Reno.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Fase de Slow Start",
                            "description": "Detalhar o crescimento exponencial da cwnd (dobrando a cada RTT) até o threshold (ssthresh), visando probe rápido da capacidade da rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais do Controle de Congestionamento",
                                  "subSteps": [
                                    "Defina cwnd (Congestion Window): tamanho da janela de congestão que limita dados não confirmados.",
                                    "Explique ssthresh (Slow Start Threshold): limite superior para a fase de slow start.",
                                    "Descreva RTT (Round-Trip Time): tempo para um pacote ir e voltar.",
                                    "Discuta o objetivo: descobrir capacidade da rede rapidamente sem causar congestão.",
                                    "Compare com estado inicial: cwnd começa em 1 ou poucos MSS (Maximum Segment Size)."
                                  ],
                                  "verification": "Liste e defina corretamente cwnd, ssthresh e RTT em um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 5681 sobre TCP Congestion Control",
                                    "Vídeo introdutório sobre TCP (Khan Academy ou similar)"
                                  ],
                                  "tips": "Use analogias como 'cwnd é como o tamanho da mangueira testando o fluxo da rede'.",
                                  "learningObjective": "Compreender os termos chave e seu papel no algoritmo.",
                                  "commonMistakes": [
                                    "Confundir cwnd com rwnd (receive window)",
                                    "Ignorar que ssthresh é dinâmico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Mecanismo de Slow Start",
                                  "subSteps": [
                                    "Inicie com cwnd = 1 MSS após handshake TCP.",
                                    "No final de cada RTT, dobre cwnd (ex: 1 → 2 → 4 → 8 MSS).",
                                    "Envie ACKs cumulativos para trigger aumento.",
                                    "Explique 'slow' como conservador, não literal (ainda exponencial).",
                                    "Descreva probe: testar rede enviando mais dados gradualmente."
                                  ],
                                  "verification": "Desenhe timeline de 3 RTTs mostrando duplicação de cwnd.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Simulador TCP online como ns-3 ou Wireshark"
                                  ],
                                  "tips": "Lembre: cada RTT bem-sucedido significa 'rede aguenta mais'.",
                                  "learningObjective": "Dominar a regra de duplicação por RTT.",
                                  "commonMistakes": [
                                    "Achar que dobra por ACK individual, não por RTT",
                                    "Confundir com fast recovery"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Transição para Congestion Avoidance",
                                  "subSteps": [
                                    "Monitore cwnd até atingir ou exceder ssthresh.",
                                    "Ao atingir ssthresh: mude para crescimento linear (aumento de 1 MSS por RTT).",
                                    "Calcule exemplo: ssthresh=16, cwnd cresce 1,2,4,8,16 → linear.",
                                    "Explique detecção de perda: timeout ou 3 dup ACKs ajusta ssthresh.",
                                    "Discuta benefícios: rápido ramp-up sem overshoot excessivo."
                                  ],
                                  "verification": "Simule tabela de cwnd vs RTT até ssthresh em planilha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets",
                                    "RFC 5681 seção 3.1"
                                  ],
                                  "tips": "Visualize com gráfico exponencial vs linear.",
                                  "learningObjective": "Entender ponto de transição e razões.",
                                  "commonMistakes": [
                                    "Pensar que slow start para abruptamente",
                                    "Ignorar halving de ssthresh em perdas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Verificar Comportamento",
                                  "subSteps": [
                                    "Configure Wireshark para capturar tráfego TCP real.",
                                    "Inicie transferência de arquivo grande e observe cwnd via gráficos.",
                                    "Use tcptrace ou similar para plotar evolução de cwnd.",
                                    "Compare simulação com teoria: confirme duplicação inicial.",
                                    "Teste cenários: rede vazia vs congestionada."
                                  ],
                                  "verification": "Capture e anote gráfico mostrando slow start até ssthresh.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Conexão internet estável",
                                    "tcptrace tool"
                                  ],
                                  "tips": "Filtre por 'tcp.analysis' no Wireshark para métricas.",
                                  "learningObjective": "Aplicar conceitos em ferramenta real.",
                                  "commonMistakes": [
                                    "Não calibrar escala de tempo para RTTs",
                                    "Confundir variações com outros algoritmos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma transferência HTTP de um arquivo 1MB em rede WiFi vazia: cwnd inicia em 2 MSS (~3KB), dobra para 4,8,16 MSS por RTT (~20ms cada), atingindo ssthresh=64KB em 4 RTTs (~80ms), acelerando download de segundos para milissegundos.",
                              "finalVerifications": [
                                "Descreva verbalmente o crescimento de cwnd em 5 RTTs com ssthresh=32.",
                                "Desenhe diagrama de cwnd vs tempo mostrando exponencial até threshold.",
                                "Explique por que 'slow start' é exponencial apesar do nome.",
                                "Identifique em Wireshark um trace real de slow start.",
                                "Calcule throughput aproximado: cwnd/RTT durante fase.",
                                "Diferencie slow start de Reno/NewReno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do crescimento exponencial (dobro por RTT).",
                                "Correta identificação do papel de ssthresh na transição.",
                                "Uso correto de terminologia (cwnd, MSS, RTT).",
                                "Capacidade de simular e interpretar traces reais.",
                                "Explicação clara do objetivo de probing de banda.",
                                "Análise de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Crescimento exponencial (2^n) e séries geométricas.",
                                "Física: Analogia com fluxo de fluidos e gargalos em tubulações.",
                                "Estatística: Modelagem probabilística de perdas de pacotes.",
                                "Economia: Otimização de recursos em redes compartilhadas."
                              ],
                              "realWorldApplication": "No streaming Netflix ou Zoom calls, slow start permite upload/download rápido inicial sem colapsar a rede doméstica/ISP, evitando buffer underruns e garantindo QoS em conexões variáveis como 4G/5G."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Fase de Congestion Avoidance",
                            "description": "Explicar o aumento linear da cwnd (1 MSS por RTT) para probe gradual da banda disponível sem causar congestionamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto e objetivo da Fase de Congestion Avoidance",
                                  "subSteps": [
                                    "Revise as fases anteriores do controle de congestionamento TCP: Slow Start e detecção de congestionamento.",
                                    "Identifique o problema: após Slow Start, a rede pode suportar mais banda sem congestionar.",
                                    "Explique o objetivo: aumentar a cwnd de forma gradual e linear para sondar a banda disponível.",
                                    "Discuta por que linear em vez de exponencial: evita oscilações e congestionamentos abruptos.",
                                    "Analise o estado de entrada: quando cwnd >= ssthresh após Slow Start."
                                  ],
                                  "verification": "O aluno pode descrever verbalmente ou por escrito o porquê da transição para Congestion Avoidance e seu objetivo principal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama das fases TCP (Slow Start, Congestion Avoidance, Fast Recovery)",
                                    "RFC 5681 - TCP Congestion Control"
                                  ],
                                  "tips": "Pense na rede como uma estrada: após acelerar (Slow Start), mantenha velocidade constante crescente para testar limites sem acidentes.",
                                  "learningObjective": "Ao final deste passo, o aluno compreenderá o contexto e a necessidade da Fase de Congestion Avoidance no algoritmo TCP.",
                                  "commonMistakes": [
                                    "Confundir com Slow Start (exponencial vs linear)",
                                    "Ignorar o papel do ssthresh na transição",
                                    "Achar que é a fase final do TCP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o mecanismo de aumento linear da congestion window (cwnd)",
                                  "subSteps": [
                                    "Defina cwnd: tamanho da janela de congestão em MSS (Maximum Segment Size).",
                                    "Estude a regra: cwnd += 1 MSS por RTT (Round Trip Time) completo.",
                                    "Calcule exemplo: se cwnd = 10 MSS e RTT = 100ms, após um RTT, cwnd = 11 MSS.",
                                    "Entenda ACKs cumulativos: cada RTT bem-sucedido (sem perdas) permite um aumento.",
                                    "Visualize: crescimento aritmético, não geométrico."
                                  ],
                                  "verification": "O aluno resolve um cálculo simples: dado cwnd inicial 16 MSS, quantos RTTs para chegar a 20 MSS? (Resposta: 4 RTTs).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou planilha para simulações",
                                    "Ferramenta de simulação como ns-3 ou Cisco Packet Tracer"
                                  ],
                                  "tips": "Lembre-se: 1 MSS por RTT é conservador; imagine adicionar um carro por ciclo de trânsito na estrada.",
                                  "learningObjective": "Ao final, o aluno calculará e explicará o aumento linear da cwnd por RTT.",
                                  "commonMistakes": [
                                    "Aumentar por ACK individual em vez de por RTT",
                                    "Usar multiplicação em vez de adição",
                                    "Confundir MSS com MTU"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular o comportamento da fase e condições de saída",
                                  "subSteps": [
                                    "Simule uma sequência: inicie com cwnd = ssthresh = 16 MSS; liste cwnd após 5 RTTs sem perdas.",
                                    "Identifique detecção de congestamento: perda de pacote (timeout ou 3 dup ACKs).",
                                    "Explique reação: cwnd /= 2, ssthresh = cwnd/2, reinício em Congestion Avoidance.",
                                    "Compare throughput: linear resulta em taxa estável vs exponencial volátil.",
                                    "Use Wireshark para capturar tráfego real e observar."
                                  ],
                                  "verification": "O aluno cria um gráfico manual ou digital de cwnd vs RTTs, mostrando crescimento linear até detecção de perda.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark para captura de pacotes TCP",
                                    "Papel e lápis ou ferramenta como Draw.io para gráficos"
                                  ],
                                  "tips": "Capture tráfego HTTP em sua rede local para ver cwnd em ação; filtre por TCP.",
                                  "learningObjective": "Ao final, o aluno simulará e analisará o comportamento dinâmico da cwnd na fase.",
                                  "commonMistakes": [
                                    "Não considerar ACKs perdidos como sinal de congestão",
                                    "Achar que fase termina sem perdas",
                                    "Ignorar Fast Recovery em dup ACKs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impactos, variações e importância prática",
                                  "subSteps": [
                                    "Discuta fairness: múltiplos fluxos TCP convergem para divisão igual da banda.",
                                    "Compare com Reno/NewReno/Cubic: base comum de aumento linear.",
                                    "Avalie estabilidade: probing gradual maximiza uso sem oscilações.",
                                    "Relacione com AIMD (Additive Increase Multiplicative Decrease).",
                                    "Pense em cenários: WiFi vs fibra ótica."
                                  ],
                                  "verification": "O aluno explica como dois fluxos TCP compartilham banda em Congestion Avoidance, desenhando um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeos Khan Academy ou YouTube sobre TCP Congestion Control",
                                    "Artigo 'Congestion Avoidance and Control' de Van Jacobson"
                                  ],
                                  "tips": "Use analogia de elevadores: todos sobem devagar até um cair, então metade velocidade.",
                                  "learningObjective": "Ao final, o aluno avaliará o impacto da fase em redes reais e suas variações.",
                                  "commonMistakes": [
                                    "Subestimar fairness entre fluxos",
                                    "Confundir com queue management (RED/AQM)",
                                    "Ignorar evolução para algoritmos modernos"
                                  ]
                                }
                              ],
                              "practicalExample": "Durante um download de vídeo via YouTube (TCP), após o Slow Start inicial rápido, observe no Wireshark o crescimento linear da cwnd (ex: de 20 para 25 MSS em 500ms), permitindo taxa estável sem buffer underrun ou congestionamento na sua rede doméstica compartilhada.",
                              "finalVerifications": [
                                "Explicar corretamente o aumento: 1 MSS por RTT.",
                                "Desenhar gráfico de cwnd vs tempo mostrando linearidade.",
                                "Identificar condições de entrada (cwnd >= ssthresh) e saída (perda de pacotes).",
                                "Calcular cwnd após N RTTs sem erros.",
                                "Diferenciar de Slow Start em exemplos numéricos.",
                                "Simular em Wireshark ou ferramenta similar."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mecanismo de aumento linear (1 MSS/RTT).",
                                "Correta descrição de transições e reações a congestionamento.",
                                "Uso de exemplos concretos e cálculos numéricos.",
                                "Compreensão de fairness e estabilidade.",
                                "Aplicação em cenários reais via simulação.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Progressão aritmética e sequências lineares.",
                                "Física: Modelos de fluxo de tráfego e dinâmica de fluidos em redes.",
                                "Economia: Otimização de recursos compartilhados e equilíbrio de Nash.",
                                "Estatística: Probing adaptativo e inferência bayesiana em perdas.",
                                "Engenharia: Controle de sistemas feedback (PID-like)."
                              ],
                              "realWorldApplication": "Na internet global, essa fase garante que milhões de conexões TCP (downloads, streaming, web) sondem eficientemente a banda disponível em roteadores compartilhados, evitando colapsos como o ' congestionamento de 1986', permitindo navegação suave mesmo em horários de pico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Algoritmo TCP Tahoe",
                            "description": "Comparar o comportamento de reset completo da cwnd para 1 MSS em timeouts ou ACKs duplicados, reiniciando Slow Start.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Controle de Congestionamento TCP",
                                  "subSteps": [
                                    "Estude o conceito de Congestion Window (cwnd) e seu papel no controle de taxa de envio.",
                                    "Aprenda as fases Slow Start (cwnd dobra a cada RTT) e Congestion Avoidance (cwnd aumenta linearmente).",
                                    "Entenda os triggers de congestionamento: Timeout (RTO) e ACKs duplicados.",
                                    "Revise o MSS (Maximum Segment Size) como unidade base para cwnd.",
                                    "Desenhe um diagrama simples de evolução normal de cwnd sem perdas."
                                  ],
                                  "verification": "Desenhe e explique um gráfico de cwnd crescendo em Slow Start e Congestion Avoidance sem perdas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 5681 sobre TCP Congestion Control",
                                    "Ferramenta de desenho como Draw.io ou papel e caneta",
                                    "Vídeo introdutório sobre TCP (ex: Khan Academy ou YouTube)"
                                  ],
                                  "tips": "Use analogias como 'cwnd é como o tamanho da janela de um funil controlando o fluxo de pacotes'.",
                                  "learningObjective": "Compreender os mecanismos básicos de cwnd e fases de TCP para contextualizar Tahoe.",
                                  "commonMistakes": [
                                    "Confundir cwnd com rwnd (receive window)",
                                    "Ignorar que Slow Start inicia com cwnd=1 MSS",
                                    "Não diferenciar RTT de RTO"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Comportamento do TCP Tahoe em Timeout (RTO)",
                                  "subSteps": [
                                    "Simule um cenário onde um pacote é perdido e não há ACKs (timeout ocorre após RTO).",
                                    "Descreva o reset: cwnd é setado para 1 MSS, ssthresh é halved (ou para max(flightSize/2, 2*MSS)).",
                                    "Reinicie em Slow Start a partir de cwnd=1 MSS.",
                                    "Trace o gráfico de cwnd: queda abrupta para 1, reinício exponencial.",
                                    "Compare com Reno (que usa dup ACKs para partial recovery)."
                                  ],
                                  "verification": "Crie um gráfico manual ou em ferramenta mostrando cwnd antes/depois do timeout.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador ns-3 ou Wireshark com traces TCP",
                                    "Papel milimetrado para gráficos",
                                    "RFC 2001 (original Tahoe)"
                                  ],
                                  "tips": "Pense no timeout como 'reinício total' devido à incerteza de congestionamento severo.",
                                  "learningObjective": "Dominar o reset completo de cwnd em timeouts no Tahoe.",
                                  "commonMistakes": [
                                    "Esquecer de halvar ssthresh",
                                    "Assumir que cwnd vai para 0 em vez de 1 MSS",
                                    "Confundir RTO com retransmissão imediata"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Comportamento do TCP Tahoe em ACKs Duplicados",
                                  "subSteps": [
                                    "Simule perda detectada por 3 ACKs duplicados (Fast Retransmit).",
                                    "Descreva o reset idêntico: cwnd para 1 MSS, ssthresh halved, reinício Slow Start.",
                                    "Note que Tahoe trata dup ACKs como timeout (sem Fast Recovery como no Reno).",
                                    "Trace o gráfico: queda para 1 MSS após 3 dup ACKs.",
                                    "Compare os dois triggers: ambos causam reset completo, mas dup ACKs são mais rápidos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que Tahoe não distingue timeout de dup ACKs.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Wireshark para capturar traces reais de rede",
                                    "Simulador online como ns-3 playground",
                                    "Gráficos de exemplo de cwnd em Tahoe vs Reno"
                                  ],
                                  "tips": "Lembre: Tahoe é 'conservador' - sempre reset total para simplicidade.",
                                  "learningObjective": "Entender o tratamento uniforme de perdas em Tahoe via dup ACKs.",
                                  "commonMistakes": [
                                    "Confundir com Reno (que usa Fast Recovery após dup ACKs)",
                                    "Achar que dup ACKs evitam reset total",
                                    "Não contar exatamente 3 dup ACKs para trigger"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Simular Cenários Completos",
                                  "subSteps": [
                                    "Compare timeouts vs dup ACKs: ambos reset cwnd=1 MSS e Slow Start, mas frequência difere.",
                                    "Simule sequências: envie 10 pacotes, perca 1 (dup ACKs) vs perca todos (timeout).",
                                    "Gere gráficos lado a lado mostrando throughput recovery.",
                                    "Discuta limitações de Tahoe (ineficiente em perdas isoladas).",
                                    "Teste em simulador para validar comportamentos."
                                  ],
                                  "verification": "Produza dois gráficos comparativos e explique diferenças em recuperação.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Ns-3 ou OMNeT++ simulador",
                                    "Python com Matplotlib para plotar cwnd",
                                    "Traces Wireshark de rede real"
                                  ],
                                  "tips": "Use seeds diferentes no simulador para variar perdas e observar consistência.",
                                  "learningObjective": "Capacitar comparação precisa e simulação prática do algoritmo TCP Tahoe.",
                                  "commonMistakes": [
                                    "Ignorar impacto de RTT na detecção",
                                    "Não halvar ssthresh corretamente",
                                    "Confundir throughput com cwnd"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma transferência de arquivo de 1MB via HTTP sobre TCP Tahoe em uma rede com 5% perda de pacotes: ao detectar perda via timeout, cwnd cai de 32 MSS para 1 MSS, reiniciando Slow Start e halving ssthresh de 64 para 32 MSS; similarmente com 3 dup ACKs, mas recovery mais rápido. Simule no ns-3 e observe gráfico de cwnd caindo abruptamente em ambos casos, resultando em 'sawtooth' pattern conservador.",
                              "finalVerifications": [
                                "Desenhar gráfico preciso de cwnd para timeout e 3 dup ACKs no Tahoe.",
                                "Explicar verbalmente por que ambos triggers causam reset para 1 MSS.",
                                "Simular em ferramenta e identificar ssthresh halved.",
                                "Comparar throughput recovery vs TCP Reno em cenário de perda única.",
                                "Identificar limitações: ineficiência em redes wireless com perdas não-congestionamento.",
                                "Citar RFCs corretas (5681) para suporte."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do reset cwnd=1 MSS e Slow Start reinício (100% match com RFC).",
                                "Qualidade dos gráficos: eixos corretos (tempo/RTT vs cwnd/MSS), labels claros.",
                                "Profundidade da comparação: destacar triggers, timing e throughput.",
                                "Uso correto de terminologia (ssthresh, RTO, dup ACKs, Fast Retransmit).",
                                "Evidência de simulação prática com screenshots ou traces.",
                                "Identificação de 3+ limitações do Tahoe."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem exponencial/linear de crescimento de cwnd (sequências geométricas).",
                                "Física: Analogia com fluxo de fluidos e gargalos em tubulações (leis de conservação).",
                                "Estatística: Análise de perdas probabilísticas e impacto no throughput médio.",
                                "Programação: Implementar simulador simples em Python para evolução de cwnd."
                              ],
                              "realWorldApplication": "O TCP Tahoe é base para implementações antigas de internet; entender seu reset conservador explica lentidão em redes instáveis como Wi-Fi ou satélite, guiando otimizações em data centers (ex: Google usa variantes) e debugging de lentidão web via Wireshark."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.1",
                              "10.1.4.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.4",
                            "name": "Algoritmo TCP Reno",
                            "description": "Analisar melhorias com Fast Recovery, reduzindo cwnd para metade em ACKs duplicados e inflando temporariamente durante recovery.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do TCP Tahoe e Detecção de Perdas",
                                  "subSteps": [
                                    "Estude o mecanismo de controle de congestionamento no TCP Tahoe: slow start, congestion avoidance e retransmissão por timeout.",
                                    "Analise como o Tahoe reage a perdas: ao detectar timeout ou ACK triplo duplicado, define ssthresh = cwnd/2 e reinicia slow start.",
                                    "Identifique limitações do Tahoe: recuperação lenta após perdas não-timeout, levando a underutilização da banda.",
                                    "Compare com cenários reais de rede onde perdas ocorrem por congestionamento em vez de corrupção.",
                                    "Desenhe um diagrama de evolução de cwnd no Tahoe durante uma perda."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito as fases do Tahoe e liste 3 limitações específicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 5681 sobre TCP congestion control",
                                    "Vídeo tutorial sobre TCP Tahoe no YouTube",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias como 'tráfego rodoviário' para visualizar slow start como aceleração gradual.",
                                  "learningObjective": "Compreender o baseline do TCP Tahoe para contextualizar as melhorias do Reno.",
                                  "commonMistakes": [
                                    "Confundir ACK duplicado com timeout",
                                    "Ignorar a distinção entre perdas por congestionamento e corrupção",
                                    "Subestimar o impacto da reinicialização completa de cwnd"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Fast Retransmit no TCP Reno",
                                  "subSteps": [
                                    "Aprenda o gatilho: retransmitir o segmento perdido após 3 ACKs duplicados consecutivos, sem esperar timeout.",
                                    "Explique por que 3 ACKs: indica perda isolada sem congestionamento severo.",
                                    "Simule o fluxo: receptor envia ACKs duplicados para o último segmento recebido corretamente.",
                                    "Diferencie de Tahoe: Reno retransmite imediatamente, evitando o timeout longo.",
                                    "Registre mudanças em variáveis: flightSize e outstanding segments."
                                  ],
                                  "verification": "Simule em papel uma sequência de ACKs duplicados e identifique o momento da retransmissão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online como draw.io",
                                    "Exemplos de traces Wireshark de TCP Reno",
                                    "RFC 2581 (TCP Reno)"
                                  ],
                                  "tips": "Conte os ACKs duplicados em traces reais para fixar o conceito de '3'.",
                                  "learningObjective": "Dominar a detecção rápida de perdas via Fast Retransmit.",
                                  "commonMistakes": [
                                    "Achar que 2 ACKs duplicados bastam",
                                    "Confundir Fast Retransmit com Fast Recovery",
                                    "Não considerar ACKs para segmentos após o perdido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Mecanismo de Fast Recovery",
                                  "subSteps": [
                                    "Ao entrar em Fast Recovery: ssthresh = cwnd/2, cwnd = ssthresh + 3*MSS (um para cada ACK duplicado).",
                                    "Inflação temporária: para cada ACK duplicado adicional, cwnd += MSS, permitindo envio de novos segmentos.",
                                    "Deflação no ACK novo: quando ACK de novo material chega, cwnd = ssthresh e retoma congestion avoidance.",
                                    "Calcule exemplos numéricos: suponha cwnd=20, perda leva a cwnd=10 + 3=13, depois infla para 16, defla para 10.",
                                    "Desenhe gráfico de evolução de cwnd durante Fast Recovery."
                                  ],
                                  "verification": "Resolva um exercício numérico: dado cwnd inicial e 4 ACKs duplicados, calcule cwnd final.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel",
                                    "Simulador ns-3 ou Mininet",
                                    "Pseudocódigo do algoritmo Reno"
                                  ],
                                  "tips": "Lembre: inflar permite 'encher o pipe' durante recovery sem slow start.",
                                  "learningObjective": "Explicar precisamente as regras de ajuste de cwnd no Fast Recovery.",
                                  "commonMistakes": [
                                    "Reduzir cwnd para 1 em vez de metade",
                                    "Não inflar cwnd com ACKs extras",
                                    "Confundir ssthresh com cwnd inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Melhorias e Simular o Algoritmo",
                                  "subSteps": [
                                    "Compare throughput: Reno recupera mais rápido que Tahoe, evitando idle periods.",
                                    "Simule cenários: perda isolada vs. múltiplas perdas, observe impacto em RTT e goodput.",
                                    "Analise limitações do Reno: múltiplas perdas causam colapso (motivação para NewReno).",
                                    "Use ferramentas para capturar traces e validar comportamento.",
                                    "Discuta métricas: redução de tempo de recovery em até 50% em redes WAN."
                                  ],
                                  "verification": "Gere um gráfico comparativo de cwnd Tahoe vs. Reno e explique diferenças.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Wireshark para análise de tráfego",
                                    "Simulador online como TCP Simulator",
                                    "Artigo acadêmico sobre performance TCP Reno"
                                  ],
                                  "tips": "Teste com perdas artificiais em loopback para resultados rápidos.",
                                  "learningObjective": "Quantificar as melhorias do Reno e identificar cenários de falha.",
                                  "commonMistakes": [
                                    "Ignorar timeouts em perdas múltiplas",
                                    "Superestimar Reno em redes wireless",
                                    "Não medir throughput real"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure uma rede virtual com Mininet ou ns-3, inicie uma transferência TCP (ex: iperf), induza perda de 1% em um link, capture traces com tcpdump/Wireshark e analise a evolução de cwnd durante Fast Recovery, confirmando redução para metade e inflação temporária.",
                              "finalVerifications": [
                                "Explicar a sequência exata: 3 ACKs dup → Fast Retransmit → Fast Recovery com cwnd/2 + 3*MSS.",
                                "Calcular cwnd após 5 ACKs duplicados adicionais em um exemplo numérico.",
                                "Comparar diagrama de cwnd Reno vs. Tahoe para perda isolada.",
                                "Identificar quando Reno cai para slow start (timeout).",
                                "Descrever limitação em perdas múltiplas.",
                                "Simular verbalmente um trace Wireshark de Reno em recovery."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas regras de ajuste de cwnd (inflação/deflação).",
                                "Correta distinção entre Fast Retransmit e Fast Recovery.",
                                "Uso correto de terminologia (ssthresh, flightSize, ACK novo).",
                                "Análise quantitativa de melhorias em throughput.",
                                "Identificação de cenários onde Reno falha.",
                                "Qualidade de diagramas e simulações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos probabilísticos de perda de pacotes e queues (teoria de filas M/M/1).",
                                "Física: Analogia com dinâmica de fluidos em tubulações (cwnd como vazão).",
                                "Estatística: Análise de traces para calcular médias de RTT e perda.",
                                "Economia: Otimização de recursos em redes compartilhadas como alocação de banda."
                              ],
                              "realWorldApplication": "O TCP Reno é implementado em bilhões de conexões internet diárias (base para HTTP/HTTPS, streaming), reduzindo latência em downloads e melhorando eficiência em links WAN com perdas esporádicas, como Wi-Fi ou fibra ótica congestionada."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Controle de Fluxo e Confiabilidade no TCP",
                    "description": "Uso de números de sequência, ACKs e janelas deslizantes para controle de fluxo e retransmissão de pacotes perdidos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Números de Sequência no TCP",
                        "description": "Os números de sequência são valores de 32 bits atribuídos a cada byte de dados enviado em uma conexão TCP, permitindo a identificação única, ordenação de segmentos e detecção de perdas ou duplicatas para garantir a confiabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Identificar o propósito dos números de sequência",
                            "description": "Explicar como os números de sequência numeram os bytes de dados para assegurar a entrega em ordem e detectar pacotes perdidos ou fora de sequência em uma conexão TCP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do Protocolo TCP",
                                  "subSteps": [
                                    "Estudar o modelo TCP/IP e o papel da camada de transporte.",
                                    "Explicar o que são segmentos TCP e como eles encapsulam dados.",
                                    "Identificar desafios de rede como perda, duplicação e desordem de pacotes.",
                                    "Comparar TCP (confiável) com UDP (não confiável).",
                                    "Analisar um cabeçalho TCP básico, focando nos campos SEQ e ACK."
                                  ],
                                  "verification": "Resumir em 3 frases os motivos pelos quais o TCP precisa de mecanismos de confiabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do modelo TCP/IP",
                                    "Vídeo introdutório sobre TCP (ex: Khan Academy ou Cisco Networking Academy)",
                                    "Cabeçalho TCP impresso ou screenshot"
                                  ],
                                  "tips": "Use analogias como 'carta pelo correio' para visualizar problemas de rede.",
                                  "learningObjective": "Compreender o contexto onde os números de sequência são essenciais para a confiabilidade TCP.",
                                  "commonMistakes": [
                                    "Confundir TCP com IP (TCP é transporte, IP é rede)",
                                    "Ignorar que TCP é orientado a conexão e usa handshakes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o Conceito e Numeração dos Números de Sequência",
                                  "subSteps": [
                                    "Definir número de sequência (SEQ) como contador de bytes transmitidos.",
                                    "Explicar o Initial Sequence Number (ISN) aleatório para segurança.",
                                    "Calcular SEQ para segmentos: SEQ = posição do primeiro byte no stream.",
                                    "Demonstrar wrap-around após 2^32 - 1 bytes.",
                                    "Visualizar SEQ em um fluxograma de envio de dados."
                                  ],
                                  "verification": "Calcular SEQ para um stream de 1500 bytes dividido em dois segmentos de 750 bytes cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou planilha para simular numeração",
                                    "Ferramenta online como TCP Sequence Diagram Generator",
                                    "Livro ou PDF sobre TCP (ex: RFC 793)"
                                  ],
                                  "tips": "Lembre-se: SEQ numera BYTES, não pacotes, para precisão.",
                                  "learningObjective": "Dominar como os SEQ numeram bytes em um fluxo contínuo de dados.",
                                  "commonMistakes": [
                                    "Confundir SEQ com número de segmento (é por byte)",
                                    "Esquecer o ISN aleatório (não inicia sempre em 0)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Garantia de Ordem de Entrega",
                                  "subSteps": [
                                    "Descrever como receptor usa SEQ para detectar desordem.",
                                    "Explicar buffer de reordenação no receptor.",
                                    "Simular chegada fora de ordem: segmentos 1,3,2 -> reordenar para 1,2,3.",
                                    "Discutir entrega ao aplicação apenas em ordem.",
                                    "Analisar impacto em aplicações como streaming."
                                  ],
                                  "verification": "Desenhar um diagrama mostrando reordenação de 3 segmentos fora de ordem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Software Wireshark para capturar tráfego TCP real",
                                    "Simulador TCP online (ex: TCPtrace ou ns-3)"
                                  ],
                                  "tips": "Pense em uma fila de supermercado: itens chegam bagunçados, mas saem em ordem.",
                                  "learningObjective": "Entender como SEQ assegura entrega sequencial ao receptor.",
                                  "commonMistakes": [
                                    "Achar que TCP entrega fora de ordem à aplicação",
                                    "Ignorar buffers no receptor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar Pacotes Perdidos e Fora de Sequência",
                                  "subSteps": [
                                    "Explicar detecção de gaps: SEQ esperado != SEQ recebido.",
                                    "Descrever ACKs baseados em SEQ (ACK = próximo byte esperado).",
                                    "Simular perda: retransmissão via timeout ou duplicate ACKs.",
                                    "Identificar fora de sequência via SEQ não contíguo.",
                                    "Revisar Fast Retransmit e Go-Back-N."
                                  ],
                                  "verification": "Identificar perda em um log de SEQ: 1000, 1500, 2000 (gap em 1500).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de traces Wireshark",
                                    "Ferramenta de simulação TCP (ex: Packet Tracer)",
                                    "RFC 5681 sobre Congestion Control"
                                  ],
                                  "tips": "Monitore ACKs: 3 ACKs duplicados trigger retransmissão rápida.",
                                  "learningObjective": "Aplicar SEQ para diagnosticar e corrigir problemas de transmissão.",
                                  "commonMistakes": [
                                    "Confundir SEQ com ACK (SEQ é enviado, ACK confirma)",
                                    "Subestimar wrap-around em conexões longas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma transferência de arquivo de 2000 bytes em segmentos de 500 bytes: SEQ 0 (bytes 0-499), SEQ 500 (500-999), SEQ 1000 (1000-1499), SEQ 1500 (1500-1999). Se o segundo segmento se perde, receptor recebe SEQ 0 (ACK 500), SEQ 1000 (não ACK, gap detectado), SEQ 1500 (ainda gap). Enviador retransmite SEQ 500 após timeout ou 3 duplicate ACKs 500.",
                              "finalVerifications": [
                                "Explicar em suas palavras o propósito principal dos números de sequência no TCP.",
                                "Identificar o SEQ number em um cabeçalho TCP capturado no Wireshark.",
                                "Simular e detectar um pacote perdido em um diagrama de sequência TCP.",
                                "Diferenciar como SEQ previne desordem vs. perda de pacotes.",
                                "Calcular o próximo SEQ esperado após envio de 1460 bytes (MSS típico).",
                                "Descrever o papel do ISN na segurança TCP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de SEQ como numerador de bytes (não pacotes).",
                                "Correta explicação de detecção de gaps e reordenação.",
                                "Uso correto de exemplos com cálculos numéricos de SEQ.",
                                "Compreensão de ACKs cumulativos baseados em SEQ.",
                                "Identificação de erros comuns como wrap-around ou ISN.",
                                "Aplicação prática via simulação ou Wireshark."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e contadores de 32 bits (wrap-around).",
                                "Física: Analogia com ondas de sinal numeradas para sincronização.",
                                "Segurança da Informação: Mitigação de ataques de previsão de sequência (RFC 6528).",
                                "Estatística: Probabilidade de perda em redes e recuperação.",
                                "Engenharia: Design de protocolos confiáveis em sistemas distribuídos."
                              ],
                              "realWorldApplication": "Em navegadores web (HTTPS), garante que HTML, CSS e JS sejam entregues na ordem correta, evitando páginas quebradas; em streaming (Netflix), reordena pacotes de vídeo perdidos para reprodução fluida sem buffering excessivo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Calcular números de sequência em uma conexão TCP",
                            "description": "Demonstrar o cálculo de números de sequência iniciais (ISN) e subsequentes para segmentos de dados, considerando o wrap-around em campos de 32 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos Números de Sequência no TCP",
                                  "subSteps": [
                                    "Estude o cabeçalho TCP, focando no campo Sequence Number de 32 bits (4 bytes).",
                                    "Aprenda que o Initial Sequence Number (ISN) é escolhido aleatoriamente para prevenir ataques de previsão.",
                                    "Entenda que os números de sequência contam bytes de dados enviados, não o número de segmentos.",
                                    "Revise o conceito de Acknowledgment Number (ACK), que confirma bytes recebidos.",
                                    "Leia trechos da RFC 793 sobre controle de fluxo e confiabilidade."
                                  ],
                                  "verification": "Desenhe o cabeçalho TCP e anote o tamanho e propósito do campo Sequence Number.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 793 (TCP Specification)",
                                    "Diagrama interativo de cabeçalho TCP (Wireshark ou online)"
                                  ],
                                  "tips": [
                                    "Visualize os 32 bits como um contador que vai de 0 a 4.294.967.295 antes de wrap-around."
                                  ],
                                  "learningObjective": "Explicar o papel dos números de sequência e ACK no controle de confiabilidade TCP.",
                                  "commonMistakes": [
                                    "Confundir Sequence Number com número de porta ou segmento.",
                                    "Ignorar que conta bytes, não pacotes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o ISN e Números de Sequência para o Primeiro Segmento",
                                  "subSteps": [
                                    "Escolha um ISN exemplo (ex: 12345678 em hex: 0xBBE0EE).",
                                    "Simule o envio de um segmento com N bytes de dados: próximo Seq = ISN + N.",
                                    "Calcule o ACK para o SYN: ACK = ISN_cliente + 1.",
                                    "Pratique com dados de 10 bytes: Seq inicial = ISN, final esperado = ISN + 10.",
                                    "Registre os valores em decimal e hexadecimal para familiaridade."
                                  ],
                                  "verification": "Calcule Seq e ACK para um segmento SYN com 0 dados e um com 5 bytes; resultados devem bater com fórmulas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal",
                                    "Planilha Excel para simulações",
                                    "Ferramenta online de conversão hex-dec"
                                  ],
                                  "tips": [
                                    "Sempre adicione o comprimento exato dos dados ao Seq atual."
                                  ],
                                  "learningObjective": "Aplicar fórmula básica Seq_next = Seq_atual + bytes_enviados.",
                                  "commonMistakes": [
                                    "Esquecer de somar 1 para SYN/ACK flags.",
                                    "Usar bits em vez de bytes nos cálculos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Números Subsequentes Considerando ACKs e Múltiplos Segmentos",
                                  "subSteps": [
                                    "Simule uma transferência: envie 1400 bytes em 2 segmentos (700 cada), atualizando Seq após cada ACK.",
                                    "Calcule Seq após ACK recebido: próximo envio usa último Seq + bytes confirmados.",
                                    "Inclua flags: SYN (+1), FIN (+1) no cálculo de bytes.",
                                    "Pratique uma troca completa: cliente envia 20 bytes, servidor ACK, servidor responde 10 bytes.",
                                    "Use Wireshark para capturar tráfego real e validar cálculos manuais."
                                  ],
                                  "verification": "Simule 3 segmentos e liste Seq/ACK para cada; compare com captura Wireshark.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Exemplo de captura TCP pcap",
                                    "Papel e caneta para fluxogramas"
                                  ],
                                  "tips": [
                                    "Desenhe um fluxograma da conexão para rastrear Seq/ACK."
                                  ],
                                  "learningObjective": "Gerenciar Seq/ACK em fluxos bidirecionais com múltiplos segmentos.",
                                  "commonMistakes": [
                                    "Não atualizar Seq após ACK parcial.",
                                    "Confundir direção: cada lado tem seu próprio Seq."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Wrap-Around e Verificações Finais",
                                  "subSteps": [
                                    "Calcule wrap-around: após 2^32 - 1 (4294967295), volta a 0.",
                                    "Simule transferência longa: envie 5GB de dados e localize o wrap.",
                                    "Verifique handling de ACKs durante wrap: TCP trata como linear com window.",
                                    "Teste cenários de perda: reenvio usa último Seq não-ACKed.",
                                    "Implemente uma simulação simples em Python para validar."
                                  ],
                                  "verification": "Calcule Seq após wrap-around para 4.3GB enviados; execute simulação Python sem erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com socket ou scapy",
                                    "Código template para simulação TCP Seq"
                                  ],
                                  "tips": [
                                    "Use módulo 2**32 para simular wrap em código: seq = (seq + bytes) % (1<<32)"
                                  ],
                                  "learningObjective": "Lidar com overflow de 32 bits e manter integridade em transferências longas.",
                                  "commonMistakes": [
                                    "Assumir parada no wrap; TCP continua seamless.",
                                    "Ignorar PAWS para duplicates antigos."
                                  ]
                                }
                              ],
                              "practicalExample": "Cliente ISN=1000 (0x3E8). Envia SYN (Seq=1000), servidor SYN-ACK (ACK=1001). Cliente envia 'HELLO' (5 bytes, Seq=1001, próximo=1006). Servidor ACK=1006, envia 'WORLD' (5 bytes, seu Seq=2000, próximo=2005). Cliente ACK=2005. Total: bytes confirmados corretamente sem gaps.",
                              "finalVerifications": [
                                "Calcule Seq/ACK para uma conexão com 1500 bytes em 2 segmentos.",
                                "Simule wrap-around: após 4294967295 bytes, próximo Seq=0.",
                                "Explique por que ISN é randômico (prevenir hijacking).",
                                "Capture Wireshark e anote 5 Seq/ACK corretamente.",
                                "Implemente função Python que gera próximo Seq com wrap.",
                                "Identifique erro em um trace com Seq duplicado."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos de Seq/ACK para exemplos dados.",
                                "Correta explicação de byte-counting vs packet-counting.",
                                "Demonstração de wrap-around sem erros lógicos.",
                                "Uso correto de hex/decimal em simulações.",
                                "Integração de ACKs em fluxos bidirecionais.",
                                "Identificação de 3 erros comuns em traces Wireshark."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular (mod 2^32) e overflow handling.",
                                "Programação: Implementação em sockets Python ou C para seq manual.",
                                "Criptografia: ISN randômico contra TCP sequence prediction attacks.",
                                "Física/Engenharia: Analogia com contadores em protocolos seriais.",
                                "Segurança: Impacto de seq previsíveis em MITM attacks."
                              ],
                              "realWorldApplication": "Em navegadores web, TCP seq garante que páginas carreguem na ordem correta apesar de perdas na internet; usado em HTTPS, email (SMTP), streaming (Netflix), evitando dados corrompidos ou fora de ordem."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Aplicar números de sequência na detecção de perdas",
                            "description": "Analisar um fluxo de pacotes TCP para identificar perdas baseadas em números de sequência ausentes e preparar retransmissões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Números de Sequência no TCP",
                                  "subSteps": [
                                    "Estude a estrutura do cabeçalho TCP, focando no campo Sequence Number (32 bits).",
                                    "Entenda como o Sequence Number é inicializado no SYN e incrementado por bytes enviados.",
                                    "Aprenda o papel do Acknowledgment Number na confirmação de recebimento.",
                                    "Revise o mecanismo de janela deslizante e seu impacto na sequência.",
                                    "Examine diagramas de handshake TCP three-way para visualizar sequências iniciais."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como um Sequence Number ausente indica perda, com exemplo numérico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação RFC 793 (TCP), Wireshark User Guide, diagramas TCP online.",
                                  "tips": "Use ferramentas visuais como TCP sequence diagrams generators para melhor compreensão.",
                                  "learningObjective": "Compreender o funcionamento e propósito dos números de sequência no TCP.",
                                  "commonMistakes": "Confundir Sequence Number com Acknowledgment Number; ignorar wrap-around em 32 bits."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Capturar e Filtrar Fluxo de Pacotes TCP",
                                  "subSteps": [
                                    "Instale e configure Wireshark para capturar tráfego em uma interface de rede.",
                                    "Inicie uma sessão TCP (ex: telnet ou http) e capture pacotes durante transferência de dados.",
                                    "Aplique filtro 'tcp.analysis.lost_segment' ou 'tcp.seq' para isolar fluxo relevante.",
                                    "Salve o capture em formato .pcap para análise offline.",
                                    "Identifique o par de portas origem/destino para focar no fluxo bidirecional."
                                  ],
                                  "verification": "Capture um arquivo .pcap com pelo menos 50 pacotes TCP e filtre corretamente o fluxo alvo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Wireshark (gratuito), máquina com rede ativa, tutorial Wireshark básico.",
                                  "tips": "Use loopback ou VMs para capturas controladas sem interferir na rede real.",
                                  "learningObjective": "Capturar e preparar dados reais de tráfego TCP para análise.",
                                  "commonMistakes": "Não filtrar corretamente, capturando ruído desnecessário; esquecer de parar captura."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Sequência de Números de Sequência e Detectar Ausentes",
                                  "subSteps": [
                                    "No Wireshark, navegue pela lista de pacotes e anote Sequence Numbers em ordem cronológica.",
                                    "Calcule diferenças esperadas: próximo SEQ = SEQ atual + len(payload) + 1.",
                                    "Identifique gaps onde SEQ recebido != SEQ esperado, marcando como potencial perda.",
                                    "Verifique ACKs recebidos para confirmar se o receptor detectou a perda.",
                                    "Use Expert Information no Wireshark para flags como 'TCP Retransmission' ou 'TCP Dup ACK'."
                                  ],
                                  "verification": "Liste 3 gaps de sequência em um trace fornecido, justificando cada detecção.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Arquivo .pcap com perdas simuladas (ex: via tc netem), Wireshark.",
                                  "tips": "Siga a coluna 'TCP Seq' e 'Delta' no Wireshark para spotting rápido de anomalias.",
                                  "learningObjective": "Detectar perdas por análise manual de números de sequência.",
                                  "commonMistakes": "Ignorar len(payload) no cálculo de SEQ esperado; confundir retransmissões com novas perdas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preparar Detecção Automatizada e Simular Retransmissões",
                                  "subSteps": [
                                    "Escreva um script simples em Python com Scapy para parsear .pcap e detectar gaps.",
                                    "Simule perda injetando delays/drops com tc netem em uma conexão TCP teste.",
                                    "Monitore retransmissões via Wireshark após perda detectada.",
                                    "Documente passos para trigger RTO (Retransmission Timeout) baseado em SEQ.",
                                    "Teste em fluxo bidirecional para verificar fast retransmit via Dup ACKs."
                                  ],
                                  "verification": "Execute script que outputa perdas detectadas e confirme com Wireshark retransmissões.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python + Scapy, tc (Linux traffic control), sample .pcap files.",
                                  "tips": "Comece com script básico printando SEQs antes de lógica de gap.",
                                  "learningObjective": "Automatizar detecção e preparar ações de retransmissão confiável.",
                                  "commonMistakes": "Não considerar direção do fluxo (sender/receiver); erros em parsing de .pcap."
                                }
                              ],
                              "practicalExample": "Em um trace Wireshark de uma transferência HTTP, SEQ inicia em 1000. Pacotes chegam: 1000 (100 bytes), 1201 (skip de 100 bytes? Esperado 1100), 1201. Gap de 1000-1100 indica perda de um pacote; receptor envia Dup ACK em 1000, triggerando fast retransmit.",
                              "finalVerifications": [
                                "Detectar corretamente todas as perdas em um trace de 100 pacotes com 5 gaps.",
                                "Explicar causalidade entre gap SEQ e Dup ACKs/retransmissões.",
                                "Simular perda e confirmar retransmissão manualmente.",
                                "Script automatizado identifica gaps com 100% precisão em teste conhecido.",
                                "Diferenciar perda de out-of-order via análise de SEQ e timestamps.",
                                "Documentar relatório com screenshots Wireshark de detecções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gaps SEQ (90%+ acurácia).",
                                "Explicação clara do cálculo SEQ esperado vs recebido.",
                                "Uso correto de ferramentas (Wireshark filtros, Scapy parsing).",
                                "Análise de impactos (atraso, throughput) da perda detectada.",
                                "Criatividade em automação e simulação de cenários.",
                                "Relatório estruturado com evidências visuais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de sequências aritméticas e detecção de falhas.",
                                "Programação: Parsing de binários e automação de rede com Python/Scapy.",
                                "Estatística: Análise de traces para métricas de perda e RTT.",
                                "Física: Analogia com transmissão de sinais e ruído em canais."
                              ],
                              "realWorldApplication": "Em troubleshooting de redes empresariais, detectar perdas TCP via SEQ gaps otimiza VoIP/video calls; em desenvolvimento de apps cloud, garante entrega confiável de dados em conexões instáveis como mobile 5G."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "ACKs (Acknowledgments) no TCP",
                        "description": "Os ACKs são confirmações enviadas pelo receptor para informar o remetente sobre os bytes recebidos com sucesso, utilizando números de sequência para ACKs cumulativos que impulsionam a retransmissão de pacotes perdidos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Explicar o mecanismo de ACKs cumulativos",
                            "description": "Descrever como um ACK cumulativo confirma todos os bytes até um número de sequência específico, otimizando o protocolo para eficiência em redes com perdas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Números de Sequência e ACKs Básicos no TCP",
                                  "subSteps": [
                                    "Revise o conceito de números de sequência (sequence numbers) no TCP, que identificam cada byte de dados enviado.",
                                    "Explique que ACKs (acknowledgments) são respostas do receptor confirmando recebimento de dados.",
                                    "Diferencie ACKs individuais (confirmam um segmento específico) de ACKs cumulativos (confirmam tudo até um ponto).",
                                    "Estude diagramas de handshake TCP para contextualizar.",
                                    "Anote exemplos numéricos simples, como envio de bytes 1-1000."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando envio de dados e ACK básico; confirme se identifica corretamente o número de sequência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama TCP básico (RFC 793)",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Comece com fluxos sem perdas para construir base sólida antes de introduzir cumulativos.",
                                  "learningObjective": "Entender a fundação de sequence numbers e ACKs para preparar explicação cumulativa.",
                                  "commonMistakes": [
                                    "Confundir sequence number com segmento number",
                                    "Ignorar que sequence numbers são por byte, não por pacote"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar ACKs Individuais de Cumulativos",
                                  "subSteps": [
                                    "Descreva ACKs individuais: cada segmento perdido requer ACK específico, ineficiente em perdas múltiplas.",
                                    "Introduza ACKs cumulativos: um ACK n confirma todos os bytes até n-1 recebidos corretamente.",
                                    "Compare com diagrama: mostre rede com perdas onde ACK cumulativo otimiza retransmissões.",
                                    "Calcule exemplos: se bytes 1-500 OK e 501 perdido, ACK cumulativo é 501.",
                                    "Simule em papel uma troca com 3 segmentos perdidos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença usando um exemplo com 2 perdas; verifique se menciona eficiência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Vídeo tutorial sobre TCP ACKs (Khan Academy ou similar)"
                                  ],
                                  "tips": "Use setas em diagramas para mostrar fluxo de ACKs, destacando redução de tráfego com cumulativos.",
                                  "learningObjective": "Distinguir mecanismos e identificar quando cumulativos são superiores.",
                                  "commonMistakes": [
                                    "Achar que ACK cumulativo ignora perdas anteriores",
                                    "Confundir ACK com próximo esperado em vez de confirmado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Mecanismo de ACKs Cumulativos em Detalhe",
                                  "subSteps": [
                                    "Detalhe o algoritmo: receptor envia ACK com o menor sequence number não recebido +1.",
                                    "Aborde 'fast retransmit': 3 ACKs duplicados trigger retransmissão sem timeout.",
                                    "Simule cenário: envie segmentos 1-10, perca 5 e 7; trace ACKs cumulativos.",
                                    "Discuta janela deslizante e como ACKs avançam a janela do remetente.",
                                    "Implemente pseudocódigo simples para geração de ACK cumulativo.",
                                    "Analise impacto em redes com perdas altas (ex: WiFi)."
                                  ],
                                  "verification": "Simule um cenário com perdas em ferramenta online (TCP simulator) e liste ACKs gerados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador TCP online (ex: tcp-playground ou Wireshark trace)",
                                    "Pseudocódigo editor (Notepad++)"
                                  ],
                                  "tips": "Sempre trace sequence numbers numericamente para evitar confusão visual.",
                                  "learningObjective": "Dominar o fluxo preciso de geração e interpretação de ACKs cumulativos.",
                                  "commonMistakes": [
                                    "Esquecer ACK duplicado para fast recovery",
                                    "Não considerar ordem de chegada fora de sequência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Benefícios e Otimizações com ACKs Cumulativos",
                                  "subSteps": [
                                    "Quantifique eficiência: reduzem overhead de ACKs em 50-70% em perdas seletivas.",
                                    "Compare com UDP (sem ACKs) e outros protocolos.",
                                    "Estude Selective ACKs (SACK) como extensão cumulativa.",
                                    "Crie tabela comparativa: ACK individual vs cumulativo em throughput.",
                                    "Discuta limitações: head-of-line blocking em perdas precoces."
                                  ],
                                  "verification": "Resuma benefícios em parágrafo e calcule overhead em exemplo dado; valide com fórmulas básicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo RFC 5681 (TCP Congestion Control)",
                                    "Planilha Excel para cálculos de throughput"
                                  ],
                                  "tips": "Use métricas reais como 'ACKs por byte confirmado' para quantificar ganhos.",
                                  "learningObjective": "Avaliar impactos práticos e otimizações relacionadas.",
                                  "commonMistakes": [
                                    "Superestimar eficiência em perdas totais",
                                    "Ignorar interação com controle de congestão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma transferência de arquivo HTTP sobre TCP (ex: baixar imagem de 10KB), se pacotes com bytes 2000-3000 forem perdidos em WiFi instável, o receptor envia ACK 2000 cumulativo repetidamente. Após 3 ACKs duplicados, o servidor retransmite apenas o perdido, confirmando o resto com ACK 10000 ao receber.",
                              "finalVerifications": [
                                "Explicar corretamente o que ACK n significa (todos bytes até n-1 confirmados).",
                                "Simular trace TCP com perdas e identificar ACKs cumulativos.",
                                "Diferenciar de ACKs individuais com exemplo numérico.",
                                "Descrever fast retransmit via ACKs duplicados.",
                                "Calcular avanço da janela deslizante com ACK cumulativo."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: uso correto de sequence/ACK numbers.",
                                "Clareza na explicação: diagramas e exemplos acionáveis.",
                                "Compreensão de eficiência: quantificação de benefícios em perdas.",
                                "Profundidade: menção a fast retransmit e SACK.",
                                "Aplicação contextual: ligação com redes reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular em sequence numbers (wrap-around).",
                                "Probabilidade: Modelagem de perdas de pacotes em redes.",
                                "Física: Analogia com sinais eletromagnéticos em transmissão sem fio.",
                                "Economia: Otimização de recursos (banda) em sistemas limitados."
                              ],
                              "realWorldApplication": "No streaming de vídeo Netflix ou chamadas Zoom, ACKs cumulativos no TCP garantem retransmissão eficiente de frames perdidos em conexões móveis ruins, minimizando buffering e mantendo qualidade sem desperdiçar banda em ACKs excessivos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Interpretar ACKs em um trace de rede TCP",
                            "description": "Analisar capturas de pacotes (ex.: Wireshark) para identificar ACKs, calcular o próximo byte esperado e detectar timeouts para retransmissão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente e Carregar o Trace de Rede",
                                  "subSteps": [
                                    "Instalar ou abrir o Wireshark no computador",
                                    "Baixar ou obter um arquivo de captura .pcap com tráfego TCP real (ex.: captura de uma conexão HTTP via tcpdump)",
                                    "Abrir o arquivo no Wireshark e aplicar filtro 'tcp' para exibir apenas pacotes TCP",
                                    "Configurar colunas personalizadas para mostrar Seq, Ack e Flags visíveis na lista de pacotes",
                                    "Salvar a sessão para reutilização futura"
                                  ],
                                  "verification": "Lista de pacotes TCP carregada e filtrada, com colunas Seq/Ack visíveis e pelo menos 50 pacotes exibidos",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Wireshark (versão 4.x ou superior)",
                                    "Arquivo .pcap de exemplo com tráfego TCP (disponível em sites como Wireshark Sample Captures)"
                                  ],
                                  "tips": "Use o filtro 'tcp.analysis.retransmission' para pré-visualizar problemas, mas remova-o inicialmente para análise manual",
                                  "learningObjective": "Configurar corretamente as ferramentas para análise isolada de tráfego TCP",
                                  "commonMistakes": [
                                    "Abrir arquivo não-TCP (ex.: ICMP only)",
                                    "Esquecer de filtrar, sobrecarregando a visualização",
                                    "Não ajustar colunas, dificultando leitura rápida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Localizar ACKs em Pacotes TCP",
                                  "subSteps": [
                                    "Selecionar um pacote TCP na lista e expandir a seção 'Transmission Control Protocol' nos detalhes",
                                    "Localizar o campo 'Acknowledgment number' e verificar se a flag 'ACK' está setada (bit 1)",
                                    "Identificar tipos de ACKs: SYN-ACK (durante handshake), ACK puro e ACK com dados",
                                    "Rastrear 5-10 pacotes consecutivos anotando os valores de ACK number",
                                    "Destacar pacotes com ACK flag usando coloração no Wireshark (Analyze > Enabled Protocols)"
                                  ],
                                  "verification": "Anotações de pelo menos 5 ACK numbers corretamente identificados de pacotes com flag ACK setada",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Wireshark aberto com trace",
                                    "Papel ou bloco de notas para anotações manuais"
                                  ],
                                  "tips": "Pressione Ctrl + clique em pacote para follow TCP stream e ver fluxo sequencial",
                                  "learningObjective": "Reconhecer visualmente ACKs e seus campos em uma captura real",
                                  "commonMistakes": [
                                    "Confundir Ack number com Sequence number",
                                    "Ignorar flags, analisando ACKs sem flag setada",
                                    "Não expandir detalhes do protocolo TCP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Próximo Byte Esperado Usando ACK Numbers",
                                  "subSteps": [
                                    "Explicar que ACK number indica o próximo byte esperado pelo receptor (seq do sender + len dados)",
                                    "Para uma sequência de pacotes, calcular manualmente: próximo esperado = ACK atual do receptor",
                                    "Verificar consistência: ACK deve avançar monotonicamente ou repetir em losses",
                                    "Calcular window size (Bytes in flight = MSS * (próximo esperado - ACK atual))",
                                    "Usar Expert Information no Wireshark para validar cálculos manuais"
                                  ],
                                  "verification": "Tabela anotada com 3 exemplos de cálculos corretos de próximo byte esperado",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou planilha para aritmética",
                                    "Wireshark com trace aberto"
                                  ],
                                  "tips": "Lembre-se: seq numbers wrap around após 2^32; use relative sequence numbers no Wireshark",
                                  "learningObjective": "Dominar o cálculo preciso do estado de fluxo baseado em ACKs",
                                  "commonMistakes": [
                                    "Confundir sender/receiver perspectives",
                                    "Não contabilizar length de payload",
                                    "Ignorar wrap-around em traces longos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar Timeouts e Retransmissões via Análise de ACKs",
                                  "subSteps": [
                                    "Procurar ACK duplicados (mesmo número repetido 3x indica loss - Fast Retransmit)",
                                    "Identificar gaps: seq avança mas ACK estagna, seguido de retransmissão",
                                    "Aplicar filtro 'tcp.analysis.lost_segment' e correlacionar com timeouts (sem ACK após RTO)",
                                    "Medir tempo entre pacotes para estimar RTO (tipicamente 1-60s)",
                                    "Anotar causa: loss detectado por timeout vs duplicate ACKs"
                                  ],
                                  "verification": "Relatório de 2-3 eventos de retransmissão identificados com evidências de ACKs",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark com filtros avançados",
                                    "Timer para medir delays"
                                  ],
                                  "tips": "Use Statistics > TCP Stream Graphs > Round Trip Time para visualizar timeouts",
                                  "learningObjective": "Diagnosticar problemas de confiabilidade TCP através de padrões de ACK",
                                  "commonMistakes": [
                                    "Confundir duplicate ACKs com ACKs normais em zero-window",
                                    "Não diferenciar retransmissão de out-of-order",
                                    "Subestimar RTO sem medir timestamps"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um trace Wireshark de uma conexão HTTP baixando um arquivo de 10KB: Pacotes seq=1000-2000 enviados; pacote seq=1500 perdido. Receptor envia ACK=1000 repetidamente (duplicados). Após ~200ms (RTO), sender retransmite seq=1500; ACK avança para 2001. Calcule próximo esperado como 1500 durante stall.",
                              "finalVerifications": [
                                "Identificar corretamente ACK flag e number em 90% dos pacotes de um trace novo",
                                "Calcular próximo byte esperado sem erros em 5 sequências manuais",
                                "Detectar e explicar 2 retransmissões em trace com losses intencionais",
                                "Usar filtros Wireshark para isolar ACK-related issues",
                                "Explicar diferença entre timeout e fast retransmit",
                                "Interpretar window scaling impact em ACKs"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de campos TCP (90%+ correto)",
                                "Correção matemática em cálculos de seq/ACK (sem erros aritméticos)",
                                "Profundidade na análise de padrões (explica causas de stalls)",
                                "Eficiência no uso de ferramentas Wireshark (filtros e graphs)",
                                "Clareza em relatórios/anotações (lógico e conciso)",
                                "Criatividade em correlações (ex: liga a performance real)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e sequências em números de 32 bits",
                                "Programação: Implementar sockets TCP em Python (scapy para gerar traces)",
                                "Segurança da Informação: Detectar ACK spoofing em ataques de hijacking",
                                "Física/Engenharia: Analogia com sistemas de correio confiável (ACK como recibo)"
                              ],
                              "realWorldApplication": "Em data centers (ex.: AWS), analistas usam isso para troubleshoot lentidão de apps web causada por packet loss; devs otimizam apps TCP para cloud; ISPs diagnosticam falhas de rede residenciais via traces de clientes."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Simular retransmissão baseada em ACKs",
                            "description": "Simular o processo de retransmissão de um segmento perdido quando um ACK duplicado é recebido ou timeout ocorre, usando diagramas de tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Segmentos TCP, ACKs e Mecanismos de Detecção de Perda",
                                  "subSteps": [
                                    "Revise a estrutura de um segmento TCP: campos como SEQ (sequence number), ACK (acknowledgment number), flags.",
                                    "Estude o papel dos ACKs: ACK cumulativo confirma todos os bytes até o número ACK.",
                                    "Aprenda sobre ACK duplicado: ocorre quando um segmento é recebido fora de ordem ou perdido, remetendo ACKs com o mesmo número.",
                                    "Compreenda timeouts: RTO (Retransmission Timeout) baseado em RTT estimado.",
                                    "Desenhe um diagrama simples de handshake TCP de 3 vias para contextualizar."
                                  ],
                                  "verification": "Crie um glossário com definições de SEQ, ACK, ACK duplicado e timeout, e explique em voz alta como eles detectam perdas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de segmento TCP (imagem ou desenho manual)",
                                    "Documentação RFC 793 ou Wireshark tutorial",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use cores diferentes para SEQ e ACK em diagramas para visualizar melhor.",
                                  "learningObjective": "Compreender os fundamentos de ACKs e detecção de perdas no TCP.",
                                  "commonMistakes": [
                                    "Confundir ACK cumulativo com ACK seletivo",
                                    "Ignorar o papel do RTT no cálculo de timeout"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Cenário de Simulação com Diagrama de Tempo Inicial",
                                  "subSteps": [
                                    "Desenhe um diagrama de tempo (timeline) com emissor (A) e receptor (B) no topo.",
                                    "Simule envio de 4 segmentos: SEQ=1,2,3,4 (assuma MSS=1 para simplicidade).",
                                    "Marque ACKs esperados: após receber SEQ=1, envie ACK=2; SEQ=2, ACK=3, etc.",
                                    "Introduza perda: defina que o segmento SEQ=3 é perdido.",
                                    "Adicione setas para envios e ACKs com timestamps fictícios (ex: t=0,1,2...)."
                                  ],
                                  "verification": "Mostre o diagrama inicial a alguém e explique o fluxo sem perda primeiro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io, Lucidchart ou papel quadriculado",
                                    "Modelo de diagrama de tempo TCP pronto como referência"
                                  ],
                                  "tips": "Use setas bidirecionais e labels claros como 'Perdido' em vermelho.",
                                  "learningObjective": "Configurar visualmente um cenário de comunicação TCP com perda simulada.",
                                  "commonMistakes": [
                                    "Esquecer de marcar sequence numbers corretamente",
                                    "Não alinhar timelines horizontalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Detecção de Perda via ACK Duplicado ou Timeout",
                                  "subSteps": [
                                    "No diagrama, simule: A envia 1,2,3(perdido),4; B recebe 1 (ACK2), 2(ACK3), 4(ACK3 duplicado).",
                                    "Registre ACK duplicado: B envia ACK3 novamente após receber 4 (fast retransmit).",
                                    "Alternativa: simule timeout - marque tempo sem ACK3, A retransmite após RTO.",
                                    "Compare os dois casos: desenhe ramificações no diagrama para ACK dup vs timeout.",
                                    "Anote thresholds: 3 ACKs duplicados tipicamente trigger fast retransmit."
                                  ],
                                  "verification": "Identifique no diagrama o ponto exato onde perda é detectada e o tipo (ACK dup ou timeout).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama do Step 2 expandido",
                                    "Referência TCP congestion control (RFC 5681)",
                                    "Cronômetro para simular tempos"
                                  ],
                                  "tips": "Simule em papel primeiro, depois digitalize para editar.",
                                  "learningObjective": "Demonstrar como TCP detecta perdas usando ACKs duplicados ou timeouts.",
                                  "commonMistakes": [
                                    "Confundir ACK duplicado com ACK perdido",
                                    "Não contar corretamente o número de duplicados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular a Retransmissão e Verificar Recuperação",
                                  "subSteps": [
                                    "Após detecção (ex: 3 ACK3), A retransmite SEQ=3.",
                                    "B recebe SEQ=3 (envia ACK4), então SEQ=4 pendente é confirmado.",
                                    "Atualize diagrama: adicione setas de retransmissão e ACK final.",
                                    "Simule para timeout: A retransmite SEQ=3 após RTO, B ACK4.",
                                    "Calcule impacto: compare latência com/sem perda."
                                  ],
                                  "verification": "Complete o diagrama final e calcule o número total de segmentos enviados (deve ser 5 em vez de 4).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama atualizado",
                                    "Calculadora para RTT/RTO simples",
                                    "Exemplo Wireshark capture de TCP perda (opcional)"
                                  ],
                                  "tips": "Adicione legendas para retransmissões em negrito.",
                                  "learningObjective": "Executar e validar a retransmissão TCP em simulação.",
                                  "commonMistakes": [
                                    "Não ajustar window size após retransmissão",
                                    "Esquecer ACK final cumulativo"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o download de uma imagem de 4 KB dividida em 4 segmentos TCP. O terceiro segmento se perde na rede Wi-Fi congestionada. Desenhe o diagrama mostrando ACKs duplicados (3x ACK para byte 3), trigger de fast retransmit, retransmissão e ACK final confirmando a imagem completa.",
                              "finalVerifications": [
                                "Diagrama completo mostra perda, detecção e retransmissão corretamente.",
                                "Explicação oral diferencia ACK duplicado de timeout.",
                                "Cálculo correto: 5 segmentos enviados para 4 originais.",
                                "Identificação de fast retransmit threshold (3 duplicados).",
                                "Comparação de latência: com perda ~2x RTT extra.",
                                "Sem erros em sequence/ACK numbers no diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos diagramas de tempo (setas, labels, timelines alinhadas): 30%",
                                "Correta simulação de ACKs duplicados e/ou timeout: 25%",
                                "Detalhes na retransmissão e recuperação: 20%",
                                "Explicação escrita dos mecanismos TCP: 15%",
                                "Criatividade no exemplo prático e conexões reais: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de probabilidades de perda de pacotes e estatísticas de RTT.",
                                "Programação: Implementar socket TCP em Python para observar retransmissões reais com Wireshark.",
                                "Física: Analogia com transmissão de sinais em redes sem fio e interferências.",
                                "Estatística: Análise de traces de rede para taxas de perda."
                              ],
                              "realWorldApplication": "Em navegadores web, TCP retransmite pacotes perdidos durante streaming de vídeo no YouTube, garantindo que frames não sejam pulados, mesmo em redes móveis instáveis com perdas de 1-5%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Janelas Deslizantes para Controle de Fluxo",
                        "description": "A janela deslizante é um mecanismo que define o tamanho máximo de dados não confirmados (janela do remetente e receptora), permitindo controle de fluxo adaptativo e evitando sobrecarga do receptor com buffers limitados.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Descrever o funcionamento da janela deslizante",
                            "description": "Explicar os componentes da janela (esquerda: próximo a enviar; direita: próximo esperado pelo receptor) e como ela desliza com ACKs recebidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Números de Sequência e ACKs em TCP",
                                  "subSteps": [
                                    "Estude o conceito de números de sequência (sequence numbers) atribuídos a cada byte de dados enviado pelo remetente.",
                                    "Aprenda sobre ACKs (acknowledgments) cumulativos enviados pelo receptor para confirmar recebimento.",
                                    "Revise como os ACKs indicam o próximo byte esperado pelo receptor.",
                                    "Desenhe um diagrama simples de envio de dados com números de sequência e ACKs correspondentes.",
                                    "Compare ACKs individuais vs. cumulativos em termos de eficiência."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como um ACK cumulativo confirma múltiplos bytes de uma vez.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de TCP sequence numbers (online ou livro de redes)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Use números pequenos (ex: 1-10) para simular e evitar confusão com wrap-around.",
                                  "learningObjective": "Compreender o papel dos números de sequência e ACKs como base para a janela deslizante.",
                                  "commonMistakes": [
                                    "Confundir ACK com número de sequência do remetente",
                                    "Ignorar que ACKs são cumulativos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os Componentes da Janela Deslizante",
                                  "subSteps": [
                                    "Defina a janela deslizante como um intervalo de bytes permitidos para envio pelo remetente.",
                                    "Identifique o ponteiro esquerdo: representa o próximo byte a ser enviado (SND.NXT).",
                                    "Identifique o ponteiro direito: representa o próximo byte esperado pelo receptor (baseado no tamanho da janela reportado).",
                                    "Desenhe a janela mostrando esquerda (próximo a enviar) e direita (limite permitido).",
                                    "Explique como o receptor reporta o tamanho da janela via campo Window no cabeçalho TCP."
                                  ],
                                  "verification": "Desenhe e rotule uma janela com ponteiros esquerdo e direito, indicando valores exemplo (ex: esquerda=1001, direita=2001).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cabeçalho TCP diagramado (RFC 793 ou Wireshark screenshot)",
                                    "Ferramenta de desenho digital ou papel"
                                  ],
                                  "tips": "Visualize a janela como uma 'janela de oportunidade' que limita o envio para evitar sobrecarga.",
                                  "learningObjective": "Dominar os componentes visuais e funcionais da janela deslizante no contexto do remetente.",
                                  "commonMistakes": [
                                    "Trocar ponteiro esquerdo com direito",
                                    "Confundir tamanho da janela com números de sequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Mecanismo de Deslizamento da Janela com ACKs",
                                  "subSteps": [
                                    "Descreva como o remetente envia dados dentro da janela atual.",
                                    "Explique que ao receber um ACK, o ponteiro esquerdo avança para o valor do ACK + 1 (confirmando bytes anteriores).",
                                    "Mostre como o deslizamento permite novos envios até o ponteiro direito.",
                                    "Discuta o que acontece se a janela encolhe (zero window) ou cresce com atualizações do receptor.",
                                    "Simule um ciclo: envio → ACK → deslize → novo envio."
                                  ],
                                  "verification": "Simule em papel: envie bytes 1001-1050, receba ACK=1051, avance esquerda para 1051.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador TCP online (ex: TCP window slider tool)",
                                    "Sequência de números em tabela"
                                  ],
                                  "tips": "Pense no deslizamento como remover 'blocos confirmados' da esquerda, adicionando espaço novo.",
                                  "learningObjective": "Compreender dinamicamente como ACKs causam o movimento da janela para controle de fluxo.",
                                  "commonMistakes": [
                                    "Achar que ACKs movem o ponteiro direito",
                                    "Esquecer atualizações de tamanho da janela"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Janela Deslizante ao Controle de Fluxo Geral",
                                  "subSteps": [
                                    "Relacione a janela ao controle de fluxo: evita sobrecarregar o buffer do receptor.",
                                    "Compare com Go-Back-N ou Selective Repeat para contexto.",
                                    "Descreva cenários de janela cheia (bloqueio de envio) e recuperação.",
                                    "Revise o papel conjunto com controle de congestão (ex: slow start).",
                                    "Crie um fluxograma do ciclo completo de janela deslizante."
                                  ],
                                  "verification": "Crie um fluxograma mostrando envio, ACK, deslize e condição de janela zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 793 (TCP spec)",
                                    "Vídeo tutorial sobre TCP flow control"
                                  ],
                                  "tips": "Analogia: fila de supermercado onde ACK libera espaço para novos clientes.",
                                  "learningObjective": "Conectar a janela deslizante ao propósito maior de confiabilidade e eficiência em TCP.",
                                  "commonMistakes": [
                                    "Confundir controle de fluxo com controle de congestão",
                                    "Ignorar impacto de perdas de pacotes"
                                  ]
                                }
                              ],
                              "practicalExample": "Imagine um servidor web enviando uma página HTML de 5000 bytes para um navegador. Inicialmente, janela: esquerda=1 (próximo a enviar), direita=1501 (tamanho 1500). Servidor envia bytes 1-1000. Receptor ACK=1001 (confirma 1-1000), esquerda desliza para 1001, permitindo envio de 1001-2000. Se ACKs atrasarem, servidor para em direita=1501 até novo ACK ou window update.",
                              "finalVerifications": [
                                "Desenhe corretamente uma janela inicial e após 3 ACKs.",
                                "Explique verbalmente o que cada ponteiro representa.",
                                "Simule um cenário com janela zero e recuperação.",
                                "Identifique em um trace Wireshark os campos sequence, ACK e Window.",
                                "Compare antes/depois de um deslizamento em termos de bytes pendentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ponteiros esquerdo e direito (100%).",
                                "Correta descrição do mecanismo de deslizamento com ACKs cumulativos.",
                                "Uso de exemplos numéricos coerentes sem erros de wrap-around.",
                                "Integração clara com controle de fluxo (evitar buffer overflow).",
                                "Diagrama visual claro e rotulado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular (32-bit sequence space wrap-around).",
                                "Algoritmos e Estruturas de Dados: Buffers circulares e filas deslizantes.",
                                "Física: Analogias de fluxo de fluidos em tubos com capacidade limitada."
                              ],
                              "realWorldApplication": "Em downloads de arquivos grandes (ex: Netflix streaming), a janela deslizante otimiza a taxa de transferência, prevenindo perda de dados por buffer cheio no cliente, garantindo eficiência na internet global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1",
                              "10.1.4.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Calcular o tamanho e avanço da janela",
                            "description": "Calcular o espaço disponível na janela deslizante baseado em anúncios de janela (window size) e números de sequência/ACK, simulando envios em burst.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Componentes Básicos da Janela Deslizante no TCP",
                                  "subSteps": [
                                    "Revise os conceitos de número de sequência (SEQ), número de ACK e tamanho de janela (window size) anunciado pelo receptor.",
                                    "Identifique o left edge da janela do remetente (próximo SEQ a enviar) e do receptor (último ACK + 1).",
                                    "Aprenda a fórmula básica: Espaço disponível = Window Size - (Next SEQ - Left Edge).",
                                    "Desenhe um diagrama simples da janela deslizante com SEQ e ACK marcados.",
                                    "Pratique identificando o estado inicial da janela em um exemplo dado."
                                  ],
                                  "verification": "Desenhe corretamente um diagrama da janela com SEQ=1000, ACK=800, Window=500, identificando left edge=800 e espaço=500.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou ferramenta de desenho digital (ex: Draw.io), documentação TCP RFC 793.",
                                  "tips": "Use números pequenos inicialmente para visualizar melhor o diagrama.",
                                  "learningObjective": "Compreender os elementos fundamentais que definem o tamanho e posição da janela deslizante.",
                                  "commonMistakes": "Confundir SEQ do remetente com ACK do receptor; ignorar que window size é anunciado pelo receptor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Espaço Disponível na Janela Inicial",
                                  "subSteps": [
                                    "Dado um estado inicial (Next SEQ, ACK recebido, Window anunciado), calcule o left edge = ACK.",
                                    "Calcule o right edge = left edge + Window Size.",
                                    "Determine espaço disponível = right edge - Next SEQ.",
                                    "Registre o resultado e verifique se Next SEQ está dentro da janela (espaço >= 0).",
                                    "Repita com 3 exemplos variados de valores."
                                  ],
                                  "verification": "Calcule corretamente para Next SEQ=1200, ACK=1000, Window=400 → Espaço=200.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou planilha Excel, exemplos impressos de estados TCP.",
                                  "tips": "Sempre subtraia Next SEQ do right edge para evitar erros de sinal.",
                                  "learningObjective": "Dominar o cálculo preciso do espaço disponível na janela em estados iniciais.",
                                  "commonMistakes": "Usar SEQ em vez de ACK para left edge; esquecer de tratar overflow em números de 32 bits (use mod 2^32 se necessário)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular o Avanço da Janela com ACKs Recebidos",
                                  "subSteps": [
                                    "Ao receber um ACK, avance o left edge para ACK + 1.",
                                    "Recalcule o right edge = novo left edge + Window Size.",
                                    "Atualize Next SEQ após envios simulados e recalcule espaço disponível.",
                                    "Simule uma sequência de 4 ACKs progressivos e registre mudanças na janela.",
                                    "Verifique se bursts podem ser enviados até o right edge."
                                  ],
                                  "verification": "Simule: Inicial Next=1000, ACK=800, Win=500. Recebe ACK=950 → Novo left=951, espaço=500 - (1000-951)=451.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha para rastrear estados (colunas: SEQ, ACK, Win, Left, Right, Espaço), Wireshark trace exemplo (opcional).",
                                  "tips": "Mantenha uma tabela passo a passo para visualizar o deslize da janela.",
                                  "learningObjective": "Aplicar ACKs para avançar a janela e recalcular espaço dinamicamente.",
                                  "commonMistakes": "Não avançar Next SEQ após envios simulados; confundir window shrink com avanço normal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Cenários de Burst e Anúncios de Janela Variáveis",
                                  "subSteps": [
                                    "Simule um burst: Envie pacotes até preencher o espaço disponível, então espere ACK.",
                                    "Introduza mudança de window size em novos ACKs (ex: zero window ou aumento).",
                                    "Calcule quantos bytes podem ser enviados em burst dado estado atual.",
                                    "Registre impactos em throughput e lide com window=0 (parada).",
                                    "Teste com 2 cenários completos incluindo perdas simuladas."
                                  ],
                                  "verification": "Em burst: Espaço=300, envie 300 bytes → Next SEQ +=300, espaço=0 até ACK.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulador TCP online (ex: TCP Window Simulator) ou planilha avançada, traces Wireshark de sessões reais.",
                                  "tips": "Priorize cenários com window variável para praticar persistência probes.",
                                  "learningObjective": "Integrar cálculos em simulações realistas de tráfego TCP com bursts e variações.",
                                  "commonMistakes": "Ignorar que window=0 para envio; calcular burst além do right edge."
                                }
                              ],
                              "practicalExample": "Cenário: Servidor envia dados com Next SEQ=2000, recebe ACK=1500 com Window=1000. Espaço=1500+1000-2000=500. Envia burst de 500 bytes (Next=2500). Recebe ACK=2200 com Window=800 → Novo left=2201, right=3001, espaço=3001-2500=501. Simule avanço.",
                              "finalVerifications": [
                                "Calcule corretamente espaço disponível em 5 cenários variados sem erros.",
                                "Simule avanço da janela com sequência de 10 ACKs e bursts, registrando estados precisos.",
                                "Identifique e explique quando burst é possível (espaço > 0) vs. bloqueio (window=0).",
                                "Desenhe diagrama preciso de janela antes/depois de ACK e envio.",
                                "Preveja throughput aproximado baseado em window size e ACK frequency.",
                                "Lide com wrap-around de SEQ/ACK em números de 32 bits."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de left/right edge e espaço disponível (100% correto).",
                                "Compreensão conceitual demonstrada em simulações de burst e window shrink.",
                                "Qualidade dos diagramas e tabelas de rastreamento (clareza e completude).",
                                "Identificação correta de erros comuns e avoidance em exemplos.",
                                "Aplicação em cenários reais com variações de window (ex: zero window).",
                                "Explicação fluida dos impactos no controle de fluxo TCP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular para wrap-around de SEQ/ACK (teoria dos números).",
                                "Programação: Implementar lógica de janela em sockets TCP (Python socket library).",
                                "Física: Analogia com fluxo de tráfego em tubulações (controle de vazão).",
                                "Estatística: Calcular throughput médio baseado em histórico de windows.",
                                "Economia: Otimização de recursos em redes (alocação de banda como escassez)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de aplicações web, calcular janelas TCP otimiza uploads/downloads em conexões lentas, evitando timeouts; em troubleshooting de rede com Wireshark, diagnosticar lentidão por janelas pequenas; em data centers, tuning de stacks TCP para maximizar throughput em bursts de dados de big data."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Aplicar controle de fluxo com janelas zero",
                            "description": "Demonstrar como uma janela zero pausa o envio de dados até que o receptor libere buffer, prevenindo overflow em conexões assimétricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Controle de Fluxo e Janelas Deslizantes no TCP",
                                  "subSteps": [
                                    "Estude o header TCP e identifique o campo 'window' (rwnd - receiver window).",
                                    "Explique como as janelas deslizantes permitem envio de múltiplos segmentos sem ACK individual.",
                                    "Diferencie controle de fluxo (baseado em buffer do receptor) de controle de congestão.",
                                    "Desenhe um diagrama simples de uma janela deslizante em operação normal.",
                                    "Analise o papel dos ACKs cumulativos na atualização da janela."
                                  ],
                                  "verification": "Desenhe e explique um diagrama de janela deslizante com pelo menos 4 segmentos enviados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação RFC 793 (TCP)",
                                    "Ferramenta de desenho como Draw.io",
                                    "Vídeo sobre TCP no YouTube"
                                  ],
                                  "tips": "Lembre-se: rwnd é anunciado pelo receptor em cada ACK para refletir espaço disponível no buffer.",
                                  "learningObjective": "Compreender os mecanismos básicos de janelas deslizantes para controle de fluxo no TCP.",
                                  "commonMistakes": [
                                    "Confundir rwnd com cwnd (janela de congestão do remetente)",
                                    "Ignorar que ACKs são cumulativos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Mecanismo da Janela Zero (Zero Window)",
                                  "subSteps": [
                                    "Descreva o que significa rwnd = 0 no ACK do receptor.",
                                    "Explique como o remetente reage ao receber uma janela zero: para de enviar dados.",
                                    "Detalhe o processo de 'persistência': envio de sondas (probes) para verificar liberação do buffer.",
                                    "Analise o timer de persistência e intervalos de sondagem (exponencial inicial).",
                                    "Compare com persistência zero window vs. retransmissão de dados."
                                  ],
                                  "verification": "Escreva uma sequência de eventos quando rwnd vai para zero e depois é liberado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 1122 (Requisitos TCP)",
                                    "Wireshark para captura de pacotes TCP",
                                    "Artigo sobre Zero Window Probes"
                                  ],
                                  "tips": "A janela zero previne overflow, mas requer sondas para detectar quando o buffer é liberado.",
                                  "learningObjective": "Dominar o comportamento exato da janela zero e probes de persistência.",
                                  "commonMistakes": [
                                    "Achar que janela zero causa timeout imediato",
                                    "Esquecer das sondas de persistência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular uma Conexão Assimétrica com Janela Zero",
                                  "subSteps": [
                                    "Configure um ambiente de simulação (ex: ns-3, Mininet ou código Python com sockets).",
                                    "Crie um receptor com buffer limitado que processa dados lentamente.",
                                    "Inicie envio de dados rápidos do remetente e observe o receptor anunciar rwnd=0.",
                                    "Monitore o tráfego com Wireshark: identifique ACK com window=0 e probes subsequentes.",
                                    "Ajuste o buffer para simular liberação e observe reabertura da janela."
                                  ],
                                  "verification": "Capture e anote um trace Wireshark mostrando transição para janela zero e recuperação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Python sockets ou ns-3 simulator",
                                    "Dois computadores ou VM para cliente/servidor"
                                  ],
                                  "tips": "Use netcat (nc) para testes rápidos: receptor lento com pipe para simular buffer.",
                                  "learningObjective": "Aplicar praticamente o controle de fluxo em cenários assimétricos.",
                                  "commonMistakes": [
                                    "Não configurar buffer corretamente no SO",
                                    "Ignorar filtros Wireshark para TCP window"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Aplicar em Cenários de Produção",
                                  "subSteps": [
                                    "Identifique cenários reais de conexões assimétricas (ex: mobile lento vs. servidor rápido).",
                                    "Calcule impacto: tempo de pausa devido a janela zero em uma transferência de 1GB.",
                                    "Discuta otimizações: tuning de buffers SO (sysctl net.ipv4.tcp_rmem).",
                                    "Compare com protocolos alternativos como QUIC que evitam zero windows.",
                                    "Crie um diagrama de timing para um ciclo completo de zero window."
                                  ],
                                  "verification": "Resolva um problema hipotético: 'Receptor com 64KB buffer, dados chegam a 100Mbps, processamento 1Mbps'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou planilha para simulações matemáticas",
                                    "Documentação kernel Linux TCP tuning"
                                  ],
                                  "tips": "Formula: tempo para encher buffer = tamanho_buffer / throughput_diferença.",
                                  "learningObjective": "Avaliar e otimizar controle de fluxo com janelas zero em contextos reais.",
                                  "commonMistakes": [
                                    "Subestimar overhead das sondas de persistência",
                                    "Confundir com deadlocks em bidirecional zero window"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor web recebendo upload de vídeo de um cliente mobile com buffer pequeno (64KB) e processamento lento (devido a CPU limitada). O cliente envia dados a 10Mbps, mas o servidor processa a 1Mbps. Após encher o buffer, o servidor envia ACK com rwnd=0, pausando o cliente. Sondagens periódicas detectam liberação do buffer (após compressão do vídeo), reabrindo a janela para 128KB, permitindo continuidade sem perda de pacotes.",
                              "finalVerifications": [
                                "Explicar verbalmente o que rwnd=0 significa e seu impacto no remetente.",
                                "Identificar em um trace Wireshark um ACK com window=0 e probes subsequentes.",
                                "Calcular tempo aproximado para encher um buffer de 64KB com diferença de 9Mbps.",
                                "Desenhar sequência de pacotes em uma conexão com zero window.",
                                "Diferenciar zero window de zero window syndrome (deadlock bidirecional).",
                                "Configurar buffers em sockets para simular o cenário."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre rwnd, cwnd e probes (90%+ acerto).",
                                "Habilidade prática: Sucesso em simulação com Wireshark ou sockets (trace válido).",
                                "Análise quantitativa: Cálculos corretos de tempos e tamanhos de buffer.",
                                "Criatividade: Aplicação em cenários reais além do exemplo dado.",
                                "Comunicação: Diagramas claros e explicações concisas.",
                                "Profundidade: Menção a RFCs e otimizações SO."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos de filas M/M/1 para buffers e Little's Law (L = λW).",
                                "Sistemas Operacionais: Gerenciamento de buffers kernel e syscalls setsockopt.",
                                "Física: Analogia com fluxo de tráfego e semáforos para prevenir congestionamentos.",
                                "Engenharia de Software: Design de APIs assíncronas para evitar bloqueios semelhantes."
                              ],
                              "realWorldApplication": "Em aplicações IoT, como sensores enviando dados contínuos para gateways com memória limitada, prevenindo perda de dados críticos; em streaming de vídeo adaptativo (Netflix), onde buffers variáveis usam zero windows para pausar downloads durante picos de processamento; ou em VoIP (Zoom), garantindo áudio sem overflow em conexões assimétricas 5G."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.4",
                            "name": "Integrar janelas com retransmissão de perdas",
                            "description": "Simular uma sequência completa: envio com janela, perda detectada por ACKs, retransmissão e ajuste da janela para manter confiabilidade e fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Janela Deslizante Inicial e Envio de Pacotes",
                                  "subSteps": [
                                    "Defina o tamanho inicial da janela deslizante (ex: 4 pacotes).",
                                    "Numere os pacotes sequencialmente a partir de uma sequência inicial (ex: seq=0).",
                                    "Envie os primeiros pacotes dentro da janela para o receptor.",
                                    "Registre o estado da janela: próximo a enviar e próximo esperado ACK.",
                                    "Aguarde ACKs cumulativos ou individuais."
                                  ],
                                  "verification": "Verifique se os primeiros pacotes foram enviados corretamente e o estado da janela foi anotado em um diagrama ou log.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Simulador TCP simples (ex: Python socket ou ns-3)",
                                    "Documentação TCP RFC 793"
                                  ],
                                  "tips": "Desenhe um diagrama de timeline para visualizar envios e ACKs esperados.",
                                  "learningObjective": "Entender como a janela inicial permite envio eficiente sem sobrecarregar o receptor.",
                                  "commonMistakes": "Confundir sequência de pacotes com número da janela; ignorar ACKs cumulativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular Perda de Pacote e Detectar via ACKs",
                                  "subSteps": [
                                    "Introduza perda artificial em um pacote dentro da janela (ex: pacote seq=2 perdido).",
                                    "Simule ACKs do receptor: envie ACK para pacotes recebidos até o perdido.",
                                    "No emissor, detecte perda por timeout ou ACK duplicado (triple duplicate ACK).",
                                    "Registre o número de ACKs duplicados ou tempo de timeout.",
                                    "Atualize o estado da janela para refletir pacotes pendentes."
                                  ],
                                  "verification": "Confirme detecção de perda por log de ACKs duplicados ou timeout disparado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador ou script Python com perda randômica",
                                    "Cronômetro para timeout",
                                    "Diagrama de rede"
                                  ],
                                  "tips": "Use probabilidade baixa de perda (5-10%) para simulações realistas.",
                                  "learningObjective": "Compreender mecanismos de detecção de perda no TCP (timeout e fast retransmit).",
                                  "commonMistakes": "Não diferenciar ACK cumulativo de duplicado; ignorar RTO (Retransmission Timeout)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Retransmissão dos Pacotes Perdidos",
                                  "subSteps": [
                                    "Retransmita o pacote perdido mais antigo (base da janela).",
                                    "Continue enviando novos pacotes se a janela permitir (evite head-of-line blocking).",
                                    "Aguarde ACK confirmando recebimento do retransmitido.",
                                    "Atualize ponteiros da janela após ACK válido.",
                                    "Registre métricas: RTT do pacote retransmitido."
                                  ],
                                  "verification": "Verifique se o pacote perdido foi retransmitido e ACK recebido, avançando a janela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de simulação com logs de retransmissão",
                                    "Wireshark para captura real (opcional)"
                                  ],
                                  "tips": "Monitore congestion window (cwnd) para evitar colapso desnecessário.",
                                  "learningObjective": "Dominar o processo de retransmissão seletiva e impacto no fluxo.",
                                  "commonMistakes": "Retransmitir todos os pacotes em vez de seletivo; não ajustar timers pós-retransmissão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar Janela e Concluir Transferência Confiável",
                                  "subSteps": [
                                    "Ajuste o tamanho da janela baseada em ACKs (aumente se fluxo bom, reduza se perdas).",
                                    "Continue enviando até todos os dados serem ACKed (FIN/ACK para fechamento).",
                                    "Calcule throughput efetivo: dados entregues / tempo total.",
                                    "Analise impacto da perda no desempenho geral.",
                                    "Documente lições para otimização futura."
                                  ],
                                  "verification": "Simulação completa com todos pacotes entregues e janela zerada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha para cálculo de throughput",
                                    "Gráficos de simulação"
                                  ],
                                  "tips": "Implemente slow-start se múltiplas perdas ocorrerem.",
                                  "learningObjective": "Integrar controle de fluxo e confiabilidade para transferência end-to-end.",
                                  "commonMistakes": "Não fechar conexão corretamente; ignorar ajuste dinâmico da janela."
                                }
                              ],
                              "practicalExample": "Simule download de um arquivo de 1MB via TCP onde 10% dos pacotes se perdem: envie janela de 4 pacotes, detecte perda no pacote 5 via 3 ACKs duplicados, retransmita e ajuste janela para 3, completando o download em ~2x o tempo sem perdas.",
                              "finalVerifications": [
                                "Todos pacotes foram entregues em ordem via ACKs cumulativos.",
                                "Perdas foram detectadas e retransmitidas corretamente.",
                                "Janela deslizou adequadamente sem overflow/underflow.",
                                "Throughput calculado reflete impacto das perdas.",
                                "Conexão fechada com FIN/ACK sem dados pendentes.",
                                "Logs/diagramas mostram sequência completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção e retransmissão (sem falsos positivos).",
                                "Correto ajuste dinâmico da janela (aumento/redução).",
                                "Eficiência: minimização de timeouts desnecessários.",
                                "Análise quantitativa de métricas (RTT, throughput).",
                                "Clareza em diagramas e explicações.",
                                "Tratamento de edge cases como perdas consecutivas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos probabilísticos de perda de pacotes (distribuição binomial).",
                                "Física: Analogia com transmissão de sinais e ruído em canais.",
                                "Estatística: Análise de throughput e variância em simulações.",
                                "Programação: Implementação em Python sockets ou C.",
                                "Economia: Otimização de recursos em redes compartilhadas."
                              ],
                              "realWorldApplication": "No TCP/IP da internet, essa integração garante downloads confiáveis de sites/arquivos (ex: Netflix streaming ajusta janelas em redes móveis com perdas, evitando rebuffering)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.3",
                              "10.1.4.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Nível de Rede",
                "description": "Cobre plano de dados, plano de controle com Redes Definidas por Software (SDN), algoritmos de roteamento e protocolo IP.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Plano de Dados",
                    "description": "Estrutura responsável pelo encaminhamento de pacotes no nível de rede, sem estado centralizado.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Definição e Responsabilidades do Plano de Dados",
                        "description": "O plano de dados é a estrutura distribuída no nível de rede responsável pelo encaminhamento stateless de pacotes, sem manutenção de estado centralizado, atuando de forma reativa com base em tabelas locais de roteamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Identificar o papel do plano de dados no modelo TCP/IP",
                            "description": "Explicar como o plano de dados opera no nível de rede para encaminhar pacotes de forma independente, sem coordenação central, contrastando com arquiteturas tradicionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral do modelo TCP/IP",
                                  "subSteps": [
                                    "Estude os quatro níveis principais do modelo TCP/IP: Aplicação, Transporte, Rede e Enlace.",
                                    "Identifique que o nível de Rede é responsável pelo roteamento e encaminhamento de pacotes entre redes.",
                                    "Revise diagramas do modelo TCP/IP para visualizar a posição do plano de dados.",
                                    "Anote as funções principais de cada nível para contextualizar o plano de dados.",
                                    "Compare brevemente com o modelo OSI para destacar semelhanças."
                                  ],
                                  "verification": "Desenhe um diagrama do modelo TCP/IP e rotule corretamente o nível de Rede.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama do modelo TCP/IP (impresso ou digital), caneta e papel.",
                                  "tips": "Use cores diferentes para cada nível para facilitar a memorização visual.",
                                  "learningObjective": "Entender a posição hierárquica do plano de dados no modelo TCP/IP.",
                                  "commonMistakes": "Confundir o modelo TCP/IP com o OSI, ignorando que TCP/IP tem 4 níveis em vez de 7."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o papel do plano de dados no nível de Rede",
                                  "subSteps": [
                                    "Defina o plano de dados como o conjunto de protocolos (ex: IP) que gerencia o encaminhamento de pacotes.",
                                    "Explique que pacotes são unidades independentes com endereços de origem e destino.",
                                    "Descreva como roteadores usam tabelas de roteamento para decidir o próximo salto.",
                                    "Simule mentalmente o fluxo: envio, roteamento e entrega sem estado centralizado.",
                                    "Liste protocolos chave: IP, ICMP, ARP."
                                  ],
                                  "verification": "Liste 3 funções principais do plano de dados e explique uma em suas palavras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Vídeo tutorial sobre IP (YouTube ou Khan Academy), notas de aula.",
                                  "tips": "Pense em pacotes como cartas no correio: cada uma viaja sozinha sem coordenar com outras.",
                                  "learningObjective": "Identificar as responsabilidades específicas do plano de dados no encaminhamento.",
                                  "commonMistakes": "Achar que o plano de dados mantém conexão contínua, confundindo com nível de Transporte."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o encaminhamento independente e descentralizado",
                                  "subSteps": [
                                    "Discuta a natureza 'best-effort' e sem conexão do IP: pacotes podem tomar rotas diferentes.",
                                    "Explique a ausência de coordenação central: cada roteador decide localmente.",
                                    "Simule cenários de falha: se um caminho falha, pacotes usam rotas alternativas automaticamente.",
                                    "Calcule um exemplo simples de hops em uma rede com 3 roteadores.",
                                    "Destaque benefícios: escalabilidade e resiliência."
                                  ],
                                  "verification": "Descreva o que acontece se um roteador falha em uma rede IP.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Simulador de rede online (ex: Cisco Packet Tracer gratuito), papel para diagramas.",
                                  "tips": "Visualize pacotes como formigas em um formigueiro: cada uma segue feromônios locais.",
                                  "learningObjective": "Compreender o mecanismo descentralizado de encaminhamento de pacotes.",
                                  "commonMistakes": "Imaginar roteamento como uma linha reta fixa, ignorando rotas dinâmicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com arquiteturas tradicionais centralizadas",
                                  "subSteps": [
                                    "Descreva arquiteturas tradicionais (ex: X.25): controle centralizado e circuitos virtuais.",
                                    "Compare: TCP/IP (datagramas independentes) vs. tradicional (conexões estabelecidas previamente).",
                                    "Liste vantagens do TCP/IP: flexibilidade, custo baixo, escalabilidade.",
                                    "Discuta desvantagens: perda de pacotes possível, necessidade de retransmissão no nível superior.",
                                    "Crie uma tabela de comparação com 4-5 critérios."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e explique uma vantagem chave do TCP/IP.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Tabela em branco (Excel ou papel), artigos sobre X.25 vs. IP.",
                                  "tips": "Use analogias: TCP/IP como estrada pública vs. tradicional como telefonema reservado.",
                                  "learningObjective": "Diferenciar o plano de dados TCP/IP de abordagens centralizadas.",
                                  "commonMistakes": "Subestimar as diferenças, achando que ambos são 'semelhantes' em roteamento."
                                }
                              ],
                              "practicalExample": "Em uma rede doméstica, ao acessar um site, seu pacote de requisição é fragmentado em datagramas IP independentes. Cada roteador (ISP, backbone) os encaminha baseado em tabelas locais sem saber do pacote completo, chegando ao servidor via rotas possivelmente diferentes, demonstrando encaminhamento descentralizado.",
                              "finalVerifications": [
                                "Explicar verbalmente o papel do plano de dados em 1 minuto.",
                                "Desenhar fluxo de pacotes em uma rede com 3 nós.",
                                "Identificar corretamente IP como protocolo do plano de dados.",
                                "Comparar TCP/IP vs. X.25 em 3 pontos chave.",
                                "Simular encaminhamento em ferramenta como Packet Tracer.",
                                "Responder quiz de 5 perguntas sobre descentralização."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do nível de Rede e plano de dados (30%)",
                                "Clareza no conceito de pacotes independentes (25%)",
                                "Correta distinção de encaminhamento descentralizado (20%)",
                                "Comparação válida com arquiteturas tradicionais (15%)",
                                "Uso de exemplos ou diagramas relevantes (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para modelar rotas e algoritmos de roteamento (ex: Dijkstra).",
                                "Física: Propagação de sinais em redes como ondas eletromagnéticas.",
                                "História: Evolução das redes desde ARPANET até Internet moderna.",
                                "Economia: Impacto da escalabilidade TCP/IP no custo de infraestrutura global."
                              ],
                              "realWorldApplication": "Na Internet global, roteadores de provedores como Google ou Verizon usam o plano de dados IP para encaminhar bilhões de pacotes independentes diariamente, permitindo streaming de vídeo resiliente a falhas, como no Netflix, onde pacotes perdidos são retransmitidos sem interromper o fluxo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Descrever o conceito de encaminhamento stateless",
                            "description": "Detalhar como switches e roteadores no plano de dados tomam decisões de forwarding baseadas apenas no cabeçalho do pacote e em tabelas pré-configuradas, sem armazenar estado de conexões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do Encaminhamento no Plano de Dados",
                                  "subSteps": [
                                    "Revise o papel do plano de dados em switches e roteadores: processar pacotes independentemente.",
                                    "Identifique que o encaminhamento (forwarding) é a decisão de onde enviar o pacote com base em seu destino.",
                                    "Diferencie plano de dados (rápido, por pacote) do plano de controle (configuração de rotas).",
                                    "Estude exemplos básicos de cabeçalhos IP: endereço IP de origem e destino.",
                                    "Desenhe um diagrama simples de um pacote atravessando um roteador."
                                  ],
                                  "verification": "Crie um diagrama rotulado mostrando o fluxo de um pacote em um roteador e explique verbalmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama em papel ou ferramenta como Draw.io; vídeo introdutório sobre plano de dados (ex: Cisco Networking Basics).",
                                  "tips": "Foquem em visualizações; use setas para mostrar decisões de forwarding.",
                                  "learningObjective": "Compreender o contexto do encaminhamento no plano de dados.",
                                  "commonMistakes": "Confundir plano de dados com plano de controle; assumir que roteadores 'lembram' pacotes anteriores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Stateful e Stateless Forwarding",
                                  "subSteps": [
                                    "Defina stateless: decisões baseadas apenas no pacote atual, sem memória de conexões prévias.",
                                    "Defina stateful: mantém tabela de estado (ex: conexões TCP ativas em firewalls).",
                                    "Compare: stateless é mais simples e escalável; stateful é para controle de fluxo.",
                                    "Liste cenários: switches L2 usam MAC tables (stateless por tabela), roteadores IP usam tabelas de roteamento.",
                                    "Analise um exemplo: pacote A e B com mesmo destino são tratados independentemente."
                                  ],
                                  "verification": "Escreva uma tabela comparativa com 3 diferenças chave entre stateless e stateful.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela em spreadsheet ou papel; recurso online como Khan Academy ou Wikipedia sobre packet forwarding.",
                                  "tips": "Use analogia: stateless como correio olhando só o endereço; stateful como porteiro checando visitas anteriores.",
                                  "learningObjective": "Distinguir stateless de stateful para contextualizar o conceito.",
                                  "commonMistakes": "Achar que todos os roteadores são stateful; ignorar que stateless é padrão na Internet core."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Mecanismo de Decisão Stateless",
                                  "subSteps": [
                                    "Examine componentes: cabeçalho do pacote (IP destino) + tabelas pré-configuradas (FIB/RIB em roteadores).",
                                    "Descreva lookup: roteador consulta tabela de roteamento com IP destino para próxima hop/interface.",
                                    "Simule processo: pacote chega → extrai IP dst → match na tabela → forward ou drop.",
                                    "Discuta switches: usa MAC table (ARP cache) para L2 forwarding, também stateless.",
                                    "Note ausência de estado: cada pacote é autônomo, sem tracking de sequência."
                                  ],
                                  "verification": "Simule manualmente o forwarding de 2 pacotes fictícios usando uma tabela de roteamento impressa.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplo de tabela de roteamento (de tutoriais Cisco); Wireshark para capturar pacotes reais.",
                                  "tips": "Pratique lookups em tabelas reais via 'show ip route' em simulador como Packet Tracer.",
                                  "learningObjective": "Detalhar como decisões são tomadas sem estado.",
                                  "commonMistakes": "Confundir tabela de roteamento com estado de conexão; pensar que ARP é stateful."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens, Limitações e Exemplos Práticos",
                                  "subSteps": [
                                    "Liste vantagens: alta velocidade, escalabilidade em data centers, simplicidade.",
                                    "Discuta limitações: não detecta anomalias de conexão (ex: SYN flood precisa de stateful).",
                                    "Aplique a Internet: BGP + IP forwarding é stateless na core.",
                                    "Crie um fluxograma completo do processo stateless.",
                                    "Debata cenários: por que data centers usam switches stateless."
                                  ],
                                  "verification": "Explique em 1 minuto o conceito para um 'parceiro de estudo' e responda 3 perguntas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Packet Tracer ou GNS3 para simulação; fluxograma tool como Lucidchart.",
                                  "tips": "Grave sua explicação para autoavaliação de clareza.",
                                  "learningObjective": "Sintetizar o conceito com implicações reais.",
                                  "commonMistakes": "Superestimar stateless como 'perfeito'; ignorar que edge devices podem ser stateful."
                                }
                              ],
                              "practicalExample": "Em um switch Ethernet, um pacote com MAC destino 00:11:22:33:44:55 chega na porta 1. O switch consulta sua tabela CAM (pré-configurada via aprendizado ARP), encontra saída na porta 5, e encaminha imediatamente. Um segundo pacote idêntico é tratado da mesma forma, sem 'lembrar' o primeiro – puro stateless.",
                              "finalVerifications": [
                                "Explicar corretamente que stateless usa apenas cabeçalho e tabelas, sem estado de conexão.",
                                "Diferenciar stateless de stateful com pelo menos 2 exemplos precisos.",
                                "Simular forwarding de um pacote usando tabela de roteamento manual.",
                                "Identificar componentes chave: cabeçalho IP, FIB, próxima hop.",
                                "Descrever por que stateless é ideal para alto throughput em roteadores core.",
                                "Listar uma limitação: incapacidade de trackear fluxos sem hardware adicional."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição exata sem confusões com stateful (30%).",
                                "Detalhe técnico: menção a cabeçalhos, tabelas e lookup (25%).",
                                "Clareza na explicação: uso de analogias e diagramas (20%).",
                                "Exemplos relevantes: ligação a switches/roteadores reais (15%).",
                                "Compreensão de implicações: vantagens e limitações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de dados como tabelas hash e buscas O(1).",
                                "Segurança da Informação: Contraste com firewalls stateful para detecção de intrusões.",
                                "Engenharia de Software: Paralelismo e escalabilidade em sistemas distribuídos.",
                                "Física: Analogia com propagação de sinais em redes ópticas sem memória."
                              ],
                              "realWorldApplication": "Na espinha dorsal da Internet (ex: roteadores Cisco em ISPs), stateless forwarding permite processar trilhões de pacotes/segundo em data centers como os do Google, onde tabelas BGP são consultadas por pacote para roteamento global eficiente e de baixa latência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Listar as principais responsabilidades do plano de dados",
                            "description": "Enumerar funções como lookup de endereços IP, determinação de próxima salto (next-hop) e entrega de pacotes em redes IP, sem envolvimento em controle de fluxo ou roteamento dinâmico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Geral do Plano de Dados",
                                  "subSteps": [
                                    "Defina o plano de dados como a camada responsável pelo encaminhamento de pacotes em roteadores IP.",
                                    "Diferencie plano de dados (forwarding) do plano de controle (cálculo de rotas).",
                                    "Identifique que o plano de dados usa tabelas estáticas pré-populadas.",
                                    "Liste exemplos de hardware que implementam o plano de dados, como ASICs em roteadores.",
                                    "Revise o fluxo básico: entrada de pacote → processamento → saída."
                                  ],
                                  "verification": "Escreva uma definição de 3 frases do plano de dados e sua distinção do plano de controle.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de roteador (plano de dados vs controle)",
                                    "Artigo sobre SDN (Software Defined Networking)"
                                  ],
                                  "tips": "Use analogia: plano de dados é como um carteiro seguindo um mapa fixo, sem planejar rotas novas.",
                                  "learningObjective": "Entender o papel exclusivo do plano de dados no forwarding de pacotes IP.",
                                  "commonMistakes": [
                                    "Confundir com plano de controle",
                                    "Achar que faz roteamento dinâmico",
                                    "Ignorar hardware dedicado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Lookup de Endereços IP",
                                  "subSteps": [
                                    "Explique o lookup como busca na tabela de roteamento pelo IP de destino do pacote.",
                                    "Descreva estruturas de dados usadas: tabelas de forwarding com prefixos CIDR.",
                                    "Simule um lookup: pacote para 10.0.0.1 consulta tabela e encontra match mais longo.",
                                    "Discuta Longest Prefix Match (LPM) como algoritmo chave.",
                                    "Pratique com exemplo: tabela com entradas 10.0.0.0/8 → next-hop A."
                                  ],
                                  "verification": "Realize um lookup manual em uma tabela fictícia e anote o resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de roteamento exemplo em papel ou Excel",
                                    "Ferramenta online como IP calculator"
                                  ],
                                  "tips": "Sempre priorize o prefixo mais longo para matches precisos.",
                                  "learningObjective": "Dominar o processo de busca por IP de destino na tabela de forwarding.",
                                  "commonMistakes": [
                                    "Usar match exato em vez de prefixo",
                                    "Ignorar máscaras de sub-rede",
                                    "Confundir IP origem com destino"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Determinação do Next-Hop",
                                  "subSteps": [
                                    "Defina next-hop como o próximo roteador ou host no caminho do pacote.",
                                    "Extraia do resultado do lookup: IP next-hop e interface de saída.",
                                    "Descreva reescrita do cabeçalho: alterar MAC de destino para next-hop.",
                                    "Simule: lookup retorna next-hop 192.168.1.2 via eth1.",
                                    "Verifique ARP para resolver MAC do next-hop se necessário."
                                  ],
                                  "verification": "Desenhe o fluxo de um pacote incluindo next-hop e interface.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de rede com 3 roteadores",
                                    "Comando 'show ip route' de Cisco (simulação)"
                                  ],
                                  "tips": "Lembre: next-hop é determinado estaticamente pela tabela, não calculado em tempo real.",
                                  "learningObjective": "Compreender como o plano de dados seleciona o próximo salto.",
                                  "commonMistakes": [
                                    "Confundir next-hop com destino final",
                                    "Esquecer reescrita de L2",
                                    "Misturar com roteamento dinâmico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender a Entrega de Pacotes e Limitações",
                                  "subSteps": [
                                    "Descreva a entrega: enfileirar pacote na interface de saída e transmitir.",
                                    "Liste o que NÃO faz: sem controle de fluxo (TCP), sem roteamento dinâmico (OSPF).",
                                    "Simule ciclo completo: receive → lookup → next-hop → send.",
                                    "Discuta escalabilidade: milhões de pacotes/segundo via hardware.",
                                    "Revise lista final: lookup IP, next-hop, entrega."
                                  ],
                                  "verification": "Liste as 3 responsabilidades principais e 2 exclusões em uma tabela.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Vídeo curto sobre packet forwarding (YouTube)",
                                    "Quiz online sobre data plane"
                                  ],
                                  "tips": "Foco em stateless: cada pacote é processado independentemente.",
                                  "learningObjective": "Consolidar responsabilidades e delimitações do plano de dados.",
                                  "commonMistakes": [
                                    "Incluir funções de L4 como controle de fluxo",
                                    "Achar que persiste estado de conexão",
                                    "Subestimar velocidade requerida"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um roteador doméstico, um pacote de um PC (192.168.1.10) para Google (8.8.8.8) chega: 1) Lookup na tabela encontra next-hop 192.168.1.1 via WAN; 2) Determina MAC via ARP; 3) Reencapsula e envia para o provedor, sem calcular rotas ou gerenciar congestionamento.",
                              "finalVerifications": [
                                "Liste corretamente as 3 principais responsabilidades: lookup IP, next-hop, entrega.",
                                "Explique sem erros o que o plano de dados NÃO faz (ex: roteamento dinâmico).",
                                "Simule um ciclo completo de forwarding com exemplo numérico.",
                                "Diferencie plano de dados de plano de controle em 2 pontos chave.",
                                "Identifique Longest Prefix Match em uma tabela de 3 entradas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na lista de responsabilidades (100% match com definição).",
                                "Clareza na distinção de funções excluídas.",
                                "Capacidade de simular lookup e next-hop com exemplos corretos.",
                                "Uso correto de terminologia (LPM, forwarding table, stateless).",
                                "Completude dos steps com sub-passos acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos de busca em árvores trie para LPM.",
                                "Programação: Implementar tabela de forwarding em Python ou C.",
                                "Física: Propagação de sinais elétricos em cabos Ethernet.",
                                "Segurança: Análise de pacotes com Wireshark para verificar forwarding."
                              ],
                              "realWorldApplication": "Em data centers da AWS ou roteadores backbone da Internet, o plano de dados processa trilhões de pacotes/dia, garantindo latência baixa sem intervenção de CPU para roteamento, essencial para streaming, cloud e IoT."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Mecanismos de Encaminhamento no Plano de Dados",
                        "description": "Processos e estruturas usadas pelo plano de dados para processar e encaminhar pacotes de alta velocidade, utilizando tabelas de forwarding e matching de regras.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Explicar o uso de tabelas de forwarding",
                            "description": "Descrever como as tabelas de forwarding (FIB - Forwarding Information Base) são populadas e consultadas para mapear endereços de destino a portas de saída em roteadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito e Propósito da Tabela de Forwarding (FIB)",
                                  "subSteps": [
                                    "Defina FIB como a Forwarding Information Base, uma tabela otimizada para encaminhamento rápido de pacotes.",
                                    "Diferencie FIB do RIB (Routing Information Base), que armazena rotas calculadas por protocolos de roteamento.",
                                    "Explique o papel da FIB no plano de dados: mapear prefixos de IP de destino para interfaces de saída e next-hops.",
                                    "Descreva a estrutura típica: colunas como prefixo de destino, máscara, next-hop IP, interface de saída e métrica.",
                                    "Discuta otimizações como uso de TCAM ou tries para lookups em O(1) ou log(n)."
                                  ],
                                  "verification": "Crie um diagrama manual da FIB com 3 entradas exemplo e rotule cada coluna corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Documentação Cisco 'show ip cef' ou similar"
                                  ],
                                  "tips": "Visualize a FIB como um 'mapa rápido' usado pelo hardware, não pelo software de roteamento.",
                                  "learningObjective": "Compreender a estrutura, propósito e diferenças da FIB em relação ao RIB.",
                                  "commonMistakes": [
                                    "Confundir FIB com tabela de roteamento completa (RIB)",
                                    "Ignorar otimizações de hardware como TCAM"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar a População da Tabela de Forwarding",
                                  "subSteps": [
                                    "Descreva como protocolos de roteamento (OSPF, BGP, RIP) atualizam o RIB com rotas aprendidas.",
                                    "Explique o processo de seleção da melhor rota no RIB usando algoritmos como shortest path ou policy-based.",
                                    "Detalhe a instalação: roteador software copia rotas selecionadas para FIB, otimizando para lookups.",
                                    "Aborde atualizações dinâmicas: adição/remoção de entradas via triggers de protocolo ou eventos de link.",
                                    "Mencione sincronização com hardware: push para line cards ou ASICs em roteadores de alto desempenho."
                                  ],
                                  "verification": "Liste 5 fontes de rotas (estáticas, OSPF, BGP etc.) e trace o caminho RIB -> FIB para uma delas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador como Packet Tracer ou GNS3",
                                    "Guia de comandos Cisco 'show ip route' vs 'show fib'"
                                  ],
                                  "tips": "Lembre-se: população é unidirecional; mudanças no RIB propagam para FIB, mas não o inverso.",
                                  "learningObjective": "Dominar os mecanismos de população e manutenção da FIB.",
                                  "commonMistakes": [
                                    "Achar que FIB é populada diretamente por protocolos",
                                    "Esquecer flushing de rotas inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a Consulta e Uso da FIB no Encaminhamento",
                                  "subSteps": [
                                    "Explique chegada de pacote: parsing do cabeçalho IP para extrair endereço de destino.",
                                    "Detalhe longest prefix match (LPM): busca na FIB pelo prefixo mais específico que combine.",
                                    "Descreva resultado: identificação de next-hop IP e porta/interface de saída.",
                                    "Aborde ações pós-lookup: rewrite de MAC (ARP se necessário), decremento TTL e forwarding.",
                                    "Discuta cenários especiais: rotas default, multipath (ECMP) e recursion para next-hop."
                                  ],
                                  "verification": "Simule um lookup com IP destino 192.168.1.100 em uma FIB exemplo e indique saída.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark para capturar pacotes",
                                    "Exemplos de saídas de 'show fib'"
                                  ],
                                  "tips": "Pratique LPM: 192.168.1.0/24 vence sobre 192.0.0.0/8 para 192.168.1.100.",
                                  "learningObjective": "Entender o processo de consulta rápida e decisão de forwarding via FIB.",
                                  "commonMistakes": [
                                    "Usar exact match em vez de LPM",
                                    "Ignorar recursion quando next-hop não é direto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Diagnosticar Problemas em Tabelas de Forwarding",
                                  "subSteps": [
                                    "Aprenda comandos chave: 'show ip cef' (FIB), 'show ip route' (RIB), 'debug ip cef'.",
                                    "Interprete saídas: identificar rotas missing, inconsistent ou blackholed.",
                                    "Teste conectividade: use ping/traceroute para validar forwarding real.",
                                    "Simule falhas: remova rotas e observe repopulação da FIB.",
                                    "Discuta escalabilidade: impactos de tabelas cheias em roteadores edge (BGP full routes)."
                                  ],
                                  "verification": "Execute comandos em simulador e explique discrepâncias entre RIB e FIB.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cisco Packet Tracer ou EVE-NG",
                                    "Referência de troubleshooting Cisco"
                                  ],
                                  "tips": "Sempre compare RIB e FIB; dessincronia causa blackholes.",
                                  "learningObjective": "Aplicar diagnósticos práticos para validar e corrigir uso da FIB.",
                                  "commonMistakes": [
                                    "Diagnosticar só RIB ignorando FIB",
                                    "Confundir saídas de comandos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa, roteador R1 recebe pacote destino 8.8.8.8/32 de host interno. FIB populada via BGP mostra prefixo 8.8.8.0/24 -> next-hop 10.0.0.1 porta GigabitEthernet0/1. LPM seleciona essa entrada, pacote é encaminhado após ARP para 10.0.0.1.",
                              "finalVerifications": [
                                "Pode diferenciar e diagramar FIB vs RIB com precisão.",
                                "Explica população completa de uma rota exemplo (fonte -> RIB -> FIB).",
                                "Simula lookup LPM corretamente para IPs variados.",
                                "Identifica e corrige problemas comuns em saídas de comandos.",
                                "Descreve impacto de falhas na FIB em conectividade de rede.",
                                "Integra conceitos em um fluxo end-to-end de pacote."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (diferenças FIB/RIB, LPM): 25%",
                                "Detalhe no processo de população e consulta: 25%",
                                "Capacidade de simulação e diagramação: 20%",
                                "Habilidade de troubleshooting com comandos: 15%",
                                "Clareza na explicação oral/escrita: 10%",
                                "Exemplos práticos e conexões reais: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos de busca (tries, LPM como prefix trees).",
                                "Algoritmos e Estruturas de Dados: Otimização de tabelas para O(1) lookups.",
                                "Segurança da Informação: Vulnerabilidades como route poisoning afetando FIB.",
                                "Física: Propagação de sinais elétricos/ópticos pelas portas de saída.",
                                "Gestão de Projetos: Escalabilidade em redes de grande porte (ISPs)."
                              ],
                              "realWorldApplication": "Em provedores de internet (ISPs), a FIB em roteadores core como Cisco ASR lida com milhões de prefixos BGP, encaminhando tráfego global com latência <1ms; falhas causam outages como o de 2021 no Facebook."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Analisar o processo de matching de pacotes",
                            "description": "Detalhar o pipeline de processamento em hardware (como em switches SDN) para matching de cabeçalhos IP e aplicação de ações como forward, drop ou modify.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura de cabeçalhos IP para matching",
                                  "subSteps": [
                                    "Identifique os campos principais do cabeçalho IPv4/IPv6: source/destination IP, protocol, ports (TCP/UDP).",
                                    "Analise o formato exato: versão, IHL, TOS, total length, identification, flags, fragment offset, TTL, checksum.",
                                    "Extraia exemplos de pacotes usando ferramentas como Wireshark para visualizar campos reais.",
                                    "Mapeie quais campos são comumente usados em regras de matching (ex: 5-tuple).",
                                    "Compare IPv4 vs IPv6 em termos de campos relevantes para SDN."
                                  ],
                                  "verification": "Desenhe um diagrama do cabeçalho IP destacando 5 campos chave para matching e liste seus tamanhos em bits.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação RFC 791/8200, Wireshark instalado, capturas de tráfego de exemplo.",
                                  "tips": "Foquem em campos de 32 bits ou menos para aceleração em hardware TCAM.",
                                  "learningObjective": "Identificar e descrever campos de cabeçalho IP usados em regras de fluxo SDN.",
                                  "commonMistakes": "Confundir source com destination IP; ignorar extensões IPv6 como flow label."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar tabelas de fluxo em switches SDN (OpenFlow)",
                                  "subSteps": [
                                    "Estude a especificação OpenFlow: match fields, priority, counters, actions.",
                                    "Descreva como tabelas de fluxo são organizadas (múltiplas tabelas em pipeline).",
                                    "Aprenda sobre wildcards e máscaras para matching parcial (ex: prefixo IP).",
                                    "Simule inserção de regras via controlador (ex: Ryu ou ONOS).",
                                    "Entenda lookup exato, LPM e TCAM para hardware matching."
                                  ],
                                  "verification": "Crie uma regra de fluxo simples em sintaxe OpenFlow e explique seu match pattern.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Especificação OpenFlow 1.5, Mininet ou emulador SDN, controlador Ryu.",
                                  "tips": "Priorize regras por número; use contadores para monitorar hits.",
                                  "learningObjective": "Explicar estrutura e operação de tabelas de fluxo em SDN.",
                                  "commonMistakes": "Esquecer que matching é de cima para baixo por priority; confundir match com action."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar o pipeline de processamento de pacotes em hardware",
                                  "subSteps": [
                                    "Descreva parsing inicial: deserialização do pacote em hardware (P4 ou ASIC).",
                                    "Explique lookup em TCAM/SRAM: comparação paralela de cabeçalhos com regras.",
                                    "Trace o fluxo: ingress port -> parser -> match table(s) -> action execution.",
                                    "Discuta next-table jumps e group tables para pipelines multi-etapa.",
                                    "Analise overhead: latência de pipeline vs throughput em Gbps."
                                  ],
                                  "verification": "Monte um fluxograma do pipeline desde chegada do pacote até egress.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Documentos de switches como Barefoot Tofino ou Cisco Nexus, P4 tutorials.",
                                  "tips": "Visualize com diagramas; lembre que hardware acelera exact-match mas LPM é mais lento.",
                                  "learningObjective": "Mapear o pipeline completo de matching em switches SDN.",
                                  "commonMistakes": "Ignorar parsing errors (ex: checksum fail); assumir matching sequencial em vez de paralelo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar ações pós-matching: forward, drop, modify",
                                  "subSteps": [
                                    "Liste ações básicas: output port, drop, set-field (ex: modificar TTL ou VLAN).",
                                    "Simule cenários: forward para porta específica, drop por ACL, modify QoS.",
                                    "Estude meters e groups para rate-limiting e load-balancing.",
                                    "Avalie impacto em performance: actions inline vs deferred.",
                                    "Teste em simulador: envie pacotes e observe ações aplicadas."
                                  ],
                                  "verification": "Implemente e teste 3 regras com ações diferentes em Mininet, capturando saídas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Mininet, Wireshark, controlador SDN com scripts Python.",
                                  "tips": "Use 'apply_actions' vs 'write_actions' para entender timing.",
                                  "learningObjective": "Descrever e aplicar ações baseadas em resultados de matching.",
                                  "commonMistakes": "Aplicar action sem match hit (fallback table-miss); overflow em modify fields."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e otimizar análise de matching",
                                  "subSteps": [
                                    "Combine steps anteriores: trace um pacote completo pelo pipeline.",
                                    "Otimize regras: reduzir TCAM usage com hashing ou exact-match tables.",
                                    "Monitore com counters: hits, bytes, packets para debugging.",
                                    "Discuta escalabilidade: milhares de regras em data centers.",
                                    "Avalie falhas: table-miss_flow, packet_in para controlador."
                                  ],
                                  "verification": "Analise um trace Wireshark de um fluxo SDN e identifique matching/actions aplicados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Traces SDN reais, ferramentas como ofctl ou ovs-ofctl.",
                                  "tips": "Sempre verifique contadores pós-teste para validar hits.",
                                  "learningObjective": "Otimizar e debugar processos de matching em cenários reais.",
                                  "commonMistakes": "Overfitting regras (太多 wildcards); ignorar table-miss handling."
                                }
                              ],
                              "practicalExample": "Em um switch SDN OpenFlow, um pacote IP com src=10.0.0.1:80 dst=192.168.1.1:443 é parsed; matcha regra priority=100 (match src=10.0.0.0/24, dst=192.168.1.0/24, tcp dst_port=443) -> action: set_queue(1), output(port=2). Se não match, table-miss envia packet_in ao controlador.",
                              "finalVerifications": [
                                "Diagramar pipeline de matching com parsing, lookup e actions.",
                                "Explicar TCAM vs SRAM em hardware matching.",
                                "Simular matching de um pacote IP em ferramenta SDN.",
                                "Identificar ações para forward/drop/modify em regra OpenFlow.",
                                "Analisar trace Wireshark com matching aplicado.",
                                "Otimizar uma tabela de fluxo para 1000 regras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de campos IP para matching (90% cobertura).",
                                "Correta representação do pipeline SDN (inclui parsing e actions).",
                                "Uso correto de sintaxe OpenFlow em exemplos (sem erros).",
                                "Profundidade em hardware: TCAM/LPM mencionado com trade-offs.",
                                "Capacidade de simulação/debug em Mininet (logs válidos).",
                                "Otimização proposta viável (redução TCAM >20%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar controlador SDN em Python (Ryu/POX).",
                                "Segurança: Regras de firewall baseadas em matching de pacotes.",
                                "Matemática: Algoritmos de hashing e Longest Prefix Matching (LPM).",
                                "Engenharia de Software: Modelagem de pipelines em P4.",
                                "Análise de Dados: Monitoramento de counters para ML em tráfego."
                              ],
                              "realWorldApplication": "Em data centers AWS/Google Cloud, switches SDN como Arista ou Cisco usam matching para roteamento dinâmico, load-balancing e DDoS mitigation, processando terabits/segundo com latência <1us."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Comparar encaminhamento em roteadores tradicionais vs. SDN",
                            "description": "Contrastar o forwarding distribuído e stateless no plano de dados tradicional com o controle centralizado em SDN, destacando limitações de escalabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o encaminhamento em roteadores tradicionais",
                                  "subSteps": [
                                    "Estude a arquitetura de roteadores tradicionais: plano de controle e plano de dados separados em cada dispositivo.",
                                    "Aprenda sobre tabelas de roteamento (ex: RIB e FIB) e como o forwarding é stateless e distribuído.",
                                    "Analise o processo de lookup de pacotes: matching de prefixos mais longos (LPM).",
                                    "Desenhe um diagrama simples de uma rede com 3 roteadores tradicionais.",
                                    "Simule o fluxo de um pacote através da rede usando ferramentas como Wireshark ou diagramas."
                                  ],
                                  "verification": "Desenhe e explique um diagrama de forwarding distribuído com pelo menos 3 roteadores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama em branco",
                                    "Documentação Cisco sobre roteamento",
                                    "Vídeo tutorial sobre BGP/OSPF"
                                  ],
                                  "tips": [
                                    "Comece com exemplos simples de redes pequenas para visualizar o fluxo distribuído.",
                                    "Use analogia de bibliotecários independentes em filiais para stateless forwarding."
                                  ],
                                  "learningObjective": "Compreender o modelo distribuído e stateless de encaminhamento em roteadores tradicionais.",
                                  "commonMistakes": [
                                    "Confundir plano de controle com plano de dados.",
                                    "Ignorar a dependência em protocolos de sinalização como OSPF para atualizações de tabelas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a arquitetura SDN",
                                  "subSteps": [
                                    "Estude os pilares do SDN: desacoplamento de plano de controle e dados, controle centralizado via controlador.",
                                    "Aprenda sobre OpenFlow: protocolo para comunicação entre controlador e switches.",
                                    "Analise fluxos (flows): regras instaladas dinamicamente no plano de dados.",
                                    "Desenhe um diagrama de rede SDN com controlador central e switches.",
                                    "Identifique componentes: switches OpenFlow, controlador (ex: ONOS, Ryu)."
                                  ],
                                  "verification": "Crie um diagrama SDN destacando o controlador central e fluxos instalados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Diagrama em branco",
                                    "Documentação OpenFlow.org",
                                    "Mininet para simulação SDN"
                                  ],
                                  "tips": [
                                    "Pense no controlador como um 'cérebro' central que orquestra todos os switches.",
                                    "Instale Mininet para testes práticos se possível."
                                  ],
                                  "learningObjective": "Dominar o conceito de controle centralizado e stateful em SDN.",
                                  "commonMistakes": [
                                    "Achar que SDN elimina roteadores; switches SDN ainda fazem forwarding.",
                                    "Confundir OpenFlow com SDN (SDN é mais amplo)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar mecanismos de encaminhamento",
                                  "subSteps": [
                                    "Liste diferenças: distribuído vs. centralizado, stateless vs. stateful (fluxos).",
                                    "Compare velocidade: lookup local rápido em tradicionais vs. instalação de regras em SDN.",
                                    "Analise consistência: convergência lenta em tradicionais vs. visão global em SDN.",
                                    "Crie uma tabela comparativa com colunas: Local de Decisão, Estado, Protocolos.",
                                    "Discuta trade-offs: simplicidade tradicional vs. programabilidade SDN."
                                  ],
                                  "verification": "Produza uma tabela comparativa com pelo menos 5 diferenças chave.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Artigos comparativos SDN vs. tradicional"
                                  ],
                                  "tips": [
                                    "Use bullet points para diferenças claras.",
                                    "Foque em forwarding puro, não em roteamento de alto nível."
                                  ],
                                  "learningObjective": "Identificar e contrastar diferenças fundamentais nos planos de dados.",
                                  "commonMistakes": [
                                    "Ignorar que SDN pode ser mais lento inicialmente devido a instalação de fluxos.",
                                    "Generalizar sem exemplos concretos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar limitações de escalabilidade",
                                  "subSteps": [
                                    "Em tradicionais: discuta explosão de tabelas TCAM com crescimento de rede.",
                                    "Em SDN: analise gargalos no controlador (single point of failure, latência).",
                                    "Compare escalabilidade: hierarquia distribuída vs. controladores distribuídos (ex: East-West).",
                                    "Calcule exemplos: tempo de convergência em falhas para cada modelo.",
                                    "Proponha soluções: SDN com múltiplos controladores para mitigar limitações."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que SDN escala melhor em data centers.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora para simulações",
                                    "Papers sobre escalabilidade SDN (ex: Kandoo)"
                                  ],
                                  "tips": [
                                    "Quantifique: ex. 1M fluxos por switch em SDN vs. limites TCAM tradicionais.",
                                    "Considere cenários reais como data centers."
                                  ],
                                  "learningObjective": "Avaliar impactos na escalabilidade e limitações de cada abordagem.",
                                  "commonMistakes": [
                                    "Subestimar overhead de controle em SDN.",
                                    "Achar tradicionais sempre melhores em escala pequena."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede de data center com 10 switches: tradicionalmente, cada switch mantém tabelas independentes, levando a loops durante falhas (convergência ~segundos); em SDN, o controlador instala fluxos globais instantaneamente, evitando loops, mas com latência inicial de 10-50ms por fluxo novo.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave em forwarding.",
                                "Desenhar diagramas precisos de ambos os modelos.",
                                "Preencher tabela comparativa sem erros.",
                                "Identificar cenários onde SDN falha em escalabilidade.",
                                "Discutir uma limitação tradicional resolvida por SDN.",
                                "Simular forwarding simples em ferramenta como Mininet."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de forwarding stateless vs. stateful (80%+ correto).",
                                "Profundidade na análise de escalabilidade com exemplos quantitativos.",
                                "Clareza em diagramas e tabelas comparativas.",
                                "Identificação correta de pelo menos 4 limitações tradicionais.",
                                "Compreensão de trade-offs, sem viés unilateral.",
                                "Capacidade de ligar conceitos a aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar controladores SDN em Python (Ryu/POX).",
                                "Segurança: SDN para detecção centralizada de intrusões.",
                                "Matemática: Modelos de grafos para análise de convergência.",
                                "Gestão: Orquestração de redes como DevOps em cloud.",
                                "Economia: Custos de hardware TCAM vs. software SDN."
                              ],
                              "realWorldApplication": "Em provedores como Google B4 ou data centers AWS, SDN permite escalabilidade para milhões de fluxos, otimizando tráfego e reduzindo custos em comparação com roteadores tradicionais limitados por hardware."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Integração com Protocolo IP e Algoritmos de Roteamento",
                        "description": "Relação do plano de dados com o protocolo IP e como algoritmos de roteamento populam suas tabelas, garantindo conectividade em redes grandes.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Relacionar plano de dados com o protocolo IP",
                            "description": "Explicar como o IP fornece endereçamento e fragmentação, enquanto o plano de dados executa o forwarding baseado em datagramas IP sem garantias de entrega.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Funções Principais do Protocolo IP",
                                  "subSteps": [
                                    "Estudar o endereçamento IP (IPv4 e IPv6), incluindo estrutura de endereços e máscaras de sub-rede.",
                                    "Analisar o processo de fragmentação e remontagem de datagramas IP quando necessário.",
                                    "Examinar a estrutura do cabeçalho IP, focando em campos como origem, destino, TTL e flags de fragmentação."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando como o IP fornece endereçamento e fragmentação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 791 (IPv4), RFC 8200 (IPv6)",
                                    "Diagramas interativos de cabeçalho IP (ex: Wireshark packet capture)"
                                  ],
                                  "tips": "Use ferramentas como Wireshark para capturar pacotes reais e visualizar headers IP.",
                                  "learningObjective": "Identificar e descrever as responsabilidades do IP em endereçamento e fragmentação no layer de rede.",
                                  "commonMistakes": "Confundir fragmentação IP com segmentação TCP; lembrar que IP opera sem conexão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Plano de Dados em Roteadores",
                                  "subSteps": [
                                    "Definir plano de dados como o conjunto de mecanismos para forwarding stateless de pacotes.",
                                    "Estudar tabelas de forwarding (FIB) e Longest Prefix Match (LPM) para lookup de rotas.",
                                    "Analisar o fluxo de processamento de um datagrama IP no hardware de roteador (ASICs)."
                                  ],
                                  "verification": "Desenhar um fluxograma simples do processamento de um datagrama IP no plano de dados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Livro 'Computer Networking: A Top-Down Approach' (Kurose/Ross), Capítulo 4",
                                    "Simulador Cisco Packet Tracer"
                                  ],
                                  "tips": "Diferencie plano de dados (rápido, stateless) de plano de controle (lento, stateful).",
                                  "learningObjective": "Explicar como o plano de dados executa forwarding baseado em informações do cabeçalho IP.",
                                  "commonMistakes": "Achar que plano de dados garante entrega; é puramente best-effort."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Protocolo IP com Operações do Plano de Dados",
                                  "subSteps": [
                                    "Mapear como endereços IP são usados em lookups de forwarding tables.",
                                    "Discutir como fragmentação IP afeta o forwarding (cada fragmento forwardado independentemente).",
                                    "Simular o caminho de um datagrama IP através de múltiplos roteadores no plano de dados."
                                  ],
                                  "verification": "Criar um diagrama mostrando interação entre cabeçalho IP e mecanismos de forwarding.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de traceroute (comando linha de comando)",
                                    "Vídeos sobre SDN (Software-Defined Networking)"
                                  ],
                                  "tips": "Pense no IP como 'etiqueta' que o plano de dados lê para decidir próximo hop.",
                                  "learningObjective": "Demonstrar a dependência do plano de dados em datagramas IP para forwarding.",
                                  "commonMistakes": "Ignorar que plano de dados não modifica conteúdo IP, apenas forwarda."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Ausência de Garantias de Entrega no Modelo IP/Data Plane",
                                  "subSteps": [
                                    "Explicar o modelo best-effort: sem ACKs, ordenação ou confiabilidade no IP.",
                                    "Discutir perdas, duplicatas e reordenação possíveis durante forwarding.",
                                    "Comparar com camadas superiores (TCP) que adicionam garantias."
                                  ],
                                  "verification": "Responder a 5 perguntas de autoavaliação sobre cenários de falha em forwarding IP.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "RFC 791 Seção 1.3 (best-effort)",
                                    "Exemplos de captura Wireshark com perdas"
                                  ],
                                  "tips": "Lembre: IP entrega 'se possível', sem retry; isso é intencional para escalabilidade.",
                                  "learningObjective": "Entender implicações da falta de garantias no relacionamento IP/plano de dados.",
                                  "commonMistakes": "Confundir IP com UDP/TCP; IP é o 'transporte básico' sem garantias."
                                }
                              ],
                              "practicalExample": "Usando Packet Tracer, configure uma topologia com 3 roteadores. Envie um ping de Host A para Host B com MTU diferente em um link, observe fragmentação IP e forwarding no plano de dados via traceroute, notando possível perda sem retry automático.",
                              "finalVerifications": [
                                "Explicar em suas palavras como endereços IP guiam o forwarding no plano de dados.",
                                "Desenhar e rotular um diagrama de um datagrama IP sendo forwardado através de roteadores.",
                                "Identificar 3 campos do cabeçalho IP usados pelo plano de dados.",
                                "Descrever um cenário onde fragmentação ocorre e como afeta forwarding.",
                                "Discutir por que não há garantias de entrega e implicações para aplicações.",
                                "Simular perda de pacote e explicar resposta do IP (nenhuma)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre IP e plano de dados (30%).",
                                "Clareza e estrutura da explicação: Uso de diagramas e exemplos (25%).",
                                "Profundidade de análise: Cobertura de fragmentação e best-effort (20%).",
                                "Aplicação prática: Qualidade da simulação ou exemplo (15%).",
                                "Conexões interdisciplinares: Menção a escalabilidade e hardware (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos de Longest Prefix Match como busca em trie (estruturas de dados).",
                                "Física: Propagação de sinais e latência em links físicos afetando forwarding.",
                                "Segurança da Informação: Vulnerabilidades IP como spoofing impactando roteamento.",
                                "Engenharia de Software: Implementação de SDN separando planos de dados/controle."
                              ],
                              "realWorldApplication": "Na Internet global, roteadores backbone forwardam trilhões de datagramas IP por dia usando plano de dados para lookups ultrarrápidos em ASICs, com IP fornecendo endereços e fragmentação, mas sem garantias – perdas são corrigidas por TCP em aplicações como streaming de vídeo ou web browsing."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Descrever a influência de algoritmos de roteamento",
                            "description": "Detalhar como protocolos como OSPF ou BGP computam rotas no plano de controle e instalam entradas no plano de dados via atualizações de tabelas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os planos de controle e dados em roteadores",
                                  "subSteps": [
                                    "Definir o plano de controle como o componente responsável por decisões de roteamento e manutenção de tabelas.",
                                    "Definir o plano de dados como o responsável pelo forwarding de pacotes baseado em tabelas pré-computadas.",
                                    "Explicar a interação: o plano de controle popula as tabelas usadas pelo plano de dados.",
                                    "Identificar exemplos de separação em roteadores modernos (ex: SDN).",
                                    "Diferenciar routing (cálculo) de forwarding (encaminhamento)."
                                  ],
                                  "verification": "Desenhar um diagrama simples mostrando a interação entre os planos e explicar verbalmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagrama de roteador SDN",
                                    "Vídeo introdutório sobre arquitetura de roteadores (YouTube: Computer Networking basics)",
                                    "Livro 'Computer Networking: A Top-Down Approach' capítulo de roteadores"
                                  ],
                                  "tips": "Use analogias como 'cérebro (controle) e músculos (dados)' para fixar conceitos.",
                                  "learningObjective": "Distinguir funcionalmente os planos de controle e dados e sua integração.",
                                  "commonMistakes": "Confundir plano de controle com processamento de pacotes em tempo real."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o protocolo OSPF e seu algoritmo de roteamento",
                                  "subSteps": [
                                    "Descrever OSPF como protocolo de estado de link (link-state) para redes internas.",
                                    "Explicar a construção do grafo de rede via LSAs (Link State Advertisements).",
                                    "Detalhar o uso do algoritmo de Dijkstra (SPF) para calcular o caminho mais curto.",
                                    "Mostrar como métricas (custo baseado em largura de banda) influenciam as rotas.",
                                    "Simular floodings de LSAs em uma topologia pequena."
                                  ],
                                  "verification": "Calcular manualmente rotas em um grafo de 4 nós usando Dijkstra.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador Packet Tracer ou GNS3",
                                    "Documentação RFC 2328 (OSPFv2)",
                                    "Ferramenta online de Dijkstra (ex: geeksforgeeks.org)"
                                  ],
                                  "tips": "Comece com topologias lineares para praticar Dijkstra antes de redes complexas.",
                                  "learningObjective": "Compreender como OSPF computa rotas no plano de controle.",
                                  "commonMistakes": "Ignorar reconvergência após falhas de link."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o protocolo BGP e seu algoritmo de roteamento",
                                  "subSteps": [
                                    "Descrever BGP como protocolo de vetor de caminho para roteamento exterior (AS).",
                                    "Explicar anúncios de prefixos IP e atributos (AS_PATH, LOCAL_PREF).",
                                    "Detalhar seleção de melhor rota via algoritmo de decisão BGP (tie-breakers).",
                                    "Discutir políticas de roteamento e influência humana nas decisões.",
                                    "Comparar com OSPF: escalabilidade para Internet vs. convergência rápida."
                                  ],
                                  "verification": "Analisar um dump de tabela BGP e justificar a melhor rota escolhida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta BGP lookup (ex: bgp.he.net)",
                                    "RFC 4271 (BGP-4)",
                                    "Simulador BGP em Quagga/FRR"
                                  ],
                                  "tips": "Memorize a ordem dos tie-breakers BGP com mnemônicos como 'Weight, LOCAL_PREF, etc.'.",
                                  "learningObjective": "Entender o mecanismo de seleção de rotas no BGP.",
                                  "commonMistakes": "Confundir BGP com roteamento interno ou ignorar atributos de política."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a instalação de rotas no plano de dados e influência geral",
                                  "subSteps": [
                                    "Explicar atualizações de tabelas: RIB (Routing Information Base) para FIB (Forwarding Information Base).",
                                    "Descrever instalação via protocolos como Zebra/FRR ou comandos 'ip route'.",
                                    "Discutir influência: otimização de tráfego, resiliência e latência.",
                                    "Analisar impactos de falhas em algoritmos (loops, blackholes).",
                                    "Sintetizar como OSPF/BGP afetam o forwarding global."
                                  ],
                                  "verification": "Configurar OSPF em simulador e observar atualizações na tabela de roteamento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Cisco Packet Tracer",
                                    "Documentação de 'show ip route' em roteadores",
                                    "Artigo sobre RIB vs FIB"
                                  ],
                                  "tips": "Monitore logs em tempo real durante simulações para ver atualizações.",
                                  "learningObjective": "Descrever o fluxo completo da computação à instalação de rotas.",
                                  "commonMistakes": "Achar que o plano de controle encaminha pacotes diretamente."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 3 roteadores conectados via OSPF, configure o protocolo no Packet Tracer: adicione links com custos diferentes, observe LSAs floodadas, cálculo SPF e instalação na tabela 'ip route'; altere um link para ver reconvergência e impacto no ping entre hosts.",
                              "finalVerifications": [
                                "Explicar com diagrama como OSPF usa Dijkstra para popular FIB.",
                                "Comparar seleção de rotas OSPF vs BGP em cenários específicos.",
                                "Descrever o que acontece se um LSA falhar no OSPF.",
                                "Interpretar uma entrada de tabela BGP e justificar sua escolha.",
                                "Simular falha de rota e verificar reconvergência no plano de dados.",
                                "Definir influência de algoritmos em termos de latência e disponibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual nos planos de controle/dados (80% correto).",
                                "Detalhamento correto de algoritmos OSPF (Dijkstra) e BGP (tie-breakers).",
                                "Capacidade de ligar computação de rotas à instalação em FIB.",
                                "Uso adequado de terminologia técnica (LSA, AS_PATH, RIB/FIB).",
                                "Exemplos práticos viáveis e relacionados ao contexto.",
                                "Análise de influência com pelo menos 3 impactos mensuráveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos de grafos (Dijkstra como shortest path).",
                                "Segurança da Informação: Vulnerabilidades BGP (hijacking de prefixos).",
                                "Física: Modelagem de redes como circuitos com resistências (custos).",
                                "Economia: Otimização de custos em provedores de Internet via políticas BGP.",
                                "Gestão: Planejamento de topologias para resiliência."
                              ],
                              "realWorldApplication": "Na infraestrutura da Internet, BGP roteia trilhões de pacotes diariamente entre ISPs, enquanto OSPF gerencia data centers do Google/Facebook; falhas em algoritmos causam outages globais (ex: rotação errada em 2021 afetou Facebook), influenciando latência em streaming e e-commerce."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Identificar limitações do plano de dados sem SDN",
                            "description": "Analisar problemas como convergência lenta de roteamento e falta de visibilidade global, justificando a separação em SDN com plano de controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a arquitetura tradicional do plano de dados",
                                  "subSteps": [
                                    "Estudar o modelo integrado de plano de dados e plano de controle em roteadores convencionais.",
                                    "Explicar o papel dos protocolos de roteamento distribuídos, como OSPF e BGP, no cálculo de rotas.",
                                    "Identificar como o processamento de controle é realizado no mesmo dispositivo que encaminha pacotes.",
                                    "Desenhar um diagrama representando a integração vertical nos roteadores.",
                                    "Discutir as implicações dessa integração para a escalabilidade."
                                  ],
                                  "verification": "Criar e rotular um diagrama da arquitetura tradicional, explicando verbalmente sua integração.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação (ex: Draw.io)",
                                    "Documentação de OSPF/BGP"
                                  ],
                                  "tips": [
                                    "Use analogias como 'cérebro e músculos no mesmo corpo' para visualizar a integração.",
                                    "Priorize exemplos visuais para fixar conceitos."
                                  ],
                                  "learningObjective": "Entender a base da arquitetura de redes sem separação de planos.",
                                  "commonMistakes": [
                                    "Confundir plano de dados (forwarding) com plano de controle (routing)",
                                    "Subestimar o overhead computacional nos roteadores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a limitação de convergência lenta de roteamento",
                                  "subSteps": [
                                    "Simular uma falha de link em uma topologia de rede simples com 4 roteadores.",
                                    "Calcular o tempo de detecção e propagação de rotas em protocolos como OSPF.",
                                    "Medir o impacto em termos de perda de pacotes e latência durante a reconvergência.",
                                    "Comparar tempos de convergência em redes pequenas vs. grandes.",
                                    "Registrar métricas típicas (ex: 30-50 segundos em OSPF)."
                                  ],
                                  "verification": "Executar simulação no Packet Tracer ou GNS3 e registrar o tempo de reconvergência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de rede (Cisco Packet Tracer ou GNS3)",
                                    "Topologia de rede básica"
                                  ],
                                  "tips": [
                                    "Comece com topologias lineares para isolar o problema de loops.",
                                    "Anote timestamps exatos de falha e recuperação."
                                  ],
                                  "learningObjective": "Identificar quantitativamente o problema de convergência lenta.",
                                  "commonMistakes": [
                                    "Ignorar hold-down timers que prolongam a convergência",
                                    "Confundir convergência com throughput"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a falta de visibilidade global na rede",
                                  "subSteps": [
                                    "Descrever como cada roteador mantém apenas visão local da topologia.",
                                    "Analisar cenários onde decisões locais causam ineficiências globais (ex: rotas subótimas).",
                                    "Discutir dificuldades em monitoramento centralizado e troubleshooting.",
                                    "Listar impactos como blackholing de tráfego ou elephant flows não otimizados.",
                                    "Comparar com visão ideal de um observador central."
                                  ],
                                  "verification": "Mapear uma topologia e destacar informações ausentes em cada nó.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de topologia expandida",
                                    "Ferramentas de monitoramento como Wireshark"
                                  ],
                                  "tips": [
                                    "Pense em 'visão de túnel' para roteadores locais.",
                                    "Use exemplos de falhas reais como inspiração."
                                  ],
                                  "learningObjective": "Reconhecer as limitações de descentralização na visibilidade.",
                                  "commonMistakes": [
                                    "Superestimar a precisão de tabelas de roteamento locais",
                                    "Confundir visibilidade com conectividade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar a separação em SDN com plano de controle",
                                  "subSteps": [
                                    "Explicar o conceito de plano de controle centralizado no SDN.",
                                    "Mapear como SDN resolve convergência lenta via atualizações globais instantâneas.",
                                    "Destacar ganhos em visibilidade com controladores como OpenDaylight.",
                                    "Discutir trade-offs, como ponto único de falha mitigado por clustering.",
                                    "Concluir com benefícios em programação e automação de rede."
                                  ],
                                  "verification": "Escrever um parágrafo justificando SDN baseado nas limitações identificadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação SDN (ex: ONF.org)",
                                    "Vídeo introdutório SDN (5 min)"
                                  ],
                                  "tips": [
                                    "Ligue cada limitação a uma solução SDN específica.",
                                    "Evite exagerar benefícios sem mencionar custos."
                                  ],
                                  "learningObjective": "Articular a motivação para adotar SDN.",
                                  "commonMistakes": [
                                    "Ignorar latência de comunicação controlador-switch",
                                    "Generalizar SDN como panaceia"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 50 roteadores, uma falha de link causa reconvergência de 45 segundos via OSPF, resultando em 10% de perda de pacotes em VoIP. Sem visibilidade global, o administrador demora horas para identificar a causa raiz. Com SDN, o controlador atualiza rotas em milissegundos e monitora tudo centralmente.",
                              "finalVerifications": [
                                "Listar pelo menos 4 limitações principais do plano de dados tradicional.",
                                "Explicar com exemplo a convergência lenta e seu impacto.",
                                "Desenhar comparação entre arquitetura tradicional e SDN.",
                                "Justificar verbalmente 3 benefícios da separação de planos.",
                                "Simular uma falha e medir tempo de recuperação.",
                                "Identificar 2 cenários reais afetados pela falta de visibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de limitações (convergência, visibilidade, escalabilidade).",
                                "Uso de exemplos concretos e simulações para suporte.",
                                "Clareza na justificativa para SDN com mapeamento direto de problemas.",
                                "Profundidade nos subpassos com pelo menos 4 por step.",
                                "Correção técnica em diagramas e cálculos de tempo.",
                                "Conexão lógica entre steps e conclusão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos de grafos e algoritmos de caminho mais curto (Dijkstra).",
                                "Programação: Desenvolvimento de controladores SDN em Python (ex: Ryu).",
                                "Segurança da Informação: Vulnerabilidades em roteamento distribuído vs. centralizado.",
                                "Gestão de Projetos: Análise de trade-offs em arquiteturas de rede."
                              ],
                              "realWorldApplication": "Em data centers do Google ou AWS, onde SDN permite orquestração dinâmica de tráfego para milhões de VMs, reduzindo latência e otimizando elephant flows em tempo real, evitando downtime em serviços críticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.4",
                            "name": "Exemplificar fluxo de um pacote no plano de dados",
                            "description": "Traçar o caminho de um pacote IP desde a chegada em um roteador até o next-hop, incluindo lookup longest-prefix matching (LPM).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a chegada do pacote IP no roteador",
                                  "subSteps": [
                                    "Identifique o pacote IP chegando na interface de entrada do roteador via link físico (ex: Ethernet).",
                                    "Descreva o parsing inicial do cabeçalho IP: extraia endereço de origem (src IP), destino (dst IP) e TTL.",
                                    "Verifique integridade básica do pacote usando checksum do cabeçalho IP.",
                                    "Registre metadados como porta de entrada e timestamp de chegada.",
                                    "Confirme que o pacote não é fragmentado ou gerencie fragmentação se aplicável."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando o pacote chegando e os campos extraídos do cabeçalho IP.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama de roteador básico, RFC 791 (IP header spec), Wireshark para captura de exemplo.",
                                  "tips": "Use Wireshark para capturar tráfego real e visualizar o cabeçalho IP passo a passo.",
                                  "learningObjective": "Entender o processamento inicial de um pacote IP na camada de enlace/rede.",
                                  "commonMistakes": "Confundir endereço MAC com IP; ignorar checksum que pode descartar pacotes corrompidos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e realizar lookup na tabela de roteamento com LPM",
                                  "subSteps": [
                                    "Acesse a Forwarding Information Base (FIB) ou tabela de roteamento do roteador.",
                                    "Extraia o endereço IP de destino do pacote.",
                                    "Aplique Longest Prefix Matching (LPM): compare prefixos da tabela com o dst IP, escolhendo o match mais longo.",
                                    "Use estrutura de dados como trie ou Patricia trie para eficiência no lookup.",
                                    "Registre o prefixo vencedor e a rota associada (next-hop IP e interface)."
                                  ],
                                  "verification": "Simule manualmente um lookup com uma tabela de roteamento exemplo e anote o match LPM.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplo de tabela de roteamento (CIDR), calculadora binária para máscaras, simulador como Cisco Packet Tracer.",
                                  "tips": "Converta IPs para binário para visualizar LPM claramente; teste com múltiplos prefixos.",
                                  "learningObjective": "Dominar o algoritmo LPM para resolução de rotas em tabelas de roteamento.",
                                  "commonMistakes": "Escolher prefixo mais curto em vez de mais longo; esquecer de considerar default route (/0)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar next-hop e preparar encaminhamento",
                                  "subSteps": [
                                    "Identifique o next-hop IP da rota selecionada via LPM.",
                                    "Resolva o MAC do next-hop via ARP se necessário (envie ARP request se não em cache).",
                                    "Selecione a interface de saída baseada na rota.",
                                    "Decrementar TTL e recalcular checksum do cabeçalho IP.",
                                    "Enfileire o pacote na fila de saída da interface."
                                  ],
                                  "verification": "Crie um fluxo de trace com src IP, dst IP, next-hop e interface de saída anotados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela ARP cache exemplo, ferramenta ARP simulator, Packet Tracer.",
                                  "tips": "Lembre-se: ARP é só para L2 next-hop no mesmo segmento; roteamento é L3.",
                                  "learningObjective": "Compreender transição de L3 para L2 no encaminhamento.",
                                  "commonMistakes": "Não decrementar TTL levando a loops infinitos; usar MAC src incorreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Encaminhar pacote e verificar saída",
                                  "subSteps": [
                                    "Transmita o pacote pela interface de saída com novo cabeçalho Ethernet (dst MAC do next-hop).",
                                    "Monitore por erros de transmissão ou congestionamento na fila.",
                                    "Registre estatísticas: pacotes encaminhados, drops por TTL=0.",
                                    "Simule o que acontece se LPM falhar (ex: enviar para default route).",
                                    "Documente o caminho completo do pacote neste roteador."
                                  ],
                                  "verification": "Use simulador para enviar pacote e capture saída com Wireshark confirmando mudanças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Cisco Packet Tracer ou GNS3, Wireshark, topologia de rede simples com 2-3 roteadores.",
                                  "tips": "Configure TTL baixo para testar drops; compare pacotes entrada/saída.",
                                  "learningObjective": "Visualizar o fluxo completo de um pacote em um roteador realista.",
                                  "commonMistakes": "Ignorar mudança de MAC na saída; confundir FIB com RIB."
                                }
                              ],
                              "practicalExample": "Em um roteador Cisco com tabela: 192.168.1.0/24 via 10.0.0.2 Gi0/0, 192.168.0.0/16 via 10.0.1.2 Gi0/1. Pacote dst 192.168.1.100 chega: LPM escolhe /24, next-hop 10.0.0.2, ARP resolve MAC, TTL--, envia por Gi0/0.",
                              "finalVerifications": [
                                "Diagrama completo do fluxo do pacote com todos os passos anotados.",
                                "Simulação em Packet Tracer mostrando captura entrada/saída.",
                                "Cálculo manual correto de LPM com pelo menos 3 prefixos competindo.",
                                "Explicação verbal do que acontece se TTL=0 ou sem match.",
                                "Lista de mudanças no cabeçalho IP (TTL, checksum).",
                                "Registro de MACs alterados na saída."
                              ],
                              "assessmentCriteria": [
                                "Precisão no traçado LPM (match correto do prefixo mais longo).",
                                "Correta sequência de processamento (parsing -> lookup -> ARP -> forward).",
                                "Identificação de erros comuns como TTL não decrementado.",
                                "Uso adequado de ferramentas/simuladores para verificação.",
                                "Clareza no diagrama e documentação do fluxo.",
                                "Compreensão de diferenças entre RIB/FIB e impacto no forwarding."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações binárias e algoritmos de trie para LPM.",
                                "Programação: Implementar LPM em Python com dicionários ou bibliotecas como ipaddress.",
                                "Sistemas Operacionais: Gerenciamento de filas e buffers em kernels de roteadores (ex: Linux netfilter).",
                                "Segurança: Análise de pacotes com Wireshark para detecção de anomalias IP.",
                                "Física: Propagação de sinais em cabos Ethernet durante transmissão."
                              ],
                              "realWorldApplication": "Em data centers como Google ou ISPs, roteadores BGP usam LPM para encaminhar bilhões de pacotes/segundo, otimizando rotas e evitando blackholes na Internet global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Plano de Controle",
                    "description": "Mecanismos de controle distribuído para configuração de rotas, contrastando com abordagens tradicionais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Plano de Controle Distribuído Tradicional",
                        "description": "Abordagens tradicionais onde cada roteador mantém e atualiza tabelas de roteamento de forma distribuída utilizando protocolos como OSPF e BGP para configuração dinâmica de rotas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Identificar mecanismos de roteamento distribuído",
                            "description": "Reconhecer e listar protocolos de roteamento distribuído como OSPF, BGP e RIP, explicando como eles trocam informações de estado de enlace e topologia entre roteadores vizinhos para construir tabelas de roteamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do roteamento distribuído",
                                  "subSteps": [
                                    "Defina roteamento distribuído como um processo onde roteadores trocam informações autonomamente sem um controlador central.",
                                    "Explique a diferença entre roteamento centralizado e distribuído, destacando vantagens como escalabilidade e resiliência.",
                                    "Identifique os componentes chave: tabelas de roteamento, atualizações de vizinhos e convergência.",
                                    "Desenhe um diagrama simples de uma rede com 3 roteadores trocando informações.",
                                    "Liste os desafios comuns, como loops de roteamento e convergência lenta."
                                  ],
                                  "verification": "Crie um diagrama anotado mostrando troca de informações entre roteadores e explique verbalmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Vídeo introdutório sobre roteamento (YouTube: 'Distributed Routing Basics')"
                                  ],
                                  "tips": "Use analogias como 'vizinhos conversando em uma rua' para visualizar a troca de informações.",
                                  "learningObjective": "Entender os princípios básicos e componentes do roteamento distribuído.",
                                  "commonMistakes": [
                                    "Confundir roteamento distribuído com centralizado",
                                    "Ignorar o papel da convergência na estabilidade da rede"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o protocolo OSPF (Open Shortest Path First)",
                                  "subSteps": [
                                    "Descreva OSPF como um protocolo de estado de enlace (link-state) que usa flooding de LSAs (Link State Advertisements).",
                                    "Explique como roteadores vizinhos formam adjacências e sincronizam bases de dados de estado de enlace.",
                                    "Detalhe o algoritmo SPF (Shortest Path First) para calcular a tabela de roteamento.",
                                    "Identifique tipos de LSAs e áreas OSPF para escalabilidade.",
                                    "Simule a troca de LSAs em uma rede de 4 roteadores."
                                  ],
                                  "verification": "Liste 3 tipos de LSAs e desenhe o processo de flooding em um diagrama.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Documentação OSPF oficial (RFC 2328)",
                                    "Simulador como Cisco Packet Tracer"
                                  ],
                                  "tips": "Lembre-se: OSPF reconstrói a topologia completa em cada roteador para evitar loops.",
                                  "learningObjective": "Dominar o funcionamento do OSPF na troca de topologia e construção de tabelas.",
                                  "commonMistakes": [
                                    "Confundir OSPF com distance-vector",
                                    "Esquecer o conceito de áreas para hierarquia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o protocolo RIP (Routing Information Protocol)",
                                  "subSteps": [
                                    "Classifique RIP como distance-vector, usando métrica hop-count para trocar tabelas completas.",
                                    "Descreva atualizações periódicas (a cada 30s) entre roteadores vizinhos via UDP.",
                                    "Explique mecanismos anti-loop como split horizon e poison reverse.",
                                    "Compare RIP v1 (classful) e v2 (CIDR support).",
                                    "Calcule manualmente uma tabela de roteamento em uma rede pequena com RIP."
                                  ],
                                  "verification": "Configure uma rede simples no Packet Tracer com RIP e verifique a tabela de roteamento.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Cisco Packet Tracer ou GNS3",
                                    "Guia RIP (RFC 2453)"
                                  ],
                                  "tips": "Teste convergência lenta do RIP adicionando/removendo links para observar.",
                                  "learningObjective": "Compreender como RIP usa distance-vector para roteamento distribuído.",
                                  "commonMistakes": [
                                    "Ignorar limitações de 15 hops",
                                    "Não aplicar split horizon corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar o protocolo BGP (Border Gateway Protocol)",
                                  "subSteps": [
                                    "Identifique BGP como path-vector para roteamento entre AS (Autonomous Systems).",
                                    "Explique sessões TCP entre peers e troca de NLRI (Network Layer Reachability Information).",
                                    "Descreva atributos como AS_PATH, LOCAL_PREF e MED para seleção de caminhos.",
                                    "Diferencie eBGP (externo) e iBGP (interno).",
                                    "Analise um exemplo de anúncio de prefixos e decisão de melhor caminho."
                                  ],
                                  "verification": "Desenhe um diagrama de 3 ASs trocando rotas BGP e liste atributos usados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "RFC 4271 BGP",
                                    "Ferramenta como BGP simulator online"
                                  ],
                                  "tips": "Pense em BGP como 'mapa de caminhos' entre redes independentes da internet.",
                                  "learningObjective": "Entender BGP para roteamento em escala global.",
                                  "commonMistakes": [
                                    "Confundir BGP com IGP",
                                    "Esquecer que BGP usa políticas, não apenas métricas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar protocolos e sintetizar o processo de construção de tabelas",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: OSPF (link-state), RIP (distance-vector), BGP (path-vector).",
                                    "Explique genericamente a troca de estado de enlace/topologia entre vizinhos.",
                                    "Descreva convergência e instalação de rotas nas tabelas de roteamento.",
                                    "Discuta cenários de falha e recuperação em cada protocolo.",
                                    "Resuma como todos constroem tabelas distribuídas via mensagens vizinhas."
                                  ],
                                  "verification": "Preencha a tabela comparativa e explique um cenário de falha para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Google Sheets para tabela",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Use cores na tabela para destacar diferenças em tipo de protocolo e velocidade de convergência.",
                                  "learningObjective": "Sintetizar como protocolos distribuídos constroem tabelas de roteamento coletivamente.",
                                  "commonMistakes": [
                                    "Generalizar incorretamente mecanismos de todos os protocolos",
                                    "Ignorar diferenças de escala"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório com Cisco Packet Tracer, configure uma rede com 4 roteadores: um rodando OSPF em área única, outro RIP, e simule BGP entre dois ASs. Observe as tabelas de roteamento 'show ip route' após trocas de mensagens e falha de um link, verificando reconvergência.",
                              "finalVerifications": [
                                "Liste corretamente OSPF, BGP e RIP como protocolos distribuídos.",
                                "Explique flooding de LSAs no OSPF e atualizações periódicas no RIP.",
                                "Descreva atributos BGP e sua seleção de caminhos.",
                                "Desenhe troca de informações entre 3 roteadores vizinhos.",
                                "Compare convergência: rápida em OSPF vs. lenta em RIP.",
                                "Identifique quando usar cada protocolo (ex: OSPF intra-domínio, BGP inter-AS)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e descrição de cada protocolo (80% correto).",
                                "Clareza na explicação de mecanismos de troca de informações (diagrama legível).",
                                "Compreensão de construção de tabelas (exemplo prático funcional).",
                                "Capacidade de comparação e cenários de falha (tabela completa).",
                                "Uso correto de terminologia técnica (LSAs, AS_PATH, hop-count).",
                                "Criatividade em analogias ou exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grafos e algoritmos de caminho mais curto (SPF como Dijkstra).",
                                "Segurança da Informação: Vulnerabilidades em protocolos de roteamento (BGP hijacking).",
                                "Administração: Políticas de roteamento e gerenciamento de redes empresariais.",
                                "Física: Analogia com propagação de sinais em redes sem fio.",
                                "Economia: Otimização de custos em tráfego de dados na internet."
                              ],
                              "realWorldApplication": "Na internet global, BGP roteia tráfego entre ISPs evitando falhas; OSPF gerencia redes corporativas internas para alta disponibilidade; RIP em redes legadas pequenas, garantindo conectividade distribuída sem servidor central em data centers ou provedores de nuvem como AWS VPC."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Explicar convergência em roteamento distribuído",
                            "description": "Descrever o processo de convergência em redes tradicionais, incluindo loops de contagem e atrasos na propagação de atualizações de rotas, com exemplos de cenários de falha de enlace.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Roteamento Distribuído",
                                  "subSteps": [
                                    "Defina roteamento distribuído como o processo em que roteadores trocam informações de rotas sem um controlador central.",
                                    "Explique protocolos de roteamento de vetor de distância (ex: RIP) e estado de enlace (ex: OSPF).",
                                    "Descreva tabelas de roteamento e como elas são atualizadas periodicamente.",
                                    "Identifique métricas de custo como hop count ou largura de banda.",
                                    "Discuta a importância da convergência para estabilidade da rede."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos básicos e liste 2 protocolos de exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de rede simples com 3 roteadores",
                                    "Documentação do RIP e OSPF"
                                  ],
                                  "tips": "Use desenhos à mão para visualizar trocas de mensagens entre roteadores.",
                                  "learningObjective": "Compreender os fundamentos do roteamento distribuído e sua relação com convergência.",
                                  "commonMistakes": [
                                    "Confundir roteamento distribuído com centralizado",
                                    "Ignorar diferenças entre protocolos de vetor de distância e estado de enlace"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o Processo de Convergência Normal",
                                  "subSteps": [
                                    "Explique que convergência é o tempo para todos roteadores terem tabelas consistentes após mudança.",
                                    "Descreva propagação de atualizações: roteador detecta mudança e envia para vizinhos.",
                                    "Ilustre com exemplo: adição de novo enlace, propagação em cascata até estabilizar.",
                                    "Calcule tempo aproximado baseado em intervalos de atualização (ex: 30s no RIP).",
                                    "Destaque convergência rápida em topologias estáveis."
                                  ],
                                  "verification": "Desenhe um diagrama de 4 roteadores mostrando propagação de uma atualização de rota.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Simulador de rede como Cisco Packet Tracer"
                                  ],
                                  "tips": "Simule passo a passo com setas indicando direção da propagação.",
                                  "learningObjective": "Mapear o fluxo sequencial de atualizações durante convergência normal.",
                                  "commonMistakes": [
                                    "Subestimar atrasos cumulativos em redes grandes",
                                    "Confundir convergência com detecção inicial de falha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Loops de Contagem (Count-to-Infinity) e Atrasos",
                                  "subSteps": [
                                    "Defina loop de roteamento: ciclo temporário onde pacotes circulam inutilmente.",
                                    "Explique count-to-infinity: roteadores incrementam custo indefinidamente até máximo.",
                                    "Descreva cenário: falha de enlace A-B, B informa A via C com custo antigo.",
                                    "Discuta mecanismos de mitigação como split horizon e poison reverse.",
                                    "Calcule exemplo: custo inicial 1, após falha sobe para 16 no RIP."
                                  ],
                                  "verification": "Explique verbalmente um loop count-to-infinity e proponha split horizon como solução.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo animado de count-to-infinity online",
                                    "Folha de cálculo para simular contagens"
                                  ],
                                  "tips": "Use números concretos para rastrear custos em cada iteração.",
                                  "learningObjective": "Identificar e explicar problemas clássicos na convergência.",
                                  "commonMistakes": [
                                    "Achar que loops são permanentes sem mecanismos de proteção",
                                    "Confundir split horizon com hold-down timers"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Cenários de Falha de Enlace com Exemplos",
                                  "subSteps": [
                                    "Simule falha: rede linear A-B-C, B falha, A redescobre via C com atraso.",
                                    "Meça convergência: tempo total = detecção + propagação + estabilização.",
                                    "Compare redes em estrela vs. malha: impacto em atrasos.",
                                    "Inclua hold-down timers: período de suspeita para evitar loops.",
                                    "Teste em simulador: observe logs de atualizações."
                                  ],
                                  "verification": "Crie e rode simulação de falha, registrando tempo de convergência.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Cisco Packet Tracer ou GNS3",
                                    "Topologias pré-configuradas RIP"
                                  ],
                                  "tips": "Registre timestamps de cada mensagem para análise precisa.",
                                  "learningObjective": "Aplicar conceitos em cenários reais de falha e medir impactos.",
                                  "commonMistakes": [
                                    "Ignorar overhead de mensagens durante convergência",
                                    "Não considerar topologia na análise"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com roteadores A-B-C em linha (A conectado a B, B a C), se o enlace B-C falha, B marca rota para C como inválida e notifica A. A, sem alternativa imediata, pode criar loop temporário informando B de uma rota via si mesmo, levando a count-to-infinity até atingir 16 hops no RIP, demorando ~8 minutos para convergir.",
                              "finalVerifications": [
                                "Descreva diferenças entre convergência em RIP e OSPF.",
                                "Explique como split horizon previne count-to-infinity.",
                                "Calcule tempo de convergência em rede de 5 roteadores com intervalo 30s.",
                                "Identifique 3 causas de atrasos na propagação.",
                                "Simule falha em ferramenta e meça tempo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de convergência e processos envolvidos (30%)",
                                "Correta identificação e explicação de loops count-to-infinity (25%)",
                                "Uso de exemplos concretos com diagramas ou simulações (20%)",
                                "Compreensão de mecanismos de mitigação (15%)",
                                "Análise de impactos em cenários reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para modelar topologias e algoritmos de caminho mais curto.",
                                "Física: Analogia com propagação de ondas para atrasos em sinais de rede.",
                                "Estatística: Análise probabilística de tempos de falha e convergência.",
                                "Economia: Custos de convergência lenta em redes de provedores de internet."
                              ],
                              "realWorldApplication": "Em data centers da Amazon AWS ou redes de ISPs como Verizon, falhas de enlace causam outages se convergência for lenta; protocolos como BGP usam timers semelhantes para evitar blackholes globais durante rotações de tráfego."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Analisar limitações do controle distribuído",
                            "description": "Discutir problemas como escalabilidade limitada, complexidade na configuração de políticas e lentidão na resposta a mudanças de tráfego em redes com roteamento distribuído.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Controle Distribuído em Redes",
                                  "subSteps": [
                                    "Defina controle distribuído como a tomada de decisões de roteamento por múltiplos nós sem um controlador central.",
                                    "Descreva componentes chave: roteadores autônomos, protocolos como OSPF ou BGP em modo distribuído.",
                                    "Compare brevemente com controle centralizado para destacar diferenças.",
                                    "Identifique premissas básicas: convergência eventual e consistência eventual.",
                                    "Registre anotações sobre vantagens iniciais para contextualizar limitações."
                                  ],
                                  "verification": "Crie um diagrama simples de uma rede com 3 roteadores distribuídos e anote premissas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; documentação de protocolos OSPF/BGP.",
                                  "tips": "Use analogias como 'formigas em uma colônia' para visualizar decisões locais.",
                                  "learningObjective": "Entender os princípios operacionais do controle distribuído para basear análises de limitações.",
                                  "commonMistakes": "Confundir com controle centralizado; ignorar premissas de convergência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Limitações de Escalabilidade",
                                  "subSteps": [
                                    "Explique como o overhead de mensagens cresce quadraticamente com o número de nós (O(n²)).",
                                    "Simule adição de nós e observe loops de roteamento ou blackholes.",
                                    "Discuta impacto em redes grandes: tempo de convergência aumenta exponencialmente.",
                                    "Calcule exemplos numéricos: para 10 vs 100 roteadores, compare floods de LSAs.",
                                    "Liste mitigações parciais como áreas em OSPF, mas note suas restrições."
                                  ],
                                  "verification": "Produza um gráfico mostrando overhead vs número de nós e identifique ponto de quebra.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou Python com matplotlib para gráficos; simulador de rede como Mininet.",
                                  "tips": "Comece com redes pequenas (3-5 nós) antes de escalar para visualizar problemas.",
                                  "learningObjective": "Quantificar e qualificar por que o controle distribuído falha em escalar.",
                                  "commonMistakes": "Subestimar overhead de controle; confundir com gargalos de dados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Complexidade na Configuração de Políticas",
                                  "subSteps": [
                                    "Descreva políticas como filtros de rota ou preferências em BGP.",
                                    "Analise necessidade de configuração manual em cada roteador, levando a inconsistências.",
                                    "Discuta propagação lenta de mudanças de política devido a floods distribuídos.",
                                    "Exemplo: política anti-hijack requer atualizações em todos os ASes afetados.",
                                    "Avalie ferramentas como route-maps e prefix-lists, notando sua verbosidade."
                                  ],
                                  "verification": "Escreva uma configuração de política simples para 3 roteadores e simule uma mudança inconsistente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Documentação Cisco/Juniper para route-maps; emulador GNS3 ou EVE-NG.",
                                  "tips": "Teste configurações em lab virtual para ver erros de propagação em tempo real.",
                                  "learningObjective": "Identificar fontes de complexidade humana e operacional nas políticas distribuídas.",
                                  "commonMistakes": "Ignorar herança de configurações; assumir sincronia instantânea."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Lentidão na Resposta a Mudanças de Tráfego",
                                  "subSteps": [
                                    "Explique detecção distribuída de mudanças via hello packets ou keepalives.",
                                    "Modele resposta a falhas: tempo de detecção + cálculo local + flood + reconvergência.",
                                    "Compare com centralizado: SDN responde em ms vs minutos em distribuído.",
                                    "Discuta tráfego dinâmico: elephant flows ou DDoS sobrecarregam controle.",
                                    "Proponha métricas: convergence time > 30s é inaceitável para apps modernas."
                                  ],
                                  "verification": "Simule falha de link em rede de 4 nós e meça tempo total de reconvergência.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Simulador Mininet ou NS-3; cronômetro para medições manuais.",
                                  "tips": "Use traces de tráfego real (CAIDA) para simulações realistas.",
                                  "learningObjective": "Compreender impactos em latência e disponibilidade devido a respostas lentas.",
                                  "commonMistakes": "Confundir detecção com propagação; ignorar cenários de churn alto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Limitações e Implicações Gerais",
                                  "subSteps": [
                                    "Compile as três limitações principais em uma tabela comparativa.",
                                    "Discuta trade-offs: robustez vs performance em cenários reais.",
                                    "Relacione com evoluções como SDN para controle centralizado.",
                                    "Brainstorm soluções híbridas ou distribuídas modernas (P4, etc.).",
                                    "Redija um parágrafo resumindo quando evitar controle distribuído tradicional."
                                  ],
                                  "verification": "Crie relatório de 1 página com tabela e recomendações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto; tabela em Markdown ou Word.",
                                  "tips": "Priorize limitações por impacto: escalabilidade > políticas > resposta.",
                                  "learningObjective": "Integrar análises para formar visão holística das limitações.",
                                  "commonMistakes": "Focar só em desvantagens sem contexto de uso."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 20 roteadores BGP distribuídos, adicionar um novo data center causa floods de rotas que duram 5 minutos, criando blackholes e perda de pacotes durante picos de tráfego de e-commerce. Simule isso no Mininet: configure BGP, injete falha e observe reconvergência lenta e inconsistências de política entre sites.",
                              "finalVerifications": [
                                "Pode listar e explicar as 3 limitações principais com exemplos numéricos.",
                                "Simula uma rede de 5+ nós e demonstra falhas de escalabilidade ou convergência.",
                                "Escreve configurações de política que ilustrem complexidade distribuída.",
                                "Compara tempos de resposta distribuído vs centralizado em cenário de falha.",
                                "Produz diagrama ou relatório sintetizando implicações para redes grandes.",
                                "Identifica cenários onde controle distribuído ainda é viável (ex: small WANs)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correta identificação de mecanismos como floods LSAs ou route reflectors.",
                                "Profundidade quantitativa: Uso de métricas como O(n²) ou tempos de convergência reais.",
                                "Clareza na explicação: Analogias e diagramas eficazes para conceitos abstratos.",
                                "Evidências práticas: Referência a simulações ou dados empíricos.",
                                "Síntese crítica: Discussão de trade-offs e evoluções futuras.",
                                "Originalidade: Exemplos contextualizados ao ID 10.1.5.2.1.3."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de complexidade algorítmica (gráfos distribuídos, convergência).",
                                "Administração: Gestão de políticas e configuração em larga escala (governança de TI).",
                                "Física: Modelagem de propagação de sinais em redes como ondas (analogia para floods).",
                                "Economia: Custos de escalabilidade e trade-offs em infraestrutura de rede."
                              ],
                              "realWorldApplication": "Em provedores de nuvem como AWS ou data centers de telecom, controle distribuído tradicional causa outages durante picos (ex: falha BGP na Level3 em 2010), motivando migração para SDN como OpenFlow para escalabilidade e respostas rápidas em CDNs globais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Plano de Controle em Redes Definidas por Software (SDN)",
                        "description": "Separação lógica entre plano de dados (forwarding) e plano de controle centralizado, onde um controlador SDN programa switches de forma global para configuração de rotas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Descrever arquitetura SDN",
                            "description": "Explicar os componentes principais do SDN: plano de dados (switches OpenFlow), plano de controle (controlador como NOX ou ONOS) e interfaces de programação como REST e OpenFlow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de SDN",
                                  "subSteps": [
                                    "Pesquise a definição de SDN (Software-Defined Networking) e sua motivação principal: separar o controle de dados.",
                                    "Identifique a arquitetura tradicional de rede versus SDN.",
                                    "Liste os três planos principais: dados, controle e aplicação.",
                                    "Estude diagramas básicos de arquitetura SDN disponíveis online.",
                                    "Anote as vantagens do SDN, como centralização e programabilidade."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo explicando SDN e seus planos principais; revise se cobre definição e motivação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Notebook para anotações",
                                    "Vídeos introdutórios sobre SDN (ex: YouTube ou Cisco SDN intro)"
                                  ],
                                  "tips": [
                                    "Comece com vídeos visuais para melhor compreensão.",
                                    "Use mind maps para conectar conceitos."
                                  ],
                                  "learningObjective": "Compreender o que é SDN e por que ele difere das redes tradicionais.",
                                  "commonMistakes": [
                                    "Confundir SDN com virtualização de rede.",
                                    "Ignorar a separação plano de controle e dados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Plano de Dados em SDN",
                                  "subSteps": [
                                    "Descreva o papel do plano de dados: encaminhamento de pacotes.",
                                    "Estude switches OpenFlow: hardware/software que executa fluxos de tráfego.",
                                    "Aprenda sobre tabelas de fluxo (flow tables) e matching/actions.",
                                    "Instale ou simule um switch OpenFlow usando Mininet.",
                                    "Teste comandos básicos para visualizar fluxos em um switch."
                                  ],
                                  "verification": "Desenhe um diagrama simples do plano de dados e explique o fluxo de um pacote.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Mininet instalado (ferramenta gratuita)",
                                    "Documentação OpenFlow oficial",
                                    "Ambiente virtual como VirtualBox"
                                  ],
                                  "tips": [
                                    "Use Mininet para hands-on imediato.",
                                    "Foque em como switches são 'burros' sem controlador."
                                  ],
                                  "learningObjective": "Dominar o funcionamento do plano de dados com switches OpenFlow.",
                                  "commonMistakes": [
                                    "Pensar que switches SDN são inteligentes sozinhos.",
                                    "Confundir OpenFlow com protocolo proprietário."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Plano de Controle em SDN",
                                  "subSteps": [
                                    "Defina o plano de controle: cérebro da rede, decide rotas e políticas.",
                                    "Estude controladores como NOX, POX ou ONOS: exemplos open-source.",
                                    "Aprenda como o controlador se comunica com switches via OpenFlow.",
                                    "Explore módulos de controladores (ex: apps em ONOS).",
                                    "Simule uma topologia SDN com controlador em Mininet."
                                  ],
                                  "verification": "Liste 3 funções de um controlador e execute um demo simples no Mininet.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Mininet + controlador POX/ONOS",
                                    "Tutoriais ONOS/Mininet",
                                    "Terminal Linux"
                                  ],
                                  "tips": [
                                    "Inicie com POX por ser simples.",
                                    "Registre logs de comunicação controlador-switch."
                                  ],
                                  "learningObjective": "Entender o papel central do controlador SDN.",
                                  "commonMistakes": [
                                    "Subestimar a escalabilidade do controlador.",
                                    "Confundir plano de controle com plano de aplicação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever Interfaces e Integração na Arquitetura SDN",
                                  "subSteps": [
                                    "Estude interfaces: OpenFlow (sul), REST/Northbound APIs (norte).",
                                    "Aprenda como aplicações se conectam via REST/JSON.",
                                    "Explore o plano de aplicação: serviços como balanceamento de carga.",
                                    "Monte um diagrama completo da arquitetura SDN.",
                                    "Discuta integrações como SDN com NFV."
                                  ],
                                  "verification": "Crie um fluxograma mostrando comunicação entre planos e interfaces.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io ou Lucidchart)",
                                    "Documentação REST APIs de ONOS",
                                    "Exemplos de código Northbound"
                                  ],
                                  "tips": [
                                    "Use cores diferentes para planos no diagrama.",
                                    "Pense em APIs como 'programação da rede'."
                                  ],
                                  "learningObjective": "Integrar todos os componentes via interfaces de programação.",
                                  "commonMistakes": [
                                    "Inverter interfaces norte/sul.",
                                    "Ignorar o plano de aplicação."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa, use SDN para criar um controlador ONOS que detecta tráfego alto via OpenFlow nos switches, redireciona via REST API para um balanceador de carga, demonstrando os três planos em ação.",
                              "finalVerifications": [
                                "Pode listar e descrever os três planos principais de SDN?",
                                "Consegue explicar o protocolo OpenFlow e seu papel?",
                                "Desenha corretamente um diagrama da arquitetura SDN?",
                                "Identifica exemplos de controladores como NOX/ONOS?",
                                "Diferencia interfaces norte (REST) e sul (OpenFlow)?",
                                "Simula uma topologia básica no Mininet?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos planos de dados, controle e aplicação (peso 30%)",
                                "Correta identificação de componentes como switches OpenFlow e controladores (25%)",
                                "Clareza no diagrama e explicação de interfaces (20%)",
                                "Uso de exemplos práticos e simulações (15%)",
                                "Compreensão de vantagens e limitações do SDN (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de apps Northbound em Python/Java.",
                                "Segurança da Informação: Políticas de firewall centralizadas via SDN.",
                                "Sistemas Operacionais: Integração com kernels Linux para redes virtuais.",
                                "Engenharia de Software: Modularidade em controladores como ONOS.",
                                "Matemática: Algoritmos de roteamento otimizado no plano de controle."
                              ],
                              "realWorldApplication": "Em data centers da Google ou AWS, SDN permite gerenciar milhões de fluxos dinamicamente, otimizando tráfego em clouds, reduzindo latência e facilitando migrações para 5G/edge computing."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Explicar configuração de rotas via controlador",
                            "description": "Detalhar como o controlador SDN coleta topologia via LLDP, computa caminhos ótimos e instala regras de fluxo nos switches para roteamento centralizado e programável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a coleta de topologia via LLDP",
                                  "subSteps": [
                                    "Estudar o protocolo LLDP (Link Layer Discovery Protocol) e seus pacotes de anúncio.",
                                    "Explicar como switches enviam pacotes LLDP para vizinhos periodicamente.",
                                    "Descrever como o controlador SDN escuta esses pacotes via porta de escuta OpenFlow.",
                                    "Modelar a topologia como grafo: switches como nós, links como arestas.",
                                    "Identificar hosts e suas conexões através de pacotes ARP/LLDP."
                                  ],
                                  "verification": "Desenhar um diagrama simples de topologia coletada de 3 switches e confirmar com simulação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.1AB (LLDP)",
                                    "Simulador Mininet",
                                    "Controlador Ryu ou ONOS"
                                  ],
                                  "tips": "Sempre verifique o intervalo de anúncio LLDP (padrão 30s) para atualizações rápidas.",
                                  "learningObjective": "Entender como o controlador constrói o mapa da rede dinamicamente via LLDP.",
                                  "commonMistakes": [
                                    "Confundir LLDP com CDP (Cisco-specifico)",
                                    "Ignorar detecção de loops na topologia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a rede e descobrir dispositivos",
                                  "subSteps": [
                                    "Implementar listener no controlador para pacotes LLDP e ARP.",
                                    "Construir estrutura de dados interna (ex: grafo com NetworkX em Python).",
                                    "Atualizar topologia em tempo real com eventos de link up/down.",
                                    "Mapear portas dos switches e endereços MAC/IP de hosts.",
                                    "Validar consistência da topologia removendo hosts desconectados."
                                  ],
                                  "verification": "Executar script de coleta e imprimir grafo da topologia no console.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca NetworkX (Python)",
                                    "Exemplo de app Ryu para topologia",
                                    "Mininet para teste"
                                  ],
                                  "tips": "Use eventos OpenFlow (OFPT_PACKET_IN) para pacotes discovery.",
                                  "learningObjective": "Dominar a construção dinâmica do grafo de rede no controlador.",
                                  "commonMistakes": [
                                    "Não tratar falhas de link",
                                    "Armazenar topologia estática em vez de dinâmica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar caminhos ótimos",
                                  "subSteps": [
                                    "Selecionar algoritmo: Dijkstra para menor custo, A* para heurística.",
                                    "Definir métricas de custo (latência, banda, hops).",
                                    "Implementar função de roteamento no controlador usando o grafo.",
                                    "Calcular caminho bidirecional para tráfego full-duplex.",
                                    "Otimizar para balanceamento de carga ou QoS."
                                  ],
                                  "verification": "Simular tráfego entre dois hosts e verificar caminho via dump de flows.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Algoritmo Dijkstra implementado",
                                    "Ferramenta Wireshark para análise",
                                    "Código exemplo em Ryu"
                                  ],
                                  "tips": "Pondere arestas com métricas reais obtidas via LLDP (ex: velocidade do link).",
                                  "learningObjective": "Aplicar teoria de grafos para roteamento otimizado em SDN.",
                                  "commonMistakes": [
                                    "Usar BFS em vez de Dijkstra para custos não-uniformes",
                                    "Ignorar caminhos reversos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Instalar regras de fluxo nos switches",
                                  "subSteps": [
                                    "Gerar sequências de ações OpenFlow para cada switch no caminho.",
                                    "Enviar FlowMod mensagens (OFPT_FLOW_MOD) com match/actions.",
                                    "Configurar tabelas de fluxo para roteamento programável.",
                                    "Instalar flows proativos ou reativos baseados em eventos.",
                                    "Definir timeouts para flows dinâmicos."
                                  ],
                                  "verification": "Usar ovs-ofctl dump-flows para inspecionar regras instaladas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Especificação OpenFlow 1.3",
                                    "Comando ovs-ofctl",
                                    "Controlador com API OpenFlow"
                                  ],
                                  "tips": "Sempre inclua actions para output na porta correta e next hop.",
                                  "learningObjective": "Executar instalação centralizada de políticas de roteamento.",
                                  "commonMistakes": [
                                    "Match incorreto (ex: IP src/dst trocados)",
                                    "Flooding em vez de fluxo específico"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e manter o roteamento",
                                  "subSteps": [
                                    "Monitorar estatísticas de fluxo via FlowStatsRequest.",
                                    "Detectar falhas e recomputar rotas alternativas.",
                                    "Implementar atualizações suaves sem perda de pacotes.",
                                    "Testar failover com desligamento de links.",
                                    "Documentar logs de mudanças de rota."
                                  ],
                                  "verification": "Gerar tráfego iperf e medir latência/perda antes/depois de falha.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta iperf",
                                    "Logs do controlador",
                                    "Script de teste de falha"
                                  ],
                                  "tips": "Use barriers (OFPT_BARRIER_REQUEST) para sincronizar instalações.",
                                  "learningObjective": "Garantir resiliência e monitoramento no roteamento SDN.",
                                  "commonMistakes": [
                                    "Não remover flows obsoletos",
                                    "Recomputar rotas sem otimização"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma topologia Mininet com 3 switches (s1-s2-s3) e hosts h1/h2 conectados a s1/s3, o controlador Ryu coleta LLDP, detecta links, computa caminho h1->s1->s2->s3->h2 via Dijkstra (menor hops), instala flows: match dst=IP_h2 action=output:porta_s3 em s1/s2, e testa ping sem perda.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo LLDP -> paths -> flows.",
                                "Desenhar diagrama de topologia e instalação de flows.",
                                "Simular em Mininet e dump flows corretos.",
                                "Identificar e corrigir uma falha de link manualmente.",
                                "Comparar roteamento SDN vs tradicional distribuído.",
                                "Medir tempo de convergência de rota após falha."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de LLDP e OpenFlow (90% correto).",
                                "Capacidade de modelar grafo e computar paths manualmente.",
                                "Implementação funcional em simulador sem erros.",
                                "Explicação clara de otimizações e resiliência.",
                                "Uso correto de terminologia SDN (control plane, data plane).",
                                "Criatividade em exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Algoritmos de Caminho Mais Curto (Dijkstra).",
                                "Programação: Desenvolvimento em Python com bibliotecas NetworkX e Ryu.",
                                "Segurança: Autenticação de controladores e prevenção de spoofing LLDP.",
                                "Sistemas Operacionais: Gerenciamento de rede em Linux com Open vSwitch.",
                                "Engenharia de Software: Design de APIs para controle de rede."
                              ],
                              "realWorldApplication": "Em data centers como Google B4 ou redes 5G, controladores SDN como ONOS computam rotas otimizadas para milhões de flows, reduzindo latência em 30% e habilitando slicing de rede para IoT e vídeo streaming."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Identificar protocolos SDN chave",
                            "description": "Listar e descrever protocolos como OpenFlow para comunicação entre controlador e switches, e NETCONF/YANG para configuração de dispositivos de rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de SDN e a Necessidade de Protocolos Chave",
                                  "subSteps": [
                                    "Pesquise a arquitetura SDN: plano de dados, plano de controle e plano de aplicação.",
                                    "Identifique o papel dos protocolos na separação entre controlador e switches.",
                                    "Liste os principais desafios resolvidos por protocolos SDN, como centralização de controle.",
                                    "Revise diagramas de arquitetura SDN para visualizar fluxos de comunicação.",
                                    "Anote diferenças entre redes tradicionais e SDN em termos de protocolos."
                                  ],
                                  "verification": "Crie um diagrama simples da arquitetura SDN rotulando onde os protocolos se encaixam; verifique se cobre controlador, switches e comunicação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documento oficial SDN da ONF (opennetworking.org)",
                                    "Vídeo introdutório sobre SDN no YouTube (canal NetworkChuck)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use analogias como 'controlador é o cérebro, protocolos são os nervos' para fixar conceitos.",
                                  "learningObjective": "Compreender o contexto e a importância dos protocolos SDN na arquitetura geral.",
                                  "commonMistakes": "Confundir SDN com virtualização de rede; foque na separação de planos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Protocolo OpenFlow em Detalhe",
                                  "subSteps": [
                                    "Estude a estrutura do OpenFlow: mensagens controller-to-switch (ex: FlowMod) e switch-to-controller (ex: PacketIn).",
                                    "Analise camadas do OpenFlow (Secure Channel, Flow Table, Group Table).",
                                    "Implemente um exemplo simples de match-action em fluxos OpenFlow.",
                                    "Revise versões do OpenFlow (1.0 a 1.5+) e mudanças chave.",
                                    "Simule comunicação OpenFlow usando ferramentas como Mininet."
                                  ],
                                  "verification": "Descreva em 3 frases o fluxo de uma instalação de regra OpenFlow; teste em simulação sem erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Especificação OpenFlow 1.3 (opennetworking.org)",
                                    "Mininet tutorial (mininet.org)",
                                    "Wireshark para capturar tráfego OpenFlow"
                                  ],
                                  "tips": "Comece com OpenFlow 1.3, a mais comum; pratique capturando pacotes reais.",
                                  "learningObjective": "Dominar o protocolo OpenFlow para comunicação entre controlador e switches.",
                                  "commonMistakes": "Ignorar diferenças entre match fields e actions; sempre liste ambos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar NETCONF e YANG para Configuração de Dispositivos",
                                  "subSteps": [
                                    "Aprenda NETCONF: operações RPC como get-config, edit-config e suas operações CRUD.",
                                    "Estude YANG: modelagem de dados, módulos, folhas e containers.",
                                    "Mapeie como YANG define estruturas de dados usadas pelo NETCONF.",
                                    "Compare NETCONF com SNMP/SYSLOG em termos de configuração programática.",
                                    "Pratique modelando um módulo YANG simples para uma interface de rede."
                                  ],
                                  "verification": "Crie um módulo YANG básico e uma operação NETCONF get-config; valide sintaxe com pyang.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "RFC 6241 (NETCONF)",
                                    "RFC 7950 (YANG)",
                                    "Ferramenta pyang (yangtools.org)",
                                    "Exemplos YANG da IETF"
                                  ],
                                  "tips": "Pense em YANG como 'JSON para redes'; use editores online para testar.",
                                  "learningObjective": "Identificar e descrever NETCONF/YANG para configuração em SDN.",
                                  "commonMistakes": "Confundir YANG (modelo) com NETCONF (transporte); memorize a dupla."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Protocolos e Identificar em Cenários Práticos",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: OpenFlow vs NETCONF/YANG (uso, camada, exemplos).",
                                    "Identifique cenários: OpenFlow para forwarding, NETCONF para config inicial.",
                                    "Liste outros protocolos SDN relacionados (OVSDB, P4) e sua relação.",
                                    "Simule um cenário SDN completo usando ambos protocolos.",
                                    "Teste identificação em quizzes ou flashcards."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas de identificação de protocolos em fluxogramas SDN.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela comparativa em branco",
                                    "Mininet + Ryu controller",
                                    "Flashcards Anki com protocolos SDN"
                                  ],
                                  "tips": "Use mnemônicos: 'OpenFlow flui tráfego, NETCONF configura o hardware'.",
                                  "learningObjective": "Diferenciar e identificar protocolos SDN chave em contextos reais.",
                                  "commonMistakes": "Superestimar OpenFlow para config; reserve NETCONF para isso."
                                }
                              ],
                              "practicalExample": "Em um laboratório Mininet, use Ryu controller para instalar regras OpenFlow em switches simulados, direcionando tráfego HTTP para uma porta específica, e configure interfaces via NETCONF/YANG no mesmo ambiente.",
                              "finalVerifications": [
                                "Liste OpenFlow, NETCONF e YANG com uma frase descritiva cada.",
                                "Desenhe fluxo OpenFlow de PacketIn para FlowMod.",
                                "Explique como YANG modela dados para uma operação NETCONF edit-config.",
                                "Identifique protocolo correto para 'instalar fluxo dinâmico' vs 'configurar VLAN'.",
                                "Simule erro comum e corrija em ferramenta.",
                                "Compare com protocolo tradicional (ex: SNMP)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de OpenFlow (camadas e mensagens): 25%",
                                "Compreensão de NETCONF/YANG (operações e modelagem): 25%",
                                "Capacidade de diferenciação e comparação: 20%",
                                "Uso correto em exemplos práticos/simulações: 15%",
                                "Identificação em cenários/diagramas: 10%",
                                "Clareza na tabela comparativa e verificações: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Modelagem YANG similar a schemas JSON/XML em desenvolvimento de APIs.",
                                "Segurança: Protocolos SDN integram com criptografia (TLS em OpenFlow/NETCONF).",
                                "Matemática: Lógica de match-action em OpenFlow usa expressões booleanas.",
                                "Gestão de Projetos: Protocolos SDN em automação de DevOps para redes."
                              ],
                              "realWorldApplication": "Em data centers da Google (usando OpenFlow para tráfego), provedores como AT&T usam NETCONF/YANG para configuração em massa de roteadores em redes 5G SDN."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Contrastes entre Abordagens Tradicionais e SDN",
                        "description": "Comparação entre controle distribuído tradicional e centralizado em SDN, destacando vantagens em flexibilidade, escalabilidade e gerenciamento de rotas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Comparar mecanismos de configuração de rotas",
                            "description": "Contrastar roteamento distribuído (reativo, local) com SDN (proativo, global), usando tabelas comparativas para métricas como tempo de convergência e overhead de controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Roteamento Distribuído Tradicional",
                                  "subSteps": [
                                    "Estude os princípios do roteamento distribuído, onde cada roteador toma decisões locais baseadas em tabelas de roteamento atualizadas por protocolos como OSPF ou RIP.",
                                    "Analise o caráter reativo: roteadores respondem a mudanças na topologia trocando mensagens de controle entre vizinhos.",
                                    "Identifique limitações como loops de roteamento temporários e dependência de convergência lenta.",
                                    "Revise exemplos de protocolos reativos e como eles constroem tabelas de forwarding localmente.",
                                    "Anote características chave: descentralizado, reativo e baseado em estado local."
                                  ],
                                  "verification": "Crie um diagrama simples de uma rede com 4 roteadores mostrando troca de mensagens reativas e confirme que identifica o processo de convergência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação OSPF/RIP (RFCs ou tutoriais Khan Academy)",
                                    "Ferramenta de desenho como Draw.io",
                                    "Vídeos introdutórios sobre roteamento distribuído no YouTube (Cisco Networking Academy)"
                                  ],
                                  "tips": [
                                    "Comece com redes pequenas para visualizar o fluxo de mensagens.",
                                    "Use analogias como 'conversa entre vizinhos' para reatividade."
                                  ],
                                  "learningObjective": "Explicar como o roteamento distribuído opera de forma reativa e local, identificando seus mecanismos principais.",
                                  "commonMistakes": [
                                    "Confundir reativo com proativo.",
                                    "Ignorar o impacto de topologias em loop na convergência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Roteamento em SDN (Software-Defined Networking)",
                                  "subSteps": [
                                    "Defina SDN: separação do plano de controle (centralizado) do plano de dados (distribuído).",
                                    "Descreva o roteamento proativo: controlador global computa rotas e instala regras em switches via southbound API (ex: OpenFlow).",
                                    "Analise vantagens como visão global da rede e atualizações instantâneas.",
                                    "Estude exemplos de controladores como ONOS ou Ryu e como eles gerenciam fluxos.",
                                    "Compare visualmente com distribuído usando fluxogramas."
                                  ],
                                  "verification": "Desenhe um fluxograma de SDN mostrando controlador instalando regras em switches e verifique ausência de trocas peer-to-peer.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação OpenFlow (opennetworking.org)",
                                    "Simulador Mininet",
                                    "Tutoriais SDN no Coursera ou edX"
                                  ],
                                  "tips": [
                                    "Instale Mininet rapidamente para simular SDN básico.",
                                    "Pense no controlador como um 'cérebro central' da rede."
                                  ],
                                  "learningObjective": "Descrever o roteamento proativo e global em SDN, destacando a centralização do controle.",
                                  "commonMistakes": [
                                    "Achar que SDN elimina roteadores completamente.",
                                    "Subestimar latência na comunicação controlador-switch."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Pesquisar Métricas de Comparação",
                                  "subSteps": [
                                    "Liste métricas chave: tempo de convergência (tempo para estabilizar rotas após falha), overhead de controle (tráfego de mensagens de sinalização), escalabilidade, resiliência a falhas.",
                                    "Pesquise valores típicos: ex. OSPF convergência ~segundos a minutos vs SDN ~milissegundos.",
                                    "Colete dados de fontes confiáveis sobre overhead: distribuído alto devido a floods vs SDN baixo e direcionado.",
                                    "Crie uma tabela inicial com métricas e defina critérios qualitativos/quantitativos.",
                                    "Inclua outras métricas como consumo de memória em roteadores/controladores."
                                  ],
                                  "verification": "Compile uma lista de 5 métricas com definições e exemplos numéricos de papers ou simulações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papers IEEE sobre SDN vs traditional routing",
                                    "Ferramentas como Wireshark para medir overhead",
                                    "Planilhas Google Sheets para tabelas"
                                  ],
                                  "tips": [
                                    "Use benchmarks de simulações NS-3 ou Mininet para dados reais.",
                                    "Priorize métricas impactantes como convergência em cenários de falha."
                                  ],
                                  "learningObjective": "Identificar e quantificar métricas relevantes para comparar mecanismos de roteamento.",
                                  "commonMistakes": [
                                    "Focar só em tempo de convergência ignorando overhead.",
                                    "Usar dados desatualizados de protocolos legados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e Analisar Tabelas Comparativas",
                                  "subSteps": [
                                    "Crie uma tabela comparativa com colunas: Abordagem (Distribuída/SDN), Métrica, Descrição, Vantagens/Desvantagens.",
                                    "Preencha com dados das métricas, usando qualitativo (ex: 'lento' vs 'rápido') e quantitativo.",
                                    "Analise trade-offs: ex. SDN melhor convergência mas single point of failure.",
                                    "Simule cenários em Mininet para validar tabela (falha de link e medir tempos).",
                                    "Escreva um parágrafo de contraste baseado na tabela."
                                  ],
                                  "verification": "Produza uma tabela completa em Markdown ou Excel e simule um cenário validando pelo menos 2 métricas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Mininet ou GNS3 para simulação",
                                    "Google Sheets ou LaTeX para tabelas profissionais",
                                    "Papers comparativos SDN (ex: 'SDN: A Comprehensive Survey')"
                                  ],
                                  "tips": [
                                    "Teste falhas reais em simulação para números autênticos.",
                                    "Use cores na tabela para destacar diferenças visuais."
                                  ],
                                  "learningObjective": "Contrastar mecanismos usando tabelas comparativas acionáveis e baseadas em evidências.",
                                  "commonMistakes": [
                                    "Tabelas enviesadas sem dados quantitativos.",
                                    "Ignorar contexto de escala (pequena vs grande rede)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 10 switches, simule uma falha de link: no roteamento distribuído (OSPF), leva 15s para convergir com alto overhead de LSAs; em SDN (Mininet+ONOS), o controlador recalcula e instala rotas em 50ms com overhead mínimo, demonstrado via Wireshark.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças reativo vs proativo sem hesitação.",
                                "Apresentar tabela comparativa cobrindo 5+ métricas com dados.",
                                "Simular convergência em ferramenta e medir tempos/overhead.",
                                "Identificar cenários onde distribuído é preferível (ex: redes pequenas).",
                                "Discutir trade-offs como centralização vs descentralização.",
                                "Responder quiz com 90% acerto sobre conceitos e métricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre reativo/local e proativo/global (30%).",
                                "Qualidade da tabela: completude, dados quantitativos e análise (25%).",
                                "Evidências práticas: simulações ou capturas reais (20%).",
                                "Análise crítica: trade-offs e contextos de uso (15%).",
                                "Clareza e organização: diagramas/tabelas legíveis (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para modelar topologias e algoritmos de caminho mais curto.",
                                "Administração: Gerenciamento centralizado vs distribuído em sistemas empresariais.",
                                "Física: Analogias com propagação de sinais e latência em redes.",
                                "Economia: Custo-benefício de overhead vs desempenho em infraestruturas.",
                                "Segurança da Informação: Impacto na detecção de falhas e resiliência."
                              ],
                              "realWorldApplication": "Em data centers do Google (usando SDN com Jupiter), rotas são configuradas proativamente para alta escalabilidade e baixa latência, contrastando com ISPs tradicionais que usam OSPF distribuído, sofrendo lentidão em outages globais como o de 2021 na Fastly."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Avaliar vantagens e desvantagens",
                            "description": "Analisar benefícios do SDN como programação centralizada e otimização global versus riscos como ponto único de falha, com exemplos de cenários reais de implantações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de SDN e Redes Tradicionais",
                                  "subSteps": [
                                    "Pesquisar a definição e arquitetura do SDN (plano de controle centralizado vs. plano de dados).",
                                    "Descrever a arquitetura tradicional de redes (controle distribuído em switches/roteadores).",
                                    "Identificar diferenças chave: centralização vs. descentralização.",
                                    "Visualizar diagramas comparativos de ambas as abordagens.",
                                    "Mapear componentes principais: controller SDN, switches OpenFlow vs. protocolos tradicionais como OSPF."
                                  ],
                                  "verification": "Criar um diagrama ou tabela comparativa resumindo as diferenças arquiteturais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigos introdutórios sobre SDN (ex: Open Networking Foundation)",
                                    "Diagramas de arquitetura SDN vs. tradicional",
                                    "Vídeos tutoriais no YouTube sobre SDN basics"
                                  ],
                                  "tips": "Use analogias como 'SDN é como um maestro centralizando a orquestra vs. músicos independentes'.",
                                  "learningObjective": "Diferenciar as arquiteturas de SDN e redes tradicionais para contextualizar vantagens/desvantagens.",
                                  "commonMistakes": [
                                    "Confundir plano de controle com plano de dados",
                                    "Ignorar protocolos como OpenFlow no SDN"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Detalhar Vantagens do SDN",
                                  "subSteps": [
                                    "Listar vantagens principais: programação centralizada, otimização global de tráfego e agilidade na configuração.",
                                    "Explicar programação centralizada: como o controller gerencia políticas de rede de forma unificada.",
                                    "Detalhar otimização global: uso de algoritmos para balanceamento de carga em toda a rede.",
                                    "Discutir simplicidade na inovação: introdução rápida de novos serviços via software.",
                                    "Exemplificar com métricas: redução de latência em 30-50% em cenários de alto tráfego."
                                  ],
                                  "verification": "Elaborar uma lista com 4 vantagens, cada uma com explicação e benefício quantificável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação SDN da Cisco ou VMware",
                                    "Casos de estudo de otimização em SDN",
                                    "Ferramentas como Mininet para simulação básica"
                                  ],
                                  "tips": "Priorize vantagens mensuráveis com dados de performance para fortalecer a análise.",
                                  "learningObjective": "Reconhecer benefícios concretos do SDN em comparação às redes tradicionais.",
                                  "commonMistakes": [
                                    "Superestimar simplicidade sem considerar custos iniciais",
                                    "Ignorar dependência de hardware compatível"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Analisar Desvantagens e Riscos do SDN",
                                  "subSteps": [
                                    "Listar riscos principais: ponto único de falha no controller, complexidade na escalabilidade e dependência de software.",
                                    "Explicar ponto único de falha: impacto de downtime no controller em toda a rede.",
                                    "Detalhar desafios de segurança: superfície de ataque ampliada no plano de controle centralizado.",
                                    "Discutir latência adicional: comunicação southbound para switches.",
                                    "Analisar custos: necessidade de hardware SDN-ready e treinamento especializado."
                                  ],
                                  "verification": "Criar uma matriz de riscos com probabilidade, impacto e mitigações para cada desvantagem.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Relatórios de falhas SDN (ex: incidentes em Google B4)",
                                    "Artigos sobre segurança SDN",
                                    "Ferramentas de análise de risco como SWOT"
                                  ],
                                  "tips": "Considere mitigações como controllers distribuídos (ex: ONOS) para equilibrar a análise.",
                                  "learningObjective": "Avaliar riscos do SDN de forma crítica, identificando trade-offs.",
                                  "commonMistakes": [
                                    "Subestimar resiliência com clusters de controllers",
                                    "Confundir riscos teóricos com práticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise em Cenários Reais e Realizar Avaliação Balanceada",
                                  "subSteps": [
                                    "Selecionar cenários reais: implantações em data centers (Google B4) vs. redes empresariais tradicionais.",
                                    "Avaliar vantagens/desvantagens em um cenário: ex. otimização em SDN vs. falha em controller.",
                                    "Pesar prós e contras: calcular um score qualitativo (ex: +3 para agilidade, -2 para risco de falha).",
                                    "Propor recomendações: quando adotar SDN (altos volumes) vs. híbrido.",
                                    "Documentar lições de implantações reais: sucessos e falhas reportadas."
                                  ],
                                  "verification": "Redigir um relatório de 1 página com análise balanceada de um cenário real.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Casos de estudo: Google B4, AT&T SDN",
                                    "Ferramentas de simulação como Mininet ou GNS3",
                                    "Templates de análise SWOT"
                                  ],
                                  "tips": "Use dados reais de implantações para validar pontos, evitando opiniões subjetivas.",
                                  "learningObjective": "Integrar vantagens e desvantagens em uma avaliação contextualizada e acionável.",
                                  "commonMistakes": [
                                    "Viés para um lado só",
                                    "Falta de exemplos concretos de implantações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede de data center de uma empresa de e-commerce como a Amazon, o SDN permite otimização global de tráfego durante picos de Black Friday (vantagem: programação centralizada reduz latência em 40%), mas uma falha no controller principal causa downtime total (desvantagem: ponto único de falha), mitigado por clusters redundantes.",
                              "finalVerifications": [
                                "Lista precisa de pelo menos 4 vantagens e 4 desvantagens do SDN com explicações.",
                                "Análise de pelo menos 2 cenários reais de implantação (ex: Google B4, Facebook Wedge).",
                                "Matriz SWOT completa com mitigações para riscos.",
                                "Avaliação balanceada recomendando cenários ideais para SDN.",
                                "Diagramas ou tabelas comparativas claras.",
                                "Referências a fontes confiáveis citadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual nas vantagens/desvantagens (90% correto).",
                                "Profundidade da análise com exemplos reais e métricas.",
                                "Equilíbrio entre prós e contras, sem viés evidente.",
                                "Clareza e estrutura na apresentação (diagramas/tabelas).",
                                "Criatividade em mitigações e recomendações práticas.",
                                "Uso adequado de terminologia técnica (controller, OpenFlow, etc.).",
                                "Completude: todos elementos da expansão atômica abordados."
                              ],
                              "crossCurricularConnections": [
                                "Segurança da Informação: análise de vulnerabilidades em controllers centralizados.",
                                "Gerenciamento de Projetos: avaliação de custos e ROI em implantações SDN.",
                                "Matemática Aplicada: modelagem de otimização de tráfego com algoritmos.",
                                "Economia Empresarial: trade-offs custo-benefício em infraestruturas de rede.",
                                "Ética em TI: impactos de falhas de rede em serviços críticos."
                              ],
                              "realWorldApplication": "Em provedores de nuvem como AWS ou Google Cloud, SDN otimiza tráfego global reduzindo custos operacionais em 30%, mas exige alta disponibilidade (99.999%) para evitar outages que custam milhões por hora, como visto no incidente de falha de controller na Azure em 2023."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Redes Definidas por Software (SDN)",
                    "description": "Arquitetura que separa plano de controle do plano de dados, permitindo programação centralizada da rede.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Plano de Dados em SDN",
                        "description": "Componente da arquitetura SDN responsável pelo encaminhamento de pacotes de dados com base em regras instaladas pelo plano de controle, utilizando switches SDN que operam de forma simplificada e programável.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Identificar funções do plano de dados",
                            "description": "Explicar como o plano de dados realiza o forwarding de pacotes em switches SDN, sem lógica de roteamento local, dependendo exclusivamente de tabelas de fluxo programadas pelo controlador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Arquitetura SDN e Separação de Planos",
                                  "subSteps": [
                                    "Estude a definição de SDN e seus componentes principais: plano de dados, plano de controle e protocolo de comunicação (ex: OpenFlow).",
                                    "Identifique a diferença entre switches tradicionais (com lógica de roteamento integrada) e switches SDN (simples forwarding).",
                                    "Desenhe um diagrama simples mostrando a comunicação entre switch SDN, controlador e hosts.",
                                    "Revise exemplos de fluxos de pacotes em SDN vs. redes convencionais."
                                  ],
                                  "verification": "Crie um diagrama da arquitetura SDN e explique verbalmente ou por escrito a separação de planos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação OpenFlow oficial (opennetworking.org)",
                                    "Vídeo introdutório sobre SDN no YouTube (canal de networking como NetworkChuck)",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Use analogias: plano de dados é como um carteiro que segue instruções, controlador é o chefe que dá as regras.",
                                  "learningObjective": "Diferenciar SDN de redes tradicionais e entender a separação plano de dados/controle.",
                                  "commonMistakes": "Confundir plano de dados com roteamento tradicional; assumir que switches SDN têm inteligência local."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Funções Principais do Plano de Dados",
                                  "subSteps": [
                                    "Liste as funções chave: recepção de pacotes, matching de fluxos, forwarding, estatísticas e modificação de pacotes.",
                                    "Explique que o plano de dados NÃO possui lógica de roteamento ou decisões complexas.",
                                    "Compare com hardware ASIC/TCAM usado para lookups rápidos em tabelas de fluxo.",
                                    "Simule mentalmente o ciclo de vida de um pacote no switch SDN."
                                  ],
                                  "verification": "Escreva uma lista de 5 funções do plano de dados e justifique por que não há roteamento local.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Slides ou PDF sobre SDN Data Plane (ex: curso Coursera Redes SDN)",
                                    "Mininet simulator para visualização básica"
                                  ],
                                  "tips": "Lembre-se: plano de dados é 'burro' por design, otimizado para velocidade.",
                                  "learningObjective": "Listar e descrever funções exclusivas do plano de dados em SDN.",
                                  "commonMistakes": "Incluir funções do controlador como funções do plano de dados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Mecanismo de Forwarding via Tabelas de Fluxo",
                                  "subSteps": [
                                    "Aprenda como tabelas de fluxo são estruturas com regras (match fields, actions, counters).",
                                    "Descreva o processo: pacote chega → match na tabela → action (forward, drop, etc.).",
                                    "Estude o protocolo OpenFlow para instalação de fluxos pelo controlador.",
                                    "Pratique descrevendo um fluxo exemplo: match porta origem → forward porta X."
                                  ],
                                  "verification": "Desenhe o fluxo de um pacote através de uma tabela de fluxo com match/action.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "OpenFlow Switch Specification (versão 1.3)",
                                    "Emulador Mininet + POX controller para teste hands-on"
                                  ],
                                  "tips": "Pense em tabelas de fluxo como regras de firewall avançadas, mas para forwarding.",
                                  "learningObjective": "Explicar passo a passo o forwarding stateless baseado em tabelas.",
                                  "commonMistakes": "Achar que switches SDN roteiam como routers IP; ignorar counters para estatísticas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Dependência Exclusiva do Controlador",
                                  "subSteps": [
                                    "Explique como o controlador programa tabelas via southbound API (OpenFlow).",
                                    "Discuta cenários de miss de fluxo: pacote para controlador (Packet-In).",
                                    "Destaque ausência de protocolos de roteamento locais (BGP, OSPF) nos switches.",
                                    "Simule uma falha no controlador e impactos no forwarding."
                                  ],
                                  "verification": "Responda a perguntas: 'O que acontece sem controlador?' e 'Como instalar uma regra?'",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tutorial Mininet SDN (mininet.org)",
                                    "Documentação Ryu/ONOS controllers"
                                  ],
                                  "tips": "Sem controlador = sem regras novas; use cache de fluxos para performance.",
                                  "learningObjective": "Compreender a dependência total das tabelas programadas externamente.",
                                  "commonMistakes": "Supor que switches SDN aprendem rotas automaticamente como STP."
                                }
                              ],
                              "practicalExample": "Em um data center, um switch SDN recebe um pacote HTTP de Host A para Host B. A tabela de fluxo tem regra: match dstIP=HostB → output porta 3. O pacote é forwardado instantaneamente sem consulta ao controlador, demonstrando forwarding stateless e dependência prévia de programação.",
                              "finalVerifications": [
                                "Explicar verbalmente o ciclo de forwarding de um pacote em SDN.",
                                "Desenhar e rotular um diagrama de tabela de fluxo com match/action.",
                                "Identificar 3 diferenças entre plano de dados SDN e switch tradicional.",
                                "Simular um Packet-In em um emulador como Mininet.",
                                "Listar funções do plano de dados sem mencionar lógica de controle."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do forwarding stateless (90% match com definição oficial).",
                                "Correta identificação de dependência exclusiva de tabelas de fluxo (sem menção a roteamento local).",
                                "Diagrama claro e completo da arquitetura e fluxo de pacotes.",
                                "Explicação fluida de Packet-In/Miss handling.",
                                "Uso correto de terminologia SDN/OpenFlow."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de controladores em Python (Ryu/POX).",
                                "Sistemas Operacionais: Conceitos de kernel/userspace semelhantes à separação planos.",
                                "Segurança da Informação: Regras de fluxo para ACLs dinâmicas.",
                                "Engenharia de Software: Abstração e modularidade na arquitetura SDN.",
                                "Matemática: Estruturas de dados como tries/TCAM para matching eficiente."
                              ],
                              "realWorldApplication": "Em redes de provedores de nuvem como Google ou AWS, switches SDN no plano de dados forwardam tráfego de VMs com baixa latência, permitindo escalabilidade global e gerenciamento centralizado de políticas de tráfego via controladores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Comparar plano de dados SDN com redes tradicionais",
                            "description": "Diferenciar o plano de dados em SDN (hardware simples e programável) do plano de dados em redes tradicionais (switches e roteadores com controle distribuído).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Plano de Dados em Redes Tradicionais",
                                  "subSteps": [
                                    "Defina o plano de dados como a camada responsável pelo forwarding de pacotes em switches e roteadores.",
                                    "Explique o controle distribuído: cada dispositivo executa protocolos de roteamento independentes como OSPF ou BGP.",
                                    "Descreva funções principais: lookup de tabelas de roteamento, processamento de pacotes e decisões locais.",
                                    "Identifique desafios: configuração manual complexa, escalabilidade limitada e lentidão em atualizações.",
                                    "Liste exemplos de hardware: switches Cisco com ASICs proprietários."
                                  ],
                                  "verification": "Crie um diagrama simples de uma rede tradicional com 3 switches e anote funções de cada um.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama em branco ou ferramenta como Draw.io",
                                    "Documentação básica de protocolos OSPF/BGP (PDF ou wiki)"
                                  ],
                                  "tips": "Comece com um exemplo pequeno de rede para visualizar o fluxo distribuído.",
                                  "learningObjective": "Compreender a arquitetura distribuída e suas limitações no plano de dados tradicional.",
                                  "commonMistakes": [
                                    "Confundir plano de dados com plano de controle",
                                    "Ignorar a dependência em protocolos proprietários"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Plano de Dados em SDN",
                                  "subSteps": [
                                    "Defina o plano de dados SDN como hardware simples e programável, focado apenas em forwarding.",
                                    "Descreva switches SDN: usam flow tables populadas pelo controlador via OpenFlow.",
                                    "Explique a separação: plano de dados 'burro' (apenas executa regras), controle centralizado.",
                                    "Destaque programabilidade: regras dinâmicas via APIs, sem necessidade de configurações locais.",
                                    "Compare hardware: switches commodity com chipsets abertos vs proprietários."
                                  ],
                                  "verification": "Liste 4 características únicas do hardware SDN e explique como o OpenFlow funciona.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre OpenFlow (YouTube, 10min)",
                                    "Especificação OpenFlow resumida (PDF)"
                                  ],
                                  "tips": "Pense no controlador como um 'cérebro' remoto que dita regras aos switches 'músculos'.",
                                  "learningObjective": "Dominar os princípios de simplicidade e programabilidade no plano de dados SDN.",
                                  "commonMistakes": [
                                    "Achar que SDN elimina hardware",
                                    "Confundir flow tables com tabelas de roteamento tradicionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Chave entre SDN e Tradicional",
                                  "subSteps": [
                                    "Compare arquitetura: distribuída (tradicional) vs centralizada (SDN).",
                                    "Analise simplicidade: hardware complexo e stateful (tradicional) vs simples e stateless (SDN).",
                                    "Avalie programabilidade: protocolos fixos (tradicional) vs APIs flexíveis (SDN).",
                                    "Discuta escalabilidade: atualizações lentas por dispositivo (tradicional) vs globais via controlador (SDN).",
                                    "Considere gerenciamento: manual e vendor-lock (tradicional) vs automatizado (SDN).",
                                    "Registre prós/contras em uma tabela comparativa."
                                  ],
                                  "verification": "Preencha uma tabela com pelo menos 5 diferenças em colunas: Aspecto, Tradicional, SDN.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Artigos comparativos SDN vs tradicional (online)"
                                  ],
                                  "tips": "Use categorias como 'controle', 'hardware' e 'gerenciamento' para estruturar a comparação.",
                                  "learningObjective": "Capacitar a diferenciação precisa entre os dois modelos de plano de dados.",
                                  "commonMistakes": [
                                    "Superestimar SDN como 'sem hardware'",
                                    "Ignorar latência no controlador SDN"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação em um Cenário Prático",
                                  "subSteps": [
                                    "Escolha um cenário: rede corporativa com pico de tráfego.",
                                    "Simule tradicional: configure cada switch manualmente para redirecionar tráfego.",
                                    "Simule SDN: envie regra única do controlador para todos switches.",
                                    "Meça diferenças: tempo de configuração, flexibilidade e erros potenciais.",
                                    "Crie um diagrama lado a lado mostrando o fluxo em ambos os casos."
                                  ],
                                  "verification": "Apresente diagramas e explique como SDN resolve problemas tradicionais no cenário.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (Draw.io ou Lucidchart)",
                                    "Simulador Mininet (opcional para demo)"
                                  ],
                                  "tips": "Foque em um problema real como balanceamento de carga para tornar concreto.",
                                  "learningObjective": "Integrar conhecimentos em análise comparativa aplicada.",
                                  "commonMistakes": [
                                    "Esquecer impacto na performance",
                                    "Não considerar falhas no controlador SDN"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um data center, uma falha de link ocorre. Em rede tradicional, administradores reconfiguram roteamento em múltiplos dispositivos via CLI (horas). Em SDN, o controlador detecta e atualiza flow tables em todos switches em segundos, minimizando downtime.",
                              "finalVerifications": [
                                "Liste 5 diferenças chave entre hardware SDN e tradicional.",
                                "Explique como OpenFlow habilita programabilidade no plano de dados SDN.",
                                "Descreva um cenário onde SDN supera redes tradicionais em gerenciamento.",
                                "Crie uma tabela comparativa precisa.",
                                "Identifique 3 limitações potenciais do SDN.",
                                "Compare escalabilidade em redes de 100+ switches."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas descrições de ambos os planos de dados (80%+ acurácia).",
                                "Profundidade da tabela comparativa (mínimo 5 aspectos cobertos).",
                                "Clareza nos diagramas e exemplos práticos.",
                                "Identificação correta de prós/contras de cada abordagem.",
                                "Capacidade de aplicar conceitos a cenários reais.",
                                "Ausência de confusões comuns como plano de controle vs dados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de linguagens como Python para controladores SDN (ex: Ryu, ONOS).",
                                "Segurança de Redes: SDN facilita políticas de segurança centralizadas vs distribuídas.",
                                "Arquitetura de Sistemas: Conceitos de desacoplamento semelhantes a microservices.",
                                "Análise de Dados: Monitoramento de tráfego via plano de dados SDN."
                              ],
                              "realWorldApplication": "Empresas como Google (B4 network) e provedores de cloud (AWS, Azure) usam SDN para otimizar tráfego em data centers globais, reduzindo custos operacionais em 40% via automação centralizada do plano de dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Descrever protocolos de comunicação no plano de dados",
                            "description": "Entender o papel do OpenFlow no plano de dados para instalação e gerenciamento de fluxos de tráfego pelos switches SDN.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de Plano de Dados em SDN",
                                  "subSteps": [
                                    "Defina SDN e seus planos principais: controle, aplicação e dados.",
                                    "Explique o papel do plano de dados: forwarding de pacotes nos switches.",
                                    "Identifique a necessidade de protocolos para comunicação entre controlador e switches.",
                                    "Diferencie plano de dados de plano de controle.",
                                    "Estude exemplos básicos de switches SDN compatíveis com OpenFlow."
                                  ],
                                  "verification": "Resuma em 3 frases o papel do plano de dados e liste 2 protocolos comuns.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama SDN básico",
                                    "Documentação SDN introductória (RFC ou site ONF)"
                                  ],
                                  "tips": "Use diagramas visuais para mapear fluxos de pacotes entre planos.",
                                  "learningObjective": "Entender a arquitetura SDN e o foco no plano de dados.",
                                  "commonMistakes": [
                                    "Confundir plano de dados com plano de controle",
                                    "Ignorar switches como dispositivos passivos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a estrutura e mensagens do protocolo OpenFlow",
                                  "subSteps": [
                                    "Analise a versão OpenFlow 1.3: header comum e tipos de mensagens (Controller-to-Switch, Asymmetric, Symmetric).",
                                    "Liste mensagens chave: OFPT_HELLO, OFPT_ERROR, OFPT_ECHO_REQUEST.",
                                    "Estude match fields (campos de correspondência) e actions em flow tables.",
                                    "Descreva o handshake inicial entre switch e controlador.",
                                    "Compare OpenFlow com protocolos tradicionais como SNMP."
                                  ],
                                  "verification": "Desenhe o header OpenFlow e identifique 4 tipos de mensagens.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Especificação OpenFlow 1.3 (PDF ONF)",
                                    "Ferramenta Wireshark para capturar tráfego OpenFlow"
                                  ],
                                  "tips": "Memorize o formato do header: version, type, length, xid.",
                                  "learningObjective": "Dominar as mensagens e estrutura básica do OpenFlow.",
                                  "commonMistakes": [
                                    "Confundir match com action",
                                    "Subestimar a importância do HELLO para negociação de versão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar instalação e gerenciamento de fluxos no plano de dados",
                                  "subSteps": [
                                    "Descreva o processo de instalação de fluxo: FlowMod mensagens (ADD, MODIFY, DELETE).",
                                    "Explique pipeline processing: table-miss, group tables, meters.",
                                    "Simule um fluxo: match em porta de entrada, action para encaminhar para porta específica.",
                                    "Discuta gerenciamento: timeouts, counters para estatísticas de fluxo.",
                                    "Estude remoção de fluxos reativos vs. proativos."
                                  ],
                                  "verification": "Crie um exemplo de FlowMod JSON/YAML para instalar um fluxo simples.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Mininet ou emulador SDN",
                                    "Documentação Ryu/ONOS controlador",
                                    "Editor de texto para flows"
                                  ],
                                  "tips": "Teste em Mininet para ver fluxos sendo instalados em tempo real.",
                                  "learningObjective": "Compreender como OpenFlow gerencia fluxos de tráfego.",
                                  "commonMistakes": [
                                    "Ignorar priorities em flow entries",
                                    "Confundir hard_timeout com idle_timeout"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar cenários práticos e limitações do OpenFlow",
                                  "subSteps": [
                                    "Simule um cenário de balanceamento de carga via OpenFlow.",
                                    "Discuta limitações: escalabilidade em switches com muitas tabelas.",
                                    "Explore extensões: P4 vs. OpenFlow para maior flexibilidade.",
                                    "Analise segurança: TLS para canais OpenFlow.",
                                    "Revise métricas de performance: latência de instalação de fluxo."
                                  ],
                                  "verification": "Explique um cenário onde OpenFlow falha e proponha solução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeos tutoriais SDN (YouTube/ONF)",
                                    "Artigo sobre limitações OpenFlow"
                                  ],
                                  "tips": "Considere sempre autenticação em ambientes reais.",
                                  "learningObjective": "Aplicar conhecimento em contextos reais e identificar gaps.",
                                  "commonMistakes": [
                                    "Superestimar velocidade de instalação em redes grandes",
                                    "Esquecer criptografia em comunicações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa, use OpenFlow para instalar um fluxo que redireciona todo tráfego HTTP (porta 80) de um servidor sobrecarregado para um balanceador de carga: match=dst_port=80, action=output=port3. Monitore counters para verificar hits.",
                              "finalVerifications": [
                                "Explique o papel do OpenFlow no plano de dados SDN.",
                                "Liste e descreva 5 mensagens OpenFlow principais.",
                                "Descreva o processo completo de instalação de um fluxo.",
                                "Identifique 3 match fields comuns e 2 actions.",
                                "Diferencie fluxos proativos e reativos.",
                                "Simule um erro comum em Wireshark."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de mensagens OpenFlow (80% correto).",
                                "Capacidade de diagramar fluxo de instalação (claro e completo).",
                                "Exemplos práticos viáveis e relevantes.",
                                "Identificação correta de erros comuns e soluções.",
                                "Conexão com conceitos SDN amplos.",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Scripts em Python com bibliotecas Ryu/POX para controladores.",
                                "Segurança de Redes: Autenticação e criptografia em canais OpenFlow.",
                                "Matemática: Algoritmos de roteamento e modelagem de tráfego.",
                                "Engenharia de Software: Design de APIs para SDN.",
                                "Física: Princípios de transmissão de dados em redes óticas."
                              ],
                              "realWorldApplication": "Em data centers como Google ou AWS, OpenFlow permite controladores centralizados instalarem fluxos dinâmicos para otimizar tráfego, reduzir latência e implementar QoS em tempo real, escalando para milhões de fluxos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Plano de Controle em SDN",
                        "description": "Componente lógico centralizado que gerencia a rede inteira, calculando rotas, instalando regras nos switches e monitorando o estado da rede, separado fisicamente do plano de dados.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Explicar a separação do plano de controle",
                            "description": "Descrever os benefícios da separação do plano de controle do plano de dados, como programação centralizada e abstração de hardware heterogêneo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os planos de controle e dados em redes tradicionais",
                                  "subSteps": [
                                    "Defina o plano de dados como o conjunto de switches e roteadores que encaminham pacotes.",
                                    "Descreva o plano de controle como as lógicas distribuídas em cada dispositivo para decisões de roteamento.",
                                    "Explique como, em redes tradicionais, esses planos estão acoplados em cada hardware.",
                                    "Ilustre com um diagrama simples de uma rede legacy.",
                                    "Compare o impacto dessa integração em termos de configuração manual."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando planos integrados e explique oralmente as limitações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; vídeo introdutório sobre redes tradicionais.",
                                  "tips": "Use analogias como 'cérebro e músculos' integrados em cada braço para simplificar.",
                                  "learningObjective": "Compreender a arquitetura integrada tradicional para contrastar com SDN.",
                                  "commonMistakes": "Confundir plano de dados com aplicação; ignorar a distribuição do controle."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a separação dos planos em SDN",
                                  "subSteps": [
                                    "Defina SDN como arquitetura que separa plano de controle (centralizado) do plano de dados (distribuído).",
                                    "Descreva o controlador SDN como entidade central que gerencia switches via protocolos como OpenFlow.",
                                    "Explique como switches tornam-se 'burros' (apenas forwarding) sob instrução do controlador.",
                                    "Desenhe um diagrama comparativo: tradicional vs. SDN.",
                                    "Liste protocolos chave: OpenFlow para comunicação controle-dados."
                                  ],
                                  "verification": "Crie um diagrama de SDN e rotule os componentes separados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta Draw.io ou Lucidchart; documentação OpenFlow básica.",
                                  "tips": "Pense no controlador como um maestro orquestrando uma orquestra de instrumentos (switches).",
                                  "learningObjective": "Visualizar e descrever a arquitetura de separação em SDN.",
                                  "commonMistakes": "Achar que separação elimina hardware; confundir controlador com servidor de aplicação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar benefícios da programação centralizada",
                                  "subSteps": [
                                    "Descreva como o controle central permite políticas globais de rede via APIs simples.",
                                    "Destaque simplificação: uma mudança no controlador afeta toda a rede instantaneamente.",
                                    "Discuta agilidade: deploy rápido de novas features sem tocar hardware.",
                                    "Exemplo: Implementar QoS centralizado para priorizar tráfego vídeo.",
                                    "Compare com tradicional: configs manuais em cada switch."
                                  ],
                                  "verification": "Escreva um script pseudo-código para uma política centralizada e explique seu impacto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de texto; exemplos de APIs SDN como RESTCONF ou NETCONF.",
                                  "tips": "Enfatize 'programável como software' vs. 'configurável como hardware'.",
                                  "learningObjective": "Identificar como centralização facilita programação e gerenciamento.",
                                  "commonMistakes": "Subestimar latência na comunicação controle-dados; ignorar escalabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar abstração de hardware heterogêneo",
                                  "subSteps": [
                                    "Defina abstração: controlador vê rede como abstração unificada, ignorando vendors.",
                                    "Explique compatibilidade: switches de diferentes fabricantes via southbound APIs padronizadas.",
                                    "Discuta portabilidade: apps de rede rodem independentemente de hardware subjacente.",
                                    "Exemplo: Migrar de Cisco para white-box switches sem reescrever lógica.",
                                    "Liste benefícios: redução de vendor lock-in e inovação rápida."
                                  ],
                                  "verification": "Descreva um cenário de rede multi-vendor e como SDN abstrai isso.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Casos de estudo SDN (ex: Google B4); lista de southbound protocols.",
                                  "tips": "Use metáfora de 'driver de impressora' para abstração de hardware.",
                                  "learningObjective": "Compreender como separação permite heterogeneidade sem complexidade.",
                                  "commonMistakes": "Confundir abstração com virtualização; achar que elimina diferenças de hardware."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com switches Cisco e Juniper misturados, o controlador SDN (ex: OpenDaylight) separa o controle: uma política de balanceamento de carga é programada centralmente via API Python, aplicando-se a todos switches via OpenFlow, sem configs manuais por vendor.",
                              "finalVerifications": [
                                "Defina precisamente plano de controle vs. plano de dados em SDN.",
                                "Desenhe e explique diagrama de separação SDN.",
                                "Liste 3 benefícios da programação centralizada com exemplos.",
                                "Explique abstração de hardware com cenário multi-vendor.",
                                "Compare SDN vs. tradicional em termos de gerenciamento.",
                                "Identifique protocolos como OpenFlow em contexto."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões.",
                                "Clareza na explicação: uso de diagramas e analogias eficazes.",
                                "Profundidade nos benefícios: cobertura completa de centralização e abstração.",
                                "Exemplos relevantes: práticos e contextualizados em SDN.",
                                "Compreensão comparativa: contraste claro com redes tradicionais.",
                                "Articulação verbal/escrita: fluida e estruturada."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Software: Padrões de separação de camadas (MVC-like).",
                                "Programação: Uso de APIs para controle centralizado (Python em controladores SDN).",
                                "Sistemas Distribuídos: Consistência e escalabilidade em sistemas centralizados.",
                                "Gestão de Projetos: Abstração reduzindo complexidade em infraestruturas grandes."
                              ],
                              "realWorldApplication": "Em data centers do Google (projeto B4), SDN separa controle para otimizar tráfego global, permitindo programação centralizada que abstrai milhares de switches heterogêneos, reduzindo latência e custos operacionais em provedores de cloud como AWS e Azure."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Identificar componentes do plano de controle",
                            "description": "Reconhecer o controlador SDN como elemento central, responsável por decisões de roteamento e políticas de rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a arquitetura básica de SDN e a separação de planos",
                                  "subSteps": [
                                    "Estude a definição de SDN e sua arquitetura em camadas (Application Plane, Control Plane, Data Plane).",
                                    "Identifique a separação entre plano de controle (decisões lógicas) e plano de dados (forwarding físico).",
                                    "Analise diagramas que mostram o fluxo de comunicação entre planos via protocolos como OpenFlow.",
                                    "Compare SDN com redes tradicionais para destacar a centralização do controle.",
                                    "Anote as vantagens da separação, como flexibilidade e programabilidade."
                                  ],
                                  "verification": "Crie um diagrama simples da arquitetura SDN e explique a separação de planos em um parágrafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documento oficial OpenFlow: opennetworking.org/sdn-resources",
                                    "Vídeo: 'SDN Explained' no YouTube (primeiros 10 min)",
                                    "Diagrama SDN básico (imprima ou desenhe)"
                                  ],
                                  "tips": "Use cores diferentes no diagrama para planos de controle (azul) e dados (verde) para visualização clara.",
                                  "learningObjective": "Dominar os conceitos fundamentais de SDN e a distinção entre planos de controle e dados.",
                                  "commonMistakes": "Confundir plano de controle com hardware físico; lembre-se que é lógico e centralizado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Controlador SDN como componente central",
                                  "subSteps": [
                                    "Defina o controlador SDN: software que gerencia a rede globalmente.",
                                    "Liste exemplos de controladores: OpenDaylight, ONOS, Ryu, Floodlight.",
                                    "Descreva sua posição central: recebe informações dos switches e envia comandos.",
                                    "Explore interfaces do controlador: northbound (para apps) e southbound (para switches).",
                                    "Registre responsabilidades principais: roteamento dinâmico e aplicação de políticas."
                                  ],
                                  "verification": "Liste 3 controladores SDN com uma função chave de cada e desenhe sua posição no diagrama SDN.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Site OpenDaylight: opendaylight.org",
                                    "Lista de controladores SDN no Wikipedia",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Pense no controlador como o 'cérebro' da rede: ele pensa, switches executam.",
                                  "learningObjective": "Reconhecer o controlador como núcleo do plano de controle e suas interfaces.",
                                  "commonMistakes": "Achar que o controlador roteia pacotes diretamente; ele instrui os switches."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar funções específicas do Controlador no plano de controle",
                                  "subSteps": [
                                    "Detalhe decisões de roteamento: calcular caminhos baseados em topologia e tráfego.",
                                    "Analise políticas de rede: QoS, balanceamento de carga, isolamento de tráfego.",
                                    "Estude coleta de estatísticas: monitoramento de fluxo via switches.",
                                    "Simule cenários: como o controlador responde a falhas ou picos de tráfego.",
                                    "Identifique outros componentes: aplicações northbound que estendem funcionalidades."
                                  ],
                                  "verification": "Escreva um fluxograma mostrando como o controlador toma uma decisão de roteamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tutorial Ryu Controller: ryu.readthedocs.io",
                                    "Simulador Mininet: mininet.org (instalação básica)",
                                    "Papel e caneta para fluxograma"
                                  ],
                                  "tips": "Use exemplos reais como 'bloquear tráfego suspeito' para tornar políticas tangíveis.",
                                  "learningObjective": "Entender funções práticas do controlador em roteamento e políticas.",
                                  "commonMistakes": "Ignorar northbound APIs; elas permitem customizações avançadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear todos os componentes do plano de controle em SDN",
                                  "subSteps": [
                                    "Liste componentes principais: Controlador central, controladores distribuídos (se aplicável), aplicações de rede.",
                                    "Descreva interações: controlador com switches via southbound, apps via northbound.",
                                    "Diferencie de plano de dados: switches SDN como dispositivos dumb.",
                                    "Crie um mapa mental completo do plano de controle.",
                                    "Teste conhecimento respondendo: 'Qual componente é responsável por políticas?'."
                                  ],
                                  "verification": "Construa um mapa mental ou tabela listando componentes, funções e interações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de mindmap online como MindMeister (gratuito)",
                                    "Artigo: 'SDN Control Plane Components' PDF"
                                  ],
                                  "tips": "Inclua setas no mapa para mostrar fluxos de controle (ex: stats up, rules down).",
                                  "learningObjective": "Identificar e inter-relacionar todos os componentes do plano de controle.",
                                  "commonMistakes": "Omitir aplicações northbound; plano de controle inclui lógica de alto nível."
                                }
                              ],
                              "practicalExample": "Em uma rede SDN de um data center usando controlador ONOS, o componente central identifica sobrecarga em um link, calcula novo caminho via algoritmos de roteamento e aplica política de QoS priorizando tráfego de vídeo, instruindo switches OpenFlow a forwarding os pacotes adequadamente.",
                              "finalVerifications": [
                                "Desenhar diagrama preciso do plano de controle destacando controlador.",
                                "Explicar verbalmente funções de roteamento e políticas do controlador.",
                                "Listar 3 controladores SDN com exemplos de uso.",
                                "Diferenciar corretamente plano de controle vs. plano de dados.",
                                "Simular em Mininet um comando básico do controlador alterando fluxo.",
                                "Identificar northbound/southbound APIs em um cenário dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do controlador como central (0-4 pontos).",
                                "Completude na listagem de funções (roteamento, políticas, monitoramento) (0-4 pontos).",
                                "Clareza em diagramas e mapas mentais (0-4 pontos).",
                                "Correta distinção de planos SDN (0-3 pontos).",
                                "Exemplos práticos relevantes e realistas (0-3 pontos).",
                                "Ausência de erros comuns como confusão com hardware (0-2 pontos)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de apps northbound usando Python em controladores como Ryu.",
                                "Segurança da Computação: Implementação de políticas de firewall centralizadas no controlador.",
                                "Matemática: Algoritmos de grafos para cálculo de rotas no plano de controle.",
                                "Gestão de Projetos: Modelagem de redes escaláveis em ambientes empresariais."
                              ],
                              "realWorldApplication": "Em provedores de telecomunicações como Verizon, controladores SDN gerenciam redes 5G dinamicamente, otimizando roteamento para milhões de dispositivos IoT e aplicando políticas de segurança em tempo real, reduzindo latência e custos operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Analisar fluxos de controle em SDN",
                            "description": "Mapear o processo de comunicação entre controlador e switches via protocolos como OpenFlow para atualização de tabelas de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de SDN e OpenFlow",
                                  "subSteps": [
                                    "Estude a arquitetura SDN: plano de dados (switches), plano de controle (controlador) e plano de aplicação.",
                                    "Identifique o papel do protocolo OpenFlow na comunicação southbound.",
                                    "Revise o modelo de pipeline de processamento de pacotes nos switches OpenFlow.",
                                    "Liste os principais componentes: datapath ID, match fields, actions e instructions.",
                                    "Desenhe um diagrama simples da topologia SDN básica."
                                  ],
                                  "verification": "Crie um diagrama anotado dos componentes SDN e OpenFlow; verifique se todos os elementos chave estão presentes e corretamente rotulados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação OpenFlow Switch Specification (versão 1.3+), diagramas de arquitetura SDN (ex: ONF.org), software de desenho como Draw.io.",
                                  "tips": "Use cores diferentes para planos de dados, controle e aplicação para facilitar a visualização.",
                                  "learningObjective": "Compreender a separação de planos em SDN e o papel do OpenFlow na comunicação controlador-switch.",
                                  "commonMistakes": "Confundir plano de controle com plano de dados; ignorar a versão do OpenFlow (use 1.3 ou superior para exemplos modernos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Classificar Mensagens de Controle OpenFlow",
                                  "subSteps": [
                                    "Liste mensagens do controlador para switch: Flow-Mod (add/modify/delete), Packet-Out.",
                                    "Liste mensagens do switch para controlador: Packet-In, Flow-Removed, Port-Status.",
                                    "Explique o handshake inicial: Hello, Features-Request/Reply, Set-Config.",
                                    "Analise o ciclo de vida de uma regra de fluxo: instalação via Flow-Mod e remoção.",
                                    "Registre exemplos de payloads para Flow-Mod (match + actions)."
                                  ],
                                  "verification": "Compile uma tabela com 5+ mensagens OpenFlow, suas direções e propósitos; valide contra especificação oficial.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Especificação OpenFlow (ONF.org), Wireshark com filtro OpenFlow, tabela em Excel ou Markdown.",
                                  "tips": "Agrupe mensagens por direção (controller-to-switch vs switch-to-controller) para melhor organização.",
                                  "learningObjective": "Dominar os tipos de mensagens usadas nos fluxos de controle para comunicação bidirecional.",
                                  "commonMistakes": "Omitir mensagens de status como Error ou Barrier-Request; confundir Flow-Mod com Group-Mod."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear o Processo de Comunicação para Atualização de Tabelas de Fluxo",
                                  "subSteps": [
                                    "Descreva o fluxo típico: pacote chega ao switch sem match → Packet-In ao controlador.",
                                    "Trace a resposta: controlador processa, envia Flow-Mod com match/action para instalar regra.",
                                    "Simule encaminhamento: próximo pacote matches a regra → action executada (ex: output para porta).",
                                    "Inclua timeouts: idle/hard timeouts em Flow-Mod e evento Flow-Removed.",
                                    "Diagrame sequência com ferramentas UML ou Mermaid para o ciclo completo."
                                  ],
                                  "verification": "Gere um diagrama de sequência mostrando Packet-In → Flow-Mod → processamento; confirme com simulação em ferramenta.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ferramenta de diagrama (Lucidchart ou PlantUML), emulador Mininet com controlador Ryu/POX.",
                                  "tips": "Use setas numeradas no diagrama para indicar ordem temporal e inclua timestamps simulados.",
                                  "learningObjective": "Mapear sequencialmente o fluxo de controle para instalação e uso de regras de fluxo.",
                                  "commonMistakes": "Ignorar o papel do Barrier-Message para sincronização; assumir comunicação unidirecional."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Analisar um Fluxo de Controle Completo",
                                  "subSteps": [
                                    "Configure ambiente Mininet: topologia simples (h1-s1-controller).",
                                    "Gere tráfego que trigger Packet-In (ex: ping novo host).",
                                    "Capture tráfego com tcpdump/Wireshark filtrando OpenFlow.",
                                    "Analise captura: identifique mensagens e atualizações na tabela de fluxo do switch (dpctl dump-flows).",
                                    "Documente variações: multipath com Group-Table ou meter para QoS."
                                  ],
                                  "verification": "Execute simulação, capture logs e explique 3+ mensagens chave em relatório curto.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Mininet, controlador Ryu/ONOS, Wireshark/tcpdump, terminal Linux/VM.",
                                  "tips": "Inicie com topologia mínima para evitar sobrecarga; use --topo linear,2 para simplicidade.",
                                  "learningObjective": "Aplicar análise prática para validar fluxos de controle em ambiente controlado.",
                                  "commonMistakes": "Não instalar controlador corretamente (ex: ryu-manager simple_switch_13); ignorar filtros de porta OpenFlow (6653/6633)."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa, um pacote HTTP de um host A para B chega ao switch sem regra: switch envia Packet-In ao controlador SDN. Controlador analisa (porta 80), envia Flow-Mod para encaminhar para porta 2 (B) com contador de bytes. Próximos pacotes são processados localmente, atualizando tabela de fluxo.",
                              "finalVerifications": [
                                "Diagrama completo do fluxo SDN com mensagens OpenFlow corretas.",
                                "Tabela de fluxo dump (dpctl) mostrando regra instalada após Packet-In.",
                                "Captura Wireshark validando sequência Packet-In → Flow-Mod.",
                                "Explicação escrita de um ciclo completo sem erros conceituais.",
                                "Identificação correta de 5+ tipos de mensagens em contexto.",
                                "Simulação funcional em Mininet sem falhas de configuração."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 100% das mensagens e papéis corretos (30%).",
                                "Completude do mapeamento: todos passos do fluxo cobertos (25%).",
                                "Qualidade de diagramas e simulações: claros e executáveis (20%).",
                                "Análise de erros comuns evitados (15%).",
                                "Documentação prática com exemplos reais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar lógica de controlador em Python (Ryu/POX).",
                                "Segurança de Redes: Análise de fluxos para detecção de intrusões via controlador.",
                                "Sistemas Operacionais: Gerenciamento de kernel modules em switches (OVS).",
                                "Matemática: Modelagem de grafos para topologias SDN."
                              ],
                              "realWorldApplication": "Em data centers como Google B4 ou provedores 5G (ex: Nokia/ Ericsson SDN), controladores centralizados usam OpenFlow para roteamento dinâmico de tráfego, otimizando latência e balanceamento de carga em tempo real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Arquitetura Geral e Programação em SDN",
                        "description": "Visão integrada da arquitetura SDN, enfatizando a programação centralizada da rede para automação, escalabilidade e inovação em serviços de rede.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Desenhar a arquitetura SDN completa",
                            "description": "Representar diagramaticamente os planos de dados, controle e aplicação, mostrando interfaces como southbound (ex: OpenFlow) e northbound APIs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes fundamentais da arquitetura SDN",
                                  "subSteps": [
                                    "Estude a definição de SDN e seus três planos principais: Dados, Controle e Aplicação.",
                                    "Identifique os elementos chave: switches (data plane), controlador SDN (control plane) e aplicações (application plane).",
                                    "Liste as interfaces: southbound (ex: OpenFlow para comunicação dados-controle) e northbound (APIs REST para controle-aplicação).",
                                    "Revise exemplos reais como OpenDaylight ou ONOS.",
                                    "Anote fluxos de dados: pacotes do data plane para o controlador via southbound, e regras de forwarding de volta."
                                  ],
                                  "verification": "Criar uma lista anotada com todos os componentes e interfaces corretamente identificados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet para diagramas SDN oficiais",
                                    "Papel e caneta ou ferramenta digital como draw.io"
                                  ],
                                  "tips": "Use diagramas oficiais do ONF (Open Networking Foundation) como referência visual inicial.",
                                  "learningObjective": "Dominar a estrutura conceitual da arquitetura SDN para basear o desenho.",
                                  "commonMistakes": [
                                    "Confundir planos (ex: achar que switches fazem controle)",
                                    "Ignorar interfaces específicas como OpenFlow"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar o Plano de Dados (Data Plane)",
                                  "subSteps": [
                                    "Desenhe switches ou dispositivos de rede no fundo do diagrama.",
                                    "Represente fluxos de pacotes de entrada/saída nos switches.",
                                    "Indique tabelas de fluxo (flow tables) onde regras de forwarding são aplicadas.",
                                    "Marque conexões para hosts ou redes externas.",
                                    "Adicione setas bidirecionais para tráfego de dados."
                                  ],
                                  "verification": "Verificar se o data plane isolado mostra switches com flow tables e fluxos de pacotes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de desenho: draw.io, Lucidchart ou papel quadriculado"
                                  ],
                                  "tips": "Use ícones padronizados (ex: retângulos para switches) para clareza.",
                                  "learningObjective": "Visualizar o data plane como executor passivo de regras.",
                                  "commonMistakes": [
                                    "Desenhar switches com lógica de controle embutida",
                                    "Omitir tabelas de fluxo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar o Plano de Controle e interfaces southbound",
                                  "subSteps": [
                                    "Posicione o controlador SDN acima do data plane.",
                                    "Desenhe setas southbound (ex: OpenFlow) do controlador para switches.",
                                    "Indique funções do controlador: coleta de estatísticas, instalação de regras de fluxo.",
                                    "Represente comunicação segura (ex: TLS no OpenFlow).",
                                    "Adicione múltiplos controladores para redundância se aplicável."
                                  ],
                                  "verification": "Confirmar setas southbound conectando controlador a todos os switches com labels como 'OpenFlow'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referências OpenFlow specification PDF",
                                    "Ferramenta de desenho"
                                  ],
                                  "tips": "Use setas grossas para southbound para diferenciar de outros fluxos.",
                                  "learningObjective": "Entender o papel central do controlador na orquestração.",
                                  "commonMistakes": [
                                    "Invertar direção das interfaces southbound",
                                    "Esquecer estatísticas de fluxo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenhar o Plano de Aplicação e interfaces northbound",
                                  "subSteps": [
                                    "Coloque aplicações acima do controlador.",
                                    "Desenhe APIs northbound (ex: REST/JSON) como setas do controlador para apps.",
                                    "Exemplifique apps: balanceador de carga, firewall virtual, roteador de caminhos.",
                                    "Mostre como apps enviam políticas de alto nível para o controlador.",
                                    "Indique feedback de telemetria das apps."
                                  ],
                                  "verification": "Verificar presença de pelo menos 2-3 apps com setas northbound rotuladas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de controladores como ONOS",
                                    "Ferramenta de desenho"
                                  ],
                                  "tips": "Agrupe apps em uma caixa 'Application Plane' para organização.",
                                  "learningObjective": "Compreender abstração de rede via APIs programáveis.",
                                  "commonMistakes": [
                                    "Confundir northbound com southbound",
                                    "Não especificar tipo de API"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar o diagrama completo e adicionar anotações",
                                  "subSteps": [
                                    "Una todos os planos em um diagrama coeso com camadas verticais.",
                                    "Adicione legendas para ícones, interfaces e fluxos.",
                                    "Inclua exemplos de fluxo: pacote desconhecido -> controlador -> regra instalada.",
                                    "Revise por completude e clareza.",
                                    "Exporte ou fotografe o diagrama final."
                                  ],
                                  "verification": "Diagrama final deve ter todos os elementos interconectados sem ambiguidades.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de desenho com export PDF",
                                    "Checklist de componentes SDN"
                                  ],
                                  "tips": "Use cores diferentes para cada plano (ex: azul data, verde controle, laranja app).",
                                  "learningObjective": "Criar uma representação holística e comunicável da arquitetura SDN.",
                                  "commonMistakes": [
                                    "Diagrama desorganizado ou ilegível",
                                    "Falta de legendas"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenhe a arquitetura SDN para uma rede corporativa simples: 4 switches OpenFlow conectados a hosts, um controlador central OpenDaylight recebendo fluxos via southbound OpenFlow, e duas aplicações northbound (balanceador de carga HTTP e monitor de tráfego) enviando políticas via REST APIs. Mostre um fluxo exemplo onde um pacote novo vai ao controlador e retorna uma regra de forwarding.",
                              "finalVerifications": [
                                "Diagrama inclui os três planos SDN claramente separados?",
                                "Interfaces southbound (ex: OpenFlow) estão corretamente posicionadas e rotuladas?",
                                "Interfaces northbound (ex: APIs) conectam controlador a aplicações?",
                                "Fluxos de dados e controle são representados com setas direcionais?",
                                "Legenda explica todos os ícones e elementos?",
                                "Exemplo de fluxo end-to-end está ilustrado?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Todos os componentes SDN corretos e posicionados?",
                                "Clareza visual: Diagrama legível, com cores, setas e labels adequados?",
                                "Completude: Ausência de omissões em planos ou interfaces?",
                                "Detalhamento: Tabelas de fluxo, exemplos de apps e fluxos mostrados?",
                                "Originalidade: Representação criativa mas fiel à arquitetura padrão?",
                                "Profissionalismo: Formato limpo, pronto para apresentação"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de aplicações SDN usando linguagens como Python para northbound APIs.",
                                "Segurança da Informação: Implementação de políticas de segurança no controlador SDN.",
                                "Matemática: Modelagem de grafos para topologias de rede e algoritmos de roteamento.",
                                "Gestão de Projetos: Planejamento de deployment SDN em ambientes empresariais.",
                                "Engenharia de Software: Abordagens modulares semelhantes a microservices."
                              ],
                              "realWorldApplication": "Em data centers como o Google B4 para otimização dinâmica de tráfego, em redes 5G para orquestração de slices de rede, ou em provedores de cloud como AWS para gerenciamento programático de switches virtuais, permitindo escalabilidade e automação em larga escala."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1",
                              "10.1.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Explicar vantagens da programação centralizada",
                            "description": "Discutir como SDN permite controle global, otimização de recursos, suporte a virtualização de rede e facilidades para novos protocolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Programação Centralizada em SDN",
                                  "subSteps": [
                                    "Defina programação centralizada como o controle unificado de switches e roteadores via um controlador SDN central.",
                                    "Compare com redes tradicionais distribuídas, destacando decisões locais vs. visão global.",
                                    "Identifique componentes chave: plano de dados (switches), plano de controle (controlador) e plano de aplicação.",
                                    "Estude um diagrama simples de arquitetura SDN para visualizar o fluxo.",
                                    "Anote diferenças em termos de escalabilidade e simplicidade de gerenciamento."
                                  ],
                                  "verification": "Crie um diagrama comparativo entre SDN centralizada e rede tradicional, explicando o papel do controlador.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama de arquitetura SDN (impresso ou digital)",
                                    "Vídeo introdutório sobre SDN (ex: YouTube - SDN Basics)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'maestro de orquestra' para o controlador para facilitar a compreensão.",
                                  "learningObjective": "Diferenciar programação centralizada de distribuída e identificar componentes SDN.",
                                  "commonMistakes": [
                                    "Confundir controlador com switch",
                                    "Ignorar a separação de planos em SDN"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar a Vantagem de Controle Global",
                                  "subSteps": [
                                    "Descreva como o controlador SDN tem visão completa da topologia de rede via protocolos como OpenFlow.",
                                    "Discuta cenários onde decisões globais evitam loops ou congestionamentos locais.",
                                    "Simule um exemplo: balanceamento de carga em tempo real monitorando todo o tráfego.",
                                    "Liste benefícios: consistência de políticas, resposta rápida a falhas e segurança unificada.",
                                    "Pesquise casos reais de controle global em SDN."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o controle global previne um congestionamento em uma rede de 10 switches.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de simulação SDN como Mininet",
                                    "Documentação OpenFlow",
                                    "Artigos sobre casos de uso SDN"
                                  ],
                                  "tips": "Pense em termos de 'visão de pássaro' vs. 'visão de formiga' para ilustrar o controle global.",
                                  "learningObjective": "Articular como o controle global melhora gerenciamento e resiliência de rede.",
                                  "commonMistakes": [
                                    "Subestimar a latência de comunicação controlador-switch",
                                    "Confundir com centralização de hardware"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Otimização de Recursos e Suporte a Virtualização",
                                  "subSteps": [
                                    "Explique otimização: algoritmo central calcula caminhos eficientes baseados em métricas globais (ex: menor latência).",
                                    "Discuta virtualização de rede (Network Virtualization): múltiplas redes lógicas sobre hardware físico via SDN.",
                                    "Exemplo: slicing de rede para IoT vs. vídeo streaming com QoS diferente.",
                                    "Calcule um exemplo simples de economia de banda com otimização central.",
                                    "Compare métricas: uso de CPU e energia em SDN vs. tradicional."
                                  ],
                                  "verification": "Desenhe um cenário de virtualização onde SDN otimiza recursos para duas aplicações simultâneas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulador Mininet ou GNS3",
                                    "Planilhas para cálculos de otimização",
                                    "Leitura: 'SDN and Network Virtualization'"
                                  ],
                                  "tips": "Use gráficos de before/after para mostrar ganhos de eficiência.",
                                  "learningObjective": "Demonstrar impacto da centralização em eficiência e flexibilidade de rede.",
                                  "commonMistakes": [
                                    "Ignorar overhead de sinalização",
                                    "Confundir virtualização de rede com virtualização de servidores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Facilidades para Novos Protocolos e Síntese das Vantagens",
                                  "subSteps": [
                                    "Descreva como SDN permite programação via APIs (ex: REST, Northbound), facilitando novos protocolos sem hardware changes.",
                                    "Exemplo: implementar protocolo customizado para 5G slicing via controlador.",
                                    "Liste inovações: P4 para programação de dados plane, auto-adaptação via ML.",
                                    "Sintetize todas as vantagens em um quadro comparativo.",
                                    "Debata limitações potenciais para visão equilibrada."
                                  ],
                                  "verification": "Crie uma tabela resumindo as 4 vantagens principais com exemplos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Documentação P4 e REST APIs SDN",
                                    "Quadro comparativo template",
                                    "Vídeo sobre programação SDN avançada"
                                  ],
                                  "tips": "Foco em agilidade: 'programar rede como software' acelera inovação.",
                                  "learningObjective": "Explicar como SDN acelera adoção de novos protocolos e integrar todas as vantagens.",
                                  "commonMistakes": [
                                    "Superestimar simplicidade sem considerar segurança do controlador",
                                    "Esquecer dependência de software atualizado"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um data center de uma empresa de streaming, SDN centralizado monitora tráfego global, otimiza rotas para priorizar vídeos HD (virtualização), detecta falhas instantaneamente (controle global), economiza 30% de banda e permite teste rápido de protocolo multicast customizado sem downtime.",
                              "finalVerifications": [
                                "Liste e explique corretamente as quatro vantagens principais da programação centralizada.",
                                "Forneça um exemplo prático para cada vantagem.",
                                "Compare SDN com rede tradicional em termos de gerenciamento.",
                                "Desenhe um diagrama mostrando fluxo de controle em SDN.",
                                "Discuta uma limitação real da abordagem centralizada.",
                                "Explique como SDN suporta virtualização de rede."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na definição de programação centralizada (20%)",
                                "Profundidade na explicação de cada vantagem com exemplos (30%)",
                                "Uso de analogias ou diagramas para ilustrar conceitos (15%)",
                                "Integração de conexões interdisciplinares (10%)",
                                "Capacidade de sintetizar vantagens em contexto real (15%)",
                                "Identificação de erros comuns e limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos de otimização de grafos para rotas eficientes.",
                                "Administração: Gerenciamento centralizado similar a supply chain logística.",
                                "Física: Analogia com controle central em sistemas elétricos inteligentes (smart grids).",
                                "Economia: Análise custo-benefício de otimização de recursos de rede."
                              ],
                              "realWorldApplication": "Empresas como Google e Facebook usam SDN (ex: OpenFlow em data centers) para gerenciar tráfego global, reduzindo custos operacionais em 40% e habilitando serviços como Google B4 para interconexão de WAN com otimização dinâmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1",
                              "10.1.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Comparar SDN com modelo TCP/IP tradicional no nível de rede",
                            "description": "Analisar diferenças entre roteamento distribuído (IP tradicional) e controle centralizado em SDN, destacando impactos em desempenho e gerenciamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo TCP/IP tradicional no nível de rede (roteamento distribuído)",
                                  "subSteps": [
                                    "Estude a camada de rede do modelo TCP/IP, focando em IP (IPv4/IPv6).",
                                    "Analise protocolos de roteamento distribuído como OSPF, BGP e RIP.",
                                    "Desenhe diagramas de switches/routers trocando mensagens de roteamento autonomamente.",
                                    "Identifique como cada dispositivo mantém tabelas de roteamento locais baseadas em algoritmos.",
                                    "Simule um cenário simples de convergência de roteamento após falha de link."
                                  ],
                                  "verification": "Crie um diagrama anotado mostrando fluxo de decisões distribuídas e liste 3 protocolos chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Computer Networking: A Top-Down Approach' (cap. 4)",
                                    "Diagramas online de OSPF",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Comece com exemplos visuais para fixar conceitos distribuídos antes de SDN.",
                                  "learningObjective": "Compreender como o roteamento distribuído opera sem coordenação central.",
                                  "commonMistakes": [
                                    "Confundir camada de rede com enlace",
                                    "Ignorar overhead de mensagens de roteamento",
                                    "Achar que todos os dispositivos têm visão global"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a arquitetura SDN e controle centralizado",
                                  "subSteps": [
                                    "Defina os planos SDN: Data Plane (switches), Control Plane (controller), Application Plane.",
                                    "Estude protocolos como OpenFlow para comunicação controller-switch.",
                                    "Desenhe arquitetura SDN com controller central gerenciando fluxos.",
                                    "Compare switches SDN (flow-based) vs. tradicionais (packet-by-packet).",
                                    "Instale e explore um controller simples como Ryu ou ONOS em ambiente virtual."
                                  ],
                                  "verification": "Monte um diagrama da arquitetura SDN de 3 planos e explique OpenFlow em 1 parágrafo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação OpenFlow.org",
                                    "Mininet para simulação SDN",
                                    "Tutorial Ryu Controller"
                                  ],
                                  "tips": "Use Mininet para visualizar o controle central em ação rapidamente.",
                                  "learningObjective": "Dominar os componentes e fluxo de controle centralizado em SDN.",
                                  "commonMistakes": [
                                    "Confundir data plane com control plane",
                                    "Subestimar latência controller-switch",
                                    "Achar SDN sem estado nos switches"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar estruturas e mecanismos chave entre SDN e TCP/IP tradicional",
                                  "subSteps": [
                                    "Liste diferenças em controle: distribuído (TCP/IP) vs. centralizado (SDN).",
                                    "Compare roteamento: tabelas locais/dinâmicas vs. fluxos programáticos.",
                                    "Analise escalabilidade: convergência lenta em grandes redes vs. atualizações globais rápidas.",
                                    "Discuta flexibilidade: rígida em IP vs. programável em SDN.",
                                    "Crie uma tabela comparativa com colunas: Aspecto, TCP/IP, SDN."
                                  ],
                                  "verification": "Produza uma tabela comparativa com pelo menos 6 aspectos e justificativas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel",
                                    "Artigos IEEE sobre SDN vs. traditional networking"
                                  ],
                                  "tips": "Use tabela para estruturar comparações e evitar omissões.",
                                  "learningObjective": "Identificar diferenças fundamentais em arquitetura e operação.",
                                  "commonMistakes": [
                                    "Focar só em vantagens SDN ignorando limitações",
                                    "Confundir SDN com overlay networks",
                                    "Não quantificar diferenças (ex: latência)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impactos em desempenho e gerenciamento",
                                  "subSteps": [
                                    "Avalie desempenho: gargalo central SDN vs. overhead distribuído IP.",
                                    "Discuta gerenciamento: configuração manual IP vs. APIs SDN.",
                                    "Simule cenários: falha em rede IP (reconvergência) vs. SDN (reativo/proativo).",
                                    "Calcule métricas qualitativas: throughput, latência, tempo de setup de fluxo.",
                                    "Conclua prós/contras em contextos como data centers vs. WANs."
                                  ],
                                  "verification": "Escreva relatório de 300 palavras com impactos e um cenário simulado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Mininet + Wireshark para métricas",
                                    "Papers sobre performance SDN (ex: SIGCOMM)"
                                  ],
                                  "tips": "Meça com ferramentas reais para dados concretos, não só teoria.",
                                  "learningObjective": "Avaliar trade-offs práticos de cada abordagem.",
                                  "commonMistakes": [
                                    "Generalizar sem contexto (ex: SDN sempre melhor)",
                                    "Ignorar single point of failure no controller",
                                    "Não considerar custo de migração"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 50 switches, use Mininet para simular: no modo TCP/IP tradicional, uma falha de link causa 30s de reconvergência OSPF afetando tráfego VoIP; em SDN, o controller redireciona fluxos em <1s via OpenFlow, minimizando perda de pacotes.",
                              "finalVerifications": [
                                "Pode listar e explicar 5 diferenças principais entre SDN e roteamento IP tradicional.",
                                "Cria diagramas precisos de ambas arquiteturas.",
                                "Simula um cenário comparativo em Mininet com métricas de desempenho.",
                                "Discute trade-offs em gerenciamento sem viés.",
                                "Identifica cenários onde cada modelo é superior.",
                                "Explica impactos em protocolos como OpenFlow vs. OSPF."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas diferenças arquiteturais (30%)",
                                "Profundidade na análise de impactos em desempenho (25%)",
                                "Uso de exemplos/simulações concretas (20%)",
                                "Clareza na tabela/diagrama comparativo (15%)",
                                "Consideração equilibrada de prós/contras (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de APIs SDN (Python em Ryu/ONOS) liga a Redes e Desenvolvimento de Software.",
                                "Segurança: SDN facilita políticas de segurança centralizadas, conecta a Cibersegurança.",
                                "Matemática: Modelos de grafos para roteamento distribuído vs. otimização linear em SDN.",
                                "Gestão: SDN como paradigma de DevOps em TI, liga a Administração de Sistemas."
                              ],
                              "realWorldApplication": "Em data centers do Google (Jupiter network), SDN centralizado otimiza tráfego global reduzindo latência em 30% vs. roteamento tradicional; telcos como Verizon usam SDN para orquestração dinâmica de serviços 5G."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1",
                              "10.1.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.4",
                            "name": "Referenciar fontes bibliográficas de SDN",
                            "description": "Consultar e citar conceitos de livros como Tanenbaum/Wetherall, Kurose/Ross e Nadeau/Gray para embasar o entendimento de SDN.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Obter Fontes Bibliográficas Principais de SDN",
                                  "subSteps": [
                                    "Pesquise os livros recomendados: 'Computer Networks' de Tanenbaum/Wetherall, 'Computer Networking: A Top-Down Approach' de Kurose/Ross e 'Software Defined Networks: A Comprehensive Approach' de Nadeau/Gray.",
                                    "Verifique edições mais recentes disponíveis em bibliotecas digitais como Google Books, IEEE Xplore ou Amazon preview.",
                                    "Anote ISBNs, autores e anos de publicação para referência futura.",
                                    "Baixe ou acesse capítulos introdutórios gratuitamente disponíveis ou resumos acadêmicos.",
                                    "Crie uma lista inicial de 3-5 fontes adicionais relacionadas a SDN via Google Scholar."
                                  ],
                                  "verification": "Lista de fontes com detalhes bibliográficos completa e acessível.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Acesso à internet, Google Scholar, biblioteca universitária, PDF readers.",
                                  "tips": "Priorize edições pós-2012 para cobertura atual de SDN.",
                                  "learningObjective": "Compreender a importância de fontes autoritativas em SDN.",
                                  "commonMistakes": "Usar fontes desatualizadas ou não acadêmicas como blogs sem verificação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e Ler Seções Relevantes sobre SDN",
                                  "subSteps": [
                                    "No livro de Tanenbaum/Wetherall, leia capítulos sobre redes modernas e controle distribuído (ex: Cap. 5 ou equivalente).",
                                    "Em Kurose/Ross, foque em seções de arquitetura de rede e SDN (Cap. 9 em edições recentes).",
                                    "Em Nadeau/Gray, estude capítulos iniciais sobre arquitetura SDN e OpenFlow.",
                                    "Destaque conceitos chave como plano de controle, plano de dados e separação de planos.",
                                    "Registre páginas exatas e resuma em 1-2 parágrafos por livro."
                                  ],
                                  "verification": "Resumos anotados com referências de página para cada livro.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Cópias dos livros (físico/digital), caderno de notas ou ferramenta como Notion/Evernote.",
                                  "tips": "Use Ctrl+F para buscar 'SDN' ou 'Software-Defined' nos PDFs.",
                                  "learningObjective": "Extrair conceitos fundamentais de SDN de fontes primárias.",
                                  "commonMistakes": "Ler superficialmente sem anotar páginas específicas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair Conceitos e Praticar Citações Iniciais",
                                  "subSteps": [
                                    "Selecione 3 conceitos SDN (ex: controlador centralizado de Tanenbaum, fluxos em OpenFlow de Nadeau).",
                                    "Escreva citações no formato APA ou IEEE: ex: (Tanenbaum & Wetherall, 2011, p. 456).",
                                    "Crie cartões de estudo com conceito + citação + explicação breve.",
                                    "Compare conceitos entre livros para identificar convergências/divergências.",
                                    "Formate uma bibliografia preliminar com as 3 fontes principais."
                                  ],
                                  "verification": "5 cartões de estudo com citações corretas e bibliografia formatada.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ferramentas de citação como Zotero ou Mendeley, modelo APA/IEEE.",
                                  "tips": "Use gerenciadores de referências para automação.",
                                  "learningObjective": "Dominar formatação de citações acadêmicas para SDN.",
                                  "commonMistakes": "Citar incorretamente autores ou páginas, ou plagiar sem parafrasear."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Citações em um Contexto Prático SDN",
                                  "subSteps": [
                                    "Escreva um parágrafo explicando arquitetura SDN citando os 3 livros.",
                                    "Inclua pelo menos uma citação por fonte em um relatório curto (300 palavras).",
                                    "Adicione glossário com termos citados.",
                                    "Revise para fluidez e precisão conceitual.",
                                    "Compartilhe draft com peer para feedback inicial."
                                  ],
                                  "verification": "Relatório curto com citações integradas e sem erros.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Editor de texto (Google Docs/LaTeX), guia de estilo de citação.",
                                  "tips": "Integre citações naturalmente, não como lista.",
                                  "learningObjective": "Aplicar referências para embasar argumentos SDN.",
                                  "commonMistakes": "Sobrecarregar texto com citações excessivas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Refinar Referências Finais",
                                  "subSteps": [
                                    "Cheque precisão factual cruzando com fontes originais.",
                                    "Valide formatação com ferramentas online (ex: Citation Machine).",
                                    "Adicione DOIs ou links permanentes se disponíveis.",
                                    "Simule revisão por professor: corrija ambiguidades.",
                                    "Atualize bibliografia completa."
                                  ],
                                  "verification": "Referências validadas e relatório final polido.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Ferramentas de verificação de citação, acesso aos livros.",
                                  "tips": "Sempre cite a edição exata usada.",
                                  "learningObjective": "Garantir integridade acadêmica em referências SDN.",
                                  "commonMistakes": "Ignorar atualizações em edições novas."
                                }
                              ],
                              "practicalExample": "Em um relatório sobre SDN, cite: 'A separação entre plano de controle e dados, como descrito por Nadeau e Gray (2014, p. 23), permite programação dinâmica, complementando a visão de Tanenbaum e Wetherall (2011, Cap. 4) sobre redes programáveis.'",
                              "finalVerifications": [
                                "Todas citações incluem autor, ano e página/edition correta.",
                                "Conceitos SDN extraídos são precisos e relevantes.",
                                "Bibliografia formatada consistentemente (APA/IEEE).",
                                "Integração fluida sem plágio detectável.",
                                "Fontes acessíveis e verificadas por DOI/link.",
                                "Pelo menos 3 fontes principais usadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das citações (30%): Sem erros em autores/páginas.",
                                "Relevância dos conceitos SDN citados (25%): Alinhados à arquitetura SDN.",
                                "Qualidade da integração textual (20%): Fluida e embasadora.",
                                "Formatação bibliográfica (15%): Padrão acadêmico.",
                                "Profundidade de análise comparativa (10%): Conexões entre fontes."
                              ],
                              "crossCurricularConnections": [
                                "Pesquisa Acadêmica: Técnicas de revisão bibliográfica.",
                                "Escrita Técnica: Redação de relatórios em Computação.",
                                "Gestão de Conhecimento: Uso de ferramentas como Zotero.",
                                "Ética Profissional: Evitar plágio em engenharia de redes."
                              ],
                              "realWorldApplication": "Em projetos de rede corporativa, referenciar esses livros embasa propostas SDN para gerentes, como justificar OpenFlow em relatórios para migração de data centers tradicionais para SDN controlados por controladores como ONOS ou Ryu."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1",
                              "10.1.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Algoritmos de Roteamento",
                    "description": "Algoritmos como distância-vetor e estado de enlace para cálculo de rotas ótimas em redes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Roteamento Distância-Vetor",
                        "description": "Algoritmo de roteamento que utiliza trocas periódicas de tabelas de roteamento entre vizinhos, calculando distâncias mínimas com base no algoritmo de Bellman-Ford, exemplificado pelo protocolo RIP.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Descrever o princípio de operação do algoritmo Distância-Vetor",
                            "description": "Explicar como os roteadores trocam vetores de distância para destinos conhecidos, atualizando tabelas locais com o menor custo via vizinhos, incluindo o uso da equação de relaxamento de Bellman-Ford.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos do Algoritmo Distância-Vetor",
                                  "subSteps": [
                                    "Definir vetor de distância como uma lista de pares (destino, custo mínimo conhecido).",
                                    "Explicar a tabela de roteamento: colunas para destino, custo e próximo salto.",
                                    "Identificar vizinhos diretos e seus custos iniciais.",
                                    "Entender estado inicial: apenas rotas diretas com custo do link.",
                                    "Diferenciar de algoritmos link-state, focando em distâncias agregadas."
                                  ],
                                  "verification": "Criar e desenhar uma tabela de roteamento inicial para um roteador com 2 vizinhos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de rede simples"
                                  ],
                                  "tips": "Visualize uma rede linear com 3 nós para fixar conceitos iniciais.",
                                  "learningObjective": "Identificar e descrever os componentes fundamentais da tabela de roteamento em DV.",
                                  "commonMistakes": [
                                    "Confundir vetor de distância com tabela de roteamento completa",
                                    "Ignorar que custos podem ser assimétricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processo de Troca de Vetores de Distância entre Roteadores",
                                  "subSteps": [
                                    "Descrever envio periódico: roteadores broadcastam vetores para todos vizinhos.",
                                    "Explicar formato da mensagem: lista de (destino, distância atual).",
                                    "Simular envio de um roteador A para vizinho B.",
                                    "Detalhar recepção: B recebe e armazena temporariamente o vetor de A.",
                                    "Mencionar intervalo típico: 30 segundos no RIP."
                                  ],
                                  "verification": "Desenhar setas de troca de mensagens entre 2 roteadores e listar conteúdos enviados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Marcadores coloridos para mensagens"
                                  ],
                                  "tips": "Use cores diferentes para vetores de cada roteador para facilitar visualização.",
                                  "learningObjective": "Explicar o mecanismo de propagação assíncrona de informações de roteamento.",
                                  "commonMistakes": [
                                    "Achar que troca é síncrona ou sob demanda",
                                    "Esquecer que apenas vizinhos recebem diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atualização Local via Equação de Relaxamento de Bellman-Ford",
                                  "subSteps": [
                                    "Apresentar equação: para cada destino x, D(x) = min(D(x), D_y(x) + custo(y, roteador atual)) onde y é vizinho.",
                                    "Explicar relaxamento: testar se caminho via vizinho melhora distância conhecida.",
                                    "Atualizar custo e próximo salto se melhorado.",
                                    "Processar todos destinos do vetor recebido em uma única atualização.",
                                    "Exemplo: se via B custo para C é 3 + 1 = 4 < atual 5, atualizar para 4 via B."
                                  ],
                                  "verification": "Aplicar equação manualmente em uma tabela recebida e mostrar tabela atualizada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela impressa de exemplo"
                                  ],
                                  "tips": "Escreva a equação em um post-it para consultar durante cálculos.",
                                  "learningObjective": "Aplicar corretamente o relaxamento de Bellman-Ford para atualizar rotas.",
                                  "commonMistakes": [
                                    "Usar custo total em vez de incremental",
                                    "Não atualizar próximo salto corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Convergência, Mudanças e Problemas do Algoritmo",
                                  "subSteps": [
                                    "Descrever iterações: trocas e atualizações repetem até estabilidade em todas tabelas.",
                                    "Explicar convergência para caminhos ótimos em redes estáveis.",
                                    "Tratar falhas: distâncias aumentam gradualmente via vizinhos alternos.",
                                    "Identificar loop de contagem infinita: métrica cresce até infinito sem mitigação.",
                                    "Mencionar soluções básicas: split horizon e hold-down timers."
                                  ],
                                  "verification": "Simular 3 rodadas de trocas em rede de 3 roteadores até convergência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para tabelas múltiplas",
                                    "Cronograma de trocas"
                                  ],
                                  "tips": "Simule falha de link após convergência para ver propagação lenta.",
                                  "learningObjective": "Analisar dinâmica de convergência e limitações do DV.",
                                  "commonMistakes": [
                                    "Acreditar em convergência instantânea",
                                    "Ignorar lentidão em grandes redes"
                                  ]
                                }
                              ],
                              "practicalExample": "Rede linear A--1--B--10--C. Inicial: A conhece B(1); B conhece A(1),C(10); C conhece B(10). Após troca 1: A recebe de B vetor {A:1,C:10}, relaxa C via B custo 1+10=11. Troca 2: A envia {B:1,C:11} para B; B atualiza A via...? Continua até A ter C:11, estável.",
                              "finalVerifications": [
                                "Descrever troca de vetores e frequência.",
                                "Aplicar equação Bellman-Ford em exemplo com números.",
                                "Desenhar tabelas de roteamento antes/depois de 2 trocas.",
                                "Explicar como falha em link B-C propaga para A.",
                                "Identificar risco de loops e mitigação básica.",
                                "Comparar com link-state em termos de informação trocada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na equação de relaxamento e aplicação.",
                                "Correção nas tabelas de roteamento simuladas.",
                                "Compreensão clara de convergência vs. divergência.",
                                "Identificação correta de problemas como contagem infinita.",
                                "Uso de exemplos concretos sem erros numéricos.",
                                "Explicação fluida do ciclo completo: troca-atualização-convergência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Caminhos mais curtos em grafos e programação dinâmica (Bellman-Ford).",
                                "Física: Propagação de ondas/informações em meios distribuídos.",
                                "Economia: Otimização de rotas com custos mínimos em logística.",
                                "Estatística: Modelagem de redes probabilísticas e convergência estocástica."
                              ],
                              "realWorldApplication": "Implementado no protocolo RIP para redes IP pequenas, como LANs empresariais, onde roteadores como Cisco usam DV para descobrir rotas automaticamente sem configuração manual completa."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Identificar problemas comuns no roteamento Distância-Vetor",
                            "description": "Analisar problemas como o 'count-to-infinity', loops de roteamento e convergência lenta, demonstrando com exemplos como o envenenamento de rotas (route poisoning) mitiga esses issues.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Roteamento Distância-Vetor",
                                  "subSteps": [
                                    "Explique o princípio de Bellman-Ford usado no DV: cada roteador mantém uma tabela de distâncias para todas as redes.",
                                    "Descreva como as tabelas são trocadas periodicamente entre vizinhos.",
                                    "Identifique métricas comuns como hop count no RIP.",
                                    "Desenhe uma topologia simples de 3 roteadores (A-B-C) para ilustrar atualizações normais.",
                                    "Simule uma atualização inicial sem falhas."
                                  ],
                                  "verification": "Construa e verbalize uma tabela de roteamento correta para a topologia sem problemas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Simulador de rede como Cisco Packet Tracer ou GNS3"
                                  ],
                                  "tips": [
                                    "Use setas para mostrar direção das atualizações de tabela.",
                                    "Lembre-se: DV usa 'vizinhos' diretos apenas."
                                  ],
                                  "learningObjective": "Compreender o mecanismo básico de propagação de rotas no DV para contextualizar problemas.",
                                  "commonMistakes": [
                                    "Confundir DV com Link-State (que usa mapas globais).",
                                    "Ignorar o papel das métricas na escolha de rotas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Problema de Count-to-Infinity",
                                  "subSteps": [
                                    "Simule falha de link: remova a conexão B-C em uma rede linear A-B-C-D.",
                                    "Mostre como B informa A de uma rota via C (distância 2), mas C perde a rota.",
                                    "Demonstre iterações: C atualiza para via B (distância 3), B para 4, e assim por diante até infinito.",
                                    "Calcule o número de iterações necessárias para convergir (ex: 16 hops no RIP).",
                                    "Registre o tempo de convergência em uma tabela."
                                  ],
                                  "verification": "Reproduza o cenário em diagrama mostrando contagens crescentes até detecção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama em papel ou ferramenta digital como Draw.io",
                                    "Packet Tracer para simulação"
                                  ],
                                  "tips": [
                                    "Use timers para simular atualizações periódicas (ex: 30s).",
                                    "Anote distâncias em cada iteração."
                                  ],
                                  "learningObjective": "Identificar e quantificar o problema de contagem infinita em cenários de falha.",
                                  "commonMistakes": [
                                    "Parar simulação cedo sem mostrar loop completo.",
                                    "Confundir com split horizon."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Routing Loops e Convergência Lenta",
                                  "subSteps": [
                                    "Configure uma topologia triangular (A-B-C) e simule falha A-B.",
                                    "Observe pacotes em loop: A envia para B, B para C, C para B, etc.",
                                    "Meça tempo de convergência lenta devido a atualizações assíncronas.",
                                    "Compare com cenários sem falhas para destacar impacto.",
                                    "Discuta blackholes: rotas inválidas causando perda de pacotes."
                                  ],
                                  "verification": "Trace um pacote em loop usando simulação e identifique o ciclo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de rede",
                                    "Cronômetro para medir convergência"
                                  ],
                                  "tips": [
                                    "Ative debug de roteamento para logs.",
                                    "Use ping contínuo para detectar loops."
                                  ],
                                  "learningObjective": "Reconhecer loops temporários e atrasos na estabilização da rede.",
                                  "commonMistakes": [
                                    "Ignorar temporariedade dos loops.",
                                    "Confundir convergência lenta com count-to-infinity."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Mitigação com Route Poisoning",
                                  "subSteps": [
                                    "Explique route poisoning: roteador anuncia rota inválida com métrica infinita (ex: 16 no RIP).",
                                    "Simule em topologia A-B-C: B envenena rota para C ao detectar falha.",
                                    "Mostre propagação rápida do veneno acelerando convergência.",
                                    "Compare tempos com e sem poisoning em simulações idênticas.",
                                    "Discuta limitações e combinação com split horizon."
                                  ],
                                  "verification": "Execute simulação com poisoning e confirme convergência em <5 atualizações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Packet Tracer configurado com RIP",
                                    "Documentação RIP RFC 1058"
                                  ],
                                  "tips": [
                                    "Defina 'ip route 0.0.0.0 16 null0' para poisoning manual.",
                                    "Teste múltiplas falhas."
                                  ],
                                  "learningObjective": "Aplicar e validar técnicas de mitigação para problemas DV.",
                                  "commonMistakes": [
                                    "Usar métrica errada (não 16).",
                                    "Esquecer propagação bidirecional."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com RIP, o roteador central falha. Sem poisoning, contadores sobem de 2 para 16 hops em 8 minutos, causando downtime. Com poisoning, convergência em 90s via rotas alternativas.",
                              "finalVerifications": [
                                "Explicar count-to-infinity com diagrama de 4 roteadores.",
                                "Simular loop de roteamento e medir duração.",
                                "Configurar route poisoning em simulador e comparar convergência.",
                                "Identificar 3 problemas DV em log de roteador real.",
                                "Discutir por que DV não escala para grandes redes.",
                                "Propor alternativa (ex: OSPF) para cenário dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de mecanismos DV (90% correto).",
                                "Capacidade de simular e diagnosticar problemas (sucesso em 2 cenários).",
                                "Explicação clara de mitigações com evidências.",
                                "Uso correto de terminologia (count-to-infinity, poisoning).",
                                "Análise quantitativa (tempos, hops).",
                                "Criatividade em exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmo Bellman-Ford e grafos direcionados.",
                                "Programação: Implementar DV em Python com sockets.",
                                "Física: Analogia com propagação de ondas em falhas.",
                                "Segurança: Impacto de loops em ataques de negação de serviço."
                              ],
                              "realWorldApplication": "Em redes legadas RIP da Internet inicial (pré-OSPF), count-to-infinity causou outages globais; route poisoning no RIPv1 reduziu para minutos, influenciando designs modernos como BGP."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Simular o cálculo de rotas em uma rede Distância-Vetor",
                            "description": "Executar manualmente iterações de atualização de tabelas em uma topologia simples de 4 roteadores, calculando distâncias e próximos saltos até convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a topologia da rede e inicializar tabelas de roteamento",
                                  "subSteps": [
                                    "Desenhe um grafo com 4 roteadores (A, B, C, D) em um anel: A-B (custo 1), B-C (1), C-D (1), D-A (1).",
                                    "Identifique vizinhos de cada roteador: A (B,D), B (A,C), C (B,D), D (A,C).",
                                    "Crie tabelas iniciais para cada roteador: preencha distâncias infinitas (∞) para destinos não vizinhos e custo 1 para vizinhos com próximo salto direto.",
                                    "Registre a tabela inicial: ex. A: B=1(next=B), D=1(next=D), C=∞, A=0.",
                                    "Verifique que todas as tabelas estão corretas e simétricas nos links."
                                  ],
                                  "verification": "Todas as 4 tabelas iniciais estão completas, com vizinhos em custo 1 e outros em ∞.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Folha com modelo de tabela de roteamento (destino, distância, próximo salto)"
                                  ],
                                  "tips": "Use ∞ como 999 para facilitar cálculos; rotule roteadores claramente no desenho.",
                                  "learningObjective": "Compreender a configuração inicial em redes Distância-Vetor, focando em vizinhos diretos.",
                                  "commonMistakes": [
                                    "Esquecer de definir custo 0 para si mesmo",
                                    "Assumir conexões inexistentes",
                                    "Não marcar próximo salto corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a primeira iteração de troca e atualização de tabelas",
                                  "subSteps": [
                                    "Simule o envio: cada roteador envia sua tabela atual para todos os vizinhos.",
                                    "Para cada roteador receptor, calcule novas distâncias: para cada destino na tabela recebida, nova_dist = custo_link + dist_recebida; atualize se menor.",
                                    "Atualize próximo salto para o vizinho que enviou a melhor rota.",
                                    "Exemplo para A recebendo de B: B envia B=0, A=1, C=1(next=C?), D=∞; A atualiza C=1 (de B) +1=2 via B.",
                                    "Registre todas as atualizações nas 4 tabelas após a iteração 1."
                                  ],
                                  "verification": "Tabelas após iteração 1 mostram distâncias atualizadas para destinos a 2 saltos (ex. A conhece C via B em 2).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmas tabelas do step 1",
                                    "Calculadora opcional para somas"
                                  ],
                                  "tips": "Atualize uma tabela por vez para evitar confusão; anote 'via X' temporariamente.",
                                  "learningObjective": "Aplicar o algoritmo Bellman-Ford em uma iteração: min(dist_atual, custo + dist_vizinho).",
                                  "commonMistakes": [
                                    "Não adicionar custo do link ao receber",
                                    "Atualizar com tabela própria",
                                    "Ignorar se nova_dist não for menor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações subsequentes até detectar convergência",
                                  "subSteps": [
                                    "Repita o processo de troca e atualização para iteração 2: envie tabelas atualizadas, calcule e registre mudanças.",
                                    "Continue para iteração 3+: compare tabelas consecutivas; pare quando nenhuma mudança ocorrer (convergência).",
                                    "Para topologia anel, espere ~3 iterações para distâncias diametrais (ex. A-D=2 via B-C ou D direto=1, mas convergir para mínimas).",
                                    "Registre número de iterações necessárias e tabelas finais.",
                                    "Marque próximo saltos finais para todos os pares origem-destino."
                                  ],
                                  "verification": "Tabelas não mudam entre iterações finais; distâncias corretas (ex. A-C=2 via B, A-D=1 via D).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabelas atualizadas",
                                    "Folha para histórico de iterações"
                                  ],
                                  "tips": "Faça uma cópia da tabela anterior para comparar mudanças; acelere desenhando apenas deltas.",
                                  "learningObjective": "Simular convergência assíncrona em DV e identificar loops de contagem (se aplicável).",
                                  "commonMistakes": [
                                    "Parar cedo sem verificar todas as tabelas",
                                    "Confundir direções em anel",
                                    "Não propagar atualizações corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e verificar rotas finais",
                                  "subSteps": [
                                    "Liste todas as rotas finais: para cada origem, destino, distância e próximo salto.",
                                    "Compare com caminhos ótimos conhecidos (use Dijkstra mentalmente para validar).",
                                    "Identifique qualquer rota subótima devido a convergência lenta.",
                                    "Desenhe setas de próximos saltos no grafo para visualizar fluxos.",
                                    "Documente tempo total de convergência e lições aprendidas."
                                  ],
                                  "verification": "Rotas finais formam árvores livres de loops apontando para destinos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Grafo desenhado",
                                    "Tabelas finais"
                                  ],
                                  "tips": "Valide traçando uma rota completa de A para C: A->B->C.",
                                  "learningObjective": "Interpretar tabelas convergidas e relacionar com roteamento real.",
                                  "commonMistakes": [
                                    "Aceitar loops em próximos saltos",
                                    "Ignorar assimetrias",
                                    "Não validar com caminhos conhecidos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede anel A-B-C-D-A (todos custos 1), após convergência: Tabela A: B=1(via B), C=2(via B), D=1(via D); próximo saltos evitam loop horário/anti-horário dependendo da propagação.",
                              "finalVerifications": [
                                "Todas tabelas convergiram sem mudanças em iterações finais.",
                                "Distâncias mínimas corretas para todos pares (ex. diâmetro=2).",
                                "Próximos saltos formam caminhos sem loops.",
                                "Número de iterações ≤4 para topologia pequena.",
                                "Documentação inclui tabelas iniciais, finais e pelo menos 2 iterações intermediárias.",
                                "Grafo com setas de rotas visualiza corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas atualizações: 100% das distâncias calculadas corretamente.",
                                "Completude das tabelas: todos destinos preenchidos em todas iterações.",
                                "Detecção correta de convergência: sem paradas prematuras.",
                                "Análise qualitativa: identificação de pelo menos 1 característica DV (ex. convergência lenta).",
                                "Clareza na documentação: tabelas legíveis e rotas traçadas.",
                                "Validação cruzada: rotas manuais coincidem com tabelas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos de grafos e programação dinâmica (Bellman-Ford).",
                                "Programação: Implementar simulação em Python com loops de atualização.",
                                "Física: Analogia com propagação de ondas ou difusão em redes.",
                                "Economia: Otimização de custos em logística de entregas."
                              ],
                              "realWorldApplication": "Simulação reflete protocolos como RIP em redes empresariais iniciais; usado para depuração de roteadores Cisco, planejamento de topologias e compreensão de problemas como 'count-to-infinity' em falhas de link."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Roteamento Estado de Enlace",
                        "description": "Algoritmo que coleta informações completas sobre o estado de todos os enlaces da rede via flooding, construindo um grafo e usando Dijkstra para calcular rotas mais curtas, como no protocolo OSPF.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Explicar o processo de construção do banco de dados de estado de enlace",
                            "description": "Detalhar como os roteadores inundam (flooding) pacotes LSA (Link State Advertisements) para criar um mapa topológico sincronizado em toda a rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Link State Advertisements (LSAs)",
                                  "subSteps": [
                                    "Estude a estrutura básica de um LSA, incluindo cabeçalho (LS Age, LS Type, Link State ID, Advertising Router, Sequence Number) e corpo com informações de links.",
                                    "Identifique os principais tipos de LSAs (Router LSA, Network LSA, Summary LSA, AS External LSA).",
                                    "Analise como LSAs representam a topologia local de um roteador (links, custos, vizinhos).",
                                    "Revise o papel do Sequence Number e Checksum para garantir integridade e frescor.",
                                    "Desenhe um exemplo de LSA para um roteador com dois links."
                                  ],
                                  "verification": "Crie um diagrama anotado de um LSA exemplo e explique seus campos para um colega.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação OSPF RFC 2328",
                                    "Diagramas de rede em ferramenta como draw.io",
                                    "Simulador Packet Tracer"
                                  ],
                                  "tips": "Foquem em como LSAs são 'anúncios' locais que se tornam globais via flooding.",
                                  "learningObjective": "Entender a composição e propósito dos LSAs como blocos de construção do LSDB.",
                                  "commonMistakes": [
                                    "Confundir LSAs com pacotes de roteamento dinâmico como RIP updates",
                                    "Ignorar o papel do Sequence Number em detectar duplicatas",
                                    "Achar que todos LSAs são idênticos em toda a rede"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer Adjacências e Iniciar Geração de LSAs",
                                  "subSteps": [
                                    "Configure Hellos para descoberta de vizinhos e formação de adjacências (Master/Slave election).",
                                    "Gere LSAs iniciais (Router LSA tipo 1) baseados na topologia local detectada.",
                                    "Inicie a troca de Database Description (DD) packets para comparar sumários de LSDB.",
                                    "Envie Link State Requests (LSR) para LSAs faltantes identificados nas DDs.",
                                    "Receba Link State Updates (LSU) em resposta aos LSRs."
                                  ],
                                  "verification": "Simule em Packet Tracer a formação de adjacência e gere logs de LSAs iniciais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Cisco Packet Tracer ou GNS3",
                                    "Topologia de rede com 3 roteadores",
                                    "Captura de pacotes Wireshark"
                                  ],
                                  "tips": "Use modo debug em simuladores para ver Hellos e DDs em tempo real.",
                                  "learningObjective": "Dominar o protocolo de sincronização inicial que precede o flooding completo.",
                                  "commonMistakes": [
                                    "Pular Hellos achando que adjacências são automáticas",
                                    "Confundir DD packets com LSAs reais",
                                    "Não notar eleição Master/Slave afetando ordem de sincronização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o Processo de Flooding dos LSAs",
                                  "subSteps": [
                                    "Ao receber um LSU, valide o LSA (sequência, checksum, idade).",
                                    "Instale o LSA no LSDB local se for mais recente.",
                                    "Reenvie (flood) o LSA para todos os vizinhos adjacentes, exceto a origem (evite loops com ACKs).",
                                    "Use Link State Acknowledgements (LSAck) para confirmação confiável.",
                                    "Monitore flooding sequencial até convergência em toda a área OSPF."
                                  ],
                                  "verification": "Capture tráfego em simulador e confirme que LSAs são floodados sem loops infinitos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Simulador com topologia em estrela ou malha",
                                    "Wireshark para filtrar OSPF LSAs",
                                    "Cronograma de flooding manual"
                                  ],
                                  "tips": "Desenhe setas de flooding em um mapa da rede para visualizar propagação.",
                                  "learningObjective": "Explicar como flooding garante que todos roteadores tenham cópias idênticas do LSDB.",
                                  "commonMistakes": [
                                    "Achar flooding é broadcast irrestrito (é para adjacentes)",
                                    "Ignorar ACKs levando a perda de pacotes",
                                    "Subestimar impacto de Sequence Number em flooding seletivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sincronizar e Manter o Link State Database (LSDB)",
                                  "subSteps": [
                                    "Armazene LSAs em LSDB organizado por tipo, ID e sequência.",
                                    "Execute SPF (Dijkstra) periodicamente para calcular árvores de roteamento baseadas no LSDB.",
                                    "Atualize LSDB com LSAs refrescos (a cada 30min) ou mudanças topológicas.",
                                    "Detecte e resolva inconsistências via MaxAge (60min) para LSAs obsoletos.",
                                    "Verifique sincronização completa via DD packets full-state."
                                  ],
                                  "verification": "Compare LSDBs de múltiplos roteadores em simulador e confirme identidade.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de visualização OSPF LSDB",
                                    "Exercícios de SPF manual em grafos",
                                    "Documentação de comandos 'show ip ospf database'"
                                  ],
                                  "tips": "Use 'show ip ospf database' para inspecionar LSDB real em simuladores.",
                                  "learningObjective": "Compreender como o LSDB sincronizado habilita cálculo independente de rotas.",
                                  "commonMistakes": [
                                    "Confundir LSDB com tabela de roteamento",
                                    "Ignorar purga MaxAge causando mapas desatualizados",
                                    "Achar SPF roda só no flooding inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar Consistência e Resolução de Problemas",
                                  "subSteps": [
                                    "Execute verificações pós-flooding: compare sumários DD entre roteadores.",
                                    "Identifique falhas comuns como LSAs duplicados ou não floodados.",
                                    "Simule falhas (link down) e observe regeneração/flooding de LSAs delta.",
                                    "Analise logs para timeouts ou rejeições de LSAs inválidos.",
                                    "Confirme convergência total com tabelas de roteamento idênticas."
                                  ],
                                  "verification": "Gere relatório de troubleshooting listando causas e soluções para 3 cenários.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Cenários de falha pré-configurados em Packet Tracer",
                                    "Checklist de troubleshooting OSPF"
                                  ],
                                  "tips": "Sempre cheque timers: Hello/Dead para adjacências, MaxAge para LSAs.",
                                  "learningObjective": "Diagnosticar e validar um LSDB sincronizado em cenários reais.",
                                  "commonMistakes": [
                                    "Não diferenciar flooding inicial vs. incremental",
                                    "Ignorar áreas OSPF limitando flooding",
                                    "Confundir inconsistências LSDB com problemas de adjacência"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede OSPF com 4 roteadores (R1-R2-R3-R4 em linha), R1 gera um Router LSA após link up. R1 floods para R2, que ACK e refloods para R3, etc. Após 3 hops, todos têm LSDB idêntico com mapa topológico completo, permitindo SPF calcular rotas como R4 to R1 via R3-R2.",
                              "finalVerifications": [
                                "Todos roteadores exibem LSDB idêntico via 'show ip ospf database'.",
                                "Tabelas de roteamento convergem sem loops ou rotas inválidas.",
                                "Flooding de LSA teste alcança todos em <5 segundos.",
                                "Nenhum LSA com Sequence Number desatualizado permanece.",
                                "SPF executa sem erros em todos nós.",
                                "Adjacências full-state em todos links."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de flooding (sem loops, ACKs obrigatórios): 20%",
                                "Detalhe nos componentes LSA e LSDB: 20%",
                                "Explicação clara de sincronização via DD/LSR/LSU/LSAck: 20%",
                                "Uso correto de exemplos/simulações: 15%",
                                "Identificação de erros comuns e troubleshooting: 15%",
                                "Conexão com cálculo SPF: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grafos e algoritmo de Dijkstra para SPF.",
                                "Física: Propagação de sinais em mídias de rede afetando flooding.",
                                "Estatística: Análise de convergência e tempos de flooding em redes grandes.",
                                "Administração: Escalabilidade de LSDB em redes empresariais."
                              ],
                              "realWorldApplication": "Em data centers empresariais usando OSPF, o LSDB sincronizado via flooding permite roteamento rápido e resiliente, como no Google Cloud ou redes ISP, onde mudanças topológicas (ex: falha de link) propagam em segundos para milhões de rotas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Aplicar o algoritmo de Dijkstra para cálculo de rotas",
                            "description": "Executar passo a passo o algoritmo de Dijkstra em um grafo de rede extraído do estado de enlace, priorizando nós com menor custo acumulado para determinar caminhos ótimos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a representação do grafo e inicializar estruturas de dados",
                                  "subSteps": [
                                    "Extrair o estado de enlace do grafo de rede, identificando nós, arestas e custos associados.",
                                    "Construir a lista de adjacência ou matriz de adjacência para representar o grafo.",
                                    "Definir o nó fonte (origem) e inicializar arrays: distâncias (todos ∞ exceto fonte=0), visitados (falso), predecessores (null).",
                                    "Implementar ou simular uma fila de prioridade (min-heap) vazia.",
                                    "Inserir o nó fonte na fila com prioridade 0."
                                  ],
                                  "verification": "Verificar se a lista de adjacência está correta comparando com o estado de enlace e se distâncias iniciais são: fonte=0, outros=∞.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para desenho manual",
                                    "Editor de texto ou planilha para matriz",
                                    "Biblioteca heapq em Python (opcional)"
                                  ],
                                  "tips": "Use uma tabela para visualizar distâncias e predecessores; comece com grafos pequenos (4-6 nós).",
                                  "learningObjective": "Entender a representação do grafo de estado de enlace e inicializar corretamente as estruturas para Dijkstra.",
                                  "commonMistakes": [
                                    "Definir distância da fonte como ∞ em vez de 0",
                                    "Esquecer de incluir todos os nós na inicialização",
                                    "Usar grafo direcionado quando for não-direcionado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o nó com menor custo acumulado da fila de prioridade",
                                  "subSteps": [
                                    "Extrair o nó u com a menor distância da fila de prioridade.",
                                    "Marcar u como visitado para evitar reprocessamento.",
                                    "Se todos os nós foram visitados, parar o algoritmo.",
                                    "Preparar para relaxar as arestas de u.",
                                    "Atualizar a fila removendo entradas duplicadas se necessário."
                                  ],
                                  "verification": "Simular extração: o primeiro nó extraído deve ser a fonte com custo 0; confirme marcação de visitado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Fila de prioridade simulada em papel ou código Python com heapq"
                                  ],
                                  "tips": "Sempre extraia o mínimo; em simulações manuais, risque nós visitados.",
                                  "learningObjective": "Dominar a seleção gulosa do nó não visitado com menor custo acumulado.",
                                  "commonMistakes": [
                                    "Extrair nó já visitado",
                                    "Não atualizar prioridades após relaxamentos",
                                    "Ignorar fila de prioridade e usar busca linear"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relaxar as arestas dos vizinhos do nó selecionado",
                                  "subSteps": [
                                    "Para cada vizinho v de u, calcular novo_custo = dist[u] + custo(u,v).",
                                    "Se novo_custo < dist[v], atualizar dist[v] = novo_custo e predecessor[v] = u.",
                                    "Inserir ou atualizar v na fila de prioridade com a nova prioridade.",
                                    "Repetir para todos os vizinhos não visitados.",
                                    "Registrar mudanças em uma tabela de rastreamento."
                                  ],
                                  "verification": "Verificar se pelo menos uma atualização ocorreu e distâncias diminuíram corretamente para vizinhos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de rastreamento em papel",
                                    "Código Python para automação"
                                  ],
                                  "tips": "Só relaxe para vizinhos não visitados; use ∞ como sentinel para comparações.",
                                  "learningObjective": "Aplicar o relaxamento de arestas corretamente para propagar custos mínimos.",
                                  "commonMistakes": [
                                    "Relaxar para nós visitados",
                                    "Erro aritmético em soma de custos",
                                    "Não atualizar predecessor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar até conclusão e reconstruir caminhos ótimos",
                                  "subSteps": [
                                    "Repetir steps 2-3 até a fila estar vazia ou todos visitados.",
                                    "Para cada nó destino, reconstruir caminho traçando predecessores de volta à fonte.",
                                    "Calcular custo total do caminho somando arestas.",
                                    "Verificar se não há ciclos ou caminhos inválidos.",
                                    "Documentar tabela final de distâncias e caminhos."
                                  ],
                                  "verification": "Caminhos reconstruídos devem coincidir com distâncias mínimas; simule com grafo conhecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico final em papel",
                                    "Função de reconstrução em pseudocódigo"
                                  ],
                                  "tips": "Backtrack de destino para fonte via predecessores; valide somando custos.",
                                  "learningObjective": "Finalizar o algoritmo e extrair rotas ótimas do estado de enlace.",
                                  "commonMistakes": [
                                    "Parar prematuramente antes de esvaziar fila",
                                    "Ciclos em predecessores",
                                    "Caminho com custo > distância mínima"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo de 4 roteadores A(B fonte), B, C, D. Arestas: A-B:4, A-C:2, B-D:5, C-D:8, B-C:1. Inicial: dist[A]=0, outros=∞. Extrai A, relaxa: B=4, C=2. Extrai C (min=2), relaxa D=10 via C. Extrai B (4), relaxa D=9 via B (atualiza). Extrai D(9). Caminhos: A-B-D custo9; A-C custo2.",
                              "finalVerifications": [
                                "Todas distâncias finais são mínimas e coincidem com cálculo manual.",
                                "Predecessores formam caminhos acíclicos da fonte aos destinos.",
                                "Nenhum nó visitado foi reprocessado.",
                                "Fila de prioridade sempre extrai o menor custo atual.",
                                "Custos de caminhos reconstruídos somam exatamente às distâncias.",
                                "Algoritmo converge em < N iterações (N=nós)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas atualizações de relaxamento (sem erros aritméticos).",
                                "Correta implementação da priority queue (extração de mínimos).",
                                "Eficiência: O(n log n) com heap, sem buscas lineares excessivas.",
                                "Validação completa: distâncias e caminhos verificados.",
                                "Tratamento de grafos desconexos (dist=∞ preservada).",
                                "Documentação clara de cada iteração."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Busca em Largura/Profundidade.",
                                "Otimização: Problema do Caminho Mais Curto e Programação Dinâmica.",
                                "Física: Modelagem de redes de fluxo e difusão de sinais.",
                                "Economia: Cálculo de rotas de menor custo em logística.",
                                "Engenharia: Protocolos OSPF/IS-IS em redes reais."
                              ],
                              "realWorldApplication": "Em roteadores de redes IP (ex: OSPF), calcula tabelas de roteamento distribuídas baseadas em topologia de estado de enlace, otimizando tráfego em internet e data centers para menor latência e custo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Comparar convergência e escalabilidade do Estado de Enlace",
                            "description": "Discutir vantagens como convergência rápida e detecção precisa de falhas, versus overhead de tráfego e memória em redes grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Convergência e Escalabilidade",
                                  "subSteps": [
                                    "Defina convergência como o tempo necessário para todos os roteadores atualizarem suas tabelas de roteamento após uma mudança na topologia.",
                                    "Defina escalabilidade como a capacidade do protocolo lidar com aumento no número de nós sem degradação significativa de performance.",
                                    "Identifique métricas chave: tempo de convergência (segundos), uso de banda (overhead de mensagens), uso de memória (armazenamento de estado).",
                                    "Compare conceitualmente com roteamento à distância-vetor (ex: RIP), que usa Bellman-Ford e sofre de contagem ao infinito.",
                                    "Liste vantagens iniciais do Estado de Enlace (LS): visão global da topologia via flooding de LSAs."
                                  ],
                                  "verification": "Crie um glossário com definições e métricas; explique para um colega sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Kurose & Ross (Cap. 4), diagrama de rede simples no papel"
                                  ],
                                  "tips": "Use analogias: convergência como 'boato se espalhando' vs. 'mapa completo distribuído'.",
                                  "learningObjective": "Dominar definições e métricas para basear comparações.",
                                  "commonMistakes": [
                                    "Confundir convergência com latência",
                                    "Ignorar overhead em escalabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Convergência no Roteamento Estado de Enlace",
                                  "subSteps": [
                                    "Descreva o processo: descoberta de vizinhos (Hello), flooding de LSAs, cálculo SPF (Dijkstra).",
                                    "Simule uma falha de link: LSAs são floodados imediatamente, SPF recalculado em paralelo.",
                                    "Meça tempo: tipicamente 1-5s em OSPF vs. 30s+ em RIP devido a loops.",
                                    "Discuta detecção precisa: LSAs incluem sequências e timestamps para evitar duplicatas.",
                                    "Compare com DV: LS evita count-to-infinity por visão completa."
                                  ],
                                  "verification": "Desenhe timeline de convergência para uma topologia de 5 roteadores com falha.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta Cisco Packet Tracer ou GNS3 para simulação básica",
                                    "Pseudocódigo de Dijkstra"
                                  ],
                                  "tips": "Flooding é como 'envio de correio aéreo' - rápido mas custoso.",
                                  "learningObjective": "Explicar mecanismos que garantem convergência rápida no LS.",
                                  "commonMistakes": [
                                    "Subestimar tempo de flooding em redes grandes",
                                    "Confundir LSA com atualizações periódicas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Escalabilidade do Roteamento Estado de Enlace",
                                  "subSteps": [
                                    "Calcule overhead: cada roteador armazena N*(N-1)/2 links; flooding O(N) por mudança.",
                                    "Discuta memória: LSDB (Link State Database) cresce com O(N^2) em topologias densas.",
                                    "Compare tráfego: LS usa bursts iniciais + Hellos vs. DV periódico (13s em RIP).",
                                    "Aborde mitigações: áreas em OSPF, summarização de rotas.",
                                    "Limites práticos: bom para <1000 roteadores; ruim em Internet full-mesh."
                                  ],
                                  "verification": "Tabela comparativa de uso de memória/tráfego para redes de 10, 100, 1000 nós.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel para cálculos O(N)",
                                    "Documentação OSPF RFC 2328"
                                  ],
                                  "tips": "Pense em 'mapa mundial' vs. 'rumores locais': mapa é preciso mas pesado.",
                                  "learningObjective": "Quantificar desvantagens de escalabilidade no LS.",
                                  "commonMistakes": [
                                    "Ignorar benefícios de hierarquia",
                                    "Comparar sem considerar mitigações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Comparação Completa e Vantagens/Desvantagens",
                                  "subSteps": [
                                    "Crie tabela: LS vs. DV - convergência (rápida vs. lenta), escalabilidade (boa em média vs. pobre em grande).",
                                    "Discuta vantagens LS: precisão (sem loops), suporte multicast.",
                                    "Desvantagens LS: CPU/memória alta em mudanças frequentes.",
                                    "Cenários ideais: LS em enterprise/backbones, DV em small LANs.",
                                    "Conclua com trade-offs: LS para redes estáveis/médias."
                                  ],
                                  "verification": "Escreva parágrafo de 200 palavras resumindo comparação com exemplos numéricos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Templates de tabela em Google Docs",
                                    "Vídeos Khan Academy sobre roteamento"
                                  ],
                                  "tips": "Use gráficos de performance vs. tamanho de rede para visualização.",
                                  "learningObjective": "Capacitar discussão balanceada de prós e contras.",
                                  "commonMistakes": [
                                    "Viés para um protocolo sem dados",
                                    "Omitir contexto de rede"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 20 roteadores OSPF (LS), simule falha de link no Packet Tracer: convergência em ~3s com 500 pacotes LSA floodados (overhead 2MB memória LSDB). Compare com RIP (DV): 45s e count-to-infinity temporário.",
                              "finalVerifications": [
                                "Explicar por que LS detecta falhas mais rápido que DV.",
                                "Calcular overhead aproximado de LSAs em rede de 50 nós.",
                                "Identificar quando LS é preferível sobre DV.",
                                "Desenhar SPF tree para topologia simples.",
                                "Discutir impacto de áreas OSPF na escalabilidade.",
                                "Comparar uso de CPU em convergência LS vs. DV."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas: 30%)",
                                "Uso de evidências quantitativas (métricas/tabelas: 25%)",
                                "Análise balanceada de trade-offs (20%)",
                                "Exemplos práticos e simulações (15%)",
                                "Clareza na comunicação (gráficos/tabelas: 10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmo de Dijkstra e grafos direcionados.",
                                "Física: Propagação de sinais e latência em meios de transmissão.",
                                "Economia: Trade-offs custo-benefício em design de infraestrutura.",
                                "Estatística: Modelagem probabilística de falhas de rede."
                              ],
                              "realWorldApplication": "Em provedores de Internet como backbone da Verizon usando OSPF para convergência rápida em falhas, evitando downtime em milhões de usuários, apesar do overhead gerenciado por áreas hierárquicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Comparação e Aplicações de Algoritmos de Roteamento",
                        "description": "Análise comparativa entre distância-vetor e estado de enlace, incluindo integração com SDN e protocolo IP para rotas ótimas em redes modernas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Comparar características de Distância-Vetor e Estado de Enlace",
                            "description": "Elaborar uma tabela comparativa cobrindo métricas como convergência, uso de banda, memória, escalabilidade e robustez a falhas, com exemplos de RIP vs OSPF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Algoritmos Distance-Vector e Link-State",
                                  "subSteps": [
                                    "Estude o princípio do Distance-Vector (DV): roteadores trocam tabelas de distância completas com vizinhos usando Bellman-Ford.",
                                    "Analise o Link-State (LS): roteadores floodam informações de enlaces para construir mapa topológico e usam Dijkstra para rotas mais curtas.",
                                    "Identifique diferenças chave iniciais: DV é reativo e iterativo, LS é proativo e global.",
                                    "Registre exemplos: RIP como DV clássico, OSPF como LS moderno.",
                                    "Desenhe diagramas simples de uma rede com 3 roteadores para ilustrar trocas de mensagens em cada algoritmo."
                                  ],
                                  "verification": "Crie um diagrama comparativo mostrando mensagens trocadas em DV vs LS após uma mudança de topologia.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Kurose & Ross ou Tanenbaum sobre redes",
                                    "Vídeos Khan Academy ou Cisco Networking Academy sobre roteamento",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Use analogias: DV como fofoca local, LS como mapa completo da cidade.",
                                    "Foquem em como as mensagens são enviadas: periódicas em DV vs eventos em LS."
                                  ],
                                  "learningObjective": "Compreender os mecanismos fundamentais de operação de DV e LS para basear comparações.",
                                  "commonMistakes": [
                                    "Confundir DV com contagem ao infinito sem contar loops de roteamento.",
                                    "Achar que LS não tem overhead porque 'sabe tudo' – flooding é caro."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Pesquisar Métricas de Comparação",
                                  "subSteps": [
                                    "Liste métricas principais: convergência (tempo para estabilizar rotas), uso de banda (tráfego gerado), memória (armazenamento de dados), escalabilidade (com N roteadores), robustez a falhas (loops, blackholes).",
                                    "Pesquise características de DV: convergência lenta, baixo overhead inicial mas alto em loops, pouca memória, pobre escalabilidade >30 roteadores, suscetível a loops.",
                                    "Pesquise LS: convergência rápida, alto overhead de flooding, alta memória para LSDB, boa escalabilidade com áreas, robusto com autenticação.",
                                    "Colete dados quantitativos: ex. DV envia N tabelas por vizinho, LS envia LSA por enlace.",
                                    "Anote exemplos específicos: RIP hop-count limitado a 15, OSPF usa custo de banda."
                                  ],
                                  "verification": "Crie uma lista anotada com pelo menos 5 métricas e 2 fatos chave por algoritmo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação RFC 1058 (RIP)",
                                    "RFC 2328 (OSPF)",
                                    "Ferramentas online como Packet Tracer para simulações"
                                  ],
                                  "tips": [
                                    "Priorize métricas em ordem de impacto prático: comece com convergência.",
                                    "Use tabelas temporárias para organizar antes da final."
                                  ],
                                  "learningObjective": "Identificar métricas relevantes e mapear forças/fracos de cada algoritmo.",
                                  "commonMistakes": [
                                    "Ignorar escalabilidade hierárquica no OSPF.",
                                    "Superestimar simplicidade do DV sem considerar count-to-infinity."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Tabela Comparativa Estruturada",
                                  "subSteps": [
                                    "Crie colunas: Métrica, Distance-Vector (ex. RIP), Link-State (ex. OSPF), Vencedor/Vantagem.",
                                    "Preencha cada linha com dados concisos: ex. Convergência: Lenta (segundos-minutos), Rápida (segundos), LS vence.",
                                    "Inclua exemplos numéricos: Uso de banda DV ~ O(N^2), LS O(E log V).",
                                    "Adicione coluna de cenários: DV para redes pequenas estáveis, LS para grandes dinâmicas.",
                                    "Formate em Markdown ou Excel para clareza visual."
                                  ],
                                  "verification": "Revise a tabela para cobertura completa das 5 métricas com exemplos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Google Sheets ou Markdown editor",
                                    "Referências de steps anteriores"
                                  ],
                                  "tips": [
                                    "Use ícones ou cores para destacar vencedores.",
                                    "Mantenha células curtas para legibilidade."
                                  ],
                                  "learningObjective": "Sintetizar informações em formato tabular comparativo acionável.",
                                  "commonMistakes": [
                                    "Tabela desbalanceada com mais detalhes em um lado.",
                                    "Omitir exemplos concretos como RIP vs OSPF."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implicações e Verificar Tabela",
                                  "subSteps": [
                                    "Discuta trade-offs: DV simples/barato para pequenas redes, LS poderoso para enterprise.",
                                    "Simule cenários: falha de link em rede de 10 nós – compare tempo de recuperação.",
                                    "Valide com fontes externas: confirme se OSPF realmente usa mais memória mas escala melhor.",
                                    "Adicione insights: por que BGP mistura elementos dos dois.",
                                    "Revise tabela por precisão e complete gaps."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que LS é preferido em ISPs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador GNS3 ou Cisco Packet Tracer",
                                    "Artigos sobre roteamento real-world"
                                  ],
                                  "tips": [
                                    "Pense em custo-benefício: DV para IoT simples, LS para data centers.",
                                    "Teste com quiz auto-aplicado nas métricas."
                                  ],
                                  "learningObjective": "Aplicar comparação para decisões de design de rede.",
                                  "commonMistakes": [
                                    "Generalizar demais sem contexto de tamanho de rede.",
                                    "Confundir robustez com segurança – LS tem mais features anti-loop."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com 20 roteadores, após falha de um enlace crítico, RIP (DV) leva 2 minutos para convergir devido a count-to-infinity, enquanto OSPF (LS) recalcula em 10 segundos via flooding de LSAs e SPF. Crie tabela mostrando: Convergência (RIP: lenta; OSPF: rápida), Banda (RIP: baixa periódica; OSPF: alta burst).",
                              "finalVerifications": [
                                "Explique count-to-infinity em DV com exemplo numérico.",
                                "Descreva como LS usa LSDB e algoritmo SPF.",
                                "Liste 3 vantagens de OSPF sobre RIP.",
                                "Identifique cenário onde RIP é preferível.",
                                "Preencha lacunas em uma tabela incompleta fornecida."
                              ],
                              "assessmentCriteria": [
                                "Tabela cobre todas 5 métricas com precisão factual.",
                                "Exemplos RIP/OSPF corretos e relevantes.",
                                "Análise de trade-offs clara e equilibrada.",
                                "Formato visual claro e legível.",
                                "Insights sobre aplicações reais incluídos.",
                                "Ausência de erros conceituais como confundir algoritmos."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: DV como relaxações Bellman-Ford, LS como Dijkstra em grafos.",
                                "Análise de Algoritmos: Complexidade O(N^2) DV vs O(E log V) LS.",
                                "Engenharia de Software: Trade-offs em design distribuído.",
                                "Matemática Discreta: Modelagem de redes como grafos pesados."
                              ],
                              "realWorldApplication": "Em provedores de internet como ISPs, OSPF (LS) é usado em backbones para convergência rápida em falhas, enquanto RIP (DV) persiste em redes legadas pequenas como LANs domésticas; ajuda engenheiros a escolher protocolos para minimizar downtime em data centers."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Relacionar algoritmos de roteamento ao plano de controle em SDN",
                            "description": "Explicar como SDN centraliza o cálculo de rotas usando esses algoritmos no controlador, melhorando a programmabilidade em redes IP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Algoritmos de Roteamento Tradicionais",
                                  "subSteps": [
                                    "Liste os principais algoritmos de roteamento: Dijkstra, Bellman-Ford, OSPF e BGP.",
                                    "Explique o funcionamento distribuído: cada roteador calcula e troca tabelas de roteamento.",
                                    "Descreva limitações: convergência lenta, loops de roteamento e complexidade em redes grandes.",
                                    "Crie um diagrama simples de uma rede IP tradicional com roteadores distribuídos.",
                                    "Simule um cenário de falha de link e observe o reconvergência."
                                  ],
                                  "verification": "Crie um diagrama anotado mostrando cálculo distribuído e liste 3 limitações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação (Draw.io), vídeo tutorial sobre OSPF/BGP.",
                                  "tips": "Use analogias como 'trabalhadores independentes em uma fábrica' para o modelo distribuído.",
                                  "learningObjective": "Compreender o paradigma distribuído de roteamento em redes tradicionais.",
                                  "commonMistakes": "Confundir algoritmos de caminho único (Dijkstra) com de vetor de distância (RIP)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Arquitetura SDN e o Plano de Controle",
                                  "subSteps": [
                                    "Descreva os planos SDN: dados (switches), controle (controlador central) e aplicação.",
                                    "Explique o protocolo OpenFlow para comunicação entre controlador e switches.",
                                    "Identifique o papel do controlador: coleta topologia, calcula rotas globais e instala fluxos.",
                                    "Compare com redes tradicionais: centralizado vs. distribuído.",
                                    "Desenhe um diagrama da arquitetura SDN destacando o plano de controle."
                                  ],
                                  "verification": "Desenhe e rotule um diagrama SDN com fluxos de controle e dados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação OpenFlow oficial, ferramenta de diagramação.",
                                  "tips": "Pense no controlador como um 'cérebro central' orquestrando switches 'executores'.",
                                  "learningObjective": "Dominar os componentes e fluxos da arquitetura SDN.",
                                  "commonMistakes": "Ignorar a separação estrita entre planos de dados e controle."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Algoritmos de Roteamento ao Controlador SDN",
                                  "subSteps": [
                                    "Identifique como Dijkstra/OSPF são centralizados: controlador roda o algoritmo globalmente.",
                                    "Descreva o processo: controlador aprende topologia via LLDP, calcula rotas e envia via OpenFlow.",
                                    "Implemente um exemplo conceitual: use Dijkstra para encontrar caminho mais curto em SDN.",
                                    "Discuta customizações: algoritmos programáveis via APIs do controlador (ex: Ryu, ONOS).",
                                    "Simule em ferramenta: configure Mininet com controlador usando roteamento SDN."
                                  ],
                                  "verification": "Escreva pseudocódigo de como o controlador usa Dijkstra para instalar rotas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mininet instalado, controlador Ryu/POX, tutoriais SDN.",
                                  "tips": "Comece com topologias simples (estrela ou linha) para testar roteamento.",
                                  "learningObjective": "Relacionar algoritmos tradicionais à execução centralizada em SDN.",
                                  "commonMistakes": "Assumir que switches SDN calculam rotas localmente como em IP tradicional."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Melhorias na Programmabilidade",
                                  "subSteps": [
                                    "Compare convergência: SDN é instantânea via controlador vs. lenta em distribuído.",
                                    "Discuta programmabilidade: algoritmos customizados via software (ex: ML para rotas).",
                                    "Avalie cenários: balanceamento de carga global, QoS otimizado em IP.",
                                    "Liste benefícios: simplicidade de gerenciamento, escalabilidade em data centers.",
                                    "Crie um relatório resumindo vantagens para redes IP modernas."
                                  ],
                                  "verification": "Redija um parágrafo comparando programmabilidade SDN vs. tradicional.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos sobre SDN (ONF whitepapers), editor de texto.",
                                  "tips": "Use métricas quantitativas como tempo de convergência em ms para comparações.",
                                  "learningObjective": "Avaliar impactos da centralização na eficiência e flexibilidade.",
                                  "commonMistakes": "Superestimar overhead de comunicação controlador-switch."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa simulada no Mininet, configure um controlador Ryu que usa o algoritmo Dijkstra para calcular rotas curtas entre hosts. Ao falhar um link, o controlador recalcula globalmente e atualiza fluxos OpenFlow em switches em <1s, contrastando com OSPF tradicional que leva 30s+ para convergir.",
                              "finalVerifications": [
                                "Pode diagramar fluxo de roteamento SDN vs. tradicional?",
                                "Explica corretamente como OpenFlow instala rotas calculadas?",
                                "Identifica 3 benefícios de centralização em SDN?",
                                "Simula um cenário simples de falha e recuperação em ferramenta?",
                                "Compara convergência e programmabilidade quantitativamente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de algoritmos e arquitetura SDN (30%)",
                                "Clareza nos diagramas e mapeamentos conceituais (25%)",
                                "Profundidade na análise de melhorias de programmabilidade (20%)",
                                "Qualidade da simulação prática e verificações (15%)",
                                "Identificação correta de limitações e erros comuns (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de algoritmos em Python (Ryu/ONOS)",
                                "Segurança: Políticas de roteamento seguras via controlador central",
                                "Matemática: Grafos e algoritmos de caminho mais curto (Dijkstra)",
                                "Gestão de Projetos: Orquestração de redes em data centers"
                              ],
                              "realWorldApplication": "Em data centers do Google (B4 network), SDN centraliza BGP-like routing no controlador para otimizar tráfego global, reduzindo latência em 30% e permitindo atualizações programáticas para ML-driven traffic engineering."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Protocolo IP",
                    "description": "Protocolo principal do nível de rede para endereçamento, fragmentação e roteamento de datagramas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Datagrama IP e Cabeçalho",
                        "description": "Compreender a estrutura do datagrama IP, incluindo o cabeçalho IPv4, seus campos principais e o modelo de serviço connectionless e best-effort.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Identificar os campos principais do cabeçalho IPv4",
                            "description": "Listar e descrever os campos do cabeçalho IPv4, incluindo versão (4 bits), IHL (comprimento do cabeçalho), DSCP/ECN (8 bits para qualidade de serviço), comprimento total do datagrama (16 bits), identificação (para fragmentação), flags (DF, MF), offset de fragmento, TTL (time to live), protocolo (TCP=6, UDP=17), checksum, endereços IP de origem e destino.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Familiarizar-se com a estrutura geral do cabeçalho IPv4",
                                  "subSteps": [
                                    "Pesquise o RFC 791 para entender o cabeçalho mínimo de 20 bytes (160 bits).",
                                    "Localize e estude um diagrama visual do cabeçalho IPv4 dividido em 5 palavras de 32 bits cada.",
                                    "Identifique as posições bit a bit: bits 0-3 (Versão), 4-7 (IHL), 8-15 (DSCP/ECN), 16-31 (Total Length).",
                                    "Anote o tamanho total padrão e opções para extensão.",
                                    "Compare com IPv6 para contextualizar diferenças."
                                  ],
                                  "verification": "Desenhe o diagrama do cabeçalho e rotule as 5 primeiras posições corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 791 PDF",
                                    "Diagrama do cabeçalho IPv4 (imagem ou ferramenta online como Wireshark docs)"
                                  ],
                                  "tips": "Use cores diferentes para cada campo no diagrama para melhor memorização visual.",
                                  "learningObjective": "Compreender a organização bit a bit do cabeçalho IPv4 padrão.",
                                  "commonMistakes": "Confundir IHL com o comprimento total; lembrar que IHL é em palavras de 32 bits, não bytes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar campos de identificação e fragmentação",
                                  "subSteps": [
                                    "Analise o campo Identification (16 bits, bits 32-47): usado para remontagem de fragmentos.",
                                    "Estude Flags (3 bits, bits 48-50): Bit 0=Reserved, Bit 1=DF (Don't Fragment), Bit 2=MF (More Fragments).",
                                    "Descreva Fragment Offset (13 bits, bits 51-63): indica posição do fragmento em unidades de 8 bytes.",
                                    "Calcule exemplos: offset 100 significa byte 800 do datagrama original.",
                                    "Pratique cenários de fragmentação com datagramas > MTU (1500 bytes)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como DF e MF afetam o roteamento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora binária",
                                    "Exemplos de pacotes fragmentados em Wireshark"
                                  ],
                                  "tips": "Lembre-se: Flags + Offset = 16 bits; offset é sempre múltiplo de 8.",
                                  "learningObjective": "Dominar os campos responsáveis pela fragmentação e remontagem de datagramas.",
                                  "commonMistakes": "Esquecer que offset é em unidades de 8 bytes, não bytes individuais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar campos de controle de roteamento e integridade",
                                  "subSteps": [
                                    "Estude TTL (8 bits, bits 64-71): decrementado por cada hop, evita loops (ex: padrão 64 ou 128).",
                                    "Memorize Protocolo (8 bits, bits 72-79): 6=TCP, 17=UDP, 1=ICMP, etc.",
                                    "Aprenda Header Checksum (16 bits, bits 80-95): soma de complemento de 1 apenas do cabeçalho, recalculado por hop.",
                                    "Calcule um checksum simples usando ferramenta online para prática.",
                                    "Diferencie checksum do cabeçalho de checksums de payload."
                                  ],
                                  "verification": "Liste 3 protocolos comuns e seus números, e explique o papel do TTL em um loop.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de números de protocolo IANA",
                                    "Calculadora de checksum IPv4 online"
                                  ],
                                  "tips": "TTL baixo indica rede local; checksum ignora payload para eficiência.",
                                  "learningObjective": "Entender como TTL, Protocol e Checksum garantem roteamento seguro e integridade.",
                                  "commonMistakes": "Confundir Protocol com porta; checksum é só do cabeçalho e muda por hop."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar endereços IP e praticar identificação completa",
                                  "subSteps": [
                                    "Descreva Source IP (32 bits, bits 96-127) e Destination IP (32 bits, bits 128-159): endereços de 4 bytes cada.",
                                    "Converta IPs decimais para binários/hex para visualizar nos 32 bits.",
                                    "Use Wireshark para capturar pacotes reais e destacar todos os campos.",
                                    "Crie uma tabela resumindo todos os 12 campos principais com tamanho, posição e função.",
                                    "Teste-se rotulando um cabeçalho capturado sem consultar notas."
                                  ],
                                  "verification": "Identifique e descreva todos os campos em um exemplo de pacote real.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark ou tcpdump",
                                    "Papel e caneta para tabela",
                                    "Pacote de exemplo IPv4"
                                  ],
                                  "tips": "Sempre verifique o IHL primeiro para saber se há opções extras além dos 20 bytes.",
                                  "learningObjective": "Identificar e descrever fluentemente todos os campos principais do cabeçalho IPv4.",
                                  "commonMistakes": "Ignorar ordem dos bytes (network byte order, big-endian)."
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture um ping (ICMP sobre IPv4) para google.com. No pacote detalhado, localize: Versão=4 (4 bits), IHL=5 (20 bytes), TTL=64, Protocol=1 (ICMP), Source IP (seu IP), Dest IP (8.8.8.8), e verifique o checksum calculado automaticamente pela ferramenta.",
                              "finalVerifications": [
                                "Liste todos os 12 campos principais com tamanhos exatos em bits.",
                                "Desenhe o diagrama do cabeçalho e rotule posições corretamente.",
                                "Explique função de DF, MF e como offset funciona em fragmentos.",
                                "Calcule ou valide um checksum de cabeçalho simples.",
                                "Identifique campos em um trace Wireshark sem erros.",
                                "Diferencie IPv4 header de IPv6 header em 3 pontos chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de tamanhos e posições bit a bit (100% correto).",
                                "Compreensão funcional: explicação clara de pelo menos 80% dos campos.",
                                "Habilidade prática: identificação correta em traces reais.",
                                "Uso correto de terminologia (ex: IHL em dwords, não bytes).",
                                "Capacidade de calcular offset e checksum em exemplos simples.",
                                "Integração de conceitos: ligação com fragmentação e roteamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações binárias, soma de complemento de 1 para checksum.",
                                "Segurança da Informação: TTL previne loops (ataques de roteamento).",
                                "Física/Engenharia: Propagação de sinal em redes (fragmentação por MTU).",
                                "Programação: Parsing de headers em sockets Python (struct module).",
                                "Estatística: Análise de tráfego para QoS via DSCP."
                              ],
                              "realWorldApplication": "Em troubleshooting de rede, administradores usam Wireshark para inspecionar TTL baixo (problemas de roteamento), checksum inválido (corrupção), ou fragmentos (firewalls bloqueando), otimizando conexões em data centers ou diagnosticando lentidão na internet."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Explicar o modelo de serviço best-effort do IP",
                            "description": "Descrever como o IP oferece entrega não garantida, sem conexão, sem ordenação ou confiabilidade, com possível perda, duplicação ou reordenação de datagramas, e como isso difere de protocolos de transporte como TCP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de serviço best-effort",
                                  "subSteps": [
                                    "Defina 'best-effort' como um modelo onde a rede faz o melhor esforço possível para entregar dados, sem garantias.",
                                    "Identifique que não há contratos de serviço: entrega não é obrigatória.",
                                    "Explique que o foco é na simplicidade e eficiência em vez de robustez.",
                                    "Compare brevemente com serviços postais sem rastreamento.",
                                    "Liste cenários onde best-effort é aceitável, como transmissão de rádio."
                                  ],
                                  "verification": "Escreva uma definição em 2-3 frases e dê um exemplo analógico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Artigo introdutório sobre IP (RFC 791)",
                                    "Vídeo curto sobre redes (YouTube: 'IP Best Effort')"
                                  ],
                                  "tips": "Use analogias cotidianas para fixar o conceito; evite jargões inicialmente.",
                                  "learningObjective": "Dominar a definição e motivação do best-effort no contexto de redes.",
                                  "commonMistakes": [
                                    "Confundir com 'zero esforço'",
                                    "Achar que best-effort significa 'ruim'",
                                    "Ignorar benefícios de simplicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar as características principais do modelo IP",
                                  "subSteps": [
                                    "Descreva 'sem conexão': IP envia datagramas independentes, sem setup de circuito.",
                                    "Explique 'não garantida': possível perda, duplicação ou reordenação de pacotes.",
                                    "Detalhe ausência de ordenação e confiabilidade: receptor deve lidar com isso.",
                                    "Estude o cabeçalho IP: identifique campos como TTL que suportam best-effort.",
                                    "Simule mentalmente o fluxo: envio > roteamento > possível descarte."
                                  ],
                                  "verification": "Liste e explique as 5 características chave em uma tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama do cabeçalho IP (impresso ou digital)",
                                    "Ferramenta online como Packet Tracer",
                                    "RFC 791 seções sobre serviço"
                                  ],
                                  "tips": "Desenhe fluxogramas para visualizar o processo não confiável.",
                                  "learningObjective": "Identificar e descrever precisamente as limitações do IP.",
                                  "commonMistakes": [
                                    "Achar que IP garante entrega",
                                    "Confundir datagrama com stream",
                                    "Ignorar TTL como mecanismo de proteção"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar IP com protocolos de transporte como TCP",
                                  "subSteps": [
                                    "Compare camadas: IP (rede) vs TCP (transporte).",
                                    "Liste diferenças: TCP garante entrega, ordenação, controle de fluxo; IP não.",
                                    "Explique por quê: TCP adiciona overhead para confiabilidade sobre IP best-effort.",
                                    "Analise trade-offs: IP rápido/escalável; TCP confiável mas lento.",
                                    "Exemplo: HTTP/TCP vs UDP/IP em streaming."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 4 colunas (Característica, IP, TCP, Implicação).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela modelo em Excel/Google Sheets",
                                    "Documentação TCP/IP (RFC 793)",
                                    "Vídeo comparativo TCP vs UDP"
                                  ],
                                  "tips": "Use cores na tabela para destacar diferenças; foque em implicações práticas.",
                                  "learningObjective": "Diferenciar claramente os modelos de serviço de IP e TCP.",
                                  "commonMistakes": [
                                    "Colocar TCP na camada de rede",
                                    "Subestimar overhead do TCP",
                                    "Ignorar que UDP usa IP best-effort"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar implicações e mecanismos de mitigação",
                                  "subSteps": [
                                    "Discuta problemas: perda (congestionamento), duplicação (roteadores), reordenação (rotas diferentes).",
                                    "Explique mecanismos IP: checksum, fragmentação, TTL para loops.",
                                    "Descreva como apps lidam: retransmissão em camadas superiores.",
                                    "Analise escalabilidade: best-effort permite bilhões de hosts.",
                                    "Reflita sobre design: simplicidade > perfeição."
                                  ],
                                  "verification": "Responda a 3 perguntas: 'Por que perda ocorre?', 'Como mitigar?', 'Vantagem da simplicidade?'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Exemplos de traces Wireshark",
                                    "Artigo sobre congestionamento na Internet"
                                  ],
                                  "tips": "Execute uma simulação simples de perda de pacotes para ver na prática.",
                                  "learningObjective": "Entender impactos reais e razões de design do best-effort.",
                                  "commonMistakes": [
                                    "Achar IP responsável por confiabilidade",
                                    "Ignorar fragmentação",
                                    "Superestimar mecanismos de correção no IP"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark em uma rede local, capture tráfego UDP (ex: ping com flood). Observe datagramas IP chegando fora de ordem ou perdidos devido a congestionamento artificial (limite bandwidth). Compare com TCP (ex: download arquivo) onde reordenação é invisível ao usuário.",
                              "finalVerifications": [
                                "Liste e explique 5 características do best-effort do IP.",
                                "Descreva 3 diferenças chave entre IP e TCP.",
                                "Explique com analogia como perda de datagramas ocorre.",
                                "Identifique 2 mecanismos no cabeçalho IP que suportam best-effort.",
                                "Dê um exemplo de app que depende de best-effort e por quê.",
                                "Simule verbalmente o que acontece se um datagrama for duplicado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de best-effort (sem garantias).",
                                "Correta identificação de características (perda, duplicação, etc.).",
                                "Comparação clara e precisa com TCP.",
                                "Uso de exemplos concretos e analogias.",
                                "Compreensão de trade-offs e implicações de design.",
                                "Capacidade de explicar mecanismos de mitigação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e estatística para modelar perda de pacotes.",
                                "Física: Analogia com propagação de ondas e interferência em sinais.",
                                "Economia: Trade-offs custo-benefício em sistemas escaláveis.",
                                "Filosofia: Princípios de minimalismo e eficiência em design.",
                                "Segurança: Implicações de best-effort em ataques como DDoS."
                              ],
                              "realWorldApplication": "O modelo best-effort do IP é fundamental para a Internet, permitindo escalabilidade massiva em serviços como streaming de vídeo (Netflix via UDP), jogos online (latência baixa > perfeição) e IoT, onde dispositivos simples enviam dados sem overhead de confiabilidade, contrastando com transferências críticas como banking que usam TCP sobre IP."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Interpretar os campos TTL e Protocolo",
                            "description": "Explicar o funcionamento do TTL (decrementado a cada salto para evitar loops infinitos) e o campo Protocolo (que indica o protocolo de camada superior encapsulado no datagrama IP).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Campo TTL (Time To Live)",
                                  "subSteps": [
                                    "Estude a definição de TTL: um contador de 8 bits no cabeçalho IP que limita o número de saltos (hops) de um datagrama.",
                                    "Aprenda o propósito principal: prevenir loops infinitos em roteadores ao decrementar TTL em 1 a cada salto.",
                                    "Identifique valores iniciais comuns: tipicamente 64 ou 128, dependendo do SO (ex: Linux usa 64, Windows 128).",
                                    "Analise o que acontece quando TTL chega a 0: o roteador descarta o pacote e envia mensagem ICMP Time Exceeded.",
                                    "Pratique convertendo valores decimais para binários/hexadecimais (ex: TTL=64 é 0x40)."
                                  ],
                                  "verification": "Resuma em uma frase o mecanismo de decremento e propósito anti-loop; converta 3 valores de TTL corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 791 (IP)",
                                    "Cabeçalho IP diagram (imagem ou PDF)",
                                    "Calculadora binária/hex"
                                  ],
                                  "tips": "Lembre-se: TTL mede hops, não tempo real; foque no contador de saltos.",
                                  "learningObjective": "Explicar o funcionamento e propósito do campo TTL com precisão técnica.",
                                  "commonMistakes": [
                                    "Confundir TTL com tempo absoluto em segundos.",
                                    "Ignorar que decremento ocorre apenas em roteadores, não hosts.",
                                    "Esquecer mensagem ICMP ao TTL=0."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Campo Protocolo",
                                  "subSteps": [
                                    "Defina o campo Protocolo: 8 bits que identificam o protocolo de camada superior encapsulado (ex: TCP, UDP).",
                                    "Memorize valores comuns: ICMP=1, IGMP=2, TCP=6, UDP=17, ESP=50 (IPsec).",
                                    "Entenda a importância: permite que o host receptor decida qual protocolo entregar os dados.",
                                    "Estude tabela de protocolos da IANA para mais valores.",
                                    "Pratique identificando: dado um valor hex 0x11, associe a UDP."
                                  ],
                                  "verification": "Liste 5 valores de Protocolo comuns com nomes; explique decapsulamento.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista IANA Protocol Numbers",
                                    "Cabeçalho IP com offsets destacados",
                                    "Tabela de protocolos PDF"
                                  ],
                                  "tips": "Pense no Protocolo como um 'rótulo de entrega' para a camada de transporte.",
                                  "learningObjective": "Identificar e interpretar valores do campo Protocolo para protocolos de camada superior.",
                                  "commonMistakes": [
                                    "Confundir com campo 'Tipo de Serviço' ou outros.",
                                    "Achar que é para camada 2 (Ethernet).",
                                    "Esquecer valores como 1 (ICMP) em pings."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar TTL e Protocolo em um Cabeçalho IP Exemplo",
                                  "subSteps": [
                                    "Examine um cabeçalho IP dump: identifique offsets (TTL byte 8, Protocolo byte 9).",
                                    "Analise exemplo: TTL=0x40 (64), Protocolo=0x06 (TCP); interprete significados.",
                                    "Simule rota: trace hops decrementando TTL manualmente em papel.",
                                    "Compare com traceroute: observe TTL decremento em respostas ICMP.",
                                    "Registre em tabela: posição, valor hex/dec, interpretação."
                                  ],
                                  "verification": "Anote interpretação completa de 2 cabeçalhos exemplo fornecidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark ou tcpdump capture",
                                    "Hex dump de pacotes IP exemplo",
                                    "Ferramenta traceroute"
                                  ],
                                  "tips": "Use Wireshark filtro 'ip' para isolar cabeçalhos; expanda IPv4 para ver campos.",
                                  "learningObjective": "Analisar valores reais de TTL e Protocolo em datagramas IP.",
                                  "commonMistakes": [
                                    "Ler offsets errados (TTL é byte 8 da versão 4).",
                                    "Ignorar endianness em dumps (big-endian padrão).",
                                    "Não correlacionar Protocolo com payload."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conhecimento em Cenários Práticos",
                                  "subSteps": [
                                    "Execute traceroute para ver TTL em ação (ex: traceroute google.com).",
                                    "Capture tráfego com ping/UDP e verifique Protocolo no Wireshark.",
                                    "Simule loop: discuta o que acontece se TTL alto em rede com loop.",
                                    "Troubleshoot: dado TTL=1 na chegada, quantos hops ocorreram?",
                                    "Crie quiz pessoal: interprete 3 cenários variados."
                                  ],
                                  "verification": "Capture e interprete 1 pacote real; explique 2 cenários de falha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Comando traceroute/ping",
                                    "Rede com internet"
                                  ],
                                  "tips": "Inicie com ping local para TTL alto; vá para remoto para ver decremento.",
                                  "learningObjective": "Aplicar interpretação de TTL e Protocolo em ferramentas de rede reais.",
                                  "commonMistakes": [
                                    "Não filtrar tráfego irrelevante no Wireshark.",
                                    "Confundir TTL de ida/volta em traceroute.",
                                    "Ignorar firewalls que alteram TTL."
                                  ]
                                }
                              ],
                              "practicalExample": "Capture um pacote ICMP (ping) para 8.8.8.8 com Wireshark: observe TTL inicial=64 (Windows), Protocolo=1. Trace rota com traceroute; veja TTL decrementar (ex: hop3 TTL=61). Para TCP (navegação), Protocolo=6 leva a porta 80/443.",
                              "finalVerifications": [
                                "Explicar mecanismo anti-loop do TTL com diagrama de 4 hops.",
                                "Listar e decodificar 5 valores de Protocolo comuns de memória.",
                                "Interpretar offsets corretos em hex dump de cabeçalho IP.",
                                "Simular falha: pacote com TTL=0 não chega ao destino.",
                                "Diferenciar uso de TTL em traceroute vs tráfego normal.",
                                "Identificar Protocolo=17 como UDP e implicações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de decremento TTL (100% correta).",
                                "Correta associação de pelo menos 80% dos valores Protocolo.",
                                "Análise correta de cabeçalho exemplo sem erros de offset.",
                                "Demonstração prática via Wireshark/traceroute screenshots.",
                                "Compreensão de interações (TTL=0 → ICMP; Protocolo → decapsulamento).",
                                "Criatividade em cenários de troubleshooting."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão binário/decimal/hex para campos de 8 bits.",
                                "Segurança da Informação: TTL em ataques de loop ou traceroute stealth.",
                                "Programação: Uso de sockets para definir TTL (setsockopt) em apps de rede.",
                                "Física: Analogia de TTL com decaimento de sinal em transmissão.",
                                "Estatística: Análise de distribuição de TTL em tráfego real."
                              ],
                              "realWorldApplication": "Em administração de redes, TTL baixo em pacotes indica rotas longas ou problemas (ex: otimizar roteamento); Protocolo garante entrega correta a apps (ex: firewall bloqueia UDP=17); essencial em troubleshooting com Wireshark e prevenção de loops em BGP."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Endereçamento IP",
                        "description": "Dominar o sistema de endereçamento lógico IPv4, incluindo classes, máscaras de sub-rede e noções básicas de CIDR para identificação de redes e hosts.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Classificar endereços IPv4 por classes",
                            "description": "Identificar as classes A (1-126), B (128-191), C (192-223), D (multicast) e E (reservada), explicando o número de bits para rede e host em cada uma, e calcular o range de endereços válidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura básica do endereço IPv4 e o conceito de classes de endereçamento",
                                  "subSteps": [
                                    "Explicar que um endereço IPv4 é composto por 32 bits divididos em 4 octetos (cada um de 8 bits, representado em decimal de 0-255).",
                                    "Descrever o conceito de classes de IP: divisão hierárquica em rede e host baseada no primeiro octeto.",
                                    "Listar as classes principais: A, B, C (unicast), D (multicast), E (reservada).",
                                    "Identificar endereços especiais: 0.0.0.0 (padrão), 127.0.0.0/8 (loopback).",
                                    "Converter um IP exemplo (ex: 192.168.1.1) para binário nos primeiros bits para visualizar a máscara de classe."
                                  ],
                                  "verification": "Criar um diagrama da estrutura IPv4 com classes marcadas e explicar verbalmente ou por escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora binária online ou app",
                                    "Tabela de classes IPv4 impressa"
                                  ],
                                  "tips": "Sempre comece pelo primeiro octeto para classificação rápida; memorize o bit de início de cada classe (0 para A, 10 para B, 110 para C).",
                                  "learningObjective": "Compreender a composição binária e decimal do IPv4 e o propósito das classes de endereçamento.",
                                  "commonMistakes": [
                                    "Confundir octetos com bits individuais",
                                    "Ignorar que classes são baseadas apenas no primeiro octeto",
                                    "Esquecer endereços reservados como 127.x.x.x"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar ranges, máscaras e bits de rede/host para cada classe",
                                  "subSteps": [
                                    "Classe A: 1-126 (bit inicial 0), 8 bits rede, 24 bits host (máscara /8).",
                                    "Classe B: 128-191 (bits iniciais 10), 16 bits rede, 16 bits host (/16).",
                                    "Classe C: 192-223 (bits iniciais 110), 24 bits rede, 8 bits host (/24).",
                                    "Classe D: 224-239 (bits iniciais 1110), multicast, sem rede/host tradicional.",
                                    "Classe E: 240-255 (bits iniciais 1111), reservada para pesquisa."
                                  ],
                                  "verification": "Recitar de memória os ranges e bits para cada classe e preencher uma tabela em branco.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Flashcards com ranges e bits",
                                    "Tabela em branco para preenchimento",
                                    "Vídeo curto sobre classes IPv4 (opcional)"
                                  ],
                                  "tips": "Use mnemônicos: 'A para Ampla (poucos nets, muitos hosts)', 'C para Comum (muitos nets, poucos hosts)'; pratique com quiz online.",
                                  "learningObjective": "Identificar precisamente o range e alocação de bits para rede e host em cada classe IPv4.",
                                  "commonMistakes": [
                                    "Incluir 0 e 127 em classe A válida",
                                    "Confundir ranges de D e E",
                                    "Errar contagem de bits (ex: achar A tem 7 bits rede)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular ranges de endereços válidos e número de hosts por classe",
                                  "subSteps": [
                                    "Para classe A: rede fixa no 1º octeto, hosts de .0.0.1 a .255.255.254 (2^24 - 2 hosts válidos).",
                                    "Para classe B: rede nos 1º-2º octetos, hosts de .0.1 a .255.254 (2^16 - 2).",
                                    "Para classe C: rede nos 1º-3º octetos, hosts de .1 a .254 (2^8 - 2).",
                                    "Calcular exemplo: Para 10.0.0.0 (A), range 10.0.0.0 a 10.255.255.255, ~16M hosts.",
                                    "Notar sub-redes: rede e broadcast não são hosts válidos."
                                  ],
                                  "verification": "Calcular ranges e hosts para 3 IPs de classes diferentes e validar com calculadora.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel para potências de 2",
                                    "Lista de IPs exemplo"
                                  ],
                                  "tips": "Fórmula sempre: hosts = 2^(bits host) - 2; ignore alocação total, foque em válidos.",
                                  "learningObjective": "Calcular com precisão o range completo e número de endereços hosts utilizáveis por classe.",
                                  "commonMistakes": [
                                    "Esquecer subtrair rede e broadcast (-2)",
                                    "Calcular potências erradas (ex: 2^24 como 16M mas errar exato)",
                                    "Aplicar fórmula de hosts em multicast D"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar classificação de endereços IPv4 reais",
                                  "subSteps": [
                                    "Classificar 10 IPs mistos: ex: 8.8.8.8 (C), 172.16.0.1 (B), 225.1.2.3 (D).",
                                    "Para cada, identificar classe, bits rede/host, range aproximado.",
                                    "Converter primeiro octeto para binário para confirmar bits iniciais.",
                                    "Simular erro comum: classificar 127.0.0.1 (loopback, não classe A pura).",
                                    "Criar lista própria de 5 IPs e classificar com colega ou autoavaliação."
                                  ],
                                  "verification": "Quiz com 15 IPs: 100% acerto em classe, 80% em bits e range.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de 20 IPs de teste",
                                    "Ferramenta online como ipinfo.io para validação",
                                    "Cronômetro para simular exame"
                                  ],
                                  "tips": "Verifique sempre o primeiro octeto primeiro; pratique diariamente 5 IPs para fixar.",
                                  "learningObjective": "Classificar endereços IPv4 com confiança, incluindo cálculos associados.",
                                  "commonMistakes": [
                                    "Classificar 191.x como B (191 é B, mas 192 é C)",
                                    "Não notar exceções como privados (10/8 A privada)",
                                    "Confundir D/E com unicast"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o IP 192.168.1.1: Primeiro octeto 192 (110 em binário -> classe C). 24 bits rede (192.168.1.0), 8 bits host (.1 a .254). Range: 192.168.1.0 a 192.168.1.255, 254 hosts válidos. Aplicação: Configurar roteador doméstico.",
                              "finalVerifications": [
                                "Classificar corretamente 10 endereços IPv4 variados sem erros.",
                                "Explicar bits rede/host e máscara para todas as 5 classes.",
                                "Calcular range e hosts válidos para um IP de cada classe A/B/C.",
                                "Identificar e explicar exceções como loopback e multicast.",
                                "Converter 5 primeiros octetos para binário e justificar classe.",
                                "Preencher tabela completa de classes de memória."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ranges (100% para classes A/B/C/D/E).",
                                "Correção nos cálculos de bits rede/host e hosts válidos (±0 erro).",
                                "Explicação clara de conceitos, incluindo binário e exceções.",
                                "Velocidade e confiança na classificação prática (menos de 10s por IP).",
                                "Uso correto de terminologia (ex: 'máscara de classe', 'endereços válidos').",
                                "Criatividade em exemplos reais ou auto-gerados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações binárias, potências de 2 e subtrações para hosts.",
                                "Física/Engenharia: Sinais digitais e transmissão de dados em redes.",
                                "História da Computação: Evolução de classful para CIDR nos anos 90.",
                                "Segurança da Informação: Identificação de ranges multicast para vulnerabilidades."
                              ],
                              "realWorldApplication": "Em administração de redes, roteadores Cisco usam classificação para roteamento inicial; administradores de TI configuram sub-redes privadas (ex: 192.168.x.x classe C para LANs domésticas/empresariais), evitando conflitos em data centers ou IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Calcular rede e host usando máscaras de sub-rede",
                            "description": "Aplicar máscaras de sub-rede (ex: /24 = 255.255.255.0) para determinar o endereço de rede, broadcast e hosts disponíveis a partir de um IP dado, como 192.168.1.100/24.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Máscaras de Sub-rede e Notação CIDR",
                                  "subSteps": [
                                    "Estude a estrutura de um endereço IPv4 (4 octetos de 8 bits cada, total 32 bits).",
                                    "Aprenda que a máscara de sub-rede divide a rede em bits de rede e bits de host (ex: /24 significa 24 bits de rede).",
                                    "Memorize máscaras comuns: /24 = 255.255.255.0 (11111111.11111111.11111111.00000000 em binário).",
                                    "Converta notação CIDR para máscara decimal e vice-versa.",
                                    "Identifique o número de hosts possíveis: 2^(32 - prefixo) - 2."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que /24 representa e calcule hosts para /24.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora binária online",
                                    "Tabela de máscaras CIDR"
                                  ],
                                  "tips": "Use mnemônicos para máscaras: /8=255.0.0.0, /16=255.255.0.0, /24=255.255.255.0.",
                                  "learningObjective": "Compreender o papel da máscara de sub-rede na divisão de endereços IP.",
                                  "commonMistakes": [
                                    "Confundir bits de rede com bits de host",
                                    "Esquecer de subtrair 2 para hosts utilizáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter IP e Máscara para Binário e Calcular Endereço de Rede",
                                  "subSteps": [
                                    "Converta cada octeto do IP para binário (ex: 192=11000000).",
                                    "Converta a máscara para binário (ex: /24=11111111.11111111.11111111.00000000).",
                                    "Aplique operação AND bit a bit: IP AND Máscara = Endereço de Rede.",
                                    "Converta o resultado binário de volta para decimal.",
                                    "Verifique: todos os hosts da sub-rede começam com esse prefixo."
                                  ],
                                  "verification": "Calcule endereço de rede para 192.168.1.100/24 e confirme 192.168.1.0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de conversão binário-decimal (ex: RapidTables)",
                                    "Papel e caneta para prática manual"
                                  ],
                                  "tips": "Preencha zeros à esquerda nos binários para 8 bits sempre.",
                                  "learningObjective": "Executar cálculo preciso do endereço de rede usando AND lógico.",
                                  "commonMistakes": [
                                    "Erros na conversão decimal-binário",
                                    "Aplicar OR em vez de AND"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Endereço de Broadcast",
                                  "subSteps": [
                                    "Inverta a máscara de sub-rede (todos 1s viram 0s e vice-versa).",
                                    "Aplique operação OR bit a bit: Endereço de Rede OR Máscara Invertida = Broadcast.",
                                    "Converta o resultado para decimal.",
                                    "Confirme: broadcast tem todos os bits de host em 1.",
                                    "Exemplo: Para /24, últimos 8 bits em 1 = .255."
                                  ],
                                  "verification": "Para 192.168.1.0/24, calcule broadcast como 192.168.1.255.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora lógica online",
                                    "Exemplos de sub-redes"
                                  ],
                                  "tips": "Máscara invertida de /24 é 0.0.0.255.",
                                  "learningObjective": "Determinar o endereço de broadcast da sub-rede.",
                                  "commonMistakes": [
                                    "Confundir inversão da máscara",
                                    "Usar AND para broadcast"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar Hosts Disponíveis e Praticar Integração",
                                  "subSteps": [
                                    "Calcule total de endereços: 2^(bits de host).",
                                    "Subtraia rede e broadcast: hosts utilizáveis = total - 2.",
                                    "Liste intervalo de hosts: rede+1 até broadcast-1.",
                                    "Pratique com IP diferente, ex: 10.0.0.50/26.",
                                    "Valide com ferramenta online para confirmação."
                                  ],
                                  "verification": "Para 192.168.1.100/24, liste: rede 192.168.1.0, broadcast 192.168.1.255, hosts 192.168.1.1 a .254 (254 hosts).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Subnet Calculator online (ex: subnet-calculator.com)",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Para /31, hosts=0 (ponto-ponto); /32=um host só.",
                                  "learningObjective": "Calcular e listar hosts válidos em uma sub-rede.",
                                  "commonMistakes": [
                                    "Incluir rede/broadcast como hosts",
                                    "Erro no expoente de bits de host"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado IP 172.16.5.130/23: Máscara 255.255.254.0. Endereço de rede: 172.16.4.0 (AND). Broadcast: 172.16.5.255 (OR com invertida 0.0.1.255). Hosts: 510 utilizáveis (de 172.16.4.1 a 172.16.5.254).",
                              "finalVerifications": [
                                "Calcule corretamente rede, broadcast e hosts para 3 IPs diferentes (/24, /26, /30).",
                                "Explique o impacto de máscaras variadas no número de hosts.",
                                "Identifique hosts válidos em um intervalo dado.",
                                "Use ferramenta online para validar seus cálculos manuais.",
                                "Resolva um problema de troubleshooting: 'Por que 192.168.1.1 e .254 não são hosts?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos binários e decimais.",
                                "Correta identificação de rede, broadcast e hosts válidos.",
                                "Explicação clara do raciocínio lógico (AND/OR/inversão).",
                                "Eficiência no tempo: completa em <2h total.",
                                "Aplicação correta em exemplos variados (classes A/B/C)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações binárias, potências de 2 e lógica booleana.",
                                "Segurança da Informação: Segmentação de redes para isolamento de tráfego.",
                                "Administração de Sistemas: Planejamento de sub-redes em ambientes empresariais.",
                                "Física/Elétrica: Representação binária em hardware de rede."
                              ],
                              "realWorldApplication": "Em uma rede corporativa, um administrador usa isso para dividir 192.168.1.0/24 em sub-redes menores (/26), alocando 192.168.1.0/26 para RH (62 hosts), evitando desperdício e melhorando segurança/firewall."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Compreender endereços CIDR e supernetting",
                            "description": "Explicar Classless Inter-Domain Routing (CIDR), notação /n e agregação de rotas para reduzir tabelas de roteamento, com exemplos como 192.168.0.0/23 cobrindo duas /24.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do Endereçamento IP de Classe e Limitações",
                                  "subSteps": [
                                    "Revise as classes de endereços IP (A, B, C) e suas máscaras padrão (/8, /16, /24).",
                                    "Identifique problemas das classes: desperdício de endereços e tabelas de roteamento inchadas.",
                                    "Converta endereços IP decimais para binários para visualizar máscaras.",
                                    "Calcule o número de hosts por sub-rede em classes padrão.",
                                    "Compare classful vs classless routing."
                                  ],
                                  "verification": "Liste corretamente as máscaras de classes A, B, C e explique uma limitação com um exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora binária online",
                                    "Tabela de classes IP (PDF ou wiki)",
                                    "Papel e caneta para conversões"
                                  ],
                                  "tips": "Sempre comece convertendo para binário para visualizar bits de rede/host claramente.",
                                  "learningObjective": "Compreender por que o CIDR foi introduzido como solução para ineficiências do classful addressing.",
                                  "commonMistakes": [
                                    "Confundir número de hosts com endereços totais (subtraia rede e broadcast)",
                                    "Ignorar o desperdício em classes A e B"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Notação CIDR e Cálculo de Máscaras /n",
                                  "subSteps": [
                                    "Aprenda a notação CIDR: IP/prefixo (ex: 192.168.0.0/24 significa 24 bits de rede).",
                                    "Converta /n para máscara de sub-rede em decimal e binário.",
                                    "Calcule o número de endereços: 2^(32-n), subtraindo rede e broadcast para hosts.",
                                    "Determine o range de IPs: primeiro IP é rede, último é broadcast.",
                                    "Pratique com /16, /23, /27."
                                  ],
                                  "verification": "Converta 10.0.0.0/23 para máscara decimal e calcule hosts (510).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta online de calculadora CIDR (ex: subnet-calculator.com)",
                                    "Planilha Excel para cálculos binários"
                                  ],
                                  "tips": "Lembre: /n onde n=24 é 255.255.255.0; adicione zeros à direita em binário para hosts.",
                                  "learningObjective": "Calcular precisamente ranges e hosts em qualquer notação CIDR /n.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair rede/broadcast para hosts viáveis",
                                    "Erro em contagem de bits (32 total)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender Subnetting e Supernetting (Agregação de Rotas)",
                                  "subSteps": [
                                    "Diferencie subnetting (dividir /24 em menores) de supernetting (combinar /24 em maiores).",
                                    "Para supernetting: encontre prefixo comum em binário (ex: 192.168.0.0/24 + 192.168.1.0/24 = /23).",
                                    "Verifique se ranges são contíguos e alinhados em potências de 2.",
                                    "Calcule supernets: reduza bits de host até cobrir múltiplas sub-redes.",
                                    "Exemplo: 4x /24 = /22 (2^(32-22)=1024 endereços)."
                                  ],
                                  "verification": "Agregue 192.168.0.0/24 e 192.168.1.0/24 em supernet correto (/23).",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Simulador de roteador como Cisco Packet Tracer",
                                    "Lista de exemplos de supernets"
                                  ],
                                  "tips": "Alinhe os ranges pelo bit mais significativo comum; teste com ping simulado.",
                                  "learningObjective": "Aplicar supernetting para agregar rotas e reduzir entradas em tabelas.",
                                  "commonMistakes": [
                                    "Combinar ranges não-contíguos",
                                    "Não verificar alinhamento binário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Exemplos e Aplicar em Cenários de Roteamento",
                                  "subSteps": [
                                    "Resolva exercícios: encontre supernet para 8 sub-redes /24 consecutivas (/21).",
                                    "Simule tabela de roteamento: mostre redução de linhas com CIDR.",
                                    "Crie diagrama de rede usando CIDR para 2 departamentos (/25 cada, supernet /24).",
                                    "Compare tamanhos de tabelas classful vs CIDR.",
                                    "Teste com ferramenta: valide ranges sem overlap."
                                  ],
                                  "verification": "Crie e explique uma tabela de roteamento otimizada com supernets para 4 redes.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Packet Tracer ou GNS3",
                                    "Exercícios PDF de CIDR",
                                    "Whiteboard virtual"
                                  ],
                                  "tips": "Use binário para visualização rápida; memorize potências de 2 (512=/23, 256=/24).",
                                  "learningObjective": "Resolver problemas reais de roteamento usando CIDR e supernetting.",
                                  "commonMistakes": [
                                    "Overlap de ranges",
                                    "Cálculo errado de prefixo comum"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa com duas sub-redes 192.168.0.0/24 (Vendas) e 192.168.1.0/24 (TI), use supernetting para anunciar 192.168.0.0/23 ao roteador upstream, reduzindo a tabela de roteamento externa de 2 para 1 entrada, economizando recursos.",
                              "finalVerifications": [
                                "Explique CIDR vs classful e dê exemplo de notação /n.",
                                "Calcule hosts e range para 10.1.1.0/26.",
                                "Agregue corretamente duas /24 em /23.",
                                "Descreva benefício da agregação de rotas.",
                                "Identifique erro em supernet inválido (ex: ranges não alinhados)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de máscaras, hosts e ranges (100% correto).",
                                "Explicação clara de supernetting com binário visual.",
                                "Identificação correta de quando supernetting é aplicável.",
                                "Uso de exemplos reais sem erros comuns.",
                                "Redução demonstrada em tamanho de tabela de roteamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações binárias, potências de 2 e logaritmos.",
                                "Segurança da Informação: Segmentação de redes com CIDR para isolamento.",
                                "Administração: Otimização de recursos de rede para escalabilidade.",
                                "Física/Engenharia: Modelagem de tráfego em redes físicas."
                              ],
                              "realWorldApplication": "Provedores de internet usam CIDR/supernetting para anunciar blocos BGP eficientes (ex: /8 da Apple como 17.0.0.0/8), reduzindo a tabela global de roteamento de milhões para ~900k entradas, evitando colapsos na Internet."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Fragmentação e Roteamento de Datagramas",
                        "description": "Entender os mecanismos de fragmentação para MTU heterogêneos e o processo básico de roteamento de datagramas IP em redes.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Descrever o processo de fragmentação IP",
                            "description": "Explicar quando e como um datagrama é fragmentado (se maior que MTU do enlace), usando campos identificação, flags MF (mais fragmentos), DF (don't fragment) e offset de fragmento (em unidades de 8 bytes).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os gatilhos para fragmentação IP",
                                  "subSteps": [
                                    "Defina MTU (Maximum Transmission Unit) como o tamanho máximo de um frame no enlace físico.",
                                    "Explique que fragmentação ocorre quando o datagrama IP excede o MTU da saída do roteador.",
                                    "Descreva o papel da flag DF (Don't Fragment): se setada, o datagrama é descartado e ICMP 'Fragmentation Needed' é enviado.",
                                    "Discuta cenários onde fragmentação é necessária, como túneis ou mudanças de MTU em rotas.",
                                    "Identifique que apenas o roteador de saída fragmenta, não o origem se souber o Path MTU."
                                  ],
                                  "verification": "Resuma em uma frase quando e por que fragmentar, citando DF e MTU corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de header IP",
                                    "Exemplo de datagrama com Wireshark"
                                  ],
                                  "tips": "Sempre verifique o MTU da interface de saída, não da entrada.",
                                  "learningObjective": "Identificar condições precisas para iniciar fragmentação IP.",
                                  "commonMistakes": [
                                    "Confundir MTU de enlace com MSS de TCP",
                                    "Ignorar que origem pode pré-fragmentar com Path MTU Discovery"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar campos do header IP para fragmentação",
                                  "subSteps": [
                                    "Localize o campo Identification (16 bits): usado para agrupar fragmentos do mesmo datagrama original.",
                                    "Examine Flags (3 bits): bit 0 reservado (0), bit 1 = DF, bit 2 = MF (More Fragments, 1 se não for o último).",
                                    "Estude Fragment Offset (13 bits): indica posição do fragmento no datagrama original, em unidades de 8 bytes.",
                                    "Calcule o tamanho total do header IP (20 bytes mínimo) e como ele afeta o payload fragmentado.",
                                    "Verifique Total Length: soma header + dados do fragmento."
                                  ],
                                  "verification": "Desenhe o header IP destacando Identification, Flags e Offset, com valores exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Header IP detalhado em imagem ou Wireshark",
                                    "Calculadora para offsets"
                                  ],
                                  "tips": "Offset * 8 = bytes reais desde o início do payload original.",
                                  "learningObjective": "Mapear e interpretar campos exatos usados na fragmentação.",
                                  "commonMistakes": [
                                    "Confundir MF com DF",
                                    "Esquecer que offset é em múltiplos de 8 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o processo de fragmentação passo a passo",
                                  "subSteps": [
                                    "Copie o header IP original para todos fragmentos, mantendo Identification igual.",
                                    "Divida o payload original em pedaços ≤ (MTU - header IP), alinhados em 8 bytes.",
                                    "Para primeiro fragmento: Offset=0, MF=1 (se >1 fragmento).",
                                    "Para fragmentos intermediários: Offset = (tamanho anterior cumulativo)/8, MF=1.",
                                    "Para último: Offset apropriado, MF=0; ajuste Total Length para cada.",
                                    "Roteie fragmentos independentemente."
                                  ],
                                  "verification": "Fragmentar um datagrama exemplo de 4000 bytes com MTU=1500 e listar headers de cada fragmento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para cálculos",
                                    "Simulador IP fragmentation online"
                                  ],
                                  "tips": "Garanta que fragmentos não excedam MTU incluindo novo header.",
                                  "learningObjective": "Simular fragmentação completa com cálculos precisos.",
                                  "commonMistakes": [
                                    "Não alinhar offset em 8 bytes",
                                    "Setar MF=1 no último fragmento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender reassembly e implicações",
                                  "subSteps": [
                                    "Explique que reassembly ocorre apenas no destino final, usando Identification + origem/destino.",
                                    "Ordene fragmentos por Offset, valide MF (deve haver MF=0 no final).",
                                    "Reconstrua payload concatenando dados, descartando se faltar fragmento ou inconsistente.",
                                    "Discuta overhead: perda de performance, risco de fragmentos perdidos.",
                                    "Mencione IPv6: sem fragmentação em roteadores, usa Path MTU Discovery."
                                  ],
                                  "verification": "Descreva sequência de reassembly para fragmentos exemplo, identificando erros potenciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo de captura Wireshark com fragmentos IP",
                                    "Diagrama de reassembly"
                                  ],
                                  "tips": "Roteadores não reassembly; só encaminham fragmentos.",
                                  "learningObjective": "Compreender ciclo completo de fragmentação e reassembly.",
                                  "commonMistakes": [
                                    "Pensar que roteadores reassembly",
                                    "Ignorar que IPv4 destino faz reassembly"
                                  ]
                                }
                              ],
                              "practicalExample": "Datagrama IP original: Header 20 bytes + Payload 3976 bytes (Total Length=3996). MTU saída=1500. Fragmentos: 1º (Offset=0, MF=1, Length=1500, dados=1480); 2º (Offset=185, MF=1, Length=1500, dados=1480); 3º (Offset=370, MF=0, Length=1016, dados=996). Todos com mesmo Identification.",
                              "finalVerifications": [
                                "Calcule offset correto para 3º fragmento de payload 2000 bytes fragmentado em MTU 800.",
                                "Explique o que acontece se DF=1 e MTU insuficiente.",
                                "Identifique MF e offset em um header IP capturado no Wireshark.",
                                "Descreva reassembly se um fragmento intermediário perdido.",
                                "Compare fragmentação IPv4 vs IPv6.",
                                "Liste 3 riscos de fragmentação em redes reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos campos IP (Identification, Flags, Offset em 8 bytes): 30%",
                                "Correção no processo de divisão e cálculo de fragmentos: 25%",
                                "Explicação clara de triggers (MTU, DF) e reassembly: 20%",
                                "Uso de exemplo numérico concreto e verificável: 15%",
                                "Identificação de erros comuns e tips práticos: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos de divisão, multiplicação por 8 e offsets modulares.",
                                "Física: Limites de transmissão em meios físicos (ex: Ethernet MTU).",
                                "Segurança da Informação: Ataques de fragmentação (Teardrop) e Path MTU Discovery.",
                                "Desenvolvimento de Software: Implementação em bibliotecas de rede (ex: Scapy Python)."
                              ],
                              "realWorldApplication": "Em redes WAN ou VPNs (ex: túneis GRE), onde MTUs variam, fragmentação permite transmissão sobre enlaces menores; ferramentas como PMTUD evitam, mas entendimento é crucial para debug de perdas de pacotes em firewalls que bloqueiam fragmentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Explicar a reagregação de fragmentos",
                            "description": "Detalhar como o host de destino reagrega fragmentos usando identificação e offset, descartando se incompleto ou com erro no checksum, sem reordenação intermediária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Campos de Identificação e Offset nos Fragmentos IP",
                                  "subSteps": [
                                    "Estude o cabeçalho IP fragmentado: identifique o campo Identification (16 bits), Fragment Offset (13 bits) e Flags (3 bits, especialmente MF - More Fragments).",
                                    "Aprenda como o Identification é o mesmo para todos os fragmentos de um datagrama original, permitindo agrupamento.",
                                    "Calcule offsets: offset indica a posição do fragmento em unidades de 8 bytes (ex: offset 0 = primeiro fragmento).",
                                    "Identifique o bit MF: 1 se mais fragmentos virão, 0 no último.",
                                    "Revise exemplos numéricos: datagrama de 4000 bytes fragmentado em MTU 1500, calcule offsets (0, 185, 370)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como ID e offset agrupam fragmentos, com um exemplo numérico correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Cabeçalho IP diagram (RFC 791)",
                                    "Calculadora para offsets",
                                    "Ferramenta Wireshark para capturar fragmentos reais"
                                  ],
                                  "tips": "Sempre multiplique offset por 8 para obter bytes reais; memorize que ID é único por datagrama.",
                                  "learningObjective": "Identificar e interpretar corretamente os campos Identification, Offset e Flags em fragmentos IP.",
                                  "commonMistakes": [
                                    "Confundir offset com bytes diretos (esquecer x8)",
                                    "Ignorar MF no último fragmento",
                                    "Achar que ID muda por fragmento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular o Processo de Recebimento e Armazenamento de Fragmentos",
                                  "subSteps": [
                                    "Configure um buffer de reassembly no host destino para cada ID único.",
                                    "Ao receber um fragmento: extraia ID, offset e MF; armazene dados no buffer na posição offset x 8.",
                                    "Não reordene intermediariamente: roteadores não fazem isso, apenas hosts finais.",
                                    "Registre chegada fora de ordem: exiba timeline de chegada de fragmentos 1,3,2.",
                                    "Implemente uma tabela simples: ID | Offset | Dados | MF | Checsum OK."
                                  ],
                                  "verification": "Crie uma tabela manual simulando armazenamento de 3 fragmentos fora de ordem e mostre o buffer parcial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para tabela",
                                    "Simulador IP fragmentation online (ex: Cisco Packet Tracer)",
                                    "Exemplos de traces Wireshark"
                                  ],
                                  "tips": "Use um timer: descarte buffer após 15-60s se incompleto (timer de reassembly).",
                                  "learningObjective": "Simular o armazenamento ordenado de fragmentos usando ID e offset sem reordenação prematura.",
                                  "commonMistakes": [
                                    "Tentar reordenar durante recebimento (só host final faz)",
                                    "Perder fragmentos duplicados (aceitar apenas primeiro)",
                                    "Ignorar timer de reassembly"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Completude, Checksum e Descartar Fragmentos Inválidos",
                                  "subSteps": [
                                    "Ao receber fragmento com MF=0: verifique se todos offsets até Total Length estão preenchidos.",
                                    "Calcule gaps: compare offsets sequenciais; se gap ou overlap inválido, descarte buffer inteiro.",
                                    "Valide checksum do cabeçalho de cada fragmento individualmente (não do todo ainda).",
                                    "Se incompleto após timer ou MF=0 sem full coverage: descarte e envie ICMP Time Exceeded se aplicável.",
                                    "Detecte erros: duplicatas (ignorar), offsets inválidos (> total length)."
                                  ],
                                  "verification": "Analise um trace Wireshark com fragmentos incompletos e identifique por que foi descartado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark com filtro 'ip.flags.mf == 1'",
                                    "RFC 791 seção sobre reassembly",
                                    "Checklist de verificações em planilha"
                                  ],
                                  "tips": "Checksum é por fragmento, não global; sempre cheque MF=0 como trigger para verificação final.",
                                  "learningObjective": "Aplicar regras de descarte para fragmentos incompletos, com erros de checksum ou gaps.",
                                  "commonMistakes": [
                                    "Checksum no datagrama completo prematuramente",
                                    "Não descartar buffer inteiro em gap",
                                    "Aceitar overlaps sem validação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar a Reagregação Final e Entrega do Datagrama",
                                  "subSteps": [
                                    "Concatene dados do buffer: copie sequencialmente de offset 0 ao final.",
                                    "Remova headers de fragmentos; reconstrua header IP original (ajuste Total Length, limpe flags/offset).",
                                    "Calcule checksum IP final no datagrama reagregado.",
                                    "Passe para camada superior (TCP/UDP) se checksum OK.",
                                    "Teste: envie datagrama grande via ping com DF=0 e capture reassembly."
                                  ],
                                  "verification": "Reconstrua um datagrama de 3 fragmentos em papel e valide header final.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ping com grandes pacotes (ping -s 4000)",
                                    "Wireshark para before/after",
                                    "Editor hex para manual reassembly"
                                  ],
                                  "tips": "Header original preserva TTL inicial aproximado; foco em dados payload.",
                                  "learningObjective": "Reconstruir e validar o datagrama original a partir do buffer reagregado.",
                                  "commonMistakes": [
                                    "Copiar headers fragmentados no final",
                                    "Esquecer limpar flags/offset no header IP",
                                    "Não recalcular Total Length"
                                  ]
                                }
                              ],
                              "practicalExample": "Use Wireshark para capturar 'ping -s 3000 -M do <IP>' (Don't Fragment=0). Observe fragmentos com mesmo ID, offsets 0/1480/2960 (MF=0 no último). Veja reassembly automático no host, identificando gaps se um fragmento perdido.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo: ID agrupa, offset posiciona, MF triggera check.",
                                "Identificar em trace Wireshark um caso de descarte por incompleto.",
                                "Calcular offset correto para um fragmento dado (ex: posição 1480 bytes -> offset 185).",
                                "Simular tabela de buffer com 4 fragmentos fora de ordem.",
                                "Descrever consequências de erro checksum em um fragmento.",
                                "Reconstruir header IP final de exemplo fragmentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de ID/offset/MF (100% correto).",
                                "Correta identificação de regras de descarte (incompleto/checksum/gap).",
                                "Exemplo prático com Wireshark ou simulação válida.",
                                "Compreensão de no-reordenação intermediária.",
                                "Cálculos de offset e reassembly sem erros matemáticos.",
                                "Integração de timer de reassembly e ICMP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos binários e aritmética modular para offsets (13 bits x8).",
                                "Segurança da Informação: Checksum como detecção de integridade (CRC similar).",
                                "Física: Analogia com ondas/partículas fragmentadas e reagregadas.",
                                "Programação: Implementar buffer em Python/C para reassembly.",
                                "Estatística: Probabilidade de perda de fragmentos em redes reais."
                              ],
                              "realWorldApplication": "Em redes WAN/Internet, datagramas grandes (ex: vídeos streaming, downloads) são fragmentados por MTUs variáveis (Ethernet 1500 vs outros); hosts finais reagregam para apps como Netflix ou FTP funcionarem sem perda de pacotes incompletos, evitando desperdício de banda."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Compreender o roteamento básico de datagramas IP",
                            "description": "Descrever o encaminhamento de datagramas: roteador consulta tabela de roteamento baseada no IP destino, decrementa TTL, recalcula checksum e envia para próximo salto via ARP se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura do cabeçalho IP relevante para roteamento",
                                  "subSteps": [
                                    "Identifique os campos principais do cabeçalho IP: Endereço IP de origem, IP de destino, TTL (Time to Live) e Checksum.",
                                    "Descreva o papel de cada campo no processo de roteamento.",
                                    "Analise um exemplo de cabeçalho IP capturado em uma ferramenta como Wireshark.",
                                    "Diferencie campos imutáveis (origem, destino) dos mutáveis (TTL, checksum).",
                                    "Registre anotações sobre como esses campos são usados pelo roteador."
                                  ],
                                  "verification": "Liste e explique corretamente os 4 campos principais com suas funções no roteamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do cabeçalho IP (RFC 791)",
                                    "Ferramenta Wireshark ou captura de pacotes exemplo"
                                  ],
                                  "tips": "Use diagramas visuais para memorizar a posição dos campos no cabeçalho de 20 bytes.",
                                  "learningObjective": "Compreender os componentes do cabeçalho IP essenciais para o processo de roteamento de datagramas.",
                                  "commonMistakes": [
                                    "Confundir IP de origem com destino",
                                    "Ignorar que checksum é recalculado a cada salto",
                                    "Subestimar o tamanho fixo do cabeçalho"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Consultar a tabela de roteamento no roteador",
                                  "subSteps": [
                                    "Explique como o roteador usa o IP de destino para consultar a tabela de roteamento.",
                                    "Descreva o algoritmo de longest prefix match (LPM) para encontrar a melhor rota.",
                                    "Identifique a interface de saída e o próximo salto (next hop) na tabela.",
                                    "Simule uma consulta com IP destino exemplo (ex: 192.168.1.100 -> rota via 192.168.1.1).",
                                    "Discuta rotas padrão (default route) quando não há match exato."
                                  ],
                                  "verification": "Simule uma consulta em uma tabela de roteamento fictícia e indique próximo salto corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de tabela de roteamento (comando 'show ip route' em Cisco)",
                                    "Calculadora de prefixos IP online"
                                  ],
                                  "tips": "Sempre priorize rotas mais específicas (menor máscara de sub-rede).",
                                  "learningObjective": "Dominar o processo de lookup na tabela de roteamento baseado no IP destino.",
                                  "commonMistakes": [
                                    "Usar match exato em vez de prefixo mais longo",
                                    "Confundir gateway com interface de saída",
                                    "Ignorar métrica de custo na escolha da rota"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar o datagrama: decrementar TTL e recalcular checksum",
                                  "subSteps": [
                                    "Decrementar o campo TTL em 1 e descartar se chegar a 0 (evitar loops).",
                                    "Explique por que TTL previne loops infinitos na rede.",
                                    "Recalcule o checksum do cabeçalho IP após alterar TTL (somatório de palavras de 16 bits).",
                                    "Verifique o novo checksum com uma ferramenta ou calculadora.",
                                    "Registre o impacto dessas mudanças no datagrama."
                                  ],
                                  "verification": "Calcule manualmente checksum antes/depois de decrementar TTL em um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora de IP checksum online",
                                    "Exemplo de cabeçalho IP em hexadecimal"
                                  ],
                                  "tips": "Lembre-se: checksum é ones' complement sum; ignore payload.",
                                  "learningObjective": "Executar e compreender as modificações obrigatórias no datagrama durante o roteamento.",
                                  "commonMistakes": [
                                    "Esquecer de recalcular checksum após TTL",
                                    "Decrementar TTL incorretamente (subtrair mais de 1)",
                                    "Confundir TTL com Hop Limit em IPv6"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Encaminhar para o próximo salto usando ARP",
                                  "subSteps": [
                                    "Determine o endereço MAC do próximo salto consultando cache ARP.",
                                    "Se não em cache, envie ARP Request para MAC do IP next hop.",
                                    "Atualize cache ARP com resposta e reenvie datagrama na camada 2 (Ethernet).",
                                    "Explique encapsulamento: IP datagrama dentro frame Ethernet com MACs corretos.",
                                    "Simule o processo completo de um salto roteador-para-roteador."
                                  ],
                                  "verification": "Descreva o fluxo ARP para um next hop específico e liste frames envolvidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de ARP em Wireshark",
                                    "Tabela ARP cache exemplo"
                                  ],
                                  "tips": "ARP é só para mesma sub-rede; roteamento é inter-sub-rede.",
                                  "learningObjective": "Integrar ARP no encaminhamento final do datagrama para o próximo roteador.",
                                  "commonMistakes": [
                                    "Usar ARP para roteamento global (só local)",
                                    "Confundir MAC origem/destino no frame",
                                    "Ignorar timeout no ARP cache"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o roteamento de um datagrama de 192.168.1.10 (host A) para 10.0.0.5 (servidor remoto): Roteador R1 consulta tabela, encontra next hop 192.168.2.1 (R2), decrementa TTL de 64 para 63, recalcula checksum e usa ARP para obter MAC de R2 antes de enviar via Ethernet.",
                              "finalVerifications": [
                                "Explique verbalmente o fluxo completo de roteamento de um datagrama exemplo.",
                                "Desenhe um diagrama mostrando mudanças no cabeçalho IP a cada salto.",
                                "Simule em Wireshark ou Packet Tracer o processo de encaminhamento.",
                                "Identifique e corrija erros em um cenário de roteamento com TTL expirado.",
                                "Liste diferenças entre roteamento IP e switching L2.",
                                "Responda quiz com 5 perguntas sobre tabela de roteamento e ARP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da consulta de tabela de roteamento (LPM correto).",
                                "Compreensão correta do papel e modificação do TTL.",
                                "Cálculo exato de checksum após alterações.",
                                "Integração precisa de ARP no encaminhamento final.",
                                "Uso correto de terminologia (datagrama, next hop, cache ARP).",
                                "Capacidade de simular cenários práticos sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de checksum usando soma de complemento de 1.",
                                "Segurança da Informação: Implicações de TTL em ataques de loop ou traceroute.",
                                "Programação: Uso de sockets IP em Python (raw sockets para manipular cabeçalhos).",
                                "Física: Propagação de sinais em cabos/rede sem fio afetando TTL.",
                                "Administração: Configuração de rotas em sistemas operacionais (route add)."
                              ],
                              "realWorldApplication": "Nos roteadores da internet (ex: BGP em ASes), esse processo garante que pacotes de e-mails, vídeos ou transações bancárias cheguem ao destino através de milhares de saltos, prevenindo loops e otimizando caminhos em data centers globais como os da Google ou AWS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.4",
                            "name": "Identificar problemas comuns em roteamento IP",
                            "description": "Reconhecer erros como TTL=0 (ICMP Time Exceeded), fragmentação excessiva e blackholing por DF e PMTU Discovery.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o mecanismo de TTL e ICMP Time Exceeded",
                                  "subSteps": [
                                    "Estude o campo TTL no cabeçalho IP e seu propósito de prevenir loops infinitos.",
                                    "Aprenda como cada roteador decrementa o TTL em 1 e descarta o pacote se TTL=0.",
                                    "Analise a mensagem ICMP Time Exceeded (Type 11, Code 0) enviada pelo roteador.",
                                    "Examine exemplos de pacotes em Wireshark mostrando TTL expirando.",
                                    "Pratique configurando TTL baixo em pacotes de teste."
                                  ],
                                  "verification": "Capture tráfego com Wireshark e identifique pacotes ICMP Time Exceeded com TTL=0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Wireshark, documentação RFC 791 (IP), tutorial de traceroute",
                                  "tips": "Use traceroute para visualizar TTL timeouts em tempo real.",
                                  "learningObjective": "Explicar o papel do TTL no roteamento e reconhecer mensagens ICMP relacionadas.",
                                  "commonMistakes": "Confundir TTL com MTU; ignorar que TTL é em hops, não tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar problemas de fragmentação excessiva",
                                  "subSteps": [
                                    "Revise o processo de fragmentação IP quando pacotes excedem MTU do link.",
                                    "Identifique flags no cabeçalho IP: MF (More Fragments) e offset de fragmento.",
                                    "Estude impactos como perda de fragmentos, reassembly falha e overhead de CPU.",
                                    "Capture fragmentos IP em Wireshark e reconstrua pacotes.",
                                    "Teste enviando pacotes grandes sem DF para forçar fragmentação."
                                  ],
                                  "verification": "Gere fragmentação intencional e confirme detecção via Wireshark sem reassembly.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Wireshark, ping com tamanho de pacote grande (ex: ping -s 3000), RFC 791",
                                  "tips": "Aumente o tamanho do pacote gradualmente para observar o limiar de fragmentação.",
                                  "learningObjective": "Detectar e explicar fragmentação excessiva em tráfego de rede.",
                                  "commonMistakes": "Assumir que todos os pacotes fragmentados são problemáticos; não verificar MTU de path."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar PMTU Discovery e blackholing com bit DF",
                                  "subSteps": [
                                    "Aprenda PMTU Discovery: uso do bit DF para descobrir MTU máximo do path.",
                                    "Entenda blackholing: roteadores dropam pacotes DF sem enviar ICMP Fragmentation Needed.",
                                    "Analise ICMP Type 3 Code 4 (Fragmentation Needed) e por que firewalls bloqueiam.",
                                    "Simule cenários com DF setado e MTU mismatch.",
                                    "Configure roteadores para testar respostas ICMP."
                                  ],
                                  "verification": "Envie pacotes DF grandes e verifique se recebe ICMP ou blackhole (sem resposta).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Cisco Packet Tracer ou GNS3, ping -M do (Linux) ou -f (Windows), RFC 1191",
                                  "tips": "Use 'ping -M do -s <size>' para forçar DF e detectar PMTU.",
                                  "learningObjective": "Identificar blackholing causado por DF e falhas em PMTU Discovery.",
                                  "commonMistakes": "Ignorar filtros ICMP em roteadores; confundir com perda de pacote simples."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diagnosticar problemas combinados usando ferramentas",
                                  "subSteps": [
                                    "Integre conhecimentos: execute traceroute para TTL, ping grande para fragmentação/PMTU.",
                                    "Interprete saídas: * * * para TTL=0, timeouts para blackholing.",
                                    "Crie checklist de diagnóstico para roteamento IP.",
                                    "Simule rede com falhas e resolva.",
                                    "Documente casos em relatório."
                                  ],
                                  "verification": "Resolva 3 cenários simulados identificando o problema exato em <5 minutos cada.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Packet Tracer/GNS3, Wireshark, traceroute/ping tools",
                                  "tips": "Combine traceroute com Wireshark para correlação visual.",
                                  "learningObjective": "Aplicar diagnóstico prático para identificar problemas de roteamento IP.",
                                  "commonMistakes": "Não isolar variáveis (ex: testar TTL sem controlar MTU)."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa, traceroute para um servidor remoto mostra hops iniciais ok, mas após hop 5: * * *. Captura Wireshark revela ICMP Time Exceeded do roteador 5. Ping com DF e tamanho 1500 falha sem ICMP, indicando blackholing por MTU 1400 no path.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito os 3 problemas principais com exemplos de ICMP.",
                                "Executar traceroute e identificar TTL timeout em simulação.",
                                "Detectar fragmentação excessiva em Wireshark com >10 fragmentos por pacote.",
                                "Simular blackholing com DF e confirmar ausência de ICMP Fragmentation Needed.",
                                "Diagnosticar problema misto em cenário desconhecido.",
                                "Listar 3 causas comuns e soluções para cada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de TTL=0 vs. fragmentação vs. blackholing (90%+ acerto).",
                                "Uso correto de ferramentas como traceroute/ping/Wireshark.",
                                "Explicação clara de mecanismos IP/ICMP envolvidos.",
                                "Análise de impactos no desempenho de rede.",
                                "Proposta de soluções preventivas (ex: ajustar TTL/MTU).",
                                "Relatório estruturado com evidências de captura."
                              ],
                              "crossCurricularConnections": [
                                "Segurança de Rede: ICMP filtering e prevenção de loops/DoS.",
                                "Desempenho e Otimização: Tuning de MTU para throughput máximo.",
                                "Programação de Redes: Scripts Python com Scapy para testes automatizados.",
                                "Matemática: Cálculos de MTU path e overhead de fragmentação."
                              ],
                              "realWorldApplication": "Em data centers ou ISPs, diagnosticar lentidão de rede: TTL baixo causa timeouts em rotas longas; fragmentação excessiva sobrecarrega roteadores; blackholing interrompe conexões VPN/Cloud quando MTU mismatch com túneis IPsec."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Nível de Enlace",
                "description": "Discute os padrões IEEE para o nível de enlace.",
                "totalSkills": 39,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Arquitetura IEEE 802",
                    "description": "Estrutura geral dos padrões IEEE 802, incluindo subcamadas MAC e LLC no nível de enlace.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Estrutura Geral dos Padrões IEEE 802",
                        "description": "Visão geral da arquitetura IEEE 802, que define padrões para redes locais (LAN) e metropolitanas (MAN), dividindo o nível de enlace em subcamadas LLC e MAC para padronizar o acesso ao meio físico e o controle de enlace lógico.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Identificar os principais padrões IEEE 802",
                            "description": "Listar e descrever os padrões IEEE 802 principais, como 802.3 (Ethernet), 802.11 (Wi-Fi), 802.15 (Bluetooth) e 802.16 (WiMAX), explicando seu escopo em redes LAN e MAN.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos dos Padrões IEEE 802",
                                  "subSteps": [
                                    "Acesse a página oficial do IEEE ou Wikipedia sobre IEEE 802 para ler a visão geral.",
                                    "Identifique o propósito do IEEE 802 como família de padrões para redes locais (LAN) e metropolitanas (MAN).",
                                    "Anote a estrutura de numeração: 802.x onde x indica o subcomitê (ex: 802.3 para Ethernet).",
                                    "Liste os tipos de redes cobertos: LAN, MAN, PAN.",
                                    "Registre datas de aprovação e evoluções principais dos padrões."
                                  ],
                                  "verification": "Você tem um resumo escrito com pelo menos 5 pontos chave sobre IEEE 802.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Página Wikipedia: IEEE 802",
                                    "Site oficial IEEE Standards Association (standards.ieee.org)"
                                  ],
                                  "tips": "Comece com uma visão geral ampla antes de mergulhar em detalhes para construir contexto.",
                                  "learningObjective": "Compreender o escopo e estrutura geral da família IEEE 802.",
                                  "commonMistakes": [
                                    "Confundir IEEE 802 com outros padrões como TCP/IP; focar apenas em nomes sem contexto histórico."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar os Padrões Principais para LAN: 802.3 e 802.11",
                                  "subSteps": [
                                    "Pesquise especificamente 802.3 (Ethernet): leia sobre cabo coaxial, twisted pair, velocidades (10/100/1000 Mbps).",
                                    "Anote aplicações: redes cabeadas em escritórios e data centers.",
                                    "Estude 802.11 (Wi-Fi): versões (a/b/g/n/ac/ax), frequências (2.4GHz, 5GHz), alcance e throughput.",
                                    "Compare 802.3 vs 802.11 em uma tabela simples (cabeado vs wireless).",
                                    "Identifique escopo em LAN: conectividade local em ambientes fechados."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 4 colunas (nome, tipo, principais features, aplicações LAN).",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Documentos IEEE 802.3 e 802.11 summaries",
                                    "Vídeo Khan Academy ou YouTube sobre Ethernet e Wi-Fi"
                                  ],
                                  "tips": "Use diagramas visuais para diferenciar cabeado e wireless.",
                                  "learningObjective": "Descrever em detalhes 802.3 e 802.11 e seu papel em LAN.",
                                  "commonMistakes": [
                                    "Ignorar evoluções como Gigabit Ethernet ou Wi-Fi 6; confundir Wi-Fi com Bluetooth."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Padrões para PAN e MAN: 802.15 e 802.16",
                                  "subSteps": [
                                    "Pesquise 802.15 (Bluetooth, Zigbee): foque em WPAN para dispositivos pessoais (alcance curto, baixo consumo).",
                                    "Anote exemplos: fones sem fio, wearables.",
                                    "Estude 802.16 (WiMAX): características de MAN (alcance km, mobilidade, banda larga sem fio).",
                                    "Compare com LAN: PAN para proximidade, MAN para áreas urbanas amplas.",
                                    "Liste limitações e sucessores (ex: 5G sucedendo WiMAX)."
                                  ],
                                  "verification": "Escreva descrições curtas (2-3 frases cada) para 802.15 e 802.16, incluindo escopo de rede.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Wikipedia: IEEE 802.15 e 802.16",
                                    "Infográficos sobre Bluetooth e WiMAX"
                                  ],
                                  "tips": "Associe a padrões cotidianos: Bluetooth no celular, WiMAX em provedores rurais.",
                                  "learningObjective": "Identificar e descrever 802.15 e 802.16 em contextos PAN e MAN.",
                                  "commonMistakes": [
                                    "Confundir Bluetooth (802.15.1) com outros 802.15; achar WiMAX obsoleto sem notar legado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Comparar Todos os Padrões Principais",
                                  "subSteps": [
                                    "Compile uma lista final: 802.3, 802.11, 802.15, 802.16 com descrições e escopos.",
                                    "Crie um mapa mental ou tabela unificada mostrando LAN/MAN/PAN.",
                                    "Explique interconexões: como Ethernet backbone suporta Wi-Fi.",
                                    "Teste-se recitando de memória.",
                                    "Pesquise um padrão adicional opcional como 802.1 (gerenciamento) para completude."
                                  ],
                                  "verification": "Gere um mapa mental ou tabela com todos os 4 padrões e apresente verbalmente.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Ferramenta de mind mapping como MindMeister ou papel/caneta",
                                    "Flashcards Anki para revisão"
                                  ],
                                  "tips": "Use cores para diferenciar tipos de rede (azul LAN, verde PAN, vermelho MAN).",
                                  "learningObjective": "Sintetizar conhecimentos para identificar e descrever principais padrões IEEE 802.",
                                  "commonMistakes": [
                                    "Listar sem descrever escopo; esquecer aplicações práticas em LAN/MAN."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma tabela comparativa em uma planilha (Google Sheets) listando os 4 padrões com colunas: Nome, Tipo de Rede (LAN/MAN/PAN), Tecnologia Principal, Exemplos de Uso e Velocidade/Alcance aproximados. Preencha com dados pesquisados e compartilhe com um colega para feedback.",
                              "finalVerifications": [
                                "Pode listar corretamente os 4 padrões principais sem consultar notas.",
                                "Descreve o escopo de cada um em LAN, MAN ou PAN.",
                                "Explica diferenças entre cabeado (802.3) e wireless (802.11/15/16).",
                                "Identifica pelo menos 2 aplicações reais para cada padrão.",
                                "Cria um diagrama simples mostrando hierarquia IEEE 802.",
                                "Responde a perguntas como 'Qual padrão para redes metropolitanas?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e numeração dos padrões (100% correto).",
                                "Profundidade das descrições (inclui features chave e escopo de rede).",
                                "Capacidade de comparação entre padrões (tabela ou mapa mental claro).",
                                "Uso correto de terminologia (LAN, MAN, PAN, Ethernet, Wi-Fi, etc.).",
                                "Evidência de compreensão prática via exemplos reais.",
                                "Completude: cobre todos os 4 padrões mencionados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Ondas eletromagnéticas em Wi-Fi/Bluetooth (frequências, interferência).",
                                "Matemática: Taxas de dados, throughput e latência (cálculos de velocidade).",
                                "História: Evolução da computação e telecomunicações desde 1980s.",
                                "Engenharia: Design de protocolos e topologias de rede.",
                                "Ética: Privacidade em redes wireless (segurança IEEE 802.11)."
                              ],
                              "realWorldApplication": "Esses padrões formam a base da internet moderna: 802.3 em data centers globais (ex: Google Cloud), 802.11 em todos os roteadores domésticos Wi-Fi, 802.15 em IoT como smart homes (Alexa), e 802.16 legado em provedores de internet rural no Brasil, impactando conectividade diária e 5G atual."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Explicar a divisão em subcamadas do nível de enlace",
                            "description": "Descrever a separação do nível de enlace em subcamada LLC (controle lógico de enlace) e MAC (controle de acesso ao meio), destacando como isso permite independência entre controle lógico e acesso físico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Modelo OSI e o Nível de Enlace",
                                  "subSteps": [
                                    "Estude o modelo OSI de 7 camadas e identifique o Nível 2 (Enlace de Dados).",
                                    "Descreva as funções gerais do nível de enlace: detecção de erros, controle de fluxo e acesso ao meio.",
                                    "Compare com outros níveis para contextualizar sua importância.",
                                    "Crie um diagrama simples do modelo OSI destacando o nível de enlace.",
                                    "Liste exemplos de protocolos que operam nesse nível."
                                  ],
                                  "verification": "Diagrama completo do OSI com nível de enlace destacado e lista de funções corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do modelo OSI (impresso ou digital)",
                                    "Vídeo introdutório sobre OSI (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use cores diferentes para cada camada no diagrama para melhor visualização.",
                                  "learningObjective": "Compreender o papel fundamental do nível de enlace no modelo OSI.",
                                  "commonMistakes": [
                                    "Confundir nível de enlace com rede (Nível 3)",
                                    "Ignorar funções de detecção de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Arquitetura IEEE 802",
                                  "subSteps": [
                                    "Pesquise a origem e propósito dos padrões IEEE 802 para redes locais (LAN).",
                                    "Identifique como IEEE 802 mapeia para o nível de enlace do OSI.",
                                    "Desenhe a estrutura geral: divisão em LLC e MAC.",
                                    "Explique por que a divisão foi criada: padronização e flexibilidade.",
                                    "Liste padrões IEEE 802 comuns (ex: 802.3 Ethernet, 802.11 Wi-Fi)."
                                  ],
                                  "verification": "Diagrama da estrutura IEEE 802 com LLC e MAC rotulados corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial IEEE 802 (PDF ou site)",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Foque na independência: LLC é comum, MAC é específico do meio.",
                                  "learningObjective": "Entender a motivação e estrutura básica da arquitetura IEEE 802.",
                                  "commonMistakes": [
                                    "Achar que IEEE 802 é só Ethernet",
                                    "Confundir com modelo TCP/IP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Subcamada LLC (Logical Link Control)",
                                  "subSteps": [
                                    "Defina LLC: funções como multiplexação, controle de fluxo e detecção/recuperação de erros.",
                                    "Estude os tipos de LLC (Type 1, 2, 3) e suas diferenças.",
                                    "Compare LLC com protocolos como HDLC.",
                                    "Simule um fluxo de dados passando pela LLC.",
                                    "Anote exemplos de uso em redes Ethernet e Token Ring."
                                  ],
                                  "verification": "Resumo escrito das funções LLC com pelo menos 3 exemplos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigos sobre LLC (Cisco Networking Academy)",
                                    "Simulador de redes como Packet Tracer"
                                  ],
                                  "tips": "Lembre-se: LLC é independente do meio físico, como um 'controle lógico universal'.",
                                  "learningObjective": "Dominar as responsabilidades e características da subcamada LLC.",
                                  "commonMistakes": [
                                    "Confundir LLC com MAC",
                                    "Subestimar multiplexação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar a Subcamada MAC (Media Access Control)",
                                  "subSteps": [
                                    "Defina MAC: funções como endereçamento (MAC addresses), acesso ao meio (CSMA/CD, CSMA/CA).",
                                    "Descreva formatos de frames MAC e campos chave (preâmbulo, endereços, CRC).",
                                    "Compare MAC em Ethernet (802.3) vs. Wi-Fi (802.11).",
                                    "Simule colisões e resolução em CSMA/CD.",
                                    "Liste vantagens de MAC ser específico do meio físico."
                                  ],
                                  "verification": "Diagrama de frame MAC com legendas e simulação descrita de CSMA/CD.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de frames Wireshark",
                                    "Vídeos sobre CSMA/CD"
                                  ],
                                  "tips": "Use Wireshark para capturar frames reais e analisar.",
                                  "learningObjective": "Compreender o papel da MAC no controle físico do meio.",
                                  "commonMistakes": [
                                    "Confundir endereço MAC com IP",
                                    "Ignorar diferenças por tecnologia"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Independência e Benefícios da Divisão",
                                  "subSteps": [
                                    "Explique como LLC e MAC se comunicam via SAP (Service Access Point).",
                                    "Discuta benefícios: reutilização de LLC em múltiplos MACs, evolução independente.",
                                    "Crie um fluxograma de dados: Aplicação → LLC → MAC → Físico.",
                                    "Compare cenários com e sem divisão (ex: flexibilidade em novas tecnologias).",
                                    "Resuma vantagens para padronização global."
                                  ],
                                  "verification": "Fluxograma completo e parágrafo explicando 3 benefícios chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta digital para fluxogramas"
                                  ],
                                  "tips": "Pense em Wi-Fi usando LLC com MAC sem fio: prova de independência.",
                                  "learningObjective": "Avaliar o impacto da separação LLC/MAC na arquitetura de redes.",
                                  "commonMistakes": [
                                    "Achar que são totalmente independentes (há interface)",
                                    "Não ligar a aplicações reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede Ethernet (IEEE 802.3), a LLC gerencia o controle de fluxo entre dois PCs enviando dados, enquanto a MAC resolve colisões no cabo usando CSMA/CD, permitindo que o mesmo LLC funcione em Wi-Fi (802.11) com MAC diferente para ondas de rádio.",
                              "finalVerifications": [
                                "Diagramar corretamente LLC e MAC no nível de enlace IEEE 802.",
                                "Explicar funções de LLC sem mencionar aspectos físicos.",
                                "Descrever um frame MAC com pelo menos 5 campos chave.",
                                "Identificar 3 benefícios da divisão em um parágrafo coerente.",
                                "Simular verbalmente o fluxo de um pacote através das subcamadas.",
                                "Comparar LLC/MAC com arquiteturas monolíticas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de LLC e MAC (30%)",
                                "Profundidade de funções: cobertura completa de responsabilidades (25%)",
                                "Clareza na independência: explicação lógica dos benefícios (20%)",
                                "Uso de diagramas/exemplos: visualizações acionáveis e precisas (15%)",
                                "Conexão com padrões IEEE: referências corretas a 802.x (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais e detecção de colisões (ondas eletromagnéticas).",
                                "Matemática: Cálculo de probabilidades em CSMA/CA.",
                                "Programação: Implementação de protocolos em Python (Scapy para frames MAC).",
                                "Segurança da Informação: Análise de vulnerabilidades em LLC/MAC."
                              ],
                              "realWorldApplication": "Essa divisão permite que fabricantes desenvolvam placas de rede Ethernet e Wi-Fi intercambiáveis, facilitando redes híbridas em empresas, data centers e residências, onde LLC padronizada garante compatibilidade lógica enquanto MAC adapta ao cabo ou ar."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Comparar IEEE 802 com o modelo OSI",
                            "description": "Mapear a arquitetura IEEE 802 ao modelo OSI, identificando que LLC e MAC correspondem à camada de enlace de dados, e como se relaciona com a camada física.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Modelo OSI",
                                  "subSteps": [
                                    "Estude as 7 camadas do modelo OSI: Física, Enlace de Dados, Rede, Transporte, Sessão, Apresentação e Aplicação.",
                                    "Identifique as responsabilidades principais de cada camada, focando na Camada Física (bits físicos) e Camada de Enlace de Dados (frames, MAC addresses).",
                                    "Desenhe um diagrama simples das camadas OSI em uma folha de papel ou ferramenta digital.",
                                    "Anote exemplos de protocolos ou tecnologias para cada camada.",
                                    "Compare brevemente com o modelo TCP/IP para contextualizar."
                                  ],
                                  "verification": "Você pode listar e descrever corretamente as 7 camadas OSI com suas funções principais sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do modelo OSI (impresso ou online)",
                                    "Vídeo introdutório sobre OSI (ex: Khan Academy)"
                                  ],
                                  "tips": "Use mnemônicos como 'Please Do Not Throw Sausage Pizza Away' para lembrar as camadas.",
                                  "learningObjective": "Compreender a estrutura e funções das camadas OSI relevantes para redes locais.",
                                  "commonMistakes": [
                                    "Confundir Camada Física com Enlace (física é hardware/sinais, enlace é framing/error control)",
                                    "Ignorar que OSI é um modelo conceitual, não implementado diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Arquitetura IEEE 802",
                                  "subSteps": [
                                    "Pesquise os padrões IEEE 802, focando em que é um conjunto para redes locais (LAN) e metropolitanas (MAN).",
                                    "Identifique os componentes principais: LLC (Logical Link Control) e MAC (Media Access Control).",
                                    "Aprenda que IEEE 802 divide a Camada de Enlace em LLC (superior, gerencia fluxos) e MAC (inferior, acesso ao meio).",
                                    "Estude exemplos: 802.3 (Ethernet), 802.11 (Wi-Fi), e sua relação com Camada Física.",
                                    "Desenhe o diagrama da pilha IEEE 802."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito os componentes LLC e MAC e dê exemplos de padrões IEEE 802.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial IEEE 802 (resumo online)",
                                    "Diagrama comparativo IEEE 802"
                                  ],
                                  "tips": "Lembre-se: IEEE 802 não cobre camadas acima de Enlace; usa TCP/IP para o resto.",
                                  "learningObjective": "Dominar a estrutura de dois níveis da Camada de Enlace no IEEE 802.",
                                  "commonMistakes": [
                                    "Pensar que IEEE 802 é uma camada única",
                                    "Confundir MAC com endereços IP (MAC é camada 2)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear IEEE 802 ao Modelo OSI",
                                  "subSteps": [
                                    "Mapeie LLC e MAC à Camada 2 (Enlace de Dados) do OSI: LLC no topo, MAC no fundo.",
                                    "Mapeie a subcamada Physical do IEEE 802 à Camada 1 (Física) do OSI.",
                                    "Note que IEEE 802 não define camadas 3-7; elas são fornecidas por outros protocolos.",
                                    "Crie uma tabela comparativa: colunas para OSI e IEEE 802, linhas para camadas.",
                                    "Identifique como frames Ethernet (MAC) interagem com bits físicos."
                                  ],
                                  "verification": "Preencha corretamente uma tabela de mapeamento sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela em branco para mapeamento",
                                    "Referência visual OSI vs IEEE 802"
                                  ],
                                  "tips": "Visualize: OSI Enlace = IEEE LLC + MAC; OSI Física = IEEE Physical.",
                                  "learningObjective": "Realizar mapeamento preciso entre arquiteturas.",
                                  "commonMistakes": [
                                    "Mapear LLC/MAC para camadas erradas",
                                    "Esquecer que Physical é compartilhada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Diferenças e Semelhanças",
                                  "subSteps": [
                                    "Liste semelhanças: Ambas focam em Enlace e Física para LANs.",
                                    "Liste diferenças: OSI é genérico (7 camadas), IEEE 802 é específico para LAN (divide Enlace).",
                                    "Discuta vantagens: IEEE 802 padroniza múltiplas tecnologias (Ethernet, Wi-Fi).",
                                    "Crie um fluxograma de um pacote viajando por IEEE 802 mapeado ao OSI.",
                                    "Resuma em 3-5 pontos chave da comparação."
                                  ],
                                  "verification": "Explique as diferenças principais em uma gravação curta ou parágrafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma (ex: Draw.io)",
                                    "Notas dos passos anteriores"
                                  ],
                                  "tips": "Pergunte: 'Onde Ethernet se encaixa?' (MAC + Physical).",
                                  "learningObjective": "Criticar e comparar as arquiteturas de forma analítica.",
                                  "commonMistakes": [
                                    "Ignorar que IEEE 802 é prático, OSI teórico",
                                    "Generalizar demais sem exemplos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede Ethernet doméstica (IEEE 802.3), um frame é criado na subcamada MAC (endereços MAC, CRC), passa pelo LLC para controle de fluxo, e então pela Physical para transmissão de bits via cabo. No OSI, isso é todo na Camada 2 (Enlace) + 1 (Física), com IP na Camada 3 acima.",
                              "finalVerifications": [
                                "Desenhar e rotular corretamente o mapeamento IEEE 802 -> OSI.",
                                "Explicar o papel de LLC vs MAC em uma rede Wi-Fi.",
                                "Identificar que IEEE 802 não define roteamento (Camada 3).",
                                "Comparar com um diagrama de rede real (ex: switch Ethernet).",
                                "Responder a perguntas como: 'Por que IEEE divide Enlace?'",
                                "Criar uma tabela de protocolos IEEE 802 e suas camadas OSI."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento (100% correto: LLC/MAC=Enlace, Physical=Física).",
                                "Profundidade de explicação (inclui funções e exemplos).",
                                "Uso de diagramas/tabelas claros e rotulados.",
                                "Identificação de pelo menos 3 diferenças/semelhanças.",
                                "Aplicação a cenários reais sem erros conceituais.",
                                "Clareza na comunicação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Física: Transmissão de sinais na Camada Física (ondas eletromagnéticas).",
                                "Matemática: Cálculo de endereços MAC (binário/hexadecimal).",
                                "Programação: Uso de sockets em Python para simular camadas.",
                                "História da Tecnologia: Evolução de LANs desde ARPANET."
                              ],
                              "realWorldApplication": "Em redes corporativas, administradores usam esse conhecimento para troubleshooting de switches (Camada 2 IEEE 802) vs roteadores (Camada 3), otimizando Ethernet/Wi-Fi e garantindo interoperabilidade em data centers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Subcamada LLC (Logical Link Control)",
                        "description": "Subcamada responsável pelo controle lógico de enlace, fornecendo serviços como multiplexação, controle de fluxo e detecção de erros, independente do meio físico.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Descrever as funções da subcamada LLC",
                            "description": "Explicar as três funções principais da LLC: fornecimento de interfaces unificadas para camadas superiores, controle de sequência de frames e detecção de erros não dependente do hardware.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito e Posição da Subcamada LLC na Arquitetura IEEE 802",
                                  "subSteps": [
                                    "Estude a pilha OSI e o modelo IEEE 802, identificando a camada de enlace de dados dividida em MAC e LLC.",
                                    "Leia a definição oficial da LLC no padrão IEEE 802.2.",
                                    "Desenhe um diagrama da pilha de protocolos mostrando LLC entre a camada de rede e MAC.",
                                    "Compare LLC com a subcamada MAC em termos de responsabilidades.",
                                    "Anote as motivações históricas para a separação LLC/MAC."
                                  ],
                                  "verification": "Crie um diagrama anotado da pilha IEEE 802 com LLC destacada e explique verbalmente sua posição.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação IEEE 802.2, diagramas da pilha OSI/TCP-IP, vídeo introdutório sobre IEEE 802.",
                                  "tips": "Use cores diferentes no diagrama para distinguir LLC de MAC e camadas superiores.",
                                  "learningObjective": "Compreender o papel e a posição da LLC na arquitetura de redes.",
                                  "commonMistakes": "Confundir LLC com MAC ou achar que LLC é específica de um meio físico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Função de Fornecimento de Interfaces Unificadas",
                                  "subSteps": [
                                    "Defina 'interface unificada' e explique como LLC abstrai diferenças entre tipos de MAC (ex: Ethernet, Token Ring).",
                                    "Estude os campos do header LLC (DSAP, SSAP, Control) e seu papel na multiplexação.",
                                    "Simule o fluxo de dados de uma camada superior (ex: IP) passando pela LLC para diferentes MACs.",
                                    "Compare cenários com e sem LLC para ilustrar a unificação.",
                                    "Liste protocolos de camada superior suportados via LLC (ex: IP, ARP)."
                                  ],
                                  "verification": "Descreva em um parágrafo como LLC permite que IP funcione sobre múltiplos tipos de LAN sem modificações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exemplos de headers LLC (Wireshark captures), diagramas de multiplexação LLC.",
                                  "tips": "Pense na LLC como um 'adaptador universal' para redes locais.",
                                  "learningObjective": "Dominar como LLC fornece abstração para camadas superiores.",
                                  "commonMistakes": "Ignorar o papel dos campos SAP na identificação de protocolos superiores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Controle de Sequência de Frames",
                                  "subSteps": [
                                    "Explique os tipos de PDU LLC (Type 1: conexãoless, Type 2: connection-oriented com sequencing).",
                                    "Descreva o mecanismo de numeração de sequência e ACKs em modo connection-oriented.",
                                    "Simule uma troca de frames com perda e recuperação via controle de sequência.",
                                    "Diferencie controle de sequência da LLC de mecanismos de transporte (TCP).",
                                    "Identifique quando usar Type 1 vs Type 2."
                                  ],
                                  "verification": "Crie um fluxograma de uma sessão connection-oriented LLC com numeração de frames.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Capturas Wireshark de tráfego LLC Type 2, tutoriais sobre PDUs LLC.",
                                  "tips": "Use ferramentas como Packet Tracer para simular sequências de frames.",
                                  "learningObjective": "Entender o controle de sequência para garantia de entrega ordenada.",
                                  "commonMistakes": "Confundir sequencing da LLC com retransmissão de camada superior."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar a Detecção de Erros Independente de Hardware",
                                  "subSteps": [
                                    "Descreva o campo Control e como ele suporta detecção de erros via checksums ou CRC opcionais.",
                                    "Explique a independência de hardware: LLC adiciona verificação além do CRC da MAC.",
                                    "Compare detecção de erros em LLC Type 1 (básica) vs Type 2 (avançada com ACK/NACK).",
                                    "Analise um exemplo de frame corrompido e como LLC o detecta/rejeita.",
                                    "Discuta limitações: LLC não corrige erros, apenas detecta."
                                  ],
                                  "verification": "Explique em bullet points como um erro em um frame é detectado na LLC, citando campos envolvidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Especificação IEEE 802.2 para campo Control, exemplos de frames LLC com erros simulados.",
                                  "tips": "Lembre-se: LLC complementa, não substitui, a detecção da MAC.",
                                  "learningObjective": "Compreender a detecção de erros padronizada na LLC.",
                                  "commonMistakes": "Achar que LLC faz correção de erros ou depende exclusivamente de hardware."
                                }
                              ],
                              "practicalExample": "Em uma rede Ethernet 802.3 com IP sobre LLC, um pacote IP é encapsulado com header LLC (DSAP/SSAP=06 para IP), permitindo que o mesmo IP stack funcione em WiFi 802.11 sem alterações, com LLC gerenciando sequência para sessões confiáveis e detectando erros via Control field.",
                              "finalVerifications": [
                                "Liste e defina corretamente as três funções principais da LLC.",
                                "Desenhe um header LLC e rotule os campos relacionados a cada função.",
                                "Explique com um diagrama como LLC unifica interfaces para Ethernet e WiFi.",
                                "Simule verbalmente uma sequência de frames com ACK para controle de sequência.",
                                "Diferencie detecção de erros da LLC da MAC em um cenário de frame corrompido.",
                                "Resuma as funções em uma tabela comparativa com subcamada MAC."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das três funções (interfaces, sequência, erros).",
                                "Uso correto de terminologia IEEE 802.2 (PDU types, DSAP/SSAP, Control field).",
                                "Capacidade de ilustrar funções com diagramas ou exemplos concretos.",
                                "Diferenciação clara entre LLC e MAC.",
                                "Compreensão de independência de hardware e unificação.",
                                "Aplicação prática em cenários reais de redes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de checksums e algoritmos de detecção de erros.",
                                "Programação: Implementação de protocolos em sockets raw ou bibliotecas de rede.",
                                "Física: Propagação de sinais e fontes de erros em meios físicos.",
                                "Segurança da Informação: Impacto de erros não detectados em integridade de dados."
                              ],
                              "realWorldApplication": "A LLC é essencial em redes corporativas mistas (Ethernet + WiFi), permitindo protocolos como IP e AppleTalk compartilharem a mesma infraestrutura sem adaptações específicas, garantindo confiabilidade em aplicações como VoIP ou transferências de arquivos sensíveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Identificar os tipos de serviço da LLC",
                            "description": "Diferenciar os tipos de serviço LLC: Type 1 (sem conexão), Type 2 (conexão-orientado) e Type 3 (conexão sem confirmação), com exemplos de uso em protocolos como Ethernet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos da subcamada LLC",
                                  "subSteps": [
                                    "Estudar a posição da LLC na pilha IEEE 802 (acima da MAC, abaixo da rede).",
                                    "Identificar as funções principais: multiplexação de protocolos, controle de fluxo e detecção de erros.",
                                    "Revisar os campos do cabeçalho LLC: DSAP, SSAP, controle.",
                                    "Entender que LLC fornece serviços independentes da MAC para diferentes protocolos de rede.",
                                    "Ler sobre a padronização IEEE 802.2."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o papel da LLC e seus componentes principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama da pilha IEEE 802",
                                    "Documentação IEEE 802.2",
                                    "Vídeo introdutório sobre subcamada de enlace"
                                  ],
                                  "tips": "Visualize a LLC como uma 'ponte' entre MAC e rede para múltiplos protocolos.",
                                  "learningObjective": "Dominar os fundamentos da LLC para contextualizar os tipos de serviço.",
                                  "commonMistakes": [
                                    "Confundir LLC com MAC (LLC é lógica, MAC é acesso ao meio)",
                                    "Ignorar o cabeçalho LLC nos frames Ethernet"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Type 1 (Sem conexão - Unacknowledged Connectionless)",
                                  "subSteps": [
                                    "Definir Type 1: serviço sem estabelecimento de conexão, sem confirmação de entrega.",
                                    "Estudar características: datagramas independentes, melhor esforço, sem controle de fluxo.",
                                    "Examinar PDU Type 1: campo de controle U-format (sem numeração).",
                                    "Identificar usos: tráfego IP sobre Ethernet (802.3).",
                                    "Simular envio de frames Type 1 em um diagrama."
                                  ],
                                  "verification": "Desenhar um frame Ethernet com LLC Type 1 e descrever seu fluxo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de frames Ethernet com Wireshark",
                                    "Tabela de PDUs LLC",
                                    "Simulador de redes como Cisco Packet Tracer"
                                  ],
                                  "tips": "Pense no Type 1 como 'envio de carta sem aviso de recebimento'.",
                                  "learningObjective": "Diferenciar as características únicas do serviço connectionless sem ACK.",
                                  "commonMistakes": [
                                    "Confundir com Type 3 (Type 1 não tem ACK opcional)",
                                    "Achar que é confiável (é não confiável)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Type 3 (Conexão sem confirmação - Acknowledged Connectionless)",
                                  "subSteps": [
                                    "Definir Type 3: connectionless com confirmação opcional de entrega.",
                                    "Comparar com Type 1: adiciona ACK para PDUs específicos, mas sem conexão virtual.",
                                    "Analisar PDU Type 1 com formato A (ACK) ou P (Poll).",
                                    "Estudar cenários de uso: protocolos de broadcast ou multicast em LANs.",
                                    "Praticar identificação em traces de rede."
                                  ],
                                  "verification": "Identificar diferenças entre Type 1 e Type 3 em um exemplo de frame.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Capturas Wireshark de tráfego LAN",
                                    "Especificação IEEE 802.2 Type 3",
                                    "Diagramas de PDUs"
                                  ],
                                  "tips": "Type 3 é como 'carta com recibo opcional', mas ainda sem sessão.",
                                  "learningObjective": "Compreender o serviço connectionless com feedback seletivo.",
                                  "commonMistakes": [
                                    "Misturar ACK do Type 3 com conexão do Type 2",
                                    "Pensar que é totalmente confiável (ACK é por PDU, não fluxo)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Type 2 (Orientado a conexão - Connection-mode) e comparações",
                                  "subSteps": [
                                    "Definir Type 2: serviço com estabelecimento, manutenção e término de conexão virtual.",
                                    "Descrever fases: conexão setup (SABME), dados (I-frames), disconnect (DISC).",
                                    "Analisar PDUs: U-format (setup), S-format (supervisão), I-format (dados numerados).",
                                    "Comparar os três tipos em tabela: conexão, ACK, usos.",
                                    "Exemplar em Ethernet: protocolos legados como IBM SNA."
                                  ],
                                  "verification": "Preencher tabela comparativa dos três tipos e dar exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela comparativa LLC services",
                                    "Exemplos de protocolos usando Type 2",
                                    "Ferramenta de análise de frames"
                                  ],
                                  "tips": "Type 2 é como 'chamada telefônica': setup, conversa, hangup.",
                                  "learningObjective": "Diferenciar todos os tipos e aplicar em contextos reais.",
                                  "commonMistakes": [
                                    "Confundir numeração de frames Type 2 com TCP",
                                    "Subestimar complexidade do setup em Type 2"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede Ethernet 802.3, IP usa LLC Type 1 para datagramas UDP (sem conexão). ARP usa Type 1 para requests. Protocolos de gerenciamento como LLC2 (Type 2) em redes token ring legadas estabelecem conexão para sessões confiáveis.",
                              "finalVerifications": [
                                "Diferenciar corretamente Type 1, Type 2 e Type 3 por características chave.",
                                "Identificar PDU formats para cada tipo em um frame dado.",
                                "Dar exemplos de protocolos usando cada tipo em IEEE 802.",
                                "Explicar quando usar cada tipo baseado em requisitos de confiabilidade.",
                                "Montar tabela comparativa completa.",
                                "Analisar trace Wireshark e classificar LLC service."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e características de cada tipo (80% acerto).",
                                "Correta identificação de PDUs e campos de controle.",
                                "Uso apropriado de exemplos reais de protocolos.",
                                "Clareza na comparação e diferenciação entre tipos.",
                                "Capacidade de aplicar conceitos em cenários de rede.",
                                "Ausência de confusões comuns como ACK vs conexão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos de estados finitos para máquinas de Type 2.",
                                "Programação: Analogia com sockets TCP (connection-oriented) vs UDP.",
                                "Física: Transmissão de sinais em meios compartilhados (Ethernet CSMA/CD)."
                              ],
                              "realWorldApplication": "Em switches Ethernet modernos, LLC Type 1 suporta tráfego IP rápido e sem estado em data centers. Type 2 é usado em sistemas legados industriais para comunicações confiáveis ponto-a-ponto, como em automação fabril."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Analisar o cabeçalho LLC",
                            "description": "Interpretar a estrutura do cabeçalho LLC, incluindo DSAP, SSAP, controle e informações de serviço, e como ele é inserido nos frames de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura geral do cabeçalho LLC",
                                  "subSteps": [
                                    "Estude o formato padrão do cabeçalho LLC: 1 byte DSAP, 1 byte SSAP, 1 ou 2 bytes Controle, e opcionalmente 1 byte de Flag de Comando/Resposta.",
                                    "Identifique o tamanho total do cabeçalho (geralmente 3-4 bytes).",
                                    "Revise o papel da subcamada LLC na pilha IEEE 802: multiplexing e flux control.",
                                    "Compare com MAC frame para ver onde o LLC é inserido (após endereço MAC).",
                                    "Anote diagramas visuais do cabeçalho."
                                  ],
                                  "verification": "Desenhe o diagrama do cabeçalho LLC e rotule cada campo corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama IEEE 802.2",
                                    "Documentação oficial IEEE 802.2",
                                    "Editor de texto ou papel para diagramas"
                                  ],
                                  "tips": "Use cores diferentes para cada campo no diagrama para facilitar a visualização.",
                                  "learningObjective": "Compreender a composição e posição do cabeçalho LLC em um frame de dados.",
                                  "commonMistakes": [
                                    "Confundir LLC com MAC header",
                                    "Ignorar o campo opcional de Flag",
                                    "Esquecer que Controle pode ser 1 ou 2 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os campos DSAP e SSAP",
                                  "subSteps": [
                                    "Decodifique DSAP (Destination Service Access Point): valores como 0xAA para SNAP, 0xE0 para IP.",
                                    "Decodifique SSAP (Source Service Access Point): similar ao DSAP, com bit 7 indicando comando/resposta.",
                                    "Pratique conversão hex para valores de serviço (ex: IP, ARP).",
                                    "Identifique se é SNAP (DSAP=SSAP=0xAA) para extensões.",
                                    "Liste serviços comuns mapeados para cada SAP."
                                  ],
                                  "verification": "Dado um byte DSAP/SSAP em hex, identifique o protocolo corretamente em 5 exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de SAPs IEEE 802.2",
                                    "Calculadora hex/binária",
                                    "Exemplos de frames reais"
                                  ],
                                  "tips": "Sempre verifique o bit mais significativo do SSAP para C/R (Command/Response).",
                                  "learningObjective": "Interpretar DSAP e SSAP para identificar protocolos de serviço.",
                                  "commonMistakes": [
                                    "Ignorar o bit C/R no SSAP",
                                    "Confundir DSAP com endereço IP",
                                    "Não reconhecer SNAP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o campo de Controle",
                                  "subSteps": [
                                    "Estude formatos U (unnumbered), S (supervisory), I (information) frames.",
                                    "Analise bits: P/F (Poll/Final), tipo de frame, sequências N(S)/N(R).",
                                    "Pratique decodificação de exemplos: ex: U-frame com código 0x03 para UI (unnumbered information).",
                                    "Diferencie modo ABM (Asynchronous Balanced Mode) vs outros.",
                                    "Registre funções como ACK, REJ, SABME."
                                  ],
                                  "verification": "Classifique 5 campos de controle em hex como U, S ou I e descreva sua função.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Especificação IEEE 802.2 Controle field",
                                    "Ferramenta Wireshark para captura",
                                    "Lista de códigos de controle"
                                  ],
                                  "tips": "Lembre-se: formatos U não têm bits de sequência, S tem N(R), I tem N(S) e N(R).",
                                  "learningObjective": "Decodificar o campo Controle para entender tipos de frames LLC.",
                                  "commonMistakes": [
                                    "Confundir formatos U/S/I",
                                    "Ignorar P/F bit",
                                    "Não ajustar para 1 vs 2 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar informações de serviço e inserção no frame",
                                  "subSteps": [
                                    "Analise o campo de Flag de Comando/Resposta após Controle (se presente).",
                                    "Estude como LLC é encapsulado em MAC frame: após endereços, antes de dados.",
                                    "Simule inserção: crie um frame exemplo com LLC header.",
                                    "Verifique alinhamento em redes Ethernet (padded se necessário).",
                                    "Discuta variações em 802.3 vs 802.11."
                                  ],
                                  "verification": "Monte um frame completo com LLC header e valide a posição dos campos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de frames de rede (Packet Tracer ou Wireshark)",
                                    "Template de frame IEEE 802"
                                  ],
                                  "tips": "Use Wireshark para capturar tráfego real e destacar o LLC header.",
                                  "learningObjective": "Compreender como o cabeçalho LLC integra-se ao frame de dados completo.",
                                  "commonMistakes": [
                                    "Colocar LLC antes de MAC addresses",
                                    "Esquecer padding em frames curtos",
                                    "Ignorar diferenças entre standards"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture um pacote Ethernet com protocolo IP (DSAP=SSAP=0xAA, SNAP). Analise o LLC header: identifique DSAP/SSAP como SNAP, Controle como 0x03 (UI), e confirme inserção após MAC addresses, permitindo multiplexação para IP.",
                              "finalVerifications": [
                                "Pode desenhar e rotular o cabeçalho LLC completo.",
                                "Decodifica corretamente DSAP/SSAP para protocolos comuns.",
                                "Classifica campos Controle como U/S/I com funções exatas.",
                                "Explica inserção do LLC em um frame Ethernet.",
                                "Identifica SNAP e seu papel em extensões modernas.",
                                "Valida um exemplo real de Wireshark."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os campos (DSAP, SSAP, Controle).",
                                "Correta interpretação de bits especiais (C/R, P/F).",
                                "Explicação clara da integração com MAC frame.",
                                "Uso correto de exemplos reais ou simulados.",
                                "Ausência de confusões entre LLC e outras sublayers.",
                                "Capacidade de listar serviços SAP comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão binária/hexadecimal para decodificação de campos.",
                                "Programação: Implementação de parsers LLC em Python/Scapy para análise de pacotes.",
                                "Segurança da Informação: Análise de frames para detecção de anomalias em DSAP/SSAP.",
                                "Física: Sinalização elétrica em cabos Ethernet afetando frames LLC.",
                                "Gestão de Projetos: Protocolos padronizados em design de redes corporativas."
                              ],
                              "realWorldApplication": "Em troubleshooting de redes Ethernet empresariais, analise cabeçalhos LLC em Wireshark para diagnosticar falhas de multiplexação de protocolos (ex: IP vs ARP), otimizando switches e roteadores em data centers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Subcamada MAC (Media Access Control)",
                        "description": "Subcamada que gerencia o acesso ao meio de transmissão compartilhado, resolvendo colisões e formatando frames para diferentes mídias físicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Explicar os mecanismos de controle de acesso ao meio",
                            "description": "Descrever métodos como CSMA/CD (para Ethernet), CSMA/CA (para Wi-Fi) e token passing (para 802.5), focando na prevenção e resolução de colisões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos básicos de controle de acesso ao meio e colisões",
                                  "subSteps": [
                                    "Definir controle de acesso ao meio (MAC) como o protocolo que gerencia o acesso compartilhado ao meio de transmissão.",
                                    "Explicar o problema das colisões: quando múltiplos dispositivos tentam transmitir simultaneamente, causando interferência e perda de dados.",
                                    "Diferenciar meios compartilhados (half-duplex) de dedicados (full-duplex).",
                                    "Classificar mecanismos: baseados em contenda (CSMA) vs. sem contenda (token passing)."
                                  ],
                                  "verification": "Resumir em um diagrama simples o que é uma colisão e por que o MAC é necessário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama de rede compartilhada (papel ou ferramenta como Draw.io)",
                                    "Vídeo introdutório sobre MAC (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use analogia de uma rodovia compartilhada para visualizar colisões.",
                                  "learningObjective": "Compreender o papel do MAC na prevenção de colisões em redes compartilhadas.",
                                  "commonMistakes": "Confundir MAC com endereço físico (é camada, não endereço)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o mecanismo CSMA/CD (Ethernet)",
                                  "subSteps": [
                                    "Descrever CSMA: Carrier Sense Multiple Access - escuta antes de transmitir.",
                                    "Explicar CD: Collision Detection - detecta colisão durante transmissão e para.",
                                    "Detalhar o processo: Listen > Transmit > Detect Collision > Jam Signal > Backoff (Exponential).",
                                    "Analisar o algoritmo de backoff: tempo aleatório baseado em 2^k * slot time."
                                  ],
                                  "verification": "Simular em papel uma sequência de transmissão com colisão e backoff.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Artigo sobre Ethernet IEEE 802.3"
                                  ],
                                  "tips": "Lembre-se: CSMA/CD é para cabos (Ethernet clássica), obsoleto em full-duplex.",
                                  "learningObjective": "Dominar o fluxo completo do CSMA/CD e sua eficiência em LANs cabeadas.",
                                  "commonMistakes": "Esquecer que em Gigabit Ethernet, CSMA/CD não é mais usado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o CSMA/CA (Wi-Fi)",
                                  "subSteps": [
                                    "Explicar CA: Collision Avoidance - evita colisões em vez de detectá-las (wireless não permite detecção fácil).",
                                    "Descrever RTS/CTS (Request to Send/Clear to Send) para reserva de canal.",
                                    "Detalhar NAV (Network Allocation Vector): tempo estimado de transmissão anunciado.",
                                    "Abordar backoff e ACKs para confirmação de recepção."
                                  ],
                                  "verification": "Desenhar um fluxograma RTS/CTS com dois nós competindo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulador Wi-Fi (Wireshark com captura Wi-Fi)",
                                    "Documentação IEEE 802.11"
                                  ],
                                  "tips": "Pense em Wi-Fi como rádio: colisões são 'invisíveis' ao transmissor.",
                                  "learningObjective": "Entender adaptações do CSMA para ambientes sem fio sem colisão detectável.",
                                  "commonMistakes": "Confundir CSMA/CA com CSMA/CD; CA é proativo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Token Passing (IEEE 802.5)",
                                  "subSteps": [
                                    "Descrever token passing: token circula; só quem tem token transmite.",
                                    "Explicar frames: Token > Data > Ack; detecção de perda de token.",
                                    "Comparar com CSMA: determinístico, sem colisões, mas latência fixa.",
                                    "Discutir limitações: falha de nó pode parar a rede (soluções como monitor)."
                                  ],
                                  "verification": "Listar prós e contras vs. CSMA em uma tabela comparativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama de ring topology (Token Ring)",
                                    "Artigo histórico sobre 802.5"
                                  ],
                                  "tips": "Token Ring é obsoleto, mas conceito útil para redes determinísticas.",
                                  "learningObjective": "Compreender mecanismos sem contenda e suas aplicações industriais.",
                                  "commonMistakes": "Achar que token passing é usado em Ethernet moderna."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar mecanismos e sintetizar conhecimentos",
                                  "subSteps": [
                                    "Criar tabela comparativa: CSMA/CD vs. CSMA/CA vs. Token Passing (colisões, eficiência, uso).",
                                    "Discutir evoluções: full-duplex elimina necessidade de CSMA/CD.",
                                    "Aplicar a cenários: LAN cabeada vs. Wi-Fi vs. redes industriais.",
                                    "Resumir foco: prevenção (CA, token) vs. resolução (CD)."
                                  ],
                                  "verification": "Explicar oralmente ou por escrito qual mecanismo usar em cada cenário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de tabela (Google Sheets)",
                                    "Resumo visual dos três mecanismos"
                                  ],
                                  "tips": "Foque em trade-offs: throughput vs. latência vs. complexidade.",
                                  "learningObjective": "Integrar conhecimentos para análise crítica de protocolos MAC.",
                                  "commonMistakes": "Ignorar contexto histórico/tecnológico de cada um."
                                }
                              ],
                              "practicalExample": "Em uma rede Ethernet de escritório com 5 PCs compartilhando um hub: PC1 transmite, PC2 colide (CSMA/CD detecta, jam, backoff). Simule no Packet Tracer e observe tráfego.",
                              "finalVerifications": [
                                "Descrever passo a passo o processo de CSMA/CD.",
                                "Diferenciar CSMA/CA de CSMA/CD com exemplos.",
                                "Explicar como token passing evita colisões completamente.",
                                "Criar diagrama de RTS/CTS em Wi-Fi.",
                                "Listar 3 vantagens/desvantagens de cada mecanismo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos fluxos (sem omissões chave).",
                                "Uso correto de terminologia técnica (ex: backoff, NAV).",
                                "Capacidade de comparar mecanismos em tabela clara.",
                                "Exemplos práticos relevantes e corretos.",
                                "Análise de cenários reais com justificativa."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais e interferência eletromagnética em CSMA/CA.",
                                "Matemática: Probabilidades de colisão e algoritmos de backoff exponencial.",
                                "Engenharia: Design de protocolos determinísticos em redes industriais.",
                                "Segurança: Implicações de colisões em DoS attacks."
                              ],
                              "realWorldApplication": "Em redes Wi-Fi domésticas (CSMA/CA gerencia múltiplos dispositivos); data centers Ethernet full-duplex (sem CSMA); automação industrial (token passing like em Profibus para previsibilidade)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Descrever a estrutura do frame MAC",
                            "description": "Analisar os componentes de um frame MAC genérico: préambulo, endereços destino/fonte, tipo/length, dados LLC, CRC e interframe gap, com exemplos do padrão 802.3.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o propósito e estrutura geral do frame MAC",
                                  "subSteps": [
                                    "Pesquise o que é um frame MAC e seu papel na subcamada MAC do IEEE 802.3.",
                                    "Identifique os componentes principais: préambulo, endereços destino/fonte, tipo/length, dados LLC, CRC e interframe gap.",
                                    "Desenhe um diagrama esquemático da estrutura geral do frame.",
                                    "Compare com frames de outros protocolos para destacar diferenças.",
                                    "Anote o tamanho total típico de um frame Ethernet (64-1518 bytes)."
                                  ],
                                  "verification": "Você pode desenhar e rotular corretamente um diagrama da estrutura geral do frame MAC sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.3",
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Vídeo tutorial sobre frames Ethernet"
                                  ],
                                  "tips": "Comece pelo todo antes dos detalhes; use cores diferentes para cada componente no diagrama.",
                                  "learningObjective": "Compreender o frame MAC como unidade de transmissão na camada de enlace.",
                                  "commonMistakes": [
                                    "Confundir frame MAC com pacote IP",
                                    "Ignorar o interframe gap como parte do frame"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o cabeçalho: Préambulo, endereços e tipo/length",
                                  "subSteps": [
                                    "Estude o préambulo (7 bytes de 10101010 + 1 byte SFD = 10101011) e sua função de sincronização.",
                                    "Descreva os endereços MAC (6 bytes cada: destino primeiro, fonte depois) e formatos (unicast, multicast, broadcast).",
                                    "Explique o campo tipo/length (2 bytes): valores > 1500 indicam tipo (ex: EtherType 0x0800 para IPv4), < 1500 indica length.",
                                    "Calcule exemplos de endereços MAC em hexadecimal.",
                                    "Pratique identificando endereços em um frame capturado."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a função de cada campo do cabeçalho com exemplos numéricos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark para capturas de pacotes",
                                    "Tabela de EtherTypes",
                                    "Calculadora hexadecimal"
                                  ],
                                  "tips": "Lembre-se: destino vem antes da fonte; use Wireshark para ver frames reais.",
                                  "learningObjective": "Dominar os campos iniciais responsáveis por sincronização e roteamento local.",
                                  "commonMistakes": [
                                    "Inverter ordem de endereços destino/fonte",
                                    "Confundir tipo com length sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o corpo e trailer: Dados LLC, CRC e interframe gap",
                                  "subSteps": [
                                    "Descreva os dados LLC (46-1500 bytes, com padding se necessário para mínimo 64 bytes).",
                                    "Aprenda o CRC (FCS - 4 bytes, algoritmo CRC-32) e como detectar erros.",
                                    "Entenda o interframe gap (12 bytes no meio físico, ~9.6 µs em 10 Mbps).",
                                    "Simule cálculo de CRC para um frame simples usando ferramentas online.",
                                    "Discuta como padding é adicionado para frames curtos."
                                  ],
                                  "verification": "Gere um frame exemplo, calcule seu CRC e verifique integridade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online CRC calculator",
                                    "Especificação IEEE 802.3 seção 3",
                                    "Amostras de frames em texto/hex"
                                  ],
                                  "tips": "O interframe gap não é transmitido, mas é silêncio entre frames; teste CRC com erros intencionais.",
                                  "learningObjective": "Compreender mecanismos de integridade e espaçamento no frame.",
                                  "commonMistakes": [
                                    "Pensar que CRC é encriptação",
                                    "Esquecer padding nos dados LLC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e exemplificar um frame MAC completo no padrão 802.3",
                                  "subSteps": [
                                    "Monte um frame completo exemplo: préambulo, DA=FF:FF:FF:FF:FF:FF, SA=00:11:22:33:44:55, tipo=0x0800, dados simples, CRC calculado.",
                                    "Capture um frame real com Wireshark e dissecione componente por componente.",
                                    "Compare frames 802.3u (Fast Ethernet) vs. originais.",
                                    "Crie variações: broadcast, com padding, oversized.",
                                    "Explique detecção de erros via CRC em cenários reais."
                                  ],
                                  "verification": "Construa e valide um frame completo que passe verificação CRC e atenda regras 802.3.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Gerador de frames online ou Python Scapy",
                                    "IEEE 802.3 PDF"
                                  ],
                                  "tips": "Use Scapy para gerar frames: sendp(Ether()/IP()/ICMP()) e capture.",
                                  "learningObjective": "Aplicar conhecimento para construir e analisar frames reais.",
                                  "commonMistakes": [
                                    "Frames menores que 64 bytes sem padding",
                                    "CRC incorreto devido a endianness"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture tráfego Ethernet local. Selecione um frame IPv4: identifique préambulo/SFD (não visível no Wireshark, mas explicado), DA/SA (ex: 33:33:00:00:00:01 / aa:bb:cc:dd:ee:ff), EtherType 0x0800, dados LLC (IP header + payload), FCS (verifique se válido). Explique como o switch usa DA para forwarding.",
                              "finalVerifications": [
                                "Liste e descreva todos os 7 componentes do frame MAC com tamanhos exatos.",
                                "Desenhe um frame completo com valores hexadecimais exemplo.",
                                "Calcule CRC para um frame dado e valide.",
                                "Explique diferenças entre frames com tipo vs. length.",
                                "Identifique erros comuns em um frame malformado.",
                                "Compare estrutura MAC 802.3 com 802.11 (WiFi)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de cada campo (tamanhos, funções, formatos).",
                                "Uso correto de exemplos numéricos/hexadecimais.",
                                "Compreensão de interdependências (ex: padding para CRC).",
                                "Capacidade de diagramação clara e rotulada.",
                                "Aplicação prática via ferramentas como Wireshark/Scapy.",
                                "Identificação de erros e verificações de integridade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de CRC-32 (polinômios, divisão modular).",
                                "Física: Sincronização de clock via préambulo (sinais digitais).",
                                "Segurança da Informação: Detecção de erros vs. correção (FCS).",
                                "Programação: Implementação de geradores de frames em Python (Scapy).",
                                "Engenharia: Design de protocolos para redes Ethernet modernas."
                              ],
                              "realWorldApplication": "Em redes Ethernet (LANs corporativas, data centers), switches leem DA no frame MAC para forwarding instantâneo; CRC previne transmissão de dados corrompidos em cabos longos ou WiFi; análise de frames é essencial para troubleshooting de rede com ferramentas como Wireshark em suporte técnico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Diferenciar endereçamento MAC",
                            "description": "Explicar endereços MAC de 48 bits (OUI + NIC), unicast/multicast/broadcast, e como são usados para identificação única em LANs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica do endereço MAC",
                                  "subSteps": [
                                    "Estude a definição de endereço MAC como identificador de 48 bits (6 bytes) único para interfaces de rede.",
                                    "Aprenda a representação em hexadecimal (ex: 00:1A:2B:3C:4D:5E).",
                                    "Divida o endereço em OUI (Organizationally Unique Identifier, primeiros 3 bytes) e NIC (Network Interface Card, últimos 3 bytes).",
                                    "Converta um exemplo de MAC de hexadecimal para binário para visualizar os 48 bits.",
                                    "Pesquise exemplos de OUIs de fabricantes conhecidos (ex: Cisco: 00-00-0C)."
                                  ],
                                  "verification": "Represente corretamente um endereço MAC exemplo em hex, binário e identifique OUI/NIC.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação IEEE 802",
                                    "Calculadora hexadecimal/binária online",
                                    "Lista de OUIs (oui.ieee.org)"
                                  ],
                                  "tips": "Sempre conte 6 pares de hexágonos para confirmar 48 bits.",
                                  "learningObjective": "Entender que o MAC é um endereço de camada 2 de 48 bits composto por OUI (global) e NIC (local).",
                                  "commonMistakes": [
                                    "Confundir comprimento com IPv6 (128 bits)",
                                    "Ignorar que OUI é atribuído pela IEEE."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar tipos de endereços MAC: Unicast, Multicast e Broadcast",
                                  "subSteps": [
                                    "Defina unicast: bit menos significativo do primeiro byte = 0 (destinado a um dispositivo único).",
                                    "Defina multicast: bit menos significativo do primeiro byte = 1 (grupo de dispositivos, ex: 01:00:5E).",
                                    "Defina broadcast: FF:FF:FF:FF:FF:FF (todos os dispositivos na LAN).",
                                    "Analise o bit I/G (Individual/Group) no primeiro byte para classificação.",
                                    "Examine exemplos reais: unicast pessoal, multicast para protocolos como DHCP."
                                  ],
                                  "verification": "Classifique 3 endereços MAC exemplo como unicast, multicast ou broadcast com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark para capturar pacotes",
                                    "Tabela de bits MAC"
                                  ],
                                  "tips": "Verifique sempre o primeiro bit do primeiro byte: 0=unicast, 1=multicast/broadcast.",
                                  "learningObjective": "Distinguir os tipos de MAC pelo bit I/G e seu propósito de entrega de frames.",
                                  "commonMistakes": [
                                    "Confundir multicast com broadcast (broadcast é um caso especial)",
                                    "Esquecer que unicast tem bit 0."
                                  ]
                                },
                                {
                                  "stepNumber": "3",
                                  "title": "Explorar o uso de endereços MAC em LANs para identificação única",
                                  "subSteps": [
                                    "Entenda o papel na subcamada MAC: identificação de frames Ethernet em redes locais.",
                                    "Aprenda como switches usam tabelas MAC (CAM) para encaminhamento baseado em MAC.",
                                    "Discuta unicidade: global via OUI, mas NIC pode ser spoofed localmente.",
                                    "Simule envio de frames: origem/destino MAC em cabeçalho Ethernet.",
                                    "Compare com IP: MAC camada 2 (LAN), IP camada 3 (WAN)."
                                  ],
                                  "verification": "Descreva o fluxo de um frame Ethernet em uma LAN usando MACs de origem e destino.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Simulador de rede como Packet Tracer",
                                    "Diagrama Ethernet frame"
                                  ],
                                  "tips": "Lembre: MAC não roteia entre redes; ARP mapeia IP para MAC.",
                                  "learningObjective": "Compreender como MACs garantem entrega única de frames em LANs.",
                                  "commonMistakes": [
                                    "Pensar que MAC é roteável como IP",
                                    "Ignorar spoofing em testes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar diferenciação e análise de endereços MAC",
                                  "subSteps": [
                                    "Capture tráfego de rede local e identifique MACs em pacotes.",
                                    "Analise OUIs para identificar fabricantes de dispositivos na rede.",
                                    "Classifique tipos de MAC em uma captura Wireshark.",
                                    "Crie cenários: unicast para web, broadcast para ARP, multicast para streaming.",
                                    "Compare dois MACs e diferencie estrutura e tipo."
                                  ],
                                  "verification": "Analise uma captura de rede e liste 5 MACs com tipo, OUI e uso inferido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Rede Wi-Fi local ativa"
                                  ],
                                  "tips": "Filtre por 'eth.src' ou 'eth.dst' no Wireshark para focar em MACs.",
                                  "learningObjective": "Aplicar diferenciação prática de MACs em cenários reais de LAN.",
                                  "commonMistakes": [
                                    "Não filtrar tráfego irrelevante",
                                    "Confundir MAC com IPv4 em listagens."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede doméstica, use o comando 'ipconfig /all' (Windows) ou 'ifconfig' (Linux) para ver o MAC físico da sua placa de rede. Capture tráfego com Wireshark durante um ping: identifique o MAC unicast de origem/destino, broadcast em ARP e multicast em protocolos como mDNS.",
                              "finalVerifications": [
                                "Explicar corretamente a estrutura 48 bits (OUI + NIC).",
                                "Classificar unicast/multicast/broadcast por bit I/G.",
                                "Descrever uso em frames Ethernet para identificação em LAN.",
                                "Identificar OUI de um fabricante em um MAC dado.",
                                "Diferenciar MAC de IP em termos de escopo e função.",
                                "Analisar uma captura simples de rede."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da estrutura e componentes MAC (80% correto).",
                                "Correta diferenciação de tipos com exemplos (todas classificações certas).",
                                "Compreensão clara do papel em LANs vs. outras camadas.",
                                "Uso correto de terminologia (OUI, NIC, I/G bit).",
                                "Capacidade de análise prática em exemplos reais.",
                                "Ausência de confusões comuns (ex: MAC vs IP)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão entre hexadecimal, binário e decimal para análise de bits.",
                                "Segurança da Informação: Spoofing de MAC e ataques como CAM table overflow.",
                                "Física: Transmissão de sinais em meios físicos (Ethernet, Wi-Fi).",
                                "Programação: Uso de bibliotecas como Scapy para manipular frames MAC.",
                                "Administração: Gerenciamento de redes em VLANs baseadas em MAC."
                              ],
                              "realWorldApplication": "Administradores de rede usam endereços MAC para configurar portas de switches, filtrar acessos em firewalls (MAC filtering), troubleshooting de loops (STP), e identificar dispositivos em logs de segurança para detectar intrusos em LANs corporativas ou IoT doméstico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.4",
                            "name": "Comparar MAC em diferentes padrões IEEE 802",
                            "description": "Contrastar o MAC de Ethernet (802.3) com Wi-Fi (802.11), destacando diferenças em detecção de colisões e gerenciamento de energia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o mecanismo MAC no padrão IEEE 802.3 (Ethernet)",
                                  "subSteps": [
                                    "Estude o CSMA/CD (Carrier Sense Multiple Access with Collision Detection): como estações verificam o meio antes de transmitir e detectam colisões durante a transmissão.",
                                    "Analise o processo de backoff exponencial após uma colisão, incluindo o cálculo do tempo de espera.",
                                    "Examine o frame Ethernet, focando em campos como Preamble, SFD, MAC addresses e CRC para detecção de erros.",
                                    "Identifique limitações do CSMA/CD em redes modernas com switches full-duplex.",
                                    "Registre as principais características de gerenciamento de energia no 802.3 (ausência de modos de economia avançados)."
                                  ],
                                  "verification": "Crie um diagrama de fluxo do CSMA/CD e explique-o em voz alta ou por escrito sem consultar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "IEEE 802.3 standard summary (online PDF)",
                                    "Vídeos Khan Academy ou Cisco Networking Academy sobre Ethernet MAC",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias como 'uma conversa em sala lotada onde todos param se ouvirem sobreposição' para visualizar CSMA/CD.",
                                  "learningObjective": "Compreender os fundamentos do MAC em Ethernet, especialmente CSMA/CD e suas limitações.",
                                  "commonMistakes": "Confundir detecção de colisão (durante transmissão) com prevenção (antes); ignorar transição para full-duplex."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o mecanismo MAC no padrão IEEE 802.11 (Wi-Fi)",
                                  "subSteps": [
                                    "Estude o CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance): uso de RTS/CTS para evitar colisões ocultas.",
                                    "Analise o mecanismo de backoff e o NAV (Network Allocation Vector) para reserva de tempo no meio.",
                                    "Examine o frame 802.11, destacando campos como Duration, Sequence Control e QoS para priorização.",
                                    "Descreva modos de gerenciamento de energia: PSM (Power Save Mode) e modos de beacon para estações adormecidas.",
                                    "Identifique adaptações para ambientes sem fio como mobilidade e fading."
                                  ],
                                  "verification": "Desenhe um diagrama RTS/CTS e liste 3 diferenças chave do CSMA/CD.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "IEEE 802.11 standard overview (Wi-Fi Alliance resources)",
                                    "Wireshark para capturar frames Wi-Fi",
                                    "Simulador NS-3 ou Packet Tracer"
                                  ],
                                  "tips": "Capture tráfego Wi-Fi real com Wireshark para ver RTS/CTS em ação em redes congestionadas.",
                                  "learningObjective": "Dominar os princípios do MAC em Wi-Fi, com ênfase em CSMA/CA e power saving.",
                                  "commonMistakes": "Achar que Wi-Fi usa detecção de colisão (não pode em half-duplex sem fio); subestimar overhead do CSMA/CA."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar detecção e acesso ao meio entre 802.3 e 802.11",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: CSMA/CD vs CSMA/CA (detecção vs avoidance, RTS/CTS vs jam signals).",
                                    "Calcule eficiência aproximada: impacto de colisões em Ethernet vs overhead em Wi-Fi.",
                                    "Discuta cenários onde cada um é superior (Ethernet em LAN cabeada vs Wi-Fi em ambientes multi-hop).",
                                    "Analise problemas de terminal oculto e como RTS/CTS os resolve no Wi-Fi.",
                                    "Registre métricas: throughput, latência e probabilidade de colisão em cada padrão."
                                  ],
                                  "verification": "Preencha a tabela comparativa e justifique 3 diferenças com exemplos numéricos ou diagramas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabela em branco no Google Sheets ou Excel",
                                    "Gráficos de performance de fontes como Cisco ou livros de Kurose/Ross"
                                  ],
                                  "tips": "Use probabilidades simples: em CSMA/CA, probabilidade de colisão cai com RTS/CTS em redes densas.",
                                  "learningObjective": "Contrastar mecanismos de acesso ao meio, destacando trade-offs em colisões.",
                                  "commonMistakes": "Ignorar que Ethernet moderna não usa CSMA/CD em full-duplex; equiparar RTS/CTS diretamente a detecção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar gerenciamento de energia e sintetizar diferenças gerais",
                                  "subSteps": [
                                    "Compare power management: Ethernet (sempre ativo ou LPI em 802.3az) vs Wi-Fi (PSM, U-APSD com beacons).",
                                    "Crie um resumo das diferenças chave em uma matriz: colisões, energia, frames, adaptações ambientais.",
                                    "Discuta implicações: por que Wi-Fi prioriza economia vs Ethernet focado em velocidade.",
                                    "Explore evoluções: 802.11ax (OFDMA) vs 802.3bt (PoE++).",
                                    "Formule uma conclusão sobre quando usar cada MAC."
                                  ],
                                  "verification": "Escreva um parágrafo síntese de 200 palavras comparando os dois MACs e cite 2 aplicações reais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Resumos de 802.3az e 802.11 power save (IEEE docs)",
                                    "Artigo comparativo online sobre MAC layers"
                                  ],
                                  "tips": "Pense em baterias: Wi-Fi para laptops/IoT, Ethernet para servidores fixos.",
                                  "learningObjective": "Sintetizar diferenças em energia e aplicações, solidificando a comparação.",
                                  "commonMistakes": "Generalizar Ethernet como sem power save (existem extensões); focar só em colisões ignorando frames."
                                }
                              ],
                              "practicalExample": "Configure duas redes virtuais no Packet Tracer: uma LAN Ethernet com hub para induzir colisões (observe CSMA/CD via logs) e uma WLAN Wi-Fi com múltiplos clients (ative RTS/CTS e monitore power save via beacons). Compare tempos de transmissão e consumo simulado de energia.",
                              "finalVerifications": [
                                "Explicar CSMA/CD vs CSMA/CA sem hesitação.",
                                "Listar 4 diferenças em frames MAC entre padrões.",
                                "Identificar cenário onde CSMA/CA é essencial (ex: terminal oculto).",
                                "Descrever como PSM funciona em Wi-Fi.",
                                "Preencher tabela comparativa corretamente em <5 minutos.",
                                "Discutir trade-off throughput vs eficiência energética."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção CSMA/CD (detecção) vs CSMA/CA (avoidance): 25%.",
                                "Profundidade na comparação de power management: 20%.",
                                "Uso de exemplos/diagramas concretos: 20%.",
                                "Identificação de trade-offs e implicações reais: 20%.",
                                "Clareza e estrutura na síntese final: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais sem fio vs cabeados (atenuação, interferência).",
                                "Matemática: Modelos probabilísticos de backoff exponencial e colisões.",
                                "Engenharia: Design de protocolos para QoS e escalabilidade em redes.",
                                "Ciência de Dados: Análise de traces Wireshark para métricas de performance."
                              ],
                              "realWorldApplication": "Em design de redes IoT, escolher Wi-Fi MAC para dispositivos battery-powered em smart homes (economia de energia via PSM) versus Ethernet MAC em data centers para alta throughput sem colisões em switches full-duplex, otimizando custo e performance."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Padrão IEEE 802.3 - Ethernet",
                    "description": "Especificações para redes Ethernet cabeadas, com CSMA/CD e velocidades variadas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Especificações Básicas do IEEE 802.3",
                        "description": "O padrão IEEE 802.3 define as especificações para redes locais cabeadas Ethernet, incluindo topologias em barramento, estrela e ponto-a-ponto, com suporte a diferentes meios físicos como cabo coaxial, par trançado e fibra ótica.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Identificar o escopo do padrão IEEE 802.3",
                            "description": "Reconhecer que o IEEE 802.3 especifica o nível físico e de enlace de dados para redes Ethernet cabeadas, diferenciando-o de padrões sem fio como 802.11 e enfatizando sua evolução desde 10 Mbps até velocidades de 400 Gbps.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral dos padrões IEEE 802",
                                  "subSteps": [
                                    "Pesquise o que é o grupo de trabalho IEEE 802 e seu foco em redes locais (LAN) e metropolitanas (MAN).",
                                    "Identifique as camadas do modelo OSI cobertas pelos padrões 802 (física e controle de acesso ao meio - MAC).",
                                    "Liste exemplos de padrões 802, como 802.3 (Ethernet) e 802.11 (Wi-Fi).",
                                    "Leia a visão geral no site oficial do IEEE 802.",
                                    "Anote a distinção entre padrões cabeados e sem fio dentro da família 802."
                                  ],
                                  "verification": "Crie um mapa mental ou tabela resumindo 3-5 padrões 802 principais e suas camadas OSI.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Site oficial IEEE 802: https://www.ieee802.org/",
                                    "Wikipedia: IEEE 802",
                                    "Diagrama do modelo OSI"
                                  ],
                                  "tips": "Comece pelo glossário para evitar confusão com outros comitês IEEE.",
                                  "learningObjective": "Entender o contexto amplo dos padrões IEEE 802 como base para redes LAN.",
                                  "commonMistakes": [
                                    "Confundir IEEE 802 com ISO 802 (não existe).",
                                    "Achar que todos os padrões 802 cobrem todas as camadas OSI."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o escopo preciso do IEEE 802.3",
                                  "subSteps": [
                                    "Leia a introdução do padrão IEEE 802.3, focando nas seções de escopo.",
                                    "Identifique que 802.3 especifica a camada física (PHY) e subcamada MAC para Ethernet cabeada.",
                                    "Anote que não inclui camada de rede (IP) ou superior.",
                                    "Compare com o modelo OSI: PHY (camada 1) e MAC (parte da camada 2).",
                                    "Registre exemplos de mídias físicas suportadas (par trançado, fibra óptica)."
                                  ],
                                  "verification": "Escreva uma definição de 1 parágrafo do escopo do 802.3 citando seções do padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documento IEEE 802.3 oficial (disponível gratuitamente em ieee.org)",
                                    "Resumo do padrão Ethernet no site Ethernet Alliance",
                                    "Modelo OSI ilustrado"
                                  ],
                                  "tips": "Use Ctrl+F no PDF do padrão para buscar 'scope' ou 'escopo'.",
                                  "learningObjective": "Reconhecer o escopo exato do 802.3 limitado a PHY e MAC para redes cabeadas.",
                                  "commonMistakes": [
                                    "Incluir camada LLC (802.2) no escopo do 802.3.",
                                    "Confundir com especificações de roteamento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar IEEE 802.3 de padrões sem fio como 802.11",
                                  "subSteps": [
                                    "Compare tabelas de especificações: 802.3 (cabeado, CSMA/CD originalmente) vs. 802.11 (sem fio, CSMA/CA).",
                                    "Liste diferenças chave: meio físico (cabo vs. ar), topologias (estrela vs. BSS/ESS), sensibilidades (interferência EM vs. RF).",
                                    "Identifique velocidades típicas iniciais: 10 Mbps (802.3) vs. 1-2 Mbps (802.11).",
                                    "Crie uma tabela de comparação com 5 colunas: padrão, meio, camada MAC, uso principal, limitações.",
                                    "Discuta por que 802.3 é preferido para backbone de alta velocidade."
                                  ],
                                  "verification": "Preencha uma tabela de comparação e explique verbalmente 3 diferenças principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Comparação IEEE 802.3 vs 802.11 (artigos Cisco ou tutorials Khan Academy)",
                                    "Ferramenta de tabela (Google Sheets ou papel)"
                                  ],
                                  "tips": "Foque em CSMA/CD vs CSMA/CA para memorizar a distinção fundamental.",
                                  "learningObjective": "Diferenciar claramente Ethernet cabeada (802.3) de Wi-Fi (802.11).",
                                  "commonMistakes": [
                                    "Achar que ambos usam o mesmo mecanismo de detecção de colisão.",
                                    "Ignorar que 802.11 tem sublayers adicionais para RF."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar a evolução histórica e velocidades do IEEE 802.3",
                                  "subSteps": [
                                    "Monte uma linha do tempo: 1980 (10BASE5, 10 Mbps) até 802.3bs (400 Gbps, 2017).",
                                    "Identifique marcos: Fast Ethernet (100 Mbps), Gigabit (1 Gbps), 10G, 40G/100G.",
                                    "Note evoluções em codificação (Manchester a PAM4), mídias e distâncias.",
                                    "Pesquise atualizações recentes no site IEEE (ex: 802.3ck para 800 Gbps).",
                                    "Relacione evolução com demandas de data centers e cloud."
                                  ],
                                  "verification": "Crie uma linha do tempo visual com 6-8 velocidades chave e datas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Página Wikipedia IEEE 802.3 (seção história)",
                                    "Ethernet Roadmap do Ethernet Alliance",
                                    "Ferramenta de linha do tempo (Canva ou PowerPoint)"
                                  ],
                                  "tips": "Use mnemônicos como '10-100-1G-10G-40/100-400' para lembrar progressão.",
                                  "learningObjective": "Compreender a escalabilidade do 802.3 de 10 Mbps a 400+ Gbps.",
                                  "commonMistakes": [
                                    "Parar na evolução em 1 Gbps (ignorar hyperscale moderno).",
                                    "Confundir velocidades com padrões Wi-Fi."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de rede corporativa, você identifica que para ligar switches em um data center com 100 Gbps, deve usar cabos SFP28 compatíveis com IEEE 802.3bm (100GBASE-SR4), rejeitando 802.11ac por baixa latência e distância insuficiente.",
                              "finalVerifications": [
                                "Explique o escopo do 802.3 em 2 minutos sem consultar notas.",
                                "Diferencie 802.3 de 802.11 em uma tabela sem erros.",
                                "Liste 5 velocidades evolutivas do 802.3 com anos aproximados.",
                                "Identifique PHY e MAC em um diagrama de frame Ethernet.",
                                "Responda quiz de 10 perguntas sobre escopo com 90% acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de escopo (PHY + MAC, cabeado).",
                                "Correta diferenciação de padrões sem fio.",
                                "Compreensão cronológica da evolução de velocidades.",
                                "Uso correto de terminologia técnica (ex: CSMA/CD).",
                                "Aplicação contextual em cenários reais.",
                                "Ausência de confusões com outros padrões IEEE."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais em cabos (atenuação, reflexão).",
                                "Matemática: Codificação de linha (NRZ, 4B/5B, PAM4).",
                                "História da Tecnologia: Evolução das redes desde ARPANET.",
                                "Engenharia Elétrica: Especificações de transceptores e conectores.",
                                "Negócios: Impacto em infraestrutura de data centers e cloud computing."
                              ],
                              "realWorldApplication": "O padrão IEEE 802.3 é fundamental em redes empresariais, data centers (ex: conexões 100/400 Gbps em AWS/Google Cloud) e provedores de internet, garantindo alta velocidade e confiabilidade em backbones cabeados, diferentemente do Wi-Fi usado em acessos finais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Descrever as camadas físicas suportadas",
                            "description": "Explicar os meios de transmissão suportados pelo IEEE 802.3, como 10BASE5 (coaxial grosso), 10BASE-T (par trançado) e 1000BASE-SX (fibra multimodo), incluindo codificações como Manchester e 4B/5B.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o papel das camadas físicas no IEEE 802.3",
                                  "subSteps": [
                                    "Leia a seção introdutória do padrão IEEE 802.3 sobre a camada física (PHY).",
                                    "Identifique que a PHY define os meios de transmissão, sinalização e codificação para Ethernet.",
                                    "Anote as funções principais: conversão de bits em sinais elétricos/ópticos e detecção de colisões.",
                                    "Compare com o modelo OSI para contextualizar a camada 1.",
                                    "Resuma em um diagrama simples as interfaces entre MAC e PHY."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo explicando o papel da PHY e verifique se cobre meios, sinalização e codificação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação IEEE 802.3 (seção 1), diagrama OSI, vídeo introdutório sobre Ethernet PHY no YouTube.",
                                  "tips": "Use analogias como 'PHY é o cabo e plugues que conectam o carro (MAC) à estrada'.",
                                  "learningObjective": "Compreender as responsabilidades fundamentais da camada física no padrão Ethernet.",
                                  "commonMistakes": "Confundir PHY com MAC; achar que PHY só lida com cabos sem sinalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar meios de transmissão coaxiais clássicos como 10BASE5",
                                  "subSteps": [
                                    "Pesquise especificações de 10BASE5: coaxial grosso (Thicknet), 10 Mbps, topologia bus.",
                                    "Descreva características: distância máxima 500m, conector N-type, transceptor vampire tap.",
                                    "Analise esquema de codificação Manchester: auto-sincronização via transições de sinal.",
                                    "Calcule largura de banda e sinalização: sinal bifásico em 10 MHz.",
                                    "Desenhe um diagrama de rede 10BASE5 com estações conectadas."
                                  ],
                                  "verification": "Liste 5 características chave de 10BASE5 e explique Manchester em 2 frases.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "IEEE 802.3-2018 PDF (cláusula 8), imagens de cabos coaxiais, simulador de rede como Cisco Packet Tracer.",
                                  "tips": "Lembre que coaxial grosso era usado em LANs antigas por robustez em ambientes ruidosos.",
                                  "learningObjective": "Descrever em detalhes o meio coaxial e sua codificação no Ethernet original.",
                                  "commonMistakes": "Esquecer limitações como detecção de colisão em bus compartilhado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar meios modernos: par trançado (10BASE-T) e fibra (1000BASE-SX)",
                                  "subSteps": [
                                    "Estude 10BASE-T: par trançado UTP Cat3/5, 100m, hub/switch, codificação Manchester.",
                                    "Detalhe 1000BASE-SX: fibra multimodo 850nm, 550m, codificação 4B/5B + 8B/10B para Gigabit.",
                                    "Compare distâncias, velocidades e imunidade a ruído: cobre vs. óptico.",
                                    "Identifique conectores: RJ-45 para UTP, SC/LC para fibra.",
                                    "Liste vantagens: full-duplex em switches modernos."
                                  ],
                                  "verification": "Crie uma tabela comparativa com colunas: Meio, Velocidade, Distância, Codificação para 3 variantes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Especificações IEEE 802.3ab (1000BASE-T), 802.3z (fibra), fotos de cabos RJ-45 e fibra.",
                                  "tips": "Foquem em evolução: de bus compartilhado para ponto-a-ponto full-duplex.",
                                  "learningObjective": "Comparar e contrastar meios de cobre e fibra com suas codificações específicas.",
                                  "commonMistakes": "Confundir 10BASE-T (10Mbps) com 100BASE-TX (100Mbps); ignorar modos full/half-duplex."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar codificações e sintetizar descrições completas",
                                  "subSteps": [
                                    "Revise codificações: Manchester (10Mbps), 4B/5B (para FDDI-like), NRZ em Gigabit.",
                                    "Explique propósitos: clock recovery, DC balance, erro de detecção.",
                                    "Escreva descrições padronizadas para cada meio mencionado.",
                                    "Crie um fluxograma de seleção de PHY baseado em velocidade/distância.",
                                    "Teste descrevendo verbalmente para um parceiro ou gravando."
                                  ],
                                  "verification": "Escreva um parágrafo descrevendo todos os meios e codificações sem consultar notas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de codificações Ethernet, gravador de áudio, flashcards.",
                                  "tips": "Use mnemônicos: 'Manchester para 10M, 4B/5B para mais bandeira'.",
                                  "learningObjective": "Sintetizar conhecimentos para descrever fluentemente as camadas físicas suportadas.",
                                  "commonMistakes": "Generalizar codificações sem ligar ao meio específico."
                                }
                              ],
                              "practicalExample": "Em uma LAN corporativa legada, use 10BASE5 para backbone de 500m conectando 10 estações via taps vampiro, com Manchester garantindo sincronização em ambiente fabril ruidoso; migre para 1000BASE-SX em data center para links de 300m entre switches via fibra multimodo.",
                              "finalVerifications": [
                                "Liste corretamente 3 meios físicos com velocidades e distâncias.",
                                "Explique Manchester e 4B/5B com exemplos de uso.",
                                "Desenhe diagrama simples de rede usando 10BASE-T e 1000BASE-SX.",
                                "Compare coaxial vs. fibra em termos de ruído e custo.",
                                "Responda: 'Qual codificação em 10BASE5?' sem hesitação.",
                                "Identifique conectores para cada meio."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: nomes, velocidades e codificações corretos (30%).",
                                "Completude: cobre todos os exemplos citados (25%).",
                                "Clareza na descrição: linguagem acessível e estruturada (20%).",
                                "Uso de exemplos visuais/diagramas (15%).",
                                "Compreensão de codificações e propósitos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais, atenuação em cabos e reflexão em fibras.",
                                "Matemática: Codificação de linha (4B/5B ratios), largura de banda e Nyquist.",
                                "Engenharia Elétrica: Impedância de cabos, conectores e transceptores.",
                                "História da Tecnologia: Evolução de LANs desde 1980s."
                              ],
                              "realWorldApplication": "Projetar infraestruturas de rede em empresas, data centers ou ISPs, escolhendo PHY como 1000BASE-SX para alta velocidade em curtas distâncias ou 10GBASE-LR para longa-haul, otimizando custo vs. performance em ambientes reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Comparar topologias Ethernet clássicas",
                            "description": "Analisar topologias como barramento (bus), estrela (star) e full-duplex ponto-a-ponto, destacando vantagens da topologia estrela com hubs/switches sobre o barramento compartilhado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Topologia de Barramento (Bus)",
                                  "subSteps": [
                                    "Pesquise a definição de topologia de barramento em Ethernet clássica (10BASE5 e 10BASE2).",
                                    "Identifique componentes principais: cabo coaxial compartilhado, transceptores e terminadores.",
                                    "Descreva como os dados são transmitidos: CSMA/CD para detecção de colisões.",
                                    "Liste limitações: colisões frequentes, distância máxima de 500m, falha total se cabo quebrar.",
                                    "Desenhe um diagrama simples da topologia."
                                  ],
                                  "verification": "Crie um diagrama rotulado e liste 3 limitações principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet para pesquisa (Wikipedia, Cisco docs)",
                                    "Papel e caneta ou software de desenho (Draw.io)"
                                  ],
                                  "tips": "Foquem em como o meio compartilhado causa colisões; use analogia de uma festa onde todos falam ao mesmo tempo.",
                                  "learningObjective": "Compreender os princípios e limitações da topologia de barramento Ethernet.",
                                  "commonMistakes": [
                                    "Confundir com topologia anel",
                                    "Ignorar o papel dos terminadores",
                                    "Subestimar impacto das colisões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Topologia de Estrela (Star) com Hubs",
                                  "subSteps": [
                                    "Defina topologia de estrela: nós conectados a um hub central via cabos UTP.",
                                    "Explique o funcionamento: hub repete sinais para todos os ports (meio compartilhado lógico).",
                                    "Compare com barramento: ainda usa CSMA/CD, mas isolado por segmento.",
                                    "Liste vantagens iniciais: fácil adição/remoção de nós, falha localizada.",
                                    "Desenhe diagrama mostrando hub no centro."
                                  ],
                                  "verification": "Desenhe diagrama e explique por que falhas são isoladas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.3",
                                    "Ferramenta de desenho digital"
                                  ],
                                  "tips": "Pense no hub como um 'repetidor multi-porta'; isole o problema de colisões.",
                                  "learningObjective": "Dominar a estrutura e benefícios iniciais da topologia estrela com hubs.",
                                  "commonMistakes": [
                                    "Achar que hubs eliminam colisões completamente",
                                    "Confundir hub com switch",
                                    "Ignorar cabos UTP vs coaxial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Topologia Full-Duplex Ponto-a-Ponto",
                                  "subSteps": [
                                    "Descreva full-duplex: transmissão simultânea bidirecional sem colisões (switches dedicados).",
                                    "Identifique componentes: switches em vez de hubs, pares trançados dedicados.",
                                    "Explique ausência de CSMA/CD: detecção via hardware/full-duplex.",
                                    "Liste vantagens: dobro de throughput, sem colisões, escalável.",
                                    "Compare com half-duplex (barramento/estrela com hubs)."
                                  ],
                                  "verification": "Liste 4 diferenças chave entre half e full-duplex.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Vídeos tutoriais sobre Ethernet full-duplex (YouTube/Khan Academy)",
                                    "Papel para anotações"
                                  ],
                                  "tips": "Full-duplex é como uma conversa telefônica bidirecional vs rádio unidirecional.",
                                  "learningObjective": "Compreender a evolução para topologias ponto-a-ponto full-duplex.",
                                  "commonMistakes": [
                                    "Confundir full-duplex com velocidade maior sem full-duplex",
                                    "Achar que switches são hubs avançados sem considerar duplex"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Topologias e Destacar Vantagens da Estrela Moderna",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: barramento vs estrela (hub) vs estrela (switch/full-duplex).",
                                    "Colunas: colisões, escalabilidade, custo, confiabilidade, distância.",
                                    "Destaque vantagens estrela com switches: sem colisões, full-duplex, gerenciamento fácil.",
                                    "Discuta por que barramento foi obsoleto: manutenção difícil, baixa performance.",
                                    "Resuma em um parágrafo as razões para adoção da estrela."
                                  ],
                                  "verification": "Apresente tabela comparativa completa e parágrafo de resumo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha (Google Sheets/Excel)",
                                    "Resumos dos steps anteriores"
                                  ],
                                  "tips": "Use métricas quantitativas como 'colisões em 50% do tráfego em barramento'.",
                                  "learningObjective": "Analisar criticamente e comparar topologias Ethernet clássicas.",
                                  "commonMistakes": [
                                    "Ignorar custo inicial de switches",
                                    "Não quantificar vantagens",
                                    "Focar só em teoria sem prática"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório de rede escolar, configure três PCs: um em 'barramento simulado' (usando hub antigo), um em estrela half-duplex e um em switch full-duplex. Meça throughput com iPerf e observe colisões via Wireshark, comparando tempos de transferência de arquivos.",
                              "finalVerifications": [
                                "Pode desenhar e rotular diagramas de todas as topologias.",
                                "Lista corretamente prós/contras de cada uma.",
                                "Explica por que estrela com switches supera barramento.",
                                "Identifica cenários onde full-duplex é essencial.",
                                "Cria tabela comparativa precisa.",
                                "Discute impacto de colisões em performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas descrições (80% correto).",
                                "Profundidade da comparação (cobertura de 5+ critérios).",
                                "Clareza nos diagramas e tabelas.",
                                "Uso de exemplos práticos reais.",
                                "Identificação correta de vantagens da estrela moderna.",
                                "Ausência de confusões entre hub/switch e half/full-duplex."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais e reflexão em cabos (terminadores).",
                                "Matemática: Probabilidade de colisões em CSMA/CD (modelos estocásticos).",
                                "Eletrônica: Diferenças em pares trançados vs coaxial.",
                                "Gestão: Custos de manutenção e escalabilidade em TI."
                              ],
                              "realWorldApplication": "Em redes corporativas, topologias estrela com switches full-duplex são padrão em LANs de escritórios, permitindo alto throughput sem colisões, facilitando VoIP, streaming e trabalho remoto, ao contrário de barramentos obsoletos em setups legados industriais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Mecanismo CSMA/CD",
                        "description": "CSMA/CD (Carrier Sense Multiple Access with Collision Detection) é o protocolo de acesso ao meio usado em Ethernet clássica half-duplex para detectar e resolver colisões em meios compartilhados.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Explicar o funcionamento do CSMA/CD",
                            "description": "Descrever as etapas: Carrier Sense (verificar se o meio está livre), Multiple Access (transmitir se livre), Collision Detection (detectar colisão durante transmissão) e backoff exponencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Carrier Sense (Sentido do Portador)",
                                  "subSteps": [
                                    "Estude o conceito de meio compartilhado em redes Ethernet com hubs.",
                                    "Aprenda como uma estação verifica se o canal está ocioso escutando por 9.6 µs (slot time mínimo).",
                                    "Entenda que se o canal estiver ocupado, a estação espera e verifica novamente.",
                                    "Analise o diagrama de timing para detecção de portador livre.",
                                    "Diferencie detecção passiva de energia no cabo de transmissão ativa."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o processo de Carrier Sense sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de CSMA/CD",
                                    "Vídeo tutorial sobre Ethernet básica",
                                    "Simulador de redes online (ex: Packet Tracer)"
                                  ],
                                  "tips": "Visualize o cabo como uma estrada: só entre se estiver vazia.",
                                  "learningObjective": "Dominar a fase inicial de verificação do meio antes da transmissão.",
                                  "commonMistakes": [
                                    "Confundir com transmissão imediata",
                                    "Ignorar o tempo mínimo de escuta",
                                    "Misturar com CSMA/CA que usa RTS/CTS"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar Multiple Access (Acesso Múltiplo)",
                                  "subSteps": [
                                    "Descreva como estações transmitem simultaneamente se o Carrier Sense indicar livre.",
                                    "Estude o formato de quadro Ethernet (preâmbulo, SFD, dados).",
                                    "Simule transmissão de múltiplas estações em um canal livre.",
                                    "Analise como o sinal se propaga bidirecionalmente no cabo coaxial ou par trançado.",
                                    "Discuta a vulnerabilidade a colisões devido ao acesso concorrente."
                                  ],
                                  "verification": "Crie um fluxograma simples mostrando transmissão após Carrier Sense positivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Fluxograma em branco",
                                    "Documentação IEEE 802.3",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Lembre-se: múltiplo acesso significa 'todos podem tentar', mas não garante sucesso.",
                                  "learningObjective": "Entender como o acesso concorrente inicia a transmissão em redes compartilhadas.",
                                  "commonMistakes": [
                                    "Achar que há coordenação central",
                                    "Omitir o papel do preâmbulo",
                                    "Confundir com redes token ring"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar Collision Detection (Detecção de Colisão)",
                                  "subSteps": [
                                    "Aprenda como estações monitoram o sinal durante transmissão para detectar sobreposição.",
                                    "Estude o sinal JAM (sequência de 32 bits) enviado para sinalizar colisão a todas as estações.",
                                    "Analise o cálculo de CRC para validar quadros e detectar erros.",
                                    "Simule uma colisão: duas estações transmitem quase simultaneamente.",
                                    "Entenda o tempo máximo de detecção (2x propagação + slot time)."
                                  ],
                                  "verification": "Explique o que acontece fisicamente em uma colisão e como é detectada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Osciloscópio simulado online",
                                    "Vídeos de colisões Ethernet",
                                    "Papel para desenhar waveforms"
                                  ],
                                  "tips": "Colisão é como duas pessoas gritando ao mesmo tempo: sinal distorcido é detectado.",
                                  "learningObjective": "Compreender a detecção ativa de colisões durante transmissão.",
                                  "commonMistakes": [
                                    "Pensar que colisões são impossíveis em Ethernet",
                                    "Confundir JAM com padding",
                                    "Ignorar detecção contínua"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Backoff Exponencial e Recuperação",
                                  "subSteps": [
                                    "Estude o algoritmo truncated binary exponential backoff: esperar k*slot_time onde k é aleatório [0,2^n-1].",
                                    "Aprenda que n aumenta após cada colisão (até 10 tentativas).",
                                    "Simule 3 rodadas de backoff para uma estação colidindo.",
                                    "Discuta retransmissão após backoff ou falha após 16 tentativas.",
                                    "Compare com CSMA/CA para contextualizar evolução."
                                  ],
                                  "verification": "Calcule manualmente o backoff para n=3 e k=2, explicando o propósito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de backoff Ethernet",
                                    "Simulador de CSMA/CD (ex: NS-3)"
                                  ],
                                  "tips": "O backoff aleatório evita 'liveslock' eterno entre duas estações.",
                                  "learningObjective": "Dominar o mecanismo de recuperação probabilística após colisões.",
                                  "commonMistakes": [
                                    "Confundir com backoff fixo",
                                    "Errar o limite de 1024 slots",
                                    "Omitir truncamento após 10 colisões"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma rede Ethernet clássica com 4 estações conectadas a um hub de 10 Mbps. Use papel e lápis ou Cisco Packet Tracer: Estação A tenta transmitir dados; B inicia logo após (colisão detectada); ambas enviam JAM, calculam backoff e retransmitem com sucesso.",
                              "finalVerifications": [
                                "Descreva as quatro fases principais do CSMA/CD em sequência correta.",
                                "Explique o papel do sinal JAM e slot time.",
                                "Calcule um exemplo de backoff exponencial para 2 colisões.",
                                "Diferencie CSMA/CD de CSMA/CA.",
                                "Desenhe um diagrama de timing de uma transmissão bem-sucedida e uma com colisão.",
                                "Liste limitações do CSMA/CD em redes modernas."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas descrições das fases CSMA/CD (90%+ acurácia).",
                                "Clareza e estrutura lógica na explicação sequencial.",
                                "Uso correto de terminologia IEEE 802.3 (JAM, slot time, backoff).",
                                "Capacidade de simular ou diagramar cenários de colisão.",
                                "Integração de exemplos práticos e distinções com outros protocolos.",
                                "Compreensão de implicações probabilísticas no backoff."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais elétricos e interferência de ondas.",
                                "Matemática: Algoritmos probabilísticos e exponenciação binária.",
                                "Probabilidade e Estatística: Distribuição aleatória no backoff para resolver contenção.",
                                "Engenharia: Design de protocolos de rede e eficiência de throughput."
                              ],
                              "realWorldApplication": "Em redes Ethernet legadas com hubs (pré-1997), CSMA/CD gerenciava colisões em LANs compartilhadas, como escritórios antigos. Hoje, essencial para entender por que switches full-duplex e WiFi (CSMA/CA) substituíram, otimizando redes sem colisões em data centers e IoT industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Calcular o tempo mínimo de detecção de colisão",
                            "description": "Determinar o tempo de propagação máximo no segmento (2 * comprimento máximo / velocidade da luz no meio) para garantir detecção de colisões, como 512 bit times em Ethernet 10 Mbps.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de CSMA/CD e Detecção de Colisão",
                                  "subSteps": [
                                    "Estude o protocolo CSMA/CD: Carrier Sense Multiple Access with Collision Detection.",
                                    "Explique por que colisões ocorrem em redes compartilhadas e a necessidade de detecção rápida.",
                                    "Defina tempo de propagação como o tempo para um sinal viajar ida e volta no segmento.",
                                    "Identifique que o tempo mínimo de detecção deve cobrir o pior caso: sinal de uma extremidade colidindo com outra.",
                                    "Revise a importância do tempo de detecção ser menor que o tempo de transmissão de um quadro mínimo."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e explique o papel do tempo de detecção.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação IEEE 802.3, vídeo tutorial sobre CSMA/CD.",
                                  "tips": "Use diagramas de rede para visualizar o sinal viajando entre estações remotas.",
                                  "learningObjective": "Compreender os princípios físicos e lógicos por trás da detecção de colisão em Ethernet.",
                                  "commonMistakes": "Confundir CSMA/CA (Wi-Fi) com CSMA/CD (Ethernet cabeada); ignorar o fator 'ida e volta'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Parâmetros do Segmento Ethernet",
                                  "subSteps": [
                                    "Determine o comprimento máximo do segmento: 500m para 10BASE5 ou 2500m com repetidores (até 4).",
                                    "Calcule a velocidade da propagação: tipicamente 2x10^8 m/s em cabos coaxiais (2/3 da velocidade da luz).",
                                    "Liste especificações do Ethernet 10 Mbps: taxa de dados 10^7 bits/segundo, quadro mínimo 512 bits.",
                                    "Registre bit time: 1 / taxa de dados = 100 ns.",
                                    "Confirme limites do padrão IEEE 802.3 para colisão worst-case."
                                  ],
                                  "verification": "Crie uma tabela com valores: comprimento, velocidade, bit time.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Especificação IEEE 802.3 PDF, calculadora.",
                                  "tips": "Use valores padronizados iniciais para evitar erros de suposição.",
                                  "learningObjective": "Coletar dados precisos do sistema para cálculos subsequentes.",
                                  "commonMistakes": "Usar velocidade da luz no vácuo (3x10^8 m/s) em vez de no cabo; esquecer repetidores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Tempo de Propagação Máximo",
                                  "subSteps": [
                                    "Aplique a fórmula: tempo = 2 * comprimento máximo / velocidade de propagação.",
                                    "Exemplo: para 2500m a 2x10^8 m/s, calcule 2 * 2500 / 2e8 = 25 μs.",
                                    "Converta unidades consistentemente (metros, segundos).",
                                    "Ajuste para configurações específicas, como 500m sem repetidores.",
                                    "Compare com tempo de transmissão do quadro mínimo."
                                  ],
                                  "verification": "Mostre cálculo passo a passo resultando em ~25 μs para worst-case.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica, planilha Excel para fórmulas.",
                                  "tips": "Sempre multiplique por 2 para ida e volta; verifique unidades (s para μs).",
                                  "learningObjective": "Dominar o cálculo físico do tempo de propagação em redes.",
                                  "commonMistakes": "Esquecer o fator 2; usar velocidade errada (ex: 3x10^8 em cabo)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Converter para Bit Times e Verificar Conformidade",
                                  "subSteps": [
                                    "Calcule bit times necessários: tempo de propagação / bit time.",
                                    "Exemplo: 25 μs / 100 ns = 250 bit times; padrão usa 512 para margem.",
                                    "Explique por que 512 bit times: cobre worst-case com repetidores e overhead.",
                                    "Simule cenários: reduza comprimento e recalcule.",
                                    "Documente o tempo mínimo de detecção como 512 bit times em 10 Mbps."
                                  ],
                                  "verification": "Produza resultado final: 512 bit times, com justificativa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Simulador de rede online (ex: Cisco Packet Tracer), papel e caneta.",
                                  "tips": "Arredonde para cima para segurança; teste com valores do padrão.",
                                  "learningObjective": "Integrar cálculo físico com métricas de rede digital.",
                                  "commonMistakes": "Calcular apenas ida (não volta); ignorar quadro mínimo de 64 bytes (512 bits)."
                                }
                              ],
                              "practicalExample": "Em uma rede Ethernet 10 Mbps com 4 repetidores (2500m total), calcule: velocidade 2e8 m/s, tempo = 2*2500/2e8 = 25μs, bit time=100ns, 25μs/100ns=250 bits. Padrão usa 512 bits para garantir detecção em todos os casos.",
                              "finalVerifications": [
                                "Cálculo resulta em pelo menos 512 bit times para Ethernet 10 Mbps worst-case.",
                                "Fórmula inclui fator 2 para propagação round-trip.",
                                "Velocidade de propagação ajustada para meio físico (ex: 66% c).",
                                "Comparação com tempo de quadro mínimo (51.2 μs) confirmada.",
                                "Explicação verbal do impacto em design de rede.",
                                "Teste com comprimento reduzido (500m) produz <512 bits."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: erro <1% nos cálculos.",
                                "Uso correto de unidades e conversões (s, μs, ns, bits).",
                                "Justificativa física baseada em IEEE 802.3.",
                                "Identificação de worst-case scenario.",
                                "Aplicação prática em exemplo numérico.",
                                "Clareza na documentação de passos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas eletromagnéticas em meios dielétricos.",
                                "Matemática: Cálculo de velocidades, proporções e conversões unitárias.",
                                "Engenharia: Design de sistemas com margens de segurança.",
                                "Telecomunicações: Protocolos de acesso múltiplo em redes sem fio."
                              ],
                              "realWorldApplication": "Determina o limite máximo de tamanho de rede em Ethernet clássica (ex: 500m por segmento), influencia migração para switched/full-duplex Ethernet sem CSMA/CD, e é base para timing em redes modernas como Fibre Channel."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Analisar resolução de colisões",
                            "description": "Detalhar o algoritmo de backoff binário exponencial truncado, onde após colisão, o transmissor espera k * 512 bit times, com k aleatório de 0 a 2^n -1, n até 10.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender colisões e detecção em CSMA/CD",
                                  "subSteps": [
                                    "Revise o funcionamento básico do CSMA/CD: Carrier Sense, Multiple Access with Collision Detection.",
                                    "Identifique cenários onde colisões ocorrem, como transmissões simultâneas em redes compartilhadas.",
                                    "Explique a jam signal: transmissão de 32 bits para notificar colisão.",
                                    "Descreva o que acontece imediatamente após detecção: parar transmissão e enviar jam.",
                                    "Diferencie colisão de carrier sense falho."
                                  ],
                                  "verification": "Escreva um diagrama de sequência mostrando detecção de colisão e jam signal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação IEEE 802.3, simulador de rede como Cisco Packet Tracer.",
                                  "tips": "Use timelines visuais para mapear sinais no cabo.",
                                  "learningObjective": "Entender triggers e resposta inicial a colisões.",
                                  "commonMistakes": "Confundir CSMA/CA (WiFi) com CSMA/CD; ignorar jam signal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o algoritmo de backoff binário exponencial",
                                  "subSteps": [
                                    "Defina o backoff: tempo de espera antes de retransmitir após colisão.",
                                    "Aprenda a fórmula: espera k * 512 bit times, onde k é aleatório uniforme de {0,1,...,2^n -1}.",
                                    "Entenda n: número de colisões consecutivas para esta frame, inicia em 0.",
                                    "Calcule exemplos: para n=1, k=0 ou 1 (espera 0 ou 512 bits); n=2, k=0-3.",
                                    "Explique por que exponencial: aumenta intervalo para reduzir probabilidade de colisão recorrente."
                                  ],
                                  "verification": "Calcule delays para n=0 a 3 e liste intervalos possíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de cálculo ou calculadora para potências de 2, pseudocódigo do algoritmo.",
                                  "tips": "Memorize 512 bits como slot time no Ethernet 10Mbps.",
                                  "learningObjective": "Dominar fórmula e lógica de escalonamento exponencial.",
                                  "commonMistakes": "Usar 2^n em vez de 2^n -1 para range de k; confundir n com tentativas totais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar truncamento e limites do backoff",
                                  "subSteps": [
                                    "Estude truncamento: n máximo=10 (1023 slots), mesmo para mais colisões.",
                                    "Explique excesso de colisões: após 16 tentativas, descartar frame.",
                                    "Calcule tempo máximo de backoff: 1023 * 512 bit times ≈ 51.2μs em 10Mbps.",
                                    "Discuta impacto: evita starvation em redes carregadas.",
                                    "Compare com backoff linear ou fixo."
                                  ],
                                  "verification": "Resuma regras de truncamento em tabela: n vs. max k vs. ação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela IEEE 802.3 para backoff parameters.",
                                  "tips": "Converta bit times para tempo: divida por taxa de bits (ex: 10Mbps = 10^7 bps).",
                                  "learningObjective": "Compreender mecanismos de prevenção de loops infinitos.",
                                  "commonMistakes": "Ignorar que n reseta por frame bem-sucedida; confundir max n=10 com 16 tentativas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e analisar cenários de colisão",
                                  "subSteps": [
                                    "Simule 2 estações colidindo: calcule backoffs para múltiplas retransmissões.",
                                    "Modele probabilidade: para n baixo, alta chance de resolução rápida.",
                                    "Analise pior caso: n=10, k=1023 repetido.",
                                    "Compare eficiência: calcule throughput médio vs. sem backoff.",
                                    "Teste em ferramenta: implemente pseudocódigo ou use simulador."
                                  ],
                                  "verification": "Crie simulação manual ou código simples gerando k aleatórios e somando delays.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python ou JS para simulação, Wireshark para captura Ethernet legacy.",
                                  "tips": "Use random.uniform(0, 2**n) e floor para k.",
                                  "learningObjective": "Aplicar algoritmo em cenários reais para análise.",
                                  "commonMistakes": "Não resetar n após sucesso; ignorar aleatoriedade em cálculos."
                                }
                              ],
                              "practicalExample": "Em uma LAN Ethernet 10Mbps com 4 estações, estações A e B transmitem simultaneamente (colisão 1, n=1). Ambas enviam jam, escolhem k=1 e 0 (esperas 512 e 0 bits). B retransmite primeiro; A colide novamente com C (n=2 para A), escolhe k=2, espera 1024 bits. Simule sequência até sucesso.",
                              "finalVerifications": [
                                "Explique verbalmente o backoff para n=3: range de k e tempo total possível.",
                                "Calcule delay máximo truncado e converta para ms.",
                                "Desenhe fluxograma completo de resolução de colisão.",
                                "Simule 10 rodadas de colisões e compute tentativas médias.",
                                "Diferencie de CSMA/CA em WiFi.",
                                "Identifique quando frame é descartada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula de backoff e range de k (100% correto).",
                                "Correta identificação de truncamento (n<=10).",
                                "Cálculos de tempo precisos com unidades.",
                                "Análise qualitativa de eficiência exponencial.",
                                "Simulação funcional sem erros lógicos.",
                                "Conexão clara com CSMA/CD completo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e distribuições uniformes para k.",
                                "Programação: Implementar simulador em Python com random e loops.",
                                "Física: Propagação de sinais em cabos coaxiais (10Base5).",
                                "Estatística: Análise de throughput e colisões em redes carregadas."
                              ],
                              "realWorldApplication": "Em redes Ethernet clássicas (hubs), CSMA/CD resolvia colisões em LANs compartilhadas; hoje, legado em switches full-duplex sem colisões, mas algoritmo inspira WiFi (BEB em 802.11) e troubleshooting de redes antigas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Estrutura do Frame Ethernet",
                        "description": "O frame Ethernet IEEE 802.3u/802.3ab inclui campos como Preamble, SFD, Destino, Origem, Type/Length, Data, CRC e opcionalmente VLAN Tag.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Descrever os campos do frame Ethernet",
                            "description": "Identificar e explicar cada campo: Preamble (7 bytes + 1 SFD), MAC Destino/Origem (6 bytes cada), EtherType/Length (2 bytes), Payload (46-1500 bytes), FCS (4 bytes CRC-32).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Preamble e SFD",
                                  "subSteps": [
                                    "Estude o Preamble: 7 bytes de padrão alternado 10101010 (56 bits) para sincronização de clock do receptor.",
                                    "Analise o SFD (Start Frame Delimiter): 1 byte com padrão 10101011, marcando o início do frame real.",
                                    "Pesquise o propósito: permite que o receptor detecte o começo da transmissão e ajuste o timing.",
                                    "Compare com frames sem preamble para entender a importância da sincronização.",
                                    "Anote o tamanho total: 8 bytes (7 + 1)."
                                  ],
                                  "verification": "Desenhe o início do frame e rotule Preamble e SFD com seus padrões binários e tamanhos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.3",
                                    "Diagrama visual de frame Ethernet",
                                    "Ferramenta de captura como Wireshark"
                                  ],
                                  "tips": "Visualize o Preamble como um 'sinal de alerta' para o receptor se preparar.",
                                  "learningObjective": "Explicar o papel do Preamble e SFD na sincronização inicial do frame Ethernet.",
                                  "commonMistakes": [
                                    "Confundir Preamble com parte dos dados",
                                    "Esquecer que SFD é separado e tem o último bit alterado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os Campos de Endereço MAC Destino e Origem",
                                  "subSteps": [
                                    "Descreva MAC Destino: 6 bytes no início, identificando o receptor (unicast, multicast ou broadcast).",
                                    "Explique MAC Origem: 6 bytes seguintes, endereço único do transmissor.",
                                    "Estude o formato: 48 bits, representados como XX:XX:XX:XX:XX:XX em hexadecimal.",
                                    "Diferencie broadcast (FF:FF:FF:FF:FF:FF) de unicast.",
                                    "Calcule o tamanho total: 12 bytes (6 + 6)."
                                  ],
                                  "verification": "Identifique MACs em um exemplo de frame capturado e explique seu uso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de endereços MAC exemplo",
                                    "Ferramenta Wireshark para visualizar frames reais",
                                    "Tabela IEEE OUI para fabricantes"
                                  ],
                                  "tips": "Lembre-se: Destino vem primeiro para decisão rápida de encaminhamento no switch.",
                                  "learningObjective": "Identificar e descrever a função dos campos MAC Destino e Origem no roteamento de frames.",
                                  "commonMistakes": [
                                    "Inverter a ordem Destino/Origem",
                                    "Confundir com IP addresses (camada superior)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Campo EtherType/Length e Payload",
                                  "subSteps": [
                                    "Defina EtherType/Length: 2 bytes indicando tipo de protocolo (ex: 0x0800 para IPv4) ou tamanho do payload.",
                                    "Diferencie EtherType (>1536) de Length (≤1500).",
                                    "Descreva Payload: 46-1500 bytes de dados da camada superior, com padding se <46 bytes.",
                                    "Calcule limites: MTU de 1500 bytes para Ethernet padrão.",
                                    "Examine exemplos: IPv4 (0x0800), ARP (0x0806)."
                                  ],
                                  "verification": "Classifique um valor de 2 bytes como EtherType ou Length e descreva o payload associado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de EtherTypes IANA",
                                    "Exemplos de frames Wireshark",
                                    "Calculadora hexadecimal"
                                  ],
                                  "tips": "Se o valor for 0x0800, espere dados IP no payload.",
                                  "learningObjective": "Diferenciar EtherType/Length e descrever o conteúdo e restrições do Payload.",
                                  "commonMistakes": [
                                    "Confundir sempre com tipo de protocolo",
                                    "Esquecer padding mínimo de 46 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender o Campo FCS (Frame Check Sequence)",
                                  "subSteps": [
                                    "Explique FCS: 4 bytes (32 bits) com CRC-32 para detecção de erros.",
                                    "Descreva o algoritmo: CRC polinomial sobre todos os campos exceto Preamble/SFD.",
                                    "Aprenda como calcular: use gerador CRC-32-IEEE 802.3.",
                                    "Entenda o impacto: receptor recalcula e compara; mismatch descarta frame.",
                                    "Note posição: final do frame, após payload."
                                  ],
                                  "verification": "Calcule CRC simples para um frame exemplo e verifique integridade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora online CRC-32",
                                    "Documentação CRC IEEE 802.3",
                                    "Software como Wireshark para validar FCS"
                                  ],
                                  "tips": "FCS protege contra ruído na transmissão física.",
                                  "learningObjective": "Descrever o mecanismo de detecção de erros via FCS e seu cálculo.",
                                  "commonMistakes": [
                                    "Incluir Preamble no cálculo CRC",
                                    "Confundir com checksum de IP"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar e Visualizar a Estrutura Completa do Frame",
                                  "subSteps": [
                                    "Liste todos os campos em ordem: Preamble/SFD (8), Dest (6), Orig (6), Type/Length (2), Payload (46-1500), FCS (4).",
                                    "Desenhe um diagrama completo com tamanhos proporcionais.",
                                    "Calcule tamanho mínimo (64 bytes) e máximo (1518 bytes).",
                                    "Simule um frame completo com dados reais.",
                                    "Compare com frame real capturado."
                                  ],
                                  "verification": "Crie um diagrama rotulado e explique a sequência total.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho",
                                    "Wireshark capture",
                                    "Templates de frame Ethernet"
                                  ],
                                  "tips": "Use cores diferentes para cada campo no diagrama.",
                                  "learningObjective": "Sintetizar todos os campos em uma visão completa do frame Ethernet.",
                                  "commonMistakes": [
                                    "Errar tamanhos totais",
                                    "Omitir interdependências como padding"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture um ping (ICMP sobre IPv4) em uma LAN Ethernet. No hex dump, identifique: bytes 1-8 (Preamble/SFD invisível no Wireshark, mas conceitual), 9-14 (MAC Dest), 15-20 (MAC Orig), 21-22 (EtherType 0x0800), 23+ (Payload IPv4/ICMP), final 4 bytes (FCS). Explique cada campo para um colega.",
                              "finalVerifications": [
                                "Listar corretamente os 6 campos principais com tamanhos exatos e ordem.",
                                "Explicar função única de cada campo sem confusões.",
                                "Desenhar diagrama preciso de frame Ethernet.",
                                "Identificar campos em um frame Wireshark real.",
                                "Calcular tamanho total de um frame exemplo.",
                                "Diferenciar EtherType de Length com exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos tamanhos e padrões binários (ex: Preamble 10101010).",
                                "Correta sequência e interdependências dos campos.",
                                "Profundidade na explicação de funções (sincronização, endereçamento, integridade).",
                                "Uso correto de terminologia técnica (CRC-32, MTU, OUI).",
                                "Capacidade de aplicar em exemplos reais (Wireshark).",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Sincronização de sinais e propagação em cabos (Preamble/SFD).",
                                "Matemática: Cálculo de polinômios CRC-32 e aritmética hexadecimal.",
                                "Segurança da Informação: Spoofing de MAC e detecção de integridade via FCS.",
                                "Engenharia: Design de protocolos e limites de MTU em hardware.",
                                "Programação: Parsing de frames em bibliotecas como Scapy (Python)."
                              ],
                              "realWorldApplication": "Em redes LAN corporativas, switches leem MAC Destino para encaminhar frames Ethernet rapidamente; FCS garante que dados corrompidos (por ruído em cabos) sejam descartados, prevenindo erros em aplicações como videochamadas ou transferências de arquivos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Explicar padding e MTU",
                            "description": "Entender o uso de padding para frames menores que 64 bytes, garantindo detecção de colisões, e o MTU padrão de 1500 bytes, com Jumbo Frames até 9000 bytes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica do frame Ethernet e o tamanho mínimo",
                                  "subSteps": [
                                    "Estude a composição do frame Ethernet: preamble, SFD, endereços MAC, tipo/length, dados, CRC.",
                                    "Identifique o tamanho mínimo de 64 bytes para um frame válido conforme IEEE 802.3.",
                                    "Analise por que frames menores que 64 bytes são inválidos (detecção de colisões em CSMA/CD).",
                                    "Calcule o tamanho mínimo: 8 (preamble+SFD) + 14 (headers) + 46 (dados min) + 4 (CRC) = 64 bytes.",
                                    "Visualize diagramas de frames Ethernet com e sem dados suficientes."
                                  ],
                                  "verification": "Desenhe um diagrama de frame Ethernet de 64 bytes e rotule todos os campos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de frame Ethernet (RFC 894 ou Wireshark docs)",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Lembre-se: o tamanho mínimo garante que o frame ocupe o slot de colisão mínimo (512 bit times).",
                                  "learningObjective": "Dominar os componentes e o requisito de tamanho mínimo do frame Ethernet.",
                                  "commonMistakes": [
                                    "Confundir tamanho mínimo com MTU.",
                                    "Ignorar o impacto do CSMA/CD no legacy Ethernet."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o conceito e aplicação do padding",
                                  "subSteps": [
                                    "Defina padding: bytes zeros adicionados ao campo de dados para atingir 64 bytes.",
                                    "Explique a necessidade: frames com dados <46 bytes não detectam colisões adequadamente em redes half-duplex.",
                                    "Simule um exemplo: frame ARP (42 bytes headers + dados) recebe 4 bytes de padding.",
                                    "Discuta como o receptor ignora padding baseado no campo Length.",
                                    "Teste com ferramenta: gere tráfego pequeno e observe padding em captura de pacotes."
                                  ],
                                  "verification": "Crie um frame hipotético de 50 bytes totais e mostre onde adicionar 14 bytes de padding.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark para captura de pacotes",
                                    "Documentação IEEE 802.3 seção 4.4"
                                  ],
                                  "tips": "Padding é transparente para camadas superiores; foque no campo Length para dados reais.",
                                  "learningObjective": "Entender o papel do padding na integridade e detecção de colisões.",
                                  "commonMistakes": [
                                    "Pensar que padding é sempre adicionado pelo remetente (switchs podem fazer).",
                                    "Confundir padding com stuff bits."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conceituar MTU e seu valor padrão em Ethernet",
                                  "subSteps": [
                                    "Defina MTU: Maximum Transmission Unit, tamanho máximo de payload por frame (1500 bytes padrão).",
                                    "Calcule frame máximo: 18 bytes headers + 1500 dados = 1518 bytes.",
                                    "Explique impactos: superior a MTU causa fragmentação em IP.",
                                    "Compare com outros meios: MTU varia por tecnologia (ex: 9000 em Jumbo).",
                                    "Analise configuração: verifique MTU em interfaces com comandos como 'ifconfig' ou 'ip link'."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre tamanho total do frame e MTU.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Comandos de rede (Linux/Windows)",
                                    "RFC 791 (IP) para fragmentação"
                                  ],
                                  "tips": "MTU padrão é legado do Ethernet original; teste com ping -M do -s 1472 para MTU 1500.",
                                  "learningObjective": "Compreender limites superiores de transmissão e suas implicações.",
                                  "commonMistakes": [
                                    "Confundir MTU com tamanho total do frame (inclui headers).",
                                    "Ignorar overhead de L2 em cálculos de throughput."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Jumbo Frames e considerações práticas",
                                  "subSteps": [
                                    "Defina Jumbo Frames: MTU >4000 bytes, comum 9000 bytes em redes LAN de alta performance.",
                                    "Discuta vantagens: redução de overhead de headers, melhor throughput em storage (iSCSI).",
                                    "Aborde desafios: necessidade de suporte em todos os dispositivos, risco de fragmentação.",
                                    "Simule configuração: ajuste MTU em VM ou switch virtual (ex: VMware).",
                                    "Avalie cenários: quando usar Jumbo vs padrão (ex: data centers vs WAN)."
                                  ],
                                  "verification": "Configure MTU 9000 em uma interface de teste e capture um Jumbo Frame.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Máquina virtual com múltiplas NICs",
                                    "Wireshark",
                                    "Documentação de switch (Cisco/HPE)"
                                  ],
                                  "tips": "Sempre teste end-to-end após mudança de MTU para evitar blackholing.",
                                  "learningObjective": "Aplicar conhecimentos de MTU em cenários avançados como Jumbo Frames.",
                                  "commonMistakes": [
                                    "Assumir suporte universal a Jumbo Frames.",
                                    "Esquecer de ajustar MTU em túneis/VPNs."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark em uma rede local, capture um pacote ARP (tipicamente 60 bytes após padding). Observe o campo Length=28 indicando dados reais, com padding 0x00 até 46 bytes de payload total, atingindo 64 bytes. Em seguida, envie um ping com tamanho grande (ex: ping -s 1472) e verifique frame de 1518 bytes confirmando MTU 1500.",
                              "finalVerifications": [
                                "Explicar corretamente por que padding é adicionado a frames menores que 64 bytes.",
                                "Citar o MTU padrão de Ethernet e calcular tamanho máximo de frame.",
                                "Descrever diferenças entre padding e Jumbo Frames.",
                                "Identificar um erro comum em configuração de MTU.",
                                "Simular cálculo de padding para um frame com 40 bytes de dados.",
                                "Explicar impacto de MTU incorreto em comunicações IP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de padding e seu propósito (detecção de colisões).",
                                "Correção nos valores: 64 bytes mínimo, 1500 MTU padrão, 9000 Jumbo.",
                                "Capacidade de calcular tamanhos de frames com padding/MTU.",
                                "Uso correto de exemplos práticos com ferramentas como Wireshark.",
                                "Compreensão de implicações em redes reais (fragmentação, throughput).",
                                "Clareza na distinção entre tamanho mínimo, padding e MTU."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos de tamanhos binários e aritméticos de bytes.",
                                "Física: Propagação de sinais e tempos de colisão em CSMA/CD.",
                                "Segurança da Informação: Detecção de erros via CRC e colisões.",
                                "Administração de Sistemas: Configuração de redes e troubleshooting."
                              ],
                              "realWorldApplication": "Em data centers, configurar Jumbo Frames (MTU 9000) em switches e NICs para SANs iSCSI, reduzindo CPU em 20-30% por menor overhead. Em troubleshooting, verificar MTU mismatch causa perda de pacotes em VPNs; usar ping para testar e adicionar padding é automático em switches modernos para compatibilidade legacy."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Interpretar endereços MAC no frame",
                            "description": "Analisar formatos de endereços MAC de 48 bits (OUI + NIC), unicast/multicast/broadcast, e como switches usam tabelas CAM para encaminhamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica do endereço MAC de 48 bits",
                                  "subSteps": [
                                    "Estude a representação do endereço MAC em formato hexadecimal (6 bytes, 12 dígitos hex separadas por dois-pontos).",
                                    "Aprenda a divisão: primeiros 24 bits (3 bytes) são o OUI (Organizationally Unique Identifier, atribuído pela IEEE).",
                                    "Identifique os últimos 24 bits como NIC (Network Interface Card, único por fabricante).",
                                    "Pratique convertendo um MAC hex para binário para visualizar os 48 bits.",
                                    "Memorize exemplos de OUIs comuns (ex: 00:1A:2B para um fabricante fictício)."
                                  ],
                                  "verification": "Converta manualmente 3 endereços MAC hex para binário e identifique OUI/NIC corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal/binária online",
                                    "Lista de OUIs da IEEE (oui.ieee.org)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Sempre leia o MAC da esquerda para a direita; o primeiro byte é o mais significativo.",
                                  "learningObjective": "Explicar a composição exata de um endereço MAC e decodificá-lo em componentes OUI e NIC.",
                                  "commonMistakes": [
                                    "Confundir ordem de bytes (big-endian é padrão)",
                                    "Ignorar que OUI pode ser local ou global",
                                    "Erro na contagem de bits (48 no total)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar tipos de endereços MAC: unicast, multicast e broadcast",
                                  "subSteps": [
                                    "Analise o bit menos significativo (LSB) do primeiro byte: 0 para unicast, 1 para multicast/grupo.",
                                    "Reconheça broadcast: FF:FF:FF:FF:FF:FF (todos 1s em binário).",
                                    "Diferencie multicast IPv4 (01:00:5E:xx:xx:xx) de outros grupos.",
                                    "Pratique com exemplos: classifique 5 MACs como unicast/multicast/broadcast.",
                                    "Entenda implicações: unicast para um destino, broadcast para todos na LAN."
                                  ],
                                  "verification": "Classifique corretamente 5 endereços MAC de teste como unicast, multicast ou broadcast.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta online de validador MAC (macvendorlookup.com)",
                                    "Tabela de bits binários para primeiros bytes"
                                  ],
                                  "tips": "Foquem no bit 0 do primeiro octet: se par (hex even), unicast; ímpar, multicast.",
                                  "learningObjective": "Distinguir e justificar o tipo de um endereço MAC baseado no bit LSB do primeiro byte.",
                                  "commonMistakes": [
                                    "Confundir multicast com broadcast",
                                    "Ignorar endereço de grupo IPv6 (33:33:xx:xx:xx:xx)",
                                    "Ler bits na ordem errada (MSB vs LSB)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Localizar e interpretar endereços MAC no frame Ethernet",
                                  "subSteps": [
                                    "Revise a estrutura do frame 802.3: campos Destination MAC (6 bytes), Source MAC (6 bytes), após preamble/SFD.",
                                    "Identifique posições: bytes 1-6 destino, 7-12 origem.",
                                    "Analise um frame capturado: decode destino (broadcast?) e source (unicast?).",
                                    "Compare OUI de source e destino para rastrear fabricantes.",
                                    "Pratique com Wireshark: filtre frames e anote MACs."
                                  ],
                                  "verification": "Em um frame Ethernet dado, identifique e interprete corretamente os campos MAC source e destination.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark ou captura de frame exemplo",
                                    "Diagrama do frame Ethernet (RFC 1042 ou similar)"
                                  ],
                                  "tips": "Use Wireshark 'expand' para ver hex cru; combine com conhecimento de tipos MAC.",
                                  "learningObjective": "Mapear endereços MAC dentro da estrutura do frame Ethernet e analisá-los no contexto.",
                                  "commonMistakes": [
                                    "Confundir source com destination",
                                    "Não notar padding ou FCS afetando offsets",
                                    "Ignorar frames VLAN-tagged (802.1Q)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender o uso de tabelas CAM por switches para encaminhamento",
                                  "subSteps": [
                                    "Aprenda que CAM (Content Addressable Memory) armazena mapeamento MAC-porta.",
                                    "Descreva aprendizado: switch aprende source MAC e associa à porta de entrada.",
                                    "Explique encaminhamento: unicast para porta exata; broadcast/multicast para todas exceto origem (flooding inicial).",
                                    "Simule aging: entradas expiram após ~300s de inatividade.",
                                    "Pratique: trace um frame através de switch com tabela CAM exemplo."
                                  ],
                                  "verification": "Desenhe uma tabela CAM para 3 frames e simule encaminhamento correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de rede como Packet Tracer",
                                    "Exemplos de tabelas CAM de switches Cisco"
                                  ],
                                  "tips": "Lembre: switches L2 usam MAC puro, sem IP; CAM é hardware-accelerated.",
                                  "learningObjective": "Explicar como switches utilizam tabelas CAM para decisões de forwarding baseadas em MAC.",
                                  "commonMistakes": [
                                    "Confundir CAM com ARP (que é IP-MAC)",
                                    "Pensar que switches flood todos os frames",
                                    "Ignorar loop prevention via STP"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Wireshark, capture um ping broadcast (ex: Destination MAC FF:FF:FF:FF:FF:FF, Source 00:50:56:C0:00:01). Identifique: broadcast (todos 1s), OUI source (00:50:56 VMware), unicast source. Simule switch: aprende source na porta 1, flooda para portas 2-4.",
                              "finalVerifications": [
                                "Decodifica qualquer MAC de 12 hex em OUI, NIC e tipo (unicast/multicast/broadcast).",
                                "Localiza MAC source/destination em um frame Ethernet hex dump.",
                                "Explica tabela CAM: como aprende e encaminha um frame unicast.",
                                "Identifica erros comuns em exemplos reais de captura.",
                                "Simula forwarding em switch com 4 portas e 3 MACs conhecidos.",
                                "Diferencia impactos de broadcast vs unicast em rede."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação de estrutura MAC (100% correto em 5 exemplos).",
                                "Correta classificação de tipos MAC baseado em bit LSB.",
                                "Interpretação contextual no frame Ethernet sem erros de posição.",
                                "Descrição completa do ciclo CAM (aprendizado, lookup, aging).",
                                "Aplicação prática em cenários de troubleshooting.",
                                "Uso correto de ferramentas como Wireshark para verificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão entre hexadecimal, binário e decimal para análise de bits.",
                                "Segurança da Informação: Detecção de MAC spoofing em ataques ARP poisoning.",
                                "Física: Propagação de sinais elétricos em cabos Ethernet afetando frames.",
                                "Programação: Uso de bibliotecas como Scapy (Python) para parse de MACs.",
                                "Estatística: Análise de tráfego para detecção de broadcast storms."
                              ],
                              "realWorldApplication": "Em administração de redes, interprete MACs em logs de switches para troubleshooting de conectividade, detectar dispositivos rogue via OUI desconhecido, otimizar tráfego evitando floods desnecessários, e investigar incidentes de segurança como MAC flooding attacks."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.4",
                        "name": "Evolução e Velocidades Ethernet",
                        "description": "A Ethernet evoluiu de 10 Mbps (1980s) para Fast Ethernet (100 Mbps), Gigabit (1 Gbps), 10G, 40G e além, com suporte full-duplex e sem CSMA/CD em switches modernos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.4.1",
                            "name": "Listar variantes de velocidade Ethernet",
                            "description": "Classificar padrões como 10BASE-T, 100BASE-TX, 1000BASE-T, 10GBASE-T, 40GBASE-SR4, destacando codificações PAM-5, 64B/66B e distâncias máximas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a nomenclatura das variantes Ethernet",
                                  "subSteps": [
                                    "Estude o formato padrão: velocidade (ex: 10, 100, 1000), tipo de sinal (BASE para banda base), meio de transmissão (T para par trançado, SX para fibra multimodo).",
                                    "Identifique componentes: BASE-T (par trançado), BASE-SX (fibra curta), SR4 (fibra multimodo paralela).",
                                    "Revise exemplos iniciais: 10BASE-T (10 Mbps, Cat3/5, 100m), 100BASE-TX (100 Mbps, Cat5, 100m).",
                                    "Crie um diagrama simples da estrutura do nome.",
                                    "Compare com padrões não-Ethernet para contrastar."
                                  ],
                                  "verification": "Crie uma tabela com 3 exemplos de nomenclatura desmontada corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.3 (páginas introdutórias), papel e caneta para diagrama, navegador para busca rápida."
                                  ],
                                  "tips": "Lembre-se: o número é em Mbps, exceto G para Gigabit.",
                                  "learningObjective": "Compreender e decompor a nomenclatura padrão IEEE 802.3 para identificar velocidade, sinal e meio.",
                                  "commonMistakes": "Confundir BASE-T com fibra ou ignorar o sufixo que indica o cabo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e classificar variantes de 10/100 Mbps e Gigabit",
                                  "subSteps": [
                                    "Liste 10BASE-T: 10 Mbps, par trançado Cat3/5, 100m máx., codificação Manchester.",
                                    "Detalhe 100BASE-TX: 100 Mbps, Cat5, 100m, codificação MLT-3/4B/5B.",
                                    "Estude 1000BASE-T: 1 Gbps, Cat5e/6, 100m, PAM-5 codificação.",
                                    "Crie flashcards com velocidade, cabo e distância para cada.",
                                    "Teste-se recitando sem olhar."
                                  ],
                                  "verification": "Recite verbalmente ou escreva as specs de 10BASE-T, 100BASE-TX e 1000BASE-T sem erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Flashcards (app como Anki), tabela comparativa em Excel ou papel."
                                  ],
                                  "tips": "Agrupe por velocidade para facilitar memorização: 10M, 100M, 1G.",
                                  "learningObjective": "Classificar com precisão as variantes Ethernet até 1 Gbps, incluindo cabos e distâncias.",
                                  "commonMistakes": "Confundir distâncias (todas 100m em cobre) ou codificações iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar variantes de alta velocidade: 10G e 40G",
                                  "subSteps": [
                                    "Analise 10GBASE-T: 10 Gbps, Cat6a/7, 100m (30m Cat6), PAM-16, 64B/66B.",
                                    "Estude 40GBASE-SR4: 40 Gbps, fibra OM3/OM4 multimodo, 100-150m, codificação 64B/66B.",
                                    "Compare com 10GBASE-SR: similar mas single lane.",
                                    "Anote diferenças em velocidade, meio e distância.",
                                    "Pesquise uma imagem de cabos/fibras para visualização."
                                  ],
                                  "verification": "Desenhe uma tabela comparando 10GBASE-T e 40GBASE-SR4 com todas as specs.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "IEEE 802.3 spec summaries online, imagens de cabos Ethernet."
                                  ],
                                  "tips": "Foco em 'T' para cobre, 'SR' para fibra curta.",
                                  "learningObjective": "Identificar specs de variantes acima de 1 Gbps, enfatizando meios ópticos vs. elétricos.",
                                  "commonMistakes": "Subestimar distâncias em fibra ou confundir PAM-5 com PAM-16."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar codificações de linha e distâncias máximas",
                                  "subSteps": [
                                    "Liste codificações: Manchester (10M), 4B/5B+MLT-3 (100M), PAM-5 (1G), PAM-16+64B/66B (10G+).",
                                    "Registre distâncias: 100m cobre até 10G (limitado), 100-400m fibra multimodo.",
                                    "Crie um mapa mental ligando velocidade > codificação > distância.",
                                    "Compare eficiência: 64B/66B para altas velocidades reduz overhead.",
                                    "Teste com quiz: associe codificação à velocidade."
                                  ],
                                  "verification": "Responda a 5 perguntas de associação correta (ex: 1000BASE-T -> PAM-5).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Mapa mental tool (MindMeister ou papel), quiz online criado por você."
                                  ],
                                  "tips": "64B/66B é padrão pós-10G para eficiência.",
                                  "learningObjective": "Associar codificações específicas (PAM-5, 64B/66B) às variantes e suas distâncias máximas.",
                                  "commonMistakes": "Misturar PAM-5 (Gigabit) com 64B/66B (10G+)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e praticar listagem completa",
                                  "subSteps": [
                                    "Compile lista completa: 10BASE-T, 100BASE-TX, 1000BASE-T, 10GBASE-T, 40GBASE-SR4.",
                                    "Para cada, anote velocidade, codificação, distância máx. e cabo.",
                                    "Crie uma tabela final com colunas: Variante | Veloc. | Codif. | Dist. | Cabo.",
                                    "Simule uma apresentação explicando evolução.",
                                    "Revise erros anteriores."
                                  ],
                                  "verification": "Gere tabela completa sem consultar notas e autoavalie precisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou documento para tabela final."
                                  ],
                                  "tips": "Evolução: mais velocidade requer melhores cabos/codificações.",
                                  "learningObjective": "Listar e classificar todas as variantes com destaques em codificações e distâncias.",
                                  "commonMistakes": "Omitir 40GBASE-SR4 ou distâncias específicas de fibra."
                                }
                              ],
                              "practicalExample": "Crie uma tabela em uma planilha comparando as 5 variantes: colunas para nome, velocidade, codificação (ex: PAM-5 para 1000BASE-T), distância máxima (100m para 10GBASE-T em Cat6a) e tipo de cabo. Use para planejar upgrade de rede local de 1G para 10G.",
                              "finalVerifications": [
                                "Pode listar as 5 variantes principais sem hesitação.",
                                "Associa corretamente codificações: PAM-5 a 1000BASE-T, 64B/66B a 10G+.",
                                "Recita distâncias máximas para cobre e fibra.",
                                "Explica nomenclatura de pelo menos 3 variantes.",
                                "Identifica evolução de Manchester para 64B/66B.",
                                "Cria tabela comparativa precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem de variantes e specs (90%+ correto).",
                                "Compreensão de codificações PAM-5 e 64B/66B.",
                                "Correta associação de distâncias por meio (cobre vs. fibra).",
                                "Clareza na explicação oral ou escrita da nomenclatura.",
                                "Capacidade de criar tabela comparativa acionável.",
                                "Identificação de limitações práticas (ex: Cat6a para 10G)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais e atenuação em cabos/fibras.",
                                "Matemática: Codificações binárias (64B/66B) e modularidade PAM.",
                                "Engenharia: Design de hardware para interfaces Ethernet.",
                                "História da Tecnologia: Evolução IEEE 802.3 desde 1980s."
                              ],
                              "realWorldApplication": "Em administração de redes empresariais, escolher o cabo certo (ex: Cat6a para 10GBASE-T em 100m) evita gargalos em data centers ou escritórios, otimizando custos em upgrades de LAN para suportar streaming 4K ou virtualização."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.4.2",
                            "name": "Comparar half-duplex e full-duplex",
                            "description": "Explicar transição para full-duplex sem CSMA/CD, usando pares dedicados bidirecionais em switches, eliminando colisões e dobrando throughput efetivo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o modo half-duplex em Ethernet",
                                  "subSteps": [
                                    "Defina half-duplex como comunicação unidirecional em um único par de fios, alternando envio e recepção.",
                                    "Explique o uso de CSMA/CD (Carrier Sense Multiple Access with Collision Detection) para detectar e resolver colisões.",
                                    "Descreva o impacto das colisões: perda de pacotes, retransmissões e redução de throughput efetivo.",
                                    "Identifique hardware típico: hubs ou repetidores que compartilham o meio.",
                                    "Calcule um exemplo simples: em 10 Mbps half-duplex, throughput efetivo cai para ~4-5 Mbps devido a colisões."
                                  ],
                                  "verification": "Desenhe um diagrama de rede half-duplex com hub e anote o fluxo de dados com colisão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Acesso a diagramas Ethernet online (ex: Wikipedia IEEE 802.3)"
                                  ],
                                  "tips": "Visualize como uma conversa onde só uma pessoa fala por vez; interrupções causam confusão.",
                                  "learningObjective": "Compreender as limitações fundamentais do half-duplex e o papel do CSMA/CD.",
                                  "commonMistakes": [
                                    "Confundir half-duplex com simplex (unidirecional permanente)",
                                    "Ignorar que CSMA/CD só funciona em half-duplex"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o modo full-duplex em Ethernet",
                                  "subSteps": [
                                    "Defina full-duplex como comunicação simultânea bidirecional usando pares de fios dedicados (um para TX, outro para RX).",
                                    "Explique a eliminação do CSMA/CD, pois não há compartilhamento de meio.",
                                    "Descreva hardware necessário: switches com portas full-duplex e cabos com múltiplos pares (ex: Cat5).",
                                    "Calcule throughput: em 10 Mbps full-duplex, efetivo é ~20 Mbps (10 Mbps cada direção).",
                                    "Liste velocidades suportadas: 10/100/1000 Mbps e além, todas full-duplex em switches modernos."
                                  ],
                                  "verification": "Crie um diagrama mostrando pares TX/RX separados em um link full-duplex.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Vídeo tutorial sobre switches Ethernet (ex: YouTube: 'Full Duplex Ethernet')"
                                  ],
                                  "tips": "Pense em uma ligação telefônica full-duplex: ambos falam e ouvem ao mesmo tempo sem interferência.",
                                  "learningObjective": "Dominar como full-duplex remove colisões e dobra o throughput.",
                                  "commonMistakes": [
                                    "Achar que full-duplex usa o mesmo par para ambos sentidos",
                                    "Confundir switches com hubs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar half-duplex e full-duplex",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para modo, direção, CSMA/CD, colisões, throughput, hardware.",
                                    "Compare eficiência: half-duplex ~30-50% utilidade vs full-duplex ~90-100%.",
                                    "Discuta latência: half-duplex tem atrasos por backoff em colisões; full-duplex não.",
                                    "Analise custos: half-duplex mais barato inicialmente, mas ineficiente para tráfego alto.",
                                    "Resuma vantagens full-duplex: sem colisões, maior velocidade, suporte a aplicações reais."
                                  ],
                                  "verification": "Preencha e explique uma tabela de comparação oralmente ou por escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Referência: RFC 802.3 ou livro de redes (Tanenbaum)"
                                  ],
                                  "tips": "Use setas bidirecionais para full-duplex e unidirecional para half-duplex nos diagramas.",
                                  "learningObjective": "Identificar diferenças chave e trade-offs entre os modos.",
                                  "commonMistakes": [
                                    "Subestimar impacto de colisões no throughput half-duplex",
                                    "Ignorar necessidade de cabos adequados para full-duplex"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar transição para full-duplex e impactos",
                                  "subSteps": [
                                    "Descreva a evolução: hubs half-duplex → switches full-duplex nos anos 90.",
                                    "Explique configuração: auto-negociação IEEE 802.3u para detectar full-duplex.",
                                    "Calcule ganho: migração de 100 Mbps half para full dobra para 200 Mbps efetivos.",
                                    "Discuta limitações remanescentes: duplex mismatch causa problemas de performance.",
                                    "Simule cenário: teste ping em rede simulada (Packet Tracer) half vs full."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que switches eliminaram CSMA/CD.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cisco Packet Tracer ou GNS3 para simulação gratuita",
                                    "Documentação IEEE 802.3ab"
                                  ],
                                  "tips": "Sempre verifique LEDs de portas de switch para confirmar full-duplex.",
                                  "learningObjective": "Compreender razões históricas e técnicas da adoção do full-duplex.",
                                  "commonMistakes": [
                                    "Achar que full-duplex é padrão em todas as redes antigas",
                                    "Confundir auto-negociação com configuração manual"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma LAN com 4 PCs conectados a um hub (half-duplex 100 Mbps), transferências simultâneas causam colisões constantes, limitando throughput a ~40 Mbps. Substituindo por switch full-duplex, cada par TX/RX dedicado permite 200 Mbps efetivos por link, sem colisões, ideal para compartilhamento de arquivos simultâneo.",
                              "finalVerifications": [
                                "Explicar verbalmente CSMA/CD e por que é desnecessário em full-duplex.",
                                "Desenhar diagramas precisos de cabos e fluxos para ambos modos.",
                                "Calcular throughput efetivo em cenários half vs full para 1 Gbps.",
                                "Identificar duplex mismatch em logs de switch.",
                                "Comparar em tabela: 5 diferenças chave.",
                                "Simular em ferramenta como Wireshark tráfego half vs full."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e distinção entre half e full-duplex (80%+ correto).",
                                "Correta representação de CSMA/CD e ausência em full-duplex.",
                                "Cálculos de throughput exatos com exemplos numéricos.",
                                "Diagramas claros mostrando pares dedicados vs compartilhados.",
                                "Explicação coerente da transição histórica e benefícios.",
                                "Identificação de erros comuns como duplex mismatch."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais e interferência em meios compartilhados.",
                                "Matemática: Cálculo de eficiência e probabilidade de colisões (modelo slotted ALOHA).",
                                "Eletrônica: Circuitos de PHY layer em transceptores Ethernet.",
                                "História da Tecnologia: Evolução de redes LAN nos anos 90."
                              ],
                              "realWorldApplication": "Em data centers e escritórios modernos, switches full-duplex em 10/40/100 Gbps suportam tráfego intenso como videochamadas, cloud storage e IoT sem colisões, maximizando banda disponível e reduzindo latência para aplicações críticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.4.3",
                            "name": "Discutir Ethernet moderna em data centers",
                            "description": "Descrever 25G/100G Ethernet com RDMA over Converged Ethernet (RoCE) e suporte a SDN, referenciando evoluções em IEEE 802.3bs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a evolução do Ethernet até velocidades de 10G e introdução ao IEEE 802.3bs",
                                  "subSteps": [
                                    "Pesquise a linha do tempo do Ethernet desde 1G até 10G, focando em padrões IEEE 802.3.",
                                    "Identifique limitações de velocidade em data centers com Ethernet 10G.",
                                    "Leia o resumo do padrão IEEE 802.3bs, que define 25G e 100G Ethernet.",
                                    "Compare métricas chave: latência, throughput e consumo de energia entre gerações.",
                                    "Anote as motivações para velocidades acima de 10G em ambientes de data center."
                                  ],
                                  "verification": "Crie um diagrama cronológico da evolução do Ethernet com destaques para IEEE 802.3bs.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentação IEEE 802.3bs (disponível online)",
                                    "Artigos sobre história do Ethernet",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use fontes oficiais IEEE para precisão; foque em como data centers impulsionaram essas evoluções.",
                                  "learningObjective": "Compreender o contexto histórico e técnico que levou ao Ethernet 25G/100G.",
                                  "commonMistakes": "Confundir IEEE 802.3bs com outros padrões como 400G; ignorar impactos em data centers."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar especificações técnicas de 25G/100G Ethernet",
                                  "subSteps": [
                                    "Analise os modos de codificação PAM-4 usados em 25G/100G.",
                                    "Estude requisitos de fibra óptica e cabos DAC para essas velocidades.",
                                    "Calcule throughput efetivo considerando overheads de protocolo.",
                                    "Examine forward error correction (FEC) e suas implicações em latência.",
                                    "Compare backplanes e transceptores para switches de data center."
                                  ],
                                  "verification": "Liste 5 especificações chave de 25G/100G e explique seu impacto em data centers.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Especificações técnicas IEEE 802.3bs PDF",
                                    "Whitepapers de vendors como Cisco/Mellanox",
                                    "Calculadora de throughput online"
                                  ],
                                  "tips": "Visualize com diagramas de sinal; teste cálculos com exemplos reais de data centers.",
                                  "learningObjective": "Dominar as características técnicas do Ethernet 25G/100G conforme IEEE 802.3bs.",
                                  "commonMistakes": "Subestimar overheads de FEC; confundir velocidades de porta com throughput agregado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar RDMA over Converged Ethernet (RoCE) em Ethernet moderna",
                                  "subSteps": [
                                    "Defina RDMA e suas vantagens sobre TCP/IP tradicional.",
                                    "Estude RoCEv1 e RoCEv2, focando em suporte a Ethernet lossy/lossless.",
                                    "Analise como 25G/100G habilita RoCE em data centers para baixa latência.",
                                    "Revise Priority Flow Control (PFC) e Explicit Congestion Notification (ECN) para RoCE.",
                                    "Simule um fluxo de dados RoCE em um cenário de data center."
                                  ],
                                  "verification": "Descreva um cenário onde RoCE supera RDMA over InfiniBand em custo.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Documentação RoCE de Mellanox/NVIDIA",
                                    "RFCs relacionadas a RoCE",
                                    "Simulador de rede como Mininet"
                                  ],
                                  "tips": "Pratique com ferramentas de simulação para ver latência em ação.",
                                  "learningObjective": "Entender como RoCE integra com Ethernet 25G/100G para aplicações HPC em data centers.",
                                  "commonMistakes": "Ignorar necessidade de redes lossless para RoCE; confundir RoCE com iWARP."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar suporte a SDN em Ethernet moderna de data centers",
                                  "subSteps": [
                                    "Explique SDN e seu papel em orquestração de redes de data center.",
                                    "Estude como switches 25G/100G suportam OpenFlow e VXLAN para SDN.",
                                    "Discuta integração de IEEE 802.3bs com controladores SDN como ONOS.",
                                    "Avalie casos de uso: telemetria, segmentação e auto-configuração.",
                                    "Prepare uma discussão sobre escalabilidade em hyperscale data centers."
                                  ],
                                  "verification": "Crie um fluxograma de como SDN controla tráfego em uma rede 100G Ethernet.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentos Open Networking Foundation",
                                    "Whitepapers SDN de VMware/ Cisco ACI",
                                    "Ferramentas de modelagem SDN"
                                  ],
                                  "tips": "Conecte SDN a RoCE para visão holística; use exemplos de Google Cloud ou AWS.",
                                  "learningObjective": "Integrar SDN com Ethernet moderna para discussões completas sobre data centers.",
                                  "commonMistakes": "Pensar SDN como substituto do hardware; subestimar compatibilidade com Ethernet legado."
                                }
                              ],
                              "practicalExample": "Em um data center de cloud provider, configure uma rede spine-leaf com switches 100G Ethernet suportando RoCE para workloads de IA, usando SDN para roteamento dinâmico de tráfego de machine learning, reduzindo latência de 10ms para 1μs em transferências de dados.",
                              "finalVerifications": [
                                "Explicar com precisão as contribuições do IEEE 802.3bs para 25G/100G.",
                                "Descrever funcionamento de RoCE em Ethernet lossless.",
                                "Discutir 3 benefícios de SDN em data centers 100G.",
                                "Comparar throughput e latência de 10G vs 100G Ethernet.",
                                "Identificar requisitos de hardware para RoCE em 25G.",
                                "Simular uma falha comum em rede RoCE e propor solução SDN."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas referências a IEEE 802.3bs (90%+ correto).",
                                "Profundidade na explicação de RoCE vs Ethernet tradicional.",
                                "Capacidade de conectar SDN a aplicações reais de data center.",
                                "Uso de exemplos quantitativos (latência, throughput).",
                                "Clareza na discussão de evoluções e limitações.",
                                "Integração coerente de todos os conceitos em uma narrativa."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais PAM-4 e óptica em fibras.",
                                "Matemática: Cálculos de throughput, FEC e taxas de erro.",
                                "Engenharia de Software: Protocolos SDN e programação de redes.",
                                "Gestão de TI: Escalabilidade e custo-benefício em data centers."
                              ],
                              "realWorldApplication": "Em hyperscale data centers como os da AWS ou Microsoft Azure, Ethernet 25G/100G com RoCE acelera transferências de dados para treinamento de IA, enquanto SDN otimiza tráfego dinâmico, reduzindo custos operacionais em 30-50% comparado a gerações anteriores."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.4.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Padrão IEEE 802.11 - Wi-Fi",
                    "description": "Padrão para redes locais sem fio, utilizando CSMA/CA e suporte a mobilidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Arquitetura do Padrão IEEE 802.11",
                        "description": "Componentes e topologias básicas das redes Wi-Fi, incluindo estações (STA), pontos de acesso (AP), Basic Service Set (BSS) e Extended Service Set (ESS).",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar componentes da arquitetura Wi-Fi",
                            "description": "Diferenciar estações (STA), pontos de acesso (AP), modos ad-hoc e infraestrutura, descrevendo funções de cada um no padrão IEEE 802.11.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de Estação (STA)",
                                  "subSteps": [
                                    "Leia a definição de STA no padrão IEEE 802.11: dispositivo que se conecta à rede Wi-Fi.",
                                    "Identifique exemplos comuns de STA: smartphones, laptops, tablets.",
                                    "Descreva as funções principais: transmitir e receber frames de dados, autenticação e associação.",
                                    "Anote as limitações: STAs não podem conectar outras STAs diretamente em modo infraestrutura.",
                                    "Crie um diagrama simples mostrando uma STA conectada a um AP."
                                  ],
                                  "verification": "Verifique se você pode listar 3 exemplos de STA e descrever sua função principal em uma frase.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.11 (seção de arquitetura)",
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Foquem em STA como 'clientes' da rede; memorize que elas iniciam conexões.",
                                  "learningObjective": "Diferenciar STA de outros componentes e listar suas funções básicas.",
                                  "commonMistakes": [
                                    "Confundir STA com AP",
                                    "Achar que STA gerencia a rede"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Pontos de Acesso (AP)",
                                  "subSteps": [
                                    "Estude a definição de AP: dispositivo central que gerencia a rede Wi-Fi.",
                                    "Liste funções: fornecer conectividade, gerenciar tráfego BSS, ponte para rede cabeada.",
                                    "Identifique exemplos: roteadores Wi-Fi domésticos, access points empresariais.",
                                    "Compare AP com STA: AP é o 'hub' que STAs se conectam.",
                                    "Desenhe um diagrama de AP conectando múltiplas STAs."
                                  ],
                                  "verification": "Crie uma lista de 4 funções do AP e valide com referência IEEE.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referência IEEE 802.11",
                                    "Vídeo tutorial sobre AP (ex: YouTube Cisco basics)"
                                  ],
                                  "tips": "Pense no AP como o 'maestro' da orquestra Wi-Fi.",
                                  "learningObjective": "Descrever funções do AP e seu papel na arquitetura Wi-Fi.",
                                  "commonMistakes": [
                                    "Achar que AP é apenas um repetidor",
                                    "Ignorar função de ponte para Ethernet"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Modo Ad-hoc",
                                  "subSteps": [
                                    "Defina modo ad-hoc: rede peer-to-peer sem AP, STAs se comunicam diretamente.",
                                    "Descreva características: IBSS (Independent Basic Service Set), auto-configuração.",
                                    "Liste funções: comunicação direta para cenários temporários como compartilhamento de arquivos.",
                                    "Identifique limitações: sem mobilidade entre BSS, escalabilidade baixa.",
                                    "Simule com dois dispositivos: configure ad-hoc em laptops para teste."
                                  ],
                                  "verification": "Explique em 2 parágrafos as diferenças do ad-hoc vs. infraestrutura.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dois laptops com Wi-Fi",
                                    "Guia de configuração ad-hoc Windows/Linux"
                                  ],
                                  "tips": "Use ad-hoc para redes rápidas sem infraestrutura, como em campo.",
                                  "learningObjective": "Identificar quando e como usar modo ad-hoc no IEEE 802.11.",
                                  "commonMistakes": [
                                    "Confundir ad-hoc com infraestrutura",
                                    "Achar que ad-hoc usa AP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Modo Infraestrutura e Integração",
                                  "subSteps": [
                                    "Defina modo infraestrutura: usa AP para conectar STAs em um BSS.",
                                    "Descreva funções: gerenciamento centralizado, roaming possível, escalável.",
                                    "Compare todos componentes: STA-AP em infra vs. STA-STA em ad-hoc.",
                                    "Revise o padrão IEEE 802.11: arquitetura dividida em STA, AP, ad-hoc, infra.",
                                    "Crie tabela comparativa de todos os componentes."
                                  ],
                                  "verification": "Preencha tabela comparativa e autoavalie precisão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabela",
                                    "Resumo IEEE 802.11"
                                  ],
                                  "tips": "Infraestrutura é o modo padrão para redes modernas.",
                                  "learningObjective": "Integrar conhecimentos para diferenciar todos componentes da arquitetura Wi-Fi.",
                                  "commonMistakes": [
                                    "Misturar funções de ad-hoc e infra",
                                    "Esquecer roaming em infra"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede doméstica, configure um roteador como AP (modo infraestrutura) conectando seu laptop (STA) à internet. Teste modo ad-hoc entre dois laptops para transferir arquivos sem roteador, observando diferenças em conectividade e gerenciamento.",
                              "finalVerifications": [
                                "Liste e descreva STA e AP corretamente.",
                                "Explique diferenças entre modo ad-hoc e infraestrutura.",
                                "Identifique funções de cada componente no IEEE 802.11.",
                                "Crie diagrama preciso da arquitetura Wi-Fi.",
                                "Responda quiz com 90% de acerto sobre componentes.",
                                "Simule rede ad-hoc com sucesso."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de STA e AP (exato match com IEEE).",
                                "Clareza na distinção entre modos ad-hoc e infraestrutura.",
                                "Completude das funções descritas para cada componente.",
                                "Qualidade dos diagramas e tabelas comparativas.",
                                "Capacidade de aplicar em exemplo prático.",
                                "Identificação correta de limitações e usos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Ondas eletromagnéticas usadas em Wi-Fi (frequências 2.4/5GHz).",
                                "Matemática: Topologias de rede e grafos para modelar BSS/IBSS.",
                                "Engenharia: Design de hardware para AP e STA.",
                                "Segurança: Autenticação em STA-AP (WPA3 no IEEE 802.11)."
                              ],
                              "realWorldApplication": "Em empresas, APs em modo infraestrutura gerenciam centenas de STAs (funcionários' dispositivos); em eventos, modo ad-hoc permite redes temporárias para compartilhamento rápido de dados sem infraestrutura fixa."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Descrever topologias BSS e ESS",
                            "description": "Explicar Basic Service Set (BSS) como conjunto básico de estações coordenadas por um AP, e Extended Service Set (ESS) como múltiplos BSS interconectados para maior cobertura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Arquitetura IEEE 802.11",
                                  "subSteps": [
                                    "Pesquise o padrão IEEE 802.11 e sua arquitetura geral.",
                                    "Identifique os componentes principais: estações (STAs), Access Points (APs) e Service Set Identifier (SSID).",
                                    "Estude o conceito de 'service set' como grupo de dispositivos que se comunicam.",
                                    "Anote definições chave de BSS e ESS de fontes confiáveis como RFCs ou documentação oficial.",
                                    "Crie um glossário pessoal com termos relacionados."
                                  ],
                                  "verification": "Liste corretamente os componentes principais e defina 'service set' em suas próprias palavras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Computador com acesso à internet, documentação IEEE 802.11 (PDFs gratuitos), bloco de notas.",
                                  "tips": "Use diagramas visuais para mapear componentes desde o início.",
                                  "learningObjective": "Entender a base conceitual da arquitetura Wi-Fi para contextualizar BSS e ESS.",
                                  "commonMistakes": "Confundir AP com roteador comum; lembre-se que AP é específico do 802.11."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Topologia Basic Service Set (BSS)",
                                  "subSteps": [
                                    "Defina BSS como um conjunto básico de estações coordenadas por um único AP.",
                                    "Descreva os tipos: Infrastructure BSS (com AP) e Independent BSS (IBSS, ad-hoc sem AP).",
                                    "Explique o papel do AP na coordenação via beacons e associação.",
                                    "Desenhe um diagrama simples de um BSS infrastructure.",
                                    "Simule uma comunicação básica entre STAs via AP."
                                  ],
                                  "verification": "Desenhe e rotule um diagrama BSS correto, explicando o fluxo de dados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de desenho (Draw.io ou papel), simulador Wireshark para captura de beacons.",
                                  "tips": "Foquem em beacons como 'anúncios' do AP para STAs se conectarem.",
                                  "learningObjective": "Descrever precisamente a estrutura, componentes e operação de um BSS.",
                                  "commonMistakes": "Ignorar IBSS; sempre mencione ambos os modos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Topologia Extended Service Set (ESS)",
                                  "subSteps": [
                                    "Defina ESS como múltiplos BSS interconectados via uma backbone distribuída (ex: Ethernet).",
                                    "Explique o Distribution System (DS) que conecta APs.",
                                    "Descreva mobilidade: roaming seamless entre BSSs no mesmo ESS via mesmo SSID.",
                                    "Desenhe um diagrama de ESS com 3 BSSs conectados.",
                                    "Compare cobertura: BSS para área pequena, ESS para grande escala."
                                  ],
                                  "verification": "Crie um diagrama ESS e explique roaming em 2 frases.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de desenho, exemplos de redes empresariais (imagens online).",
                                  "tips": "Pense em ESS como 'rede Wi-Fi grande' como em shoppings ou escritórios.",
                                  "learningObjective": "Dominar a estrutura e benefícios de ESS para expansão de cobertura.",
                                  "commonMistakes": "Confundir DS com internet; DS é interno ao ESS."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar BSS e ESS e Aplicar Conhecimento",
                                  "subSteps": [
                                    "Liste similaridades: ambos usam SSID, beacons e associação.",
                                    "Liste diferenças: BSS (único AP, cobertura limitada), ESS (múltiplos APs, roaming).",
                                    "Crie uma tabela comparativa.",
                                    "Descreva cenários: BSS para casa, ESS para campus.",
                                    "Teste conhecimento respondendo perguntas de autoavaliação."
                                  ],
                                  "verification": "Preencha tabela comparativa sem erros e responda 5 perguntas corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou tabela em documento, quiz online sobre 802.11.",
                                  "tips": "Use mnemônicos: BSS = Básico (simples), ESS = Estendido (grande).",
                                  "learningObjective": "Diferenciar BSS e ESS, aplicando a contextos reais.",
                                  "commonMistakes": "Achar que ESS não permite roaming; é o principal benefício."
                                }
                              ],
                              "practicalExample": "Em uma casa, configure um BSS com um roteador AP conectando laptops e smartphones. Para expandir ao quintal, adicione outro AP conectado via cabo Ethernet, formando um ESS com o mesmo SSID, permitindo que um smartphone mova-se sem desconectar.",
                              "finalVerifications": [
                                "Explicar BSS e ESS em 1 minuto sem consultar notas.",
                                "Desenhar diagramas precisos de BSS e ESS sob tempo limite.",
                                "Identificar BSS vs ESS em diagramas dados.",
                                "Descrever roaming em ESS corretamente.",
                                "Listar 3 vantagens de ESS sobre BSS.",
                                "Responder quiz com 90% de acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de BSS e ESS (exato vs genérico).",
                                "Clareza em diagramas e rótulos (completo vs parcial).",
                                "Compreensão de componentes (AP, DS, SSID identificados corretamente).",
                                "Explicação de roaming e coordenação (detalhada vs superficial).",
                                "Aplicação contextual (exemplos reais vs abstratos).",
                                "Ausência de erros comuns (sem confusões entre BSS/ESS)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas de rádio e limitações de cobertura BSS.",
                                "Matemática: Modelos de grafos para topologias de rede (nós STAs/APs).",
                                "Administração: Planejamento de redes empresariais com ESS para eficiência.",
                                "Segurança da Informação: Autenticação em BSS/ESS via 802.1X."
                              ],
                              "realWorldApplication": "Em redes Wi-Fi corporativas, ESS permite cobertura contínua em prédios grandes, suportando milhares de dispositivos móveis sem interrupções, como em aeroportos ou universidades, otimizando produtividade e experiência do usuário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Explicar associação de estações",
                            "description": "Detalhar o processo de scanning, autenticação e associação de uma STA a um AP, incluindo beacons e probes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes básicos da arquitetura IEEE 802.11",
                                  "subSteps": [
                                    "Defina Station (STA) como qualquer dispositivo sem fio que se conecta à rede, como laptops ou smartphones.",
                                    "Descreva Access Point (AP) como o ponto central que gerencia conexões e beacons.",
                                    "Explique beacons como frames periódicos enviados pelo AP contendo SSID, capacidades e timestamp.",
                                    "Descreva probes como frames enviados por STAs para descobrir APs disponíveis.",
                                    "Diferencie scanning passivo (escutando beacons) de scanning ativo (enviando probes)."
                                  ],
                                  "verification": "Liste corretamente os papéis de STA, AP, beacons e probes em um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação IEEE 802.11 (seção 8), diagrama de rede Wi-Fi impresso ou digital.",
                                  "tips": "Use analogias: AP como um farol (beacon) guiando navios (STAs).",
                                  "learningObjective": "Identificar e descrever os componentes fundamentais envolvidos na associação.",
                                  "commonMistakes": "Confundir STA com AP ou achar que probes são exclusivos de scanning ativo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o processo de scanning",
                                  "subSteps": [
                                    "Descreva scanning passivo: STA escuta beacons em canais pré-definidos para coletar SSIDs e métricas.",
                                    "Detalhe scanning ativo: STA envia probe requests e recebe probe responses dos APs.",
                                    "Explique seleção de AP: STA escolhe baseado em sinal RSSI, segurança e carga.",
                                    "Liste parâmetros nos beacons/probes: SSID, supported rates, channel info.",
                                    "Simule o fluxo com um cronograma de frames trocados."
                                  ],
                                  "verification": "Desenhe uma sequência de frames para scanning passivo e ativo usando uma ferramenta como draw.io.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de captura de pacotes como Wireshark, tutorial de scanning Wi-Fi.",
                                  "tips": "Capture tráfego real em sua rede Wi-Fi para ver beacons ao vivo.",
                                  "learningObjective": "Compreender como STAs descobrem APs disponíveis via scanning.",
                                  "commonMistakes": "Ignorar que scanning passivo economiza bateria comparado ao ativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar o processo de autenticação",
                                  "subSteps": [
                                    "Explique autenticação aberta (open system): simples troca de autenticação request/response.",
                                    "Descreva autenticação compartilhada (legacy): usa desafio-resposta com WEP (obsoleto).",
                                    "Mencione transição para autenticação robusta via WPA2/3 com 4-way handshake (pós-associação).",
                                    "Liste frames: Authentication Request do STA, Response do AP.",
                                    "Verifique status codes nos frames de resposta."
                                  ],
                                  "verification": "Identifique frames de autenticação em um trace Wireshark fornecido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Trace Wireshark de uma conexão Wi-Fi real, especificação IEEE 802.11i.",
                                  "tips": "Lembre-se: autenticação inicial é fraca; segurança real vem depois.",
                                  "learningObjective": "Diferenciar tipos de autenticação e seu papel na associação.",
                                  "commonMistakes": "Confundir autenticação com autorização ou achar que WPA é parte da autenticação inicial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o processo de associação",
                                  "subSteps": [
                                    "Descreva Association Request: STA envia capabilities, rates suportadas e SSID.",
                                    "Detalhe Association Response: AP aprova/rejeita com status code e AID (Association ID).",
                                    "Explique Reassociation para handover entre APs.",
                                    "Liste elementos no request/response: listen interval, QoS info.",
                                    "Conclua o processo: após associação, DHCP e dados fluem."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre autenticação e associação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama de sequência UML para associação, Wireshark.",
                                  "tips": "Associação é como 'pedir uma mesa no restaurante' após 'mostrar ID na porta'.",
                                  "learningObjective": "Mapear o fluxo completo de frames na associação STA-AP.",
                                  "commonMistakes": "Pensar que associação inclui criptografia de dados (vem depois)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar scanning, autenticação e associação em um fluxo completo",
                                  "subSteps": [
                                    "Monte o fluxo: Scanning → Autenticação → Associação → 4-way handshake (opcional).",
                                    "Discuta timeouts e retries em cada fase.",
                                    "Analise cenários de falha: sinal fraco, autenticação rejeitada.",
                                    "Compare com conexões modernas (WPA3).",
                                    "Crie um fluxograma completo."
                                  ],
                                  "verification": "Crie e apresente um fluxograma do processo inteiro sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de fluxograma (Lucidchart ou papel), traces Wireshark.",
                                  "tips": "Use cores para diferenciar tipos de frames (beacon=azul, probe=verde).",
                                  "learningObjective": "Sintetizar o processo de associação end-to-end.",
                                  "commonMistakes": "Omitir probes em scanning ou inverter ordem autenticação-associação."
                                }
                              ],
                              "practicalExample": "Simule uma STA (seu smartphone) conectando a um AP doméstico: capture com Wireshark o scanning (probes/beacons), autenticação aberta e associação. Identifique SSID, RSSI e AID nos frames, reproduzindo uma conexão em um café público.",
                              "finalVerifications": [
                                "Descreva corretamente a sequência: scanning → autenticação → associação.",
                                "Identifique beacons e probes em um trace Wireshark.",
                                "Explique o propósito de cada frame na associação.",
                                "Diferencie scanning passivo de ativo com prós/contras.",
                                "Liste 3 status codes comuns em responses.",
                                "Crie um diagrama de fluxo sem lacunas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de frames e parâmetros (80% correto).",
                                "Compreensão da ordem lógica dos processos.",
                                "Uso correto de terminologia IEEE 802.11.",
                                "Capacidade de analisar traces reais.",
                                "Identificação de erros comuns e soluções.",
                                "Clareza em diagramas e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas de rádio e RSSI (força de sinal).",
                                "Segurança da Informação: Autenticação e chaves WPA.",
                                "Matemática: Probabilidades em CSMA/CA durante descoberta.",
                                "Engenharia de Software: Estados de máquina em protocolos de rede."
                              ],
                              "realWorldApplication": "Em redes empresariais, entender associação otimiza roaming em WLANs de grandes áreas como aeroportos, permitindo handovers seamless em smartphones e IoT devices sem perda de conexão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Mecanismo CSMA/CA no IEEE 802.11",
                        "description": "Protocolo de controle de acesso ao meio baseado em Carrier Sense Multiple Access with Collision Avoidance, adaptado para redes sem fio.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Comparar CSMA/CA com CSMA/CD",
                            "description": "Explicar por que o IEEE 802.11 usa CSMA/CA em vez de CSMA/CD, destacando a impossibilidade de detecção de colisões em ambientes sem fio devido ao problema de estação oculta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o funcionamento do CSMA/CD em redes cabeadas",
                                  "subSteps": [
                                    "Pesquise o que significa CSMA/CD: Carrier Sense Multiple Access with Collision Detection.",
                                    "Estude como uma estação verifica se o meio está livre antes de transmitir (Carrier Sense).",
                                    "Aprenda o processo de detecção de colisão: se duas estações transmitem simultaneamente, detectam o sinal distorcido e param.",
                                    "Analise o algoritmo de backoff exponencial para retransmissão após colisão.",
                                    "Visualize um diagrama de Ethernet 802.3 usando CSMA/CD."
                                  ],
                                  "verification": "Desenhe um fluxograma simples do processo CSMA/CD e explique verbalmente para si mesmo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Vídeos tutoriais sobre Ethernet (YouTube/Khan Academy)",
                                    "Diagrama de CSMA/CD impresso ou digital",
                                    "Papel e caneta para fluxograma"
                                  ],
                                  "tips": "Foquem em como a detecção de colisão é possível em cabo devido à transmissão full-duplex e sinal forte.",
                                  "learningObjective": "Compreender os princípios básicos do CSMA/CD e seu uso em redes Ethernet cabeadas.",
                                  "commonMistakes": [
                                    "Confundir CSMA com CSMA/CD",
                                    "Ignorar o backoff exponencial",
                                    "Achar que CD funciona em wireless"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o CSMA/CA em redes sem fio IEEE 802.11",
                                  "subSteps": [
                                    "Defina CSMA/CA: Carrier Sense Multiple Access with Collision Avoidance.",
                                    "Estude o RTS/CTS (Request to Send/Clear to Send) para reserva de canal.",
                                    "Aprenda o mecanismo de backoff: espera aleatória antes de transmitir para evitar colisões.",
                                    "Entenda o uso de ACK (Acknowledgment) para confirmar recepção bem-sucedida.",
                                    "Compare brevemente com CSMA/CD: foco em prevenção em vez de detecção."
                                  ],
                                  "verification": "Liste 4 componentes chave do CSMA/CA e descreva seu papel em uma tabela.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.11 (resumo online)",
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Vídeo sobre WiFi MAC layer"
                                  ],
                                  "tips": "Lembre-se: CA evita colisões proativamente, pois detecção é difícil em wireless.",
                                  "learningObjective": "Dominar os mecanismos de prevenção de colisões no CSMA/CA do WiFi.",
                                  "commonMistakes": [
                                    "Confundir avoidance com detection",
                                    "Subestimar RTS/CTS",
                                    "Ignorar ACKs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o problema da estação oculta e impossibilidade de CSMA/CD em wireless",
                                  "subSteps": [
                                    "Defina o problema da estação oculta: duas estações não se 'veem' mutuamente, mas ambas acessam o AP.",
                                    "Explique por que detecção de colisão falha: sinal fraco do transmissor distante não é detectável localmente.",
                                    "Simule o cenário: Estação A transmite para AP enquanto B inicia transmissão sem detectar A.",
                                    "Discuta captura de sinal e problema de exposed node como relacionados.",
                                    "Relacione com atenuação de sinal em RF vs cabo."
                                  ],
                                  "verification": "Crie um diagrama do problema hidden node e explique por que CSMA/CD falha nele.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (Draw.io ou papel)",
                                    "Animações online do hidden node problem",
                                    "Artigo Wireshark sobre WiFi colisões"
                                  ],
                                  "tips": "Use distâncias reais: sinal cai com quadrado da distância em wireless.",
                                  "learningObjective": "Identificar limitações físicas que impedem CSMA/CD em ambientes sem fio.",
                                  "commonMistakes": [
                                    "Confundir hidden com exposed node",
                                    "Achar que potência resolve detecção",
                                    "Ignorar duplex em wireless"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar CSMA/CA vs CSMA/CD e justificar escolha no IEEE 802.11",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: critérios como detecção vs avoidance, uso de RTS/CTS, eficiência em wireless.",
                                    "Explique vantagens do CA: menor overhead em retransmissões, melhor para half-duplex.",
                                    "Discuta desvantagens: CA é menos eficiente em baixa carga que CD.",
                                    "Conclua por que 802.11 usa CA: adaptação a hidden node e características RF.",
                                    "Teste compreensão respondendo perguntas como 'Por que não CSMA/CD no WiFi?'."
                                  ],
                                  "verification": "Preencha e revise uma tabela de comparação com pelo menos 6 diferenças chave.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela",
                                    "Resumo de protocolos MAC",
                                    "Quiz online sobre CSMA"
                                  ],
                                  "tips": "Priorize hidden node como razão principal para CA.",
                                  "learningObjective": "Sintetizar comparação e raciocinar a escolha do IEEE 802.11.",
                                  "commonMistakes": [
                                    "Dizer que CD é sempre melhor",
                                    "Ignorar contexto wireless",
                                    "Confundir protocolos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede WiFi doméstica, configure dois laptops distantes do roteador (simulando hidden nodes). Use Wireshark para capturar pacotes e observe RTS/CTS evitando colisões, contrastando com uma rede Ethernet onde colisões são detectadas diretamente.",
                              "finalVerifications": [
                                "Explicar verbalmente as diferenças principais entre CSMA/CA e CSMA/CD.",
                                "Desenhar diagrama do hidden node problem e solução RTS/CTS.",
                                "Preencher tabela comparativa sem consultar notas.",
                                "Identificar cenários onde CSMA/CD falha em wireless.",
                                "Justificar por que IEEE 802.11 escolheu CSMA/CA.",
                                "Simular backoff em CSMA/CA vs CD."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de mecanismos (detecção vs avoidance).",
                                "Compreensão do hidden node e impacto em CD.",
                                "Tabela comparativa completa e organizada.",
                                "Justificativa técnica para escolha no 802.11.",
                                "Uso correto de termos (RTS/CTS, ACK, backoff).",
                                "Aplicação a cenários reais sem erros conceituais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas RF e atenuação de sinal.",
                                "Matemática: Algoritmos probabilísticos de backoff exponencial.",
                                "Probabilidade: Modelagem de colisões e eficiência de protocolos.",
                                "Engenharia: Design de protocolos para ambientes half-duplex."
                              ],
                              "realWorldApplication": "No WiFi cotidiano (smartphones, IoT), CSMA/CA garante acesso justo ao espectro compartilhado, evitando caos em redes densas como aeroportos ou escritórios, otimizando throughput em cenários com hidden nodes comuns."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Descrever o processo básico de CSMA/CA",
                            "description": "Detalhar as etapas: physical carrier sense, virtual carrier sense via NAV (Network Allocation Vector), backoff exponencial e deferral antes de transmissão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Physical Carrier Sense",
                                  "subSteps": [
                                    "Estude a definição de Physical Carrier Sense como a detecção física do meio via Clear Channel Assessment (CCA).",
                                    "Aprenda que o dispositivo 'escuta' o canal por um período DIFS (Distributed Inter-Frame Space) antes de transmitir.",
                                    "Analise como o CCA mede a energia do sinal: se abaixo do limiar, o canal é considerado livre.",
                                    "Desenhe um diagrama simples mostrando 'listen before talk'.",
                                    "Compare com CSMA/CD para destacar diferenças em redes sem fio."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o processo de CCA e DIFS, confirmando com um diagrama autoexplicativo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de CSMA/CA básico (impresso ou digital)",
                                    "Vídeo tutorial sobre CCA no YouTube (ex: Khan Academy ou Cisco)"
                                  ],
                                  "tips": "Use um temporizador para simular o DIFS de 50μs em escala ampliada (ex: 50 segundos).",
                                  "learningObjective": "Explicar com precisão como o Physical Carrier Sense detecta se o canal está livre.",
                                  "commonMistakes": "Confundir com detecção de colisão pós-transmissão (como no CSMA/CD); lembrar que Wi-Fi não detecta colisões facilmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Virtual Carrier Sense via NAV",
                                  "subSteps": [
                                    "Defina NAV (Network Allocation Vector) como um temporizador virtual baseado em durações anunciadas em frames RTS/CTS/DATA.",
                                    "Estude o cabeçalho MAC com campo Duration para atualizar o NAV em todos os nós que recebem o frame.",
                                    "Simule cenários: um nó atualiza NAV e defere transmissão mesmo se physical sense indicar livre.",
                                    "Liste frames que atualizam NAV: RTS, CTS, Data, ACK, etc.",
                                    "Pratique calculando NAV: ex: transmissão de 1000 bytes a 54Mbps leva X μs."
                                  ],
                                  "verification": "Crie um exemplo numérico de atualização de NAV e explique por que um nó defere apesar de canal fisicamente livre.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de simulação como NS-3 ou diagramas Wireshark de pacotes Wi-Fi",
                                    "Folha de cálculo para calcular durações"
                                  ],
                                  "tips": "Visualize NAV como um 'semáforo virtual' que todos respeitam para evitar hidden node problem.",
                                  "learningObjective": "Descrever como o NAV implementa carrier sense virtual e resolve problemas de nós ocultos.",
                                  "commonMistakes": "Ignorar que NAV é atualizado por frames não destinados ao receptor; todos os que 'ouvem' atualizam."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar o Backoff Exponencial",
                                  "subSteps": [
                                    "Explique o Contention Window (CW): inicia em CWmin (geralmente 31 slots), dobra em colisão até CWmax.",
                                    "Aprenda o processo: após DIFS, selecione backoff = rand(0, CW-1) * slotTime (20μs).",
                                    "Simule decremento: backoff diminui a cada slot idle; freeze em busy; reinicia em colisão.",
                                    "Calcule exemplos: CW=31, rand=15, 15 slots idle → transmitir.",
                                    "Discuta persistência: 1-persistent vs p-persistent, mas foque no exponencial de Wi-Fi."
                                  ],
                                  "verification": "Simule 3 rodadas de backoff em papel, mostrando decremento, freeze e reinício pós-colisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python script simples para rand()",
                                    "Animação interativa de backoff (ex: sites educacionais IEEE)"
                                  ],
                                  "tips": "Pense no backoff como uma loteria: números aleatórios evitam sincronia em múltiplos nós.",
                                  "learningObjective": "Calcular e descrever o algoritmo de backoff exponencial para resolução de contenção.",
                                  "commonMistakes": "Confundir decremento (por slot idle) com espera fixa; backoff é dinâmico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar o Processo Completo de CSMA/CA com Transmissão",
                                  "subSteps": [
                                    "Monte o fluxo: Physical sense (CCA + DIFS) → Virtual sense (NAV=0) → Backoff=0 → Transmitir.",
                                    "Inclua deferral: se busy, espere + DIFS + novo backoff.",
                                    "Descreva pós-transmissão: esperar SIFS + ACK; sem ACK → colisão assumida, backoff duplica CW.",
                                    "Crie um fluxograma completo unindo todos os elementos.",
                                    "Teste com cenário: 3 estações competindo por canal."
                                  ],
                                  "verification": "Desenhe e explique um fluxograma do processo completo para um parceiro ou gravando áudio.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma como Draw.io ou Lucidchart",
                                    "Capture Wireshark de tráfego Wi-Fi real"
                                  ],
                                  "tips": "Use setas coloridas no fluxograma: verde para idle, vermelho para busy.",
                                  "learningObjective": "Sintetizar as etapas em uma descrição fluida do processo básico de CSMA/CA.",
                                  "commonMistakes": "Esquecer SIFS para ACK (10μs vs DIFS 50μs); prioriza ACK sobre nova transmissão."
                                }
                              ],
                              "practicalExample": "Em uma rede Wi-Fi doméstica com smartphone, laptop e smart TV competindo pelo canal: (1) Todos escutam (physical sense) por DIFS; (2) TV atualiza NAV de um RTS do laptop para 1ms; (3) Smartphone roda backoff rand(5) slots durante idle; (4) Após NAV=0 e backoff=0, smartphone transmite dados, espera SIFS+ACK. Capture com Wireshark para ver NAV e backoff inferidos.",
                              "finalVerifications": [
                                "Liste e explique as 4 etapas principais: physical sense, virtual sense, backoff, transmissão/deferral.",
                                "Calcule corretamente um backoff inicial com CWmin=31.",
                                "Descreva diferença entre DIFS e SIFS com valores típicos.",
                                "Explique como NAV resolve hidden node sem diagramas.",
                                "Simule verbalmente uma colisão e recuperação.",
                                "Compare CSMA/CA vs CSMA/CD em 3 pontos chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: 100% das etapas corretas sem omissões.",
                                "Clareza na descrição: Fluxo lógico sem ambiguidades.",
                                "Uso de terminologia correta: CCA, NAV, CW, DIFS/SIFS.",
                                "Exemplos práticos: Inclui cenários reais ou simulações.",
                                "Profundidade: Explica exceções como RTS/CTS.",
                                "Visual aids: Diagramas ou fluxogramas bem estruturados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e distribuições uniformes no backoff rand(0,CW-1).",
                                "Física: Propagação de ondas de rádio e limiares de energia em CCA.",
                                "Estatística: Análise de throughput em redes com backoff exponencial.",
                                "Segurança da Informação: CSMA/CA como base para evitar eavesdropping em Wi-Fi."
                              ],
                              "realWorldApplication": "Em roteadores Wi-Fi (ex: seu lar ou escritório), CSMA/CA previne colisões em canais compartilhados por múltiplos dispositivos, garantindo throughput estável em redes congestionadas como streaming 4K + videochamadas, reduzindo latência e perdas de pacotes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Explicar RTS/CTS e ACK",
                            "description": "Descrever o uso de RTS (Request to Send) e CTS (Clear to Send) para mitigar o problema de estação oculta, e o mecanismo de ACK para confiabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema da Estação Oculta",
                                  "subSteps": [
                                    "Pesquisar definições de CSMA e suas limitações em redes sem fio.",
                                    "Analisar cenários onde estações não detectam transmissões umas das outras devido à distância ou obstáculos.",
                                    "Visualizar e desenhar diagramas ilustrando colisões causadas por estações ocultas.",
                                    "Comparar com CSMA/CD em redes cabeadas.",
                                    "Discutir impactos como perda de pacotes e redução de throughput."
                                  ],
                                  "verification": "Desenhar e explicar um diagrama de estações ocultas para um colega ou em voz alta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet para artigos sobre Wi-Fi",
                                    "Papel e caneta ou ferramenta de desenho digital como Draw.io"
                                  ],
                                  "tips": "Use analogias cotidianas, como carros em ruas paralelas que não se veem.",
                                  "learningObjective": "Identificar e ilustrar o problema da estação oculta em redes IEEE 802.11.",
                                  "commonMistakes": [
                                    "Confundir estação oculta com exposed node",
                                    "Ignorar o papel da propagação de sinal em frequências de rádio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o Mecanismo RTS/CTS",
                                  "subSteps": [
                                    "Definir RTS (Request to Send) e CTS (Clear to Send) como frames de controle.",
                                    "Descrever a sequência: Estação envia RTS, receptor responde CTS, então transmissão de dados.",
                                    "Explicar como CTS reserva o canal para estações vizinhas, resolvendo hidden node.",
                                    "Analisar overhead introduzido e quando ativar (threshold de tamanho de frame).",
                                    "Simular o fluxo em um diagrama sequencial."
                                  ],
                                  "verification": "Criar um diagrama de sequência mostrando RTS/CTS entre três estações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.11 (PDF ou site oficial)",
                                    "Ferramenta de diagrama como Lucidchart ou papel"
                                  ],
                                  "tips": "Lembre-se: CTS é ouvido por todas as estações no alcance do receptor.",
                                  "learningObjective": "Descrever o protocolo RTS/CTS e sua solução para colisões ocultas.",
                                  "commonMistakes": [
                                    "Pensar que RTS é ouvido apenas pelo receptor",
                                    "Esquecer que ambos RTS e CTS incluem duração do frame"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender o Mecanismo de ACK",
                                  "subSteps": [
                                    "Definir ACK como frame de confirmação positiva (positive acknowledgment).",
                                    "Explicar o processo: Receptor envia ACK após receber dados corretamente, ou timeout para retransmissão.",
                                    "Discutir ARQ (Automatic Repeat reQuest) básico para confiabilidade.",
                                    "Analisar cenários de perda de ACK e retransmissões.",
                                    "Comparar com ausência de ACK em redes não confiáveis."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o que acontece se um ACK é perdido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vídeos tutoriais sobre CSMA/CA no YouTube",
                                    "Simulador de rede como Cisco Packet Tracer"
                                  ],
                                  "tips": "ACK cobre apenas o frame de dados, não o RTS/CTS.",
                                  "learningObjective": "Compreender como ACK garante entrega confiável de frames em Wi-Fi.",
                                  "commonMistakes": [
                                    "Confundir ACK com CTS",
                                    "Ignorar o SIFS (Short Interframe Space) entre dados e ACK"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar RTS/CTS e ACK no CSMA/CA",
                                  "subSteps": [
                                    "Revisar o fluxo completo: Carrier Sense + RTS/CTS + Dados + ACK.",
                                    "Simular um cenário completo com estações ocultas usando RTS/CTS e ACK.",
                                    "Discutir NAV (Network Allocation Vector) para reserva de canal.",
                                    "Avaliar vantagens em redes densas e desvantagens (overhead).",
                                    "Testar conceitos em um simulador ou captura Wireshark."
                                  ],
                                  "verification": "Produzir um fluxograma completo do processo CSMA/CA com RTS/CTS/ACK.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark para captura de pacotes Wi-Fi",
                                    "Simulador NS-3 ou OMNeT++ (opcional)"
                                  ],
                                  "tips": "Ative RTS/CTS em roteadores para experimentos reais.",
                                  "learningObjective": "Integrar RTS/CTS e ACK no contexto do CSMA/CA para mitigar colisões e garantir confiabilidade.",
                                  "commonMistakes": [
                                    "Omitir backoff exponencial após colisão",
                                    "Confundir RTS/CTS com handshaking TCP"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede Wi-Fi de um escritório com laptops A, B e C, onde A e C são ocultas uma para a outra mas ambas veem o Access Point (AP). A quer enviar dados ao AP: A envia RTS (ouvido pelo AP), AP responde CTS (ouvido por A e C), C espera; A envia dados, AP envia ACK confirmando recebimento.",
                              "finalVerifications": [
                                "Desenhar diagrama correto de hidden node resolvido por RTS/CTS.",
                                "Explicar sequência exata: RTS → CTS → Dados → ACK.",
                                "Identificar overhead do RTS/CTS e quando usá-lo.",
                                "Simular perda de ACK e consequência (retransmissão).",
                                "Comparar CSMA/CA com CSMA/CD.",
                                "Capturar tráfego Wireshark mostrando RTS/CTS/ACK."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos frames RTS, CTS e ACK.",
                                "Correta explicação da resolução do problema hidden node.",
                                "Uso apropriado de terminologia IEEE 802.11 (NAV, SIFS, etc.).",
                                "Clareza em diagramas e fluxogramas.",
                                "Compreensão de trade-offs (overhead vs. confiabilidade).",
                                "Capacidade de relacionar ao CSMA/CA completo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas de rádio e atenuação de sinal.",
                                "Matemática: Cálculo de probabilidade de colisão e throughput.",
                                "Engenharia: Design de protocolos de comunicação confiáveis.",
                                "Segurança da Informação: Implicações de RTS/CTS em ataques de negação de serviço."
                              ],
                              "realWorldApplication": "Em redes Wi-Fi densas como estádios ou conferências, RTS/CTS previne colisões de dispositivos ocultos, enquanto ACK assegura que e-mails, vídeos e atualizações sejam entregues sem perda, otimizando o desempenho em hotspots públicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Suporte a Mobilidade no Wi-Fi",
                        "description": "Mecanismos para handover e roaming entre pontos de acesso, garantindo conectividade contínua em redes sem fio.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Descrever o processo de roaming",
                            "description": "Explicar as fases de descoberta (scanning ativo/passivo), reautenticação e reassociação durante a transição entre APs em uma ESS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Roaming em uma ESS",
                                  "subSteps": [
                                    "Pesquise a definição de Roaming no padrão IEEE 802.11 e identifique os componentes chave: Station (STA), Access Points (APs) e Extended Service Set (ESS).",
                                    "Estude o trigger para roaming: queda no sinal RSSI (Received Signal Strength Indicator) abaixo de um threshold.",
                                    "Desenhe um diagrama simples mostrando uma STA se movendo entre dois APs na mesma ESS.",
                                    "Leia seções relevantes do padrão 802.11 sobre mobilidade (capítulos sobre BSS Transition).",
                                    "Anote as diferenças entre roaming intra-ESS e inter-ESS."
                                  ],
                                  "verification": "Você pode explicar em suas palavras o que inicia o processo de roaming e listar os componentes envolvidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.11 (PDF ou site oficial)",
                                    "Papel e caneta para diagrama",
                                    "Acesso à internet para pesquisas"
                                  ],
                                  "tips": [
                                    "Use analogias como 'mudar de sala em uma casa grande mantendo a mesma rede'.",
                                    "Foque em ESS para manter o contexto intra-subnet."
                                  ],
                                  "learningObjective": "Dominar os fundamentos e triggers do roaming em Wi-Fi.",
                                  "commonMistakes": [
                                    "Confundir roaming com handover em redes celulares.",
                                    "Ignorar que roaming em ESS mantém o mesmo SSID."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Fase de Descoberta (Scanning Ativo e Passivo)",
                                  "subSteps": [
                                    "Aprenda scanning passivo: STA escuta beacons de APs vizinhos sem transmitir.",
                                    "Estude scanning ativo: STA envia Probe Request e recebe Probe Response de APs.",
                                    "Compare tempos e energias: passivo é mais eficiente em energia, ativo é mais rápido.",
                                    "Simule em software como Wireshark capturando beacons/probes em uma rede Wi-Fi real.",
                                    "Liste parâmetros chave nos frames: SSID, BSSID, supported rates, channel."
                                  ],
                                  "verification": "Descreva um frame de Probe Response e diferencie os dois tipos de scanning com prós/contras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Rede Wi-Fi acessível",
                                    "Tutoriais de captura 802.11 no Wireshark"
                                  ],
                                  "tips": [
                                    "Ative modo monitor no adaptador Wi-Fi para capturas precisas.",
                                    "Teste em canais diferentes para ver variação."
                                  ],
                                  "learningObjective": "Entender como a STA descobre novos APs candidatos.",
                                  "commonMistakes": [
                                    "Achar que scanning ativo sempre envia probes em todos canais.",
                                    "Esquecer que beacons são periódicos (~100ms)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Fase de Reautenticação",
                                  "subSteps": [
                                    "Revise tipos de autenticação: Open System, Shared Key (WEP), 802.1X (EAP).",
                                    "Descreva o processo: STA envia Authentication Request ao novo AP.",
                                    "Estude o handshake: Challenge-response em Shared Key ou EAPOL em WPA2/3.",
                                    "Capture com Wireshark um processo de autenticação durante roam.",
                                    "Note que em Fast BSS Transition (802.11r), há pré-autenticação para reduzir latência."
                                  ],
                                  "verification": "Explique o fluxo de mensagens em uma autenticação 802.1X simplificada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Rede Wi-Fi com WPA2/3",
                                    "Documentação 802.11i sobre segurança"
                                  ],
                                  "tips": [
                                    "Use PMK Caching ou OKC para ver otimizações em roaming.",
                                    "Ignore criptografia detalhada inicialmente."
                                  ],
                                  "learningObjective": "Compreender a validação de identidade durante transição.",
                                  "commonMistakes": [
                                    "Confundir autenticação com associação.",
                                    "Achar que Open System é inseguro só por nome."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar a Fase de Reassociação e Integração do Processo",
                                  "subSteps": [
                                    "Aprenda reassociação: STA envia Reassociation Request com BSSID anterior e novo.",
                                    "Descreva resposta: AP confirma e atualiza chaves de sessão se necessário.",
                                    "Monte um fluxograma completo: Trigger -> Scan -> Auth -> Reassoc -> Data flow.",
                                    "Simule roaming caminhando com um laptop entre APs e monitore com Wireshark.",
                                    "Discuta latências: full roam ~100-500ms vs fast roam <50ms."
                                  ],
                                  "verification": "Desenhe e explique o fluxograma completo do roaming.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Dois APs configurados em mesma ESS",
                                    "Laptop com Wi-Fi monitorável",
                                    "Ferramenta de fluxograma como Draw.io"
                                  ],
                                  "tips": [
                                    "Teste em ambiente controlado para evitar interferências.",
                                    "Meça tempo real com ping durante roam."
                                  ],
                                  "learningObjective": "Integrar todas as fases em um processo coeso.",
                                  "commonMistakes": [
                                    "Esquecer atualização de chaves de criptografia.",
                                    "Achar reassociação idêntica a associação inicial."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um escritório com múltiplos APs cobrindo a área (mesmo SSID e ESS), um funcionário caminha de uma sala para outra com seu laptop. O sinal do AP atual cai (RSSI < -70dBm), triggerando scan ativo: envia probes, recebe responses de AP vizinho, autentica via 802.1X (usando PMK pré-compartilhado), reassocia seamless, mantendo sessão VoIP sem interrupção.",
                              "finalVerifications": [
                                "Liste e descreva as três fases principais do roaming: descoberta, reautenticação e reassociação.",
                                "Diferencie scanning ativo vs passivo com exemplos de frames.",
                                "Explique o papel do BSSID no processo de reassociação.",
                                "Capture e identifique frames de roaming em Wireshark.",
                                "Descreva otimizações como 802.11r para fast roaming.",
                                "Monte um fluxograma correto do processo completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: todas fases e frames corretos (40%)",
                                "Completude: cobre triggers, scanning types, auth methods e reassoc (30%)",
                                "Clareza na descrição e diagramas (15%)",
                                "Evidências práticas: capturas Wireshark ou simulações (10%)",
                                "Profundidade em otimizações e latências (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas RF e atenuação de sinal (RSSI).",
                                "Segurança da Informação: Protocolos de autenticação (802.1X, WPA3).",
                                "Matemática: Modelagem de probabilidades em handoffs e latências.",
                                "Programação: Simulações de rede em NS-3 ou Python Scapy para frames 802.11."
                              ],
                              "realWorldApplication": "Em aeroportos ou shoppings com Wi-Fi enterprise (ex: Cisco Meraki), smartphones e laptops fazem roaming seamless entre APs, mantendo streaming de vídeo ou chamadas sem quedas, essencial para IoT móvel e redes 5G-Wi-Fi convergence."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Identificar desafios da mobilidade",
                            "description": "Discutir latência de handover, perda de pacotes e otimizações como pré-autenticação em versões avançadas do 802.11.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Mobilidade em Redes Wi-Fi",
                                  "subSteps": [
                                    "Revise o processo de associação básica em 802.11: autenticação, associação e re-associação.",
                                    "Identifique o que acontece quando um dispositivo móvel se move entre pontos de acesso (APs).",
                                    "Estude o conceito de handover como transição entre APs.",
                                    "Analise o impacto da mobilidade em camadas inferiores do modelo OSI.",
                                    "Liste os principais componentes envolvidos: STA (Station), AP e BSS (Basic Service Set)."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando a sequência de handover básico e explique verbalmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.11 (seções de mobilidade)",
                                    "Ferramenta de desenho como Draw.io",
                                    "Vídeos tutoriais sobre Wi-Fi basics"
                                  ],
                                  "tips": "Use analogias como mudar de sala em uma casa para visualizar handover.",
                                  "learningObjective": "Entender os mecanismos básicos de mobilidade no 802.11 para contextualizar desafios.",
                                  "commonMistakes": [
                                    "Confundir handover com roaming de camada superior (IP), focar apenas em Wi-Fi layer 2."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Latência de Handover",
                                  "subSteps": [
                                    "Meça componentes da latência: detecção de sinal fraco, scanning de canais, autenticação e re-associação.",
                                    "Calcule tempos típicos: scanning ~100-500ms, autenticação ~50ms por padrão.",
                                    "Simule cenários com ferramentas como Wireshark capturando beacons e probes.",
                                    "Compare latência em 802.11a/b/g vs. modernas (802.11n/ac/ax).",
                                    "Discuta impactos em aplicações tempo-sensíveis como VoIP."
                                  ],
                                  "verification": "Registre tempos de handover em uma simulação simples e compare com benchmarks.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark ou tcpdump",
                                    "Ambiente de teste com 2 APs e dispositivo móvel",
                                    "Referências IEEE 802.11r para fast BSS transition"
                                  ],
                                  "tips": "Ande fisicamente com um laptop entre APs para capturar tráfego real.",
                                  "learningObjective": "Quantificar e decompor a latência de handover como desafio principal.",
                                  "commonMistakes": [
                                    "Ignorar overhead de scanning passivo vs. ativo",
                                    "Subestimar impacto de criptografia em autenticação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar Perda de Pacotes em Cenários de Mobilidade",
                                  "subSteps": [
                                    "Explique causas: interrupção durante handover, fading de sinal e interferência.",
                                    "Analise métricas: taxa de perda de pacotes (PLR) e jitter em handovers.",
                                    "Use ferramentas para medir PLR em movimento (ex: iperf em modo móvel).",
                                    "Estude mecanismos de recuperação: retransmissões MAC e ACKs.",
                                    "Compare com redes fixas para destacar agravantes da mobilidade."
                                  ],
                                  "verification": "Gere relatório com gráficos de PLR antes/depois/durante handover.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta iperf ou ping em loop",
                                    "Smartphone ou laptop com Wi-Fi monitor",
                                    "Planilhas para plotar dados"
                                  ],
                                  "tips": "Teste em ambiente com obstáculos para simular fading realista.",
                                  "learningObjective": "Identificar perda de pacotes como desafio crítico e suas causas.",
                                  "commonMistakes": [
                                    "Atribuir toda perda a handover, ignorando channel overlap",
                                    "Não diferenciar perda temporária de permanente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Otimizações Avançadas como Pré-Autenticação",
                                  "subSteps": [
                                    "Estude 802.11r (Fast BSS Transition): pré-autenticação e key caching.",
                                    "Analise 802.11k (Radio Resource Measurement) para scanning otimizado.",
                                    "Discuta 802.11v (WNM) para sugestões de handover proativo.",
                                    "Compare ganhos: latência reduzida de 100s ms para <50ms.",
                                    "Avalie limitações em deployments reais (compatibilidade de hardware)."
                                  ],
                                  "verification": "Descreva em um fluxograma como pré-autenticação reduz latência.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Especificações IEEE 802.11r/k/v",
                                    "Simulador ns-3 ou documentação de vendors como Cisco"
                                  ],
                                  "tips": "Pesquise whitepapers de vendors para casos reais de implementação.",
                                  "learningObjective": "Compreender otimizações que mitigam desafios de mobilidade.",
                                  "commonMistakes": [
                                    "Confundir otimizações de layer 2 com layer 3 (ex: Mobile IP)",
                                    "Assumir suporte universal em todos os devices."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um handover em um hotspot de café: mova um laptop entre dois APs domésticos configurados como BSS separados, capture tráfego com Wireshark, meça latência e PLR durante uma videochamada Zoom, e aplique configurações 802.11r se suportado para comparar melhorias.",
                              "finalVerifications": [
                                "Explique verbalmente os 3 principais componentes de latência de handover.",
                                "Identifique pelo menos 2 causas de perda de pacotes em mobilidade.",
                                "Descreva como pré-autenticação funciona em 802.11r.",
                                "Compare desafios em Wi-Fi vs. redes cabeadas.",
                                "Crie um diagrama de handover otimizado vs. básico.",
                                "Meça PLR em um teste prático e proponha mitigação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de latência (scanning, auth, assoc).",
                                "Profundidade na análise de perda de pacotes com evidências.",
                                "Correta distinção entre otimizações 802.11r/k/v.",
                                "Uso de exemplos práticos e métricas quantitativas.",
                                "Clareza em diagramas e explicações.",
                                "Conexão de desafios com impactos em aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e fading multipath.",
                                "Matemática: Modelos probabilísticos de perda de pacotes (distribuição de Bernoulli).",
                                "Engenharia de Software: Protocolos de rede e QoS.",
                                "Segurança: Implicações de autenticação rápida em WPA3."
                              ],
                              "realWorldApplication": "Em veículos autônomos (V2X), onde handover rápido em Wi-Fi vehicular evita perda de comandos críticos; em smartphones durante chamadas em movimento, reduzindo interrupções; ou em estádios lotados para streaming seamless."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Subcamada de Controle de Acesso ao Meio (MAC)",
                    "description": "Mecanismos de controle de acesso ao meio compartilhado nos padrões IEEE 802.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "CSMA/CD (Carrier Sense Multiple Access with Collision Detection)",
                        "description": "Mecanismo de controle de acesso ao meio compartilhado utilizado nos padrões IEEE 802.3 (Ethernet cabeado), onde estações escutam o meio antes de transmitir, detectam colisões durante a transmissão e utilizam backoff exponencial para retransmissão.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Explicar o funcionamento passo a passo do CSMA/CD",
                            "description": "Descrever as etapas: carrier sense (escuta do meio), multiple access (transmissão se livre), collision detection (detecção de colisão via sinalização elétrica), jam signal e binary exponential backoff, com exemplos em redes Ethernet half-duplex.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Carrier Sense (Escuta do Meio)",
                                  "subSteps": [
                                    "Explique o que é Carrier Sense: a estação verifica se o meio está livre antes de transmitir.",
                                    "Descreva como a detecção é feita em Ethernet: monitorando a voltagem no cabo coaxial ou par trançado.",
                                    "Discuta o tempo de propagação e o problema do 'hidden terminal'.",
                                    "Simule com diagrama: estação A escuta e vê o meio livre.",
                                    "Compare com CSMA sem CD para destacar diferenças."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando uma estação escutando o meio livre e confirme com autoexplicação verbal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de rede Ethernet half-duplex",
                                    "Vídeo explicativo sobre sinais elétricos em cabos",
                                    "Simulador online de CSMA (ex: Cisco Packet Tracer)"
                                  ],
                                  "tips": "Sempre pense no sinal como uma onda elétrica que leva tempo para propagar.",
                                  "learningObjective": "Compreender como as estações evitam transmissão desnecessária escutando o meio.",
                                  "commonMistakes": [
                                    "Confundir carrier sense com detecção de colisão",
                                    "Ignorar o delay de propagação em redes longas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Multiple Access e Transmissão de Dados",
                                  "subSteps": [
                                    "Se o meio estiver livre por um tempo mínimo (Interframe Gap), inicie a transmissão.",
                                    "Descreva o preamble e SFD (Start Frame Delimiter) para sincronização.",
                                    "Explique que múltiplas estações compartilham o meio (multiple access).",
                                    "Transmita o frame de dados completo enquanto monitora continuamente.",
                                    "Calcule o tempo mínimo de transmissão baseado no slot time (2x tempo de propagação máxima)."
                                  ],
                                  "verification": "Escreva uma sequência temporal de transmissão e verifique se cobre o slot time.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Estrutura de frame Ethernet",
                                    "Cronograma de transmissão ilustrado",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Lembre-se: transmissão começa só após escuta confirmada livre.",
                                  "learningObjective": "Dominar o processo de acesso múltiplo e início seguro da transmissão.",
                                  "commonMistakes": [
                                    "Transmitir sem esperar Interframe Gap",
                                    "Esquecer monitoramento durante transmissão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Collision Detection (Detecção de Colisão)",
                                  "subSteps": [
                                    "Enquanto transmite, a estação compara o sinal transmitido com o recebido (sinalização elétrica).",
                                    "Se houver colisão, a voltagem muda (ex: de +V para 0V em Manchester encoding).",
                                    "Explique detecção em half-duplex: estações detectam discrepância no cabo.",
                                    "Descreva o que acontece se colisão ocorrer após o slot time (não detectável).",
                                    "Simule: estações A e B transmitem simultaneamente e detectam colisão."
                                  ],
                                  "verification": "Crie um diagrama de onda mostrando colisão e confirme detecção por voltagem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos de sinal Manchester encoding",
                                    "Vídeo de osciloscópio em Ethernet",
                                    "Simulador de colisões CSMA/CD"
                                  ],
                                  "tips": "Foco na detecção elétrica: transmissão gera sinal próprio para comparação.",
                                  "learningObjective": "Identificar e explicar o mecanismo físico de detecção de colisões.",
                                  "commonMistakes": [
                                    "Pensar que colisão é detectada por software",
                                    "Confundir com CSMA/CA que usa ACKs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Jam Signal e Binary Exponential Backoff",
                                  "subSteps": [
                                    "Ao detectar colisão, envie Jam Signal (32 bits de 1s) para alertar todas as estações.",
                                    "Pare a transmissão e calcule delay de backoff: k = min(10, floor(log2(N+1))) onde N é número de colisões.",
                                    "Gere número aleatório r (0 a 2^k -1) e espere r * slot time.",
                                    "Após backoff, retorne ao Carrier Sense para nova tentativa.",
                                    "Explique por que exponencial: reduz probabilidade de colisões repetidas."
                                  ],
                                  "verification": "Calcule backoff para 3ª colisão (ex: k=2, r=1, delay=512 bit times) e explique.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela de backoff exponencial",
                                    "Calculadora de probabilidade",
                                    "Exemplo em código Python simples"
                                  ],
                                  "tips": "Backoff é crucial para eficiência; teste com diferentes k.",
                                  "learningObjective": "Implementar logicamente o algoritmo de recuperação de colisões.",
                                  "commonMistakes": [
                                    "Confundir jam signal com frame de dados",
                                    "Usar backoff linear em vez de exponencial"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integração Completa e Limitações do CSMA/CD",
                                  "subSteps": [
                                    "Revise o ciclo completo: Sense → Access → Detect → Jam → Backoff.",
                                    "Discuta por que CSMA/CD é obsoleto em full-duplex (switches evitam colisões).",
                                    "Compare com CSMA/CA em Wi-Fi.",
                                    "Simule cenário completo com 3 estações.",
                                    "Calcule eficiência máxima: 1 / (1 + 5p/ (1-2p)) onde p é probabilidade de colisão."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o fluxo completo com exemplo de colisão resolvida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de fluxo CSMA/CD completo",
                                    "Artigo histórico sobre Ethernet 802.3",
                                    "Simulador NS-3 ou similar"
                                  ],
                                  "tips": "Visualize o processo como um loop até sucesso.",
                                  "learningObjective": "Sintetizar o protocolo inteiro e suas limitações históricas.",
                                  "commonMistakes": [
                                    "Aplicar CSMA/CD a redes modernas full-duplex",
                                    "Ignorar eficiência em cargas altas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede Ethernet 10BASE5 half-duplex com 3 PCs conectados por cabo coaxial: PC1 escuta (livre), transmite frame 'Olá'; PC2 simultaneamente escuta (livre devido a propagação), transmite 'Mundo'; colisão detectada por voltagem alterada; ambos enviam jam signal, calculam backoff (PC1: 0*51.2μs, PC2: 1*51.2μs), PC1 retransmite primeiro com sucesso.",
                              "finalVerifications": [
                                "Explique o ciclo CSMA/CD sem pausas em menos de 2 minutos.",
                                "Desenhe diagrama preciso de colisão com jam e backoff.",
                                "Calcule backoff para 5ª colisão consecutiva.",
                                "Diferencie CSMA/CD de CSMA/CA com 3 pontos chave.",
                                "Simule em ferramenta e grave tela mostrando detecção.",
                                "Responda quiz de 10 perguntas sobre passos com 90% acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das 5 etapas principais (carrier sense, multiple access, collision detection, jam, backoff).",
                                "Uso correto de conceitos físicos como sinalização elétrica e tempo de propagação.",
                                "Exemplos concretos com cenários Ethernet half-duplex.",
                                "Compreensão matemática do binary exponential backoff.",
                                "Identificação de limitações e evolução para full-duplex.",
                                "Clareza em diagramas e simulações.",
                                "Conexão com padrões IEEE 802.3."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de sinais elétricos e codificação Manchester.",
                                "Matemática: Algoritmo probabilístico exponencial e cálculo de eficiência.",
                                "Probabilidade: Modelagem de colisões em redes compartilhadas.",
                                "História da Computação: Evolução da Ethernet de 1970s a switches modernos.",
                                "Engenharia: Design de protocolos para ambientes ruidosos."
                              ],
                              "realWorldApplication": "CSMA/CD foi fundamental nas redes Ethernet LANs antigas (ex: escritórios nos anos 80-90 com hubs), garantindo compartilhamento eficiente de cabos compartilhados; hoje legado em ferramentas de diagnóstico de rede e compreensão de protocolos legados em data centers ou simulações de redes históricas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Calcular o tempo mínimo de detecção de colisão em CSMA/CD",
                            "description": "Aplicar a fórmula para o tempo de propagação máxima (2 * propagação / velocidade do sinal) em redes Ethernet, considerando cabo coaxial ou twisted pair, e determinar o tamanho mínimo do quadro (64 bytes).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos de CSMA/CD e detecção de colisões",
                                  "subSteps": [
                                    "Estude o protocolo CSMA/CD: Carrier Sense (escuta antes de transmitir), Multiple Access (múltiplos dispositivos no meio compartilhado) e Collision Detection (detecção de colisão durante transmissão).",
                                    "Identifique por que colisões ocorrem em redes Ethernet clássicas com cabo coaxial ou twisted pair.",
                                    "Aprenda que o tempo mínimo de detecção deve ser menor que o tempo de transmissão do quadro mínimo para garantir detecção.",
                                    "Revise o diagrama de uma rede Ethernet bus topology.",
                                    "Anote as vantagens e limitações do CSMA/CD comparado a CSMA/CA."
                                  ],
                                  "verification": "Explique em suas palavras o ciclo completo de transmissão com colisão e desenhe um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro ou slides sobre Redes de Computadores (Tanenbaum ou Kurose), diagrama de rede Ethernet"
                                  ],
                                  "tips": "Use analogias como uma sala de reuniões onde todos falam ao mesmo tempo para entender colisões.",
                                  "learningObjective": "Compreender o papel do CSMA/CD na subcamada MAC e a necessidade de detecção rápida de colisões.",
                                  "commonMistakes": [
                                    "Confundir CSMA/CD com CSMA/CA (Wi-Fi usa CA), ignorar o meio compartilhado."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o tempo de propagação máxima no meio de transmissão",
                                  "subSteps": [
                                    "Defina tempo de propagação: tempo para o sinal viajar do extremo A ao B e voltar (RTT - Round Trip Time).",
                                    "Aprenda a fórmula: Tempo de propagação máxima = 2 * (comprimento máximo do segmento / velocidade do sinal).",
                                    "Identifique velocidades típicas: 2x10^8 m/s para cabo coaxial ou twisted pair (aprox. 2/3 da velocidade da luz).",
                                    "Exemplo inicial: Para 2500m (Ethernet 10BASE5), calcule propagação.",
                                    "Pratique com unidades: converta metros para km se necessário e segundos para microssegundos."
                                  ],
                                  "verification": "Calcule o tempo de propagação para um cabo de 500m a 2x10^8 m/s e confira se é 5 μs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora, tabela de velocidades de propagação em cabos Ethernet"
                                  ],
                                  "tips": "Lembre-se: velocidade efetiva é ~200.000 km/s, não velocidade da luz (300.000 km/s).",
                                  "learningObjective": "Dominar a fórmula de tempo de propagação e aplicá-la a cenários de rede Ethernet.",
                                  "commonMistakes": [
                                    "Usar velocidade da luz em vez de velocidade no cabo, esquecer o fator 2 para RTT."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar o tempo mínimo de detecção de colisão",
                                  "subSteps": [
                                    "Entenda que o tempo mínimo de detecção (T_min) deve ser pelo menos o tempo de propagação máxima (Tp_max).",
                                    "Relacione T_min com o tempo de transmissão do quadro mínimo: quadro deve durar > 2*Tp_max.",
                                    "Calcule Tp_max para Ethernet clássica: ~51.2 μs para 10 Mbps (baseado em 2500m).",
                                    "Discuta jam signal: sinal de jam de 32 bits enviado após detecção.",
                                    "Simule: se transmissão começa no fim do cabo, colisão deve ser detectada antes do fim do quadro."
                                  ],
                                  "verification": "Justifique por que T_min = 51.2 μs em Ethernet 10BASE5 e calcule para twisted pair 500m.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de rede online (Cisco Packet Tracer), notas de fórmulas Ethernet"
                                  ],
                                  "tips": "Pense no pior caso: estações nos extremos do segmento máximo.",
                                  "learningObjective": "Calcular e justificar o tempo mínimo necessário para detecção confiável de colisões.",
                                  "commonMistakes": [
                                    "Confundir Tp_max com tempo de transmissão, ignorar o dobro para ida e volta."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com o tamanho mínimo do quadro Ethernet (64 bytes)",
                                  "subSteps": [
                                    "Calcule tempo de transmissão de quadro mínimo: 64 bytes * 8 bits/byte / 10 Mbps = 51.2 μs.",
                                    "Verifique que 51.2 μs >= Tp_max para garantir detecção.",
                                    "Entenda padding: quadros menores são preenchidos para 64 bytes.",
                                    "Compare com velocidades maiores (100 Mbps): segmentos menores necessários.",
                                    "Aplique em exercício: dado Tp_max, encontre tamanho mínimo de quadro."
                                  ],
                                  "verification": "Resolva: Para Tp_max=25.6 μs e 10 Mbps, confirme quadro mínimo de 64 bytes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fórmulas Ethernet padrão, calculadora científica"
                                  ],
                                  "tips": "Lembre: Ethernet 802.3 define 64 bytes precisamente por isso.",
                                  "learningObjective": "Conectar tempo de detecção com design do quadro mínimo em Ethernet.",
                                  "commonMistakes": [
                                    "Esquecer bits de preamble/interframe gap no cálculo de tempo."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e verificar cálculos completos",
                                  "subSteps": [
                                    "Resolva problema completo: Rede 10BASE2 (185m), calcule Tp_max e confirme quadro 64 bytes.",
                                    "Use ferramenta para simular colisão em rede virtual.",
                                    "Compare CSMA/CD clássico vs. switches modernas (full-duplex, sem colisões).",
                                    "Documente seu raciocínio em um relatório curto.",
                                    "Teste variações: impacto de cabo mais longo ou sinal mais lento."
                                  ],
                                  "verification": "Produza cálculo correto para um cenário dado e explique implicações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Packet Tracer ou Wireshark para captura, papel para cálculos"
                                  ],
                                  "tips": "Sempre valide unidades: bits vs bytes, metros vs km, s vs μs.",
                                  "learningObjective": "Aplicar integralmente o cálculo em cenários reais de rede.",
                                  "commonMistakes": [
                                    "Arredondamentos errados, não considerar velocidade bit exata (10^7 bps)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede Ethernet 10BASE5 com segmento máximo de 2500m e velocidade de propagação 2x10^8 m/s: Tp_max = 2 * 2500 / 2e8 = 25 μs. Mas padrão usa ~51.2 μs conservador. Tempo quadro 64 bytes: 64*8/10e6 = 51.2 μs. Assim, colisão é detectada antes do fim.",
                              "finalVerifications": [
                                "Calcule corretamente Tp_max para cabo 500m.",
                                "Explique por que quadro mínimo é 64 bytes.",
                                "Identifique Tp_max em Ethernet clássica (51.2 μs).",
                                "Simule detecção em diagrama.",
                                "Diferencie CSMA/CD de outros protocolos.",
                                "Ajuste cálculo para twisted pair vs coaxial."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de propagação (erro <5%).",
                                "Correta justificativa do quadro mínimo.",
                                "Uso adequado de unidades e fórmulas.",
                                "Identificação de casos extremos.",
                                "Explicação clara de conceitos CSMA/CD.",
                                "Aplicação em exemplo prático sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas eletromagnéticas em cabos.",
                                "Matemática: Cálculos de taxa, tempo e conversões de unidades.",
                                "Engenharia: Design de protocolos de rede e trade-offs.",
                                "Probabilidade: Modelagem de colisões em acessos aleatórios."
                              ],
                              "realWorldApplication": "Projeto de redes LAN Ethernet clássicas (hoje legado em sistemas industriais); entendimento de por que switches full-duplex eliminaram CSMA/CD; otimização de redes em ambientes com alta latência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Identificar vantagens e limitações do CSMA/CD",
                            "description": "Analisar eficiência em baixas cargas (alta), degradação em altas cargas devido a colisões frequentes, e transição para full-duplex em switches modernos que eliminam CSMA/CD.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Protocolo CSMA/CD",
                                  "subSteps": [
                                    "Estude a definição de CSMA/CD: Carrier Sense (escuta o meio), Multiple Access (acesso múltiplo), Collision Detection (detecção de colisão).",
                                    "Revise o funcionamento básico: estações escutam antes de transmitir, detectam colisões durante transmissão e retransmitem após backoff.",
                                    "Analise o diagrama de fluxo do CSMA/CD em uma rede Ethernet compartilhada.",
                                    "Compare com outros métodos de acesso ao meio como TDMA ou FDMA.",
                                    "Identifique o contexto histórico: uso em Ethernet 802.3 half-duplex."
                                  ],
                                  "verification": "Desenhe e explique um diagrama de fluxo do CSMA/CD corretamente para um parceiro de estudo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama de CSMA/CD (impresso ou digital)",
                                    "Vídeo tutorial sobre Ethernet MAC",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como uma sala de reuniões onde todos falam só se ninguém estiver falando.",
                                  "learningObjective": "Explicar os componentes principais e o fluxo operacional do CSMA/CD.",
                                  "commonMistakes": [
                                    "Confundir CSMA/CD com CSMA/CA (usado em Wi-Fi)",
                                    "Ignorar o papel do backoff exponencial truncado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as Vantagens do CSMA/CD em Baixas Cargas",
                                  "subSteps": [
                                    "Calcule a eficiência em cenários de baixa carga: eficiência ≈ 1 / (1 + 5t), onde t é tempo de propagação normalizado.",
                                    "Liste vantagens: simplicidade de implementação, sem necessidade de coordenação central, alta eficiência (>90%) em tráfego leve.",
                                    "Simule uma rede com 2-3 estações transmitindo raramente e observe ausência de colisões.",
                                    "Discuta adaptação dinâmica ao tráfego sem configuração prévia.",
                                    "Compare eficiência com Aloha puro (eficiência máxima 18% vs. CSMA/CD ~50% em média)."
                                  ],
                                  "verification": "Liste pelo menos 3 vantagens com exemplos quantitativos em um quadro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou simulador online de eficiência CSMA/CD",
                                    "Tabela de eficiência vs. carga",
                                    "Artigo sobre história da Ethernet"
                                  ],
                                  "tips": "Foquem em cenários reais como LANs antigas com poucos usuários.",
                                  "learningObjective": "Quantificar e exemplificar por que CSMA/CD é eficiente em baixas cargas de tráfego.",
                                  "commonMistakes": [
                                    "Superestimar eficiência em todas as cargas",
                                    "Confundir com full-duplex"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar as Limitações em Altas Cargas de Tráfego",
                                  "subSteps": [
                                    "Estude degradação: colisões frequentes levam a eficiência < 30% em cargas > 50%.",
                                    "Simule alta carga: múltiplas estações competindo, observe jams de colisões e backoffs longos.",
                                    "Discuta limitações: overhead de detecção/transmissão (51 bytes mínimo), vulnerável a captura de canal.",
                                    "Calcule probabilidade de colisão: aumenta com N estações e G carga oferecida.",
                                    "Compare com CSMA/CA que usa ACKs para mitigar."
                                  ],
                                  "verification": "Crie um gráfico de eficiência vs. carga e identifique o ponto de degradação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de simulação como NS-3 ou Cisco Packet Tracer",
                                    "Gráficos de eficiência CSMA/CD",
                                    "Folha de cálculo para cálculos"
                                  ],
                                  "tips": "Use G = λ * T, onde λ é taxa de chegada e T tempo de transmissão.",
                                  "learningObjective": "Explicar matematicamente como colisões degradam performance em altas cargas.",
                                  "commonMistakes": [
                                    "Ignorar impacto do tamanho da rede no tempo de propagação",
                                    "Achar que CSMA/CD é obsoleto sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar a Transição para Full-Duplex e Switches Modernos",
                                  "subSteps": [
                                    "Entenda full-duplex: transmissão simultânea bidirecional sem colisões, eliminando CSMA/CD.",
                                    "Estude evolução: hubs compartilhados → switches com portas dedicadas full-duplex.",
                                    "Discuta padrões IEEE 802.3: auto-negociação para half/full-duplex.",
                                    "Analise legado: CSMA/CD ainda em código para compatibilidade backward.",
                                    "Preveja cenários onde CSMA/CD persiste (redes antigas ou emuladores)."
                                  ],
                                  "verification": "Explique verbalmente por que switches modernos tornam CSMA/CD irrelevante.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama hub vs. switch",
                                    "Especificação IEEE 802.3",
                                    "Vídeo sobre evolução Ethernet"
                                  ],
                                  "tips": "Pense em duplex como 'auto-estrada em ambas direções' vs. 'rua de mão única'.",
                                  "learningObjective": "Compreender por que CSMA/CD foi substituído e seu status atual.",
                                  "commonMistakes": [
                                    "Achar que full-duplex usa CSMA/CD",
                                    "Ignorar auto-negociação"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma LAN Ethernet 10BASE5 com 5 PCs usando Packet Tracer: em baixa carga (pings esporádicos), throughput alto; adicione tráfego flood e observe colisões >50%, eficiência caindo para 20%; troque por switch full-duplex e compare zero colisões.",
                              "finalVerifications": [
                                "Liste 3 vantagens e 3 limitações do CSMA/CD com exemplos.",
                                "Desenhe gráfico de eficiência vs. carga normalizado.",
                                "Explique por que switches full-duplex eliminam CSMA/CD.",
                                "Compare CSMA/CD com CSMA/CA em termos de colisões.",
                                "Identifique cenários onde CSMA/CD ainda é relevante."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e mecanismos corretos (30%)",
                                "Análise quantitativa: uso de fórmulas de eficiência (25%)",
                                "Profundidade de limitações: impacto em altas cargas (20%)",
                                "Conexão histórica/moderna: transição para full-duplex (15%)",
                                "Clareza na explicação e exemplos práticos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos probabilísticos de colisões (distribuição de Poisson, backoff exponencial)",
                                "Física: Propagação de sinais em cabos coaxiais e detecção de colisões por voltagem",
                                "História da Tecnologia: Evolução da Ethernet de Metcalfe aos switches Gigabit",
                                "Estatística: Análise de throughput e simulações de redes"
                              ],
                              "realWorldApplication": "Em data centers legados ou emuladores de redes antigas, entender CSMA/CD ajuda a diagnosticar gargalos em migrações para Ethernet moderna; ensina lições de design escalável para IoT ou 5G onde colisões ainda ocorrem em acessos compartilhados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance)",
                        "description": "Mecanismo de controle de acesso ao meio em redes sem fio IEEE 802.11 (Wi-Fi), que evita colisões por meio de escuta física e virtual do meio, RTS/CTS e backoff exponencial, devido à impossibilidade de detecção de colisões em ambientes sem fio.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Descrever o processo de RTS/CTS e NAV em CSMA/CA",
                            "description": "Explicar Request to Send (RTS), Clear to Send (CTS), Network Allocation Vector (NAV) para reserva virtual do meio, e como isso mitiga o problema do terminal oculto em WLANs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema do Terminal Oculto em WLANs",
                                  "subSteps": [
                                    "Explicar o funcionamento básico do CSMA/CA em redes sem fio",
                                    "Descrever um cenário onde duas estações não detectam as transmissões uma da outra, mas ambas tentam acessar o receptor comum",
                                    "Ilustrar como isso causa colisões no receptor devido à falta de detecção de carrier",
                                    "Comparar com o problema em redes cabeadas (CSMA/CD) e destacar limitações do silenciamento físico em WLANs",
                                    "Discutir o impacto na taxa de throughput da rede"
                                  ],
                                  "verification": "Desenhar e rotular um diagrama mostrando estações A e B ocultas transmitindo simultaneamente para estação C, resultando em colisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Vídeo introdutório sobre CSMA/CA no YouTube",
                                    "Artigo IEEE 802.11 sobre hidden node"
                                  ],
                                  "tips": "Pense nas estações como pessoas em uma multidão: elas não se veem, mas competem pela atenção de um ponto central.",
                                  "learningObjective": "Identificar e visualizar o problema do terminal oculto como motivação para mecanismos de reserva de canal.",
                                  "commonMistakes": [
                                    "Confundir terminal oculto com terminal exposto",
                                    "Assumir que CSMA/CA detecta colisões como no Ethernet"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o Mecanismo de Handshake RTS/CTS",
                                  "subSteps": [
                                    "Definir Request to Send (RTS) e Clear to Send (CTS) como frames de controle curtos",
                                    "Explicar quando uma estação envia RTS: após carrier sense idle e para frames acima de um threshold RTS",
                                    "Descrever a resposta CTS do receptor, confirmando disponibilidade do canal",
                                    "Detalhar o campo Duration no RTS/CTS, indicando tempo necessário para transmissão de dados + ACK",
                                    "Mostrar como estações vizinhas atualizam seu NAV ao ouvir RTS ou CTS"
                                  ],
                                  "verification": "Escrever a sequência de eventos: Estação A envia RTS → B responde CTS → A transmite dados → B envia ACK.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.11 (seção MAC)",
                                    "Ferramenta Wireshark para capturar frames RTS/CTS",
                                    "Simulador online de redes sem fio"
                                  ],
                                  "tips": "Lembre-se: RTS é como pedir permissão para falar, CTS é a aprovação pública.",
                                  "learningObjective": "Dominar o handshake RTS/CTS como método de reserva física e virtual do meio.",
                                  "commonMistakes": [
                                    "Ignorar que CTS é ouvido por vizinhos de B, não só de A",
                                    "Confundir threshold RTS com tamanho mínimo de frame"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender o Network Allocation Vector (NAV)",
                                  "subSteps": [
                                    "Definir NAV como um timer virtual em cada estação indicando período de busy medium",
                                    "Explicar atualização do NAV: ao receber RTS/CTS com campo Duration, decrementa até zero",
                                    "Descrever reserva virtual: estações deferem transmissão enquanto NAV > 0, mesmo se carrier sense indicar idle",
                                    "Ilustrar como NAV resolve hidden node: vizinhos de A atualizam NAV via RTS, vizinhos de B via CTS",
                                    "Discutir reset do NAV via frames com duração zero ou NAV reset"
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito: 'NAV cria uma reserva temporal silenciosa para todos os nós próximos.'",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama temporal de NAV em ferramentas como Packet Tracer",
                                    "Tutorial sobre frames 802.11",
                                    "Papel para timeline"
                                  ],
                                  "tips": "Visualize NAV como um semáforo virtual que todos respeitam sem precisar ver o tráfego real.",
                                  "learningObjective": "Compreender NAV como mecanismo de deferral distribuído para evitar colisões ocultas.",
                                  "commonMistakes": [
                                    "Pensar que NAV é global em vez de local por estação",
                                    "Esquecer decremento contínuo do timer"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar RTS/CTS/NAV no Processo Completo de CSMA/CA",
                                  "subSteps": [
                                    "Descrever fluxo completo: Sense carrier → Enviar RTS se threshold → Aguardar CTS → Transmitir dados → Receber ACK",
                                    "Explicar mitigação do hidden node: RTS silencia vizinhos de A, CTS silencia vizinhos de B",
                                    "Discutir overhead: frames extras reduzem eficiência para dados pequenos",
                                    "Comparar CSMA/CA com/ sem RTS/CTS em termos de performance",
                                    "Mencionar configurações: RTSThreshold configurável em APs WiFi"
                                  ],
                                  "verification": "Criar um diagrama de sequência temporal mostrando todo o processo com 3 estações e NAV updates.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação como NS-3 ou OMNeT++",
                                    "Wireshark em rede WiFi real",
                                    "Templates de diagrama UML"
                                  ],
                                  "tips": "Use setas temporais para mostrar sobreposições de NAV entre estações.",
                                  "learningObjective": "Sintetizar como RTS/CTS/NAV resolvem coletivamente o hidden node em CSMA/CA.",
                                  "commonMistakes": [
                                    "Omitir ACK final",
                                    "Não mencionar que RTS/CTS é opcional baseado em threshold"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede Wi-Fi doméstica, ao enviar um vídeo grande do laptop (A) para o roteador (B), com um smartphone (C) oculto atrás de uma parede: A envia RTS (ouvido por vizinhos próximos), B responde CTS (ouvido por C), ambos atualizam NAV, evitando que C transmita durante o upload, prevenindo colisão no roteador.",
                              "finalVerifications": [
                                "Explicar o processo RTS/CTS/NAV em suas próprias palavras sem consultar notas",
                                "Desenhar diagrama preciso de hidden node mitigado por RTS/CTS",
                                "Simular captura Wireshark identificando frames RTS/CTS/NAV",
                                "Calcular duração aproximada de reserva para um frame de 1000 bytes",
                                "Discutir cenários onde RTS/CTS não é usado (ex: frames pequenos)",
                                "Comparar eficiência com CSMA puro"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do handshake RTS/CTS e papel do Duration field",
                                "Correta explicação de NAV como reserva virtual distribuída",
                                "Identificação clara de como mitiga especificamente o hidden node problem",
                                "Uso consistente de terminologia técnica (RTS, CTS, NAV, CSMA/CA)",
                                "Inclusão de fluxos completos com carrier sense e ACK",
                                "Análise de overhead e condições de uso"
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas de rádio, atenuação e alcance de sinal em WLANs",
                                "Matemática: Modelagem probabilística de colisões e cálculo de throughput",
                                "Segurança da Informação: RTS/CTS como defesa contra ataques de flooding em redes sem fio",
                                "Engenharia de Software: Design de protocolos distribuídos e timers virtuais",
                                "Estatística: Análise de performance de redes via simulações"
                              ],
                              "realWorldApplication": "Nas redes Wi-Fi IEEE 802.11 (como em casas, escritórios e hotspots públicos), RTS/CTS/NAV gerencia acesso ao espectro ISM compartilhado, evitando colisões em ambientes densos com dispositivos ocultos, melhorando throughput em cenários como streaming de vídeo ou transferências de arquivos em aeroportos lotados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Explicar o algoritmo de backoff exponencial em CSMA/CA",
                            "description": "Detalhar Distributed Coordination Function (DCF): contagem regressiva de slots aleatórios no intervalo de contenção (CWmin a CWmax), congelamento da contagem durante transmissões alheias e incremento do CW após colisões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de CSMA/CA e DCF",
                                  "subSteps": [
                                    "Estude o que é CSMA/CA: Carrier Sense Multiple Access with Collision Avoidance, usado em redes Wi-Fi para evitar colisões.",
                                    "Aprenda sobre a subcamada MAC e o Distributed Coordination Function (DCF) como mecanismo principal de acesso ao meio.",
                                    "Identifique os componentes chave: carrier sensing (CCA), RTS/CTS e backoff.",
                                    "Revise o papel do backoff em cenários de contenção múltipla.",
                                    "Compare CSMA/CA com CSMA/CD para contextualizar."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos de CSMA/CA e DCF, confirmando compreensão sem erros factuais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.11",
                                    "Vídeo tutorial sobre CSMA/CA (YouTube ou Khan Academy)",
                                    "Diagrama de rede Wi-Fi básica"
                                  ],
                                  "tips": "Use analogias como 'escutar antes de falar em uma reunião' para carrier sensing.",
                                  "learningObjective": "Compreender os fundamentos de CSMA/CA e o papel do DCF no controle de acesso.",
                                  "commonMistakes": [
                                    "Confundir CSMA/CA com CSMA/CD",
                                    "Ignorar que DCF é probabilístico",
                                    "Achar que CSMA/CA detecta colisões diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Intervalo de Contenção (CW)",
                                  "subSteps": [
                                    "Defina CW: Contention Window, intervalo inicial CWmin (geralmente 32 slots) até CWmax (1024 slots).",
                                    "Aprenda como CW é inicializado para CWmin após transmissão bem-sucedida.",
                                    "Estude a seleção aleatória: estação escolhe número inteiro aleatório entre 0 e CW-1.",
                                    "Entenda o tamanho do slot: tipicamente 9-20 µs em Wi-Fi.",
                                    "Visualize CW como uma fila de slots de backoff."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando CWmin=32 com um backoff aleatório de 5 selecionado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou ferramenta de desenho como Draw.io",
                                    "Especificação IEEE 802.11 para valores de CW",
                                    "Simulador online de CSMA/CA"
                                  ],
                                  "tips": "Pense no CW como um dado com faces variáveis para aleatoriedade.",
                                  "learningObjective": "Dominar o conceito e operação inicial do Contention Window.",
                                  "commonMistakes": [
                                    "Confundir CWmin com CWmax",
                                    "Achar que backoff é sempre fixo",
                                    "Ignorar reinicialização após sucesso"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Processo de Contagem Regressiva e Congelamento",
                                  "subSteps": [
                                    "Descreva a contagem regressiva: decrementar backoff counter a cada slot idle após carrier sense claro.",
                                    "Aprenda o congelamento: pause contagem se canal ocupado (transmissão detectada).",
                                    "Reinicie contagem quando canal idle novamente, mantendo valor restante.",
                                    "Integre com carrier sensing físico/virtual (CCA).",
                                    "Simule um cenário com 3 estações competindo."
                                  ],
                                  "verification": "Simule manualmente 5 slots com uma transmissão alheia no slot 3 e verifique se backoff congela corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel para simulação de slots",
                                    "Vídeo animação de backoff em CSMA/CA",
                                    "Timer para slots simulados"
                                  ],
                                  "tips": "Use uma tabela de timeline para visualizar idle/busy/congelado.",
                                  "learningObjective": "Explicar dinamicamente a contagem regressiva e mecanismos de pausa.",
                                  "commonMistakes": [
                                    "Decrementar durante busy",
                                    "Resetar backoff no congelamento",
                                    "Ignorar carrier sense antes de decrementar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhar o Backoff Exponencial Após Colisões",
                                  "subSteps": [
                                    "Explique colisão: falta de ACK após transmissão, detectada por timeout.",
                                    "Aprenda incremento: novo CW = min(2*CW_atual, CWmax), selecione novo backoff aleatório.",
                                    "Estude reinicialização: após sucesso, CW volta a CWmin.",
                                    "Calcule exemplos: CW inicia 32, colisão → 64, colisão → 128, etc.",
                                    "Discuta limite de tentativas (tipicamente 7) antes de drop."
                                  ],
                                  "verification": "Calcule sequência de CW para 4 colisões consecutivas e explique reinicialização.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python script simples para CW",
                                    "IEEE 802.11 std para tabelas CW",
                                    "Exemplos de traces Wireshark"
                                  ],
                                  "tips": "Multiplique por 2 mentalmente para visualizar crescimento exponencial.",
                                  "learningObjective": "Compreender o mecanismo adaptativo de backoff exponencial para reduzir colisões.",
                                  "commonMistakes": [
                                    "Incremento linear em vez de exponencial",
                                    "Não limitar a CWmax",
                                    "Confundir colisão com busy normal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede Wi-Fi doméstica com 4 dispositivos (smartphone, laptop, TV, impressora) tentando acessar internet simultaneamente: Dispositivo A escolhe backoff=10 (CW=32). Durante contagem (9,8,...), TV transmite (busy), congela em 7. Após TV terminar, continua (6,5,... até 0) e transmite. Se colisão (sem ACK), CW dobra para 64, novo backoff aleatório.",
                              "finalVerifications": [
                                "Diagramar timeline completo de backoff com congelamento e colisão.",
                                "Explicar verbalmente o processo para um par, respondendo dúvidas.",
                                "Simular 3 rodadas em papel com múltiplas estações.",
                                "Identificar erros em um diagrama fornecido de backoff incorreto.",
                                "Calcular CW após 3 colisões (32→64→128→256)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: uso correto de termos como CW, backoff counter, DCF.",
                                "Clareza na explicação: uso de diagramas e analogias eficazes.",
                                "Completude: cobrir inicialização, contagem, congelamento e exponencial.",
                                "Exemplos práticos: relevância para cenários reais como Wi-Fi.",
                                "Compreensão de exceções: limites CWmax e reinicialização."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: aleatoriedade no backoff reduz colisões.",
                                "Física: conceitos de sinal sem fio e detecção de carrier.",
                                "Matemática: crescimento exponencial e funções min/max.",
                                "Engenharia de Software: algoritmos distribuídos e concorrência."
                              ],
                              "realWorldApplication": "Implementado em todos os roteadores Wi-Fi (IEEE 802.11) para gerenciar acesso em redes densas como aeroportos ou escritórios, reduzindo colisões e melhorando throughput em até 50% em ambientes congestionados."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Comparar CSMA/CA com CSMA/CD em termos de eficiência",
                            "description": "Analisar overhead adicional do CSMA/CA (RTS/CTS), adequação a meios sem fio com alta latência de propagação, e impacto na taxa de throughput em cenários de alta densidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos do CSMA/CD",
                                  "subSteps": [
                                    "Estude o protocolo CSMA/CD usado em redes Ethernet cabeadas.",
                                    "Identifique as etapas: Carrier Sense (escuta o meio), Multiple Access (transmissão se livre), Collision Detection (detecta colisão durante transmissão).",
                                    "Analise o mecanismo de backoff exponencial após colisão.",
                                    "Discuta limitações em meios com alta latência de propagação.",
                                    "Calcule o tempo mínimo de detecção de colisão (2 * tempo de propagação)."
                                  ],
                                  "verification": "Desenhe um fluxograma do processo CSMA/CD e explique verbalmente para um colega.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Slides ou capítulo de livro sobre Ethernet (ex: Kurose & Ross), papel e caneta para diagrama"
                                  ],
                                  "tips": "Foquem no fato de que CSMA/CD requer detecção física de colisão, eficiente em cabos com baixa latência.",
                                  "learningObjective": "Compreender o mecanismo de detecção de colisão em redes cabeadas compartilhadas.",
                                  "commonMistakes": [
                                    "Confundir backoff com RTS/CTS",
                                    "Ignorar que CSMA/CD é ineficiente em longas distâncias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os Fundamentos do CSMA/CA",
                                  "subSteps": [
                                    "Estude o CSMA/CA usado em WiFi (IEEE 802.11).",
                                    "Descreva Carrier Sense (físico e virtual), Multiple Access e Collision Avoidance via RTS/CTS.",
                                    "Explique o problema do 'terminal oculto' em wireless devido à latência de propagação.",
                                    "Detalhe o handshake RTS/CTS/ACK para reserva de canal.",
                                    "Compare com CSMA sem avoidance."
                                  ],
                                  "verification": "Crie um diagrama comparando CSMA simples com CSMA/CA incluindo RTS/CTS.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.11, simulador como NS-3 ou Wireshark capture de WiFi"
                                  ],
                                  "tips": "Lembre-se: sem detecção de colisão em wireless, avoidance é preventivo.",
                                  "learningObjective": "Dominar o mecanismo de avoidance de colisão adaptado a ambientes sem fio.",
                                  "commonMistakes": [
                                    "Achar que CSMA/CA detecta colisões como CD",
                                    "Subestimar overhead de controle"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Overhead e Mecanismos de Controle",
                                  "subSteps": [
                                    "Calcule overhead do CSMA/CD: apenas retransmissões após colisão detectada.",
                                    "Quantifique overhead do CSMA/CA: frames RTS/CTS (20+14 bytes cada) + DIFS + backoff.",
                                    "Simule impacto em throughput: Throughput = (tamanho payload) / (tempo total incluindo overhead).",
                                    "Discuta NAV (Network Allocation Vector) para reserva virtual.",
                                    "Compare eficiência em baixa vs alta taxa de colisão."
                                  ],
                                  "verification": "Realize um cálculo simples de throughput para um cenário com 50% colisões em ambos protocolos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel, fórmulas de throughput de Tanenbaum"
                                  ],
                                  "tips": "Use fórmulas aproximadas: Overhead CSMA/CA ~ 20-50% em redes densas.",
                                  "learningObjective": "Quantificar o custo adicional de prevenção vs detecção de colisões.",
                                  "commonMistakes": [
                                    "Ignorar SIFS/DIFS no cálculo",
                                    "Não considerar tamanho de frame"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Eficiência em Cenários Específicos",
                                  "subSteps": [
                                    "Compare em cenários cabeados (baixa latência): CSMA/CD mais eficiente.",
                                    "Analise wireless alta densidade: CSMA/CA melhor via RTS/CTS para evitar hidden nodes.",
                                    "Avalie throughput em alta latência: CSMA/CD falha, CSMA/CA adapta.",
                                    "Discuta impacto em redes modernas (switched Ethernet sem CSMA/CD).",
                                    "Conclua com tabela de prós/contras por cenário."
                                  ],
                                  "verification": "Crie uma tabela comparativa com métricas de eficiência (throughput, overhead, adequação).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de tabela (Google Sheets), exemplos de simulações online"
                                  ],
                                  "tips": "Considere densidade: CSMA/CA brilha em >10 nodes próximos.",
                                  "learningObjective": "Aplicar comparação quantitativa e qualitativa de eficiência.",
                                  "commonMistakes": [
                                    "Generalizar sem cenários",
                                    "Esquecer evolução para full-duplex"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma cafeteria lotada com 20 laptops conectados ao WiFi (alta densidade), CSMA/CA usa RTS/CTS para evitar colisões ocultas, adicionando ~30% overhead mas mantendo throughput estável; em uma LAN Ethernet antiga compartilhada, CSMA/CD detectaria colisões rapidamente com baixo overhead, mas falharia se a distância fosse longa.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave entre CSMA/CD e CSMA/CA.",
                                "Calcular overhead aproximado de RTS/CTS para um frame de 1000 bytes.",
                                "Identificar cenário onde CSMA/CA é superior (ex: wireless denso).",
                                "Desenhar diagrama de hidden node e como RTS/CTS resolve.",
                                "Listar impactos no throughput em alta latência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de mecanismos (detecção vs avoidance).",
                                "Correta quantificação de overhead (RTS/CTS vs retransmissões).",
                                "Análise contextualizada por cenários (wired/wireless, densidade).",
                                "Uso de evidências quantitativas (cálculos de throughput).",
                                "Clareza na tabela ou diagrama comparativo.",
                                "Identificação de limitações modernas (ex: switched networks)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Latência de propagação em sinais de rádio vs cabos.",
                                "Matemática: Modelos probabilísticos de colisão e backoff exponencial.",
                                "Estatística: Análise de throughput e simulações Monte Carlo.",
                                "Engenharia de Software: Design de protocolos tolerantes a falhas."
                              ],
                              "realWorldApplication": "Em redes WiFi empresariais densas (ex: escritórios abertos), CSMA/CA otimiza eficiência apesar do overhead, enquanto CSMA/CD foi crucial em LANs Ethernet antigas; hoje, ajuda a escolher infraestruturas híbridas para IoT ou 5G."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Mecanismos baseados em Token Passing",
                        "description": "Protocolos de controle de acesso determinístico nos padrões IEEE 802.4 (Token Bus) e 802.5 (Token Ring), onde um token especial circula entre estações, garantindo acesso exclusivo e evitando colisões em redes LAN compartilhadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Descrever o funcionamento do Token Ring (IEEE 802.5)",
                            "description": "Explicar a topologia lógica em anel, inserção do token pelo monitor principal, transmissão com prioridade, detecção de erros via trailer e remoção do quadro pelo transmissor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Topologia Lógica em Anel do Token Ring",
                                  "subSteps": [
                                    "Estude a estrutura física (estrela) versus lógica (anel lógico fechado).",
                                    "Identifique as estações conectadas em um loop lógico unidirecional.",
                                    "Aprenda sobre o fluxo contínuo de bits em alta velocidade no anel.",
                                    "Diferencie topologia física de estrela (hub central) da lógica em anel.",
                                    "Visualize o token circulando apenas em uma direção."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando topologias física e lógica e rotule as componentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Vídeo explicativo sobre Token Ring no YouTube",
                                    "Diagrama oficial IEEE 802.5"
                                  ],
                                  "tips": "Use setas para indicar direção do token e cor para diferenciar físico/lógico.",
                                  "learningObjective": "Explicar e diferenciar topologias física e lógica do Token Ring.",
                                  "commonMistakes": [
                                    "Confundir topologia física com Ethernet bus",
                                    "Ignorar que o anel é lógico, não físico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Papel do Monitor Principal e Inserção do Token",
                                  "subSteps": [
                                    "Descreva o monitor principal como a estação ativa que gerencia o anel.",
                                    "Aprenda como o monitor insere o token de 3 bytes quando o anel está ocioso.",
                                    "Estude o processo de inicialização do anel pelo monitor.",
                                    "Identifique funções adicionais do monitor: detecção de falhas e limpeza.",
                                    "Simule o ciclo: token livre circula até ser capturado."
                                  ],
                                  "verification": "Liste as funções do monitor principal e explique o formato básico do token.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro 'Redes de Computadores' de Tanenbaum (cap. MAC)",
                                    "Simulador de redes online (NetSim ou similar)",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Memorize o token como MAC frame especial: SD, AC, FC (3 bytes).",
                                  "learningObjective": "Descrever o mecanismo de inserção e gerenciamento do token pelo monitor.",
                                  "commonMistakes": [
                                    "Pensar que qualquer estação insere o token",
                                    "Confundir monitor com hub"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Transmissão de Quadros com Prioridade",
                                  "subSteps": [
                                    "Explique como uma estação captura o token livre e o converte em ocupado.",
                                    "Estude a estrutura do quadro de dados: header, info, trailer (FCS).",
                                    "Aprenda sobre prioridade: bits AC (Access Control) definem níveis (0-7).",
                                    "Descreva transmissão: quadro circula até destino, que copia dados e marca.",
                                    "Entenda liberação: transmissor remove quadro e reinjeta token."
                                  ],
                                  "verification": "Escreva a sequência de transmissão passo a passo para uma estação enviando dados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Diagramas de frames Token Ring",
                                    "Software de simulação Cisco Packet Tracer",
                                    "Tabela de prioridades IEEE 802.5"
                                  ],
                                  "tips": "Pense no token como 'permissão única' para evitar colisões.",
                                  "learningObjective": "Explicar transmissão priorizada e estrutura do quadro no Token Ring.",
                                  "commonMistakes": [
                                    "Confundir com CSMA/CD do Ethernet",
                                    "Ignorar marcação de quadro pelo receptor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Detecção de Erros, Trailer e Remoção do Quadro",
                                  "subSteps": [
                                    "Analise o trailer FCS para detecção de erros de CRC.",
                                    "Descreva detecção de erros pelo monitor: frames órfãos ou beaconing.",
                                    "Aprenda remoção: transmissor reconhece seu quadro (A bit) e remove.",
                                    "Estude purificação do anel pelo monitor em falhas.",
                                    "Revise ciclo completo: token volta livre após transmissão."
                                  ],
                                  "verification": "Identifique e explique 3 mecanismos de detecção/remoção de erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Especificação IEEE 802.5 PDF",
                                    "Vídeos de falhas em Token Ring",
                                    "Quiz online sobre MAC Token Passing"
                                  ],
                                  "tips": "Foco no 'A' e 'C' bits no header para controle de quadro.",
                                  "learningObjective": "Descrever detecção de erros e processo de remoção do quadro.",
                                  "commonMistakes": [
                                    "Achar que receptor remove o quadro",
                                    "Subestimar papel do trailer FCS"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma rede Token Ring com 4 estações usando papel e caneta ou Packet Tracer: Estação A (monitor) insere token; B captura, envia quadro para D; D copia dados, quadro volta a B para remoção; token reinserido. Demonstre prioridade alta interrompendo transmissão normal.",
                              "finalVerifications": [
                                "Desenhar diagrama completo de topologia e fluxo de token.",
                                "Explicar verbalmente o ciclo de transmissão de um quadro.",
                                "Identificar diferenças chave vs. Ethernet.",
                                "Listar funções do monitor principal.",
                                "Simular detecção de erro em um cenário falho.",
                                "Descrever mecanismo de prioridade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da topologia lógica vs. física (20%)",
                                "Correta explicação do token e seu ciclo (25%)",
                                "Detalhamento de transmissão, prioridade e remoção (25%)",
                                "Uso correto de termos técnicos IEEE 802.5 (15%)",
                                "Identificação de mecanismos de erro (10%)",
                                "Clareza em diagramas e exemplos (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos (ciclos direcionados e caminhos eulerianos).",
                                "Física: Propagação de sinais em loops e latência em redes.",
                                "História: Evolução de redes LAN nos anos 80 (IBM Token Ring).",
                                "Engenharia: Design determinístico vs. probabilístico em sistemas.",
                                "Lógica/Algoritmos: Controle distribuído e mutex em programação concorrente."
                              ],
                              "realWorldApplication": "Token Ring foi amplamente usado em ambientes corporativos IBM para redes de alta confiabilidade e determinística, como em bancos e indústrias, evitando colisões do Ethernet; conceitos influenciam FDDI em fibra ótica e switches modernos com QoS priorizado."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Explicar o Token Bus (IEEE 802.4) e sua estrutura lógica",
                            "description": "Detalhar topologia física bus com anel lógico, passagem de token por ordem de endereços lógicos, alocação de estações e recuperação de falhas no token.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Topologia Física e Lógica do Token Bus",
                                  "subSteps": [
                                    "Pesquise a definição do IEEE 802.4 e identifique que usa topologia física em barramento (bus).",
                                    "Compare com topologias tradicionais: explique como o barramento físico permite conexões lineares com terminadores.",
                                    "Desenhe um diagrama simples mostrando estações conectadas em um cabo coaxial compartilhado.",
                                    "Introduza o conceito de anel lógico: estações organizadas em ordem lógica independente da posição física.",
                                    "Liste vantagens: previsibilidade no acesso ao meio apesar da topologia física compartilhada."
                                  ],
                                  "verification": "Crie um diagrama anotado diferenciando topologia física (bus) da lógica (anel) e explique em voz alta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Recursos online sobre IEEE 802.4 (Wikipedia, IEEE standards summary)"
                                  ],
                                  "tips": "Use cores diferentes no diagrama: azul para físico, vermelho para lógico, para visualizar melhor.",
                                  "learningObjective": "Compreender a distinção fundamental entre topologias física e lógica no Token Bus.",
                                  "commonMistakes": [
                                    "Confundir topologia física com lógica, assumindo que o anel é físico; ignorar o uso de cabo coaxial."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar a Passagem de Token por Ordem de Endereços Lógicos",
                                  "subSteps": [
                                    "Defina o token como um quadro especial (controle de acesso) que circula no anel lógico.",
                                    "Descreva o processo: estação receptora do token transmite por tempo máximo (THT - Token Holding Time), então passa para próxima estação lógica.",
                                    "Explique endereçamento: cada estação tem endereço lógico de 48 bits, ordenados numericamente no anel virtual.",
                                    "Simule com 4 estações (endereços 1, 3, 5, 8): token vai 1→3→5→8→1.",
                                    "Discuta prioridades: tokens de alta/baixa prioridade e como afetam a passagem."
                                  ],
                                  "verification": "Simule manualmente a passagem de token em uma tabela com 5 estações e verifique o ciclo completo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela de simulação",
                                    "Documentação IEEE 802.4 sobre frames de token"
                                  ],
                                  "tips": "Pense no token como uma 'batata quente': só quem tem pode transmitir, evitando colisões.",
                                  "learningObjective": "Dominar o mecanismo de rotação sequencial do token baseado em endereços lógicos.",
                                  "commonMistakes": [
                                    "Achar que ordem física determina passagem; esquecer limites de tempo como THT."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Alocação de Estações e Gerenciamento de Endereços",
                                  "subSteps": [
                                    "Explique alocação dinâmica: novas estações solicitam inserção via Solicit Maintenance frame.",
                                    "Descreva processo: controlador envia Solicit, estações respondem com Set Station Address, inseridas em ordem lógica.",
                                    "Discuta estações passivas vs ativas: passivas monitoram, ativas participam do anel.",
                                    "Aborde remoção: via Resolve/Request/Delete frames para manter integridade do anel.",
                                    "Liste limites: máximo 1000 estações, endereços únicos garantidos por algoritmo."
                                  ],
                                  "verification": "Descreva passos para inserir uma nova estação em um anel existente com endereços 10, 20, 30.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Diagramas de frames MAC do Token Bus",
                                    "Vídeos tutoriais sobre alocação em redes token"
                                  ],
                                  "tips": "Memorize acrônimos: Solicit Maintenance (SM), Set Station Address (SSA) para fixar o fluxo.",
                                  "learningObjective": "Compreender como o Token Bus gerencia dinamicamente estações no anel lógico.",
                                  "commonMistakes": [
                                    "Ignorar alocação dinâmica, assumindo configuração estática; confundir frames de alocação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Recuperação de Falhas no Token",
                                  "subSteps": [
                                    "Identifique falhas comuns: perda de token, estação falha, duplicação.",
                                    "Explique temporizadores: estações monitoram ausência (Token Rotation Time - TRT), iniciam recuperação se excedido.",
                                    "Descreva Claim Token: estações competem transmitindo Claim frames, vencedor reinicia anel.",
                                    "Para duplicação: Resolve Token frame detecta e corrige.",
                                    "Simule falha: estação 2 falha, próxima (3) detecta e inicia Claim após timeout."
                                  ],
                                  "verification": "Escreva um fluxograma da recuperação de token perdido e teste com cenário hipotético.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma online (Draw.io)",
                                    "Especificação IEEE 802.4 seção de recovery"
                                  ],
                                  "tips": "Lembre: recuperação é distribuída, sem mestre central, aumentando resiliência.",
                                  "learningObjective": "Mestre os mecanismos robustos de detecção e recuperação de falhas no Token Bus.",
                                  "commonMistakes": [
                                    "Achar recuperação centralizada; subestimar papel dos temporizadores TRT."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma rede Token Bus com 4 estações industrias em uma fábrica: Estação A (controle PLC, addr 001), B (sensores, 005), C (motores, 010), D (supervisão, 020). Token inicia em A, B transmite dados de sensor por 2s (dentro THT), passa para C que falha - D detecta timeout, inicia Claim Token, reinicia anel como A→C(falhosa ignorada)→D→B.",
                              "finalVerifications": [
                                "Desenhe e explique diagrama topologia física vs lógica.",
                                "Simule ciclo completo de token com 5 estações numeradas.",
                                "Liste passos exatos para alocar nova estação.",
                                "Descreva recuperação de token perdido com temporizadores.",
                                "Compare Token Bus com Token Ring (IEEE 802.5).",
                                "Identifique frames chave: Token, Solicit, Claim."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção topologia física (bus) e lógica (anel).",
                                "Correta descrição da rotação sequencial por endereços lógicos.",
                                "Detalhe completo de alocação dinâmica de estações.",
                                "Explicação robusta de mecanismos de recuperação de falhas.",
                                "Uso correto de terminologia IEEE 802.4 (THT, TRT, frames).",
                                "Capacidade de simular cenários práticos sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Ordenação e algoritmos de endereçamento lógico (sequências numéricas).",
                                "Física: Propagação de sinais em barramento coaxial e detecção de colisões evitadas.",
                                "História da Computação: Evolução de MAC protocols nos anos 80 para automação industrial.",
                                "Engenharia: Aplicações em protocolos MAP para manufatura.",
                                "Probabilidade: Análise de tempos de timeout e falhas distribuídas."
                              ],
                              "realWorldApplication": "Token Bus (IEEE 802.4) foi base para MAP em automação fabril, garantindo acesso determinístico em ambientes ruidosos industriais; conceitos aplicados hoje em redes TSN (Time-Sensitive Networking) para IoT industrial e veículos autônomos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Analisar vantagens determinísticas sobre métodos de contenção",
                            "description": "Comparar latência previsível e garantia de largura de banda (ex: timed token rotation) versus ineficiência em baixas cargas dos métodos CSMA, e razões para obsolescência frente a Ethernet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Métodos de Contenção (CSMA)",
                                  "subSteps": [
                                    "Estude o protocolo CSMA/CD e suas variantes (ex: 802.3 Ethernet clássico).",
                                    "Analise como estações 'ouvem antes de falar' e colisões ocorrem em cargas altas.",
                                    "Calcule eficiência aproximada: Eficiência = 1 / (1 + 6.44a) onde a é relação propagação/tempo slot.",
                                    "Identifique não-determinismo: latência variável devido a backoffs exponenciais.",
                                    "Registre exemplos de cenários de baixa carga (alta eficiência) vs. alta carga (colisões frequentes)."
                                  ],
                                  "verification": "Crie um diagrama de sequência mostrando uma colisão CSMA/CD resolvida e meça latência simulada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.3",
                                    "Ferramenta de simulação como NS-3 ou Wireshark",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use animações online de CSMA para visualizar colisões; foque em probabilidades de colisão.",
                                  "learningObjective": "Compreender o comportamento probabilístico e ineficiências de CSMA em diferentes cargas.",
                                  "commonMistakes": [
                                    "Confundir CSMA/CD com CSMA/CA",
                                    "Ignorar impacto da topologia bus em colisões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Mecanismos Baseados em Token Passing",
                                  "subSteps": [
                                    "Descreva o Token Ring (IEEE 802.5) e FDDI (IEEE 802.2) com rotação de token.",
                                    "Explique Timed Token Rotation: token tem tempo limite para rotação rápida em baixa carga.",
                                    "Detalhe como token garante acesso sequencial e evita colisões.",
                                    "Calcule latência máxima: soma de tempos de transmissão de frames + rotação.",
                                    "Compare com Priority Token Rotation para tráfego isócrono."
                                  ],
                                  "verification": "Desenhe um anel com 4 estações e simule rotação de token com frames de tamanhos variados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação IEEE 802.5 e 802.4",
                                    "Simulador de rede como Cisco Packet Tracer",
                                    "Vídeos tutoriais sobre Token Ring"
                                  ],
                                  "tips": "Lembre-se: token é passado mesmo sem dados para manter determinismo.",
                                  "learningObjective": "Dominar o funcionamento determinístico do token passing e suas garantias temporais.",
                                  "commonMistakes": [
                                    "Achar que token passing é centralizado",
                                    "Confundir rotação síncrona com assíncrona"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Vantagens Determinísticas: Latência e Largura de Banda",
                                  "subSteps": [
                                    "Compare latência: CSMA (imprevisível, média + variância alta) vs. Token (máxima conhecida: N * T_frame + T_rot).",
                                    "Analise garantia de BW: Token reserva slots; CSMA aloca dinamicamente mas perde em colisões.",
                                    "Quantifique ineficiência CSMA em baixa carga: overhead de carrier sense desnecessário.",
                                    "Use fórmulas: Throughput CSMA cai para <50% em alta carga; Token mantém >90%.",
                                    "Crie tabela comparativa com métricas: latência média/máx, jitter, eficiência."
                                  ],
                                  "verification": "Preencha e valide uma tabela comparativa com cenários de 10 estações, 20% e 80% carga.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para cálculos",
                                    "Referências acadêmicas sobre MAC protocols",
                                    "Calculadora"
                                  ],
                                  "tips": "Foquem em aplicações real-time: Token ideal para voz/vídeo onde jitter importa.",
                                  "learningObjective": "Quantificar superioridade determinística do token passing sobre contenção.",
                                  "commonMistakes": [
                                    "Subestimar jitter em CSMA para tráfego real-time",
                                    "Ignorar overhead de token em redes pequenas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Obsolescência Frente à Ethernet Moderna",
                                  "subSteps": [
                                    "Discuta evoluções Ethernet: switches full-duplex eliminam colisões (CSMA/CD obsoleto).",
                                    "Compare custos: Token requer anéis duplos para redundância vs. Ethernet star simples.",
                                    "Avalie escalabilidade: Token sofre com falhas de nó; Ethernet usa spanning tree.",
                                    "Liste razões: Custo, simplicidade, velocidade Gigabit+ sem determinismo via QoS.",
                                    "Conclua com nichos remanescentes: redes industriais (Token ainda usado em Profibus)."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo 3 razões principais de obsolescência com evidências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigos sobre história Ethernet vs Token Ring",
                                    "Documentação IEEE 802.1Q para QoS"
                                  ],
                                  "tips": "Pesquise casos reais: IBM Token Ring vs. Ethernet dominance nos anos 90.",
                                  "learningObjective": "Entender contexto histórico e razões práticas para adoção de Ethernet.",
                                  "commonMistakes": [
                                    "Achar Ethernet não-determinístico em full-duplex",
                                    "Ignorar VLANs/QoS como substitutos"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma rede industrial com 8 sensores enviando dados periódicos: use CSMA e observe atrasos variáveis >100ms em picos; mude para Token Passing e garanta latência <50ms máxima, medindo com Wireshark.",
                              "finalVerifications": [
                                "Explica corretamente latência máxima em token passing vs. média em CSMA.",
                                "Identifica ineficiência CSMA em baixa carga com exemplo numérico.",
                                "Lista 3 vantagens determinísticas com fórmulas ou diagramas.",
                                "Descreve razões de obsolescência vs. Ethernet moderna.",
                                "Cria tabela comparativa precisa de métricas chave.",
                                "Aplica conceitos a cenário real-time como automação fabril."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (correta distinção determinístico vs. probabilístico): 25%",
                                "Uso de evidências quantitativas (fórmulas, tabelas): 25%",
                                "Análise de vantagens e desvantagens balanceada: 20%",
                                "Conexão com obsolescência histórica: 15%",
                                "Clareza e estrutura da explicação: 15%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos probabilísticos e cálculo de throughput (Estatística).",
                                "Física: Propagação de sinais em meios compartilhados (Ondas e delays).",
                                "Engenharia: Análise de sistemas de controle e QoS (Automação).",
                                "História da Tecnologia: Evolução de padrões IEEE (Inovação tecnológica)."
                              ],
                              "realWorldApplication": "Em redes industriais SCADA (ex: usinas elétricas), token passing garantia determinismo para comandos críticos; hoje, Ethernet TSN (Time-Sensitive Networking) revive conceitos para Indústria 4.0, evitando falhas por jitter em CSMA legado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 287
          }
        ],
        "totalSkills": 287
      }
    ]
  }
}