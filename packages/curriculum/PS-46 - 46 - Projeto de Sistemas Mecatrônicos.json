{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T16:35:55.803Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - PS-46",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 267,
      "startDate": "2025-02-17",
      "duration": "5 anos",
      "dailyStudyHours": 8,
      "version": "PS-46/2025",
      "institution": "Instituto Tecnológico de Aeronáutica (ITA)",
      "basedOn": "Catálogo dos Cursos de Graduação 2025 - PS-46"
    },
    "areas": [
      {
        "id": "10",
        "name": "Mecatrônica",
        "description": "Área dedicada ao desenvolvimento integrado de sistemas mecatrônicos, robótica e automação com aplicações industriais.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "PS-46 - Projeto de Sistemas Mecatrônicos",
            "description": "Desenvolvimento Integrado de Produtos: técnicas de projeto e times multifuncionais. Introdução a sistemas de visão por computador. Introdução à robótica com aplicações mecatrônicas na indústria aeronáutica. Microprocessadores, microcontroladores e CLPs. Elaboração e execução de projetos de sistemas mecatrônicos e microcontrolados. Bibliografia: CROSS, N. Engineering design methods. Chichester: Wiley, 2004. LYSHEVSKI, S. E. Electromechanical systems, electric machines, and applied mechatronics. Boca Raton: CRC Press, 1999. SHETTY, D.; KOLK, R. Mechatronics system design. Londres: Brooks/Cole, 1997.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Desenvolvimento Integrado de Produtos",
                "description": "Técnicas de projeto e trabalho em times multifuncionais para o desenvolvimento de produtos mecatrônicos.",
                "totalSkills": 59,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Técnicas de Projeto Integrado",
                    "description": "Métodos e abordagens para o desenvolvimento de produtos mecatrônicos de forma integrada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Times Multifuncionais e Técnicas de Projeto Integrado",
                        "description": "Métodos para formação de equipes multidisciplinares e técnicas como engenharia concorrente para integrar mecânica, eletrônica e software no desenvolvimento de produtos mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Formação de Times Multifuncionais",
                            "description": "Identificar e integrar profissionais de diferentes áreas (mecânica, eletrônica, software) para colaboração eficiente em projetos mecatrônicos, promovendo comunicação e resolução de conflitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise de Necessidades do Projeto e Perfis Requeridos",
                                  "subSteps": [
                                    "Realize uma análise detalhada do escopo do projeto mecatrônico, identificando fases como design mecânico, desenvolvimento eletrônico e programação de software.",
                                    "Mapeie as competências essenciais necessárias para cada área (ex.: engenheiro mecânico para estruturas, eletrônica para circuitos, software para controle).",
                                    "Defina papéis multifuncionais, considerando sobreposições como integração de sensores.",
                                    "Crie um organograma preliminar do time, destacando responsabilidades e interdependências.",
                                    "Priorize perfis com habilidades complementares e experiência em colaboração interdisciplinar."
                                  ],
                                  "verification": "Documento de análise de necessidades aprovado pelo líder do projeto, com lista clara de perfis e justificativas.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ferramentas de mapeamento como Miro ou Excel",
                                    "Descrição detalhada do projeto",
                                    "Matriz de competências (template)"
                                  ],
                                  "tips": "Envolva stakeholders iniciais para validar as necessidades e evitar subestimação de skills soft.",
                                  "learningObjective": "Compreender como alinhar necessidades do projeto com perfis profissionais multifuncionais.",
                                  "commonMistakes": [
                                    "Ignorar skills de comunicação ao focar só em técnicas",
                                    "Sobrecarregar um perfil com múltiplas áreas sem suporte",
                                    "Não considerar disponibilidade de profissionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recrutamento e Seleção de Membros do Time",
                                  "subSteps": [
                                    "Publique chamadas internas/externas destacando o caráter multifuncional do projeto mecatrônico.",
                                    "Realize entrevistas técnicas e comportamentais, avaliando fit cultural e experiência interdisciplinar.",
                                    "Aplique testes práticos simulando integração (ex.: discussão de um problema mecatrônico híbrido).",
                                    "Selecione candidatos com equilíbrio entre áreas (mecânica, eletrônica, software) e diversidade.",
                                    "Formalize convites com descrições claras de papéis e expectativas de colaboração."
                                  ],
                                  "verification": "Lista de membros selecionados com currículos revisados e atas de entrevistas arquivadas.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Plataformas de recrutamento como LinkedIn",
                                    "Questionários de avaliação comportamental",
                                    "Simuladores de projetos mecatrônicos"
                                  ],
                                  "tips": "Busque diversidade de backgrounds para enriquecer perspectivas e inovação.",
                                  "learningObjective": "Dominar técnicas de seleção que garantam integração eficiente de experts multidisciplinares.",
                                  "commonMistakes": [
                                    "Selecionar apenas experts técnicos sem avaliar teamwork",
                                    "Ignorar conflitos potenciais de agendas",
                                    "Não comunicar visão do projeto claramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integração Inicial e Alinhamento do Time",
                                  "subSteps": [
                                    "Realize uma reunião de kick-off para apresentar o projeto e papéis individuais.",
                                    "Estabeleça normas de comunicação (ferramentas como Slack, reuniões semanais) e protocolos de integração.",
                                    "Defina metas compartilhadas e KPIs para colaboração mecatrônica.",
                                    "Promova icebreakers focados em experiências interdisciplinares passadas.",
                                    "Crie um plano de onboarding com treinamentos cruzados (ex.: mecânico aprende basics de software)."
                                  ],
                                  "verification": "Atas da reunião de kick-off assinadas por todos e plano de comunicação implementado.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ferramentas colaborativas (Slack, Trello)",
                                    "Templates de normas de time",
                                    "Vídeos introdutórios de áreas parceiras"
                                  ],
                                  "tips": "Use dinâmicas gamificadas para quebrar gelo e construir confiança rapidamente.",
                                  "learningObjective": "Implementar práticas de onboarding que fomentem alinhamento e comunicação desde o início.",
                                  "commonMistakes": [
                                    "Pular kick-off por 'falta de tempo'",
                                    "Não definir canais de comunicação claros",
                                    "Ignorar barreiras culturais entre áreas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Promoção de Colaboração e Resolução de Conflitos",
                                  "subSteps": [
                                    "Monitore interações diárias e facilite reuniões de integração para discussões conjuntas.",
                                    "Implemente metodologias ágeis como Scrum adaptado para mecatrônica, com daily stand-ups.",
                                    "Treine o time em resolução de conflitos (técnica de Thomas-Kilmann) com exemplos interdisciplinares.",
                                    "Celebre conquistas conjuntas para reforçar coesão.",
                                    "Avalie dinâmicas periodicamente e ajuste composições se necessário."
                                  ],
                                  "verification": "Relatório de progresso com feedback do time e ausência de conflitos não resolvidos.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Guia de resolução de conflitos",
                                    "Ferramentas ágeis (Jira)",
                                    "Formulários de feedback anônimo"
                                  ],
                                  "tips": "Intercale treinamentos técnicos com sessões de team building para equilíbrio.",
                                  "learningObjective": "Desenvolver habilidades para sustentar colaboração eficiente e gerenciar conflitos em times multifuncionais.",
                                  "commonMistakes": [
                                    "Deixar conflitos escalarem por medo de confronto",
                                    "Focar só em tarefas, ignorando relações interpessoais",
                                    "Não adaptar metodologias a ritmos multidisciplinares"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliação e Otimização Contínua do Time",
                                  "subSteps": [
                                    "Colete feedback 360° sobre desempenho colaborativo.",
                                    "Meça métricas como tempo de integração de subsistemas e taxa de resolução de issues.",
                                    "Identifique gaps e planeje treinamentos ou realocações.",
                                    "Documente lições aprendidas para projetos futuros.",
                                    "Formalize relatório final de formação de time."
                                  ],
                                  "verification": "Relatório de avaliação com métricas e plano de ação implementado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de survey (Google Forms)",
                                    "Dashboards de KPIs",
                                    "Template de lições aprendidas"
                                  ],
                                  "tips": "Torne avaliações regulares e construtivas para cultura de melhoria contínua.",
                                  "learningObjective": "Estabelecer ciclos de feedback para evolução sustentável do time multifuncional.",
                                  "commonMistakes": [
                                    "Avaliar só resultados técnicos, ignorando dinâmica de time",
                                    "Não agir sobre feedbacks identificados",
                                    "Tratar avaliação como evento único"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de desenvolvimento de um braço robótico mecatrônico, formar um time com engenheiro mecânico (design de juntas), eletrônico (sensores e atuadores) e desenvolvedor de software (controle PID), usando reuniões ágeis para integrar o protótipo funcional em 4 semanas.",
                              "finalVerifications": [
                                "Time multifuncional formado com equilíbrio de áreas (mecânica, eletrônica, software).",
                                "Plano de comunicação e normas estabelecidos e em uso.",
                                "Primeiro milestone de integração alcançado sem conflitos maiores.",
                                "Feedback positivo de membros sobre coesão (nota >8/10).",
                                "Documentação completa de perfis, papéis e lições aprendidas.",
                                "Métricas de colaboração mostram eficiência (ex.: issues resolvidos <48h)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de perfis necessários (cobertura 100% das áreas).",
                                "Efetividade do processo de seleção (taxa de retenção >90%).",
                                "Qualidade do alinhamento inicial (ausência de mal-entendidos em kick-off).",
                                "Habilidade em resolução de conflitos (resolução em <2 reuniões).",
                                "Sustentabilidade da colaboração (melhoria em KPIs ao longo do projeto).",
                                "Documentação e relatórios claros e acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Uso de metodologias ágeis em times multidisciplinares.",
                                "Psicologia Organizacional: Dinâmicas de grupo e resolução de conflitos.",
                                "Comunicação Empresarial: Ferramentas e protocolos para colaboração remota.",
                                "Liderança e Team Building: Técnicas de motivação interdisciplinar.",
                                "Ética Profissional: Promoção de diversidade e inclusão em times técnicos."
                              ],
                              "realWorldApplication": "Na indústria automotiva, como na formação de times para desenvolvimento de veículos elétricos autônomos na Bosch ou Tesla, onde mecânicos, eletrônicos e programadores colaboram para integrar powertrains, sensores e IA, reduzindo time-to-market em 30%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Engenharia Concorrente",
                            "description": "Aplicar princípios de desenvolvimento paralelo de subsistemas mecânicos, eletrônicos e de controle para reduzir tempo de ciclo e otimizar o design integrado de produtos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Fundamentais da Engenharia Concorrente",
                                  "subSteps": [
                                    "Estudar definições e benefícios da engenharia concorrente, como redução de tempo de ciclo e otimização integrada.",
                                    "Analisar diagramas de fluxo tradicional vs. concorrente em projetos mecatrônicos.",
                                    "Identificar riscos e mitigações associados ao desenvolvimento paralelo.",
                                    "Revisar casos de estudo de indústrias como automotiva e aeroespacial.",
                                    "Mapear subsistemas típicos: mecânico, eletrônico e de controle."
                                  ],
                                  "verification": "Resumir em um relatório os princípios chave e diferenças com métodos sequenciais, com pelo menos 3 exemplos.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Concurrent Engineering in Product Design and Development', artigos acadêmicos sobre mecatrônica, diagramas de Gantt online"
                                  ],
                                  "tips": "Use mind maps para visualizar fluxos paralelos e sequenciais.",
                                  "learningObjective": "Dominar conceitos teóricos da engenharia concorrente aplicados a mecatrônica.",
                                  "commonMistakes": [
                                    "Confundir com engenharia paralela em software",
                                    "Ignorar riscos de integração precoce"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formar e Gerenciar Equipes Multifuncionais",
                                  "subSteps": [
                                    "Selecionar membros com expertise em mecânica, eletrônica, controle e integração.",
                                    "Definir papéis, responsabilidades e canais de comunicação (ex: Slack, reuniões diárias).",
                                    "Estabelecer ferramentas colaborativas como Git para versionamento e Jira para tracking.",
                                    "Realizar workshop inicial para alinhamento de objetivos comuns.",
                                    "Criar plano de comunicação e resolução de conflitos."
                                  ],
                                  "verification": "Documentar organograma da equipe e plano de comunicação aprovado por todos os membros.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Ferramentas: Microsoft Teams ou Slack, templates de RACI matrix, software de gerenciamento como Trello"
                                  ],
                                  "tips": "Priorize diversidade de habilidades para cobrir todos os subsistemas.",
                                  "learningObjective": "Capacitar na formação de times eficazes para desenvolvimento integrado.",
                                  "commonMistakes": [
                                    "Equipes desbalanceadas em expertise",
                                    "Falta de comunicação clara levando a silos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Planejar o Desenvolvimento Paralelo de Subsistemas",
                                  "subSteps": [
                                    "Definir requisitos globais do produto e dividi-los em subsistemas interdependentes.",
                                    "Criar cronograma paralelo usando diagramas de PERT ou Gantt com sobreposições.",
                                    "Estabelecer interfaces padronizadas entre mecânica, eletrônica e controle (ex: protocolos CAN bus).",
                                    "Simular cronograma com ferramentas de projeto para identificar gargalos.",
                                    "Aprovar plano com revisão multifuncional."
                                  ],
                                  "verification": "Produzir cronograma Gantt com atividades paralelas e interfaces definidas.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Software: MS Project ou Primavera, CAD como SolidWorks para modelagem inicial"
                                  ],
                                  "tips": "Inclua buffers de 10-20% para integrações inesperadas.",
                                  "learningObjective": "Planejar fluxos paralelos que minimizem dependências sequenciais.",
                                  "commonMistakes": [
                                    "Subestimar interdependências",
                                    "Cronogramas irreais sem simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Desenvolvimento Paralelo e Integração Inicial",
                                  "subSteps": [
                                    "Desenvolver protótipos paralelos: chassi mecânico, circuito eletrônico e algoritmo de controle.",
                                    "Realizar revisões iterativas semanais com feedback cross-funcional.",
                                    "Testar interfaces em mockups virtuais (simulações MATLAB/Simulink).",
                                    "Integrar subsistemas em protótipo funcional e corrigir discrepâncias.",
                                    "Medir progresso contra cronograma e ajustar dinamicamente."
                                  ],
                                  "verification": "Demonstrar protótipo integrado com testes básicos de funcionamento.",
                                  "estimatedTime": "20 horas",
                                  "materials": [
                                    "Hardware: Arduino/Raspberry Pi para eletrônica, impressora 3D para mecânica, MATLAB para simulações"
                                  ],
                                  "tips": "Use version control para todos os artefatos digitais.",
                                  "learningObjective": "Implementar desenvolvimento paralelo com integração contínua.",
                                  "commonMistakes": [
                                    "Atrasos em um subsistema paralisando outros",
                                    "Integração tardia revelando falhas graves"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar Resultados e Otimizar o Processo",
                                  "subSteps": [
                                    "Comparar tempo de ciclo real vs. projetado e tradicional.",
                                    "Coletar métricas: custo, qualidade e lições aprendidas via retrospectives.",
                                    "Otimizar design integrado com base em testes finais.",
                                    "Documentar melhores práticas para projetos futuros.",
                                    "Apresentar relatório final com KPIs alcançados."
                                  ],
                                  "verification": "Relatório com métricas comprovando redução de tempo (ex: 30% menor) e otimizações.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Planilhas Excel para KPIs, templates de retrospective (Start-Stop-Continue)"
                                  ],
                                  "tips": "Quantifique ganhos com dados mensuráveis.",
                                  "learningObjective": "Avaliar eficácia e refinar processos de engenharia concorrente.",
                                  "commonMistakes": [
                                    "Foco só em tempo, ignorando qualidade",
                                    "Não documentar lições para reutilização"
                                  ]
                                }
                              ],
                              "practicalExample": "No desenvolvimento de um braço robótico mecatrônico: equipe desenvolve simultaneamente o mecanismo mecânico (SolidWorks), placa de controle eletrônico (PCB Eagle) e software de controle (ROS), integrando via CAN bus em 4 semanas, reduzindo ciclo de 12 para 4 semanas.",
                              "finalVerifications": [
                                "Cronograma paralelo executado com redução comprovada no tempo de ciclo (>20%).",
                                "Protótipo integrado funcional com todos subsistemas operando em conjunto.",
                                "Relatório de lições aprendidas documentado e compartilhado.",
                                "Métricas de qualidade: taxa de defeitos <5% na integração.",
                                "Feedback positivo da equipe sobre colaboração multifuncional.",
                                "Interfaces padronizadas testadas e validadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de princípios concorrentes (80% alinhamento com teoria).",
                                "Efetividade da equipe multifuncional (taxa de resolução de conflitos >90%).",
                                "Redução mensurável no tempo de ciclo (mínimo 25%).",
                                "Qualidade da integração de subsistemas (zero falhas críticas).",
                                "Documentação completa e acionável.",
                                "Criatividade em otimizações interdisciplinares."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Técnicas ágeis e Gantt.",
                                "Comunicação e Trabalho em Equipe: Dinâmicas de grupo multifuncionais.",
                                "Engenharia de Software: Versionamento e integração contínua.",
                                "Análise de Sistemas: Modelagem de interfaces e simulações."
                              ],
                              "realWorldApplication": "Na indústria automotiva (ex: Ford usa para design de veículos elétricos), reduzindo tempo de lançamento de produtos em 40%, ou em manufatura robótica (ex: ABB), otimizando linhas de produção integradas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Modelos de Projeto Integrado (V-Model)",
                            "description": "Utilizar o modelo V para planejamento sequencial e verificação integrada de requisitos, design, implementação e testes em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura e Princípios do V-Model",
                                  "subSteps": [
                                    "Estude a representação gráfica do V-Model, identificando o lado esquerdo (desenvolvimento descendente) e direito (testes ascendentes).",
                                    "Diferencie verificação (faz certo?) de validação (certo?).",
                                    "Mapeie fases principais: Requisitos do Sistema, Arquitetura de Alto Nível, Design Detalhado, Codificação/Implementação, Testes Unitários, Integração, Testes de Sistema e Aceitação.",
                                    "Adapte conceitos ao contexto mecatrônico, considerando hardware, software e integração.",
                                    "Desenhe manualmente o V-Model para um sistema genérico."
                                  ],
                                  "verification": "Desenhe e explique o V-Model em um diagrama, listando todas as fases e suas correspondências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Diagrama oficial do V-Model (impresso ou digital)",
                                    "Vídeo tutorial sobre V-Model (YouTube ou Khan Academy)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": [
                                    "Use cores diferentes para fases de desenvolvimento e testes para visualizar melhor as ligações.",
                                    "Compare com Waterfall para destacar a ênfase em testes precoces."
                                  ],
                                  "learningObjective": "Dominar os componentes fundamentais do V-Model e sua aplicação em projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Confundir verificação com validação.",
                                    "Ignorar a integração hardware-software em contextos mecatrônicos.",
                                    "Achar que é apenas para software, não sistemas integrados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Decompor Requisitos do Sistema",
                                  "subSteps": [
                                    "Colete requisitos funcionais (o que o sistema faz) e não-funcionais (desempenho, segurança) via entrevistas ou análise.",
                                    "Crie uma árvore de requisitos hierárquica: alto nível para sistema, baixo nível para subsistemas.",
                                    "Especifique critérios de aceitação para cada requisito.",
                                    "Planeje testes de aceitação correspondentes no lado direito do V.",
                                    "Revise requisitos com stakeholders para alinhamento."
                                  ],
                                  "verification": "Produza um documento de requisitos com pelo menos 10 itens hierárquicos e testes planejados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Template de documento de requisitos (Google Docs ou Word)",
                                    "Exemplos de requisitos mecatrônicos (braço robótico ou drone)"
                                  ],
                                  "tips": [
                                    "Use o formato SMART (Specific, Measurable, Achievable, Relevant, Time-bound) para requisitos.",
                                    "Priorize requisitos críticos para segurança em mecatrônica."
                                  ],
                                  "learningObjective": "Elaborar requisitos claros e rastreáveis para guiar todo o desenvolvimento.",
                                  "commonMistakes": [
                                    "Requisitos vagos ou não mensuráveis.",
                                    "Não planejar testes de validação desde o início.",
                                    "Omitir requisitos não-funcionais como robustez mecânica."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Elaborar Design de Alto Nível e Detalhado",
                                  "subSteps": [
                                    "Desenvolva arquitetura de sistema (blocos funcionais: mecânica, eletrônica, software).",
                                    "Crie diagramas de design detalhado (UML, blocos CAD para hardware).",
                                    "Trace design de volta aos requisitos com matriz de rastreabilidade.",
                                    "Planeje testes de integração para cada módulo.",
                                    "Simule design preliminar com ferramentas como MATLAB/Simulink."
                                  ],
                                  "verification": "Gere diagramas de arquitetura e matriz de rastreabilidade cobrindo todos os requisitos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Ferramentas de diagramação (Draw.io ou Visio)",
                                    "Software de simulação (Simulink ou Tinkercad)",
                                    "Templates de matriz de rastreabilidade"
                                  ],
                                  "tips": [
                                    "Mantenha modularidade para facilitar testes unitários.",
                                    "Inclua interfaces entre hardware e software explicitamente."
                                  ],
                                  "learningObjective": "Traduzir requisitos em designs modulares e verificáveis.",
                                  "commonMistakes": [
                                    "Designs não rastreáveis aos requisitos.",
                                    "Ignorar trade-offs entre custo, peso e desempenho em mecatrônica.",
                                    "Sobredimensionar componentes sem simulação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Componentes e Realizar Testes Unitários",
                                  "subSteps": [
                                    "Construa/codifique componentes individuais (hardware: montagem; software: programação Arduino/PLC).",
                                    "Execute testes unitários baseados em verificações planejadas.",
                                    "Registre resultados e itere correções.",
                                    "Documente desvios e lições aprendidas.",
                                    "Prepare para integração."
                                  ],
                                  "verification": "Relatório de testes unitários com resultados pass/fail para cada componente.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Kits mecatrônicos (Arduino, sensores, atuadores)",
                                    "Multímetro e osciloscópio",
                                    "Ambiente de programação (Arduino IDE)"
                                  ],
                                  "tips": [
                                    "Teste em ambiente controlado antes de integração.",
                                    "Automatize testes unitários com scripts onde possível."
                                  ],
                                  "learningObjective": "Implementar e verificar componentes isoladamente.",
                                  "commonMistakes": [
                                    "Pular testes unitários para 'economizar tempo'.",
                                    "Não calibrar sensores adequadamente.",
                                    "Erros de wiring em hardware."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar, Testar Sistema e Validar",
                                  "subSteps": [
                                    "Integre componentes seguindo ordem ascendente (unitário -> subsistema -> sistema).",
                                    "Execute testes de integração, sistema e aceitação.",
                                    "Valide contra requisitos originais.",
                                    "Realize análise de falhas e otimizações finais.",
                                    "Gere relatório final de projeto."
                                  ],
                                  "verification": "Sistema integrado funcionando com relatório de testes completos e validação.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Sistema protótipo completo",
                                    "Checklist de testes",
                                    "Ferramentas de debug (serial monitor)"
                                  ],
                                  "tips": [
                                    "Use mockups para testes parciais se hardware real demorar.",
                                    "Documente tudo para auditorias futuras."
                                  ],
                                  "learningObjective": "Completar ciclo V-Model com integração e validação plena.",
                                  "commonMistakes": [
                                    "Integração precipitada sem testes prévios.",
                                    "Não detectar falhas de interface cedo.",
                                    "Ignorar validação com usuário final."
                                  ]
                                }
                              ],
                              "practicalExample": "Ao planejar um braço robótico mecatrônico: defina requisitos (alcance 30cm, precisão 1mm), design (motores servo, Arduino), implemente (montagem + código PID), teste unitário (cada joint), integre e valide (movimento suave para pick-and-place).",
                              "finalVerifications": [
                                "Desenhar o V-Model completo com fases personalizadas para o projeto.",
                                "Produzir matriz de rastreabilidade de requisitos a testes.",
                                "Demonstrar protótipo funcional com todos os testes documentados.",
                                "Explicar como uma mudança em requisitos propaga pelo modelo.",
                                "Identificar e corrigir um erro comum em um exemplo dado.",
                                "Gerar relatório final com lições aprendidas."
                              ],
                              "assessmentCriteria": [
                                "Completude da rastreabilidade entre desenvolvimento e testes (100% cobertura).",
                                "Precisão e detalhe nos documentos de requisitos e design.",
                                "Taxa de sucesso nos testes (mínimo 90% pass nos primeiros runs).",
                                "Eficiência temporal (dentro das estimativas totais).",
                                "Qualidade da integração (ausência de falhas de interface).",
                                "Documentação clara e profissional."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Alinhamento com PMBOK para planejamento e controle.",
                                "Engenharia de Software: Integração com metodologias ágeis em iterações V.",
                                "Qualidade e Confiabilidade: Normas ISO 26262 para sistemas críticos.",
                                "Eletrônica Embarcada: Testes de hardware-in-the-loop.",
                                "Mecânica Aplicada: Análise de tensões e dinâmica nos designs."
                              ],
                              "realWorldApplication": "Na indústria automotiva (desenvolvimento de freios ABS pela Bosch), aeroespacial (sistemas de controle de voo) e manufatura (robôs industriais da Fanuc), o V-Model garante integração segura de mecânica, eletrônica e software, reduzindo falhas em 30-50% em projetos complexos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Sistemas de Visão por Computador",
                        "description": "Introdução aos princípios fundamentais de visão computacional aplicados à mecatrônica, incluindo aquisição de imagens e processamento para automação industrial.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Princípios Básicos de Visão Computacional",
                            "description": "Compreender captura de imagens, processamento digital (filtros, segmentação) e extração de características para integração em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos da Captura de Imagens Digitais",
                                  "subSteps": [
                                    "Entender o conceito de imagem digital como uma matriz de pixels.",
                                    "Explorar os canais de cor RGB e escalas de cinza.",
                                    "Estudar sensores de imagem: CCD vs CMOS e sua relevância em mecatrônica.",
                                    "Analisar parâmetros de captura: resolução, profundidade de bits e taxa de frames.",
                                    "Praticar aquisição de imagens usando câmeras web ou bibliotecas como OpenCV."
                                  ],
                                  "verification": "Capturar e exibir uma imagem digital com metadados corretos (resolução, canais).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Computador com Python e OpenCV instalados",
                                    "Câmera web ou smartphone",
                                    "Imagens de exemplo de componentes mecatrônicos"
                                  ],
                                  "tips": "Comece com imagens em escala de cinza para simplificar o processamento inicial.",
                                  "learningObjective": "Compreender como imagens são capturadas e representadas digitalmente para uso em sistemas mecatrônicos.",
                                  "commonMistakes": [
                                    "Confundir pixels com amostras analógicas",
                                    "Ignorar o impacto da iluminação na captura",
                                    "Não calibrar a câmera para distorções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processamento Digital Básico com Filtros",
                                  "subSteps": [
                                    "Identificar tipos de ruído em imagens (gaussiano, sal e pimenta).",
                                    "Implementar filtros de suavização: média, gaussiano.",
                                    "Aplicar filtros de realce: detecção de bordas com Sobel e Laplacian.",
                                    "Entender convolução como base matemática dos filtros.",
                                    "Testar filtros em imagens reais de peças mecatrônicas."
                                  ],
                                  "verification": "Aplicar um filtro gaussiano em uma imagem ruidosa e comparar visualmente antes/depois.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python com OpenCV e NumPy",
                                    "Imagens ruidosas de exemplo",
                                    "Editor de código como Jupyter Notebook"
                                  ],
                                  "tips": "Use kernels pequenos (3x3) inicialmente para visualizar efeitos rapidamente.",
                                  "learningObjective": "Dominar técnicas de filtragem para preparar imagens para análise em sistemas embarcados.",
                                  "commonMistakes": [
                                    "Aplicar filtros excessivos causando perda de detalhes",
                                    "Confundir filtros lineares com não-lineares",
                                    "Não normalizar kernels de convolução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Técnicas de Segmentação de Imagens",
                                  "subSteps": [
                                    "Aprender segmentação por limiarização (thresholding global e adaptativo).",
                                    "Explorar métodos baseados em bordas e regiões (region growing).",
                                    "Implementar watershed para segmentação de múltiplos objetos.",
                                    "Lidar com sombreamento e variações de iluminação.",
                                    "Aplicar em cenários mecatrônicos, como separar componentes de fundo."
                                  ],
                                  "verification": "Segmentar uma imagem de uma placa de circuito, isolando pelo menos 3 componentes.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "OpenCV instalado",
                                    "Imagens de montagens mecatrônicas",
                                    "Ferramentas de visualização como Matplotlib"
                                  ],
                                  "tips": "Combine thresholding com morfologia para refinar regiões segmentadas.",
                                  "learningObjective": "Isolar regiões de interesse em imagens para integração com atuadores mecatrônicos.",
                                  "commonMistakes": [
                                    "Escolha inadequada de threshold causando oversegmentação",
                                    "Ignorar pré-processamento com filtros",
                                    "Não tratar vazamentos de região"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extração de Características de Imagens",
                                  "subSteps": [
                                    "Definir tipos de características: cor (histograma), forma (momentos, contornos), textura (LBP).",
                                    "Calcular descritores simples: área, perímetro, circularidade.",
                                    "Implementar extração usando funções OpenCV (contours, Hu moments).",
                                    "Normalizar características para robustez.",
                                    "Integrar características em um vetor para classificação em mecatrônica."
                                  ],
                                  "verification": "Extrair e listar 5 características de um objeto segmentado em uma imagem.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/OpenCV/NumPy",
                                    "Imagens segmentadas prévias",
                                    "Planilha para registrar características"
                                  ],
                                  "tips": "Visualize contornos antes de extrair para validar segmentação.",
                                  "learningObjective": "Extrair features acionáveis para decisões em sistemas mecatrônicos inteligentes.",
                                  "commonMistakes": [
                                    "Extrair features sem segmentação precisa",
                                    "Não escalar features para comparações",
                                    "Confundir invariantes com dependentes de escala"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema mecatrônico de inspeção de qualidade, capture uma imagem de uma engrenagem, aplique filtro gaussiano para reduzir ruído, segmente a engrenagem do fundo via thresholding adaptativo e extraia características como área e circularidade para detectar defeitos de fabricação.",
                              "finalVerifications": [
                                "Explicar o pipeline completo: captura → filtro → segmentação → features.",
                                "Implementar um script OpenCV que processe uma imagem de peça mecatrônica end-to-end.",
                                "Identificar e corrigir ruído em uma imagem fornecida.",
                                "Segmentar corretamente múltiplos objetos em uma cena complexa.",
                                "Calcular e interpretar pelo menos 3 características de um objeto segmentado.",
                                "Discutir limitações em condições reais de iluminação variável."
                              ],
                              "assessmentCriteria": [
                                "Precisão da segmentação >85% (medida por IoU).",
                                "Correta aplicação e explicação de pelo menos 2 filtros.",
                                "Extração precisa de 4+ características com valores normalizados.",
                                "Código funcional e comentado em Python/OpenCV.",
                                "Integração conceitual com sistemas mecatrônicos.",
                                "Identificação de erros comuns e soluções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para convoluções e transformadas.",
                                "Programação: Bibliotecas OpenCV e NumPy para processamento.",
                                "Eletrônica: Interfaces com sensores de imagem em microcontroladores.",
                                "Física: Óptica e propriedades da luz em captura.",
                                "Engenharia de Controle: Uso de features para feedback em loops de controle."
                              ],
                              "realWorldApplication": "Integração em robôs industriais para inspeção visual automatizada de componentes mecatrônicos, como detecção de defeitos em PCBs ou alinhamento de peças em linhas de montagem, reduzindo erros humanos e aumentando eficiência produtiva."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Aplicações em Mecatrônica",
                            "description": "Analisar uso de visão por computador em inspeção de qualidade, orientação robótica e controle de processos industriais mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Visão por Computador em Sistemas Mecatrônicos",
                                  "subSteps": [
                                    "Estudar os princípios básicos de processamento de imagens, incluindo aquisição, pré-processamento e segmentação.",
                                    "Analisar componentes de hardware como câmeras industriais, iluminação e lentes usadas em ambientes mecatrônicos.",
                                    "Explorar algoritmos essenciais como detecção de bordas (Canny), extração de características (SIFT) e matching de templates.",
                                    "Revisar integrações típicas com atuadores e controladores em sistemas mecatrônicos.",
                                    "Identificar métricas de desempenho como precisão, taxa de falsos positivos e tempo de processamento em tempo real."
                                  ],
                                  "verification": "Listar e explicar 5 componentes chave de um sistema de visão por computador integrado a mecatrônica, com exemplos de uso.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Computador com Python e OpenCV instalados",
                                    "Documentação oficial do OpenCV",
                                    "Vídeos tutoriais sobre processamento de imagens industriais"
                                  ],
                                  "tips": "Comece com exemplos visuais simples para fixar conceitos; use ferramentas gratuitas como ImageJ para experimentação rápida.",
                                  "learningObjective": "Dominar os fundamentos teóricos e práticos da visão por computador aplicados a contextos mecatrônicos.",
                                  "commonMistakes": [
                                    "Confundir visão por computador com sensores ópticos simples",
                                    "Ignorar impactos ambientais como iluminação variável",
                                    "Subestimar requisitos de processamento em tempo real"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Aplicações em Inspeção de Qualidade",
                                  "subSteps": [
                                    "Estudar casos de detecção de defeitos em superfícies, como rachaduras ou irregularidades em peças metálicas.",
                                    "Implementar um pipeline básico de inspeção usando thresholding e contorno detection.",
                                    "Avaliar métricas de qualidade como taxa de detecção e falsos negativos em cenários industriais.",
                                    "Simular inspeção em linha de produção com imagens de amostra de produtos mecatrônicos.",
                                    "Comparar visão computacional com métodos manuais tradicionais em termos de eficiência e precisão."
                                  ],
                                  "verification": "Criar um relatório curto demonstrando detecção de defeito em uma imagem de teste, com métricas calculadas.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software OpenCV ou MATLAB Image Processing Toolbox",
                                    "Banco de imagens de defeitos industriais (ex: Kaggle datasets)",
                                    "Câmera webcam para testes reais"
                                  ],
                                  "tips": "Teste com diferentes condições de luz para robustez; calibre a câmera para minimizar distorções.",
                                  "learningObjective": "Capacitar análise detalhada de visão computacional para inspeção automatizada de qualidade em mecatrônica.",
                                  "commonMistakes": [
                                    "Overfitting em datasets específicos sem generalização",
                                    "Não considerar variações de cor ou textura",
                                    "Ignorar calibração da câmera"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Orientação e Navegação Robótica com Visão Computacional",
                                  "subSteps": [
                                    "Aprender técnicas de tracking de objetos e pose estimation para orientação robótica.",
                                    "Implementar algoritmos como optical flow ou feature matching para guiar braços robóticos.",
                                    "Simular cenários de pick-and-place usando ROS (Robot Operating System) com visão.",
                                    "Analisar feedback loops onde visão corrige trajetórias em tempo real.",
                                    "Estudar aplicações em montagem de componentes mecatrônicos precisos."
                                  ],
                                  "verification": "Demonstrar orientação de um robô virtual ou simulado rastreando um objeto em vídeo.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "ROS com Gazebo simulator",
                                    "OpenCV para visão",
                                    "Tutoriais ROS-Industrial Vision"
                                  ],
                                  "tips": "Use marcadores fiduciais como ArUco para prototipagem rápida; integre com controladores PID para estabilidade.",
                                  "learningObjective": "Habilitar o design de sistemas robóticos guiados por visão em ambientes mecatrônicos.",
                                  "commonMistakes": [
                                    "Baixa taxa de frames causando perda de tracking",
                                    "Não sincronizar visão com comandos de movimento",
                                    "Subestimar latência em loops de controle"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Controle de Processos Industriais Mecatrônicos",
                                  "subSteps": [
                                    "Analisar monitoramento de processos como soldagem ou usinagem via análise de imagens térmicas ou visuais.",
                                    "Desenvolver modelos para detecção de anomalias em fluxos de produção contínuos.",
                                    "Integrar visão com PLCs (Programmable Logic Controllers) para controle adaptativo.",
                                    "Simular ajustes em tempo real baseados em feedback visual, como correção de alinhamento.",
                                    "Avaliar escalabilidade em linhas de produção Industry 4.0."
                                  ],
                                  "verification": "Produzir um diagrama de fluxo mostrando integração de visão no controle de um processo mecatrônico.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software PLC Simulator (ex: OpenPLC)",
                                    "Datasets de processos industriais",
                                    "Ferramentas de diagramação como Draw.io"
                                  ],
                                  "tips": "Priorize processamento edge para reduzir latência; valide com dados reais de sensores.",
                                  "learningObjective": "Compreender e projetar controles de processos industriais aprimorados por visão computacional.",
                                  "commonMistakes": [
                                    "Falta de redundância em falhas de visão",
                                    "Integração inadequada com sistemas legados",
                                    "Ignorar segurança em controles autônomos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Avaliar Aplicações Integradas",
                                  "subSteps": [
                                    "Comparar as três aplicações (inspeção, orientação, controle) em termos de desafios e soluções comuns.",
                                    "Desenhar um sistema mecatrônico integrado usando visão para múltiplas funções.",
                                    "Realizar análise de custo-benefício e ROI para implementações industriais.",
                                    "Explorar tendências futuras como visão 3D e IA embarcada.",
                                    "Preparar um case study completo unificando os conhecimentos."
                                  ],
                                  "verification": "Apresentar um case study integrado com diagramas e métricas de performance.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ferramentas de modelagem como SysML ou Visio",
                                    "Artigos acadêmicos sobre visão em mecatrônica",
                                    "Planilhas para análise de ROI"
                                  ],
                                  "tips": "Use frameworks como SWOT para avaliação; consulte normas ISO para qualidade industrial.",
                                  "learningObjective": "Integrar conhecimentos para análise holística de aplicações de visão em mecatrônica.",
                                  "commonMistakes": [
                                    "Foco excessivo em uma aplicação isolada",
                                    "Não considerar interoperabilidade de sistemas",
                                    "Subestimar custos de manutenção"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de motores elétricos mecatrônicos, visão computacional inspeciona soldas para defeitos, orienta robôs para inserção de componentes com precisão de 0.1mm e controla o processo ajustando velocidades de conveyor baseado em detecções de backlog, reduzindo desperdícios em 25%.",
                              "finalVerifications": [
                                "Explicar com detalhes 3 aplicações específicas de visão em mecatrônica.",
                                "Implementar um protótipo simples de detecção/orientação usando OpenCV.",
                                "Calcular métricas de performance para um caso de inspeção simulado.",
                                "Desenhar um diagrama de integração visão-controle em um processo industrial.",
                                "Identificar 2 limitações e soluções para cada aplicação.",
                                "Comparar visão computacional com alternativas sensoriais em cenários mecatrônicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão e profundidade técnica nas descrições de aplicações (30%)",
                                "Qualidade e funcionalidade de implementações práticas/simulações (25%)",
                                "Análise crítica de métricas, limitações e integrações (20%)",
                                "Criatividade em exemplos e conexões interdisciplinares (15%)",
                                "Clareza na documentação e verificações finais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação e Algoritmos (Python/OpenCV para processamento)",
                                "Inteligência Artificial e Machine Learning (detecção avançada)",
                                "Engenharia de Controle (feedback loops com PLCs)",
                                "Engenharia Mecânica (design de hardware para visão)",
                                "Gestão Industrial (análise de ROI e Industry 4.0)"
                              ],
                              "realWorldApplication": "Na manufatura automotiva da Tesla ou Bosch, sistemas de visão por computador realizam inspeção 100% automatizada de baterias, guiam robôs colaborativos em montagem e otimizam processos de usinagem em tempo real, elevando eficiência operacional e conformidade com padrões de qualidade globais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Integração com Microcontroladores",
                            "description": "Integrar câmeras e algoritmos de visão com microcontroladores para feedback em tempo real em sistemas mecatrônicos autônomos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Seleção e Configuração Inicial de Hardware",
                                  "subSteps": [
                                    "Escolha um microcontrolador compatível com visão computacional, como ESP32-CAM ou Raspberry Pi Pico com módulo de câmera OV2640.",
                                    "Conecte a câmera ao microcontrolador via interfaces como SPI, I2C ou USB, verificando pinagens no datasheet.",
                                    "Alimente o sistema e teste conexões básicas com multímetro para continuidade e tensão.",
                                    "Instale bibliotecas de suporte para câmera no IDE do microcontrolador (ex: ESP-IDF ou Arduino IDE).",
                                    "Execute um sketch de teste para capturar uma imagem estática e salvá-la no cartão SD."
                                  ],
                                  "verification": "Câmera captura e salva imagem de teste sem erros no serial monitor.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Microcontrolador (ESP32-CAM), Câmera OV2640, Cabos jumper, Multímetro, Computador com IDE instalado"
                                  ],
                                  "tips": "Use protoboards para prototipagem rápida e evite soldas prematuras.",
                                  "learningObjective": "Entender compatibilidade hardware e realizar conexões seguras para visão em tempo real.",
                                  "commonMistakes": [
                                    "Conexões invertidas de VCC/GND causando danos",
                                    "Bibliotecas incompatíveis com versão do firmware",
                                    "Ignorar consumo de corrente da câmera"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolvimento de Captura e Transmissão de Imagens em Tempo Real",
                                  "subSteps": [
                                    "Implemente código para captura contínua de frames a 10-30 FPS usando APIs como esp_camera.h.",
                                    "Configure transmissão de dados via WiFi (UDP/TCP) ou serial para um host de processamento.",
                                    "Otimize resolução e qualidade da imagem para reduzir latência (ex: 320x240 pixels).",
                                    "Adicione buffer circular para evitar perda de frames durante transmissão.",
                                    "Teste latência de end-to-end com cronômetro e serial plotter."
                                  ],
                                  "verification": "Frames são capturados e transmitidos com latência <500ms, visualizável em app receptor.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "ESP32-CAM programado, Computador receptor com Python OpenCV, Rede WiFi"
                                  ],
                                  "tips": "Monitore uso de RAM com freeHeap() para evitar overflows.",
                                  "learningObjective": "Capturar e transmitir streams de vídeo em tempo real de forma eficiente.",
                                  "commonMistakes": [
                                    "Resoluções altas causando travamentos",
                                    "Sem buffering levando a frames perdidos",
                                    "WiFi instável sem retry mechanisms"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integração de Algoritmos de Visão Computacional",
                                  "subSteps": [
                                    "Desenvolva ou importe algoritmos leves (ex: detecção de bordas com Canny ou blobs com OpenCV-lite).",
                                    "Integre processamento no microcontrolador ou offload para co-processador via RPC.",
                                    "Implemente pipeline: captura -> pré-processamento -> detecção -> extração de features.",
                                    "Calibre parâmetros do algoritmo com imagens de teste variadas (iluminação, ângulos).",
                                    "Publique resultados (ex: coordenadas de objetos) via MQTT ou serial."
                                  ],
                                  "verification": "Algoritmo detecta objetos em frames transmitidos com acurácia >80%.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": [
                                    "Código fonte com bibliotecas Edge TPU ou TensorFlow Lite Micro",
                                    "Imagens de calibração"
                                  ],
                                  "tips": "Use modelos pré-treinados quantized para microcontroladores.",
                                  "learningObjective": "Aplicar visão computacional embarcada para extração de features acionáveis.",
                                  "commonMistakes": [
                                    "Algoritmos pesados excedendo ciclos CPU",
                                    "Falta de calibração causando falsos positivos",
                                    "Ignorar variações ambientais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementação de Feedback em Tempo Real e Integração no Sistema Mecatrônico",
                                  "subSteps": [
                                    "Mapeie saídas de visão para ações (ex: coordenadas -> PWM para motores).",
                                    "Crie loop de controle fechado: visão -> decisão -> atuador com taxa de 10Hz.",
                                    "Integre com outros sensores mecatrônicos (IMU, encoders) para fusão de dados.",
                                    "Implemente safety checks (ex: watchdog timer, limites de velocidade).",
                                    "Teste em hardware real: robô navegando baseado em visão."
                                  ],
                                  "verification": "Sistema responde autonomamente a estímulos visuais em <100ms.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Robô mecatrônico com motores/servos, Sensores adicionais (IMU)"
                                  ],
                                  "tips": "Use FSM (Finite State Machine) para gerenciar modos operacionais.",
                                  "learningObjective": "Fechar o loop de feedback para autonomia em sistemas mecatrônicos.",
                                  "commonMistakes": [
                                    "Latência acumulada quebrando real-time",
                                    "Sem fusão sensorial causando instabilidade",
                                    "Falta de timeouts em falhas de visão"
                                  ]
                                }
                              ],
                              "practicalExample": "Integre uma ESP32-CAM em um robô diferencial para detecção de linhas pretas no chão: a visão detecta desvios e ajusta motores em tempo real para correção de trajetória.",
                              "finalVerifications": [
                                "Sistema captura e processa frames a >15 FPS com latência total <200ms.",
                                "Algoritmo de visão acerta >90% em cenários de teste variados.",
                                "Feedback atua corretamente em atuadores mecatrônicos sem oscilações.",
                                "Sistema opera autonomamente por 10 minutos sem crashes.",
                                "Logs mostram fusão de dados de visão com outros sensores.",
                                "Consumo de energia dentro de limites do microcontrolador."
                              ],
                              "assessmentCriteria": [
                                "Precisão e robustez da detecção visual em condições reais (iluminação variável).",
                                "Latência end-to-end otimizada para real-time (<100ms crítica).",
                                "Eficiência de código: uso de RAM/CPU <80% em pico.",
                                "Integração seamless com subsistemas mecatrônicos.",
                                "Documentação clara de hardware, código e calibrações.",
                                "Capacidade de depuração e handling de falhas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Embarcada: Firmware RTOS e otimização de código C++.",
                                "Eletrônica: Interfaces de comunicação e gerenciamento de energia.",
                                "Inteligência Artificial: Modelos de ML leves para edge computing.",
                                "Controle Automático: Loops de feedback e controle PID visual.",
                                "Projetos Integrados: Design de sistemas cyber-físicos."
                              ],
                              "realWorldApplication": "Desenvolvimento de drones autônomos para inspeção agrícola, robôs de vigilância em fábricas ou veículos autônomos para navegação em armazéns, onde feedback visual em tempo real é essencial para decisões seguras e eficientes."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Robótica Mecatrônica na Indústria Aeronáutica",
                        "description": "Conceitos iniciais de robótica com ênfase em aplicações mecatrônicas no setor aeronáutico, incluindo manipulação e automação.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Fundamentos de Robótica",
                            "description": "Estudar cinemática, dinâmica e controle de robôs, com foco em integração mecatrônica de atuadores, sensores e controladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Cinemática Direta e Inversa de Robôs",
                                  "subSteps": [
                                    "Estudar os conceitos básicos de transformações homogêneas e matrizes de rotação.",
                                    "Aprender a modelar um manipulador robótico serial com 2-3 graus de liberdade (DOF).",
                                    "Calcular a cinemática direta: posição e orientação do efetuador final dado ângulos articulares.",
                                    "Praticar cinemática inversa: encontrar ângulos articulares para uma posição desejada.",
                                    "Explorar singularidades cinemáticas e seu impacto em robôs industriais."
                                  ],
                                  "verification": "Resolver um problema de cinemática direta e inversa para um robô de 3 DOF e validar com software como MATLAB Robotics Toolbox.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Introduction to Robotics' de Craig",
                                    "MATLAB ou Python com bibliotecas SymPy/Robotics Toolbox",
                                    "Planilhas para cálculos manuais"
                                  ],
                                  "tips": "Comece com robôs planar simples antes de 3D para construir intuição visual.",
                                  "learningObjective": "Modelar e calcular posições/orientações de robôs usando cinemática direta e inversa.",
                                  "commonMistakes": [
                                    "Confundir rotação com translação nas matrizes DH",
                                    "Ignorar convenções de Denavit-Hartenberg",
                                    "Erros de sinal em ângulos inversos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Dinâmica de Robôs",
                                  "subSteps": [
                                    "Revisar equações de Lagrange e Newton-Euler para sistemas multicorpos.",
                                    "Derivar o modelo dinâmico de um robô de 2 DOF usando parâmetros de massa e inércia.",
                                    "Calcular torques necessários para trajetórias pré-definidas.",
                                    "Analisar efeitos de Coriolis e forças centrífugas em movimentos rápidos.",
                                    "Simular dinâmica em software para validar equações derivadas."
                                  ],
                                  "verification": "Derivar e simular o modelo dinâmico de um braço robótico simples, plotando torques vs. tempo.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Software Simulink ou PyDy",
                                    "Parâmetros físicos de robôs reais (ex: UR5)",
                                    "Calculadora simbólica como Mathematica"
                                  ],
                                  "tips": "Use frames de referência fixos para evitar confusão em derivadas temporais.",
                                  "learningObjective": "Derivar e aplicar equações dinâmicas para prever torques em robôs.",
                                  "commonMistakes": [
                                    "Esquecer termos de Coriolis em trajetórias curvas",
                                    "Usar massas erradas nos elos",
                                    "Não linearizar para pequenos ângulos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Princípios de Controle de Robôs",
                                  "subSteps": [
                                    "Estudar controladores PID para posição e velocidade articular.",
                                    "Implementar controle em espaço cartesiano usando Jacobiano.",
                                    "Aprender controle adaptativo e robusto para incertezas dinâmicas.",
                                    "Simular rejeição de distúrbios como cargas variáveis em atuadores.",
                                    "Analisar estabilidade com critérios como Routh-Hurwitz."
                                  ],
                                  "verification": "Implementar um PID em simulação que rastreie uma trajetória com erro < 1mm.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "ROS (Robot Operating System) ou Gazebo",
                                    "Controladores em Python (control library)",
                                    "Documentação de controladores industriais como ABB"
                                  ],
                                  "tips": "Ajuste gains PID iterativamente: primeiro P, depois I, depois D.",
                                  "learningObjective": "Projetar controladores para precisão e estabilidade em robôs.",
                                  "commonMistakes": [
                                    "Overshoot excessivo por ganho D alto",
                                    "Oscilações por ganho I sem limite",
                                    "Ignorar delays em atuadores reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração Mecatrônica: Atuadores, Sensores e Controladores",
                                  "subSteps": [
                                    "Selecionar atuadores (motores DC, servos) baseados em torque e velocidade requeridos.",
                                    "Integrar sensores (encoders, IMUs, forças) para feedback.",
                                    "Configurar microcontroladores (Arduino/Raspberry Pi) para loop de controle fechado.",
                                    "Testar integração em hardware simples: ler sensor, controlar atuador.",
                                    "Aplicar a robótica aeronáutica: simular montagem de painéis com precisão."
                                  ],
                                  "verification": "Construir e demonstrar um protótipo com sensor lendo posição e atuador movendo para target.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Kit Arduino + servos + encoders",
                                    "Sensores IMU/MPU6050",
                                    "Breadboard e fios jumper"
                                  ],
                                  "tips": "Use filtros Kalman para ruído em sensores; calibre offsets antes.",
                                  "learningObjective": "Integrar componentes mecatrônicos em um sistema robótico funcional.",
                                  "commonMistakes": [
                                    "Conexões soltas causando ruído",
                                    "Não groundar corretamente",
                                    "Sobrecarga de atuadores sem limite de corrente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simulação e Validação Integrada",
                                  "subSteps": [
                                    "Modelar robô completo em software (CoppeliaSim ou Webots).",
                                    "Integrar cinemática, dinâmica, controle e mecatrônica na simulação.",
                                    "Executar cenários aeronáuticos: pintura ou inspeção de asas.",
                                    "Otimizar parâmetros via tuning automatizado.",
                                    "Comparar simulação com teoria analítica."
                                  ],
                                  "verification": "Simulação bem-sucedida de tarefa completa com métricas de performance.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "CoppeliaSim (gratuito)",
                                    "Modelos URDF de robôs",
                                    "Tutoriais ROS-Gazebo"
                                  ],
                                  "tips": "Valide passo a passo: primeiro cinemática, depois adicione dinâmica.",
                                  "learningObjective": "Validar conhecimentos integrados via simulação realista.",
                                  "commonMistakes": [
                                    "Escala errada em modelos 3D",
                                    "Física irrealista no simulador",
                                    "Ignorar fricção em juntas"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar e controlar um braço robótico de 3 DOF para simular a montagem precisa de rebites em fuselagem de aeronave, integrando encoder para feedback de posição e servo para torque controlado.",
                              "finalVerifications": [
                                "Calcular corretamente cinemática direta/inversa para manipulador dado.",
                                "Derivar torques dinâmicos e simular trajetória sem erro >5%.",
                                "Implementar PID com overshoot <10% e tempo de estabilização <2s.",
                                "Integrar hardware: sensor lê posição com precisão <1° e controla atuador.",
                                "Simulação completa reproduz tarefa aeronáutica com sucesso.",
                                "Explicar singularidades e soluções em contexto industrial."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro <1%)",
                                "Qualidade da implementação de controle (estabilidade e rejeição de distúrbios)",
                                "Funcionalidade da integração mecatrônica (sem falhas de hardware)",
                                "Profundidade da simulação e análise de resultados",
                                "Clareza na documentação de passos e otimizações",
                                "Aplicação contextual à indústria aeronáutica"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e cálculo diferencial",
                                "Física: Mecânica clássica e dinâmica de partículas",
                                "Programação: Python/MATLAB para simulações e controle",
                                "Engenharia Aeronáutica: Automação em montagem e inspeção",
                                "Eletrônica: Circuitos de sensores e atuadores"
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, esses fundamentos permitem robôs para soldagem automatizada, inspeção de fadiga estrutural e montagem precisa de componentes leves, reduzindo erros humanos e tempo de produção em empresas como Boeing ou Embraer."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Aplicações Aeronáuticas",
                            "description": "Explorar robôs para montagem de aeronaves, inspeção não destrutiva e soldagem automatizada, destacando desafios mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos das Aplicações Robóticas na Indústria Aeronáutica",
                                  "subSteps": [
                                    "Pesquisar os tipos de robôs industriais usados em aeronaves (ex: braços articulados, SCARA, colaborativos).",
                                    "Identificar os processos aeronáuticos principais: montagem estrutural, inspeção e soldagem.",
                                    "Analisar requisitos mecatrônicos: precisão, integração sensorial e controle em tempo real.",
                                    "Estudar normas aeronáuticas como FAA e EASA para robótica.",
                                    "Mapear fluxos de trabalho robóticos em linhas de produção."
                                  ],
                                  "verification": "Criar um diagrama de fluxograma resumindo os fundamentos e apresentá-lo para revisão.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Computador com acesso à internet",
                                    "Artigos da Boeing e Airbus sobre robótica",
                                    "Software de diagramação como Draw.io"
                                  ],
                                  "tips": [
                                    "Comece com vídeos da YouTube de fábricas aeronáuticas para visualização rápida.",
                                    "Foque em exemplos reais para melhor retenção."
                                  ],
                                  "learningObjective": "Compreender os princípios básicos e contextos de uso de robôs na aeronáutica.",
                                  "commonMistakes": [
                                    "Ignorar normas de segurança aeronáutica.",
                                    "Confundir robôs industriais com drones.",
                                    "Subestimar a precisão requerida (microns)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Robótica na Montagem de Aeronaves",
                                  "subSteps": [
                                    "Explorar robôs para fixação de painéis e rebiteiras automáticas.",
                                    "Simular cenários de montagem de fuselagem usando software como ROS ou V-REP.",
                                    "Integrar visão computacional para alinhamento de peças.",
                                    "Testar tolerâncias dimensionais em montagem robótica.",
                                    "Avaliar ganhos de produtividade versus métodos manuais."
                                  ],
                                  "verification": "Desenvolver uma simulação simples de montagem e gravar um vídeo demonstrando o processo.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Software de simulação robótica (ROS Gazebo gratuito)",
                                    "Tutoriais online de ROS para aeronáutica",
                                    "Modelos 3D de componentes aeronáuticos"
                                  ],
                                  "tips": [
                                    "Use dados reais de dimensões de aeronaves como Boeing 737 para realismo.",
                                    "Pratique iterações rápidas na simulação."
                                  ],
                                  "learningObjective": "Dominar técnicas robóticas específicas para montagem estrutural de aeronaves.",
                                  "commonMistakes": [
                                    "Negligenciar vibrações em ambientes de montagem.",
                                    "Não calibrar câmeras de visão adequadamente.",
                                    "Exceder limites de payload dos robôs."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspeção Não Destrutiva (NDT) com Robôs",
                                  "subSteps": [
                                    "Estudar métodos NDT: ultrassom, termografia e radiografia robótica.",
                                    "Configurar sensores em braços robóticos para escaneamento de soldas e compósitos.",
                                    "Processar dados de inspeção com IA para detecção de defeitos.",
                                    "Simular inspeções em superfícies curvas de asas.",
                                    "Comparar eficiência robótica vs. inspeção manual."
                                  ],
                                  "verification": "Gerar um relatório com imagens simuladas de defeitos detectados e métricas de precisão.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de processamento de imagem (OpenCV)",
                                    "Datasets públicos de NDT aeronáutico",
                                    "Câmera webcam para testes iniciais"
                                  ],
                                  "tips": [
                                    "Integre bibliotecas Python para automação rápida.",
                                    "Valide com benchmarks de indústrias reais."
                                  ],
                                  "learningObjective": "Aplicar robótica avançada em inspeções NDT para garantir integridade estrutural.",
                                  "commonMistakes": [
                                    "Ruído sensorial não filtrado.",
                                    "Movimentos robóticos muito rápidos causando artefatos.",
                                    "Falta de calibração para materiais compósitos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Soldagem Automatizada e Desafios Mecatrônicos",
                                  "subSteps": [
                                    "Analisar robôs para solda laser e fricção em ligas aeronáuticas (titânio, alumínio).",
                                    "Identificar desafios: controle térmico, trajetórias complexas e fadiga robótica.",
                                    "Desenvolver algoritmos de controle adaptativo para variações materiais.",
                                    "Simular ciclos completos de soldagem em juntas críticas.",
                                    "Propor soluções mecatrônicas para desafios como precisão submilimétrica."
                                  ],
                                  "verification": "Criar um protótipo virtual de soldagem e documentar resolução de um desafio específico.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Software CAD/CAM como SolidWorks ou FreeCAD",
                                    "Tutoriais de soldagem robótica",
                                    "Bibliotecas de simulação térmica"
                                  ],
                                  "tips": [
                                    "Monitore temperaturas simuladas para evitar superaquecimento.",
                                    "Considere multi-robôs colaborativos."
                                  ],
                                  "learningObjective": "Resolver desafios mecatrônicos em soldagem robótica aeronáutica.",
                                  "commonMistakes": [
                                    "Ignorar dilatação térmica.",
                                    "Trajetórias não otimizadas levando a tensões residuais.",
                                    "Subestimar integração atuador-sensor."
                                  ]
                                }
                              ],
                              "practicalExample": "Na linha de montagem do Airbus A350, robôs KUKA com visão 3D montam seções de fuselagem, inspecionam soldas via ultrassom robótico e soldam ligas de titânio, reduzindo tempo de montagem em 30% e erros humanos a zero.",
                              "finalVerifications": [
                                "Explicar verbalmente os 3 principais desafios mecatrônicos e soluções.",
                                "Demonstrar uma simulação completa de montagem + inspeção + soldagem.",
                                "Identificar defeitos em imagens NDT reais de aeronaves.",
                                "Calcular produtividade: tempo robótico vs. manual para uma junta padrão.",
                                "Mapear conexões mecatrônicas em um diagrama de sistema.",
                                "Propor melhoria para uma aplicação real como Boeing 787."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: 90% de acurácia em simulações e explicações.",
                                "Profundidade de análise: Cobertura completa de montagem, NDT e soldagem.",
                                "Criatividade em soluções: Propostas inovadoras para desafios.",
                                "Qualidade de documentação: Relatórios claros com diagramas e vídeos.",
                                "Integração interdisciplinar: Evidência de conexões com outros campos.",
                                "Eficiência temporal: Conclusão dentro dos tempos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Aeroespacial: Aerodinâmica e estruturas leves.",
                                "Ciência dos Materiais: Comportamento de ligas sob soldagem.",
                                "Inteligência Artificial: Processamento de visão para NDT.",
                                "Gestão Industrial: Otimização de linhas de produção.",
                                "Segurança e Ética: Normas FAA para robótica autônoma."
                              ],
                              "realWorldApplication": "Essas habilidades são aplicadas na Embraer e Boeing para automação de montagem do E-Jet e 787 Dreamliner, reduzindo custos em 25%, melhorando qualidade e permitindo produção em escala para aviação comercial e defesa."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Integração com Visão e Controle",
                            "description": "Desenvolver sistemas robóticos que combinem visão por computador e controle baseado em microcontroladores para tarefas precisas na indústria aeronáutica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do Hardware Integrado",
                                  "subSteps": [
                                    "Selecionar e conectar microcontrolador (ex: ESP32 ou Arduino) com câmera (ex: OV2640)",
                                    "Integrar atuadores como servos ou motores DC para simular manipulação de peças aeronáuticas",
                                    "Configurar comunicação serial ou I2C entre câmera e microcontrolador",
                                    "Testar alimentação e conexões básicas com multímetro",
                                    "Calibrar câmera para ambiente de iluminação controlada simulando fábrica aeronáutica"
                                  ],
                                  "verification": "Hardware responde a comandos básicos via serial monitor sem erros de conexão",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Microcontrolador ESP32/Arduino",
                                    "Módulo câmera OV2640",
                                    "Servos/motores DC",
                                    "Protoboard, fios jumper, multímetro",
                                    "Fonte de alimentação 5V"
                                  ],
                                  "tips": "Use diodos de proteção em motores para evitar picos de corrente; fixe componentes em base estável para simular montagem industrial.",
                                  "learningObjective": "Entender integração física de sensores de visão com controladores para precisão robótica.",
                                  "commonMistakes": [
                                    "Conexões invertidas causando curto-circuito",
                                    "Alimentação insuficiente para câmera",
                                    "Falta de aterramento levando a ruído"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementação do Módulo de Visão por Computador",
                                  "subSteps": [
                                    "Instalar bibliotecas como ESP32-CAM ou OpenCV-lite no microcontrolador",
                                    "Desenvolver algoritmo de detecção de objetos usando contornos ou matching de templates para peças aeronáuticas (ex: parafusos leves)",
                                    "Processar frames para extrair coordenadas (x,y) e dimensões do objeto detectado",
                                    "Otimizar threshold de detecção para diferentes iluminações",
                                    "Transmitir dados de visão via serial para o controlador principal"
                                  ],
                                  "verification": "Câmera detecta e reporta coordenadas de objeto de teste com precisão <5mm em 90% dos frames",
                                  "estimatedTime": "4-5 horas",
                                  "materials": [
                                    "Computador com IDE Arduino/ESP-IDF",
                                    "Objetos de teste (parafusos/placas simulando peças aeronáuticas)",
                                    "Luzes LED ajustáveis"
                                  ],
                                  "tips": "Use ROI (Region of Interest) para focar em áreas específicas e melhorar velocidade; teste com fundos contrastantes como em linhas de produção.",
                                  "learningObjective": "Dominar processamento de imagens em tempo real para identificação precisa em contextos industriais.",
                                  "commonMistakes": [
                                    "Threshold fixo falhando em variações de luz",
                                    "Processamento lento devido a resolução alta",
                                    "Falsos positivos por ruído de fundo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolvimento do Sistema de Controle",
                                  "subSteps": [
                                    "Implementar controlador PID no microcontrolador para posicionamento preciso de atuadores",
                                    "Definir setpoints baseados em coordenadas de visão (ex: mover servo para alinhar com peça detectada)",
                                    "Ajustar ganhos Kp, Ki, Kd via tuning manual ou Ziegler-Nichols",
                                    "Adicionar limites de segurança para evitar sobrecarga em simulações aeronáuticas",
                                    "Testar controle em loop aberto e fechado sem visão"
                                  ],
                                  "verification": "Sistema atinge setpoint com erro <2° em servos e oscilação <5% em 10 ciclos",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Código PID library para Arduino",
                                    "Osciloscópio ou serial plotter para tuning"
                                  ],
                                  "tips": "Comece com Kp baixo para evitar overshoot; logue erros para análise posterior.",
                                  "learningObjective": "Aplicar controle feedback para tarefas de precisão em robótica.",
                                  "commonMistakes": [
                                    "Ganhos altos causando instabilidade",
                                    "Integração numérica sem limite levando a windup",
                                    "Ignorar delays de atuadores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração Visão-Controle e Testes Iniciais",
                                  "subSteps": [
                                    "Criar loop principal que leia dados de visão e atualize setpoints de controle em tempo real",
                                    "Sincronizar taxas de amostragem (visão a 10-30 FPS, controle a 100Hz)",
                                    "Implementar lógica de estados (detectar -> alinhar -> manipular)",
                                    "Adicionar filtros Kalman para suavizar dados de visão ruidosos",
                                    "Executar testes end-to-end com peça móvel simulando montagem"
                                  ],
                                  "verification": "Sistema completo detecta, alinha e 'pega' peça em <5 segundos com sucesso >85%",
                                  "estimatedTime": "4-6 horas",
                                  "materials": [
                                    "Peças de teste móveis (ex: carrinho com parafuso)",
                                    "Cronômetro para medição de tempo"
                                  ],
                                  "tips": "Use interrupções para comunicação assíncrona; priorize latência baixa com código otimizado.",
                                  "learningObjective": "Integrar subsistemas para comportamento autônomo em cenários industriais.",
                                  "commonMistakes": [
                                    "Desincronização de loops causando jitter",
                                    "Falta de timeout em detecção falha",
                                    "Sobrecarga de processamento travando sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimização e Validação Final",
                                  "subSteps": [
                                    "Analisar logs para identificar gargalos (tempo de detecção, precisão PID)",
                                    "Otimizar código removendo delays e usando assembly inline se necessário",
                                    "Testar robustez variando iluminação, velocidades e posições de peças",
                                    "Implementar fallback manual via app serial",
                                    "Documentar parâmetros finais e gerar relatório de performance"
                                  ],
                                  "verification": "Sistema opera consistentemente em condições variadas com taxa de sucesso >95%",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software de profiling (ex: FreeRTOS tasks)",
                                    "Planilha para logs de performance"
                                  ],
                                  "tips": "Meça com métricas quantitativas; itere tuning em sessões curtas para evitar fadiga.",
                                  "learningObjective": "Refinar sistemas integrados para confiabilidade industrial.",
                                  "commonMistakes": [
                                    "Otimização prematura sem baseline",
                                    "Testes só em condições ideais",
                                    "Falta de documentação de trade-offs"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver um braço robótico que usa visão para detectar um parafuso de titânio em uma esteira, calcular sua posição e usar controle PID para posicionar um gripper precisamente, simulando montagem de fuselagem aeronáutica.",
                              "finalVerifications": [
                                "Sistema detecta e localiza peça com precisão <3mm",
                                "Controle posiciona atuadores com erro <1°",
                                "Tempo total de ciclo <4 segundos",
                                "Robustez a variações de luz (±20%)",
                                "Sem falhas de hardware em 50 ciclos",
                                "Logs mostram convergência PID estável"
                              ],
                              "assessmentCriteria": [
                                "Precisão de detecção de visão (>90% acurácia)",
                                "Estabilidade e resposta do controlador PID (overshoot <10%)",
                                "Latência end-to-end (<500ms)",
                                "Eficiência computacional (CPU <80% uso médio)",
                                "Conformidade com normas de segurança aeronáutica simuladas",
                                "Qualidade da documentação e reprodutibilidade"
                              ],
                              "crossCurricularConnections": [
                                "Inteligência Artificial: Algoritmos de visão computacional",
                                "Programação Embarcada: Firmware em C++ para microcontroladores",
                                "Engenharia Mecânica: Cinemática de braços robóticos",
                                "Eletrônica: Interfaces sensoriais e atuadores",
                                "Gestão de Projetos: Iteração e validação em ciclos ágeis"
                              ],
                              "realWorldApplication": "Em fábricas aeronáuticas como Embraer ou Boeing, sistemas assim automatizam inspeção e montagem precisa de componentes leves, reduzindo erros humanos em 70% e acelerando produção de aeronaves."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.4",
                        "name": "Microprocessadores, Microcontroladores e CLPs",
                        "description": "Componentes essenciais para controle em sistemas mecatrônicos, incluindo programação e aplicação em projetos integrados.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.4.1",
                            "name": "Características de Microprocessadores e Microcontroladores",
                            "description": "Diferenciar arquiteturas, periféricos (ADC, PWM) e seleção para projetos mecatrônicos específicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos e Diferenças Básicas entre Microprocessadores e Microcontroladores",
                                  "subSteps": [
                                    "Defina microprocessador (MPU) como CPU standalone que requer componentes externos para formar um sistema completo.",
                                    "Defina microcontrolador (MCU) como sistema integrado com CPU, memória e periféricos em um chip único.",
                                    "Compare arquiteturas básicas: von Neumann vs Harvard, RISC vs CISC.",
                                    "Liste vantagens de cada: MPU para alto desempenho, MCU para baixo custo e integração em embedded.",
                                    "Identifique aplicações iniciais em mecatrônica: MPU em PCs industriais, MCU em sensores e atuadores."
                                  ],
                                  "verification": "Crie um diagrama comparativo MPU vs MCU e explique verbalmente as diferenças principais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Datasheets de Arduino Uno (MCU) e Intel i7 (MPU), papel e caneta para diagrama, acesso à internet para glossário.",
                                  "tips": "Use analogias: MPU como cérebro sem corpo, MCU como cérebro com órgãos integrados.",
                                  "learningObjective": "Diferenciar conceitos fundamentais e arquiteturas básicas de MPU e MCU.",
                                  "commonMistakes": "Confundir MPU com MCU; ignorar que MPU precisa de placa-mãe externa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Periféricos Essenciais como ADC, PWM e Outros",
                                  "subSteps": [
                                    "Estude ADC (Analog-to-Digital Converter): função de converter sinais analógicos em digitais, resolução (bits), taxa de amostragem.",
                                    "Explore PWM (Pulse Width Modulation): geração de sinais para controle de motores/serviços, duty cycle, frequência.",
                                    "Identifique outros periféricos comuns: UART, SPI, I2C para comunicação; timers, GPIOs.",
                                    "Compare implementação em MCU populares: ex. AVR em Arduino vs ARM em STM32.",
                                    "Simule um periférico simples usando ferramentas online como Tinkercad."
                                  ],
                                  "verification": "Descreva em um relatório curto como ADC e PWM funcionam em um diagrama de blocos com exemplos numéricos.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Datasheets de MCU (ex. ATmega328, STM32), simulador Tinkercad ou Proteus, calculadora para duty cycle.",
                                  "tips": "Lembre-se: PWM não é analógico, mas simula via média temporal.",
                                  "learningObjective": "Compreender e diferenciar periféricos chave e suas especificações técnicas.",
                                  "commonMistakes": "Confundir resolução ADC com precisão; ignorar impacto de ruído em ADC."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Critérios de Seleção para Projetos Mecatrônicos",
                                  "subSteps": [
                                    "Avalie clock speed, consumo de energia e memória (RAM/Flash) para requisitos do projeto.",
                                    "Considere periféricos necessários: ex. múltiplos PWM para motores, ADC para sensores.",
                                    "Analise custo, disponibilidade, suporte de software (IDE, bibliotecas) e escalabilidade.",
                                    "Crie uma matriz de decisão: liste 3 MCU (Arduino, ESP32, PIC) e pontue por critérios.",
                                    "Considere fatores ambientais: temperatura, vibração em mecatrônica industrial."
                                  ],
                                  "verification": "Preencha uma tabela de seleção para um projeto hipotético e justifique escolhas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Planilha Excel/Google Sheets, sites de distribuidores (DigiKey, Mouser) para preços/datasheets.",
                                  "tips": "Priorize 'good enough' sobre overkill para otimizar custo e eficiência.",
                                  "learningObjective": "Aplicar critérios quantitativos e qualitativos para seleção de componentes.",
                                  "commonMistakes": "Focar só em clock speed ignorando consumo; não verificar pinagem disponível."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Aplicar em Cenários Mecatrônicos Reais",
                                  "subSteps": [
                                    "Selecione 2-3 MCU e compare specs em tabela: arquitetura, periféricos, preço.",
                                    "Simule seleção para projeto: ex. braço robótico precisando ADC (sensores) + PWM (servos).",
                                    "Discuta trade-offs: ex. ESP32 (WiFi integrado) vs ATmega (mais barato).",
                                    "Crie um fluxograma de decisão para seleção futura.",
                                    "Revise casos de falha reais: ex. MCU sem ADC suficiente em automação."
                                  ],
                                  "verification": "Apresente comparação em slide ou vídeo curto (1 min) justificando escolha para um projeto.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de apresentação (PowerPoint/Google Slides), exemplos de projetos mecatrônicos online.",
                                  "tips": "Sempre valide com protótipo virtual antes de comprar hardware.",
                                  "learningObjective": "Integrar conhecimentos para diferenciar e selecionar componentes em contextos práticos.",
                                  "commonMistakes": "Ignorar compatibilidade de software; superestimar necessidades iniciais."
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de braço robótico mecatrônico: selecione ESP32 (ARM, múltiplos ADC/PWM, WiFi para teleoperação) sobre ATmega328 (8-bit, menos periféricos), justificando pela necessidade de 4 PWMs para servos e 2 ADCs para sensores de posição/força, com clock de 240MHz para resposta rápida.",
                              "finalVerifications": [
                                "Lista corretamente 5 diferenças chave entre MPU e MCU.",
                                "Explica funcionamento de ADC e PWM com exemplos numéricos (ex. duty cycle 50%).",
                                "Cria matriz de seleção válida para um projeto mecatrônico específico.",
                                "Identifica periféricos necessários para 3 cenários comuns (motor, sensor, comunicação).",
                                "Justifica escolha de MCU com trade-offs claros (custo vs performance).",
                                "Desenha diagrama de arquitetura básica de um MCU."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: definições e specs corretas (30%)",
                                "Profundidade de análise: cobertura de periféricos e critérios (25%)",
                                "Aplicação prática: exemplos relevantes a mecatrônica (20%)",
                                "Clareza na comunicação: diagramas/tabelas legíveis (15%)",
                                "Originalidade: insights pessoais ou trade-offs únicos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Integração com sensores e atuadores analógicos/digitais.",
                                "Programação: Uso de bibliotecas para periféricos em C/Arduino IDE.",
                                "Mecânica: Seleção para controle de movimento em robótica.",
                                "Gestão de Projetos: Critérios de custo/escalabilidade em design integrado."
                              ],
                              "realWorldApplication": "Em indústrias automotivas (ECUs em veículos com ADC para sensores e PWM para injeção), manufatura (CLPs mecatrônicos controlando linhas de produção) e IoT (drones com MCU para estabilização via PWM e telemetria via ADC), onde seleção errada leva a falhas caras ou ineficiências energéticas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.4.2",
                            "name": "Programação de Microcontroladores",
                            "description": "Escrever firmware em linguagens como C/Assembly para controle de atuadores e leitura de sensores em ambientes mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Instalar IDE como Arduino IDE ou MPLAB X para microcontroladores.",
                                    "Selecionar e configurar o microcontrolador (ex: PIC16F ou AVR ATmega).",
                                    "Configurar bibliotecas para comunicação serial e periféricos.",
                                    "Testar compilação de um programa 'Hello World' com LED piscando.",
                                    "Configurar debugger ou simulador integrado."
                                  ],
                                  "verification": "Programa 'Hello World' compila e faz LED piscar no hardware ou simulador.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "Computador, microcontrolador (ex: Arduino Uno), cabo USB, IDE instalada, breadboard.",
                                  "tips": "Use simuladores como Proteus para testes iniciais sem hardware.",
                                  "learningObjective": "Configurar ambiente completo para programação de firmware.",
                                  "commonMistakes": "Drivers USB não instalados; portas COM erradas selecionadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Leitura e Processamento de Sensores",
                                  "subSteps": [
                                    "Estudar datasheet do sensor (ex: LM35 para temperatura).",
                                    "Configurar pinos ADC no firmware em C.",
                                    "Escrever código para leitura analógica/digital e conversão de dados.",
                                    "Implementar filtro simples (média móvel) para ruído.",
                                    "Enviar dados via serial para monitoramento."
                                  ],
                                  "verification": "Dados do sensor exibidos corretamente no monitor serial com variação real.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Sensor (LM35 ou potenciômetro), multímetro, osciloscópio opcional.",
                                  "tips": "Calibre o ADC com referência conhecida para precisão.",
                                  "learningObjective": "Capturar e processar sinais de sensores de forma confiável.",
                                  "commonMistakes": "Pinos errados configurados; escala ADC não convertida corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Controle de Atuadores",
                                  "subSteps": [
                                    "Analisar requisitos do atuador (ex: servo motor ou relé).",
                                    "Configurar PWM ou GPIOs para saída.",
                                    "Escrever funções de controle (ex: PID básico para motor).",
                                    "Integrar lógica de controle baseada em leituras de sensores.",
                                    "Adicionar proteções como debounce ou limites de duty cycle."
                                  ],
                                  "verification": "Atuador responde corretamente a comandos (ex: servo gira conforme temperatura).",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Servo motor, relé, fonte de alimentação externa.",
                                  "tips": "Use timers para PWM preciso em vez de delays bloqueantes.",
                                  "learningObjective": "Implementar controle preciso de atuadores via firmware.",
                                  "commonMistakes": "Sobrecarga de atuador sem limite; loops bloqueantes causam instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração, Testes e Depuração",
                                  "subSteps": [
                                    "Combinar módulos de sensor e atuador em loop principal.",
                                    "Implementar estados finitos para gerenciamento de modos.",
                                    "Testar em cenários reais com interrupções.",
                                    "Usar debugger para breakpoints e watch variables.",
                                    "Otimizar código para consumo de energia e performance."
                                  ],
                                  "verification": "Sistema integrado funciona autonomamente por 30 minutos sem falhas.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Sistema completo montado, logic analyzer opcional.",
                                  "tips": "Estruture código em funções modulares para facilitar depuração.",
                                  "learningObjective": "Criar firmware integrado robusto e depurável.",
                                  "commonMistakes": "Stack overflow por recursão; falha em tratar edge cases."
                                }
                              ],
                              "practicalExample": "Desenvolver firmware para um microcontrolador Arduino que lê temperatura de um sensor LM35 e controla um servo motor para abrir uma ventilação quando >30°C, com dados logados via serial.",
                              "finalVerifications": [
                                "Firmware compila sem warnings e carrega no microcontrolador.",
                                "Leitura de sensor varia linearmente com estímulos reais.",
                                "Atuador ativa/desativa baseado em thresholds corretos.",
                                "Sistema opera estável por >1 hora em loop fechado.",
                                "Consumo de energia dentro de specs do microcontrolador.",
                                "Código comentado e modular para reutilização."
                              ],
                              "assessmentCriteria": [
                                "Precisão e robustez na leitura/processamento de sensores (erro <5%).",
                                "Eficiência no controle de atuadores (resposta <100ms).",
                                "Qualidade do código: legível, modular, sem vazamentos de memória.",
                                "Uso correto de periféricos (ADC, PWM, timers).",
                                "Capacidade de depuração e tratamento de erros.",
                                "Otimização para ambiente mecatrônico real (baixo consumo)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Configuração de circuitos analógicos/digitais.",
                                "Programação: Estruturas em C (ponteiros, interrupções).",
                                "Mecânica: Integração com atuadores cinemáticos.",
                                "Matemática: Algoritmos de controle (PID, filtros).",
                                "Física: Sensores baseados em princípios termodinâmicos/elétricos."
                              ],
                              "realWorldApplication": "Desenvolvimento de sistemas de automação industrial, como controladores de temperatura em linhas de produção mecatrônicas, robôs autônomos ou dispositivos IoT para monitoramento ambiental."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.4.3",
                            "name": "Uso de CLPs em Automação",
                            "description": "Configurar Controladores Lógicos Programáveis (CLPs) para sequências lógicas e integração com robótica e visão em projetos industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de CLPs e sequências lógicas",
                                  "subSteps": [
                                    "Estudar a arquitetura de um CLP (CPU, I/Os, memória).",
                                    "Aprender diagramas ladder e linguagens de programação IEC 61131-3.",
                                    "Analisar exemplos de sequências lógicas simples (ex: motor liga/desliga).",
                                    "Identificar entradas/saídas digitais e analógicas em automação.",
                                    "Revisar conceitos de temporizadores e contadores."
                                  ],
                                  "verification": "Resumir em um diagrama os componentes principais de um CLP e uma sequência lógica básica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Manual do CLP (ex: Siemens S7), apostila de ladder logic, computador com internet para vídeos tutoriais."
                                  ],
                                  "tips": "Use simuladores online gratuitos como PLCSIM para visualizar conceitos sem hardware.",
                                  "learningObjective": "Entender os princípios básicos de CLPs e como sequências lógicas controlam processos.",
                                  "commonMistakes": [
                                    "Confundir contatos normalmente abertos/fechados.",
                                    "Ignorar ciclos de scan do CLP."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o ambiente de hardware do CLP",
                                  "subSteps": [
                                    "Montar o rack do CLP com módulos de I/O necessários.",
                                    "Conectar sensores, atuadores e fontes de alimentação.",
                                    "Configurar endereçamento de I/Os no software de configuração.",
                                    "Testar conexões com multímetro e alimentação segura.",
                                    "Instalar cabos de comunicação (ex: Profinet para rede)."
                                  ],
                                  "verification": "Alimentar o CLP e verificar LEDs de status e comunicação sem erros.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "CLP (ex: Siemens S7-1200), módulos I/O, sensores, atuadores, cabos, multímetro."
                                  ],
                                  "tips": "Sempre desligue a alimentação antes de conectar fios para evitar danos.",
                                  "learningObjective": "Configurar fisicamente um CLP para operação em projetos industriais.",
                                  "commonMistakes": [
                                    "Polaridade invertida em sensores.",
                                    "Endereços I/O duplicados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Programar sequências lógicas no software do CLP",
                                  "subSteps": [
                                    "Instalar e configurar o software (ex: TIA Portal).",
                                    "Criar projeto novo e mapear I/Os físicos.",
                                    "Desenhar rede ladder para sequência (ex: partida/parada com temporizador).",
                                    "Compilar e fazer download para o CLP.",
                                    "Executar em modo RUN e monitorar variáveis online."
                                  ],
                                  "verification": "O programa compila sem erros e executa uma sequência simples (ex: LED pisca).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software TIA Portal ou equivalente, computador, CLP conectado via Ethernet."
                                  ],
                                  "tips": "Use blocos de função (FB) para reutilizar lógica em sequências complexas.",
                                  "learningObjective": "Desenvolver e implementar programas ladder para controle sequencial.",
                                  "commonMistakes": [
                                    "Esquecer de resetar temporizadores.",
                                    "Lógica de intertravamento incompleta."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar o CLP com robótica e visão computacional",
                                  "subSteps": [
                                    "Configurar comunicação Modbus/TCP ou Profinet entre CLP e robô.",
                                    "Integrar câmera de visão (ex: Cognex) via Ethernet/IP.",
                                    "Programar triggers no CLP baseados em sinais de visão (ex: posição detectada).",
                                    "Sincronizar sequência: visão detecta → CLP sinaliza robô → atuador move.",
                                    "Testar handshake de dados em loop fechado."
                                  ],
                                  "verification": "CLP recebe dados de visão e comanda robô corretamente em simulação.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Robô educacional (ex: UR3), câmera de visão, CLP, software de integração."
                                  ],
                                  "tips": "Monitore tráfego de rede com Wireshark para depurar comunicações.",
                                  "learningObjective": "Realizar integração de CLP em sistemas mecatrônicos com robótica e visão.",
                                  "commonMistakes": [
                                    "Timeouts em comunicação não configurados.",
                                    "Formato de dados incompatível."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, depurar e validar o sistema integrado",
                                  "subSteps": [
                                    "Executar testes unitários em cada módulo.",
                                    "Simular falhas (ex: sensor defeituoso) e verificar respostas.",
                                    "Analisar logs de erro e oscilogramas no software.",
                                    "Otimizar tempos de ciclo e segurança (ex: E-stops).",
                                    "Documentar o projeto com prints e relatório."
                                  ],
                                  "verification": "Sistema completo executa ciclo industrial sem falhas em 10 rodadas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Sistema montado, software de monitoramento, ferramentas de depuração."
                                  ],
                                  "tips": "Use modo STEP para depuração segura em sequências críticas.",
                                  "learningObjective": "Garantir robustez e confiabilidade do sistema automatizado.",
                                  "commonMistakes": [
                                    "Testes insuficientes em bordas.",
                                    "Ignorar EMC (compatibilidade eletromagnética)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma célula de montagem industrial, configure um CLP Siemens S7 para controlar um transportador: quando a câmera de visão detecta uma peça na posição correta, o CLP ativa um braço robótico UR para pick-and-place, parando a sequência se houver defeito.",
                              "finalVerifications": [
                                "CLP executa sequências lógicas sem erros de compilação ou runtime.",
                                "Integração com robótica e visão responde em <500ms.",
                                "Sistema resiste a falhas simuladas (ex: perda de sinal).",
                                "Documentação completa com diagramas e códigos.",
                                "Eficiência: ciclo completo em tempo alvo.",
                                "Segurança: E-stops e intertravamentos funcionam."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção da programação ladder (sem bugs lógicos).",
                                "Qualidade da integração de hardware e comunicação.",
                                "Eficiência temporal e otimização de recursos.",
                                "Robustez em testes de falha e depuração.",
                                "Clareza da documentação e relatórios.",
                                "Aplicação correta de conceitos de sequências e temporizadores."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Projeto de circuitos de I/O e sensores.",
                                "Programação: Lógica em linguagens ladder e estruturadas.",
                                "Mecânica: Cinemática de robôs e atuadores.",
                                "Informática: Processamento de imagens em visão computacional.",
                                "Gestão de Projetos: Planejamento e documentação industrial."
                              ],
                              "realWorldApplication": "Na indústria manufatureira, como fábricas automotivas (ex: linha de soldagem robótica da Volkswagen), CLPs integram visão para inspeção de qualidade e controle preciso de robôs, reduzindo defeitos em 30% e aumentando produtividade."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.4.4",
                            "name": "Elaboração de Projetos Mecatrônicos",
                            "description": "Planejar e executar protótipos integrando microcontroladores, visão e robótica, com testes e validação baseada em bibliografia como Cross e Shetty.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definição de Requisitos e Planejamento do Projeto",
                                  "subSteps": [
                                    "Analise o problema e identifique requisitos funcionais e não funcionais.",
                                    "Defina objetivos SMART (Específicos, Mensuráveis, Alcançáveis, Relevantes, Temporais).",
                                    "Crie um diagrama de Gantt ou cronograma preliminar.",
                                    "Pesquise bibliografia relevante, como Cross e Shetty para princípios de design.",
                                    "Elabore um escopo inicial com deliverables."
                                  ],
                                  "verification": "Documento de planejamento aprovado com requisitos claros e cronograma.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Engineering Design' de Cross e Shetty",
                                    "Software de diagramação (ex: Lucidchart)",
                                    "Notebook"
                                  ],
                                  "tips": "Priorize requisitos críticos usando MoSCoW (Must, Should, Could, Won't).",
                                  "learningObjective": "Compreender e documentar requisitos para guiar o desenvolvimento mecatrônico.",
                                  "commonMistakes": [
                                    "Ignorar restrições de custo/tempo",
                                    "Requisitos vagos sem métricas",
                                    "Não consultar bibliografia inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Design Conceitual e Arquitetura do Sistema",
                                  "subSteps": [
                                    "Desenhe blocos funcionais: microcontrolador, sensores de visão, atuadores robóticos.",
                                    "Crie diagramas de fluxo de dados e esquemáticos elétricos preliminares.",
                                    "Selecione componentes compatíveis (ex: Arduino/ESP32 para microcontrolador, câmera OV7670).",
                                    "Simule o sistema em software (ex: Tinkercad ou Proteus).",
                                    "Valide design com princípios de Cross e Shetty (iteração e trade-offs)."
                                  ],
                                  "verification": "Diagramas e simulações aprovados por revisão par.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Software de simulação (Tinkercad, Fritzing)",
                                    "Catálogos de componentes (DigiKey)",
                                    "Papel e caneta para sketches"
                                  ],
                                  "tips": "Use modularidade para facilitar integração futura.",
                                  "learningObjective": "Desenvolver arquitetura integrada de hardware e software mecatrônico.",
                                  "commonMistakes": [
                                    "Sobredimensionar componentes desnecessariamente",
                                    "Ignorar interfaces de comunicação (I2C/SPI)",
                                    "Pular simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montagem e Implementação do Hardware",
                                  "subSteps": [
                                    "Monte o protótipo físico: conecte microcontrolador, câmera de visão e motores robóticos.",
                                    "Teste conexões elétricas com multímetro.",
                                    "Integre sensores de visão (ex: processamento de imagem básico).",
                                    "Calibre atuadores e sensores.",
                                    "Documente montagem com fotos e esquemáticos finais."
                                  ],
                                  "verification": "Hardware operacional com testes básicos de continuidade e alimentação.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Microcontrolador (Arduino Uno)",
                                    "Câmera módulo (ex: OV7670)",
                                    "Motores DC/servos",
                                    "Protoboard, fios, solda",
                                    "Multímetro"
                                  ],
                                  "tips": "Use protoboard para protótipos rápidos; evite solda inicial.",
                                  "learningObjective": "Construir protótipo físico funcional integrando componentes mecatrônicos.",
                                  "commonMistakes": [
                                    "Conexões invertidas",
                                    "Falta de proteção contra curtos",
                                    "Calibração inadequada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolvimento e Integração de Software",
                                  "subSteps": [
                                    "Programe o microcontrolador para leitura de visão e controle robótico.",
                                    "Implemente algoritmos de processamento de imagem (ex: detecção de bordas).",
                                    "Integre loops de controle PID para robótica.",
                                    "Teste unidades de código separadamente.",
                                    "Faça upload e debug inicial no hardware."
                                  ],
                                  "verification": "Código compilado e rodando sem erros críticos no protótipo.",
                                  "estimatedTime": "10 horas",
                                  "materials": [
                                    "IDE Arduino ou PlatformIO",
                                    "Bibliotecas (OpenCV lite, PID library)",
                                    "Computador com USB"
                                  ],
                                  "tips": "Use versionamento com Git para rastrear mudanças.",
                                  "learningObjective": "Programar firmware integrado para sistemas mecatrônicos com visão e robótica.",
                                  "commonMistakes": [
                                    "Loops infinitos sem timeout",
                                    "Ignorar debounce em sensores",
                                    "Código monolítico sem funções modulares"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes, Validação e Documentação Final",
                                  "subSteps": [
                                    "Execute testes unitários, integrados e de sistema.",
                                    "Valide performance contra requisitos usando métricas de Cross e Shetty.",
                                    "Registre dados de testes em planilhas.",
                                    "Otimize e itere baseado em falhas.",
                                    "Elabore relatório final com lições aprendidas."
                                  ],
                                  "verification": "Relatório completo com protótipo validado e dados empíricos.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Osciloscópio opcional",
                                    "Planilhas Excel/Google Sheets",
                                    "Câmera para vídeos de teste"
                                  ],
                                  "tips": "Automatize testes repetitivos com scripts.",
                                  "learningObjective": "Validar protótipo mecatrônico com testes rigorosos e documentação.",
                                  "commonMistakes": [
                                    "Testes insuficientes em cenários edge",
                                    "Relatório sem evidências quantitativas",
                                    "Não iterar após falhas"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver um robô seguidor de linha que usa câmera para detectar e seguir linhas coloridas, controlado por Arduino com motores DC, simulando inspeção industrial.",
                              "finalVerifications": [
                                "Protótipo integra microcontrolador, visão e robótica funcionalmente.",
                                "Testes mostram precisão >90% em tarefas definidas.",
                                "Documentação inclui esquemáticos, código e relatório de validação.",
                                "Validação alinhada com princípios de Cross e Shetty.",
                                "Cronograma respeitado com lições aprendidas registradas.",
                                "Demonstração ao vivo sem falhas críticas."
                              ],
                              "assessmentCriteria": [
                                "Clareza e completude do planejamento (20%)",
                                "Qualidade do design e simulação (20%)",
                                "Funcionalidade do hardware montado (20%)",
                                "Robustez do software integrado (20%)",
                                "Resultados de testes e validação (10%)",
                                "Documentação e apresentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos de visão computacional e controle.",
                                "Eletrônica: Circuitos e interfaces de sensores.",
                                "Mecânica: Cinemática de robôs e atuadores.",
                                "Gestão de Projetos: Planejamento e validação iterativa.",
                                "Matemática: Modelos PID e processamento de imagem."
                              ],
                              "realWorldApplication": "Desenvolvimento de robôs industriais para inspeção automatizada em linhas de produção, como detecção de defeitos via visão em fábricas automotivas ou farmacêuticas."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Times Multifuncionais",
                    "description": "Estratégias de trabalho colaborativo em equipes interdisciplinares para projetos mecatrônicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1.1",
                        "name": "Composição de Times Multifuncionais",
                        "description": "Definição dos perfis profissionais e papéis essenciais em equipes interdisciplinares para o desenvolvimento integrado de produtos mecatrônicos, incluindo engenheiros mecânicos, elétricos, de controle e software.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1.1",
                            "name": "Identificar papéis principais em times mecatrônicos",
                            "description": "Listar e descrever os papéis de engenheiros mecânicos, elétricos, de software e especialistas em controle em um projeto mecatrônico, com exemplos de integração em sistemas como robótica aeronáutica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e listar os papéis principais em times mecatrônicos",
                                  "subSteps": [
                                    "Revise definições de mecatrônica como integração de mecânica, eletrônica, software e controle.",
                                    "Identifique os quatro papéis principais: engenheiro mecânico, engenheiro elétrico, engenheiro de software e especialista em controle.",
                                    "Anote responsabilidades iniciais para cada papel com base em fontes confiáveis como livros de mecatrônica ou sites profissionais.",
                                    "Crie uma tabela simples com colunas para papel, foco principal e contribuições gerais.",
                                    "Compare papéis para destacar sobreposições iniciais."
                                  ],
                                  "verification": "Verifique se a lista inclui exatamente os quatro papéis com pelo menos uma responsabilidade anotada cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet ou livros de mecatrônica (ex: 'Mecatrônica' de Bolton)",
                                    "Papel ou planilha digital (Google Sheets)"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar sobreposições entre papéis.",
                                  "learningObjective": "Compreender a composição básica de um time mecatrônico multifuncional.",
                                  "commonMistakes": [
                                    "Confundir engenheiro elétrico com especialista em controle",
                                    "Omitir o papel de software em sistemas mecatrônicos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever responsabilidades detalhadas de cada papel",
                                  "subSteps": [
                                    "Para engenheiro mecânico: descreva design de estruturas, mecanismos e análise de tensões.",
                                    "Para engenheiro elétrico: detalhe circuitos, sensores, atuadores e sistemas de potência.",
                                    "Para engenheiro de software: explique desenvolvimento de firmware, algoritmos e interfaces homem-máquina.",
                                    "Para especialista em controle: cubra modelagem dinâmica, loops de feedback e estabilidade de sistemas.",
                                    "Inclua exemplos específicos para cada, como CAD para mecânica ou PID para controle."
                                  ],
                                  "verification": "Confira se cada papel tem 3-5 responsabilidades descritas com exemplos técnicos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Softwares gratuitos como Draw.io para diagramas",
                                    "Referências online (IEEE, ASME)"
                                  ],
                                  "tips": "Use bullet points para clareza e priorize responsabilidades únicas de cada papel.",
                                  "learningObjective": "Dominar as funções específicas e complementares de cada especialista.",
                                  "commonMistakes": [
                                    "Generalizar demais sem exemplos técnicos",
                                    "Ignorar interdependências entre papéis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar exemplos de integração em projetos de robótica aeronáutica",
                                  "subSteps": [
                                    "Escolha um sistema exemplo: drone UAV para inspeção aeronáutica.",
                                    "Descreva como o engenheiro mecânico integra chassi leve com hélices.",
                                    "Explique integração elétrica: baterias, motores e sensores GPS/IMU.",
                                    "Detalhe software para navegação autônoma e controle de voo.",
                                    "Mostre como especialista em controle otimiza estabilidade via algoritmos PID.",
                                    "Desenhe um fluxograma da integração dos papéis."
                                  ],
                                  "verification": "Valide o fluxograma mostrando fluxos de contribuição entre papéis.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramentas de desenho (Lucidchart ou papel)",
                                    "Vídeos de drones no YouTube (ex: projetos DIY)"
                                  ],
                                  "tips": "Foque em pontos de interface, como barramentos de comunicação (I2C/CAN).",
                                  "learningObjective": "Aplicar papéis em um contexto real de integração mecatrônica.",
                                  "commonMistakes": [
                                    "Descrever papéis isolados sem mostrar integrações",
                                    "Escolher exemplos não aeronáuticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e analisar composição de times multifuncionais",
                                  "subSteps": [
                                    "Analise como os papéis colaboram em fases de projeto (conceitual, protótipo, teste).",
                                    "Identifique desafios comuns de integração, como incompatibilidades de hardware/software.",
                                    "Proponha estratégias de comunicação (reuniões ágeis, ferramentas como Jira).",
                                    "Crie um organograma do time com linhas de reporte e interfaces.",
                                    "Reflita sobre escalabilidade para projetos maiores."
                                  ],
                                  "verification": "Revise o organograma para incluir todos os papéis e pelo menos duas estratégias de colaboração.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramentas de organograma (Canva ou Visio gratuito)",
                                    "Templates de times mecatrônicos online"
                                  ],
                                  "tips": "Considere papéis híbridos em times pequenos para realismo.",
                                  "learningObjective": "Avaliar dinâmicas de time para projetos mecatrônicos eficazes.",
                                  "commonMistakes": [
                                    "Focar só em tarefas individuais",
                                    "Subestimar necessidade de comunicação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de drone quadricóptero para monitoramento aeronáutico, o engenheiro mecânico projeta o frame de carbono resistente a vibrações; o elétrico integra ESC, baterias LiPo e IMU; o de software desenvolve código em ROS para path planning; o especialista em controle ajusta ganhos PID para hover estável, garantindo integração via protocolo MAVLink.",
                              "finalVerifications": [
                                "Lista precisa dos quatro papéis com descrições corretas.",
                                "Exemplo de integração em robótica aeronáutica com fluxograma.",
                                "Identificação de pelo menos três pontos de interface entre papéis.",
                                "Análise de desafios e soluções de colaboração.",
                                "Organograma funcional do time.",
                                "Reflexão escrita sobre importância da multifuncionalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das descrições de papéis (30%)",
                                "Qualidade e relevância dos exemplos de integração (25%)",
                                "Profundidade da análise de colaboração e desafios (20%)",
                                "Clareza de diagramas e fluxogramas (15%)",
                                "Criatividade em aplicações práticas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Planejamento ágil para times multifuncionais.",
                                "Comunicação: Relatórios técnicos e reuniões interdisciplinares.",
                                "Ética Profissional: Responsabilidades em segurança de sistemas autônomos.",
                                "Economia Empresarial: Alocação de recursos em times.",
                                "Matemática Aplicada: Modelagem de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, como em empresas como DJI ou Boeing, times mecatrônicos com esses papéis desenvolvem UAVs autônomos para entregas ou vigilância, otimizando integração para reduzir custos e tempo de desenvolvimento em 20-30%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.2",
                            "name": "Mapear responsabilidades por função",
                            "description": "Criar um organograma simples destacando responsabilidades específicas de cada membro da equipe multifuncional, considerando interfaces entre disciplinas como microcontroladores e visão por computador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar funções e membros da equipe multifuncional",
                                  "subSteps": [
                                    "Liste todas as disciplinas envolvidas no projeto (ex.: mecânica, eletrônica, software).",
                                    "Defina os papéis principais para cada disciplina (ex.: engenheiro mecânico, programador de visão computacional).",
                                    "Atribua nomes ou perfis fictícios aos membros da equipe.",
                                    "Registre o número de membros por função.",
                                    "Priorize funções críticas com base no escopo do projeto."
                                  ],
                                  "verification": "Verifique se a lista inclui pelo menos uma função por disciplina relevante e cobre 100% das necessidades do projeto.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Folha de papel, planilha Excel ou Google Sheets, quadro branco.",
                                  "tips": "Comece pelo escopo do projeto para evitar funções desnecessárias.",
                                  "learningObjective": "Compreender a composição de uma equipe multifuncional em mecatrônica.",
                                  "commonMistakes": "Ignorar funções de suporte como gerenciamento ou testes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir responsabilidades específicas por função",
                                  "subSteps": [
                                    "Para cada função, liste 3-5 responsabilidades principais (ex.: 'Desenvolver firmware para microcontroladores').",
                                    "Inclua tarefas diárias, entregas e métricas de desempenho.",
                                    "Garanta que responsabilidades sejam SMART (Específicas, Mensuráveis, Alcançáveis, Relevantes, Temporais).",
                                    "Revise para eliminar sobreposições iniciais.",
                                    "Documente em uma tabela: Função | Responsabilidades."
                                  ],
                                  "verification": "Confirme que cada função tem responsabilidades claras e sem ambiguidades.",
                                  "estimatedTime": "1,5 horas",
                                  "materials": "Planilha ou documento Google Docs, exemplos de organogramas de projetos mecatrônicos.",
                                  "tips": "Use verbos de ação no infinitivo para descrever responsabilidades.",
                                  "learningObjective": "Mapear tarefas acionáveis alinhadas a competências disciplinares.",
                                  "commonMistakes": "Responsabilidades vagas como 'fazer eletrônica' em vez de específicas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear interfaces e dependências entre funções",
                                  "subSteps": [
                                    "Identifique pontos de interação (ex.: microcontroladores recebem dados de visão computacional).",
                                    "Crie setas ou fluxos indicando dependências (quem entrega para quem).",
                                    "Descreva protocolos de comunicação (ex.: reuniões semanais, APIs compartilhadas).",
                                    "Avalie riscos de interfaces (ex.: atrasos em hardware afetam software).",
                                    "Adicione ao mapa: Função A → Interface → Função B."
                                  ],
                                  "verification": "Teste se todas as interfaces críticas estão mapeadas sem lacunas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software de diagramação como Draw.io, Lucidchart ou Microsoft Visio.",
                                  "tips": "Use cores diferentes para disciplinas para visualizar interfaces.",
                                  "learningObjective": "Reconhecer interdependências em times multifuncionais.",
                                  "commonMistakes": "Subestimar interfaces, causando silos disciplinares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar e refinar o organograma visual",
                                  "subSteps": [
                                    "Desenhe a hierarquia: topo com líder, ramificando funções e responsabilidades.",
                                    "Inclua setas para interfaces entre funções.",
                                    "Adicione legendas para símbolos e abreviações.",
                                    "Revise com um colega fictício ou autoavaliação.",
                                    "Exporte em formato PDF ou imagem para compartilhamento."
                                  ],
                                  "verification": "O organograma é legível, completo e reflete todos os elementos mapeados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas gratuitas como Draw.io ou Canva, impressora opcional.",
                                  "tips": "Mantenha simples: evite excesso de texto; use ícones para disciplinas.",
                                  "learningObjective": "Produzir uma representação visual clara de responsabilidades e interfaces.",
                                  "commonMistakes": "Organograma muito complexo, difícil de entender à primeira vista."
                                }
                              ],
                              "practicalExample": "Em um projeto de drone autônomo, o organograma mostra: Engenheiro Mecânico (estrutura e aerodinâmica) → interface de sensores com Eletrônico (microcontroladores para controle de voo) → integração de dados com Desenvolvedor de Software (visão computacional para detecção de obstáculos). Responsabilidades: Mecânico - Projetar chassis; Eletrônico - Implementar PWM; Software - Algoritmo de tracking.",
                              "finalVerifications": [
                                "Todas as funções estão representadas no organograma?",
                                "Responsabilidades são específicas e mensuráveis?",
                                "Interfaces entre disciplinas como microcontroladores e visão computacional estão mapeadas?",
                                "O diagrama é visualmente claro e legível?",
                                "Não há sobreposições ou lacunas nas responsabilidades?",
                                "O organograma cobre o escopo completo do projeto?"
                              ],
                              "assessmentCriteria": [
                                "Completude: Cobertura de todas as funções e responsabilidades (20%)",
                                "Especificidade: Detalhes claros e acionáveis nas responsabilidades (25%)",
                                "Precisão das interfaces: Mapeamento correto de dependências (20%)",
                                "Clareza visual: Legibilidade e simplicidade do organograma (20%)",
                                "Alinhamento interdisciplinar: Consideração de integrações mecatrônicas (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: RACI Matrix para responsabilidades",
                                "Comunicação: Protocolos de handover entre disciplinas",
                                "Engenharia de Software: Modelagem UML para interfaces",
                                "Liderança: Alocação de recursos humanos"
                              ],
                              "realWorldApplication": "Em empresas como Bosch ou Siemens, organogramas assim são usados para coordenar times em desenvolvimento de sistemas mecatrônicos, como robôs industriais, reduzindo atrasos em interfaces entre hardware (microcontroladores) e software (visão computacional), otimizando entregas de produtos integrados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.3",
                            "name": "Analisar exemplos reais de composição",
                            "description": "Estudar casos de times multifuncionais em projetos industriais aeronáuticos, identificando como a diversidade de expertise contribui para o sucesso do desenvolvimento integrado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e Selecionar Exemplos Reais de Times Multifuncionais",
                                  "subSteps": [
                                    "Identifique fontes confiáveis como relatórios da Boeing, Airbus ou NASA sobre projetos aeronáuticos.",
                                    "Busque casos específicos de desenvolvimento integrado, como o Boeing 787 Dreamliner ou Airbus A350.",
                                    "Selecione 2-3 exemplos que destaquem times multifuncionais com diversidade de expertise.",
                                    "Registre metadados: data do projeto, escopo e resultados gerais.",
                                    "Compile uma lista inicial com links ou referências para cada caso."
                                  ],
                                  "verification": "Lista de 2-3 exemplos selecionados com fontes e resumo breve de cada um documentados em um relatório inicial.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Acesso à internet, bases de dados acadêmicas (Google Scholar, IEEE Xplore), relatórios industriais da Boeing/Airbus.",
                                  "tips": "Priorize casos com dados públicos sobre composição de times para facilitar a análise.",
                                  "learningObjective": "Desenvolver habilidades de pesquisa para identificar casos reais relevantes em engenharia aeronáutica.",
                                  "commonMistakes": "Selecionar exemplos genéricos sem foco em times multifuncionais ou sem dados sobre composição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear a Composição dos Times nos Exemplos Selecionados",
                                  "subSteps": [
                                    "Para cada exemplo, liste os membros principais do time e suas expertises (ex: engenheiros mecânicos, eletrônicos, software, gestores).",
                                    "Crie um diagrama ou tabela mostrando a distribuição de funções e origens (departamentos, empresas parceiras).",
                                    "Quantifique a diversidade: porcentagem de expertises únicas, número de disciplinas envolvidas.",
                                    "Identifique líderes e papéis de integração (ex: engenheiro mecatrônico como facilitador).",
                                    "Anote evidências documentadas de como o time foi formado."
                                  ],
                                  "verification": "Diagramas ou tabelas completas para cada exemplo, destacando pelo menos 5 expertises diferentes por time.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ferramentas de diagramação (Draw.io, Microsoft Visio), documentos dos cases selecionados.",
                                  "tips": "Use cores no diagrama para visualizar diversidade de expertises rapidamente.",
                                  "learningObjective": "Capacitar a mapear estruturas de times multifuncionais em contextos industriais reais.",
                                  "commonMistakes": "Ignorar contribuições de funções não-técnicas como marketing ou suprimentos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Contribuições da Diversidade de Expertise para o Sucesso",
                                  "subSteps": [
                                    "Para cada expertise, descreva contribuições específicas ao projeto (ex: software otimizou integração de sensores).",
                                    "Identifique sinergias: como combinações de expertises resolveram desafios integrados.",
                                    "Compare sucessos e falhas atribuíveis à composição do time.",
                                    "Avalie métricas de sucesso: tempo de desenvolvimento, custo, inovação gerada.",
                                    "Extraia padrões comuns de diversidade que impulsionaram o desenvolvimento integrado."
                                  ],
                                  "verification": "Relatório analítico com 3-5 contribuições por exemplo, ligado a evidências do case.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Planilhas para análise comparativa (Excel/Google Sheets), relatórios originais dos projetos.",
                                  "tips": "Use quotes diretas de relatórios para embasar contribuições e evitar subjetividade.",
                                  "learningObjective": "Entender mecanicamente como diversidade impulsiona inovação em projetos mecatrônicos aeronáuticos.",
                                  "commonMistakes": "Atribuir sucessos genericamente sem ligar a expertises específicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Lições Aprendidas e Recomendações",
                                  "subSteps": [
                                    "Compile insights chave: melhores práticas de composição para times aeronáuticos.",
                                    "Discuta desafios da diversidade (ex: comunicação) e como foram mitigados.",
                                    "Proponha recomendações para times futuros baseadas nos exemplos.",
                                    "Crie um framework simples para composição ideal de times multifuncionais.",
                                    "Revise o relatório completo para coerência e clareza."
                                  ],
                                  "verification": "Relatório final com lições, recomendações e framework, revisado por pares ou auto-avaliação.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Editor de texto (Word/Google Docs), checklist de revisão.",
                                  "tips": "Estruture lições em bullet points acionáveis para fácil aplicação.",
                                  "learningObjective": "Transformar análises em conhecimentos aplicáveis para design de times em projetos integrados.",
                                  "commonMistakes": "Focar só em sucessos, ignorando lições de falhas ou trade-offs."
                                }
                              ],
                              "practicalExample": "No desenvolvimento do Boeing 787 Dreamliner, um time multifuncional incluiu engenheiros mecânicos (estrutura), aviônicos (eletrônica), software (controles) e especialistas em materiais compósitos de parceiros globais como Toray. Essa diversidade permitiu integração simultânea de sistemas, reduzindo tempo de desenvolvimento em 30% apesar de desafios iniciais de comunicação.",
                              "finalVerifications": [
                                "Relatório identifica pelo menos 3 expertises por exemplo e suas contribuições específicas.",
                                "Diagramas de composição mostram diversidade quantitativamente (ex: % de disciplinas).",
                                "Análise liga diversidade diretamente a métricas de sucesso do projeto.",
                                "Lições aprendidas incluem pelo menos 2 recomendações acionáveis.",
                                "Todos os exemplos são de projetos aeronáuticos industriais reais com fontes citadas.",
                                "Framework proposto para times futuros é claro e baseado em evidências."
                              ],
                              "assessmentCriteria": [
                                "Profundidade da pesquisa: Fontes variadas e relevantes (20%)",
                                "Precisão no mapeamento de composições: Diagramas detalhados e quantitativos (25%)",
                                "Qualidade da análise de contribuições: Evidências ligadas a resultados (25%)",
                                "Originalidade das lições e recomendações: Insights acionáveis e inovadores (15%)",
                                "Clareza e estrutura do relatório final: Organização lógica e visual (10%)",
                                "Conexão com desenvolvimento integrado mecatrônico (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Modelos como Stage-Gate para formação de times.",
                                "Psicologia Organizacional: Dinâmicas de grupo e gerenciamento de diversidade.",
                                "Engenharia de Sistemas: Integração de disciplinas em V-Model.",
                                "Liderança e Comunicação: Habilidades para times distribuídos globalmente."
                              ],
                              "realWorldApplication": "Ao planejar um novo projeto de drone mecatrônico, use o framework aprendido para compor um time com 40% engenharia mecânica, 30% eletrônica/software e 30% suporte (testes/supply chain), garantindo integração precoce e reduzindo riscos de retrabalho em 25%, similar aos cases aeronáuticos analisados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.1.2",
                        "name": "Estratégias de Colaboração Interdisciplinar",
                        "description": "Técnicas e ferramentas para promover o trabalho colaborativo eficiente em equipes multifuncionais, alinhadas ao desenvolvimento integrado de produtos mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.2.1",
                            "name": "Aplicar métodos de comunicação eficaz",
                            "description": "Implementar protocolos de comunicação como reuniões diárias stand-up e relatórios compartilhados para alinhar equipes em projetos envolvendo microprocessadores e CLPs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir protocolos de comunicação para o projeto",
                                  "subSteps": [
                                    "Identifique os membros da equipe e seus papéis (ex.: engenheiro de microprocessadores, programador de CLP).",
                                    "Escolha protocolos específicos: stand-ups diários de 15 minutos e relatórios semanais compartilhados.",
                                    "Defina agenda padrão para stand-ups: ontem, hoje, bloqueios.",
                                    "Estabeleça ferramentas: Slack/Teams para chat, Google Drive para relatórios, calendário compartilhado.",
                                    "Crie um documento de regras de comunicação e obtenha aprovação da equipe."
                                  ],
                                  "verification": "Documento de protocolos aprovado por todos os membros da equipe via assinatura digital ou confirmação em chat.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Google Docs ou Microsoft Word, calendário compartilhado (Google Calendar), lista de membros da equipe.",
                                  "tips": "Mantenha os protocolos simples para adesão fácil; envolva todos na definição para buy-in.",
                                  "learningObjective": "Compreender e customizar protocolos de comunicação adaptados ao contexto de projetos mecatrônicos.",
                                  "commonMistakes": "Definir protocolos muito rígidos sem flexibilidade para equipes multidisciplinares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ferramentas e ambiente de comunicação",
                                  "subSteps": [
                                    "Crie canais dedicados no Slack/Teams para o projeto (ex.: #standup-diario, #relatorios-clp).",
                                    "Configure calendário com convites automáticos para stand-ups diários às 9h.",
                                    "Crie template de relatório compartilhado no Google Sheets com colunas: progresso microprocessadores, issues CLP, próximos passos.",
                                    "Teste as ferramentas com um dry-run de 5 minutos com a equipe.",
                                    "Treine a equipe brevemente sobre uso das ferramentas (5-10 min por ferramenta)."
                                  ],
                                  "verification": "Teste bem-sucedido com registro de tela ou log de chat confirmando configuração funcional.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Slack/Microsoft Teams, Google Calendar, Google Sheets, computador com internet.",
                                  "tips": "Use integrações automáticas (ex.: bots para lembretes de stand-up) para reduzir carga manual.",
                                  "learningObjective": "Dominar configuração de ferramentas colaborativas para comunicação síncrona e assíncrona.",
                                  "commonMistakes": "Escolher ferramentas sem verificar compatibilidade com todos os dispositivos da equipe."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar stand-ups diários e relatórios compartilhados",
                                  "subSteps": [
                                    "Inicie o stand-up pontualmente: cada membro responde em 1-2 min (ontem, hoje, bloqueios).",
                                    "Registre bloqueios em canal dedicado e atribua responsáveis.",
                                    "Atualize relatório compartilhado pós-stand-up com métricas (ex.: % completado em programação CLP).",
                                    "Garanta inclusão de todos, rotacionando facilitador semanalmente.",
                                    "Encerrar com alinhamento rápido de prioridades para o dia."
                                  ],
                                  "verification": "Registro do stand-up no chat e relatório atualizado com entradas de pelo menos 80% da equipe.",
                                  "estimatedTime": "20 minutos por stand-up + 10 minutos para relatório",
                                  "materials": "Plataforma de videochamada (Zoom/Teams), template de relatório, timer para controle de tempo.",
                                  "tips": "Fique em pé durante stand-ups para manter energia e brevidade.",
                                  "learningObjective": "Aplicar protocolos em tempo real para alinhamento diário em projetos técnicos.",
                                  "commonMistakes": "Permitir que stand-ups excedam 15 minutos, levando a fadiga da equipe."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Monitorar eficácia e ajustar protocolos",
                                  "subSteps": [
                                    "Colete feedback semanal via formulário anônimo (Google Forms).",
                                    "Analise métricas: taxa de adesão, resolução de bloqueios, satisfação da equipe.",
                                    "Identifique gaps (ex.: relatórios não atualizados) e proponha ajustes.",
                                    "Realize reunião de retrospectiva mensal para refinar protocolos.",
                                    "Documente mudanças e comunique à equipe."
                                  ],
                                  "verification": "Relatório de feedback processado com pelo menos 2 ajustes implementados e comunicados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Google Forms para feedback, planilha de métricas, ata de reunião.",
                                  "tips": "Use dados quantitativos (ex.: tempo de resolução de issues) para embasar ajustes.",
                                  "learningObjective": "Avaliar e iterar processos de comunicação para melhoria contínua.",
                                  "commonMistakes": "Ignorar feedback negativo, resultando em desengajamento da equipe."
                                }
                              ],
                              "practicalExample": "Em um projeto de automação de linha de produção com microprocessadores para sensores e CLPs para controle lógico, a equipe usa stand-ups diários para reportar: 'Ontem integrei sensor ao microprocessador; hoje testo comunicação com CLP; bloqueio: delay na biblioteca.' Relatórios semanais trackam progresso, alinhando mecânicos, eletricistas e programadores, reduzindo erros de integração em 40%.",
                              "finalVerifications": [
                                "Equipe relata alinhamento diário com zero mal-entendidos em tarefas críticas.",
                                "Relatórios compartilhados atualizados em 95% das vezes com ações atribuídas.",
                                "Bloqueios resolvidos em até 24h via protocolos estabelecidos.",
                                "Feedback indica satisfação >80% com comunicação.",
                                "Métricas de projeto mostram redução em atrasos por falhas de comunicação.",
                                "Todos os membros participam ativamente de stand-ups."
                              ],
                              "assessmentCriteria": [
                                "Clareza e brevidade nas comunicações (nota 1-5).",
                                "Frequência e pontualidade de stand-ups e relatórios.",
                                "Resolução efetiva de bloqueios identificados.",
                                "Inclusão equitativa de todos os membros da equipe.",
                                "Adaptação baseada em feedback e métricas.",
                                "Integração com ferramentas técnicas (ex.: logs de CLP no relatório)."
                              ],
                              "crossCurricularConnections": [
                                "Gerenciamento de Projetos: Integra com metodologias Ágeis/Scrum.",
                                "Liderança e Trabalho em Equipe: Desenvolve habilidades de facilitação.",
                                "Programação e Eletrônica: Aplicação em debugging colaborativo de microprocessadores/CLPs.",
                                "Gestão da Qualidade: Melhora rastreabilidade em sistemas mecatrônicos."
                              ],
                              "realWorldApplication": "Na indústria de manufatura automatizada, como fábricas da Siemens ou Rockwell Automation, equipes usam stand-ups e relatórios para coordenar integração de CLPs com microprocessadores em linhas de montagem, garantindo uptime >99% e redução de downtimes por miscommunication."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.2",
                            "name": "Utilizar ferramentas colaborativas",
                            "description": "Selecionar e demonstrar o uso de ferramentas como Git, Jira ou Trello para gerenciamento de tarefas interdisciplinares em projetos mecatrônicos com robótica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e Selecionar Ferramenta Colaborativa Adequada",
                                  "subSteps": [
                                    "Analise as necessidades do projeto mecatrônico com robótica (ex: rastreamento de tarefas, versionamento de código, integração interdisciplinar).",
                                    "Compare Git (controle de versão), Jira (gerenciamento ágil) e Trello (kanban visual) com base em critérios como facilidade de uso, escalabilidade e suporte a equipes multidisciplinares.",
                                    "Crie uma tabela de prós e contras para cada ferramenta.",
                                    "Selecione a ferramenta mais adequada e justifique a escolha por escrito.",
                                    "Crie uma conta gratuita na ferramenta selecionada."
                                  ],
                                  "verification": "Tabela de comparação e justificativa documentada em um relatório curto (1 página).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Acesso à internet; sites oficiais de GitHub, Jira e Trello; planilha Google Sheets ou papel.",
                                  "tips": "Priorize ferramentas com integrações nativas para robótica (ex: GitHub Actions para CI/CD).",
                                  "learningObjective": "Identificar a ferramenta colaborativa que melhor atende às demandas de projetos interdisciplinares em mecatrônica.",
                                  "commonMistakes": "Escolher ferramenta sem considerar o tamanho da equipe ou complexidade do projeto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Ambiente Colaborativo",
                                  "subSteps": [
                                    "Crie um novo projeto ou board na ferramenta selecionada (ex: repositório GitHub, board Trello ou projeto Jira).",
                                    "Defina estrutura de boards/listas/épicos: To Do, In Progress, Done; adicione labels para disciplinas (Mecânica, Eletrônica, Software).",
                                    "Convide membros simulados da equipe (use contas de teste) e configure permissões (ex: branch protection no Git).",
                                    "Integre notificações via email/Slack para atualizações automáticas.",
                                    "Teste a configuração criando uma tarefa de exemplo."
                                  ],
                                  "verification": "Screenshot do board configurado com tarefas de teste e membros convidados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Conta gratuita na ferramenta; emails de teste para convites; simulador de equipe (amigos ou contas secundárias).",
                                  "tips": "Use templates prontos (ex: Trello para Agile) para agilizar a setup.",
                                  "learningObjective": "Configurar um ambiente colaborativo pronto para gerenciamento de tarefas em times multifuncionais.",
                                  "commonMistakes": "Ignorar permissões, levando a edições acidentais ou conflitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar Tarefas Interdisciplinares no Projeto",
                                  "subSteps": [
                                    "Crie tarefas específicas para um projeto robótico simulado (ex: 'Desenhar chassis mecânico', 'Programar controle PID', 'Testar sensores').",
                                    "Atribua tarefas a membros da equipe com prazos, dependências e descrições detalhadas.",
                                    "Atualize o status das tarefas em tempo real (mova cards, commit code no Git, log effort no Jira).",
                                    "Use comentários e anexos para feedback interdisciplinar (ex: engenheiro mecânico aprova design eletrônico).",
                                    "Gere relatórios de progresso (burndown chart ou log de commits)."
                                  ],
                                  "verification": "Relatório de progresso com pelo menos 10 tarefas criadas/atualizadas e histórico de interações.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Projeto robótico simulado; arquivos de design/código (ex: CAD, Arduino sketches); ferramenta selecionada.",
                                  "tips": "Defina dependências claras para evitar gargalos (ex: software só após hardware).",
                                  "learningObjective": "Aplicar a ferramenta para coordenar tarefas entre mecânica, eletrônica e software em robótica.",
                                  "commonMistakes": "Sobrecarregar tarefas sem descrições claras, causando confusão na equipe."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Revisar, Avaliar e Otimizar o Uso da Ferramenta",
                                  "subSteps": [
                                    "Realize uma retrospectiva: o que funcionou, o que melhorar no uso da ferramenta.",
                                    "Analise métricas (tempo de ciclo de tarefas, taxa de conclusão).",
                                    "Ajuste configurações baseadas no feedback (ex: adicionar automações).",
                                    "Documente lições aprendidas em um README ou wiki do projeto.",
                                    "Demonstre o fluxo completo em uma apresentação gravada."
                                  ],
                                  "verification": "Documento de retrospectiva e vídeo de 5 minutos demonstrando o uso.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Ferramenta de gravação (Loom ou celular); métricas exportadas da ferramenta.",
                                  "tips": "Incorpore feedback de 'equipe simulada' para realismo.",
                                  "learningObjective": "Avaliar e refinar processos colaborativos para eficiência em projetos mecatrônicos.",
                                  "commonMistakes": "Pular a retrospectiva, perdendo oportunidades de melhoria contínua."
                                }
                              ],
                              "practicalExample": "Em um projeto de robô seguidor de linha, use Trello: crie cards para 'Fabricar chassis (Mecânica)', 'Integrar motores (Eletrônica)', 'Codificar algoritmo PID (Software)'; mova cards conforme progresso, com comentários como 'Eletrônica aprovada pelo time de software' e anexos de códigos GitHub.",
                              "finalVerifications": [
                                "Todas as tarefas do projeto simulado foram criadas, atribuídas e concluídas na ferramenta.",
                                "Histórico de atualizações mostra interações interdisciplinares (comentários entre times).",
                                "Relatórios de progresso gerados corretamente (ex: burndown ou commits).",
                                "Configurações de permissões e notificações testadas e funcionais.",
                                "Retrospectiva documentada com pelo menos 3 melhorias propostas.",
                                "Demonstração gravada cobre fluxo completo de uso."
                              ],
                              "assessmentCriteria": [
                                "Seleção da ferramenta justificada com análise precisa (20%).",
                                "Configuração completa e funcional (25%).",
                                "Gerenciamento eficaz de tarefas interdisciplinares (30%).",
                                "Revisão e otimização com métricas (15%).",
                                "Documentação clara e demonstração profissional (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Integração com Git para versionamento de código robótico.",
                                "Gestão de Projetos: Alinhamento com metodologias Ágeis/Scrum.",
                                "Engenharia de Software: Uso de branches e pull requests para revisões.",
                                "Comunicação: Habilidades de feedback escrito em comentários.",
                                "Design Thinking: Iteração baseada em retrospectivas."
                              ],
                              "realWorldApplication": "Em empresas como Boston Dynamics ou Siemens, equipes mecatrônicas usam Jira/Git para coordenar desenvolvimento de robôs industriais, rastreando tarefas de prototipagem mecânica a deployment de firmware, reduzindo atrasos em 30% via visibilidade em tempo real."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.3",
                            "name": "Adotar metodologias ágeis adaptadas",
                            "description": "Adaptar práticas ágeis como Scrum para times multifuncionais, definindo sprints focados em integração de sistemas mecatrônicos como visão por computador e atuadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar contexto do time multifuncional e necessidades do projeto mecatrônico",
                                  "subSteps": [
                                    "Identifique os membros do time e suas especialidades (ex: engenheiros de software, hardware, visão computacional).",
                                    "Mapeie os componentes do sistema mecatrônico, como visão por computador e atuadores, e suas dependências de integração.",
                                    "Realize reuniões iniciais para coletar feedback sobre fluxos de trabalho atuais e gargalos.",
                                    "Defina objetivos do projeto em termos de entregas integradas, como protótipos funcionais.",
                                    "Crie um documento de análise inicial com riscos e oportunidades para agilidade."
                                  ],
                                  "verification": "Documento de análise aprovado pelo time, com mapeamento claro de papéis e dependências.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Ferramentas de colaboração (Miro, Jamboard), planilha de mapeamento (Google Sheets), gravações de reuniões.",
                                  "tips": "Envolva todos os membros desde o início para fomentar ownership.",
                                  "learningObjective": "Compreender dinâmicas multifuncionais em projetos mecatrônicos para basear adaptações ágeis.",
                                  "commonMistakes": "Ignorar feedbacks iniciais, levando a adaptações desalinhadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e customizar framework ágil base (Scrum adaptado)",
                                  "subSteps": [
                                    "Estude princípios Scrum: roles (PO, SM, Dev Team), eventos (Sprint Planning, Daily, Review, Retrospective).",
                                    "Adapte roles para multifuncionalidade: ex: Product Owner como engenheiro de sistemas, Dev Team com subequipes de visão e atuadores.",
                                    "Defina duração de sprints curta (1-2 semanas) focada em integrações incrementais.",
                                    "Incorpore práticas híbridas como Kanban para fluxos contínuos de hardware.",
                                    "Crie um playbook customizado documentando adaptações."
                                  ],
                                  "verification": "Playbook de Scrum adaptado revisado e assinado pelo time.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "Livros/guias Scrum (Scrum Guide PDF), templates de playbook (Notion ou Confluence).",
                                  "tips": "Priorize simplicidade nas adaptações para evitar sobrecarga.",
                                  "learningObjective": "Adaptar frameworks ágeis a contextos específicos de mecatrônica multifuncional.",
                                  "commonMistakes": "Adotar Scrum rígido sem customizações, causando frustrações em times técnicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir estrutura de sprints focados em integração mecatrônica",
                                  "subSteps": [
                                    "Planeje Sprint 0: backlog inicial com user stories para visão por computador e atuadores (ex: 'Como robô, eu quero detectar objetos para ativar atuador').",
                                    "Estabeleça Definition of Done (DoD) incluindo testes de integração hardware-software.",
                                    "Configure ferramentas: Jira/Trello para backlog, Git para versionamento de código/firmware.",
                                    "Simule um sprint planning com estimativas em story points ajustadas para tarefas mecatrônicas.",
                                    "Prepare rituais: dailies de 15min focados em bloqueios de integração."
                                  ],
                                  "verification": "Backlog inicial pronto com 5-10 user stories priorizadas e ferramentas configuradas.",
                                  "estimatedTime": "8-10 horas",
                                  "materials": "Ferramentas ágeis (Jira, Trello), protótipos iniciais de hardware/software.",
                                  "tips": "Use story points não-lineares para tarefas complexas como calibração de atuadores.",
                                  "learningObjective": "Estruturar sprints que promovam integrações ágeis em sistemas mecatrônicos.",
                                  "commonMistakes": "Sobrecarregar sprints com muitas integrações, levando a falhas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar piloto, monitorar e iterar",
                                  "subSteps": [
                                    "Execute um sprint piloto com entregas mínimas viáveis (MVP) de integração visão-atuadores.",
                                    "Realize dailies, review e retrospective semanais, ajustando baseados em métricas (velocity, burndown).",
                                    "Meça sucesso com KPIs: taxa de integração bem-sucedida, tempo de ciclo reduzido.",
                                    "Documente lições aprendidas e refine o playbook para sprints futuros.",
                                    "Escalone para o projeto completo após 2-3 sprints bem-sucedidos."
                                  ],
                                  "verification": "Relatório de sprint piloto com métricas positivas e ajustes implementados.",
                                  "estimatedTime": "2-4 semanas (piloto)",
                                  "materials": "Ambiente de desenvolvimento mecatrônico (Raspberry Pi, câmeras, atuadores), dashboards ágeis.",
                                  "tips": "Celebre pequenas vitórias para manter motivação em times multifuncionais.",
                                  "learningObjective": "Aplicar e refinar metodologias ágeis em cenários reais de mecatrônica.",
                                  "commonMistakes": "Não iterar após retrospectives, perpetuando ineficiências."
                                }
                              ],
                              "practicalExample": "Em um projeto de robô autônomo, adapte Scrum: Sprint 1 integra visão por computador (OpenCV em Raspberry Pi) com atuadores (servos); user story: 'Detectar bola vermelha e mover braço'. Time multifuncional: software dev planeja visão, hardware dev calibra atuadores; daily foca bloqueios como latência; review demo funcional.",
                              "finalVerifications": [
                                "Time executou pelo menos 2 sprints com integrações bem-sucedidas de visão e atuadores.",
                                "Playbook adaptado utilizado e refinado com feedback do time.",
                                "Métricas mostram redução no tempo de ciclo de integração em 30%.",
                                "Todos membros relatam maior colaboração interdisciplinar em retrospective.",
                                "Protótipo mecatrônico integrado demonstrado com DoD atendido.",
                                "Riscos iniciais mitigados via adaptações ágeis."
                              ],
                              "assessmentCriteria": [
                                "Profundidade da customização do Scrum para multifuncionalidade (rubrica 1-5).",
                                "Qualidade das user stories e backlog focados em integrações mecatrônicas.",
                                "Eficácia dos rituais ágeis em retrospectivas (participação e ações).",
                                "Melhoria mensurável em velocity e taxa de sucesso de sprints.",
                                "Documentação completa do playbook e lições aprendidas.",
                                "Demonstração prática de sprint com MVP funcional."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Integração com PMBOK para planejamento híbrido.",
                                "Engenharia de Software: Práticas DevOps para CI/CD em firmware.",
                                "Engenharia Mecânica: Sincronização com ciclos de prototipagem física.",
                                "Gestão de Equipes: Liderança e comunicação em times interdisciplinares."
                              ],
                              "realWorldApplication": "Na indústria automotiva (ex: Tesla), adaptações ágeis aceleram integração de visão computacional em veículos autônomos com atuadores de direção, reduzindo time-to-market de protótipos em 40% via sprints multifuncionais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.1.3",
                        "name": "Gerenciamento de Desafios em Times Multifuncionais",
                        "description": "Identificação e resolução de conflitos comuns em equipes interdisciplinares, garantindo a integração eficaz no contexto de projetos mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.3.1",
                            "name": "Reconhecer desafios típicos",
                            "description": "Identificar conflitos como diferenças de terminologia técnica entre disciplinas (ex.: mecânica vs. software) e impactos no cronograma de projetos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar terminologias chave das disciplinas envolvidas",
                                  "subSteps": [
                                    "Liste 10 termos técnicos comuns em mecânica (ex.: torque, inércia, fadiga).",
                                    "Liste 10 termos técnicos comuns em software (ex.: loop de controle, latência, API).",
                                    "Compare definições e usos em contextos mecatrônicos.",
                                    "Identifique 3 sobreposições semânticas (ex.: 'atraso' em mecânica vs. 'delay' em software).",
                                    "Crie um glossário inicial com definições unificadas."
                                  ],
                                  "verification": "Glossário completo com pelo menos 20 termos comparados e validados por referência em livros ou sites especializados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livros de mecânica (ex.: Shigley), documentação de software embarcado (ex.: Arduino docs), planilha Excel ou Google Sheets"
                                  ],
                                  "tips": "Use diagramas Venn para visualizar sobreposições e diferenças.",
                                  "learningObjective": "Compreender vocabulário básico de mecânica e software para identificar potenciais confusões.",
                                  "commonMistakes": [
                                    "Ignorar contextos específicos de aplicação mecatrônica.",
                                    "Confundir termos homônimos sem verificar definições precisas.",
                                    "Listar termos irrelevantes ao projeto."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar conflitos típicos de terminologia entre disciplinas",
                                  "subSteps": [
                                    "Analise cenários reais: busque casos de estudos de projetos mecatrônicos com falhas de comunicação.",
                                    "Mapeie 5 conflitos comuns (ex.: 'velocidade' como rpm em mecânica vs. baud rate em software).",
                                    "Classifique conflitos por gravidade (baixa, média, alta).",
                                    "Discuta em grupo ou simule diálogo entre 'engenheiro mecânico' e 'desenvolvedor software'.",
                                    "Documente padrões de conflito em uma tabela."
                                  ],
                                  "verification": "Tabela de conflitos com pelo menos 5 exemplos, classificados e com evidências de casos reais.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Artigos acadêmicos sobre mecatrônica (ex.: IEEE papers), vídeos de palestras TED sobre falhas em times multidisciplinares, ferramenta de mind mapping como MindMeister"
                                  ],
                                  "tips": "Registre áudios de simulações de diálogo para playback e análise.",
                                  "learningObjective": "Reconhecer padrões de conflitos terminológicos em interações multidisciplinares.",
                                  "commonMistakes": [
                                    "Focar apenas em exemplos genéricos sem ligação mecatrônica.",
                                    "Subestimar impactos culturais na interpretação de termos.",
                                    "Não classificar por frequência de ocorrência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impactos dos conflitos no cronograma de projetos",
                                  "subSteps": [
                                    "Desenhe um cronograma Gantt básico de um projeto mecatrônico hipotético.",
                                    "Simule inserção de um conflito terminológico e meça atrasos (ex.: 2 dias de reunião extra).",
                                    "Calcule métricas: % de atraso, custo adicional em horas-homem.",
                                    "Identifique pontos de mitigação no cronograma (ex.: revisão de glossário na fase de planejamento).",
                                    "Compare com cronogramas reais de projetos falhos."
                                  ],
                                  "verification": "Cronograma alterado com cálculos de impacto documentados e comparado a pelo menos 2 casos reais.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software de gerenciamento de projetos (ex.: MS Project, Trello), templates de Gantt, relatórios de post-mortem de projetos mecatrônicos"
                                  ],
                                  "tips": "Use cores para destacar impactos: vermelho para atrasos críticos.",
                                  "learningObjective": "Quantificar como conflitos terminológicos afetam prazos e recursos.",
                                  "commonMistakes": [
                                    "Ignorar efeitos em cadeia (ex.: atraso em software afeta testes mecânicos).",
                                    "Superestimar ou subestimar tempos sem base realista.",
                                    "Não considerar tamanhos de equipe variáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar reconhecimento em cenários simulados",
                                  "subSteps": [
                                    "Crie 3 cenários fictícios de reuniões de time multifuncional com diálogos conflituosos.",
                                    "Identifique desafios em tempo real durante role-playing.",
                                    "Registre soluções imediatas (ex.: pausar e consultar glossário).",
                                    "Avalie o cenário pós-simulação: o que foi reconhecido corretamente?",
                                    "Refine lista de desafios típicos com base na prática."
                                  ],
                                  "verification": "Relatório de prática com 3 cenários analisados, incluindo acertos/erros e lista refinada de desafios.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Roteiros de role-playing impressos, gravador de áudio/vídeo, timer para simulações"
                                  ],
                                  "tips": "Atue papéis opostos para empatia; grave para autoavaliação.",
                                  "learningObjective": "Aplicar reconhecimento de desafios em situações dinâmicas de time.",
                                  "commonMistakes": [
                                    "Evitar role-playing realista.",
                                    "Não pausar simulação para correções imediatas.",
                                    "Focar só em terminologia, ignorando impactos emocionais."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de braço robótico mecatrônico, o engenheiro mecânico menciona 'inércia do braço' como fator de design, enquanto o desenvolvedor software interpreta como 'inércia computacional' no loop de controle, levando a 3 dias de atraso em reuniões para esclarecer, impactando o milestone de protótipo.",
                              "finalVerifications": [
                                "Lista completa de pelo menos 10 conflitos terminológicos identificados com exemplos mecatrônicos.",
                                "Cronograma simulado com impactos quantificados (atraso >20% detectado).",
                                "Glossário unificado testado em 3 cenários de role-playing sem ambiguidades.",
                                "Relatório de prática com 80% de acerto no reconhecimento de desafios.",
                                "Conexões com gerenciamento de projetos documentadas.",
                                "Autoavaliação confirmando compreensão de impactos no cronograma."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de conflitos (90% de exemplos relevantes).",
                                "Profundidade na análise de impactos cronológicos (cálculos quantitativos incluídos).",
                                "Criatividade e realismo nos cenários práticos.",
                                "Completude do glossário e verificações (todos campos preenchidos).",
                                "Aplicação de tips e avoidance de common mistakes.",
                                "Integração interdisciplinar evidenciada."
                              ],
                              "crossCurricularConnections": [
                                "Comunicação Técnica: Criação de glossários compartilhados.",
                                "Gerenciamento de Projetos: Ferramentas como Gantt para mitigação de riscos.",
                                "Psicologia Organizacional: Dinâmicas de time e barreiras culturais.",
                                "Engenharia de Software: Padrões de documentação API para unificação.",
                                "Liderança: Facilitação de reuniões multidisciplinares."
                              ],
                              "realWorldApplication": "Em indústrias como automotiva (ex.: desenvolvimento de veículos autônomos na Bosch) ou robótica (ex.: times na Fanuc), onde falhas terminológicas causam atrasos milionários; profissionais treinados reduzem riscos em 30% via reconhecimento precoce."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3.2",
                            "name": "Implementar técnicas de resolução de conflitos",
                            "description": "Aplicar métodos como mediação e brainstorming interdisciplinar para resolver divergências em decisões de design de sistemas eletromecânicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Analisar o Conflito",
                                  "subSteps": [
                                    "Observar sinais visíveis de conflito, como discussões acaloradas, atrasos em reuniões ou tensão no time multifuncional.",
                                    "Realizar entrevistas individuais confidenciais com as partes envolvidas para coletar perspectivas.",
                                    "Mapear as divergências específicas relacionadas ao design eletromecânico, como escolhas de materiais ou integrações de sistemas.",
                                    "Identificar interesses subjacentes (ex.: segurança vs. custo) em vez de posições superficiais.",
                                    "Documentar causas raiz usando ferramentas como o diagrama de Ishikawa adaptado para times."
                                  ],
                                  "verification": "Relatório de análise do conflito criado e revisado pelo facilitador, com concordância inicial das partes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Quadro branco ou ferramenta digital como Miro",
                                    "Templates de análise de conflito (5 Whys ou Ishikawa)",
                                    "Bloco de notas para entrevistas"
                                  ],
                                  "tips": "Mantenha neutralidade e confidencialidade para construir confiança.",
                                  "learningObjective": "Desenvolver habilidade para diagnosticar conflitos de forma imparcial em contextos de design mecatrônico.",
                                  "commonMistakes": [
                                    "Julgar prematuramente as partes",
                                    "Focar apenas em sintomas visíveis sem causas raiz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Preparar a Técnica de Resolução",
                                  "subSteps": [
                                    "Avaliar o tipo de conflito (emocional, técnico ou processual) para escolher entre mediação ou brainstorming interdisciplinar.",
                                    "Preparar agenda da sessão: definir regras de ouro (respeito, escuta ativa) e duração.",
                                    "Convocar o time multifuncional e atribuir papéis (facilitador neutro, cronometrista).",
                                    "Preparar materiais específicos: flipcharts para brainstorming ou guias de mediação.",
                                    "Simular brevemente a técnica para testar viabilidade no contexto eletromecânico."
                                  ],
                                  "verification": "Plano de sessão aprovado por todas as partes, com materiais prontos e agenda distribuída.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Guias de mediação/brainstorming",
                                    "Ferramentas colaborativas como Jamboard ou MS Teams Whiteboard",
                                    "Lista de regras de engajamento"
                                  ],
                                  "tips": "Adapte a técnica ao tamanho do time: brainstorming para grupos grandes, mediação para bilaterais.",
                                  "learningObjective": "Selecionar técnicas adequadas para otimizar resoluções em times interdisciplinares de mecatrônica.",
                                  "commonMistakes": [
                                    "Escolher técnica inadequada sem análise prévia",
                                    "Omitir preparação de regras claras"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a Técnica de Resolução",
                                  "subSteps": [
                                    "Iniciar com rodada de escuta ativa: cada parte expressa sua visão sem interrupções.",
                                    "Aplicar mediação: facilitar diálogo para encontrar pontos comuns em decisões de design.",
                                    "Ou brainstorming: gerar ideias interdisciplinares (ex.: protótipos híbridos eletromecânicos) sem julgamento.",
                                    "Priorizar soluções viáveis usando votação ou matriz de decisão.",
                                    "Documentar consenso emergente em tempo real."
                                  ],
                                  "verification": "Minutas da sessão com ideias geradas e decisão consensual registrada.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": [
                                    "Flipcharts ou quadro digital",
                                    "Post-its para ideias",
                                    "Cronômetro para rodadas iguais"
                                  ],
                                  "tips": "Use timer para equidade temporal e incentive contribuições de todos os especialistas (mecânica, elétrica, software).",
                                  "learningObjective": "Facilitar dinâmicas colaborativas para convergir divergências técnicas em soluções inovadoras.",
                                  "commonMistakes": [
                                    "Permitir dominância de uma disciplina",
                                    "Ignorar ideias 'fora da caixa' no brainstorming"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Resultados e Implementar Follow-up",
                                  "subSteps": [
                                    "Verificar satisfação das partes com a solução via feedback anônimo.",
                                    "Integrar a decisão resolvida ao plano de design eletromecânico.",
                                    "Definir ações responsáveis, prazos e métricas de sucesso.",
                                    "Agendar reunião de follow-up para monitorar implementação.",
                                    "Documentar lições aprendidas para o time multifuncional."
                                  ],
                                  "verification": "Plano de ação assinado com responsáveis e data de follow-up marcada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Template de plano de ação (Trello ou Excel)",
                                    "Formulário de feedback rápido"
                                  ],
                                  "tips": "Celebre o consenso para reforçar cultura de colaboração.",
                                  "learningObjective": "Garantir sustentabilidade das resoluções de conflito em projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Encerrar sem follow-up",
                                    "Não medir satisfação pós-resolução"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um time projetando um braço robótico eletromecânico, engenheiros mecânicos defendem atuadores pesados para durabilidade, enquanto especialistas em eletrônica priorizam componentes leves para mobilidade. Aplicar brainstorming interdisciplinar gera solução híbrida: atuadores modulares com feedback sensorial, integrando ambas visões.",
                              "finalVerifications": [
                                "Todas as partes reportam concordância com a solução (pesquisa de satisfação >80%).",
                                "Decisão integrada ao documento de design sem objeções pendentes.",
                                "Atrasos no projeto reduzidos em pelo menos 20% pós-resolução.",
                                "Time demonstra maior coesão em reuniões subsequentes.",
                                "Lições aprendidas documentadas e compartilhadas com o time maior.",
                                "Solução testada em protótipo inicial sem regressões."
                              ],
                              "assessmentCriteria": [
                                "Efetividade da técnica: resolução completa em uma sessão (pontos: 0-3).",
                                "Neutralidade do facilitador: ausência de viés reportada (pontos: 0-3).",
                                "Inclusividade: todas disciplinas contribuíram igualmente (pontos: 0-3).",
                                "Sustentabilidade: follow-up implementado sem novos conflitos (pontos: 0-3).",
                                "Inovação gerada: solução excede opções originais (pontos: 0-3).",
                                "Tempo de resolução vs. impacto no projeto (eficiência: 0-3)."
                              ],
                              "crossCurricularConnections": [
                                "Comunicação Assertiva (Linguagens e Comunicação).",
                                "Design Thinking (Engenharia de Produto).",
                                "Psicologia Organizacional (Gestão de Pessoas).",
                                "Liderança Ágil (Administração).",
                                "Negociação Estratégica (Direito Empresarial)."
                              ],
                              "realWorldApplication": "Na indústria automotiva, times multifuncionais usam essas técnicas para resolver divergências em designs de veículos elétricos, como integração de baterias (mecânica/elétrica), acelerando o time-to-market e reduzindo custos de retrabalho em 15-30%."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3.3",
                            "name": "Avaliar desempenho colaborativo",
                            "description": "Desenvolver métricas de avaliação para times multifuncionais, como taxa de integração bem-sucedida e feedback 360 graus, baseadas em referências como Cross (2004).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender frameworks teóricos de avaliação colaborativa",
                                  "subSteps": [
                                    "Ler e resumir referências chave como Cross (2004) sobre desempenho em times multifuncionais.",
                                    "Identificar componentes essenciais de avaliação colaborativa, como integração e comunicação.",
                                    "Mapear desafios comuns em times mecatrônicos multifuncionais.",
                                    "Criar um glossário de termos como 'taxa de integração bem-sucedida' e 'feedback 360 graus'.",
                                    "Discutir em grupo as aplicações iniciais no contexto de projetos mecatrônicos."
                                  ],
                                  "verification": "Resumo escrito de 1-2 páginas com glossário e mapa de desafios aprovado por mentor.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Artigo de Cross (2004)",
                                    "Acesso a biblioteca acadêmica",
                                    "Ferramentas de anotações como Notion ou Google Docs"
                                  ],
                                  "tips": "Foque em exemplos reais de times mecatrônicos para contextualizar a teoria.",
                                  "learningObjective": "Dominar os fundamentos teóricos para basear métricas de avaliação.",
                                  "commonMistakes": [
                                    "Ignorar contextos específicos de mecatrônica",
                                    "Não conectar teoria a práticas industriais",
                                    "Resumos superficiais sem análise crítica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir métricas de avaliação personalizadas",
                                  "subSteps": [
                                    "Listar métricas quantitativas: taxa de integração bem-sucedida, tempo de resolução de conflitos.",
                                    "Definir métricas qualitativas: feedback 360 graus, níveis de satisfação da equipe.",
                                    "Estabelecer escalas de medição (ex: 1-5 para feedback) e benchmarks baseados em Cross (2004).",
                                    "Criar uma planilha ou template para registrar métricas em times multifuncionais.",
                                    "Validar métricas com um peer review simulando um time mecatrônico."
                                  ],
                                  "verification": "Template de métricas completo com pelo menos 5 métricas definidas e validadas.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Planilhas Google Sheets ou Excel",
                                    "Referências de Cross (2004)",
                                    "Modelos de feedback 360 graus online"
                                  ],
                                  "tips": "Garanta que métricas sejam SMART (Específicas, Mensuráveis, Alcançáveis, Relevantes, Temporais).",
                                  "learningObjective": "Criar métricas acionáveis adaptadas a times multifuncionais em mecatrônica.",
                                  "commonMistakes": [
                                    "Métricas vagas sem benchmarks",
                                    "Falta de equilíbrio entre quantitativo e qualitativo",
                                    "Ignorar viés em feedback 360"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar ferramentas de coleta de dados",
                                  "subSteps": [
                                    "Configurar formulários para feedback 360 graus usando ferramentas como Google Forms ou Microsoft Forms.",
                                    "Desenhar surveys para taxa de integração: perguntas sobre entregas conjuntas e resolução de issues.",
                                    "Treinar membros simulados do time no uso das ferramentas.",
                                    "Realizar uma coleta piloto em um cenário de projeto mecatrônico fictício.",
                                    "Ajustar ferramentas com base no piloto para melhorar usabilidade."
                                  ],
                                  "verification": "Relatório do piloto com dados coletados e ajustes implementados.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Google Forms/Microsoft Forms",
                                    "Cenário de projeto mecatrônico simulado",
                                    "Guia de feedback 360"
                                  ],
                                  "tips": "Mantenha anonimato no feedback para honestidade; teste em mobile para acessibilidade.",
                                  "learningObjective": "Implementar sistemas práticos de coleta de dados colaborativos.",
                                  "commonMistakes": [
                                    "Formulários longos que reduzem participação",
                                    "Não testar piloto adequadamente",
                                    "Falta de anonimato levando a respostas enviesadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar dados e propor melhorias",
                                  "subSteps": [
                                    "Compilar dados em dashboard (ex: Google Data Studio ou Excel gráficos).",
                                    "Analisar tendências: correlações entre integração e desempenho geral.",
                                    "Gerar relatório com insights, comparando a benchmarks de Cross (2004).",
                                    "Propor ações corretivas para desafios identificados no time.",
                                    "Apresentar análise em reunião simulada de time multifuncional."
                                  ],
                                  "verification": "Dashboard e relatório final com recomendações aprovados.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Google Data Studio/Excel avançado",
                                    "Dados do piloto",
                                    "Templates de relatórios"
                                  ],
                                  "tips": "Use visualizações claras como gráficos de radar para feedback 360.",
                                  "learningObjective": "Interpretar dados para otimizar desempenho colaborativo.",
                                  "commonMistakes": [
                                    "Análises superficiais sem estatísticas básicas",
                                    "Relatórios sem ações práticas",
                                    "Não contextualizar com referências teóricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de desenvolvimento de um braço robótico mecatrônico, avalie o time multifuncional (engenheiros mecânicos, elétricos e de software) usando taxa de integração (90% de módulos integrados sem retrabalho) e feedback 360 graus (média 4.2/5 em comunicação), identificando gargalos em reuniões e propondo daily stand-ups diários.",
                              "finalVerifications": [
                                "Métricas definidas e documentadas com benchmarks.",
                                "Ferramentas de coleta implementadas e testadas em piloto.",
                                "Análise de dados com dashboard funcional.",
                                "Relatório com recomendações acionáveis.",
                                "Apresentação simulada aprovada por pares.",
                                "Alinhamento com referências como Cross (2004)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e relevância das métricas para times multifuncionais (30%).",
                                "Qualidade da implementação e usabilidade das ferramentas (25%).",
                                "Profundidade da análise de dados e insights gerados (20%).",
                                "Conexão com teoria e referências acadêmicas (15%).",
                                "Criatividade nas recomendações práticas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Integração com metodologias ágeis como Scrum.",
                                "Psicologia Organizacional: Aplicação de dinâmicas de grupo e motivação.",
                                "Estatística: Uso de análise de dados para métricas quantitativas.",
                                "Liderança e Comunicação: Habilidades em feedback construtivo."
                              ],
                              "realWorldApplication": "Na indústria mecatrônica, como em empresas de automação (ex: Siemens ou ABB), use essas métricas para avaliações anuais de times em projetos de sistemas integrados, reduzindo tempo de desenvolvimento em 20% via feedback contínuo e melhor integração."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Introdução a Sistemas de Visão por Computador",
                    "description": "Conceitos básicos de visão computacional aplicados em sistemas mecatrônicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Fundamentos da Visão Computacional",
                        "description": "Definição, princípios básicos e importância da visão computacional como tecnologia chave em sistemas mecatrônicos para processamento e interpretação de imagens visuais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Definir Visão Computacional",
                            "description": "Explicar o conceito de visão computacional como a área da inteligência artificial que permite a máquinas interpretarem e entenderem o mundo visual, diferenciando-a de visão humana e destacando sua relevância em automação industrial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Visão Humana",
                                  "subSteps": [
                                    "Pesquisar a anatomia do olho humano (córnea, retina, bastonetes e cones)",
                                    "Estudar o processamento neural da visão no cérebro (córtex visual)",
                                    "Identificar limitações humanas como cegueira noturna ou ilusões ópticas",
                                    "Mapear as etapas: captação de luz, foco, interpretação cognitiva",
                                    "Assistir a um vídeo explicativo sobre o sistema visual humano"
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras descrevendo o processo de visão humana e suas limitações",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo 'Como vemos' do Khan Academy",
                                    "Diagrama da anatomia ocular (impresso ou digital)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'olho = câmera biológica' para facilitar a compreensão",
                                  "learningObjective": "Dominar os princípios biológicos da visão humana para estabelecer base de comparação",
                                  "commonMistakes": [
                                    "Confundir visão com processamento auditivo",
                                    "Ignorar o papel do cérebro na interpretação",
                                    "Superestimar a precisão absoluta da visão humana"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Visão Computacional",
                                  "subSteps": [
                                    "Definir visão computacional como subcampo da IA focado em interpretação visual por máquinas",
                                    "Explicar que envolve aquisição de imagens via câmeras e processamento algorítmico",
                                    "Listar componentes principais: aquisição, pré-processamento, detecção e reconhecimento",
                                    "Diferenciar de processamento de imagens puro (foco em compreensão semântica)",
                                    "Ler definição oficial de fontes como Wikipedia ou artigos acadêmicos"
                                  ],
                                  "verification": "Redigir uma definição própria de visão computacional em 50 palavras",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo 'O que é Visão Computacional?' (OpenCV docs)",
                                    "Notebook e caneta",
                                    "Acesso à internet para referências"
                                  ],
                                  "tips": "Enfatize 'máquinas entendendo o mundo visual' para captar a essência",
                                  "learningObjective": "Formular uma definição precisa e concisa de visão computacional",
                                  "commonMistakes": [
                                    "Confundir com gráficos computacionais",
                                    "Omitir o aspecto de inteligência artificial",
                                    "Generalizar como 'apenas fotos'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Visão Computacional da Visão Humana",
                                  "subSteps": [
                                    "Comparar captação: olho biológico vs sensor CCD/CMOS",
                                    "Contrastar processamento: neural paralelo vs algoritmos sequenciais",
                                    "Destacar vantagens computacionais (precisão, velocidade, não fadiga)",
                                    "Analisar desvantagens (falta de contexto intuitivo, sensibilidade a ruído)",
                                    "Criar uma tabela de comparação com 5 critérios chave"
                                  ],
                                  "verification": "Preencher e discutir uma tabela comparativa com pelo menos 4 diferenças",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para tabela",
                                    "Imagens comparativas (olho humano vs câmera)",
                                    "Vídeo demonstrativo de falhas em visão computacional"
                                  ],
                                  "tips": "Use exemplos visuais para ilustrar diferenças, como detecção de bordas falha em luz ruim",
                                  "learningObjective": "Identificar e explicar distinções fundamentais entre visão biológica e artificial",
                                  "commonMistakes": [
                                    "Ignorar vantagens humanas como adaptação contextual",
                                    "Achar visão computacional 'superior' em tudo",
                                    "Não considerar limitações técnicas atuais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar a Relevância em Automação Industrial",
                                  "subSteps": [
                                    "Identificar aplicações: inspeção de qualidade, guiamento robótico, leitura de códigos",
                                    "Explicar benefícios: redução de erros humanos, aumento de velocidade produtiva",
                                    "Pesquisar casos reais em indústrias (ex: automotiva, farmacêutica)",
                                    "Discutir integração com mecatrônica (sensores + atuadores)",
                                    "Listar 3 exemplos específicos de impacto econômico"
                                  ],
                                  "verification": "Elaborar uma lista de 5 aplicações industriais com justificativas breves",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeos de robôs industriais com visão (YouTube: 'Visão Computacional na Indústria')",
                                    "Artigos sobre Indústria 4.0",
                                    "Notebook"
                                  ],
                                  "tips": "Foquem em métricas como '99% de precisão em inspeção' para concretizar relevância",
                                  "learningObjective": "Compreender e argumentar a importância prática da visão computacional na mecatrônica",
                                  "commonMistakes": [
                                    "Limitar a aplicações genéricas sem contexto industrial",
                                    "Subestimar desafios como iluminação variável",
                                    "Confundir com IoT sem visão"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Definir Visão Computacional Completamente",
                                  "subSteps": [
                                    "Combinar conhecimentos dos steps anteriores em uma definição unificada",
                                    "Incluir diferenças chave e relevância industrial na definição",
                                    "Criar um diagrama conceitual ligando visão humana, computacional e aplicações",
                                    "Praticar explicação oral para um 'público leigo'",
                                    "Revisar e refinar a definição final"
                                  ],
                                  "verification": "Gravar um vídeo de 1 minuto explicando o conceito completo",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (Draw.io ou papel)",
                                    "Celular para gravação",
                                    "Espelho ou colega para prática oral"
                                  ],
                                  "tips": "Estruture como: definição + diferenças + relevância para clareza",
                                  "learningObjective": "Produzir uma explicação integrada e fluida do conceito",
                                  "commonMistakes": [
                                    "Definição muito técnica sem acessibilidade",
                                    "Omitir relevância prática",
                                    "Não praticar verbalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma fábrica de automóveis, uma câmera com visão computacional captura imagens de soldas em chassis; o software detecta microfissuras invisíveis ao olho humano, diferenciando de variações normais, permitindo automação de inspeção 24/7 com 99,9% de precisão, evitando recalls caros.",
                              "finalVerifications": [
                                "Definir visão computacional como área de IA para interpretação visual por máquinas",
                                "Explicar pelo menos 3 diferenças chave da visão humana",
                                "Citar 2-3 aplicações específicas em automação industrial",
                                "Criar tabela comparativa precisa",
                                "Explicar oralmente o conceito em menos de 2 minutos",
                                "Identificar limitações e vantagens computacionais"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definição correta e completa: 30%)",
                                "Diferenciação clara entre visão humana e computacional (25%)",
                                "Relevância industrial destacada com exemplos (20%)",
                                "Qualidade da tabela/diagrama comparativo (15%)",
                                "Clareza na explicação verbal/escrita (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Inteligência Artificial (algoritmos de ML para reconhecimento)",
                                "Processamento Digital de Imagens (filtros e segmentação)",
                                "Engenharia Mecatrônica (integração com robótica)",
                                "Programação (bibliotecas como OpenCV em Python)",
                                "Indústria 4.0 (IoT e automação inteligente)"
                              ],
                              "realWorldApplication": "Na automação industrial, visão computacional permite robôs identificarem peças defeituosas em linhas de montagem, guiem veículos autônomos em armazéns e realizem controle de qualidade em farmacêuticas, reduzindo custos em até 40% e aumentando eficiência operacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Identificar Princípios Básicos",
                            "description": "Listar e descrever os princípios fundamentais como aquisição de imagem, pré-processamento, segmentação e reconhecimento de padrões, com exemplos simples aplicados a sensores em robótica mecatrônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Aquisição de Imagem",
                                  "subSteps": [
                                    "Estude os conceitos básicos de sensores de imagem como câmeras CCD e CMOS.",
                                    "Aprenda sobre resolução, taxa de frames e profundidade de cor.",
                                    "Explore como converter luz em sinais digitais via A/D.",
                                    "Analise exemplos em robótica, como câmeras em braços robóticos.",
                                    "Pratique configurando parâmetros de uma câmera virtual."
                                  ],
                                  "verification": "Liste 3 componentes chave de aquisição de imagem e explique seu papel em um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Vídeo tutorial sobre sensores de imagem, software de simulação como Gazebo, caderno para anotações.",
                                  "tips": "Comece com imagens reais para visualizar o processo de captura.",
                                  "learningObjective": "Identificar e descrever os componentes fundamentais da aquisição de imagem em visão computacional.",
                                  "commonMistakes": "Confundir resolução espacial com profundidade de cor; sempre diferencie."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Pré-processamento de Imagens",
                                  "subSteps": [
                                    "Aprenda técnicas como filtragem (Gaussiano, mediana) para redução de ruído.",
                                    "Estude normalização de intensidade e equalização de histograma.",
                                    "Pratique correção de distorção geométrica comum em lentes.",
                                    "Aplique a imagens de sensores robóticos para melhorar qualidade.",
                                    "Compare imagens antes e depois do pré-processamento."
                                  ],
                                  "verification": "Aplique um filtro em uma imagem de exemplo e demonstre melhoria visual.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software OpenCV ou ImageJ, conjunto de imagens de teste de robótica, tutorial OpenCV básico.",
                                  "tips": "Use kernels pequenos inicialmente para entender efeitos rapidamente.",
                                  "learningObjective": "Descrever técnicas de pré-processamento e sua importância para dados de sensores.",
                                  "commonMistakes": "Aplicar filtros excessivos que borram bordas importantes; teste com moderação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender Segmentação de Imagens",
                                  "subSteps": [
                                    "Estude métodos como threshold adaptativo e watershed.",
                                    "Aprenda segmentação por cor e contornos (Canny edge detection).",
                                    "Explore region growing e clustering (K-means).",
                                    "Aplique a detecção de objetos em cenários robóticos.",
                                    "Avalie segmentações geradas em termos de precisão."
                                  ],
                                  "verification": "Segmente uma imagem de um objeto robótico e isole regiões corretamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "OpenCV Python notebook, imagens de peças mecatrônicas, documentação de algoritmos.",
                                  "tips": "Visualize intermediários como edges para depurar segmentação.",
                                  "learningObjective": "Explicar princípios de segmentação e selecionar método adequado para aplicações.",
                                  "commonMistakes": "Ignorar variações de iluminação; use threshold adaptativo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Reconhecimento de Padrões",
                                  "subSteps": [
                                    "Aprenda matching de templates e feature matching (SIFT, ORB).",
                                    "Estude classificação básica com KNN ou SVM.",
                                    "Explore redes neurais simples para reconhecimento.",
                                    "Aplique a identificação de padrões em sensores robóticos.",
                                    "Teste robustez contra rotações e escalas."
                                  ],
                                  "verification": "Reconheça um padrão específico em uma imagem robótica com acurácia >80%.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Biblioteca scikit-image ou OpenCV, dataset simples de padrões mecatrônicos.",
                                  "tips": "Extraia features chave antes de matching para eficiência.",
                                  "learningObjective": "Descrever métodos de reconhecimento e sua aplicação em visão robótica.",
                                  "commonMistakes": "Usar matching exato sem invariâncias; prefira descritores robustos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Princípios com Exemplos em Robótica Mecatrônica",
                                  "subSteps": [
                                    "Revise os 4 princípios em sequência de pipeline de visão.",
                                    "Crie um fluxograma completo de aquisição a reconhecimento.",
                                    "Aplique pipeline a um caso: detecção de obstáculos em robô móvel.",
                                    "Discuta limitações em ambientes reais mecatrônicos.",
                                    "Documente exemplos simples com diagramas."
                                  ],
                                  "verification": "Desenhe e explique um pipeline completo para um sensor robótico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramenta de diagrama (Draw.io), exemplos de robótica (ROS com visão).",
                                  "tips": "Pense em tempo real: otimize cada etapa para robótica.",
                                  "learningObjective": "Listar e ilustrar os princípios fundamentais aplicados a sensores em robótica.",
                                  "commonMistakes": "Isolar princípios; sempre contextualize no pipeline."
                                }
                              ],
                              "practicalExample": "Em um braço robótico mecatrônico, use aquisição de imagem via câmera para capturar peça; pré-processe para remover ruído industrial; segmente a peça por cor/contorno; reconheça padrão para sorting automático.",
                              "finalVerifications": [
                                "Lista corretamente os 4 princípios fundamentais com descrições breves.",
                                "Fornece pelo menos um exemplo robótico por princípio.",
                                "Desenha um pipeline sequencial de visão computacional.",
                                "Explica impacto de falhas em uma etapa no todo.",
                                "Identifica sensores comuns em mecatrônica (CCD/CMOS).",
                                "Demonstra compreensão via diagrama ou código simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos princípios (90%+ correto).",
                                "Relevância e simplicidade dos exemplos robóticos.",
                                "Completude do pipeline integrado.",
                                "Profundidade nos sub-passos e verificações.",
                                "Criatividade em conexões práticas.",
                                "Clareza na comunicação (diagramas/tabelas)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/OpenCV.",
                                "Eletrônica: Integração com microcontroladores (Raspberry Pi).",
                                "Mecânica: Calibração de câmeras em atuadores robóticos.",
                                "Matemática: Álgebra linear para transformações de imagem."
                              ],
                              "realWorldApplication": "Em linhas de montagem mecatrônicas, sistemas de visão detectam defeitos em peças via segmentação e reconhecimento, reduzindo erros humanos e aumentando eficiência em indústrias automotivas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Relacionar com Mecatrônica",
                            "description": "Associar a visão computacional ao desenvolvimento integrado de produtos mecatrônicos, citando benefícios como inspeção automatizada e navegação autônoma em sistemas industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da visão computacional e da mecatrônica",
                                  "subSteps": [
                                    "Definir visão computacional como o campo que permite máquinas processarem e interpretarem imagens visuais.",
                                    "Descrever mecatrônica como a integração de mecânica, eletrônica, controle e informática em sistemas inteligentes.",
                                    "Identificar componentes comuns em produtos mecatrônicos, como sensores, atuadores e microcontroladores.",
                                    "Listar exemplos básicos de visão computacional, como detecção de bordas e reconhecimento de objetos.",
                                    "Explicar como sensores visuais (câmeras) se integram como entrada em sistemas mecatrônicos."
                                  ],
                                  "verification": "Criar um mapa conceitual ligando termos chave de visão computacional e mecatrônica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Computador com acesso à internet, papel e caneta para mapa conceitual, vídeos introdutórios sobre mecatrônica (YouTube ou Khan Academy).",
                                  "tips": "Use diagramas visuais para facilitar a memorização de integrações.",
                                  "learningObjective": "Dominar definições e componentes básicos para estabelecer base conceitual.",
                                  "commonMistakes": "Confundir visão computacional com visão humana; ignorar o aspecto interdisciplinar da mecatrônica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar pontos de integração entre visão computacional e mecatrônica",
                                  "subSteps": [
                                    "Analisar como câmeras atuam como sensores primários em sistemas mecatrônicos para aquisição de dados visuais.",
                                    "Mapear fluxos de dados: captura de imagem → processamento → decisão de controle em atuadores.",
                                    "Estudar arquiteturas integradas, como uso de OpenCV em microcontroladores como Raspberry Pi.",
                                    "Discutir feedback loops onde visão computacional ajusta movimentos mecânicos em tempo real.",
                                    "Explorar hardware compatível, como câmeras USB com PLCs industriais."
                                  ],
                                  "verification": "Desenhar um diagrama de fluxo simples de um sistema integrado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de desenho (Draw.io ou papel), tutoriais OpenCV, documentação de Raspberry Pi.",
                                  "tips": "Comece com blocos simples (entrada-saída) antes de adicionar complexidade.",
                                  "learningObjective": "Reconhecer interfaces técnicas entre visão computacional e componentes mecatrônicos.",
                                  "commonMistakes": "Subestimar latência no processamento de imagens em sistemas em tempo real."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar benefícios específicos como inspeção automatizada e navegação autônoma",
                                  "subSteps": [
                                    "Explicar inspeção automatizada: detecção de defeitos em peças via análise de imagens em linhas de montagem.",
                                    "Detalhar navegação autônoma: uso de visão para SLAM (Simultaneous Localization and Mapping) em robôs móveis.",
                                    "Quantificar benefícios: redução de erros humanos (até 90%), aumento de velocidade e escalabilidade.",
                                    "Comparar com métodos tradicionais (inspeção manual) destacando eficiência e precisão.",
                                    "Citar métricas como taxa de falsos positivos em algoritmos de detecção."
                                  ],
                                  "verification": "Elaborar uma tabela comparativa de benefícios pré e pós-integração.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha (Google Sheets ou Excel), artigos científicos sobre visão em mecatrônica (IEEE ou ResearchGate).",
                                  "tips": "Use dados reais de cases industriais para tornar a análise concreta.",
                                  "learningObjective": "Associar visão computacional a ganhos práticos em produtos mecatrônicos.",
                                  "commonMistakes": "Focar apenas em teoria sem mencionar limitações como iluminação variável."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar aplicações integradas e preparar exemplos práticos",
                                  "subSteps": [
                                    "Integrar conhecimentos: projetar um sistema mecatrônico com visão para inspeção ou navegação.",
                                    "Simular cenários industriais, como robô pick-and-place com detecção visual.",
                                    "Avaliar trade-offs: custo vs. performance em implementações reais.",
                                    "Documentar passos para prototipagem básica usando kits como Arduino + câmera.",
                                    "Refletir sobre escalabilidade para produção em massa."
                                  ],
                                  "verification": "Apresentar um esboço de projeto integrado com justificativa de benefícios.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Kits Arduino/Raspberry Pi (opcional para simulação), software de simulação (Tinkercad).",
                                  "tips": "Priorize aplicações de baixo custo para protótipos iniciais.",
                                  "learningObjective": "Aplicar relação visão-mecatrônica em contextos de desenvolvimento de produtos.",
                                  "commonMistakes": "Ignorar integração de software com hardware físico."
                                }
                              ],
                              "practicalExample": "Desenvolver um braço robótico mecatrônico equipado com câmera para inspeção automatizada de soldas em uma linha de produção automotiva: a visão computacional detecta irregularidades, aciona correções via atuadores e registra dados para qualidade total.",
                              "finalVerifications": [
                                "Explicar verbalmente a integração de visão computacional em um produto mecatrônico específico.",
                                "Identificar pelo menos três benefícios quantificáveis em cenários industriais.",
                                "Desenhar um diagrama funcional de um sistema híbrido.",
                                "Comparar com alternativas sem visão computacional.",
                                "Propor uma melhoria prática baseada na análise.",
                                "Simular uma falha comum e propor solução via visão."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual e terminologia correta (25%)",
                                "Profundidade na análise de integrações e benefícios (25%)",
                                "Criatividade e relevância de exemplos práticos (20%)",
                                "Clareza em diagramas e explicações (15%)",
                                "Evidência de compreensão interdisciplinar (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Informática: Algoritmos de processamento de imagens (OpenCV, machine learning).",
                                "Matemática: Transformadas geométricas e estatística em detecção de objetos.",
                                "Física: Óptica e sensores em câmeras para mecatrônica.",
                                "Engenharia de Controle: Loops de feedback com dados visuais."
                              ],
                              "realWorldApplication": "Na indústria automotiva, sistemas mecatrônicos com visão computacional realizam inspeção automatizada de chassis, detectando microfissuras com precisão >99%, reduzindo recalls e custos; em logística, robôs AGVs usam navegação autônoma para movimentação em armazéns, otimizando fluxos e minimizando acidentes humanos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Componentes de um Sistema de Visão por Computador",
                        "description": "Principais hardware e software necessários para implementar sistemas de visão, integrados a microcontroladores e CLPs em projetos mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Descrever Hardware Essencial",
                            "description": "Identificar e explicar componentes como câmeras (CCD/CMOS), lentes, iluminação e interfaces com microprocessadores, considerando aplicações em ambientes industriais aeronáuticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Sensores de Imagem: CCD e CMOS",
                                  "subSteps": [
                                    "Pesquisar o princípio de funcionamento do sensor CCD (Charge-Coupled Device).",
                                    "Estudar o sensor CMOS (Complementary Metal-Oxide-Semiconductor) e suas diferenças estruturais.",
                                    "Comparar vantagens e desvantagens em termos de ruído, velocidade e custo.",
                                    "Analisar aplicações industriais, especialmente em ambientes de alta precisão.",
                                    "Identificar especificações chave como resolução e sensibilidade à luz."
                                  ],
                                  "verification": "Criar uma tabela comparativa entre CCD e CMOS com pelo menos 5 critérios.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Computador com acesso à internet",
                                    "Vídeos tutoriais sobre sensores de imagem",
                                    "Folhas para tabela comparativa"
                                  ],
                                  "tips": "Priorize fontes acadêmicas ou de fabricantes como Sony ou Basler para dados precisos.",
                                  "learningObjective": "Diferenciar os sensores CCD e CMOS, compreendendo suas características técnicas e adequação a sistemas de visão industrial.",
                                  "commonMistakes": [
                                    "Confundir resolução espacial com sensibilidade à luz",
                                    "Ignorar impacto do ruído em ambientes industriais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Lentes e Princípios Ópticos",
                                  "subSteps": [
                                    "Aprender tipos de lentes (fixa, zoom, telecêntrica) usadas em visão computacional.",
                                    "Compreender parâmetros ópticos: distância focal, profundidade de campo e distorção.",
                                    "Explorar calibração de lentes para correção de distorções.",
                                    "Relacionar escolha de lentes com requisitos de inspeção em aeronáutica.",
                                    "Simular efeitos ópticos usando software gratuito como LensLab."
                                  ],
                                  "verification": "Desenhar um diagrama de uma lente escolhida e listar suas specs para uma aplicação aeronáutica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de simulação óptica (ex: OpticStudio trial)",
                                    "Diagramas impressos de lentes",
                                    "Calculadora para fórmulas ópticas"
                                  ],
                                  "tips": "Lembre-se: lentes telecêntricas são ideais para medições precisas sem paralaxe.",
                                  "learningObjective": "Identificar e explicar propriedades de lentes, selecionando a adequada para cenários industriais.",
                                  "commonMistakes": [
                                    "Subestimar distorções em lentes wide-angle",
                                    "Confundir distância focal com zoom óptico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Sistemas de Iluminação",
                                  "subSteps": [
                                    "Classificar tipos de iluminação: frontal, backlight, coaxial e estruturada.",
                                    "Estudar fontes de luz (LED, halógena, laser) e suas características espectrais.",
                                    "Compreender polarização e difusores para reduzir reflexos.",
                                    "Avaliar impacto da iluminação em imagens de superfícies metálicas aeronáuticas.",
                                    "Testar configurações em fotos reais de componentes industriais."
                                  ],
                                  "verification": "Fotografar um objeto metálico com 3 configurações de luz diferentes e comparar resultados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Luzes LED ajustáveis",
                                    "Câmera smartphone",
                                    "Objetos metálicos simulando peças aeronáuticas",
                                    "Filtro polarizador opcional"
                                  ],
                                  "tips": "Use backlight para detectar contornos e coaxial para superfícies reflexivas.",
                                  "learningObjective": "Selecionar e justificar configurações de iluminação para otimizar captura de imagens em ambientes industriais.",
                                  "commonMistakes": [
                                    "Usar iluminação inadequada causando sombras ou reflexos excessivos",
                                    "Ignorar variação espectral em materiais aeronáuticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Interfaces com Microprocessadores",
                                  "subSteps": [
                                    "Listar interfaces comuns: USB 3.0, GigE, Camera Link e CoaXPress.",
                                    "Estudar protocolos de comunicação e taxas de transferência de dados.",
                                    "Compreender integração com microprocessadores (ex: Raspberry Pi, PLCs industriais).",
                                    "Analisar requisitos em tempo real para aplicações aeronáuticas.",
                                    "Diagramar um fluxo de dados de câmera para processador."
                                  ],
                                  "verification": "Montar um fluxograma de interface entre câmera e microprocessador para inspeção industrial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de diagramação (Draw.io ou papel)",
                                    "Documentação de interfaces (datasheets)",
                                    "Exemplos de SDKs de câmeras"
                                  ],
                                  "tips": "GigE é preferível para distâncias longas em fábricas aeronáuticas.",
                                  "learningObjective": "Descrever interfaces de hardware e sua integração em sistemas mecatrônicos embarcados.",
                                  "commonMistakes": [
                                    "Subestimar latência em interfaces lentas",
                                    "Confundir bandwidth com taxa de frames"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenhe e descreva um sistema de visão para inspeção automatizada de soldas em fuselagem de aeronaves, especificando câmera CMOS GigE, lente telecêntrica de 50mm, iluminação coaxial LED branca e interface Camera Link com PLC Siemens.",
                              "finalVerifications": [
                                "Lista e descreve corretamente os 4 componentes essenciais: câmeras (CCD/CMOS), lentes, iluminação e interfaces.",
                                "Explica diferenças entre CCD e CMOS com exemplos industriais.",
                                "Seleciona lentes e iluminação adequadas para superfícies aeronáuticas reflexivas.",
                                "Descreve pelo menos 3 interfaces e suas aplicações em mecatrônica.",
                                "Integra todos os componentes em um diagrama funcional.",
                                "Considera restrições ambientais industriais como vibração e poeira."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica e uso correto de terminologia especializada.",
                                "Profundidade na explicação de funcionamento e trade-offs.",
                                "Relevância às aplicações aeronáuticas industriais.",
                                "Clareza e organização na apresentação (diagramas, tabelas).",
                                "Capacidade de integração interdisciplinar dos componentes.",
                                "Identificação de erros comuns e soluções práticas."
                              ],
                              "crossCurricularConnections": [
                                "Física Óptica (lentes e luz).",
                                "Eletrônica Digital (sensores e interfaces).",
                                "Engenharia de Controle (integração com PLCs).",
                                "Ciência da Computação (processamento de imagens).",
                                "Engenharia Aeronáutica (inspeção de qualidade)."
                              ],
                              "realWorldApplication": "Em linhas de montagem da Embraer ou Boeing, sistemas de visão com esses hardwares detectam microfissuras em turbinas e fuselagens, reduzindo falhas e garantindo conformidade com normas FAA/EASA, economizando milhões em recalls."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Explicar Software e Algoritmos Básicos",
                            "description": "Descrever bibliotecas como OpenCV e algoritmos iniciais de filtragem e detecção de bordas, com integração a microcontroladores para processamento em tempo real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introdução às Bibliotecas de Software para Visão Computacional",
                                  "subSteps": [
                                    "Estudar a definição e propósito da biblioteca OpenCV.",
                                    "Explorar a instalação básica do OpenCV em um ambiente Python.",
                                    "Identificar módulos principais do OpenCV relevantes para processamento de imagens.",
                                    "Executar um script simples para carregar e exibir uma imagem.",
                                    "Comparar OpenCV com outras bibliotecas como Pillow ou scikit-image."
                                  ],
                                  "verification": "Executar com sucesso um script que carrega e exibe uma imagem usando OpenCV, sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Computador com Python instalado",
                                    "OpenCV (pip install opencv-python)",
                                    "Documentação oficial OpenCV",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Comece com tutoriais oficiais para evitar configurações complexas.",
                                  "learningObjective": "Compreender o papel do OpenCV como biblioteca open-source para visão computacional.",
                                  "commonMistakes": [
                                    "Instalar versão errada do OpenCV",
                                    "Esquecer de importar cv2",
                                    "Não verificar dependências como NumPy"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Algoritmos Básicos de Filtragem de Imagens",
                                  "subSteps": [
                                    "Explicar o conceito de ruído em imagens e necessidade de filtragem.",
                                    "Implementar filtro Gaussiano para suavização.",
                                    "Aplicar filtro mediana para remoção de ruído de sal e pimenta.",
                                    "Comparar resultados visuais antes e depois da filtragem.",
                                    "Ajustar parâmetros como tamanho do kernel para otimizar resultados."
                                  ],
                                  "verification": "Gerar e comparar imagens filtradas vs. originais, confirmando redução de ruído.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "OpenCV instalado",
                                    "Imagens de teste com ruído (baixe samples)",
                                    "Jupyter Notebook para visualização"
                                  ],
                                  "tips": "Use cv2.imshow() para visualizar em tempo real durante testes.",
                                  "learningObjective": "Dominar técnicas iniciais de pré-processamento para melhorar qualidade de imagens.",
                                  "commonMistakes": [
                                    "Kernel size ímpar não usado",
                                    "Excesso de filtragem borrando detalhes",
                                    "Ignorar normalização de imagens"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Algoritmos de Detecção de Bordas",
                                  "subSteps": [
                                    "Descrever o operador de Sobel para detecção de gradientes.",
                                    "Implementar detecção de bordas com Canny.",
                                    "Ajustar thresholds baixo e alto no Canny para precisão.",
                                    "Aplicar em imagens reais e analisar bordas detectadas.",
                                    "Explicar diferenças entre Sobel, Prewitt e Canny."
                                  ],
                                  "verification": "Produzir imagem com bordas destacadas corretamente, sem falsos positivos excessivos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "OpenCV",
                                    "Imagens de objetos mecânicos para teste",
                                    "Documentação de funções cv2.Canny() e cv2.Sobel()"
                                  ],
                                  "tips": "Teste com diferentes thresholds para entender sensibilidade.",
                                  "learningObjective": "Aplicar e explicar algoritmos clássicos de detecção de contornos em imagens.",
                                  "commonMistakes": [
                                    "Thresholds inadequados gerando bordas fracas ou excesso",
                                    "Não converter para escala de cinza antes",
                                    "Confundir gradientes com bordas finas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração com Microcontroladores para Processamento em Tempo Real",
                                  "subSteps": [
                                    "Explicar comunicação serial entre PC (com OpenCV) e microcontrolador (ex: Arduino).",
                                    "Implementar captura de vídeo e envio de dados processados via USB.",
                                    "Configurar Arduino para receber comandos de detecção e acionar saídas.",
                                    "Testar loop em tempo real: imagem -> processamento -> ação no hardware.",
                                    "Otimizar código para latência baixa (<100ms por frame)."
                                  ],
                                  "verification": "Demonstrar sistema onde detecção de borda em câmera aciona LED no Arduino em tempo real.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Arduino ou ESP32",
                                    "Câmera USB",
                                    "OpenCV + PySerial",
                                    "Fios jumper e breadboard"
                                  ],
                                  "tips": "Use threading em Python para não bloquear captura de vídeo.",
                                  "learningObjective": "Integrar software de visão com hardware embarcado para aplicações mecatrônicas.",
                                  "commonMistakes": [
                                    "Baude rate incompatível na serial",
                                    "Não flush buffers seriais",
                                    "Processamento lento por falta de downscaling de imagem"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de inspeção de peças mecatrônicas, use OpenCV no PC para filtrar ruído de uma imagem de câmera, detectar bordas de uma engrenagem defeituosa com Canny, e enviar sinal via serial para um Arduino parar a linha de produção se bordas irregulares forem detectadas.",
                              "finalVerifications": [
                                "Descrever com precisão funções principais do OpenCV para filtragem e bordas.",
                                "Executar código que integra OpenCV com microcontrolador sem erros.",
                                "Explicar diferenças entre filtros Gaussiano e mediana.",
                                "Identificar bordas em imagem real usando Canny com thresholds adequados.",
                                "Demonstrar processamento em tempo real com latência <200ms.",
                                "Comparar resultados de Sobel vs. Canny visualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas descrições de bibliotecas e algoritmos (80%+ acerto).",
                                "Qualidade do código implementado (funcional, comentado e otimizado).",
                                "Capacidade de troubleshooting em integrações hardware-software.",
                                "Profundidade na explicação de parâmetros e trade-offs.",
                                "Criatividade na aplicação prática ao contexto mecatrônico.",
                                "Tempo de processamento em tempo real dentro dos limites."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de Python e bibliotecas para automação.",
                                "Eletrônica: Comunicação serial e programação de microcontroladores.",
                                "Matemática: Gradientes e convoluções em processamento de sinais.",
                                "Física: Óptica básica em captura de imagens.",
                                "Engenharia de Controle: Feedback em tempo real para sistemas mecatrônicos."
                              ],
                              "realWorldApplication": "Inspeção automatizada de qualidade em linhas de montagem industriais, onde detecção de defeitos em peças via visão computacional integrada a PLCs ou microcontroladores previne falhas e reduz custos operacionais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Analisar Integração com Sistemas Mecatrônicos",
                            "description": "Demonstrar como conectar sistemas de visão a atuadores e controladores lógicos programáveis (CLPs) em fluxos de desenvolvimento integrado de produtos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Mapear Componentes do Sistema",
                                  "subSteps": [
                                    "Liste os componentes principais: câmera de visão, processador de imagem, CLP e atuadores (ex: motores, solenoides).",
                                    "Desenhe um diagrama de blocos mostrando fluxos de dados e sinais entre visão, CLP e atuadores.",
                                    "Defina interfaces físicas (portas I/O, Ethernet) e requisitos de energia para cada componente.",
                                    "Verifique compatibilidade de hardware consultando manuais técnicos.",
                                    "Documente entradas (dados de visão) e saídas (comandos para atuadores)."
                                  ],
                                  "verification": "Diagrama completo mapeado e validado com simulação básica de conexões.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Manuais de CLP e câmera, software de diagramação (Draw.io), multímetro.",
                                  "tips": "Use cores diferentes no diagrama para sinais digitais, analógicos e de rede.",
                                  "learningObjective": "Compreender a arquitetura integrada de sistemas mecatrônicos com visão.",
                                  "commonMistakes": "Ignorar latência de comunicação entre visão e CLP, levando a falhas de sincronismo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Protocolos de Comunicação",
                                  "subSteps": [
                                    "Selecione protocolos adequados (ex: Ethernet/IP, Modbus TCP, Profinet) baseados em velocidades e distâncias.",
                                    "Configure IPs e endereços no CLP e no processador de visão usando software proprietário.",
                                    "Implemente mapeamento de tags: dados de visão (coordenadas, detecções) para registradores no CLP.",
                                    "Teste comunicação básica enviando pacotes de teste bidirecionais.",
                                    "Ajuste parâmetros de timeout e retry para robustez em ambientes industriais."
                                  ],
                                  "verification": "Ping bem-sucedido e troca de dados simulados sem erros.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software de configuração CLP (ex: TIA Portal), cabo Ethernet, PC com rede industrial.",
                                  "tips": "Sempre isole a rede de teste da produção para evitar interferências.",
                                  "learningObjective": "Dominar configuração de redes industriais para integração em tempo real.",
                                  "commonMistakes": "Configurar firewalls que bloqueiam portas, impedindo comunicação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Programar Lógica de Integração no CLP",
                                  "subSteps": [
                                    "Crie blocos funcionais no CLP para ler dados de visão (ex: posição de objeto detectado).",
                                    "Desenvolva lógica condicional: se visão detecta peça OK, ative atuador A; senão, rejeite.",
                                    "Implemente controle PID ou sequencial para atuadores baseado em feedback de visão.",
                                    "Adicione alarmes para falhas de comunicação ou detecções inválidas.",
                                    "Simule o programa no ambiente de desenvolvimento do CLP."
                                  ],
                                  "verification": "Programa simulado executa corretamente com entradas de visão mockadas.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Software de programação CLP, exemplos de código ladder/FBD.",
                                  "tips": "Use timers para sincronizar visão com atuadores e evitar sobrecarga.",
                                  "learningObjective": "Aplicar programação de CLP para automação integrada com visão.",
                                  "commonMistakes": "Não tratar exceções, causando loops infinitos em falhas de visão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar Integração Completa",
                                  "subSteps": [
                                    "Conecte fisicamente todos componentes em bancada de testes.",
                                    "Execute ciclos completos: visão captura, CLP processa, atuador responde.",
                                    "Meça métricas: tempo de ciclo, taxa de acerto, latência end-to-end.",
                                    "Depure erros usando osciloscópio e logs de comunicação.",
                                    "Otimize e documente o fluxo para produção."
                                  ],
                                  "verification": "Sistema integrado processa 50 ciclos sem falhas, com taxa de sucesso >95%.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Bancada mecatrônica, osciloscópio, peças de teste (ex: objetos para detecção).",
                                  "tips": "Grave vídeos dos testes para análise posterior de falhas.",
                                  "learningObjective": "Validar e otimizar sistemas mecatrônicos integrados.",
                                  "commonMistakes": "Testar apenas em condições ideais, ignorando ruído ou variações de iluminação."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de parafusos, a câmera de visão detecta parafusos defeituosos; envia coordenadas via Ethernet/IP para o CLP, que aciona um ejetor pneumático para remover itens ruins, integrando detecção em <100ms.",
                              "finalVerifications": [
                                "Diagrama de integração completo e funcional.",
                                "Comunicação bidirecional sem perda de pacotes >99%.",
                                "Lógica de CLP responde corretamente a 10 cenários de visão variados.",
                                "Sistema completo executa ciclos com latência <200ms.",
                                "Documentação de depuração e otimização disponível.",
                                "Testes de robustez sob ruído e falhas simuladas passam."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de componentes e protocolos (90%+ correto).",
                                "Eficiência da programação CLP (sem loops desnecessários, código modular).",
                                "Taxa de sucesso em testes integrados (>95%).",
                                "Capacidade de depuração e otimização demonstrada.",
                                "Documentação clara e reproduzível.",
                                "Compreensão de trade-offs (velocidade vs. precisão)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Industrial (CLP ladder/FBD).",
                                "Redes Industriais (Ethernet/IP, protocolos IIoT).",
                                "Processamento de Imagens (visão computacional básica).",
                                "Controle Automático (PID para atuadores).",
                                "Eletrônica Industrial (interfaces I/O)."
                              ],
                              "realWorldApplication": "Integração em linhas de produção automotiva para inspeção visual de soldas, onde visão detecta defeitos e CLP aciona correções robóticas, reduzindo refugos em 30% e aumentando throughput."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Aplicações Básicas em Mecatrônica",
                        "description": "Exemplos práticos de visão computacional em projetos mecatrônicos, com ênfase em indústria aeronáutica e elaboração de projetos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Exemplificar Inspeção Visual",
                            "description": "Descrever aplicações como detecção de defeitos em peças aeronáuticas usando visão computacional integrada a robôs mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Fundamentais de Inspeção Visual",
                                  "subSteps": [
                                    "Estude os componentes básicos de um sistema de visão computacional: câmera, iluminação, software de processamento e atuadores robóticos.",
                                    "Analise tipos de defeitos comuns em peças aeronáuticas, como rachaduras, amassados e descolorações.",
                                    "Revise algoritmos básicos de processamento de imagens: filtragem, segmentação e detecção de bordas.",
                                    "Explore exemplos reais de integração visão-robótica em indústrias aeroespaciais.",
                                    "Discuta limitações como variações de iluminação e velocidade de processamento."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes e fluxos de um sistema de inspeção visual, identificando pelo menos 3 defeitos típicos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Vídeos tutoriais sobre OpenCV",
                                    "Artigos sobre inspeção aeronáutica",
                                    "Diagrama em branco para esboço"
                                  ],
                                  "tips": [
                                    "Use analogias com visão humana para fixar conceitos.",
                                    "Assista demonstrações em YouTube de sistemas reais."
                                  ],
                                  "learningObjective": "Entender os princípios e componentes de sistemas de inspeção visual integrados a mecatrônica.",
                                  "commonMistakes": [
                                    "Confundir visão computacional com inspeção manual.",
                                    "Ignorar impacto da iluminação em detecções."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Instale bibliotecas essenciais: OpenCV, Python e simuladores como Gazebo ou CoppeliaSim para robótica.",
                                    "Configure uma câmera webcam ou simule uma câmera industrial.",
                                    "Teste aquisição de imagens de peças simuladas (imprima fotos de peças aeronáuticas com defeitos artifícios).",
                                    "Integre hardware básico: conecte um braço robótico simples via Arduino ou Raspberry Pi.",
                                    "Calibre a câmera para precisão em distâncias de inspeção típicas (10-50 cm)."
                                  ],
                                  "verification": "Capture e exiba 5 imagens de teste processadas com filtros básicos, salvando-as em um relatório.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Computador com Python/OpenCV",
                                    "Webcam ou câmera USB",
                                    "Arduino/Raspberry Pi",
                                    "Peças impressas ou modelos 3D de aeronáutica"
                                  ],
                                  "tips": [
                                    "Use ambientes virtuais (venv) para evitar conflitos de bibliotecas.",
                                    "Comece com imagens estáticas antes de vídeo."
                                  ],
                                  "learningObjective": "Montar um setup funcional para testes de visão computacional em contexto mecatrônico.",
                                  "commonMistakes": [
                                    "Pular calibração, causando distorções.",
                                    "Usar hardware incompatível sem drivers."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Algoritmo de Detecção de Defeitos",
                                  "subSteps": [
                                    "Implemente pré-processamento: conversão para escala de cinza, remoção de ruído com Gaussian Blur.",
                                    "Aplique detecção de bordas com Canny e segmentação por limiarização.",
                                    "Treine um classificador simples (ex: thresholding ou template matching) para identificar rachaduras em peças.",
                                    "Meça métricas: área, comprimento de defeitos e gere alertas.",
                                    "Teste com dataset variado: 10 imagens boas vs. 10 com defeitos."
                                  ],
                                  "verification": "Execute o script e demonstre detecção precisa em pelo menos 80% das imagens de teste, com logs de resultados.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Código-fonte OpenCV em Python",
                                    "Dataset de imagens de peças aeronáuticas (baixe de Kaggle)",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": [
                                    "Ajuste parâmetros iterativamente com trackbars do OpenCV.",
                                    "Salve imagens anotadas para debugging visual."
                                  ],
                                  "learningObjective": "Criar um algoritmo acionável para detecção de defeitos específicos em peças aeronáuticas.",
                                  "commonMistakes": [
                                    "Overfitting em um tipo de defeito.",
                                    "Ignorar normalização de iluminação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar com Robô Mecatrônico e Exemplificar Aplicação",
                                  "subSteps": [
                                    "Conecte o algoritmo de visão ao controle do robô via serial ou ROS.",
                                    "Programe sequências: robô move câmera sobre peça, detecta defeito e para/aciona rejeição.",
                                    "Simule inspeção em linha de produção: peça em esteira conveyor simulada.",
                                    "Otimize para tempo real: reduza resolução se necessário.",
                                    "Documente o fluxo completo com vídeo de demonstração."
                                  ],
                                  "verification": "Grave um vídeo de 1 minuto mostrando o robô inspecionando 3 peças, detectando defeitos corretamente.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Braço robótico ou simulador",
                                    "Software ROS ou PySerial",
                                    "Esteira conveyor DIY ou simulada"
                                  ],
                                  "tips": [
                                    "Use threads para processamento paralelo de visão e movimento.",
                                    "Teste em loop para consistência."
                                  ],
                                  "learningObjective": "Demonstrar integração completa de visão computacional em sistema mecatrônico para inspeção.",
                                  "commonMistakes": [
                                    "Latência alta causando falsos negativos.",
                                    "Falta de sincronização visão-atuador."
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um braço robótico com câmera para inspecionar réplicas impressas de pás de turbina aeronáutica. O sistema detecta rachaduras >1mm movendo a câmera ao longo da peça, para o robô se defeito encontrado e marca com laser simulado, replicando linhas de montagem da Embraer.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo de inspeção visual integrada.",
                                "Demonstrar detecção em peça real ou simulada com >85% acurácia.",
                                "Identificar e corrigir um erro comum no setup.",
                                "Produzir relatório com métricas de performance (tempo, precisão).",
                                "Discutir 2 limitações e melhorias potenciais.",
                                "Gravar vídeo funcional do sistema integrado."
                              ],
                              "assessmentCriteria": [
                                "Precisão de detecção de defeitos: ≥90% em testes padronizados.",
                                "Tempo de processamento por peça: ≤5 segundos.",
                                "Integração estável: sem crashes em 10 ciclos consecutivos.",
                                "Documentação clara: código comentado e relatório visual.",
                                "Criatividade na adaptação a variações (iluminação, ângulos).",
                                "Compreensão conceitual: acerto em quiz de 10 perguntas sobre princípios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para transformações de imagem e convoluções.",
                                "Física: Óptica e propriedades de luz em câmeras industriais.",
                                "Programação: Algoritmos Python/OpenCV e controle de hardware.",
                                "Engenharia Aeroespacial: Normas de qualidade ASME para peças.",
                                "Inteligência Artificial: Bases de machine learning para detecção avançada."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Boeing ou Airbus, robôs mecatrônicos com visão computacional inspecionam fuselagens e turbinas para microfissuras, reduzindo recalls em 30% e acelerando produção de 20 horas/mano para minutos automatizados, garantindo segurança de voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Aplicar em Navegação Robótica",
                            "description": "Explicar uso de visão para navegação e orientação em sistemas robóticos mecatrônicos, com referência a times multifuncionais no desenvolvimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Visão Computacional em Navegação Robótica",
                                  "subSteps": [
                                    "Estude os princípios básicos de processamento de imagens: detecção de bordas, segmentação e extração de características.",
                                    "Analise técnicas de visão para orientação: tracking de objetos, SLAM (Simultaneous Localization and Mapping) e odometria visual.",
                                    "Revise exemplos de aplicação em robótica mecatrônica, como navegação em ambientes dinâmicos.",
                                    "Identifique o papel de times multifuncionais: engenheiros de software, hardware e mecânica.",
                                    "Discuta limitações como iluminação variável e processamento em tempo real."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes chave de visão para navegação e liste contribuições de cada função em um time multifuncional.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Computer Vision: Algorithms and Applications' (capítulos iniciais)",
                                    "Vídeos tutoriais sobre OpenCV para robótica",
                                    "Slides sobre SLAM"
                                  ],
                                  "tips": "Use diagramas visuais para mapear fluxos de dados da câmera ao movimento do robô.",
                                  "learningObjective": "Explicar como visão computacional permite navegação autônoma em robôs mecatrônicos.",
                                  "commonMistakes": [
                                    "Confundir visão com sensores ultrassônicos",
                                    "Ignorar impacto de latência no processamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Hardware e Software para Sistema de Visão",
                                  "subSteps": [
                                    "Monte um setup básico: câmera USB ou Raspberry Pi Camera em um robô móvel (ex: chassis com Arduino/Raspberry Pi).",
                                    "Instale bibliotecas: OpenCV, ROS (Robot Operating System) para integração mecatrônica.",
                                    "Calibre a câmera: ajuste foco, distorção e parâmetros intrínsecos.",
                                    "Teste aquisição de imagens em tempo real e visualize feeds.",
                                    "Integre com atuadores: motores para movimento baseado em dados visuais."
                                  ],
                                  "verification": "Capture e processe uma imagem de teste, demonstrando detecção de um objeto simples via código.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Raspberry Pi 4",
                                    "Câmera Pi Camera",
                                    "Chassis robô móvel",
                                    "OpenCV instalado no Python"
                                  ],
                                  "tips": "Comece com ambientes controlados e iluminação uniforme para calibração precisa.",
                                  "learningObjective": "Configurar um sistema de visão funcional integrado a hardware mecatrônico.",
                                  "commonMistakes": [
                                    "Subestimar resolução da câmera para distâncias longas",
                                    "Não sincronizar clocks entre visão e controle"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Algoritmos de Navegação Baseados em Visão",
                                  "subSteps": [
                                    "Desenvolva detecção de linha ou obstáculos usando thresholding e contornos no OpenCV.",
                                    "Implemente controle PID para orientação baseada em centroides detectados.",
                                    "Adicione navegação reativa: evitar colisões via detecção de bordas.",
                                    "Teste em simulação (Gazebo/ROS) antes do hardware real.",
                                    "Otimize para tempo real: reduza resolução ou use processamento paralelo."
                                  ],
                                  "verification": "Execute o robô em um percurso simples (seguir linha de 2m) sem desvios >5cm.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "ROS Noetic",
                                    "Gazebo simulator",
                                    "Código Python/OpenCV",
                                    "Marcadores impressos para testes"
                                  ],
                                  "tips": "Use callbacks em ROS para processamento assíncrono e evite bloqueios.",
                                  "learningObjective": "Criar algoritmos que traduzam dados visuais em comandos de navegação autônoma.",
                                  "commonMistakes": [
                                    "Overfitting a condições específicas de luz",
                                    "Ignorar ruído em detecções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar em Time Multifuncional e Avaliar Desempenho",
                                  "subSteps": [
                                    "Simule colaboração: defina papéis (visão: você; mecânica: colega; software: outro).",
                                    "Integre visão com subsistemas: odometria, IMU e planejamento de caminhos.",
                                    "Realize testes em equipe: debug conjunto e iterações.",
                                    "Meça métricas: precisão de navegação, taxa de falha, tempo de ciclo.",
                                    "Documente lições aprendidas e proponha melhorias interdisciplinares."
                                  ],
                                  "verification": "Gere relatório de teste com vídeos, métricas e feedback do 'time' simulado.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Ferramentas colaborativas como GitHub",
                                    "Planilhas para métricas",
                                    "Vídeos de testes gravados"
                                  ],
                                  "tips": "Use version control para rastrear mudanças de múltiplos membros.",
                                  "learningObjective": "Demonstrar desenvolvimento integrado em times multifuncionais para sistemas robóticos.",
                                  "commonMistakes": [
                                    "Falta de comunicação clara entre funções",
                                    "Não considerar escalabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Programe um robô diferencial para navegar em um labirinto seguindo linhas pretas no chão usando uma câmera overhead, detectando desvios e corrigindo trajetória em tempo real com OpenCV e ROS.",
                              "finalVerifications": [
                                "O robô completa um percurso de 5m com precisão <10cm de erro.",
                                "Sistema detecta e evita obstáculos em >90% dos casos.",
                                "Processamento de frames >15 FPS em hardware embarcado.",
                                "Relatório descreve contribuições multifuncionais.",
                                "Código é modular e comentado para reutilização.",
                                "Testes em condições variáveis (luz/baixa luz) funcionam."
                              ],
                              "assessmentCriteria": [
                                "Precisão e robustez da navegação visual (peso: 30%)",
                                "Eficiência computacional e tempo real (peso: 20%)",
                                "Integração com hardware mecatrônico (peso: 20%)",
                                "Documentação de colaboração em time (peso: 15%)",
                                "Tratamento de erros comuns e otimizações (peso: 15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria e álgebra linear para transformações de imagem.",
                                "Programação: Python/OpenCV/ROS para implementação.",
                                "Eletrônica: Integração com sensores e atuadores.",
                                "Gestão de Projetos: Dinâmicas de times multifuncionais.",
                                "Inteligência Artificial: Conceitos básicos de machine learning para tracking avançado."
                              ],
                              "realWorldApplication": "Desenvolvimento de robôs AGV (Automated Guided Vehicles) em fábricas para transporte autônomo, drones de inspeção em agricultura ou veículos autônomos em logística, onde times mecatrônicos colaboram para navegação segura em ambientes reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Planejar Projeto Inicial",
                            "description": "Elaborar um plano básico para um projeto mecatrônico incorporando visão computacional, referenciando métodos de design engineering (CROSS, 2004).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Objetivos e Requisitos do Projeto",
                                  "subSteps": [
                                    "Identifique o problema principal que o projeto mecatrônico com visão computacional visa resolver.",
                                    "Liste os requisitos funcionais, como detecção de objetos em tempo real.",
                                    "Defina restrições técnicas, como hardware disponível (câmera Raspberry Pi) e orçamento.",
                                    "Especifique objetivos SMART (Específicos, Mensuráveis, Alcançáveis, Relevantes, Temporais).",
                                    "Documente stakeholders envolvidos e suas expectativas."
                                  ],
                                  "verification": "Verifique se os objetivos estão documentados em um documento inicial com pelo menos 5 requisitos claros.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Papel ou editor de texto (Google Docs), modelo SMART template"
                                  ],
                                  "tips": "Comece com um brainstorm individual para evitar viés de grupo inicial.",
                                  "learningObjective": "Compreender e articular objetivos claros para projetos mecatrônicos integrando visão computacional.",
                                  "commonMistakes": [
                                    "Definir objetivos vagos como 'fazer um robô', em vez de 'detectar bolas vermelhas a 2m de distância com 90% de precisão'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar e Referenciar Métodos de Design Engineering",
                                  "subSteps": [
                                    "Estude o framework de Nigel Cross (2004) em 'Engineering Design Methods', focando em clarificação de tarefas e conceitualização.",
                                    "Pesquise aplicações de visão computacional em mecatrônica (ex: OpenCV para detecção de bordas).",
                                    "Colete referências bibliográficas e cases de estudo semelhantes.",
                                    "Analise forças e fraquezas de abordagens existentes.",
                                    "Integre insights ao plano inicial."
                                  ],
                                  "verification": "Confirme a inclusão de pelo menos 3 referências, incluindo Cross (2004), com resumo de 1 parágrafo cada.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Livro ou PDF de Cross (2004), acesso à internet para artigos IEEE/Springer, ferramenta Zotero para referências"
                                  ],
                                  "tips": "Use palavras-chave como 'vision-based mechatronics design' para buscas eficientes.",
                                  "learningObjective": "Aplicar princípios de design engineering para fundamentar o planejamento de projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Ignorar referências acadêmicas e basear-se apenas em tutoriais online superficiais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Esboçar Design Conceitual e Plano Preliminar",
                                  "subSteps": [
                                    "Crie diagramas de fluxo: entrada (câmera), processamento (visão computacional), saída (atuadores mecatrônicos).",
                                    "Desenhe arquitetura do sistema usando ferramentas como Draw.io.",
                                    "Defina componentes principais: hardware (RPi, câmera), software (Python/OpenCV).",
                                    "Estime cronograma com milestones (ex: protótipo em 2 semanas).",
                                    "Liste riscos potenciais e mitigações."
                                  ],
                                  "verification": "Avalie se o esboço inclui pelo menos 1 diagrama de fluxo e cronograma Gantt básico.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Draw.io ou Lucidchart (gratuito), planilha Excel para Gantt"
                                  ],
                                  "tips": "Mantenha o design modular para facilitar iterações futuras.",
                                  "learningObjective": "Desenvolver representações visuais e cronogramas para projetos integrados de mecatrônica.",
                                  "commonMistakes": [
                                    "Sobrecarregar o plano com detalhes prematuros, ignorando iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Revisar Viabilidade e Finalizar Plano",
                                  "subSteps": [
                                    "Avalie viabilidade técnica, custo e tempo usando matriz de decisão.",
                                    "Colete feedback de pares ou mentor sobre o plano.",
                                    "Ajuste com base em referências de Cross (2004) para refinamento conceitual.",
                                    "Compile o plano final em documento estruturado (objetivos, pesquisa, design, cronograma).",
                                    "Defina métricas de sucesso iniciais."
                                  ],
                                  "verification": "O plano final deve ter versão 1.0 assinada digitalmente e compartilhada.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Matriz de decisão template, Google Drive para compartilhamento"
                                  ],
                                  "tips": "Use a regra 80/20: foque nos 20% de elementos que resolvem 80% do problema.",
                                  "learningObjective": "Garantir viabilidade e refinamento de planos de projeto mecatrônico.",
                                  "commonMistakes": [
                                    "Pular revisão, resultando em planos irrealistas"
                                  ]
                                }
                              ],
                              "practicalExample": "Planejar um braço robótico mecatrônico que usa visão computacional (OpenCV no Raspberry Pi) para pick-and-place de peças coloridas em uma linha de montagem simulada, referenciando o método de clarificação de tarefas de Cross (2004).",
                              "finalVerifications": [
                                "Objetivos SMART estão explicitamente definidos?",
                                "Referências a Cross (2004) e pelo menos 2 fontes adicionais estão integradas?",
                                "Diagrama conceitual cobre visão computacional e componentes mecatrônicos?",
                                "Cronograma realista com milestones foi incluído?",
                                "Riscos e mitigações foram listados?",
                                "Métricas de sucesso iniciais foram especificadas?"
                              ],
                              "assessmentCriteria": [
                                "Clareza e especificidade dos objetivos (30%)",
                                "Profundidade da pesquisa e integração de design engineering (25%)",
                                "Qualidade dos diagramas e cronograma (20%)",
                                "Análise de viabilidade e riscos (15%)",
                                "Estrutura e profissionalismo do documento final (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Integração de OpenCV em Python para visão computacional.",
                                "Engenharia Elétrica: Seleção de sensores e atuadores.",
                                "Gestão de Projetos: Uso de ferramentas como Gantt e análise de riscos.",
                                "Matemática: Modelos geométricos para processamento de imagem.",
                                "Ética em Engenharia: Considerações de segurança em sistemas autônomos."
                              ],
                              "realWorldApplication": "Em indústrias automotiva e manufatura, como planejamento de sistemas de inspeção visual por robôs na linha de produção da Tesla ou Siemens, otimizando eficiência e reduzindo erros humanos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Introdução à Robótica Mecatrônica",
                    "description": "Fundamentos de robótica com foco em aplicações na indústria aeronáutica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Fundamentos da Robótica Mecatrônica",
                        "description": "Apresentação dos conceitos básicos de robótica, com ênfase na integração mecatrônica para sistemas automatizados.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Definir Robótica Mecatrônica",
                            "description": "Explicar o conceito de robótica mecatrônica como a sinergia entre mecânica, eletrônica, controle e informática, destacando sua relevância em sistemas integrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os pilares fundamentais da Robótica Mecatrônica",
                                  "subSteps": [
                                    "Pesquisar e anotar a definição de mecânica como o estudo de forças, movimentos e estruturas.",
                                    "Definir eletrônica como o campo que lida com circuitos, sensores e atuadores.",
                                    "Explicar controle como sistemas de feedback e regulação automática de processos.",
                                    "Descrever informática como programação, algoritmos e processamento de dados.",
                                    "Comparar os quatro pilares em uma tabela simples."
                                  ],
                                  "verification": "Criar uma tabela com definições precisas e fontes citadas para cada pilar.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet ou livros de mecatrônica",
                                    "Caderno e caneta",
                                    "Ferramenta de tabela como Google Sheets"
                                  ],
                                  "tips": "Priorize fontes acadêmicas ou sites como IEEE para definições precisas.",
                                  "learningObjective": "Identificar e definir com clareza os quatro componentes essenciais: mecânica, eletrônica, controle e informática.",
                                  "commonMistakes": [
                                    "Confundir eletrônica com informática",
                                    "Omitir exemplos práticos nos pilares",
                                    "Usar definições superficiais sem contexto técnico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a sinergia e integração entre os pilares",
                                  "subSteps": [
                                    "Explicar como a mecânica fornece a estrutura física para robôs.",
                                    "Descrever a contribuição da eletrônica para sensores e atuadores.",
                                    "Detalhar o papel do controle em loops de feedback para precisão.",
                                    "Mostrar como a informática integra tudo via software e IA.",
                                    "Desenhar um fluxograma ilustrando a interação dos pilares."
                                  ],
                                  "verification": "Produzir um fluxograma que demonstre a interdependência dos quatro pilares.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis ou software como Draw.io",
                                    "Referências visuais de robôs mecatrônicos"
                                  ],
                                  "tips": "Use setas no fluxograma para mostrar fluxos de dados e comandos entre pilares.",
                                  "learningObjective": "Compreender como os pilares se integram sinergeticamente para formar sistemas robóticos.",
                                  "commonMistakes": [
                                    "Tratar pilares como isolados",
                                    "Ignorar feedback loops no controle",
                                    "Subestimar o papel da informática na autonomia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar características da Robótica Mecatrônica em sistemas integrados",
                                  "subSteps": [
                                    "Identificar traços como automação, inteligência embarcada e modularidade.",
                                    "Exemplificar com um braço robótico: mecânica no movimento, eletrônica nos sensores.",
                                    "Discutir integração em sistemas como drones ou veículos autônomos.",
                                    "Listar benefícios: eficiência, precisão e adaptabilidade.",
                                    "Criar um mapa mental conectando características aos pilares."
                                  ],
                                  "verification": "Elaborar um mapa mental com pelo menos 5 características ligadas aos pilares.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de mind mapping como MindMeister ou papel",
                                    "Imagens de robôs reais"
                                  ],
                                  "tips": "Inclua ícones visuais para tornar o mapa mais intuitivo e memorável.",
                                  "learningObjective": "Reconhecer as propriedades únicas da robótica mecatrônica em contextos integrados.",
                                  "commonMistakes": [
                                    "Focar só em hardware, ignorando software",
                                    "Não ligar características à sinergia",
                                    "Confundir com robótica pura mecânica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar a relevância em sistemas integrados e aplicações",
                                  "subSteps": [
                                    "Explicar relevância em Indústria 4.0 e automação industrial.",
                                    "Relacionar com sistemas integrados como linhas de produção inteligentes.",
                                    "Discutir impactos: redução de custos, segurança e inovação.",
                                    "Pesquisar um case real e resumir em 3 pontos chave.",
                                    "Redigir um parágrafo definindo robótica mecatrônica com todos os elementos."
                                  ],
                                  "verification": "Escrever uma definição completa de 150-200 palavras incorporando todos os conceitos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigos ou vídeos sobre Indústria 4.0",
                                    "Editor de texto"
                                  ],
                                  "tips": "Inicie a definição com 'Robótica mecatrônica é...' e finalize com relevância.",
                                  "learningObjective": "Articular a definição integral e sua importância prática em sistemas modernos.",
                                  "commonMistakes": [
                                    "Definição genérica sem sinergia",
                                    "Omitir relevância atual",
                                    "Exagerar aplicações sem base factual"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um diagrama de um robô aspirador de pó (como Roomba): mecânica nas rodas e escovas, eletrônica nos sensores de obstáculos, controle no algoritmo de navegação, informática no app de programação via Wi-Fi, demonstrando sinergia em um sistema integrado doméstico.",
                              "finalVerifications": [
                                "Definir corretamente robótica mecatrônica como sinergia de mecânica, eletrônica, controle e informática.",
                                "Explicar com precisão a integração dos quatro pilares em um fluxograma ou mapa.",
                                "Identificar pelo menos 3 características chave de sistemas mecatrônicos.",
                                "Relacionar a relevância com exemplos de sistemas integrados reais.",
                                "Produzir uma definição escrita coesa e completa.",
                                "Demonstrar compreensão via diagrama prático."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual nos pilares e sinergia (30%)",
                                "Profundidade nos substeps e exemplos (25%)",
                                "Qualidade visual e clareza de diagramas/mapas (20%)",
                                "Relevância destacada com cases reais (15%)",
                                "Definição final articulada e original (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de mecânica e dinâmica nos movimentos robóticos.",
                                "Matemática: Modelos de controle e algoritmos de otimização.",
                                "Informática: Programação embarcada e inteligência artificial.",
                                "Engenharia de Produção: Integração em linhas de montagem e Indústria 4.0."
                              ],
                              "realWorldApplication": "Na indústria automotiva, robótica mecatrônica é usada em braços robóticos da KUKA para soldagem precisa em linhas de montagem da BMW, integrando mecânica para alcance, eletrônica para visão, controle para trajetória e informática para adaptação em tempo real, aumentando eficiência em 40%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Classificar Tipos de Robôs",
                            "description": "Identificar e classificar robôs industriais por configuração (cartesiano, cilíndrico, esférico, articulado) e graus de liberdade, com exemplos iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as configurações geométricas básicas de robôs industriais",
                                  "subSteps": [
                                    "Pesquise e defina robô cartesiano: eixos lineares ortogonais (X, Y, Z).",
                                    "Estude robô cilíndrico: rotação em torno de um eixo e movimentos lineares radiais e verticais.",
                                    "Analise robô esférico: rotação em dois eixos e movimento linear radial.",
                                    "Descreva robô articulado: juntas rotacionais semelhantes a braço humano, com múltiplos graus de liberdade.",
                                    "Compare as configurações em uma tabela simples, destacando alcance e precisão."
                                  ],
                                  "verification": "Crie uma tabela comparativa com definições e diagramas simples; verifique se todos os 4 tipos estão corretamente descritos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro ou PDF sobre robótica industrial",
                                    "Papel e caneta para tabela",
                                    "Vídeos introdutórios no YouTube sobre configurações de robôs"
                                  ],
                                  "tips": "Use diagramas visuais para fixar as diferenças geométricas; associe cada tipo a uma forma geométrica familiar.",
                                  "learningObjective": "Identificar e descrever as quatro configurações principais de robôs industriais.",
                                  "commonMistakes": [
                                    "Confundir cilíndrico com esférico (ambos têm rotação, mas esférico tem duas rotações iniciais)",
                                    "Ignorar limitações de alcance em configurações esféricas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar os graus de liberdade (DOF) em robôs",
                                  "subSteps": [
                                    "Defina graus de liberdade: número de movimentos independentes (translação e rotação).",
                                    "Classifique DOF comuns: 3 DOF (posição), 4-5 DOF (posição + orientação parcial), 6 DOF (posição completa + orientação).",
                                    "Relacione DOF com configurações: cartesiano tipicamente 3 DOF, articulado até 6+ DOF.",
                                    "Calcule DOF simples: some translações (3) e rotações (3) para robôs seriais.",
                                    "Visualize com exemplos: um braço humano tem 7 DOF aproximados."
                                  ],
                                  "verification": "Responda a 5 perguntas de autoavaliação sobre DOF e configure um esboço de robô com 6 DOF.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Diagramas de robôs online (ex: sites da ABB ou Fanuc)",
                                    "Folha de exercícios sobre DOF"
                                  ],
                                  "tips": "Lembre-se: DOF = 6 para manipulação completa no espaço 3D; pratique contando juntas.",
                                  "learningObjective": "Explicar e calcular graus de liberdade em diferentes configurações de robôs.",
                                  "commonMistakes": [
                                    "Confundir DOF com número de eixos (DOF considera independência)",
                                    "Subestimar rotações em articulados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender critérios de classificação combinada",
                                  "subSteps": [
                                    "Estabeleça critérios: configuração primária + número de DOF + aplicação típica.",
                                    "Crie fluxograma: inicie por configuração, adicione DOF para subclassificação.",
                                    "Classifique exemplos iniciais: SCARA (cilíndrico/4 DOF), Delta (paralelo, mas foque seriais).",
                                    "Diferencie por workspace: cartesiano (cubo), articulado (esfera).",
                                    "Registre classificações em um quadro de notas."
                                  ],
                                  "verification": "Desenvolva um fluxograma funcional e classifique 3 robôs genéricos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma online (ex: Lucidchart gratuito)",
                                    "Imagens de robôs industriais",
                                    "Quadro branco ou app de notas"
                                  ],
                                  "tips": "Sempre pergunte: 'Qual a geometria do movimento?' antes de DOF.",
                                  "learningObjective": "Aplicar critérios duplos (configuração + DOF) para classificação precisa.",
                                  "commonMistakes": [
                                    "Classificar apenas por DOF sem configuração",
                                    "Ignorar aplicações que influenciam escolhas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar classificação com exemplos reais",
                                  "subSteps": [
                                    "Selecione 5 imagens de robôs industriais (ex: ABB IRB, KUKA).",
                                    "Classifique cada um: configuração, DOF estimado, exemplo de uso.",
                                    "Compare classificações com fontes confiáveis (catálogos de fabricantes).",
                                    "Crie cartões de memória: frente (imagem), verso (classificação).",
                                    "Teste-se com autoquiz usando os cartões."
                                  ],
                                  "verification": "Classifique corretamente 80% dos 5 exemplos em um quiz autoaplicado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Imagens de robôs (Google Images ou sites de fabricantes)",
                                    "Cartões de papel ou app Anki",
                                    "Catálogos PDF de robôs (ABB, Fanuc)"
                                  ],
                                  "tips": "Comece com robôs famosos para ganhar confiança; revise erros imediatamente.",
                                  "learningObjective": "Classificar robôs reais de forma autônoma e precisa.",
                                  "commonMistakes": [
                                    "Classificar SCARA como cartesiano (é híbrido cilíndrico)",
                                    "Superestimar DOF sem evidência visual"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise um robô de soldagem automotiva da KUKA KR 6: configuração articulada (6 eixos rotacionais), 6 DOF, usado para solda por pontos em linhas de montagem de carros, alcançando posições precisas em 3D.",
                              "finalVerifications": [
                                "Liste e descreva corretamente as 4 configurações principais.",
                                "Explique graus de liberdade com pelo menos 3 exemplos (3, 4, 6 DOF).",
                                "Classifique 5 robôs industriais fornecidos com precisão.",
                                "Crie um fluxograma de classificação funcional.",
                                "Identifique aplicações típicas para cada configuração.",
                                "Diferencie workspace de cada tipo em um diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de configurações (90% correto).",
                                "Correta associação de DOF com mobilidade (sem erros conceituais).",
                                "Uso de exemplos relevantes e fontes confiáveis.",
                                "Clareza no fluxograma ou tabela de classificação.",
                                "Capacidade de explicar diferenças em workspace e aplicações.",
                                "Ausência de confusões comuns (ex: cilíndrico vs. esférico)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria analítica e sistemas de coordenadas (cartesiano vs. polar).",
                                "Física: Cinemática e dinâmica de manipulação robótica.",
                                "Engenharia Mecânica: Design de juntas e mecanismos.",
                                "Informática: Programação de trajetórias em DOF.",
                                "Indústria 4.0: Integração com automação e IoT."
                              ],
                              "realWorldApplication": "Na indústria automotiva (ex: montagem de veículos pela Volkswagen), robôs articulados de 6 DOF realizam soldagem e pintura precisas, aumentando eficiência e segurança; configurações cartesianas são usadas em pick-and-place em eletrônicos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Descrever Leis da Robótica",
                            "description": "Relacionar as três leis de Asimov à programação ética de robôs mecatrônicos e discutir implicações em projetos industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Memorizar e Descrever as Três Leis de Asimov",
                                  "subSteps": [
                                    "Ler o texto original das três leis de Asimov de 'I, Robot'.",
                                    "Anotar cada lei verbatim em um caderno ou documento digital.",
                                    "Reescrever cada lei em palavras próprias, mantendo o significado exato.",
                                    "Identificar a hierarquia implícita (1ª lei sobrepõe à 2ª, etc.).",
                                    "Discutir brevemente a Lei Zero como extensão."
                                  ],
                                  "verification": "Recitar as três leis corretamente sem consulta e explicar a hierarquia.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Texto das Leis de Asimov (impresso ou online)",
                                    "Caderno ou editor de texto"
                                  ],
                                  "tips": [
                                    "Use mnemônicos como 'Não machucar humanos (1), Obedecer (2), Auto-proteger (3)'.",
                                    "Repita em voz alta para fixação."
                                  ],
                                  "learningObjective": "Identificar e descrever precisamente as três leis de Asimov e sua estrutura hierárquica.",
                                  "commonMistakes": [
                                    "Confundir a ordem das leis.",
                                    "Omitir palavras-chave como 'through inaction' na 1ª lei."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Contexto e Propósito das Leis",
                                  "subSteps": [
                                    "Pesquisar biografia de Isaac Asimov e origem das leis na ficção científica.",
                                    "Ler resumos de histórias curtas onde as leis são aplicadas ou violadas.",
                                    "Mapear propósitos: segurança humana, obediência e autopreservação.",
                                    "Comparar com dilemas éticos reais na literatura.",
                                    "Anotar como as leis resolvem conflitos potenciais em robôs autônomos."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo o contexto histórico e literário das leis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Artigos ou Wikipedia sobre Asimov",
                                    "Livro 'I, Robot' ou resumos online",
                                    "Acesso à internet"
                                  ],
                                  "tips": [
                                    "Foque em exemplos literários para ilustrar conflitos.",
                                    "Crie um diagrama de hierarquia das leis."
                                  ],
                                  "learningObjective": "Compreender o contexto ficcional e os dilemas éticos que inspiraram as leis.",
                                  "commonMistakes": [
                                    "Ignorar a Lei Zero e suas implicações coletivas.",
                                    "Confundir ficção com propostas reais de programação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar as Leis à Programação Ética de Robôs Mecatrônicos",
                                  "subSteps": [
                                    "Mapear Lei 1 a protocolos de segurança (ex: sensores de proximidade).",
                                    "Mapear Lei 2 a comandos de controle hierárquico em software.",
                                    "Mapear Lei 3 a modos de falha segura e redundâncias.",
                                    "Discutir implementação em linguagens como ROS ou Arduino para mecatrônica.",
                                    "Explorar conflitos éticos, como priorizar humanos vs. eficiência."
                                  ],
                                  "verification": "Criar um fluxograma simples mostrando como codificar uma lei em pseudocódigo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Documentação ROS ou Arduino",
                                    "Ferramenta de diagrama (Draw.io)",
                                    "Exemplos de código ético open-source"
                                  ],
                                  "tips": [
                                    "Pense em 'fail-safe' designs inspirados nas leis.",
                                    "Use if-then-else para modelar hierarquia."
                                  ],
                                  "learningObjective": "Conectar as leis de Asimov a princípios éticos e técnicos na programação de robôs.",
                                  "commonMistakes": [
                                    "Subestimar ambiguidades linguísticas em programação.",
                                    "Ignorar trade-offs entre leis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Implicações em Projetos Industriais",
                                  "subSteps": [
                                    "Analisar casos reais: robôs colaborativos (cobots) em fábricas.",
                                    "Discutir regulamentações como ISO 10218 para segurança robótica.",
                                    "Explorar dilemas: produção vs. segurança humana em linhas de montagem.",
                                    "Propor adaptações das leis para IA industrial moderna.",
                                    "Debater limitações: leis não cobrem hacking ou decisões morais complexas."
                                  ],
                                  "verification": "Redigir um relatório curto (300 palavras) com exemplos industriais e recomendações.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Casos de estudo industriais (ex: ABB ou Fanuc robôs)",
                                    "Normas ISO online",
                                    "Vídeos de cobots em ação"
                                  ],
                                  "tips": [
                                    "Relacione a acidentes reais como o de robôs em fábricas.",
                                    "Considere cenários futuros com IA avançada."
                                  ],
                                  "learningObjective": "Avaliar impactos práticos e limitações das leis em contextos industriais mecatrônicos.",
                                  "commonMistakes": [
                                    "Generalizar ficção sem evidências reais.",
                                    "Omitir aspectos legais e de responsabilidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem automotiva, um robô mecatrônico detecta um trabalhador se aproximando (Lei 1): para imediatamente, ignora comando de produção (Lei 2 sobreposta), e só reinicia após verificação de segurança (Lei 3), evitando acidentes.",
                              "finalVerifications": [
                                "Recitar as três leis verbatim e explicar hierarquia.",
                                "Fornecer pseudocódigo para implementar uma lei em um robô.",
                                "Descrever um dilema ético industrial resolvido pelas leis.",
                                "Identificar limitações das leis em cenários reais.",
                                "Mapear leis a normas ISO de segurança robótica.",
                                "Debater Lei Zero em contextos coletivos industriais."
                              ],
                              "assessmentCriteria": [
                                "Precisão e fidelidade na descrição das leis (90%+ exatidão).",
                                "Profundidade na análise ética e programação (exemplos concretos).",
                                "Relevância das implicações industriais (ligação com mecatrônica).",
                                "Criatividade em fluxogramas ou exemplos práticos.",
                                "Identificação de limitações e propostas de melhoria.",
                                "Clareza e estrutura no relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Ética Filosófica: Dilemas morais em autonomia robótica.",
                                "Programação e Ciência da Computação: Algoritmos de decisão ética.",
                                "Direito e Regulamentação: Normas de segurança e responsabilidade civil.",
                                "Engenharia de Sistemas: Design fail-safe em mecatrônica.",
                                "Filosofia da Tecnologia: Impacto social da robótica industrial."
                              ],
                              "realWorldApplication": "Na indústria 4.0, princípios das Leis de Asimov guiam a programação de cobots em fábricas da Tesla ou Volkswagen, priorizando segurança humana sobre eficiência, reduzindo acidentes e atendendo normas como ISO/TS 15066 para colaboração homem-robô."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Componentes Mecatrônicos em Robótica",
                        "description": "Exploração dos elementos fundamentais que compõem sistemas robóticos mecatrônicos, incluindo hardware e software.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Identificar Sensores e Atuadores",
                            "description": "Listar e descrever sensores (visão por computador, proximidade) e atuadores (motores, servos) usados em robôs, com foco em integração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Sensores e Atuadores",
                                  "subSteps": [
                                    "Definir sensor como dispositivo que detecta e mede grandezas físicas do ambiente.",
                                    "Definir atuador como dispositivo que converte sinais elétricos em ação mecânica.",
                                    "Explicar o papel dos sensores na percepção do robô e dos atuadores na ação.",
                                    "Diferenciar entrada (sensores) de saída (atuadores) em sistemas robóticos.",
                                    "Discutir importância da integração para feedback em loop fechado."
                                  ],
                                  "verification": "Resumir definições em um diagrama simples de entrada-saída.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro branco ou papel",
                                    "Marcadores",
                                    "Vídeo introdutório sobre robótica (YouTube: 'Sensores e Atuadores em Robôs')"
                                  ],
                                  "tips": [
                                    "Use analogias cotidianas, como olhos (sensores) e músculos (atuadores).",
                                    "Desenhe fluxogramas para visualizar o ciclo percepção-ação."
                                  ],
                                  "learningObjective": "Diferenciar conceitos fundamentais de sensores e atuadores em robótica.",
                                  "commonMistakes": [
                                    "Confundir sensores com atuadores.",
                                    "Ignorar o papel de feedback no sistema."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Descrever Sensores Comuns em Robótica",
                                  "subSteps": [
                                    "Listar sensores de proximidade (ultrassônico, infravermelho).",
                                    "Descrever visão por computador (câmeras com processamento de imagem).",
                                    "Explorar outros sensores: encoders, sensores de luz, acelerômetros.",
                                    "Analisar princípio de funcionamento de cada um (ex: reflexão de ondas para proximidade).",
                                    "Classificar por tipo de sinal detectado (distância, luz, movimento)."
                                  ],
                                  "verification": "Criar tabela com 5 sensores, colunas: nome, função, exemplo de uso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela em Excel ou papel",
                                    "Imagens de sensores (imprimir ou digital)",
                                    "Datasheets de sensores (Arduino HC-SR04)"
                                  ],
                                  "tips": [
                                    "Pesquise exemplos reais em robôs como LEGO Mindstorms.",
                                    "Foquem em aplicações robóticas específicas."
                                  ],
                                  "learningObjective": "Listar e descrever pelo menos 5 sensores comuns com suas funções.",
                                  "commonMistakes": [
                                    "Limitar a lista a apenas 2-3 sensores.",
                                    "Descrições vagas sem princípios físicos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Descrever Atuadores Comuns em Robótica",
                                  "subSteps": [
                                    "Listar motores DC e suas características (velocidade, torque).",
                                    "Descrever servomotores (controle angular preciso).",
                                    "Explorar atuadores adicionais: steppers, solenoides, pneumáticos.",
                                    "Explicar controle: PWM para motores, sinais PWM para servos.",
                                    "Comparar atuadores por precisão, força e velocidade."
                                  ],
                                  "verification": "Montar tabela similar à dos sensores para 5 atuadores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela em Excel ou papel",
                                    "Vídeos de atuadores em ação (YouTube: 'Motores DC vs Servos')",
                                    "Datasheets (SG90 Servo)"
                                  ],
                                  "tips": [
                                    "Teste com Arduino se disponível para sentir vibrações.",
                                    "Relacione com necessidades do robô (ex: precisão para braços)."
                                  ],
                                  "learningObjective": "Listar e descrever pelo menos 5 atuadores comuns com controle.",
                                  "commonMistakes": [
                                    "Confundir motores DC com servos.",
                                    "Omitir métodos de controle."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Integração de Sensores e Atuadores",
                                  "subSteps": [
                                    "Desenhar diagrama de um sistema simples: sensor -> microcontrolador -> atuador.",
                                    "Exemplo: sensor de proximidade para evitar obstáculos com motor.",
                                    "Discutir interfaces (I2C, GPIO, analógico/digital).",
                                    "Analisar loop de controle: leitura, processamento, ação.",
                                    "Simular falhas: sensor ruim afeta atuador."
                                  ],
                                  "verification": "Esboçar diagrama de integração para um robô seguidor de linha.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel para diagramas",
                                    "Software Fritzing ou Tinkercad para simulação",
                                    "Kit Arduino básico (opcional)"
                                  ],
                                  "tips": [
                                    "Use setas para mostrar fluxo de dados.",
                                    "Pense em exemplos reais como drones."
                                  ],
                                  "learningObjective": "Demonstrar como sensores e atuadores se integram em robôs.",
                                  "commonMistakes": [
                                    "Ignorar microcontrolador como ponte.",
                                    "Diagramas desconexos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um robô aspirador de pó como o Roomba, sensores de proximidade (infravermelho) detectam obstáculos e enviam sinal para o microcontrolador, que ajusta os motores DC para desviar, integrando percepção e ação em tempo real.",
                              "finalVerifications": [
                                "Listar corretamente 5 sensores e 5 atuadores com descrições breves.",
                                "Explicar funcionamento de visão por computador e servomotor.",
                                "Desenhar diagrama de integração sensor-atuador.",
                                "Identificar exemplos em vídeos de robôs reais.",
                                "Diferenciar sensores de proximidade de atuadores motores.",
                                "Simular verbalmente um loop de controle."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude nas listas de sensores e atuadores (80% cobertura).",
                                "Clareza nas descrições técnicas e princípios físicos.",
                                "Qualidade do diagrama de integração (fluxo lógico).",
                                "Uso correto de terminologia (ex: PWM, feedback).",
                                "Conexão com aplicações robóticas reais.",
                                "Ausência de confusões entre sensores e atuadores."
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de ondas (ultrassom), óptica (visão).",
                                "Eletrônica: Interfaces digitais/analógicas, PWM.",
                                "Programação: Leitura de sensores em Arduino/Python.",
                                "Engenharia: Design de sistemas mecatrônicos.",
                                "Matemática: Cálculo de distâncias e controle PID."
                              ],
                              "realWorldApplication": "Na indústria automobilística, robôs de solda usam sensores de visão por computador para posicionar peças com precisão e atuadores servomotores para movimentos exatos, otimizando produção em linhas de montagem como na fábrica da Tesla."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Explicar Microcontroladores e CLPs",
                            "description": "Diferenciar microprocessadores, microcontroladores e CLPs (Controladores Lógicos Programáveis), exemplificando seu uso em controle robótico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Microprocessadores",
                                  "subSteps": [
                                    "Defina microprocessador como uma CPU standalone que requer componentes externos como RAM, ROM e periféricos.",
                                    "Estude arquitetura básica: ALU, unidade de controle e registradores.",
                                    "Identifique exemplos comuns como Intel 8086 ou ARM Cortex-A usados em computadores.",
                                    "Analise ciclo de instrução: fetch, decode, execute.",
                                    "Pesquise aplicações gerais em PCs e servidores."
                                  ],
                                  "verification": "Crie um diagrama simples da arquitetura de um microprocessador e liste 3 componentes externos necessários.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Vídeos Khan Academy sobre arquitetura de computadores, diagrama impresso de microprocessador.",
                                  "tips": "Use analogias como 'cérebro sem memória' para fixar o conceito.",
                                  "learningObjective": "Explicar o que é um microprocessador e suas limitações sem periféricos integrados.",
                                  "commonMistakes": "Confundir com microcontroladores achando que são idênticos; lembre-se que microprocessadores não têm I/O integrado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Microcontroladores em Detalhe",
                                  "subSteps": [
                                    "Defina microcontrolador como um chip SoC com CPU, RAM, ROM, timers e portas I/O integrados.",
                                    "Estude exemplos como Arduino (ATMega328) ou ESP32.",
                                    "Descreva programação em C/Assembly e uso de bibliotecas.",
                                    "Simule um blink LED para demonstrar controle de periféricos.",
                                    "Compare custo e simplicidade para projetos embarcados."
                                  ],
                                  "verification": "Programe um microcontrolador simulado (Tinkercad) para piscar um LED e explique o código.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador Tinkercad ou Arduino IDE, tutoriais Arduino.cc.",
                                  "tips": "Comece com breadboard virtual para evitar erros de hardware.",
                                  "learningObjective": "Diferenciar microcontroladores por sua integração completa para aplicações embarcadas.",
                                  "commonMistakes": "Ignorar consumo de energia; microcontroladores são otimizados para low-power."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender Controladores Lógicos Programáveis (CLPs)",
                                  "subSteps": [
                                    "Defina CLP como dispositivo industrial programável via ladder logic para automação.",
                                    "Estude componentes: CPU, I/O modules, power supply.",
                                    "Aprenda linguagens: Ladder Diagram, Function Block Diagram (IEC 61131-3).",
                                    "Examine robustez para ambientes industriais (vibração, temperatura).",
                                    "Pesquise exemplos como Siemens S7 ou Allen-Bradley."
                                  ],
                                  "verification": "Desenhe um diagrama ladder simples para ligar uma saída baseado em entrada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software gratuito LogixPro ou PLC Simulator, manuais Siemens online.",
                                  "tips": "Pense em CLPs como 'robôs industriais' para automação sequencial.",
                                  "learningObjective": "Identificar CLPs como solução escalável para controle industrial.",
                                  "commonMistakes": "Confundir com microcontroladores; CLPs priorizam segurança e I/O expansível."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar os Três e Exemplificar em Controle Robótico",
                                  "subSteps": [
                                    "Crie tabela comparativa: integração, custo, ambiente de uso, programação.",
                                    "Exemplo robótica: Microcontrolador em drone (controle PWM motores), CLP em linha de montagem robótica.",
                                    "Simule cenário: Microprocessador em Raspberry Pi para visão computacional robótica.",
                                    "Discuta prós/contras em robótica: flexibilidade vs. robustez.",
                                    "Desenvolva fluxograma de escolha baseado em projeto robótico."
                                  ],
                                  "verification": "Apresente tabela comparativa e exemplo robótico específico com justificativa.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ferramenta Google Sheets para tabela, vídeos YouTube sobre robótica industrial.",
                                  "tips": "Use mnemônico: Microprocessador=PC, Microcontrolador=Hobby, CLP=Fábrica.",
                                  "learningObjective": "Aplicar diferenças em contextos robóticos reais.",
                                  "commonMistakes": "Generalizar usos; cada um é otimizado para cenários específicos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Consolidar Conhecimento com Comparação Prática",
                                  "subSteps": [
                                    "Debata cenários: Qual usar para robô móvel low-cost? Para automação fabril?",
                                    "Revise diferenças chave: standalone vs. integrado vs. modular.",
                                    "Crie quiz autoavaliativo com 10 perguntas.",
                                    "Pesquise cases reais: uso em robôs industriais como ABB.",
                                    "Registre insights em um resumo pessoal."
                                  ],
                                  "verification": "Responda quiz com 90% acerto e compartilhe resumo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Quiz Google Forms auto-criado, artigos IEEE sobre robótica.",
                                  "tips": "Grave áudio explicando diferenças para reforço auditivo.",
                                  "learningObjective": "Sintetizar conhecimentos para decisões informadas em projetos.",
                                  "commonMistakes": "Subestimar CLPs em robótica; eles são cruciais em integração fabril."
                                }
                              ],
                              "practicalExample": "Em um braço robótico pick-and-place: Microcontrolador (Arduino) gerencia sensores e atuadores locais; CLP (Siemens) coordena sequência industrial com segurança; Microprocessador (RPi) processa visão via câmera para detecção de objetos.",
                              "finalVerifications": [
                                "Liste 5 diferenças chave entre microprocessadores, microcontroladores e CLPs.",
                                "Explique com diagrama como cada um se aplica em um robô móvel.",
                                "Simule um programa simples para cada em ferramenta online.",
                                "Identifique cenário robótico ideal para cada dispositivo.",
                                "Crie tabela comparativa com custo, robustez e flexibilidade.",
                                "Descreva ciclo de vida de um projeto robótico usando os três."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e diferenciação conceitual (30%)",
                                "Qualidade de exemplos robóticos concretos e relevantes (25%)",
                                "Profundidade da tabela comparativa e fluxogramas (20%)",
                                "Correção em simulações práticas (15%)",
                                "Clareza na explicação oral/escrita de aplicações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de C para microcontroladores e ladder para CLPs.",
                                "Eletrônica: Integração de I/O e periféricos.",
                                "Física: Controle de motores e sensores em robótica.",
                                "Gestão de Projetos: Escolha de hardware baseado em requisitos.",
                                "Matemática: Lógica booleana em ladder diagrams."
                              ],
                              "realWorldApplication": "Na indústria automotiva, CLPs controlam linhas robóticas de solda (ex: fábricas Tesla); microcontroladores em drones de inspeção; microprocessadores em sistemas de IA robótica como Boston Dynamics."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Introduzir Sistemas de Visão por Computador",
                            "description": "Descrever princípios básicos de visão computacional em robótica, como processamento de imagens para detecção e navegação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Visão Computacional",
                                  "subSteps": [
                                    "Definir visão computacional como a capacidade de máquinas interpretarem imagens visuais.",
                                    "Explicar os componentes principais: aquisição de imagem, pré-processamento e análise.",
                                    "Discutir aplicações em robótica, como detecção de obstáculos e navegação.",
                                    "Revisar pipeline típico: captura > processamento > interpretação > ação.",
                                    "Explorar diferenças entre visão humana e computacional."
                                  ],
                                  "verification": "O aluno explica verbalmente ou por escrito o pipeline de visão computacional com exemplos robóticos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Apresentação em slides sobre VC",
                                    "Vídeos introdutórios (YouTube: 'Computer Vision Basics')",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias cotidianas, como olhos humanos vs. câmeras, para fixar conceitos.",
                                  "learningObjective": "Identificar e descrever os princípios básicos de visão computacional aplicados à robótica.",
                                  "commonMistakes": [
                                    "Confundir visão computacional com IA geral",
                                    "Ignorar o papel do hardware (câmeras) no processo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Processamento Básico de Imagens",
                                  "subSteps": [
                                    "Instalar bibliotecas como OpenCV em Python.",
                                    "Carregar e exibir imagens usando cv2.imread() e cv2.imshow().",
                                    "Aplicar filtros básicos: conversão para escala de cinza, blur gaussiano e detecção de bordas com Canny.",
                                    "Realizar segmentação simples por limiarização (thresholding).",
                                    "Salvar imagens processadas com cv2.imwrite()."
                                  ],
                                  "verification": "Executar código que carrega uma imagem, aplica filtro e exibe/salva o resultado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3.x",
                                    "OpenCV (pip install opencv-python)",
                                    "Imagens de teste (ex: lenna.png)",
                                    "Jupyter Notebook ou IDE como VS Code"
                                  ],
                                  "tips": "Teste com imagens reais de robôs para maior engajamento; ajuste parâmetros de filtros iterativamente.",
                                  "learningObjective": "Manipular imagens digitalmente para preparar dados em sistemas robóticos.",
                                  "commonMistakes": [
                                    "Esquecer de importar bibliotecas",
                                    "Usar índices errados em arrays de pixels",
                                    "Não tratar erros de carregamento de imagem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Detecção de Objetos e Features",
                                  "subSteps": [
                                    "Implementar detecção de contornos usando findContours().",
                                    "Detectar keypoints com SIFT ou ORB para matching de features.",
                                    "Aplicar detecção de cores em HSV para segmentação de objetos específicos.",
                                    "Usar templates matching para reconhecer padrões simples.",
                                    "Integrar com bounding boxes para localizar objetos detectados."
                                  ],
                                  "verification": "Detectar e desenhar bounding boxes em torno de um objeto específico em uma imagem ou vídeo curto.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "OpenCV",
                                    "Imagens com objetos conhecidos (ex: bola vermelha)",
                                    "Webcam para teste em tempo real"
                                  ],
                                  "tips": "Converta para HSV antes de mascarar cores para robustez à iluminação.",
                                  "learningObjective": "Identificar e localizar elementos visuais relevantes para tarefas robóticas como picking.",
                                  "commonMistakes": [
                                    "Thresholds fixos sensíveis à luz",
                                    "Não filtrar contornos pequenos",
                                    "Confundir keypoints com detecção de objetos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Visão Computacional em Navegação Robótica",
                                  "subSteps": [
                                    "Capturar vídeo em tempo real com cv2.VideoCapture().",
                                    "Implementar line following: detectar linhas pretas em fundo claro.",
                                    "Detectar obstáculos via varredura de regiões de interesse (ROI).",
                                    "Gerar comandos de navegação baseados em detecções (ex: virar esquerda se obstáculo).",
                                    "Testar em simulação ou robô real (ex: TurtleBot)."
                                  ],
                                  "verification": "Executar um loop de vídeo que detecta linha/obstáculo e simula comandos de movimento.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "OpenCV",
                                    "Webcam ou câmera USB",
                                    "Robô simulado (Gazebo/ROS opcional)",
                                    "Código base de line following"
                                  ],
                                  "tips": "Use FPS baixo inicialmente para depuração; adicione PID simples para suavidade.",
                                  "learningObjective": "Integrar visão computacional para controle autônomo de robôs.",
                                  "commonMistakes": [
                                    "Loop infinito sem cv2.waitKey()",
                                    "Alta latência por processamento pesado",
                                    "Ignorar calibração de câmera"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver um robô seguidor de linha que usa visão computacional para detectar uma linha preta em piso claro via OpenCV em Raspberry Pi, ajustando motores para seguir a linha e desviar de obstáculos detectados por cor.",
                              "finalVerifications": [
                                "Explicar o pipeline completo de VC em robótica.",
                                "Processar imagem/vídeo com filtros e detecções corretas.",
                                "Implementar e demonstrar line following em tempo real.",
                                "Identificar erros comuns em cenários reais.",
                                "Propor melhorias para robustez (ex: iluminação variável).",
                                "Simular navegação autônoma com obstáculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (80%+ acerto em quiz sobre princípios).",
                                "Funcionalidade do código (execução sem erros, detecções >70% precisas).",
                                "Eficiência temporal (FPS >10 em hardware básico).",
                                "Criatividade em aplicações robóticas.",
                                "Documentação clara de código e resultados.",
                                "Capacidade de depuração de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para transformações de imagens e convoluções.",
                                "Programação: Python e bibliotecas como NumPy/OpenCV.",
                                "Física: Óptica e propriedades da luz em aquisição de imagens.",
                                "Inteligência Artificial: Introdução a redes neurais para detecção avançada.",
                                "Engenharia de Controle: Integração com sistemas de navegação PID."
                              ],
                              "realWorldApplication": "Sistemas de visão em robôs industriais para inspeção de qualidade, veículos autônomos para detecção de pedestres e faixas, drones para mapeamento topográfico e robôs agrícolas para identificação de plantas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Aplicações na Indústria Aeronáutica",
                        "description": "Análise de casos práticos de robótica mecatrônica no setor aeronáutico, integrando desenvolvimento de produtos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Exemplificar Robôs em Montagem Aeronáutica",
                            "description": "Descrever uso de robôs articulados em perfuração, rebite e montagem de fuselagens, destacando times multifuncionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Robôs Articulados e seu Papel na Montagem Aeronáutica",
                                  "subSteps": [
                                    "Pesquisar definição e características principais de robôs articulados (graus de liberdade, precisão e alcance).",
                                    "Identificar aplicações específicas na indústria aeronáutica, focando em montagem de fuselagens.",
                                    "Analisar vantagens sobre métodos manuais: velocidade, precisão e redução de erros humanos.",
                                    "Estudar componentes chave: braços robóticos, sensores e controladores.",
                                    "Visualizar diagramas ou vídeos de robôs em operação em linhas de produção aeronáutica."
                                  ],
                                  "verification": "Criar um diagrama simples anotado de um robô articulado com suas funções principais na montagem.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Vídeos tutoriais sobre robótica industrial (YouTube ou Khan Academy)",
                                    "Artigos da Boeing/Airbus sobre automação",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Comece com vídeos curtos para visualização rápida antes de ler textos densos.",
                                  "learningObjective": "Entender as características técnicas e o contexto de uso de robôs articulados na aeronáutica.",
                                  "commonMistakes": [
                                    "Confundir robôs articulados com cartesianos",
                                    "Ignorar limitações como custo inicial alto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Uso de Robôs em Perfuração e Rebite",
                                  "subSteps": [
                                    "Descrever o processo de perfuração automatizada: alinhamento, velocidade de rotação e remoção de cavacos.",
                                    "Explicar colocação de rebites: seleção automática de rebites, inserção e fixação.",
                                    "Analisar integração com visão computacional para detecção de posições exatas.",
                                    "Simular um ciclo completo de perfuração-rebite em software ou vídeo.",
                                    "Calcular ganhos de produtividade: comparar tempo manual vs. robótico (ex: 10x mais rápido)."
                                  ],
                                  "verification": "Listar 5 etapas sequenciais de um ciclo de perfuração-rebite e cronometrar um vídeo demonstrativo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simuladores online de robótica (RoboDK gratuito)",
                                    "Vídeos da KUKA ou ABB em perfuração aeronáutica",
                                    "Planilha Excel para cálculos de tempo"
                                  ],
                                  "tips": "Use slow-motion em vídeos para observar precisão milimétrica.",
                                  "learningObjective": "Dominar os processos técnicos de perfuração e rebite realizados por robôs.",
                                  "commonMistakes": [
                                    "Subestimar necessidade de calibração constante",
                                    "Não considerar tolerâncias mínimas em perfurações (0.1mm)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Montagem de Fuselagens com Robôs",
                                  "subSteps": [
                                    "Mapear etapas da montagem de fuselagem: painéis, stringers e frames.",
                                    "Descrever coordenação multi-robô: sincronização para montagem simultânea.",
                                    "Estudar ferramentas de end-effector personalizadas para fuselagem.",
                                    "Avaliar qualidade: inspeção não-destrutiva integrada aos robôs.",
                                    "Comparar com montagem manual em termos de fadiga estrutural e precisão."
                                  ],
                                  "verification": "Desenhar um fluxograma da montagem de uma seção de fuselagem usando robôs.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Diagramas técnicos de fuselagem (NASA ou Airbus sites)",
                                    "Software de desenho como Draw.io",
                                    "Casos de estudo da Embraer ou Boeing"
                                  ],
                                  "tips": "Foque em como robôs reduzem variações humanas em alinhamentos.",
                                  "learningObjective": "Compreender a aplicação integrada de robôs na montagem complexa de fuselagens.",
                                  "commonMistakes": [
                                    "Ignorar desafios de acessibilidade em estruturas curvas",
                                    "Confundir montagem primária com secundária"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar o Papel de Times Multifuncionais na Operação Robótica",
                                  "subSteps": [
                                    "Identificar papéis: engenheiros mecatrônicos, programadores, operadores e mantenedores.",
                                    "Explicar colaboração: programação off-line, testes e ajustes em tempo real.",
                                    "Analisar treinamentos necessários e protocolos de segurança (ISO 10218).",
                                    "Discutir resolução de falhas: diagnóstico rápido e downtime mínimo.",
                                    "Avaliar impacto na produtividade: times híbridos homem-robô."
                                  ],
                                  "verification": "Criar organograma de um time multifuncional para operação robótica em aeronáutica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Normas ISO sobre robótica colaborativa",
                                    "Relatórios de RH da indústria aeronáutica",
                                    "Ferramentas de mindmap como MindMeister"
                                  ],
                                  "tips": "Enfatize comunicação como chave para integração homem-máquina.",
                                  "learningObjective": "Reconhecer a importância da colaboração humana em sistemas robóticos industriais.",
                                  "commonMistakes": [
                                    "Superestimar autonomia total dos robôs",
                                    "Não incluir segurança em treinamentos"
                                  ]
                                }
                              ],
                              "practicalExample": "Na linha de montagem do Boeing 787 Dreamliner, robôs articulados KUKA realizam perfuração e rebite de painéis de fuselagem de compósitos, sincronizados com 6 robôs por estação, reduzindo tempo de ciclo de 30 para 5 minutos por junta, com times de 10 engenheiros mecatrônicos monitorando via HMI.",
                              "finalVerifications": [
                                "Explicar corretamente 3 vantagens de robôs articulados em perfuração aeronáutica.",
                                "Desenhar ciclo completo de rebite automatizado sem erros.",
                                "Identificar 4 papéis em um time multifuncional.",
                                "Calcular ganho de produtividade em um exemplo hipotético.",
                                "Listar 2 normas de segurança robótica aplicáveis.",
                                "Discutir limitação real de robôs em fuselagens curvas."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de processos (90% acurácia).",
                                "Profundidade de sub-steps com exemplos concretos.",
                                "Integração de times multifuncionais no exemplo.",
                                "Uso correto de terminologia aeronáutica/mecatrônica.",
                                "Criatividade em fluxogramas e diagramas.",
                                "Análise de vantagens/desvantagens balanceada."
                              ],
                              "crossCurricularConnections": [
                                "Programação Industrial: G-code e ROS para controle robótico.",
                                "Engenharia de Materiais: Comportamento de compósitos em perfuração.",
                                "Gestão de Projetos: Metodologias Ágeis em times multifuncionais.",
                                "Segurança do Trabalho: Normas ISO para colaboração homem-robô.",
                                "Economia Industrial: ROI de automação em aeronáutica."
                              ],
                              "realWorldApplication": "Em fábricas da Airbus A350, robôs articulados montam fuselagens com precisão submilimétrica, permitindo produção em escala para aviões comerciais, reduzindo custos em 20% e integrando times globais para manutenção preditiva via IA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1",
                              "10.1.1.4.2"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Analisar Inspeção e Qualidade com Robótica",
                            "description": "Explicar aplicação de robôs com visão computacional para inspeção não destrutiva de componentes aeronáuticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Visão Computacional em Robótica",
                                  "subSteps": [
                                    "Estudar os princípios básicos de visão computacional, como processamento de imagens e detecção de bordas.",
                                    "Explorar algoritmos comuns: detecção de objetos (ex: YOLO), segmentação de imagens e análise de defeitos.",
                                    "Analisar como câmeras e sensores são integrados a robôs manipuladores ou drones.",
                                    "Revisar exemplos de bibliotecas como OpenCV para aplicações robóticas.",
                                    "Identificar métricas de precisão em visão computacional (ex: IoU, precisão/recall)."
                                  ],
                                  "verification": "Resumir em um diagrama os componentes de um sistema de visão computacional robótico.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Computador com OpenCV instalado",
                                    "Tutoriais OpenCV online",
                                    "Vídeos demonstrativos de visão computacional"
                                  ],
                                  "tips": "Comece com imagens simples para testar algoritmos antes de cenários complexos.",
                                  "learningObjective": "Dominar os conceitos básicos de visão computacional aplicados a robôs.",
                                  "commonMistakes": [
                                    "Confundir visão computacional com sensores ultrassônicos",
                                    "Ignorar calibração de câmeras",
                                    "Não considerar ruído ambiental em imagens"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Inspeção Não Destrutiva (END) e sua Evolução com Robótica",
                                  "subSteps": [
                                    "Definir END e listar métodos tradicionais (ultrassom, radiografia, partículas magnéticas).",
                                    "Comparar limitações humanas (fadiga, subjetividade) com vantagens robóticas (precisão, repetibilidade).",
                                    "Analisar como robótica automatiza END: mobilidade, acesso a áreas difíceis.",
                                    "Estudar casos de visão computacional para detecção de trincas, corrosão e delaminação.",
                                    "Explorar normas aeronáuticas (ex: FAA, EASA) para inspeções."
                                  ],
                                  "verification": "Criar uma tabela comparativa entre END tradicional e robótica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigos sobre END em aeronáutica",
                                    "Normas FAA/EASA PDFs",
                                    "Vídeos de inspeções robóticas"
                                  ],
                                  "tips": "Foco em componentes críticos como asas e fuselagem para contextualizar.",
                                  "learningObjective": "Entender a transição de métodos manuais para robóticos em END.",
                                  "commonMistakes": [
                                    "Subestimar falsos positivos em detecções",
                                    "Ignorar requisitos regulatórios",
                                    "Confundir END com testes destrutivos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Aplicação de Robôs com Visão em Componentes Aeronáuticos",
                                  "subSteps": [
                                    "Descrever arquitetura de um sistema robótico: braço robótico + câmera + IA.",
                                    "Simular inspeção de componentes: detecção de microfissuras em ligas de titânio.",
                                    "Integrar dados de visão com outros sensores (ex: laser para profundidade).",
                                    "Estudar fluxos de trabalho: aquisição de imagem, pré-processamento, análise e relatório.",
                                    "Avaliar mobilidade robótica para inspeções em voo ou manutenção."
                                  ],
                                  "verification": "Desenhar um fluxograma do processo de inspeção robótica.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software de simulação como ROS/Gazebo",
                                    "Imagens de defeitos aeronáuticos",
                                    "Modelos 3D de componentes"
                                  ],
                                  "tips": "Use datasets públicos de defeitos para prática realista.",
                                  "learningObjective": "Mapear aplicações específicas de robótica com visão na aeronáutica.",
                                  "commonMistakes": [
                                    "Não calibrar perspectiva da câmera",
                                    "Sobrecarregar processamento sem otimização",
                                    "Ignorar condições de iluminação variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Qualidade e Impacto na Produção Aeronáutica",
                                  "subSteps": [
                                    "Definir métricas de qualidade: taxa de detecção, tempo de ciclo, custo-benefício.",
                                    "Analisar relatórios gerados por robôs: alertas automáticos e integração com ERP.",
                                    "Estudar estudos de caso reais (ex: Boeing com drones de inspeção).",
                                    "Discutir escalabilidade para linhas de produção e manutenção preditiva.",
                                    "Propor melhorias: machine learning para aprendizado contínuo."
                                  ],
                                  "verification": "Elaborar um relatório simulado de inspeção com métricas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Estudos de caso Boeing/Airbus",
                                    "Ferramentas de análise de dados como Python/Pandas",
                                    "Templates de relatórios"
                                  ],
                                  "tips": "Quantifique benefícios com números reais de eficiência.",
                                  "learningObjective": "Avaliar o impacto quantitativo da robótica em inspeção de qualidade.",
                                  "commonMistakes": [
                                    "Focar só em precisão sem custo",
                                    "Não considerar treinamento de modelos",
                                    "Subestimar integração com sistemas legados"
                                  ]
                                }
                              ],
                              "practicalExample": "Simulação de inspeção de uma asa de aeronave usando um braço robótico UR5 equipado com câmera Intel RealSense: o robô escaneia a superfície, detecta uma trinca de 0.5mm via OpenCV/YOLO e gera relatório automático com foto anotada e coordenadas GPS na peça.",
                              "finalVerifications": [
                                "Explicar com precisão o fluxo de visão computacional em END robótica.",
                                "Identificar pelo menos 3 vantagens sobre métodos manuais.",
                                "Desenhar corretamente um sistema robótico para inspeção aeronáutica.",
                                "Calcular métricas básicas de detecção em um exemplo simulado.",
                                "Relacionar normas regulatórias a aplicações práticas.",
                                "Propor uma melhoria realista no processo."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (90%+ correção em termos técnicos).",
                                "Profundidade de análise (cobertura de subpassos e exemplos).",
                                "Criatividade em aplicações práticas e conexões reais.",
                                "Clareza na comunicação (diagramas e relatórios legíveis).",
                                "Quantificação de benefícios (uso de métricas numéricas).",
                                "Adesão a normas e segurança aeronáutica."
                              ],
                              "crossCurricularConnections": [
                                "Programação e IA: Desenvolvimento de algoritmos em Python/OpenCV.",
                                "Física e Materiais: Compreensão de propagação de trincas em ligas aeronáuticas.",
                                "Engenharia de Software: Integração ROS para controle robótico.",
                                "Gestão de Qualidade: Normas ISO 9001 e Six Sigma em inspeções.",
                                "Dados e Estatística: Análise de falsos positivos/negativos."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Boeing e Airbus, robôs com visão computacional inspecionam fuselagens e turbinas para detectar defeitos invisíveis a olho nu, reduzindo tempo de manutenção em 70% e aumentando segurança de voo, conforme casos da NASA em inspeções de SpaceX."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1",
                              "10.1.1.4.2"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Discutir Desenvolvimento Integrado de Produtos Robóticos",
                            "description": "Relacionar técnicas de projeto integrado (conforme Cross, 2004) à elaboração de projetos mecatrônicos aeronáuticos com robótica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Técnicas de Projeto Integrado conforme Cross (2004)",
                                  "subSteps": [
                                    "Ler o capítulo relevante de 'Engineering Design Methods' de Nigel Cross (2004) sobre projeto integrado.",
                                    "Identificar princípios chave: integração multidisciplinar, iteração e gerenciamento de requisitos.",
                                    "Mapear os 4 pilares do design thinking integrado: empatia, definição, ideação e prototipagem.",
                                    "Anotar exemplos de aplicação em engenharia.",
                                    "Resumir em um diagrama conceitual."
                                  ],
                                  "verification": "Diagrama conceitual completo com princípios chave anotados e referenciados a Cross (2004).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Engineering Design Methods' de Nigel Cross (2004)",
                                    "Papel ou software de diagramação (ex: Draw.io)"
                                  ],
                                  "tips": "Foque em como o projeto integrado reduz silos entre disciplinas.",
                                  "learningObjective": "Dominar os fundamentos teóricos do projeto integrado para aplicação em mecatrônica.",
                                  "commonMistakes": [
                                    "Ignorar a iteração cíclica",
                                    "Confundir com design sequencial tradicional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Robótica Mecatrônica em Aplicações Aeronáuticas",
                                  "subSteps": [
                                    "Pesquisar componentes mecatrônicos em robôs aeronáuticos: atuadores, sensores e controles.",
                                    "Estudar casos como drones para inspeção de aeronaves ou sistemas autônomos de montagem.",
                                    "Analisar desafios: vibrações, aerodinâmica e integração de software/hardware.",
                                    "Listar tecnologias chave: PID controllers, visão computacional e materiais compostos.",
                                    "Criar uma tabela comparativa de robôs aeronáuticos."
                                  ],
                                  "verification": "Tabela comparativa com pelo menos 5 exemplos de robôs e suas componentes mecatrônicas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Artigos IEEE sobre robótica aeronáutica",
                                    "Vídeos de drones industriais (YouTube/NASA)",
                                    "Planilha Excel ou Google Sheets"
                                  ],
                                  "tips": "Priorize exemplos reais da indústria como Boeing ou Airbus.",
                                  "learningObjective": "Identificar elementos robóticos específicos para contextos aeronáuticos mecatrônicos.",
                                  "commonMistakes": [
                                    "Focar apenas em drones civis, ignorando aplicações industriais",
                                    "Subestimar integração sensorial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Projeto Integrado a Projetos Mecatrônicos Robóticos Aeronáuticos",
                                  "subSteps": [
                                    "Mapear princípios de Cross aos estágios de desenvolvimento de um robô aeronáutico.",
                                    "Desenhar um fluxograma de projeto integrado para um drone de inspeção.",
                                    "Discutir trade-offs: custo vs. performance em integração multidisciplinar.",
                                    "Simular iterações usando ferramentas de modelagem.",
                                    "Documentar 3 conexões específicas entre teoria e prática."
                                  ],
                                  "verification": "Fluxograma completo com mapeamento de princípios de Cross e 3 conexões documentadas.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de fluxograma (Lucidchart ou Visio)",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Use setas bidirecionais no fluxograma para enfatizar iteração.",
                                  "learningObjective": "Estabelecer ligações claras entre teoria de projeto integrado e robótica aeronáutica.",
                                  "commonMistakes": [
                                    "Aplicar princípios rigidamente sem adaptação ao contexto aeronáutico",
                                    "Omitir análise de riscos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Discussão e Apresentação do Desenvolvimento Integrado",
                                  "subSteps": [
                                    "Preparar uma apresentação de 10 minutos relacionando Cross a um projeto robótico.",
                                    "Gravar uma discussão em vídeo ou áudio explicando benefícios e desafios.",
                                    "Receber feedback de pares ou autoavaliação.",
                                    "Revisar e refinar com base em critérios de clareza e profundidade.",
                                    "Compartilhar em fórum ou grupo para discussão coletiva."
                                  ],
                                  "verification": "Vídeo ou script de apresentação revisado com feedback incorporado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta de gravação (Zoom ou Loom)",
                                    "Slides PowerPoint/Google Slides"
                                  ],
                                  "tips": "Estruture como: introdução, relação teórica-prática, exemplos, conclusão.",
                                  "learningObjective": "Desenvolver habilidades de comunicação técnica sobre integração robótica.",
                                  "commonMistakes": [
                                    "Falar em jargões sem explicação",
                                    "Exceder tempo sem foco nos relacionamentos chave"
                                  ]
                                }
                              ],
                              "practicalExample": "Discutir o desenvolvimento de um drone robótico mecatrônico para inspeção de fuselagem de aeronaves na Boeing, aplicando princípios de Cross: integração de equipes de mecânica, eletrônica e software desde a fase de empatia (entender necessidades de manutenção) até prototipagem iterativa, reduzindo tempo de projeto em 30%.",
                              "finalVerifications": [
                                "Explicar corretamente 4 princípios de Cross (2004) em contexto robótico.",
                                "Mapear pelo menos 3 componentes mecatrônicos aeronáuticos a estágios integrados.",
                                "Identificar 2 desafios reais e soluções integradas.",
                                "Apresentar fluxograma lógico de desenvolvimento.",
                                "Demonstrar compreensão via discussão gravada de 5 minutos.",
                                "Listar benefícios quantitativos (ex: redução de custos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação e aplicação de Cross (2004): 25%",
                                "Profundidade na integração mecatrônica-aeronáutica: 25%",
                                "Clareza e estrutura na discussão: 20%",
                                "Uso de exemplos reais e fluxogramas: 15%",
                                "Análise de desafios e trade-offs: 15%"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Integração de algoritmos de controle em projetos multidisciplinares.",
                                "Gestão de Projetos: Aplicação de metodologias ágeis alinhadas a Cross.",
                                "Física/Aerodinâmica: Modelagem de dinâmicas em robótica voadora.",
                                "Design Industrial: Empatia e prototipagem em contextos aeronáuticos."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Embraer ou Airbus, o desenvolvimento integrado de robôs para montagem automatizada ou inspeção reduz erros humanos, acelera produção e atende normas de segurança FAA/EASA, economizando milhões em ciclos de projeto."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1",
                              "10.1.1.4.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Microprocessadores, Microcontroladores e CLPs",
                    "description": "Componentes de controle essenciais em sistemas mecatrônicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Microprocessadores",
                        "description": "Dispositivos eletrônicos que atuam como a unidade central de processamento (CPU) em sistemas computacionais, executando instruções de programas armazenados em memória externa, essenciais para o processamento de dados em sistemas mecatrônicos de alto desempenho.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Identificar componentes e arquitetura de microprocessadores",
                            "description": "Reconhecer os principais componentes de um microprocessador, como ALU, registradores, unidade de controle e barramentos, e descrever sua arquitetura von Neumann ou Harvard em contextos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes principais de um microprocessador",
                                  "subSteps": [
                                    "Estude a ALU (Unidade Lógica Aritmética) e suas funções de operações lógicas e aritméticas.",
                                    "Analise os registradores (como acumulador, PC, IR) e seu papel no armazenamento temporário de dados.",
                                    "Examine a Unidade de Controle (CU) e como ela gerencia o fluxo de instruções.",
                                    "Descreva os barramentos (dados, endereço, controle) e sua interconexão entre componentes.",
                                    "Revise outros componentes auxiliares como contadores e decodificadores de instruções."
                                  ],
                                  "verification": "Liste corretamente os 4 componentes principais com uma função breve para cada um em um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama básico de microprocessador (impresso ou digital)",
                                    "Vídeo tutorial sobre componentes de CPU (ex: Khan Academy ou YouTube)",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Use mnemônicos como 'A-R-C-B' (ALU, Registradores, Controle, Barramentos) para memorizar.",
                                  "learningObjective": "Reconhecer e descrever as funções dos componentes essenciais de um microprocessador.",
                                  "commonMistakes": [
                                    "Confundir ALU com Unidade de Controle",
                                    "Ignorar o papel dos barramentos na comunicação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a arquitetura von Neumann",
                                  "subSteps": [
                                    "Defina a arquitetura von Neumann: memória única para dados e instruções.",
                                    "Desenhe o fluxograma clássico: Bus único compartilhado, CPU acessando memória sequencialmente.",
                                    "Explique o gargalo de von Neumann causado pelo barramento compartilhado.",
                                    "Identifique exemplos de microprocessadores von Neumann (ex: Intel 8086).",
                                    "Compare com arquiteturas modernas que mitigam o gargalo."
                                  ],
                                  "verification": "Desenhe e rotule um diagrama da arquitetura von Neumann, destacando o barramento compartilhado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Diagrama von Neumann (template para preencher)",
                                    "Artigo ou vídeo sobre John von Neumann",
                                    "Caneta e papel para esboço"
                                  ],
                                  "tips": "Pense em 'uma memória para tudo' como uma biblioteca única para livros e anotações.",
                                  "learningObjective": "Explicar os princípios e limitações da arquitetura von Neumann.",
                                  "commonMistakes": [
                                    "Confundir com Harvard",
                                    "Esquecer o gargalo do barramento único"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a arquitetura Harvard",
                                  "subSteps": [
                                    "Defina a arquitetura Harvard: memórias separadas para dados e instruções.",
                                    "Desenhe o fluxograma: Barramentos paralelos para instruções e dados.",
                                    "Explique vantagens como maior velocidade de execução e paralelismo.",
                                    "Identifique exemplos (ex: microcontroladores PIC, DSPs).",
                                    "Discuta aplicações em sistemas embarcados mecatrônicos."
                                  ],
                                  "verification": "Compare diagramas von Neumann e Harvard lado a lado, anotando 3 diferenças chave.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Templates de diagramas von Neumann e Harvard",
                                    "Vídeo comparativo (ex: sobre microcontroladores AVR)",
                                    "Marcadores coloridos para barramentos"
                                  ],
                                  "tips": "Use cores diferentes nos diagramas: azul para instruções, vermelho para dados.",
                                  "learningObjective": "Diferenciar a arquitetura Harvard da von Neumann e suas vantagens.",
                                  "commonMistakes": [
                                    "Achar que Harvard é sempre superior sem contexto",
                                    "Misturar barramentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conhecimento em contextos mecatrônicos",
                                  "subSteps": [
                                    "Analise um diagrama de microprocessador real (ex: 8051 ou ARM básico).",
                                    "Identifique componentes e arquitetura em um datasheet de microcontrolador.",
                                    "Descreva como isso se aplica em sistemas mecatrônicos como robôs ou CLPs.",
                                    "Crie um mapa mental conectando componentes a funções em automação.",
                                    "Simule identificação usando software como Logisim ou Tinkercad."
                                  ],
                                  "verification": "Identifique corretamente componentes e arquitetura em um diagrama fornecido de um microcontrolador mecatrônico.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Datasheet de microcontrolador (ex: ATmega328)",
                                    "Software simulador (Logisim gratuito)",
                                    "Exemplos de projetos mecatrônicos"
                                  ],
                                  "tips": "Comece pelo barramento principal no diagrama para orientação.",
                                  "learningObjective": "Aplicar identificação de componentes e arquiteturas em cenários mecatrônicos reais.",
                                  "commonMistakes": [
                                    "Não considerar o contexto embarcado",
                                    "Ignorar variações híbridas modernas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de braço robótico mecatrônico, identifique no microcontrolador ATmega (Harvard modificada) a ALU processando comandos de movimento, registradores armazenando posições de sensores, CU sequenciando instruções de PWM, e barramentos conectando a memória de programa separada dos dados de encoders.",
                              "finalVerifications": [
                                "Lista todos os componentes principais (ALU, registradores, CU, barramentos) com funções corretas.",
                                "Desenha diagramas precisos de von Neumann e Harvard.",
                                "Diferencia corretamente as duas arquiteturas em uma tabela comparativa.",
                                "Identifica arquitetura em um datasheet real de microprocessador.",
                                "Explica aplicação em pelo menos um contexto mecatrônico.",
                                "Responde a perguntas sobre gargalos e vantagens sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (90% correto).",
                                "Qualidade e legibilidade dos diagramas (todos elementos rotulados).",
                                "Compreensão conceitual das arquiteturas (explicações claras).",
                                "Relevância ao contexto mecatrônico (exemplos práticos).",
                                "Completude dos passos e verificações (nenhum campo omitido).",
                                "Criatividade em conexões reais (além do básico)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Integração com circuitos lógicos e interfaces periféricas.",
                                "Programação: Compreensão de assembly e ciclo de fetch-decode-execute.",
                                "Física: Princípios de sinalização digital em barramentos.",
                                "Engenharia de Controle: Aplicação em CLPs e automação industrial.",
                                "Matemática: Operações binárias na ALU."
                              ],
                              "realWorldApplication": "Em sistemas mecatrônicos industriais, como linhas de montagem automatizadas, engenheiros identificam arquiteturas Harvard em microcontroladores para processar sensores em tempo real sem gargalos, otimizando controle de motores e segurança robótica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Diferenciar microprocessadores de microcontroladores",
                            "description": "Comparar características, vantagens e limitações de microprocessadores versus microcontroladores, focando em aplicações como processamento paralelo em sistemas mecatrônicos integrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Microprocessadores: Definição e Características Básicas",
                                  "subSteps": [
                                    "Pesquise a definição de microprocessador como uma CPU em chip único que executa instruções de programas armazenados externamente.",
                                    "Identifique componentes principais: ALU, registradores, unidade de controle e barramentos.",
                                    "Estude exemplos clássicos como Intel 8086 ou ARM Cortex-A para processadores de alto desempenho.",
                                    "Analise arquitetura von Neumann ou Harvard modificada, enfatizando memória externa.",
                                    "Revise velocidades de clock típicas (GHz) e suporte a processamento paralelo."
                                  ],
                                  "verification": "Crie um diagrama simples da arquitetura de um microprocessador e liste 3 componentes chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com acesso à internet",
                                    "Datasheets de microprocessadores (ex: Intel ou ARM)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use diagramas visuais para fixar a arquitetura; compare com CPU de PC desktop.",
                                  "learningObjective": "Definir microprocessador e listar suas características principais com precisão.",
                                  "commonMistakes": [
                                    "Confundir microprocessador com microcontrolador desde o início",
                                    "Ignorar a dependência de memória externa",
                                    "Subestimar suporte a multiprocessamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Microcontroladores: Definição e Características Básicas",
                                  "subSteps": [
                                    "Defina microcontrolador como um SoC (System-on-Chip) integrando CPU, memória, periféricos e I/O em um único chip.",
                                    "Identifique componentes integrados: RAM, ROM/Flash, timers, ADC/DAC, UART, GPIO.",
                                    "Estude exemplos como AVR (Arduino), PIC ou STM32 para aplicações embarcadas.",
                                    "Analise arquitetura Harvard com memória programada separada e suporte a tempo real.",
                                    "Revise velocidades de clock típicas (MHz) e foco em baixo consumo de energia."
                                  ],
                                  "verification": "Desenhe um diagrama da arquitetura de um microcontrolador e destaque periféricos integrados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com acesso à internet",
                                    "Datasheets de microcontroladores (ex: ATMega328 ou STM32)",
                                    "Software de simulação como Tinkercad"
                                  ],
                                  "tips": "Enfatize a integração total para entender por que são 'tudo-em-um'; teste um blink LED virtual.",
                                  "learningObjective": "Definir microcontrolador e descrever sua integração SoC.",
                                  "commonMistakes": [
                                    "Achar que microcontroladores são apenas 'mini-PCs'",
                                    "Ignorar periféricos como timers e ADC",
                                    "Confundir flash com RAM volátil"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave entre Microprocessadores e Microcontroladores",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: arquitetura (von Neumann vs Harvard), memória (externa vs integrada), periféricos (ausentes vs integrados).",
                                    "Compare desempenho: clock speed, suporte a OS/multitarefa vs determinismo tempo real.",
                                    "Analise consumo de energia e custo: alto para processadores vs baixo para controladores.",
                                    "Discuta escalabilidade: processadores para computação pesada vs controladores para tarefas específicas.",
                                    "Examine interfaces: múltiplos barramentos em processadores vs GPIO direto em controladores."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 diferenças chave e justifique cada uma.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Artigos comparativos online (ex: Embedded.com)",
                                    "Impressos de steps anteriores"
                                  ],
                                  "tips": "Use cores na tabela para destacar vantagens; foque em aplicações mecatrônicas.",
                                  "learningObjective": "Identificar e justificar pelo menos 5 diferenças fundamentais.",
                                  "commonMistakes": [
                                    "Generalizar sem exemplos específicos",
                                    "Ignorar contexto de aplicação",
                                    "Confundir termos como 'paralelo' com 'multitarefa'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens, Limitações e Aplicações em Sistemas Mecatrônicos",
                                  "subSteps": [
                                    "Liste vantagens de microprocessadores: processamento paralelo, multitasking, alto desempenho em visão computacional.",
                                    "Liste limitações: alto consumo, custo, complexidade de design externo.",
                                    "Liste vantagens de microcontroladores: baixo custo, tempo real, integração fácil em mecatrônica.",
                                    "Liste limitações: desempenho limitado, sem OS complexo.",
                                    "Aplique em cenários: processadores para IA em robôs, controladores para atuadores/sensores."
                                  ],
                                  "verification": "Escreva um parágrafo comparando uso em um sistema mecatrônico integrado com processamento paralelo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de projetos mecatrônicos (ex: Raspberry Pi vs Arduino)",
                                    "Vídeos tutoriais no YouTube",
                                    "Ferramentas de diagramação como Draw.io"
                                  ],
                                  "tips": "Pense em trade-offs para aplicações reais; simule um fluxo de dados híbrido.",
                                  "learningObjective": "Avaliar quando usar cada um em contextos mecatrônicos.",
                                  "commonMistakes": [
                                    "Sobrestimar controladores para tarefas computacionais pesadas",
                                    "Ignorar processamento paralelo em mecatrônica",
                                    "Não considerar integração híbrida"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema mecatrônico de braço robótico integrado, use um microcontrolador (ex: Arduino) para controle em tempo real de servos e sensores via GPIO, enquanto um microprocessador (ex: Raspberry Pi) lida com processamento paralelo de imagens de câmera para detecção de objetos, demonstrando divisão de tarefas por limitações e vantagens.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave sem hesitação.",
                                "Preencher corretamente uma tabela de comparação cegada.",
                                "Identificar o componente adequado para 2 cenários mecatrônicos dados.",
                                "Desenhar diagramas precisos de ambas as arquiteturas.",
                                "Discutir uma aplicação híbrida com processamento paralelo.",
                                "Listar 2 vantagens e 2 limitações de cada um."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na comparação de características (30%)",
                                "Compreensão de vantagens/limitações com exemplos relevantes (25%)",
                                "Aplicação correta em contextos mecatrônicos (20%)",
                                "Uso de terminologia técnica adequada (15%)",
                                "Clareza em diagramas e tabelas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Análise de barramentos e periféricos.",
                                "Programação Embarcada: Desenvolvimento de firmware vs software de alto nível.",
                                "Engenharia de Controle: Tempo real vs processamento paralelo.",
                                "Sistemas Embarcados: Design SoC e integração híbrida.",
                                "Computação: Arquiteturas von Neumann/Harvard e OS."
                              ],
                              "realWorldApplication": "Na automação industrial mecatrônica, microcontroladores gerenciam CLPs para controle de máquinas em tempo real (ex: PLC Siemens), enquanto microprocessadores processam dados paralelos em SCADA para análise preditiva, otimizando produção em fábricas inteligentes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Aplicar microprocessadores em projetos mecatrônicos",
                            "description": "Selecionar e integrar microprocessadores em projetos de sistemas mecatrônicos, considerando clock speed, consumo de energia e interfaces com sensores e atuadores, com exemplos de bibliografia como Lyshevski.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar Requisitos do Projeto Mecatrônico",
                                  "subSteps": [
                                    "Identificar funções principais do sistema mecatrônico, como leitura de sensores e controle de atuadores.",
                                    "Determinar requisitos de performance: clock speed mínima necessária para processamento em tempo real.",
                                    "Avaliar restrições de consumo de energia e fontes de alimentação disponíveis.",
                                    "Listar interfaces requeridas (ex.: GPIO, I2C, SPI, ADC para sensores e PWM para atuadores).",
                                    "Consultar bibliografia como Lyshevski para princípios de seleção em sistemas eletromecânicos."
                                  ],
                                  "verification": "Documento de requisitos completo com tabela de especificações assinada e revisada.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Especificações do projeto",
                                    "Livro 'Electromechanical Systems' de Lyshevski",
                                    "Planilhas de cálculo (Excel ou similar)"
                                  ],
                                  "tips": "Priorize requisitos críticos como tempo de resposta; use matriz de decisão para pesar trade-offs.",
                                  "learningObjective": "Compreender e documentar requisitos funcionais e não-funcionais para integração de microprocessadores.",
                                  "commonMistakes": [
                                    "Subestimar necessidades de clock speed levando a delays",
                                    "Ignorar compatibilidade de tensão com sensores",
                                    "Não considerar dissipação térmica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o Microprocessador Adequado",
                                  "subSteps": [
                                    "Pesquisar opções de microprocessadores (ex.: ARM Cortex-M, AVR) comparando clock speed, consumo e periféricos.",
                                    "Calcular consumo estimado usando datasheets e ferramentas de simulação.",
                                    "Verificar suporte a interfaces necessárias e disponibilidade de bibliotecas.",
                                    "Comparar custo-benefício e escalabilidade para o projeto.",
                                    "Selecionar e justificar com base em critérios quantitativos (ex.: MIPS por watt)."
                                  ],
                                  "verification": "Relatório de seleção com comparação tabular de 3-5 opções e escolha justificada.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Datasheets de microprocessadores (STM32, PIC, etc.)",
                                    "Ferramentas online como DigiKey selector",
                                    "Livro Lyshevski para guidelines teóricos"
                                  ],
                                  "tips": "Use simuladores como Tinkercad para prototipagem rápida de specs.",
                                  "learningObjective": "Avaliar e escolher microprocessadores otimizados para restrições específicas de mecatrônica.",
                                  "commonMistakes": [
                                    "Escolher high-clock sem verificar consumo",
                                    "Ignorar pinagem disponível",
                                    "Não considerar ciclo de vida do componente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar Interfaces com Sensores e Atuadores",
                                  "subSteps": [
                                    "Esquematizar conexões: mapear pinos do microprocessador para sensores (ex.: ADC para temperatura) e atuadores (ex.: PWM para servos).",
                                    "Adicionar circuitos de proteção (pull-ups, filtros, drivers).",
                                    "Simular interfaces usando software como Proteus ou LTSpice.",
                                    "Definir protocolos de comunicação (ex.: I2C para múltiplos sensores).",
                                    "Integrar considerações de Lyshevski sobre modelagem dinâmica de sistemas."
                                  ],
                                  "verification": "Diagrama esquemático completo validado em simulador sem erros.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Software de esquemático (KiCad, Eagle)",
                                    "Componentes de protótipo (breadboard, fios)",
                                    "Datasheets de sensores/atuadores"
                                  ],
                                  "tips": "Sempre inclua capacitores de desacoplamento para estabilidade.",
                                  "learningObjective": "Desenhar interfaces robustas e eficientes entre microprocessador e periféricos mecatrônicos.",
                                  "commonMistakes": [
                                    "Conexões diretas sem drivers para atuadores de alta corrente",
                                    "Ruído não mitigado em sinais analógicos",
                                    "Sobrecarga de barramentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, Programar e Testar a Integração",
                                  "subSteps": [
                                    "Montar protótipo físico com microprocessador, sensores e atuadores.",
                                    "Escrever firmware básico (ex.: em C com loops de leitura/controle).",
                                    "Testar individualmente cada interface e integrar.",
                                    "Otimizar código para clock e energia (ex.: modos sleep).",
                                    "Realizar testes de estresse e validar com métricas de Lyshevski."
                                  ],
                                  "verification": "Protótipo funcional com log de testes mostrando operação estável por 1 hora.",
                                  "estimatedTime": "10 horas",
                                  "materials": [
                                    "Placa de desenvolvimento (ex.: STM32 Nucleo)",
                                    "Programador/debugger",
                                    "Multímetro, osciloscópio",
                                    "IDE como STM32CubeIDE"
                                  ],
                                  "tips": "Use debuggers para inspecionar registradores em tempo real.",
                                  "learningObjective": "Integrar e validar sistema mecatrônico completo com microprocessador.",
                                  "commonMistakes": [
                                    "Loops infinitos sem timeouts",
                                    "Não calibrar sensores",
                                    "Ignorar gerenciamento de interrupções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um carrinho robótico autônomo, selecione um STM32F4 (168MHz, baixo consumo) para ler sensor ultrassônico via ADC, processar dados e controlar motores DC via PWM, otimizando para bateria de 12V com interfaces I2C/SPI.",
                              "finalVerifications": [
                                "Microprocessador opera dentro do clock speed e consumo especificados.",
                                "Todas interfaces respondem corretamente a estímulos (sensores/atuadores).",
                                "Sistema mantém estabilidade térmica e energética por 30 minutos.",
                                "Firmware executa sem crashes em cenários de carga máxima.",
                                "Documentação inclui esquemáticos, código fonte e resultados de testes.",
                                "Integração segue princípios de Lyshevski para dinâmica eletromecânica."
                              ],
                              "assessmentCriteria": [
                                "Adequação da seleção: 30% (clock, energia, interfaces otimizadas).",
                                "Qualidade do design de interfaces: 25% (robustez, simulações validadas).",
                                "Eficiência da implementação: 20% (código otimizado, testes completos).",
                                "Documentação e justificativas: 15% (clareza e referências bibliográficas).",
                                "Inovação e trade-offs considerados: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Design de circuitos e sinalização analógica/digital.",
                                "Programação: Desenvolvimento embedded em C/Assembly.",
                                "Mecânica: Modelagem dinâmica de atuadores conforme Lyshevski.",
                                "Matemática: Cálculos de timing, filtros e controle PID.",
                                "Gestão de Projetos: Análise de requisitos e prototipagem iterativa."
                              ],
                              "realWorldApplication": "Integração em robôs industriais para automação de linhas de montagem, drones para monitoramento agrícola com otimização energética, e dispositivos médicos como próteses controladas por feedback sensorial."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Microcontroladores",
                        "description": "Circuitos integrados que combinam CPU, memória, periféricos de E/S e temporizadores em um único chip, otimizados para controle embarcado em tempo real em sistemas mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Descrever arquitetura e periféricos de microcontroladores",
                            "description": "Explicar a estrutura interna de microcontroladores como Arduino ou PIC, incluindo ADC, PWM, UART e GPIOs, e sua relevância para integração em produtos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Arquitetura Interna Básica de Microcontroladores",
                                  "subSteps": [
                                    "Identificar os componentes principais: CPU, memória (RAM, ROM/Flash, EEPROM) e sistema de clock.",
                                    "Explicar o funcionamento do barramento de dados, endereço e controle.",
                                    "Descrever o pipeline de execução de instruções e o papel do registrador de programa.",
                                    "Comparar arquiteturas de Harvard vs Von Neumann em microcontroladores como Arduino (ATmega) e PIC."
                                  ],
                                  "verification": "Criar um diagrama simples da arquitetura básica e rotulá-lo corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Datasheet do ATmega328 (Arduino Uno)",
                                    "Datasheet do PIC16F",
                                    "Papel e caneta ou software de diagramação como Draw.io"
                                  ],
                                  "tips": [
                                    "Comece pelo diagrama de blocos para visualizar melhor as conexões.",
                                    "Use analogias como 'CPU é o cérebro, memória é a agenda'."
                                  ],
                                  "learningObjective": "Entender os blocos fundamentais e suas interações em um microcontrolador.",
                                  "commonMistakes": [
                                    "Confundir RAM com ROM/Flash",
                                    "Ignorar o impacto do clock na velocidade de processamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Portas GPIO (General Purpose Input/Output)",
                                  "subSteps": [
                                    "Definir GPIOs e modos de operação (input, output, input com pull-up).",
                                    "Explicar configuração via registradores (DDRx, PORTx, PINx no AVR).",
                                    "Discutir limitações como corrente máxima e tensão suportada.",
                                    "Demonstrar alternância de estados com exemplos lógicos."
                                  ],
                                  "verification": "Listar e explicar os registradores de controle para GPIOs em um microcontrolador específico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de código Arduino para blink LED",
                                    "Datasheet seção de I/O ports"
                                  ],
                                  "tips": [
                                    "Sempre verifique o estado inicial dos pinos no reset.",
                                    "Use multímetro para testar configurações reais."
                                  ],
                                  "learningObjective": "Dominar configuração e uso de GPIOs para controle digital básico.",
                                  "commonMistakes": [
                                    "Exceder corrente por pino causando dano",
                                    "Esquecer pull-up em inputs flutuantes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Periféricos Analógicos e PWM",
                                  "subSteps": [
                                    "Descrever ADC: conversor analógico-digital, resolução (10-bit), multiplexador e referência.",
                                    "Explicar PWM: modulação por largura de pulso, registradores OCR e TOP, modos fast/phase correct.",
                                    "Comparar ADC com amostragem e PWM para controle de motores/servos.",
                                    "Calcular duty cycle e frequência PWM para aplicações práticas."
                                  ],
                                  "verification": "Calcular valores para gerar PWM de 50% duty cycle a 1kHz em um pino.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Osciloscópio ou simulador Tinkercad",
                                    "Código exemplo Arduino analogRead() e analogWrite()"
                                  ],
                                  "tips": [
                                    "Use capacitores para filtrar PWM em saídas analógicas.",
                                    "Ajuste AVcc e referência para precisão em ADC."
                                  ],
                                  "learningObjective": "Compreender e aplicar ADC para leitura de sensores e PWM para atuadores.",
                                  "commonMistakes": [
                                    "Não configurar referência ADC corretamente",
                                    "Confundir resolução com precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Interfaces de Comunicação e Integração em Mecatrônica",
                                  "subSteps": [
                                    "Explicar UART: configuração baud rate, registradores UBRR, TX/RX.",
                                    "Introduzir SPI e I2C: mestre/escravo, clock, linhas de dados.",
                                    "Discutir relevância: integração com sensores, displays e CLPs em produtos mecatrônicos.",
                                    "Mapear periféricos a aplicações como automação industrial."
                                  ],
                                  "verification": "Desenhar diagrama de conexão UART entre Arduino e PC, com parâmetros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Módulo USB-serial",
                                    "Exemplos de bibliotecas Serial Arduino",
                                    "Datasheet seções de comunicação"
                                  ],
                                  "tips": [
                                    "Verifique paridade e stop bits para compatibilidade.",
                                    "Use level shifters para 3.3V/5V."
                                  ],
                                  "learningObjective": "Integrar periféricos de comunicação em sistemas mecatrônicos complexos.",
                                  "commonMistakes": [
                                    "Baud rate mismatch causando garbage",
                                    "Pinos errados em SPI/I2C"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Arduino Uno, diagrame a arquitetura ATmega328, configure GPIO pin 13 como output para LED blink, leia ADC no A0 de um potenciômetro, gere PWM no pin 9 para dimmer LED, e envie dados via UART para Serial Monitor exibindo valores lidos.",
                              "finalVerifications": [
                                "Pode desenhar diagrama completo da arquitetura de um microcontrolador como ATmega ou PIC?",
                                "Lista corretamente funções de ADC, PWM, UART e GPIOs?",
                                "Explica registradores chave para cada periférico?",
                                "Identifica limitações elétricas e de configuração?",
                                "Relaciona periféricos a componentes mecatrônicos como sensores e atuadores?",
                                "Calcula parâmetros como duty cycle PWM e baud rate UART?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de componentes arquiteturais (30%)",
                                "Detalhe técnico de periféricos com exemplos (30%)",
                                "Clareza em diagramas e cálculos (20%)",
                                "Relevância para integração mecatrônica (10%)",
                                "Correção de terminologia e conceitos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Configuração de portas e lógica.",
                                "Programação Embarcada: Uso de registradores em C/Arduino.",
                                "Física: Sinais analógicos, PWM e conversão A/D.",
                                "Engenharia de Controle: Aplicação em servomecanismos.",
                                "Automação Industrial: Integração com CLPs e redes."
                              ],
                              "realWorldApplication": "Em produtos mecatrônicos como robôs industriais, o microcontrolador gerencia GPIOs para relés, ADC para sensores de posição/temperatura, PWM para velocidade de motores e UART para comunicação com PLCs em linhas de montagem automotiva."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Programar microcontroladores básicos",
                            "description": "Desenvolver e carregar programas simples em linguagens como C ou Assembly para microcontroladores, controlando LEDs, motores e sensores em protótipos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento para microcontroladores",
                                  "subSteps": [
                                    "Selecionar um microcontrolador básico como Arduino Uno (ATmega328P).",
                                    "Baixar e instalar o Arduino IDE ou Atmel Studio para C/Assembly.",
                                    "Instalar drivers USB e bibliotecas necessárias (ex: Wire, Servo).",
                                    "Conectar o microcontrolador via USB e verificar portas COM no IDE.",
                                    "Executar um sketch de teste 'Blink' fornecido pelo IDE."
                                  ],
                                  "verification": "O sketch Blink compila, carrega e o LED onboard pisca a cada 1 segundo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Arduino Uno ou similar",
                                    "Cabo USB",
                                    "Computador com Arduino IDE instalado"
                                  ],
                                  "tips": "Sempre desconecte shields ou componentes externos durante a configuração inicial para evitar curtos.",
                                  "learningObjective": "Configurar ferramentas e hardware para programação inicial sem erros de comunicação.",
                                  "commonMistakes": [
                                    "Selecionar porta COM errada",
                                    "Drivers USB não instalados",
                                    "Versão incompatível do IDE"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever e carregar programa simples para controle de LED externo",
                                  "subSteps": [
                                    "Montar circuito: LED + resistor 220Ω no pino digital 13.",
                                    "Escrever código em C: setup() para pinMode, loop() para digitalWrite HIGH/LOW com delay.",
                                    "Compilar o código (Ctrl+R no IDE).",
                                    "Carregar o programa no microcontrolador (Ctrl+U).",
                                    "Observar o LED piscando conforme o código."
                                  ],
                                  "verification": "LED externo pisca independentemente do LED onboard, sincronizado com delays no código.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "LED",
                                    "Resistor 220Ω",
                                    "Breadboard",
                                    "Jumpers"
                                  ],
                                  "tips": "Use const int para definir pinos, facilitando mudanças futuras.",
                                  "learningObjective": "Dominar estrutura básica de programas C para microcontroladores e controle de saídas digitais.",
                                  "commonMistakes": [
                                    "Esquecer pinMode OUTPUT",
                                    "Resistor com valor errado causando queima do LED",
                                    "Delay muito curto não visível"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar sensor analógico e lógica condicional",
                                  "subSteps": [
                                    "Conectar sensor LDR + resistor em divisor de tensão no pino A0.",
                                    "Ler valor analógico com analogRead() e mapear para threshold.",
                                    "Adicionar if/else: acender LED se luz baixa (<500).",
                                    "Adicionar Serial.print para debug no monitor serial.",
                                    "Testar variando luz ambiente."
                                  ],
                                  "verification": "LED acende apenas quando sensor detecta baixa luminosidade, confirmado no monitor serial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "LDR",
                                    "Resistor 10kΩ",
                                    "Breadboard adicional"
                                  ],
                                  "tips": "Calibre o threshold empiricamente com Serial.print para valores reais do sensor.",
                                  "learningObjective": "Implementar entrada analógica, condicionais e debug serial em programas embarcados.",
                                  "commonMistakes": [
                                    "Pino analógico usado como digital",
                                    "Falta de pull-down resistor",
                                    "Threshold fixo inadequado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Controlar motor DC com PWM e integrar sistema completo",
                                  "subSteps": [
                                    "Conectar motor DC via driver L298N ou transistor nos pinos PWM 9/10.",
                                    "Implementar analogWrite() para velocidade variável baseada no sensor.",
                                    "Combinar lógica: sensor baixo -> LED on + motor a 50% velocidade.",
                                    "Adicionar debounce ou filtro para sensor instável.",
                                    "Testar sistema integrado com variações de input."
                                  ],
                                  "verification": "Motor gira proporcionalmente à leitura do sensor, LED aceso, sem sobreaquecimento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Motor DC 5V",
                                    "Driver L298N ou MOSFET",
                                    "Bateria 5V",
                                    "Jumpers extras"
                                  ],
                                  "tips": "Use map() para converter analogRead(0-1023) para PWM(0-255) suavemente.",
                                  "learningObjective": "Aplicar PWM para controle analógico de atuadores e integrar múltiplos periféricos.",
                                  "commonMistakes": [
                                    "PWM em pino não-PWM",
                                    "Corrente alta sem driver causando reset",
                                    "Loop sem delay causando overload"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Depurar, otimizar e documentar o protótipo",
                                  "subSteps": [
                                    "Usar Serial monitor e multímetro para identificar falhas.",
                                    "Otimizar código: variáveis voláteis, funções modulares.",
                                    "Adicionar comentários e diagrama Fritzing do circuito.",
                                    "Testar edge cases: sensor saturado, alimentação instável.",
                                    "Salvar projeto e versionar com Git."
                                  ],
                                  "verification": "Sistema roda estável por 10 minutos, código comentado e diagrama disponível.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Multímetro",
                                    "Fritzing software"
                                  ],
                                  "tips": "Sempre isole alimentação do motor da lógica para evitar ruído.",
                                  "learningObjective": "Desenvolver habilidades de debug, otimização e documentação em projetos embarcados.",
                                  "commonMistakes": [
                                    "Ignorar ruído EMI do motor",
                                    "Código spaghetti sem funções",
                                    "Falta de testes extremos"
                                  ]
                                }
                              ],
                              "practicalExample": "Construir um protótipo de 'guarda noturno': sensor LDR detecta escuridão, acende LED de alerta e ativa motor para girar uma hélice de ventilador a velocidade baixa, simulando um sistema de segurança mecatrônico simples.",
                              "finalVerifications": [
                                "Programa compila e carrega sem warnings ou erros.",
                                "LED responde corretamente ao sensor em <1 segundo.",
                                "Motor PWM varia velocidade linearmente com input analógico.",
                                "Sistema integrado opera estável por 15 minutos sem reset.",
                                "Monitor serial mostra leituras e estados em tempo real.",
                                "Circuito não superaquece componentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão e robustez do código (sem bugs lógicos).",
                                "Eficiência energética e temporal (loops otimizados).",
                                "Qualidade da integração hardware-software.",
                                "Documentação clara de código e esquemático.",
                                "Criatividade na expansão além do mínimo.",
                                "Segurança no manuseio de componentes."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Circuitos de sensores e drivers de potência.",
                                "Programação: Estruturas C, loops e funções modulares.",
                                "Física: Divisores de tensão, PWM e conversão analógico-digital.",
                                "Mecânica: Acoplamento de atuadores em protótipos.",
                                "Matemática: Mapeamento linear e calibração de thresholds."
                              ],
                              "realWorldApplication": "Desenvolvimento de robôs autônomos para inspeção industrial, sistemas IoT de monitoramento ambiental (ex: detecção de intrusão com atuadores), ou automação residencial como persianas inteligentes baseadas em luz."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Integrar microcontroladores em sistemas de controle",
                            "description": "Projetar loops de controle com microcontroladores para aplicações mecatrônicas, como feedback PID, utilizando ferramentas de desenvolvimento e simuladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Loops de Controle e PID",
                                  "subSteps": [
                                    "Estudar loops de controle abertos e fechados, identificando diferenças e vantagens do fechado.",
                                    "Analisar componentes do PID: ação proporcional (P), integral (I) e derivativa (D).",
                                    "Estudar equações matemáticas do PID: u(t) = Kp*e(t) + Ki*∫e(t)dt + Kd*de(t)/dt.",
                                    "Explorar tuning de PID (métodos como Ziegler-Nichols).",
                                    "Revisar exemplos de aplicações mecatrônicas, como controle de posição de motores."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o papel de cada termo PID em um diagrama de bloco.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livros de controle automático (ex: Ogata)",
                                    "Vídeos Khan Academy sobre PID",
                                    "Simulador online como PID Tuner do MATLAB"
                                  ],
                                  "tips": "Use analogias cotidianas, como equilibrar uma vassoura na mão para entender P, I e D.",
                                  "learningObjective": "Dominar conceitos teóricos de loops de controle e PID para design de sistemas.",
                                  "commonMistakes": [
                                    "Confundir ações P, I e D",
                                    "Ignorar limites de atuação do controlador",
                                    "Subestimar necessidade de tuning"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Selecionar microcontrolador (ex: Arduino Uno ou STM32) compatível com aplicações mecatrônicas.",
                                    "Instalar IDE (Arduino IDE ou PlatformIO) e bibliotecas PID (ex: PID_v1).",
                                    "Conectar hardware básico: sensor (ex: encoder), atuador (ex: motor DC) e protoboard.",
                                    "Configurar simulação com Tinkercad ou Proteus para testes virtuais.",
                                    "Testar comunicação serial para monitoramento de variáveis."
                                  ],
                                  "verification": "Executar sketch de blink LED e ler sensor analógico, exibindo dados no Serial Monitor.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Arduino Uno",
                                    "Cabos jumper",
                                    "Sensor de temperatura ou encoder",
                                    "Computador com IDE instalada"
                                  ],
                                  "tips": "Sempre verifique pinagens no datasheet para evitar curtos.",
                                  "learningObjective": "Preparar plataforma hardware/software para implementação de controle.",
                                  "commonMistakes": [
                                    "Instalação incorreta de drivers USB",
                                    "Pins errados para PWM",
                                    "Bibliotecas incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Controlador PID em Código",
                                  "subSteps": [
                                    "Ler setpoint, valor atual do processo e calcular erro.",
                                    "Implementar função PID com bibliotecas, definindo Kp, Ki, Kd iniciais.",
                                    "Aplicar saída do PID ao atuador via PWM.",
                                    "Adicionar filtros anti-windup para evitar saturação integral.",
                                    "Estruturar código com loop principal, interrupções para leitura precisa."
                                  ],
                                  "verification": "Compilar e carregar código; observar resposta serial a mudanças de setpoint.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "IDE Arduino",
                                    "Biblioteca PID_v1",
                                    "Motor DC com driver L298N"
                                  ],
                                  "tips": "Comece com Kp baixo para evitar oscilações violentas.",
                                  "learningObjective": "Codificar algoritmo PID funcional em microcontrolador.",
                                  "commonMistakes": [
                                    "Falta de normalização de erro (0-100%)",
                                    "Sem limites na saída",
                                    "Amostragem muito lenta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Simular o Sistema",
                                  "subSteps": [
                                    "Executar testes em simulação: variar setpoint e distúrbios.",
                                    "Medir métricas: tempo de subida, overshoot, erro steady-state.",
                                    "Tune parâmetros PID iterativamente para otimizar performance.",
                                    "Testar hardware real, comparando com simulação.",
                                    "Registrar dados com osciloscópio ou plotter serial."
                                  ],
                                  "verification": "Gráfico de resposta ao degrau mostra estabilidade e precisão (<5% erro).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Simulador Tinkercad",
                                    "Osciloscópio USB ou multímetro",
                                    "Fonte de alimentação"
                                  ],
                                  "tips": "Use setpoint ramp para testar robustez dinâmica.",
                                  "learningObjective": "Validar e otimizar controlador PID em cenários simulados e reais.",
                                  "commonMistakes": [
                                    "Tuning sem distúrbios reais",
                                    "Ignorar ruído no sensor",
                                    "Overshoot excessivo por Kd alto"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar em Sistema Mecatrônico",
                                  "subSteps": [
                                    "Combinar PID com outros módulos (ex: comunicação CAN, PLC).",
                                    "Implementar supervisão: alarmes para falhas, modos manual/auto.",
                                    "Documentar esquema elétrico e fluxograma do software.",
                                    "Realizar testes integrados em protótipo mecatrônico.",
                                    "Preparar para escalabilidade (RTOS se necessário)."
                                  ],
                                  "verification": "Sistema completo mantém controle sob carga variável por 30 minutos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Protoboard completa",
                                    "CLP simulado ou shield",
                                    "Documentação tools (Draw.io)"
                                  ],
                                  "tips": "Modularize código para facilitar debug.",
                                  "learningObjective": "Incorporar PID em sistemas complexos mecatrônicos.",
                                  "commonMistakes": [
                                    "Integração sem isolamento de ruído",
                                    "Falta de redundância em sensores",
                                    "Código monolítico"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver um controlador PID em Arduino para regular a velocidade de um motor DC em um braço robótico, usando encoder como feedback e PWM no driver, simulando em Tinkercad antes do hardware real.",
                              "finalVerifications": [
                                "Sistema atinge setpoint com erro steady-state <2%.",
                                "Resposta ao degrau sem oscilações sustentadas.",
                                "Robustez a distúrbios: recuperação em <5s.",
                                "Monitoramento serial exibe variáveis PID em tempo real.",
                                "Simulação e hardware concordam em >90%.",
                                "Código compila sem warnings e é legível."
                              ],
                              "assessmentCriteria": [
                                "Precisão e estabilidade do controle (métricas quantificáveis).",
                                "Eficiência do código (uso de CPU <70%, memória otimizada).",
                                "Qualidade do tuning PID (overshoot <10%, tempo settling <3s).",
                                "Documentação completa de hardware/software.",
                                "Capacidade de lidar com variações (temperatura, carga).",
                                "Integração segura sem riscos elétricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais e cálculo para modelagem PID.",
                                "Eletrônica: Interfaces de sensores/atuadores e sinalização analógica/digital.",
                                "Programação: Estruturas de controle, interrupções e bibliotecas em C++.",
                                "Física: Dinâmica de sistemas de segunda ordem e leis de Newton.",
                                "Automação Industrial: Integração com CLPs e protocolos como Modbus."
                              ],
                              "realWorldApplication": "Controle de processos industriais como robôs soldadores em linhas automotivas, drones estabilizados por PID em atitude, ou sistemas HVAC em edifícios inteligentes para eficiência energética."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "CLPs (Controladores Lógicos Programáveis)",
                        "description": "Dispositivos industriais programáveis para automação de processos, com linguagens como Ladder Logic, robustos para ambientes mecatrônicos industriais como na aeronáutica.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Entender princípios e linguagens de programação de CLPs",
                            "description": "Identificar linguagens padrão IEC 61131-3 (Ladder, FBD, ST) e princípios de operação de CLPs em controle sequencial e contínuo em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios fundamentais e arquitetura de CLPs",
                                  "subSteps": [
                                    "Estudar a arquitetura básica de um CLP: CPU, módulos de E/S, memória e fontes de alimentação.",
                                    "Explicar o ciclo de scan: leitura de entradas, execução do programa lógico e atualização de saídas.",
                                    "Diferenciar controle sequencial (passos discretos) de controle contínuo (variáveis analógicas).",
                                    "Analisar o papel da memória de imagem de processo (Process Image).",
                                    "Identificar vantagens dos CLPs sobre relés eletromecânicos."
                                  ],
                                  "verification": "Desenhar um diagrama esquemático da arquitetura e ciclo de scan, explicando oralmente cada fase.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de referência IEC 61131-3",
                                    "Vídeos tutoriais sobre CLPs (YouTube ou plataformas educacionais)",
                                    "Simulador gratuito como OpenPLC ou LogixPro"
                                  ],
                                  "tips": "Use analogias com um 'cérebro' industrial para visualizar o ciclo de scan.",
                                  "learningObjective": "Identificar componentes chave e explicar o funcionamento operacional básico de CLPs em contextos mecatrônicos.",
                                  "commonMistakes": [
                                    "Confundir ciclo de scan com execução em tempo real síncrona.",
                                    "Ignorar a importância da memória de imagem na estabilidade do sistema."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a linguagem Ladder Diagram (LD)",
                                  "subSteps": [
                                    "Aprender símbolos básicos: contatos normalmente aberto/fechado, bobinas e rungs.",
                                    "Construir lógicas simples: AND, OR, timers e contadores.",
                                    "Simular um circuito ladder para controle sequencial (ex: motor liga/desliga).",
                                    "Converter diagramas de relés para LD.",
                                    "Identificar limitações da LD para controles complexos."
                                  ],
                                  "verification": "Criar e simular um programa LD simples para acender uma lâmpada com duas condições (AND/OR).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software simulador LD como PLC Fiddle ou Codesys",
                                    "Exemplos de diagramas ladder impressos",
                                    "IEC 61131-3 PDF"
                                  ],
                                  "tips": "Pense em LD como 'fiação virtual' de relés para facilitar a transição de elétrica.",
                                  "learningObjective": "Dominar a representação gráfica de lógica booleana em Ladder para controles discretos.",
                                  "commonMistakes": [
                                    "Esquecer de resetar contadores/timers.",
                                    "Criar loops infinitos em rungs paralelos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Function Block Diagram (FBD)",
                                  "subSteps": [
                                    "Entender blocos funcionais: AND, OR, NOT, timers e blocos PID.",
                                    "Conectar blocos em fluxos lógicos para controles contínuos.",
                                    "Diferenciar FBD de LD: foco em funções modulares vs. sequenciais.",
                                    "Implementar um exemplo de controle PID em FBD.",
                                    "Analisar reutilização de blocos em programas maiores."
                                  ],
                                  "verification": "Montar um diagrama FBD para um comparador de temperatura (controle contínuo).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Simulador Codesys ou TwinCAT",
                                    "Biblioteca de blocos IEC padrão",
                                    "Tutoriais FBD online"
                                  ],
                                  "tips": "Comece com blocos simples e expanda para redes complexas, testando incrementalmente.",
                                  "learningObjective": "Aplicar FBD para modelagem modular de funções em sistemas mecatrônicos.",
                                  "commonMistakes": [
                                    "Conexões incorretas de entradas/saídas múltiplas.",
                                    "Não considerar propagação de sinais em blocos assíncronos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar Structured Text (ST) e aplicações integradas",
                                  "subSteps": [
                                    "Aprender sintaxe ST: similar a Pascal/C (IF, WHILE, CASE, funções).",
                                    "Escrever programas ST para sequências e loops contínuos.",
                                    "Comparar ST com LD/FBD: texto vs. gráfico para complexidade.",
                                    "Implementar controle sequencial (máquina de estados) e contínuo (regulação) em ST.",
                                    "Misturar linguagens em um projeto híbrido."
                                  ],
                                  "verification": "Codificar um programa ST para sequência de 3 etapas e simular.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Editor ST no Codesys",
                                    "Referência sintaxe IEC 61131-3 ST",
                                    "Exemplos de código open-source"
                                  ],
                                  "tips": "Use indentação e comentários para legibilidade, como em programação convencional.",
                                  "learningObjective": "Escrever código textual estruturado para lógicas avançadas em CLPs.",
                                  "commonMistakes": [
                                    "Erros de sintaxe como ponto e vírgula faltante.",
                                    "Variáveis não inicializadas causando falhas lógicas."
                                  ]
                                }
                              ],
                              "practicalExample": "Programar um CLP para controlar uma esteira transportadora mecatrônica: usar LD para sequências de partida/parada (sensores detectam itens), FBD para PID de velocidade (controle contínuo) e ST para lógica de gerenciamento de falhas (if/else para alarmes).",
                              "finalVerifications": [
                                "Explicar verbalmente o ciclo de scan e suas implicações em controles reais.",
                                "Desenhar um rung LD, um bloco FBD e um snippet ST para uma lógica AND/OR.",
                                "Diferenciar aplicações sequenciais vs. contínuas com exemplos.",
                                "Simular um programa híbrido em software e debugar erros intencionais.",
                                "Listar 3 vantagens de cada linguagem IEC 61131-3.",
                                "Identificar quando usar cada linguagem em um sistema mecatrônico."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na descrição de princípios e ciclo de scan (80%+ correto).",
                                "Capacidade de criar diagramas/códigos funcionais sem erros lógicos.",
                                "Compreensão de diferenças entre linguagens e controles sequencial/contínuo.",
                                "Criatividade em exemplos práticos e conexões mecatrônicas.",
                                "Tempo de execução e depuração eficiente nos simuladores.",
                                "Clareza na explicação oral/escrita de verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica digital: lógica de relés e portas lógicas em LD/FBD.",
                                "Programação de computadores: estruturas de controle semelhantes a C/Pascal em ST.",
                                "Engenharia de controle: algoritmos PID e laços de feedback em controles contínuos.",
                                "Mecatrônica integrada: interfaces com sensores/atuadores em sistemas embarcados.",
                                "Segurança industrial: normas IEC para programação confiável."
                              ],
                              "realWorldApplication": "Em indústrias manufatureiras, automotivas e de processos contínuos (ex: linhas de montagem da Petrobras ou fábricas da Embraer), onde CLPs gerenciam automação segura e escalável de máquinas, reduzindo downtime e otimizando produção."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Configurar hardware e comunicação de CLPs",
                            "description": "Configurar módulos de E/S, redes como Profibus ou Ethernet/IP e integração com sensores/atuadores em projetos industriais mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Montar Hardware do CLP e Módulos de E/S",
                                  "subSteps": [
                                    "Identificar requisitos do projeto e selecionar modelo de CLP compatível (ex: Siemens S7-1200 ou Allen-Bradley MicroLogix).",
                                    "Escolher módulos de E/S digitais e analógicas baseados em número de sensores/atuadores necessários.",
                                    "Montar o CLP na trilho DIN, instalando módulos de E/S adjacentes com parafusos de fixação adequados.",
                                    "Conectar alimentação (24V DC) e verificar polaridade com multímetro.",
                                    "Realizar inspeção visual para ausência de curtos ou conexões soltas."
                                  ],
                                  "verification": "CLP e módulos energizados sem LEDs de erro; tensão de alimentação estável medida no bornes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "CLP e módulos de E/S",
                                    "Trilho DIN",
                                    "Fonte 24V DC",
                                    "Multímetro",
                                    "Chaves de fenda"
                                  ],
                                  "tips": "Sempre desligue a alimentação antes de manipular hardware para evitar danos.",
                                  "learningObjective": "Compreender seleção e montagem física segura de componentes de CLP.",
                                  "commonMistakes": [
                                    "Seleção errada de módulos incompatíveis",
                                    "Inversão de polaridade na alimentação",
                                    "Fixação inadequada no trilho DIN"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Módulos de E/S no Software de Programação",
                                  "subSteps": [
                                    "Instalar e abrir software do fabricante (ex: TIA Portal para Siemens ou RSLogix para Rockwell).",
                                    "Criar novo projeto e adicionar hardware do CLP via catálogo online.",
                                    "Configurar endereços I/O para cada módulo (ex: %I0.0 para entrada digital 0).",
                                    "Definir parâmetros como filtros anti-ruído para analógicos e debounce para digitais.",
                                    "Compilar e fazer download da configuração de hardware para o CLP."
                                  ],
                                  "verification": "Download bem-sucedido sem erros de compilação; I/O mapeados corretamente no software.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Computador com software de programação",
                                    "Cabo de programação Ethernet/USB",
                                    "CLP montado"
                                  ],
                                  "tips": "Use o assistente de hardware para detecção automática e evite sobreposição de endereços.",
                                  "learningObjective": "Mapear e parametrizar módulos de E/S logicamente no ambiente de programação.",
                                  "commonMistakes": [
                                    "Endereços duplicados",
                                    "Parâmetros padrão inadequados para ruído industrial",
                                    "Falha no download por cabo incompatível"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Redes de Comunicação (Profibus ou Ethernet/IP)",
                                  "subSteps": [
                                    "Selecionar módulo de comunicação (ex: CM 1241 para Profibus ou EN2T para Ethernet/IP).",
                                    "Instalar fisicamente o módulo no CLP e conectar cabo de rede (blindado para Profibus).",
                                    "No software, adicionar módulo de rede e configurar endereço IP/estação (ex: IP 192.168.0.1).",
                                    "Definir baud rate (ex: 12 Mbps para Profibus) e timeouts; configurar GSD para Profibus.",
                                    "Testar conectividade com ping ou ferramenta de diagnóstico de rede."
                                  ],
                                  "verification": "Comunicação estabelecida: ping responde; status LED verde no módulo de rede.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Módulo de comunicação",
                                    "Cabos de rede Profibus/Ethernet",
                                    "Switch ou hub se necessário",
                                    "Software de configuração"
                                  ],
                                  "tips": "Termine a rede Profibus com resistores de 220Ω nas extremidades para evitar reflexões.",
                                  "learningObjective": "Estabelecer comunicação em rede industrial entre CLP e dispositivos periféricos.",
                                  "commonMistakes": [
                                    "Endereço duplicado na rede",
                                    "Baud rate incompatível com dispositivos",
                                    "Cabos não blindados em ambiente ruidoso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Sensores/Atuadores e Realizar Testes Iniciais",
                                  "subSteps": [
                                    "Conectar sensores (ex: indutivo NPN) e atuadores (ex: relé ou motor) aos terminais de E/S.",
                                    "Criar programa simples de teste (ex: lógica para piscar saída com entrada).",
                                    "Fazer download do programa e monitorar variáveis online no software.",
                                    "Testar entradas/saídas individualmente com simulador ou hardware real.",
                                    "Diagnosticar erros via LEDs ou software e ajustar configurações."
                                  ],
                                  "verification": "Sensores detectados corretamente; atuadores respondem a comandos do CLP sem falhas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Sensores e atuadores",
                                    "Cabos de conexão",
                                    "Programa de teste simples"
                                  ],
                                  "tips": "Use força de E/S no software para testes isolados antes de energizar campo.",
                                  "learningObjective": "Integrar e validar sistema completo de hardware e comunicação.",
                                  "commonMistakes": [
                                    "Conexões erradas de sensores (PNP vs NPN)",
                                    "Sobrecarga de saídas sem proteção",
                                    "Ignorar diagnósticos de erro"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de garrafas PET, configure um CLP Siemens S7-1200 com módulo SM 1223 para 8 entradas digitais conectadas a sensores de presença, módulo de Profibus para comunicação com inversor de frequência (atuador motor), testando a detecção de garrafa e acionamento do motor via rede.",
                              "finalVerifications": [
                                "CLP e módulos sem LEDs de erro após energização completa.",
                                "Todos I/O respondem corretamente em testes forçados.",
                                "Comunicação de rede ativa com taxa de dados estável.",
                                "Integração de sensores/atuadores sem falsos disparos.",
                                "Download de programa e configuração sem warnings.",
                                "Backup da configuração salvo no software."
                              ],
                              "assessmentCriteria": [
                                "Precisão na montagem física e conexões elétricas (sem curtos).",
                                "Mapeamento correto de endereços I/O e rede.",
                                "Configurações otimizadas para ambiente industrial (filtros, timeouts).",
                                "Testes abrangentes com diagnósticos resolvidos.",
                                "Documentação de configuração e testes realizada.",
                                "Tempo de execução dentro do estimado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Conhecimentos de sinais analógicos/digitais e proteção de circuitos.",
                                "Programação: Lógica ladder e monitoramento online.",
                                "Redes Industriais: Protocolos como Modbus ou Profinet.",
                                "Mecânica: Integração com atuadores pneumáticos/hidráulicos.",
                                "Segurança do Trabalho: Normas NR-10 e NR-12 para automação."
                              ],
                              "realWorldApplication": "Em fábricas de automação industrial, como linhas de produção automotiva ou embalagem, onde CLPs configurados controlam robôs, esteiras e sensores para operação 24/7 eficiente e segura, reduzindo downtime e custos de manutenção."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Aplicar CLPs em automação mecatrônica",
                            "description": "Elaborar programas para CLPs em cenários reais, como linhas de montagem aeronáutica, considerando segurança, redundância e manutenção, alinhado à bibliografia de Shetty e Kolk.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise de Requisitos e Planejamento do Sistema",
                                  "subSteps": [
                                    "Identificar entradas (sensores, botões) e saídas (motores, válvulas) do cenário real, como linha de montagem aeronáutica.",
                                    "Definir lógica de controle principal, incluindo sequências de operação e condições de parada de emergência.",
                                    "Mapear requisitos de segurança (ex: redundância em sensores críticos) e manutenção, consultando Shetty e Kolk (Cap. 8-9).",
                                    "Elaborar diagrama de blocos e fluxograma da lógica do CLP.",
                                    "Estimar ciclos de operação e tempos de resposta necessários."
                                  ],
                                  "verification": "Fluxograma e lista de I/O aprovados por revisão pares ou simulador.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro Shetty e Kolk",
                                    "Software de diagramação (Draw.io)",
                                    "Especificações do cenário aeronáutico"
                                  ],
                                  "tips": "Priorize falhas catastróficas; use FMEA (Failure Mode and Effects Analysis) para riscos.",
                                  "learningObjective": "Compreender e documentar requisitos funcionais e de segurança para automação mecatrônica.",
                                  "commonMistakes": [
                                    "Ignorar redundância em sensores de segurança",
                                    "Subestimar tempos de ciclo",
                                    "Não consultar bibliografia para padrões industriais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolvimento do Programa CLP",
                                  "subSteps": [
                                    "Configurar ambiente de programação (ex: Ladder Logic no TIA Portal ou RSLogix).",
                                    "Implementar blocos lógicos básicos: timers, contadores e comparações para sequências.",
                                    "Adicionar funções de segurança: watchdog timers, redundância lógica e intertravamentos.",
                                    "Incorporar rotinas de manutenção: diagnósticos de falhas e logs de eventos, per Shetty e Kolk.",
                                    "Otimizar código para eficiência, reduzindo scan time."
                                  ],
                                  "verification": "Compilação sem erros e simulação inicial de lógica em software.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Software CLP (Siemens TIA Portal ou Allen-Bradley)",
                                    "Livro Shetty e Kolk",
                                    "Hardware simulado virtual"
                                  ],
                                  "tips": "Use blocos funcionais modulares para reutilização em cenários semelhantes.",
                                  "learningObjective": "Elaborar programas CLP robustos com ênfase em segurança e redundância.",
                                  "commonMistakes": [
                                    "Excesso de lógica em um rung só",
                                    "Falta de comentários no código",
                                    "Não testar edge cases como falhas simultâneas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simulação, Testes e Depuração",
                                  "subSteps": [
                                    "Carregar programa no simulador CLP e testar cenários nominais.",
                                    "Simular falhas: perda de sensor, sobrecarga de motor, paradas de emergência.",
                                    "Verificar redundância: alternar sensores backup e confirmar continuidade.",
                                    "Analisar scan time e corrigir loops infinitos ou delays excessivos.",
                                    "Documentar resultados de testes em relatório com capturas de tela."
                                  ],
                                  "verification": "100% de cobertura de testes em cenários críticos, sem falhas não tratadas.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Simulador CLP integrado (PLCSIM)",
                                    "Lista de cenários de teste",
                                    "Osciloscópio virtual"
                                  ],
                                  "tips": "Registre todos os forcing de I/O para reprodutibilidade.",
                                  "learningObjective": "Validar programa CLP em ambiente simulado, identificando e corrigindo defeitos.",
                                  "commonMistakes": [
                                    "Testar apenas fluxo feliz",
                                    "Ignorar latência de rede em simulações",
                                    "Não validar contra especificações iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementação em Hardware, Validação Final e Manutenção",
                                  "subSteps": [
                                    "Conectar CLP físico à linha de montagem simulada ou real (ex: esteira aeronáutica).",
                                    "Executar testes em campo com cargas reais, monitorando segurança.",
                                    "Configurar HMI para monitoramento e manutenção remota.",
                                    "Treinar operadores em procedimentos de manutenção e reset de falhas.",
                                    "Gerar manual de operação e plano de manutenção preditiva."
                                  ],
                                  "verification": "Sistema operacional 24h sem falhas, com relatório de validação assinado.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "CLP físico (Siemens S7-1200)",
                                    "Sensores/motores de teste",
                                    "HMI touch panel"
                                  ],
                                  "tips": "Sempre isole energias antes de conexões; use lockout/tagout.",
                                  "learningObjective": "Integrar e manter sistemas CLP em automação mecatrônica real.",
                                  "commonMistakes": [
                                    "Conexões erradas de I/O",
                                    "Falta de calibração de sensores",
                                    "Não planejar atualizações futuras"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de fuselagens aeronáuticas, programe um CLP para controlar esteiras: sensores detectam peça, motor avança; se sensor de peso falhar, redundância para e ativa alarme; manutenção via HMI mostra último erro.",
                              "finalVerifications": [
                                "Programa compila e executa sem erros em hardware real.",
                                "Todas as redundâncias e seguranças ativam corretamente em simulações de falha.",
                                "Scan time abaixo de 50ms em operação plena.",
                                "Documentação completa com fluxogramas, código comentado e manual de manutenção.",
                                "Testes de campo confirmam alinhamento com requisitos aeronáuticos.",
                                "HMI exibe diagnósticos claros para operadores."
                              ],
                              "assessmentCriteria": [
                                "Precisão da lógica de controle (90%+ cobertura de cenários).",
                                "Implementação robusta de segurança e redundância (zero falhas críticas).",
                                "Eficiência: scan time otimizado e código modular.",
                                "Qualidade da documentação e usabilidade da HMI.",
                                "Alinhamento com bibliografia Shetty e Kolk (citações explícitas).",
                                "Capacidade de manutenção: tempo médio de diagnóstico <5min."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Integração de sensores e atuadores.",
                                "Programação de Sistemas Embarcados: Lógica ladder vs. linguagens textuais.",
                                "Gestão de Projetos Industriais: Ciclo PDCA em automação.",
                                "Segurança do Trabalho: Normas NR-12 e ISO 13849.",
                                "Manutenção Preditiva: Integração com IoT e dados analíticos."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica (ex: Embraer), CLPs controlam linhas de montagem automatizadas, garantindo precisão em soldas e montagens, reduzindo downtime em 30% via redundância e diagnósticos rápidos, conforme casos em Shetty e Kolk."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.6",
                    "name": "Elaboração e Execução de Projetos Mecatrônicos",
                    "description": "Processos para planejar, desenvolver e implementar projetos de sistemas mecatrônicos e microcontrolados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.6.1",
                        "name": "Planejamento de Projetos Mecatrônicos",
                        "description": "Processos iniciais para definir objetivos, escopo, requisitos funcionais e formação de equipes multifuncionais em projetos de sistemas mecatrônicos e microcontrolados, utilizando técnicas de design engineering conforme bibliografia de Cross (2004).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.1.1",
                            "name": "Identificar e especificar requisitos do sistema",
                            "description": "Analisar necessidades do cliente e funcionais do sistema mecatrônico, incluindo interfaces homem-máquina, sensores e atuadores, para elaborar um documento de especificação claro e completo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e analisar necessidades do cliente",
                                  "subSteps": [
                                    "Preparar um questionário estruturado com perguntas abertas e fechadas sobre objetivos, restrições e expectativas.",
                                    "Realizar entrevistas ou reuniões com stakeholders para capturar requisitos iniciais.",
                                    "Registrar todas as informações verbalmente e documentar em notas ou gravações.",
                                    "Analisar as respostas para identificar necessidades explícitas e implícitas.",
                                    "Categorizar requisitos em funcionais, não-funcionais, de desempenho e de usabilidade."
                                  ],
                                  "verification": "Produzir um relatório preliminar de requisitos do cliente com pelo menos 10 itens categorizados.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Questionário template (Google Forms ou Word), gravador de áudio, software de anotações (Notion ou Excel)",
                                  "tips": "Use a técnica 5W2H (What, Why, Where, When, Who, How, How much) para guiar as perguntas.",
                                  "learningObjective": "Desenvolver habilidades de elicitação de requisitos para capturar necessidades reais do cliente.",
                                  "commonMistakes": "Ignorar requisitos implícitos ou fazer suposições sem validação com o cliente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir requisitos funcionais do sistema mecatrônico",
                                  "subSteps": [
                                    "Mapear fluxos de operação do sistema com base nas necessidades do cliente.",
                                    "Especificar funções principais, como controle de processos, monitoramento e segurança.",
                                    "Identificar interfaces homem-máquina (HMI), incluindo telas, botões e feedback visual/sonoro.",
                                    "Listar entradas (sensores) e saídas (atuadores) necessários para cada função.",
                                    "Priorizar requisitos usando MoSCoW (Must, Should, Could, Won't)."
                                  ],
                                  "verification": "Criar uma tabela de requisitos funcionais com colunas para ID, descrição, prioridade e rastreabilidade.",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "Ferramentas de modelagem como Draw.io para diagramas de fluxo, planilha Excel para tabela de requisitos",
                                  "tips": "Desenhe diagramas de caso de uso para visualizar interações.",
                                  "learningObjective": "Transformar necessidades do cliente em requisitos funcionais claros e rastreáveis.",
                                  "commonMistakes": "Misturar requisitos funcionais com não-funcionais ou omitir cenários de falha."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar componentes e subsistemas",
                                  "subSteps": [
                                    "Selecionar sensores adequados (ex: proximity, temperatura, força) com base nos requisitos de entrada.",
                                    "Definir atuadores (ex: motores, válvulas, servos) considerando potência, precisão e integração.",
                                    "Detalhar HMI: tipo de display, software de interface e protocolos de comunicação.",
                                    "Especificar requisitos de integração, como protocolos (Modbus, CAN) e alimentação elétrica.",
                                    "Verificar compatibilidade e estimar custos preliminares."
                                  ],
                                  "verification": "Gerar uma lista de componentes com especificações técnicas e justificativas.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "Catálogos de sensores/atuadores (online: DigiKey, Farnell), software de simulação básica (Tinkercad)",
                                  "tips": "Considere margens de segurança (ex: +20% em sensores para variações ambientais).",
                                  "learningObjective": "Associar requisitos a componentes mecatrônicos específicos de forma técnica.",
                                  "commonMistakes": "Escolher componentes sem considerar integração ou ambiente operacional."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Elaborar e validar o documento de especificação",
                                  "subSteps": [
                                    "Compilar todos os requisitos em um documento estruturado (SRS - System Requirements Specification).",
                                    "Incluir glossário, diagramas, tabelas e traceabilidade matrix.",
                                    "Revisar o documento internamente para completude e clareza.",
                                    "Compartilhar com o cliente para feedback e iterações.",
                                    "Incorporar revisões e finalizar a versão aprovada."
                                  ],
                                  "verification": "Documento final aprovado pelo cliente com assinatura ou e-mail de aceite.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Template de SRS (LaTeX ou Word), ferramentas de versionamento (Google Docs)",
                                  "tips": "Use numeração hierárquica para requisitos (ex: REQ-1.1) para fácil referência.",
                                  "learningObjective": "Produzir um documento profissional de especificação pronto para projeto.",
                                  "commonMistakes": "Omitir seções como riscos, suposições ou critérios de aceitação."
                                }
                              ],
                              "practicalExample": "Para um sistema mecatrônico de triagem de frutas em uma agroindústria, identificar requisitos como sensor óptico para cor/tamanho (função: classificar), atuador pneumático para rejeição (saída), HMI touch para configuração de limites pelo operador, e especificar no documento: 'O sistema deve detectar frutas <5cm com precisão 95% via câmera CCD'.",
                              "finalVerifications": [
                                "Todos os requisitos do cliente estão mapeados e priorizados no documento.",
                                "Especificações de sensores, atuadores e HMI incluem parâmetros técnicos (faixa, precisão, interface).",
                                "Documentos incluem diagramas de fluxo e matriz de rastreabilidade.",
                                "Cliente confirmou completude via feedback escrito.",
                                "Não há ambiguidades ou termos não definidos no glossário.",
                                "Requisitos de segurança e não-funcionais (ex: tempo de resposta <1s) estão explícitos."
                              ],
                              "assessmentCriteria": [
                                "Completude: Cobertura de 100% das necessidades identificadas.",
                                "Clareza: Linguagem precisa, sem ambiguidades, com exemplos.",
                                "Rastreabilidade: Cada requisito ligado a uma fonte (cliente ou análise).",
                                "Tecnicidade: Especificações realistas e viáveis para mecatrônica.",
                                "Estrutura: Documento segue padrão SRS com seções padronizadas.",
                                "Validação: Evidência de revisão e aprovação."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Técnicas de elicitação e modelagem de requisitos (UML).",
                                "Gestão de Projetos: Priorização MoSCoW e planejamento de escopo.",
                                "Ergonomia e Design de Interfaces: Princípios de HMI user-centered.",
                                "Eletrônica Industrial: Seleção de sensores e protocolos de comunicação."
                              ],
                              "realWorldApplication": "Na indústria automotiva, especificar requisitos para um sistema de montagem robótica, definindo sensores de visão para alinhamento de peças, atuadores para fixação e HMI para monitoramento em tempo real, resultando em um documento que guia o desenvolvimento e reduz retrabalho em 30%."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.2",
                            "name": "Formar e gerenciar equipes multifuncionais",
                            "description": "Selecionar e coordenar profissionais de mecânica, eletrônica, software e controle para times integrados, promovendo colaboração no desenvolvimento integrado de produtos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar necessidades e perfis requeridos para a equipe multifuncional",
                                  "subSteps": [
                                    "Analisar o escopo do projeto mecatrônico, identificando fases de design, prototipagem e testes",
                                    "Mapear competências essenciais: mecânica (estruturas e atuadores), eletrônica (circuitos e sensores), software (programação embarcada) e controle (algoritmos PID)",
                                    "Definir quantidade de membros por perfil e níveis de experiência (júnior, pleno, sênior)",
                                    "Criar descrições detalhadas de cada perfil, incluindo responsabilidades e habilidades técnicas/soft skills",
                                    "Priorizar perfis críticos e considerar redundâncias para resiliência da equipe"
                                  ],
                                  "verification": "Documento de 'Matriz de Necessidades da Equipe' elaborado, revisado e aprovado pelo gestor do projeto",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Escopo do projeto",
                                    "Matriz de competências mecatrônicas",
                                    "Templates de perfis profissionais",
                                    "Ferramentas como Excel ou Miro para mapeamento"
                                  ],
                                  "tips": "Integre soft skills como comunicação e adaptabilidade desde o início para promover colaboração",
                                  "learningObjective": "Mapear com precisão as competências multifuncionais necessárias para o sucesso do desenvolvimento integrado",
                                  "commonMistakes": [
                                    "Subestimar a interdependência entre áreas técnicas",
                                    "Ignorar perfis de suporte como integração de sistemas",
                                    "Definir perfis genéricos sem alinhamento ao projeto específico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recrutar e selecionar membros da equipe",
                                  "subSteps": [
                                    "Divulgar vagas internas/externas via plataformas como LinkedIn, sites corporativos ou redes profissionais",
                                    "Realizar triagem de currículos com foco em experiências mecatrônicas integradas",
                                    "Conduzir entrevistas técnicas e comportamentais, com testes práticos (ex: simulação de integração mecatrônica)",
                                    "Avaliar fit cultural e técnico usando matriz de pontuação",
                                    "Negociar e formalizar contratações ou alocações internas"
                                  ],
                                  "verification": "Lista de candidatos selecionados aprovada, com contratos ou alocações assinados",
                                  "estimatedTime": "3-5 dias",
                                  "materials": [
                                    "Anúncios de vagas",
                                    "Ferramentas de recrutamento (LinkedIn, Google Forms)",
                                    "Questionários técnicos mecatrônicos",
                                    "Matriz de avaliação de candidatos"
                                  ],
                                  "tips": "Inclua dinâmicas de grupo nas entrevistas para testar colaboração multifuncional desde cedo",
                                  "learningObjective": "Selecionar profissionais alinhados às necessidades técnicas e colaborativas do projeto",
                                  "commonMistakes": [
                                    "Priorizar apenas expertise técnica sem avaliar trabalho em equipe",
                                    "Apressar seleções sem validação prática",
                                    "Não diversificar fontes de recrutamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar a equipe e definir papéis e responsabilidades",
                                  "subSteps": [
                                    "Realizar reunião de kick-off para apresentação e icebreaker",
                                    "Atribuir papéis claros usando RACI (Responsible, Accountable, Consulted, Informed)",
                                    "Definir estrutura organizacional (ex: líder mecatrônico com subequipes por área)",
                                    "Estabelecer normas de colaboração, ferramentas compartilhadas (Git, Jira) e cronograma integrado",
                                    "Documentar organograma e plano de integração"
                                  ],
                                  "verification": "Organograma e plano de papéis distribuídos e assinados por todos os membros",
                                  "estimatedTime": "1 dia",
                                  "materials": [
                                    "Templates RACI",
                                    "Ferramentas colaborativas (Microsoft Teams, Jira)",
                                    "Organograma editável",
                                    "Cronograma do projeto"
                                  ],
                                  "tips": "Promova rotação de papéis em fases iniciais para fomentar entendimento interdisciplinar",
                                  "learningObjective": "Estruturar uma equipe coesa com papéis definidos para integração eficiente",
                                  "commonMistakes": [
                                    "Papéis sobrepostos causando conflitos",
                                    "Falta de clareza em responsabilidades integradas",
                                    "Ignorar feedback inicial dos membros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar a equipe, promovendo colaboração e resolução de conflitos",
                                  "subSteps": [
                                    "Implementar reuniões diárias/stand-ups e revisões semanais multifuncionais",
                                    "Monitorar progresso com KPIs de integração (ex: milestones de protótipo funcional)",
                                    "Facilitar comunicação via canais dedicados e treinamentos cross-training",
                                    "Identificar e resolver conflitos usando técnicas de mediação",
                                    "Avaliar desempenho periódico e ajustar equipe conforme necessário"
                                  ],
                                  "verification": "Relatório mensal de desempenho da equipe com métricas de colaboração e ajustes implementados",
                                  "estimatedTime": "Contínuo, 1-2 horas/semana",
                                  "materials": [
                                    "Ferramentas de gestão (Jira, Trello)",
                                    "Modelos de reuniões stand-up",
                                    "Guia de resolução de conflitos",
                                    "Dashboards de KPIs"
                                  ],
                                  "tips": "Use retrospectives ágeis para capturar lições aprendidas em tempo real",
                                  "learningObjective": "Manter alta performance e colaboração em equipes multifuncionais ao longo do projeto",
                                  "commonMistakes": [
                                    "Falta de reuniões regulares levando a silos departamentais",
                                    "Ignorar sinais precoces de conflitos",
                                    "Não ajustar equipe dinamicamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o desenvolvimento de um braço robótico mecatrônico em uma linha de montagem automotiva: selecione 1 engenheiro mecânico para design de juntas, 1 eletricista para sensores e atuadores, 1 desenvolvedor de software para controle embarcado e 1 especialista em controle para algoritmos de trajetória; coordene reuniões semanais para integração, resultando em protótipo funcional testado.",
                              "finalVerifications": [
                                "Equipe completa com todos os perfis mecatrônicos essenciais alocados",
                                "Organograma e RACI validados por todos os membros",
                                "Primeiro milestone de integração (ex: sub-sistema funcional) alcançado",
                                "Relatório inicial de colaboração sem conflitos graves",
                                "Ferramentas de comunicação e tracking configuradas e em uso",
                                "Treinamento cross-area realizado com participação total"
                              ],
                              "assessmentCriteria": [
                                "Diversidade e adequação dos perfis técnicos às demandas do projeto (nota 1-10)",
                                "Clareza e aceitação dos papéis e responsabilidades (feedback qualitativo)",
                                "Nível de colaboração demonstrado em reuniões e entregas integradas",
                                "Eficiência na resolução de conflitos e ajustes de equipe",
                                "Cumprimento de prazos iniciais de formação e integração",
                                "Métricas de engajamento (participação em stand-ups >90%)"
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos (PMBOK - gerenciamento de recursos humanos)",
                                "Liderança e Desenvolvimento de Equipes (soft skills interdisciplinares)",
                                "Comunicação Organizacional (engenharia de produção)",
                                "Recursos Humanos (seleção e desenvolvimento de talentos técnicos)"
                              ],
                              "realWorldApplication": "Na indústria automotiva, como na montagem de linhas robóticas da Volkswagen ou Tesla, equipes multifuncionais integram mecânica para chassis, eletrônica para visão computacional, software para IA e controle para precisão, acelerando o time-to-market de produtos inovadores e reduzindo custos de retrabalho em até 30%."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.3",
                            "name": "Elaborar cronograma e orçamento do projeto",
                            "description": "Utilizar métodos como Gantt e PERT para planejar fases, alocar recursos e estimar custos, considerando riscos em projetos mecatrônicos com microcontroladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Escopo do Projeto e Criar a Estrutura de Decomposição do Trabalho (WBS)",
                                  "subSteps": [
                                    "Identificar os objetivos principais do projeto mecatrônico, como integração de microcontrolador em um sistema de controle.",
                                    "Listar todas as fases principais: design, prototipagem, testes e implementação.",
                                    "Decompor cada fase em tarefas específicas e subtarefas acionáveis, usando hierarquia.",
                                    "Definir dependências entre tarefas e entregáveis esperados.",
                                    "Documentar premissas e restrições iniciais do projeto."
                                  ],
                                  "verification": "Verificar se a WBS está completa, com pelo menos 20-30 tarefas hierarquizadas e dependências mapeadas em um diagrama.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de diagramação (Draw.io ou MS Visio)",
                                    "Planilha Excel ou Google Sheets",
                                    "Descrição do projeto mecatrônico"
                                  ],
                                  "tips": "Comece pelos entregáveis finais e trabalhe retroativamente para identificar tarefas upstream.",
                                  "learningObjective": "Dominar a decomposição de projetos complexos em componentes gerenciáveis para planejamento preciso.",
                                  "commonMistakes": [
                                    "Omitir tarefas de integração de hardware/software.",
                                    "Criar tarefas vagas sem critérios de conclusão.",
                                    "Ignorar dependências críticas entre microcontrolador e atuadores."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver o Cronograma Utilizando Diagramas de Gantt e PERT",
                                  "subSteps": [
                                    "Estimar durações otimista, mais provável e pessimista para cada tarefa usando método PERT.",
                                    "Calcular tempos esperados com fórmula PERT: (O + 4M + P)/6.",
                                    "Construir diagrama de Gantt com barras representando tarefas, dependências e marcos.",
                                    "Identificar caminho crítico usando PERT e ajustar folgas.",
                                    "Definir datas de início/fim do projeto e alocar responsáveis."
                                  ],
                                  "verification": "Cronograma visualizado em Gantt/PERT com caminho crítico destacado e folgas calculadas corretamente.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Software de gerenciamento de projetos (MS Project, GanttProject ou Trello)",
                                    "Calculadora ou Excel para PERT"
                                  ],
                                  "tips": "Use cores diferentes para tipos de tarefas (ex: azul para software, vermelho para hardware) para visualização rápida.",
                                  "learningObjective": "Aplicar técnicas Gantt e PERT para sequenciar tarefas e prever atrasos em projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Subestimar tempos de debug de microcontroladores.",
                                    "Não considerar fins de semana ou feriados.",
                                    "Confundir dependências FS (Finish-Start) com SS (Start-Start)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Elaborar o Orçamento: Estimar e Alocar Recursos e Custos",
                                  "subSteps": [
                                    "Listar recursos necessários: materiais (microcontroladores, sensores), mão de obra e ferramentas.",
                                    "Estimar custos unitários e totais por tarefa, somando para orçamento baseline.",
                                    "Aplicar fatores de contingência (10-20%) para imprevistos.",
                                    "Criar tabela de alocação de recursos com curvas de uso ao longo do tempo.",
                                    "Balancear orçamento total com restrições financeiras do projeto."
                                  ],
                                  "verification": "Orçamento detalhado em planilha com totais, contingências e gráfico de fluxo de caixa simples.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Planilhas Excel/Google Sheets",
                                    "Catálogos de fornecedores (ex: Arduino, sensores)",
                                    "Modelos de orçamento de projetos"
                                  ],
                                  "tips": "Pesquise preços reais online para microcontroladores e componentes para estimativas realistas.",
                                  "learningObjective": "Desenvolver habilidades em estimativa de custos e alocação de recursos para viabilidade financeira.",
                                  "commonMistakes": [
                                    "Esquecer custos indiretos como energia ou licenças de software.",
                                    "Não escalonar compras para evitar picos de caixa.",
                                    "Superestimar mão de obra sem considerar multitarefas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Riscos, Planejar Contingências e Finalizar o Plano Integrado",
                                  "subSteps": [
                                    "Realizar análise de riscos: brainstorm de riscos técnicos (falhas em microcontroladores), de cronograma e custos.",
                                    "Avaliar probabilidade e impacto de cada risco em matriz qualitativa/quantitativa.",
                                    "Definir estratégias de mitigação, transferência ou aceitação, com planos de contingência.",
                                    "Integrar riscos ao cronograma e orçamento (reservas de tempo/custo).",
                                    "Revisar o plano completo com checklist e simular cenários what-if."
                                  ],
                                  "verification": "Matriz de riscos completa com pelo menos 10 riscos priorizados e plano integrado atualizado.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Matriz de riscos em Excel",
                                    "Ferramentas de simulação (Monte Carlo básico via Excel)"
                                  ],
                                  "tips": "Priorize riscos com score alto (probabilidade x impacto) e atribua donos para monitoramento.",
                                  "learningObjective": "Incorporar gerenciamento de riscos proativamente em planos de projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Focar só em riscos técnicos, ignorando humanos/externos.",
                                    "Reservas de contingência muito baixas (<10%).",
                                    "Não documentar triggers para ativação de contingências."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Revisar, Validar e Documentar o Cronograma e Orçamento Final",
                                  "subSteps": [
                                    "Comparar plano com padrões PMBOK adaptados para mecatrônica.",
                                    "Solicitar feedback de pares ou mentor sobre realismo.",
                                    "Gerar relatórios executivos: resumo Gantt, orçamento e riscos.",
                                    "Definir baselines para controle futuro (Earned Value).",
                                    "Preparar apresentação do plano para stakeholders."
                                  ],
                                  "verification": "Documento final aprovado com baselines fixadas e relatório de 1-2 páginas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Templates de relatórios PM",
                                    "Ferramenta de apresentação (PowerPoint/Google Slides)"
                                  ],
                                  "tips": "Use métricas como CPI/SPI para validação inicial de viabilidade.",
                                  "learningObjective": "Garantir qualidade e comunicabilidade do plano de projeto.",
                                  "commonMistakes": [
                                    "Não fixar baselines, permitindo mudanças creep.",
                                    "Relatórios muito técnicos sem resumo executivo.",
                                    "Pular validação externa."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de braço robótico controlado por ESP32: WBS divide em design CAD (semana 1), montagem hardware (2), programação firmware (3), testes (4). Gantt mostra dependência montagem->programação; orçamento: R$500 sensores + R$200 ESP32 + 40h mão de obra @R$50/h = R$2.500 total +15% contingência. Riscos: falha solda (mitigação: testes proto).",
                              "finalVerifications": [
                                "Cronograma cobre 100% das tarefas da WBS com caminho crítico claro.",
                                "Orçamento total não excede limite projeto em >20% sem contingência.",
                                "Matriz de riscos tem estratégias para top 5 riscos.",
                                "Dependências e folgas calculadas corretamente em Gantt/PERT.",
                                "Plano inclui baselines para monitoramento futuro.",
                                "Relatório executivo resume plano em 1 página."
                              ],
                              "assessmentCriteria": [
                                "Precisão e realismo das estimativas de tempo/custo (erro <15%).",
                                "Cobertura completa de fases mecatrônicas (hardware, software, integração).",
                                "Uso correto de Gantt/PERT com cálculos matemáticos validados.",
                                "Profundidade da análise de riscos (quantitativa onde possível).",
                                "Clareza e profissionalismo da documentação/visualizações.",
                                "Integração coerente entre cronograma, orçamento e riscos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos probabilísticos PERT e análise de caminho crítico.",
                                "Gestão Empresarial: Princípios de PMBOK e controle de Earned Value.",
                                "Eletrônica: Estimativa de recursos para microcontroladores e componentes.",
                                "Programação: Alocação de tempo para debug e integração de firmware.",
                                "Sustentabilidade: Inclusão de custos ambientais em orçamento."
                              ],
                              "realWorldApplication": "Em indústrias como automotiva (ex: Bosch) ou robótica (ex: projetos IoT), engenheiros mecatrônicos usam cronogramas Gantt/PERT e orçamentos detalhados para entregar sistemas com microcontroladores no prazo, evitando overruns de 30-50% comuns em projetos sem planejamento rigoroso."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.2",
                        "name": "Desenvolvimento de Sistemas Mecatrônicos",
                        "description": "Fases de design conceitual, detalhado e prototipagem, integrando microprocessadores, microcontroladores, CLPs e tecnologias como visão por computador, conforme Shetty e Kolk (1997).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.2.1",
                            "name": "Projetar arquitetura integrada do sistema",
                            "description": "Definir estrutura hardware-software com microcontroladores (ex: Arduino, STM32), sensores e atuadores, garantindo compatibilidade eletromecânica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise de Requisitos do Sistema",
                                  "subSteps": [
                                    "Identificar funções principais do sistema mecatrônico.",
                                    "Listar entradas (sensores) e saídas (atuadores) necessárias.",
                                    "Definir restrições de desempenho, energia e ambiente.",
                                    "Especificar interfaces de comunicação (ex: I2C, SPI).",
                                    "Documentar requisitos em um diagrama de casos de uso."
                                  ],
                                  "verification": "Verificar se o documento de requisitos cobre todos os aspectos funcionais e não-funcionais com exemplos concretos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Folha de papel ou software de diagramação (ex: Draw.io)",
                                    "Lista de requisitos do projeto"
                                  ],
                                  "tips": "Priorize requisitos críticos usando MoSCoW (Must, Should, Could, Won't).",
                                  "learningObjective": "Compreender e documentar requisitos para guiar o design da arquitetura.",
                                  "commonMistakes": [
                                    "Ignorar restrições ambientais como temperatura ou vibração.",
                                    "Não especificar precisão de sensores."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção de Microcontrolador e Componentes Principais",
                                  "subSteps": [
                                    "Avaliar microcontroladores (Arduino, STM32) por clock speed, pinos I/O e memória.",
                                    "Selecionar sensores compatíveis (ex: acelerômetro MPU6050 para movimento).",
                                    "Escolher atuadores (ex: servos MG996R, motores DC com drivers).",
                                    "Verificar compatibilidade de tensão e corrente.",
                                    "Criar tabela comparativa de opções."
                                  ],
                                  "verification": "Tabela de seleção preenchida com justificativas técnicas para cada escolha.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Datasheets de componentes (Arduino.cc, ST.com)",
                                    "Planilha Excel ou Google Sheets"
                                  ],
                                  "tips": "Use calculadoras online para consumo de energia total.",
                                  "learningObjective": "Selecionar componentes otimizados para integração hardware-software.",
                                  "commonMistakes": [
                                    "Escolher microcontrolador sem suporte a periféricos necessários.",
                                    "Subestimar corrente de atuadores."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Design da Arquitetura Hardware",
                                  "subSteps": [
                                    "Desenhar esquemático de conexões (pinos, alimentação, ground).",
                                    "Definir layout de protoboard ou PCB preliminar.",
                                    "Incluir proteções (diodos flyback, capacitores de desacoplamento).",
                                    "Calcular trilhas de potência e sinal.",
                                    "Gerar diagrama esquemático em software."
                                  ],
                                  "verification": "Diagrama esquemático revisado sem curtos-circuitos ou incompatibilidades.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software Fritzing ou KiCad",
                                    "Protoboard física para mockup"
                                  ],
                                  "tips": "Mantenha sinais analógicos longe de digitais para reduzir ruído.",
                                  "learningObjective": "Criar um design hardware funcional e escalável.",
                                  "commonMistakes": [
                                    "Esquecer alimentação separada para atuadores de alta corrente.",
                                    "Não considerar EMI (interferência eletromagnética)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Design da Arquitetura Software/Firmware",
                                  "subSteps": [
                                    "Definir estrutura de loop principal (setup, loop).",
                                    "Mapear funções para leitura de sensores e controle de atuadores.",
                                    "Implementar comunicação entre módulos (interrupts, timers).",
                                    "Esboçar fluxograma de controle (PID para atuadores).",
                                    "Planejar bibliotecas (ex: Wire para I2C)."
                                  ],
                                  "verification": "Pseudocódigo ou fluxograma cobrindo todos os requisitos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "IDE Arduino ou STM32CubeIDE",
                                    "Papel para fluxogramas"
                                  ],
                                  "tips": "Use estados finitos (FSM) para gerenciar modos operacionais.",
                                  "learningObjective": "Estruturar software que integre perfeitamente com hardware.",
                                  "commonMistakes": [
                                    "Bloquear loop principal com delays longos.",
                                    "Não tratar falhas de sensor."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificação de Compatibilidade e Integração",
                                  "subSteps": [
                                    "Simular esquemático em Tinkercad ou Proteus.",
                                    "Verificar timing de comunicação e sincronização.",
                                    "Analisar consumo total de energia e térmico.",
                                    "Realizar análise FMEA (Falha, Efeito e Modo de Análise).",
                                    "Documentar plano de integração física."
                                  ],
                                  "verification": "Relatório de simulação sem erros críticos e FMEA completa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simuladores online (Tinkercad, Proteus)",
                                    "Ferramentas de análise térmica"
                                  ],
                                  "tips": "Teste incremental: comece com um sensor + microcontrolador.",
                                  "learningObjective": "Garantir compatibilidade eletromecânica total antes da prototipagem.",
                                  "commonMistakes": [
                                    "Ignorar crosstalk entre sinais paralelos.",
                                    "Não considerar vibração em conexões mecânicas."
                                  ]
                                }
                              ],
                              "practicalExample": "Projetar arquitetura para um sistema de irrigação automatizado: usar STM32 com sensor de umidade do solo (capacitivo), sensor de nível de água (ultrassônico HC-SR04) e atuadores como bomba DC e válvula solenoide, integrando via PWM e I2C para controle preciso de umidade.",
                              "finalVerifications": [
                                "Diagrama esquemático completo sem incompatibilidades elétricas.",
                                "Pseudocódigo funcional mapeando todos os requisitos.",
                                "Cálculo de energia confirmando fontes adequadas.",
                                "Análise FMEA identificando riscos mitigados.",
                                "Simulação virtual rodando sem falhas.",
                                "Documentação clara com pinagem e interfaces."
                              ],
                              "assessmentCriteria": [
                                "Compatibilidade total hardware-software demonstrada.",
                                "Otimização de componentes por custo/desempenho.",
                                "Robustez contra falhas e ruídos.",
                                "Escalabilidade para expansões futuras.",
                                "Clareza e completude da documentação.",
                                "Alinhamento estrito com requisitos iniciais."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Design de circuitos e análise de sinais.",
                                "Programação: Estruturas de controle e bibliotecas embarcadas.",
                                "Mecânica: Integração com estruturas físicas e atuadores.",
                                "Matemática: Cálculos de timing, PID e consumo energético.",
                                "Gestão de Projetos: Análise de requisitos e FMEA."
                              ],
                              "realWorldApplication": "Desenvolvimento de robôs industriais em linhas de montagem automotiva, onde STM32 integra sensores de visão e atuadores pneumáticos para precisão milimétrica, reduzindo downtime e custos operacionais."
                            },
                            "estimatedTime": "6 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.2",
                            "name": "Programar e configurar microcontroladores e CLPs",
                            "description": "Desenvolver firmware em linguagens como C/Embedded ou Ladder Logic para CLPs, implementando controle PID e comunicação serial/I2C.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de desenvolvimento e hardware base",
                                  "subSteps": [
                                    "Instalar IDE apropriada (ex: Arduino IDE para microcontroladores ou TIA Portal para CLPs Siemens).",
                                    "Conectar o microcontrolador (ex: Arduino Uno ou ESP32) ou CLP ao computador via USB/Ethernet.",
                                    "Realizar teste básico de blink LED para verificar comunicação.",
                                    "Configurar bibliotecas necessárias (Wire para I2C, SoftwareSerial para comunicação serial).",
                                    "Compilar e fazer upload de um sketch simples para validar setup."
                                  ],
                                  "verification": "LED pisca conforme código e não há erros de compilação/upload.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Microcontrolador ou CLP",
                                    "Cabo USB/Ethernet",
                                    "IDE instalada",
                                    "Computador com drivers"
                                  ],
                                  "tips": "Sempre verifique a porta COM correta no IDE para evitar falhas de upload.",
                                  "learningObjective": "Configurar hardware e software para programação inicial de microcontroladores/CLPs.",
                                  "commonMistakes": [
                                    "Selecionar placa/porta errada",
                                    "Esquecer drivers USB",
                                    "Não resetar dispositivo antes do upload"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar comunicação serial e I2C",
                                  "subSteps": [
                                    "Estudar protocolos: Serial (UART) para debug e I2C para sensores (ex: DHT11).",
                                    "Escrever código C/Embedded para inicializar Serial.begin(9600) e Wire.begin().",
                                    "Configurar CLP Ladder Logic para comunicação Modbus serial ou Profibus.",
                                    "Testar leitura/escrita: Enviar dados via Serial.print() e ler sensor I2C.",
                                    "Integrar loop principal com delay para estabilidade."
                                  ],
                                  "verification": "Dados são enviados/recebidos corretamente no monitor serial ou scanner I2C.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Sensor I2C (ex: BMP280)",
                                    "Multímetro para debug",
                                    "Osciloscópio opcional"
                                  ],
                                  "tips": "Use pull-up resistors de 4.7kΩ para linhas I2C em setups longos.",
                                  "learningObjective": "Dominar protocolos de comunicação essenciais para integração de periféricos.",
                                  "commonMistakes": [
                                    "Endereço I2C incorreto",
                                    "Baud rate mismatch",
                                    "Não chamar Wire.endTransmission()"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver algoritmo de controle PID",
                                  "subSteps": [
                                    "Entender equação PID: Output = Kp*e + Ki*∫e + Kd*de/dt.",
                                    "Implementar função PID em C: Calcular erro, integral e derivada com anti-windup.",
                                    "Para Ladder Logic em CLP: Usar blocos PID prontos e configurar gains (Kp, Ki, Kd).",
                                    "Simular com setpoint fixo e ler sensor (ex: temperatura).",
                                    "Ajustar tuning manualmente via Serial monitor."
                                  ],
                                  "verification": "Saída PID estabiliza em setpoint com overshoot <10% em 5 ciclos.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Atuador (ex: relê ou PWM motor)",
                                    "Sensor analógico/digital"
                                  ],
                                  "tips": "Comece com Ki=Kd=0 e ajuste Kp primeiro para resposta rápida.",
                                  "learningObjective": "Implementar controle PID para sistemas de feedback em firmware.",
                                  "commonMistakes": [
                                    "Integral windup sem clamp",
                                    "Amostragem muito rápida causando ruído",
                                    "Unidades inconsistentes em gains"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar firmware completo e programar CLP",
                                  "subSteps": [
                                    "Combinar comunicação, PID e controle de atuadores no main loop.",
                                    "Adicionar estados finitos para modos (idle, control, error).",
                                    "Para CLP: Desenhar ladder com timers, contadores e PID block.",
                                    "Otimizar código: Usar interrupções para timers precisos.",
                                    "Fazer download para dispositivo e reset."
                                  ],
                                  "verification": "Sistema responde a comandos serial e mantém controle estável.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Firmware completo",
                                    "CLP simulator se disponível"
                                  ],
                                  "tips": "Use #define para constantes tunáveis via serial.",
                                  "learningObjective": "Criar firmware integrado com PID e comunicação para aplicações reais.",
                                  "commonMistakes": [
                                    "Loop bloqueante com delay()",
                                    "Stack overflow em recursão",
                                    "Falha em error handling"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, depurar e validar sistema",
                                  "subSteps": [
                                    "Executar testes unitários: Serial, I2C, PID isolados.",
                                    "Teste integrado: Ciclos de controle com variação de setpoint.",
                                    "Depurar com Serial.print() e lógica ladder online.",
                                    "Medir performance: Tempo de resposta, precisão, consumo.",
                                    "Documentar issues e correções."
                                  ],
                                  "verification": "Sistema passa todos testes com logs sem erros críticos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de debug (Logic Analyzer)",
                                    "Planilha para logs"
                                  ],
                                  "tips": "Registre dados em CSV para análise gráfica posterior.",
                                  "learningObjective": "Validar e otimizar firmware para robustez em produção.",
                                  "commonMistakes": [
                                    "Ignorar edge cases como sensor falho",
                                    "Testes só em condições ideais",
                                    "Não versionar código"
                                  ]
                                }
                              ],
                              "practicalExample": "Programar um Arduino para controlar temperatura de um forno usando sensor DS18B20 (I2C), PID para manter 100°C, e enviar status via serial para um app Android monitorar/adjustar setpoint.",
                              "finalVerifications": [
                                "Firmware/CLP program compila e roda sem crashes por 1 hora.",
                                "Comunicação serial/I2C transmite dados precisos (>95% accuracy).",
                                "PID estabiliza em setpoint com erro <2% e settling time <30s.",
                                "Sistema responde a falhas (ex: sensor desconectado) com safe mode.",
                                "Código é legível, comentado e versionado.",
                                "Testes unitários passam 100%."
                              ],
                              "assessmentCriteria": [
                                "Precisão do controle PID (erro steady-state <5%).",
                                "Eficiência de comunicação (sem perda de pacotes >1%).",
                                "Robustez a ruídos/falhas (recuperação <10s).",
                                "Qualidade do código (modular, sem warnings).",
                                "Documentação de tuning e testes.",
                                "Tempo de ciclo de controle <100ms."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial/integral no PID.",
                                "Eletrônica: Protocolos de barramento e sinalização.",
                                "Física: Dinâmica de sistemas e termodinâmica.",
                                "Informática: Algoritmos de controle e programação embarcada.",
                                "Gestão de Projetos: Ciclo de desenvolvimento iterativo."
                              ],
                              "realWorldApplication": "Em linhas de produção industriais, como controle de temperatura em fornos de solda ou velocidade de motores em robôs, reduzindo desperdícios e aumentando precisão em automação fabril."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.3",
                            "name": "Integrar sistemas de visão por computador",
                            "description": "Incorporar bibliotecas como OpenCV para processamento de imagens em projetos mecatrônicos, com foco em detecção de objetos e rastreamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento com OpenCV",
                                  "subSteps": [
                                    "Instalar Python e bibliotecas necessárias via pip (OpenCV, NumPy).",
                                    "Configurar câmera ou webcam para captura de vídeo.",
                                    "Testar importação e exibição de imagem básica com cv2.imshow().",
                                    "Integrar com IDE como VS Code ou Jupyter Notebook.",
                                    "Verificar compatibilidade com hardware mecatrônico (ex: Raspberry Pi)."
                                  ],
                                  "verification": "Executar script simples que captura e exibe vídeo da câmera sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Computador com Python 3.8+, câmera USB, Raspberry Pi (opcional)"
                                  ],
                                  "tips": "Use ambientes virtuais com venv para evitar conflitos de dependências.",
                                  "learningObjective": "Configurar ambiente funcional para visão computacional em projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Instalar versão errada de OpenCV (use opencv-python)",
                                    "Não testar câmera antes",
                                    "Ignorar dependências de hardware"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar processamento básico de imagens",
                                  "subSteps": [
                                    "Carregar imagem ou frame de vídeo com cv2.imread() ou cv2.VideoCapture().",
                                    "Aplicar filtros como conversão para escala de cinza e redução de ruído (GaussianBlur).",
                                    "Realizar operações morfológicas (erosão, dilatação) para pré-processamento.",
                                    "Exibir resultados em janelas e salvar frames processados.",
                                    "Otimizar para processamento em tempo real (resize frames)."
                                  ],
                                  "verification": "Processar vídeo em tempo real com filtros aplicados e sem lag perceptível.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Câmera, exemplos de imagens de teste",
                                    "Documentação OpenCV"
                                  ],
                                  "tips": "Ajuste tamanhos de kernel em filtros baseados no ruído da imagem.",
                                  "learningObjective": "Dominar pré-processamento de imagens para melhorar detecção em cenários mecatrônicos.",
                                  "commonMistakes": [
                                    "Processar frames em resolução alta sem otimização",
                                    "Esquecer de liberar captura de vídeo com release()",
                                    "Ignorar variações de iluminação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver detecção de objetos usando OpenCV",
                                  "subSteps": [
                                    "Treinar ou carregar classificadores Haar Cascade para objetos comuns (ex: faces, carros).",
                                    "Implementar detecção com cv2.CascadeClassifier.detectMultiScale().",
                                    "Desenhar bounding boxes e labels nos frames detectados.",
                                    "Filtrar detecções por confiança e tamanho mínimo.",
                                    "Testar em diferentes condições de luz e ângulos."
                                  ],
                                  "verification": "Detectar e rotular pelo menos 80% dos objetos alvo em vídeo de teste.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Arquivos XML de cascades do OpenCV GitHub",
                                    "Vídeos de teste com objetos"
                                  ],
                                  "tips": "Combine múltiplos cascades para detecção robusta.",
                                  "learningObjective": "Implementar detecção precisa de objetos para integração mecatrônica.",
                                  "commonMistakes": [
                                    "Usar escala fixa no detectMultiScale",
                                    "Não filtrar falsos positivos",
                                    "Treinar cascades sem dados suficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar rastreamento de objetos em tempo real",
                                  "subSteps": [
                                    "Inicializar tracker com cv2.TrackerCSRT_create() ou similar após detecção inicial.",
                                    "Atualizar tracker em cada frame com update() e desenhar trajetória.",
                                    "Gerenciar perda de rastreamento e reinicialização automática.",
                                    "Calcular métricas como velocidade e direção do objeto.",
                                    "Otimizar FPS para aplicações em tempo real."
                                  ],
                                  "verification": "Rastrear objeto em movimento por 30 segundos sem perda.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "OpenCV contrib para trackers avançados",
                                    "Vídeo de objetos móveis"
                                  ],
                                  "tips": "Escolha tracker baseado no cenário (CSRT para precisão, KCF para velocidade).",
                                  "learningObjective": "Rastrear objetos dinamicamente para controle mecatrônico.",
                                  "commonMistakes": [
                                    "Não lidar com oclusões",
                                    "Atualizar tracker em frames ruins",
                                    "Ignorar calibração de câmera"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar visão computacional com hardware mecatrônico",
                                  "subSteps": [
                                    "Comunicar resultados de visão via serial (PySerial) para Arduino/Raspberry Pi.",
                                    "Controlar atuadores (motores, servos) baseado em posição detectada/rastreada.",
                                    "Implementar loop de feedback: visão -> processamento -> comando -> ação.",
                                    "Testar sistema completo em protótipo (ex: braço robótico segue objeto).",
                                    "Debugar latência e sincronização."
                                  ],
                                  "verification": "Sistema mecatrônico responde corretamente a detecções em tempo real.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Arduino/RPi, motores, cabos serial",
                                    "Biblioteca PySerial"
                                  ],
                                  "tips": "Use threads para separar visão e controle de hardware.",
                                  "learningObjective": "Integrar visão em sistemas mecatrônicos completos.",
                                  "commonMistakes": [
                                    "Latência alta por processamento síncrono",
                                    "Comunicação serial instável",
                                    "Não calibrar coordenadas visão-hardware"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver um braço robótico que detecta e rastreia uma bola vermelha com OpenCV, ajustando servos para segui-la, simulando inspeção industrial.",
                              "finalVerifications": [
                                "Sistema detecta objetos com >85% de precisão em condições variadas.",
                                "Rastreamento mantém lock por >20 segundos em movimento.",
                                "Integração com hardware responde em <100ms.",
                                "Processamento roda a >15 FPS.",
                                "Nenhum crash em sessões de 5 minutos.",
                                "Resultados salvos em log/vídeo para análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão e robustez da detecção/rastreamento.",
                                "Desempenho em tempo real (FPS e latência).",
                                "Integração seamless com componentes mecatrônicos.",
                                "Código limpo, comentado e modular.",
                                "Tratamento de erros e edge cases.",
                                "Otimização de recursos (CPU/RAM)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos de visão e Python avançado.",
                                "Eletrônica: Interfaces serial e controle de atuadores.",
                                "Mecânica: Cinemática de robôs e calibração.",
                                "Inteligência Artificial: Machine Learning básico para detecção.",
                                "Matemática: Geometria e vetores para rastreamento."
                              ],
                              "realWorldApplication": "Inspeção automatizada em linhas de montagem, veículos autônomos para detecção de obstáculos, drones para rastreamento de alvos, e robótica colaborativa em manufatura."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.4",
                            "name": "Aplicar conceitos de robótica mecatrônica",
                            "description": "Desenvolver subsistemas robóticos com aplicações na indústria aeronáutica, como braços manipuladores ou drones autônomos, integrando Lyshevski (1999).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de robótica mecatrônica baseados em Lyshevski (1999)",
                                  "subSteps": [
                                    "Ler capítulos relevantes de 'Nano and Microengineering of Mechanical Systems' de Lyshevski (1999), focando em modelagem dinâmica de sistemas mecatrônicos.",
                                    "Identificar princípios de cinemática, dinâmica e controle para robôs.",
                                    "Anotar definições chave: atuadores piezoelétricos, sensores MEMS e controle adaptativo.",
                                    "Mapear conceitos para aplicações aeronáuticas, como manipulação precisa em ambientes confinados.",
                                    "Criar um glossário pessoal com 10 termos principais."
                                  ],
                                  "verification": "Glossário completo criado e conceitos explicados em um resumo de 1 página.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro de Lyshevski (1999)",
                                    "Notebook para anotações",
                                    "Acesso online a capítulos digitais"
                                  ],
                                  "tips": "Use destaques coloridos para diferenciar teoria de aplicações práticas.",
                                  "learningObjective": "Compreender os pilares teóricos da robótica mecatrônica para subsidiar o design.",
                                  "commonMistakes": [
                                    "Ignorar modelagem dinâmica, focando só em hardware",
                                    "Não relacionar conceitos à aeronáutica desde o início"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir requisitos e especificações para subsistemas robóticos aeronáuticos",
                                  "subSteps": [
                                    "Analisar casos de uso: braços manipuladores para montagem de fuselagem ou drones para inspeção.",
                                    "Listar requisitos funcionais (ex: precisão <1mm, payload 500g) e não-funcionais (ex: resistência a vibrações).",
                                    "Consultar normas aeronáuticas (ex: FAA standards para robótica em manutenção).",
                                    "Priorizar componentes mecatrônicos: sensores IMU, motores brushless, controladores PID.",
                                    "Elaborar um documento de requisitos com diagrama de fluxo."
                                  ],
                                  "verification": "Documento de requisitos aprovado por auto-revisão ou peer review, com pelo menos 20 itens especificados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Modelos de requisitos IEEE",
                                    "Software de diagramação como Draw.io",
                                    "Referências FAA online"
                                  ],
                                  "tips": "Use matriz de priorização MoSCoW (Must, Should, Could, Won't) para requisitos.",
                                  "learningObjective": "Estabelecer bases claras para design alinhado a aplicações industriais aeronáuticas.",
                                  "commonMistakes": [
                                    "Requisitos vagos sem métricas quantificáveis",
                                    "Omitir restrições ambientais como temperatura alta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar e modelar o subsistema robótico",
                                  "subSteps": [
                                    "Desenhar esquemático em CAD (ex: braço com 3 DOF ou drone quadcopter).",
                                    "Modelar dinamicamente usando equações de Lyshevski (ex: Lagrange para cinemática).",
                                    "Simular controle em MATLAB/Simulink com feedback sensorial.",
                                    "Otimizar parâmetros para eficiência energética e precisão.",
                                    "Gerar relatórios de simulação com gráficos de trajetória e erro."
                                  ],
                                  "verification": "Modelo simulado executado com erro <5% em trajetórias teste.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "SolidWorks ou Fusion 360",
                                    "MATLAB/Simulink",
                                    "Equações de Lyshevski anotadas"
                                  ],
                                  "tips": "Comece com modelo 2D antes de 3D para validar lógica.",
                                  "learningObjective": "Dominar modelagem integrada de mecânica, eletrônica e controle.",
                                  "commonMistakes": [
                                    "Não validar modelo com dados reais de sensores",
                                    "Ignorar singularidades cinemáticas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, integrar e testar o protótipo físico",
                                  "subSteps": [
                                    "Montar hardware: integrar atuadores, sensores e microcontrolador (ex: ROS no Raspberry Pi).",
                                    "Programar firmware com algoritmos de controle adaptativo de Lyshevski.",
                                    "Realizar testes incrementais: unidade (sensores), integração (movimento), sistema (tarefa completa).",
                                    "Coletar dados de performance e iterar ajustes.",
                                    "Documentar falhas e soluções em log de testes."
                                  ],
                                  "verification": "Protótipo executa tarefa aeronáutica simulada (ex: manipular peça) com sucesso em 3 tentativas.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Arduino/Raspberry Pi",
                                    "Servos/motores, IMU, bateria",
                                    "ROS framework",
                                    "Ferramentas de montagem"
                                  ],
                                  "tips": "Teste em ambiente controlado antes de cenários reais para segurança.",
                                  "learningObjective": "Aplicar conceitos teóricos em protótipo funcional.",
                                  "commonMistakes": [
                                    "Integração sem calibração de sensores",
                                    "Subestimar latência de comunicação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar para aplicação aeronáutica industrial",
                                  "subSteps": [
                                    "Simular cenários reais: vibrações de turbina, inspeção em fuselagem.",
                                    "Aplicar métricas de Lyshevski para robustez (ex: estabilidade Lyapunov).",
                                    "Otimizar com machine learning básico para adaptação.",
                                    "Preparar relatório final com vídeos de demo e dados.",
                                    "Propor escalabilidade para produção industrial."
                                  ],
                                  "verification": "Relatório final com validação em 80% dos critérios de performance aeronáutica.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Shaker para vibrações simuladas",
                                    "Câmera para gravação",
                                    "Software de análise de dados"
                                  ],
                                  "tips": "Grave todos os testes para análise posterior.",
                                  "learningObjective": "Garantir viabilidade industrial do subsistema.",
                                  "commonMistakes": [
                                    "Não considerar custos de escala",
                                    "Ignorar certificações de segurança"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver um braço manipulador mecatrônico para montagem precisa de componentes em fuselagem de aeronaves, integrando sensores MEMS e controle piezoelétrico conforme Lyshevski, capaz de posicionar parafusos com precisão de 0.5mm sob vibrações simuladas.",
                              "finalVerifications": [
                                "Subsistema integra mecânica, eletrônica e software sem falhas de comunicação.",
                                "Performance atende requisitos aeronáuticos (precisão, robustez, eficiência).",
                                "Simulações e testes físicos validam modelo teórico de Lyshevski.",
                                "Documentação completa permite replicação por terceiros.",
                                "Protótipo opera autonomamente em tarefa simulada por 10 minutos.",
                                "Análise de falhas identifica e mitiga riscos industriais."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da aplicação de conceitos de Lyshevski (30%).",
                                "Qualidade do design e modelagem (25%).",
                                "Sucesso na implementação e testes (20%).",
                                "Integração interdisciplinar e inovação (15%).",
                                "Documentação e relatórios profissionais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Design de circuitos para sensores e atuadores.",
                                "Programação: Algoritmos de controle em ROS/Python.",
                                "Aerodinâmica: Considerações de fluxo para drones.",
                                "Gestão de Projetos: Metodologia ágil para iterações.",
                                "Materiais: Seleção de compostos leves para aeronáutica."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Boeing ou Embraer, para automação de inspeções em fuselagens, montagem robótica de asas e drones autônomos para monitoramento de hangares, reduzindo tempo de manutenção em 40% e erros humanos."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.3",
                        "name": "Execução e Implementação de Projetos",
                        "description": "Construção de protótipos, testes, validação e iterações finais para implantação de sistemas mecatrônicos, assegurando conformidade com especificações e normas de segurança.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.3.1",
                            "name": "Montar e testar protótipos físicos",
                            "description": "Construir hardware mecatrônico com soldagem, cabos e enclosures, realizando testes unitários e de integração em bancada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar componentes e ferramentas",
                                  "subSteps": [
                                    "Revisar o esquema elétrico e diagrama de montagem do protótipo.",
                                    "Inspecionar todos os componentes (microcontroladores, sensores, atuadores, cabos, enclosures) por danos ou defeitos.",
                                    "Organizar ferramentas: multímetro, ferro de solda, alicates, fita isolante, parafusos e fixadores.",
                                    "Preparar estação de trabalho com ventilação e proteção ESD.",
                                    "Listar sequências de montagem e testes esperados."
                                  ],
                                  "verification": "Checklist completo assinalado e componentes organizados em bancada sem defeitos visíveis.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Esquema do projeto, componentes mecatrônicos, multímetro, ferramentas manuais, luvas antiestáticas.",
                                  "tips": "Fotografe a organização inicial para referência futura.",
                                  "learningObjective": "Garantir que todos os materiais estejam prontos e inspecionados para evitar interrupções na montagem.",
                                  "commonMistakes": "Ignorar inspeção de componentes danificados, levando a falhas posteriores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar enclosure e fixar componentes mecânicos",
                                  "subSteps": [
                                    "Cortar e preparar o enclosure conforme dimensões especificadas.",
                                    "Fixar suportes mecânicos, placas de circuito e componentes usando parafusos ou colas apropriadas.",
                                    "Instalar guias para cabos e furos para acessos (sensores, botões).",
                                    "Verificar alinhamento e estabilidade mecânica manualmente.",
                                    "Testar mobilidade de partes móveis se aplicável."
                                  ],
                                  "verification": "Enclosure montado com todos componentes fixos firmemente, sem folgas ou desalinhamentos.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Enclosure (caixa plástica ou metálica), parafusos, furadeira, serra, suportes mecânicos.",
                                  "tips": "Use gabaritos para precisão em furos e cortes.",
                                  "learningObjective": "Desenvolver habilidades em montagem mecânica precisa para suportar componentes eletrônicos.",
                                  "commonMistakes": "Furos mal posicionados que impedem encaixe correto de componentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar soldagem e conexões elétricas",
                                  "subSteps": [
                                    "Conectar cabos aos terminais conforme esquema, usando conectores ou solda.",
                                    "Soldar juntas em protoboards ou PCBs, aplicando fluxo e resfriamento adequado.",
                                    "Isolar todas as conexões com fita ou termorretrátil.",
                                    "Verificar continuidade elétrica com multímetro em todas as linhas.",
                                    "Organizar cabos dentro do enclosure para evitar curtos."
                                  ],
                                  "verification": "Multímetro confirma continuidade em todos circuitos sem curtos (resistência infinita entre linhas não conectadas).",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": "Ferro de solda, estanho, fluxo, multímetro, cabos jumper, fita isolante, termorretrátil.",
                                  "tips": "Aqueça a junta antes de aplicar estanho para solda limpa.",
                                  "learningObjective": "Dominar técnicas de soldagem e cabeamento seguras para hardware mecatrônico funcional.",
                                  "commonMistakes": "Pontes de solda não removidas causando curtos-circuitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar testes unitários e de integração",
                                  "subSteps": [
                                    "Alimentar cada módulo individual (ex: sensor, atuador) e medir saídas esperadas.",
                                    "Executar scripts de teste unitário no microcontrolador para cada componente.",
                                    "Integrar sistema completo e testar interações (ex: sensor ativa atuador).",
                                    "Registrar falhas em log e corrigir imediatamente.",
                                    "Realizar teste de estresse básico (vibração, temperatura ambiente)."
                                  ],
                                  "verification": "100% dos testes unitários e de integração passam sem erros; log de testes completo.",
                                  "estimatedTime": "45-75 minutos",
                                  "materials": "Fonte de alimentação, osciloscópio ou multímetro avançado, software de teste (ex: Arduino IDE), PC.",
                                  "tips": "Comece com baixa tensão para testes iniciais.",
                                  "learningObjective": "Validar funcionalidade individual e integrada do protótipo mecatrônico.",
                                  "commonMistakes": "Pular testes unitários, descobrindo falhas só na integração."
                                }
                              ],
                              "practicalExample": "Montagem de um protótipo de carrinho robótico autônomo: fixar Arduino, motor DC com driver L298N no chassis de acrílico, soldar conexões de sensores ultrassônicos HC-SR04, testar motor individualmente (gira sem travar), sensor (mede distâncias 2-400cm), e integração (para ao detectar obstáculo <20cm).",
                              "finalVerifications": [
                                "Protótipo fisicamente estável, sem cabos soltos ou soldas frias.",
                                "Todos circuitos elétricos com continuidade perfeita e sem curtos.",
                                "Testes unitários: cada componente responde corretamente a estímulos.",
                                "Testes de integração: sistema opera como especificado por pelo menos 10 ciclos.",
                                "Medidas de segurança: isolamento elétrico e proteção mecânica adequados.",
                                "Documentação: fotos, log de testes e esquema atualizado."
                              ],
                              "assessmentCriteria": [
                                "Precisão e qualidade da soldagem (sem excessos ou frias): 25%.",
                                "Cobertura completa de testes unitários e integração: 25%.",
                                "Estabilidade mecânica do enclosure e fixações: 20%.",
                                "Organização de cabos e isolamento elétrico: 15%.",
                                "Tempo de execução dentro do estimado e correções ágeis: 10%.",
                                "Documentação detalhada de montagem e testes: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Fundamentos de circuitos e soldagem.",
                                "Programação: Scripts de teste em linguagens como C++ para Arduino.",
                                "Design Industrial: Ergonomia e estética do enclosure.",
                                "Segurança do Trabalho: Normas NR-10 para eletricidade.",
                                "Gestão de Projetos: Planejamento e iteração em protótipos."
                              ],
                              "realWorldApplication": "Na indústria automotiva, montar protótipos de sistemas de controle veicular (ECUs com sensores); em robótica industrial, integrar atuadores e sensores em braços robóticos para linhas de produção; ou em IoT, construir dispositivos de monitoramento ambiental com enclosures à prova d'água."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.2",
                            "name": "Realizar validação e calibração do sistema",
                            "description": "Aplicar testes funcionais, de desempenho e robustez, calibrando sensores e controladores para otimizar resposta dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejamento e Preparação para Validação",
                                  "subSteps": [
                                    "Definir objetivos de validação baseados nos requisitos do sistema mecatrônico.",
                                    "Elaborar plano de testes incluindo cenários funcionais, de desempenho e de robustez.",
                                    "Verificar e preparar o ambiente de teste, incluindo hardware e software.",
                                    "Calcular tolerâncias aceitáveis para sensores e controladores.",
                                    "Documentar procedimentos de segurança e checklists iniciais."
                                  ],
                                  "verification": "Plano de testes aprovado por revisão e checklist de preparação 100% completo.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Documentos de requisitos, software de simulação (ex: MATLAB/Simulink), ferramentas de medição, EPIs.",
                                  "tips": "Priorize testes em ambiente controlado para isolar variáveis.",
                                  "learningObjective": "Compreender a importância do planejamento para testes eficazes e seguros.",
                                  "commonMistakes": "Ignorar requisitos não funcionais ou subestimar riscos de segurança."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Execução de Testes Funcionais",
                                  "subSteps": [
                                    "Executar testes unitários para cada componente (sensores, atuadores, controladores).",
                                    "Verificar integração do sistema em operação básica.",
                                    "Registrar dados de entrada/saída e comparar com especificações.",
                                    "Identificar falhas funcionais e anomalias iniciais.",
                                    "Repetir testes em loop até consistência."
                                  ],
                                  "verification": "Relatório de testes funcionais com 100% de cobertura de casos e sem falhas críticas.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Sistema mecatrônico montado, osciloscópio, multímetro, software de logging de dados.",
                                  "tips": "Use automação de testes para repetibilidade.",
                                  "learningObjective": "Aplicar testes funcionais para validar operação básica do sistema.",
                                  "commonMistakes": "Testar apenas em condições ideais, ignorando bordas de falha."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testes de Desempenho e Robustez",
                                  "subSteps": [
                                    "Aplicar cargas variáveis para medir desempenho (velocidade, precisão, eficiência).",
                                    "Simular condições adversas (vibrações, temperaturas extremas, ruído).",
                                    "Medir tempos de resposta dinâmica e estabilidade.",
                                    "Analisar dados com métricas como overshoot, settling time e erro steady-state.",
                                    "Documentar limites de operação segura."
                                  ],
                                  "verification": "Gráficos de desempenho dentro das tolerâncias especificadas e relatório de robustez.",
                                  "estimatedTime": "8 horas",
                                  "materials": "Geradores de sinal, câmaras térmicas, vibradores, analisadores de espectro.",
                                  "tips": "Monitore múltiplos parâmetros simultaneamente para correlações.",
                                  "learningObjective": "Avaliar desempenho dinâmico e robustez sob estresse.",
                                  "commonMistakes": "Não calibrar equipamentos de teste antes do uso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calibração de Sensores e Controladores",
                                  "subSteps": [
                                    "Coletar dados brutos de sensores em condições conhecidas.",
                                    "Aplicar algoritmos de calibração (ex: least squares) para ajustar offsets e gains.",
                                    "Sintonizar controladores PID via métodos como Ziegler-Nichols.",
                                    "Testar iterações de calibração e otimizar resposta dinâmica.",
                                    "Salvar parâmetros calibrados e validar em ciclo fechado."
                                  ],
                                  "verification": "Erro de medição < 2% e resposta dinâmica otimizada (sem oscilações excessivas).",
                                  "estimatedTime": "5 horas",
                                  "materials": "Software de calibração (LabVIEW), padrões de referência, computadores com simuladores.",
                                  "tips": "Faça calibrações incrementais para evitar instabilidades.",
                                  "learningObjective": "Dominar técnicas de calibração para otimização de sistemas de controle.",
                                  "commonMistakes": "Sobreajustar parâmetros levando a instabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação Final e Documentação",
                                  "subSteps": [
                                    "Executar suíte completa de testes pós-calibração.",
                                    "Comparar métricas antes/depois da calibração.",
                                    "Gerar relatório final com evidências e recomendações.",
                                    "Arquivar dados para rastreabilidade.",
                                    "Planejar manutenção futura."
                                  ],
                                  "verification": "Sistema aprovado com todas as verificações finais passadas e relatório submetido.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Templates de relatório, ferramentas de versionamento (Git).",
                                  "tips": "Use visualizações gráficas para relatórios impactantes.",
                                  "learningObjective": "Consolidar validação e preparar para implantação.",
                                  "commonMistakes": "Omitir documentação de iterações de calibração."
                                }
                              ],
                              "practicalExample": "Em um braço robótico mecatrônico, valide testes funcionais movendo-o para posições pré-definidas, teste desempenho com cargas variadas, robustez sob vibrações, calibre encoders e PID do motor para precisão <1mm em trajetórias dinâmicas.",
                              "finalVerifications": [
                                "Sistema responde dentro de especificações dinâmicas (tempo de settling <500ms).",
                                "Sensores calibrados com erro <1% em faixa operacional.",
                                "Controladores estáveis sem oscilações em testes de robustez.",
                                "Desempenho sob estresse atende 95% dos requisitos.",
                                "Documentação completa e rastreável.",
                                "Sem falhas críticas em 100 ciclos de teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude do plano de testes (30%).",
                                "Execução correta de testes e análise de dados (25%).",
                                "Eficácia da calibração (redução de erro >50%) (20%).",
                                "Qualidade da documentação e relatórios (15%).",
                                "Adesão a segurança e boas práticas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Calibração de sensores analógicos/digitais.",
                                "Programação: Scripts de automação em Python/LabVIEW.",
                                "Matemática: Modelos dinâmicos e otimização PID.",
                                "Gestão de Projetos: Planejamento e rastreabilidade."
                              ],
                              "realWorldApplication": "Na indústria automotiva, validação e calibração de sistemas ABS garantem frenagem otimizada em condições reais, reduzindo acidentes; em robótica industrial, otimiza precisão de pick-and-place em linhas de montagem."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.3",
                            "name": "Gerenciar iterações e implantação final",
                            "description": "Analisar falhas, iterar designs e preparar documentação para produção ou deployment industrial, incluindo manutenção preditiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise de Falhas e Coleta de Dados",
                                  "subSteps": [
                                    "Realizar testes repetidos no protótipo para reproduzir falhas",
                                    "Coletar dados de sensores, logs e métricas de desempenho",
                                    "Identificar padrões e causas raiz usando ferramentas como diagrama de Ishikawa",
                                    "Classificar falhas por criticidade (alta, média, baixa)",
                                    "Documentar evidências fotográficas e quantitativas"
                                  ],
                                  "verification": "Relatório de análise de falhas completo com causas raiz identificadas e aprovado por equipe",
                                  "estimatedTime": "6 horas",
                                  "materials": "Logs de sensores, software de análise (ex: MATLAB ou Python Pandas), câmeras, planilhas",
                                  "tips": "Use método 5 Porquês para aprofundar causas raiz",
                                  "learningObjective": "Dominar técnicas de diagnóstico para identificar falhas em sistemas mecatrônicos",
                                  "commonMistakes": "Atribuir falhas a sintomas superficiais sem investigação profunda"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iteração do Design",
                                  "subSteps": [
                                    "Propor modificações baseadas na análise de falhas",
                                    "Simular alterações em software CAD/FEM antes de prototipagem",
                                    "Construir e testar protótipo iterado",
                                    "Comparar métricas pré e pós-iteração",
                                    "Ajustar iterativamente até atingir critérios de aceitação"
                                  ],
                                  "verification": "Protótipo iterado passa em todos os testes com melhoria mensurável (ex: 20% melhor precisão)",
                                  "estimatedTime": "12 horas",
                                  "materials": "Software CAD (SolidWorks), impressora 3D ou ferramentas de usinagem, sensores de teste",
                                  "tips": "Mantenha um registro de mudanças para rastreabilidade",
                                  "learningObjective": "Aplicar ciclos de iteração PDCA para otimizar designs mecatrônicos",
                                  "commonMistakes": "Fazer múltiplas mudanças simultâneas, dificultando identificação de impactos"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preparação de Documentação para Implantação",
                                  "subSteps": [
                                    "Elaborar manual de operação e manutenção",
                                    "Criar desenhos técnicos finais e lista de peças (BOM)",
                                    "Desenvolver procedimentos de instalação e calibração",
                                    "Incluir especificações para produção em escala",
                                    "Revisar e validar documentação com stakeholders"
                                  ],
                                  "verification": "Pacote de documentação aprovado e pronto para handover à produção",
                                  "estimatedTime": "8 horas",
                                  "materials": "Software de documentação (ex: LaTeX, Visio), normas técnicas (ISO 9001)",
                                  "tips": "Use templates padronizados para consistência",
                                  "learningObjective": "Produzir documentação técnica clara e completa para deployment industrial",
                                  "commonMistakes": "Omitir detalhes de segurança ou tolerâncias"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Planejamento e Execução da Implantação Final",
                                  "subSteps": [
                                    "Definir cronograma de implantação e recursos necessários",
                                    "Instalar sistema em ambiente de produção simulada",
                                    "Realizar calibração e testes de integração finais",
                                    "Treinar operadores e equipe de manutenção",
                                    "Monitorar primeiros ciclos de operação"
                                  ],
                                  "verification": "Sistema implantado operacional com zero falhas nos primeiros 10 ciclos",
                                  "estimatedTime": "10 horas",
                                  "materials": "Equipamentos de produção, ferramentas de instalação, equipe de suporte",
                                  "tips": "Simule cenários de falha durante implantação",
                                  "learningObjective": "Gerenciar transição de protótipo para produção industrial",
                                  "commonMistakes": "Subestimar tempo de integração com sistemas existentes"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementação de Manutenção Preditiva",
                                  "subSteps": [
                                    "Instalar sensores IoT para monitoramento contínuo",
                                    "Configurar algoritmos de detecção de anomalias (ex: ML básico)",
                                    "Definir thresholds de alerta e planos de ação",
                                    "Testar sistema preditivo em simulações",
                                    "Integrar com dashboard de monitoramento"
                                  ],
                                  "verification": "Sistema preditivo detecta e previne falhas simuladas com 95% de acurácia",
                                  "estimatedTime": "6 horas",
                                  "materials": "Sensores IoT, software de ML (ex: TensorFlow Lite), dashboard (ex: Grafana)",
                                  "tips": "Comece com métricas simples antes de modelos complexos",
                                  "learningObjective": "Desenvolver estratégias de manutenção preditiva para longevidade do sistema",
                                  "commonMistakes": "Ignorar falsos positivos no setup inicial"
                                }
                              ],
                              "practicalExample": "Em um braço robótico mecatrônico para linha de montagem, falhas de precisão são analisadas (vibração em junta), design iterado com reforço estrutural, documentação preparada para fábrica, implantado com sucesso e manutenção preditiva via sensores vibração previne downtime futuro.",
                              "finalVerifications": [
                                "Todas falhas resolvidas com evidências de testes",
                                "Documentação completa e aprovada",
                                "Sistema implantado e operacional em produção",
                                "Manutenção preditiva configurada e testada",
                                "Relatório final com lições aprendidas",
                                "Handover para equipe de produção realizado"
                              ],
                              "assessmentCriteria": [
                                "Precisão e profundidade na análise de falhas (80% causas raiz corretas)",
                                "Efetividade das iterações (melhoria mensurável >15%)",
                                "Completude e clareza da documentação (sem ambiguidades)",
                                "Sucesso na implantação sem retrabalho",
                                "Funcionalidade da manutenção preditiva (acurácia >90%)",
                                "Gestão de tempo e recursos dentro do estimado"
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos (PMBOK para iterações)",
                                "Estatística e Dados (análise de falhas)",
                                "Programação Industrial (PLCs e IoT)",
                                "Qualidade e Normas (ISO 9001/TS 16949)",
                                "Inteligência Artificial (manutenção preditiva)"
                              ],
                              "realWorldApplication": "Na indústria automotiva, gerenciando iterações em robôs de solda para linhas de montagem, reduzindo downtime em 30% via manutenção preditiva e garantindo produção contínua 24/7."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Sistemas de Visão por Computador",
                "description": "Introdução aos sistemas de visão por computador e suas aplicações em contextos mecatrônicos.",
                "totalSkills": 50,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Definição e Princípios Básicos de Sistemas de Visão por Computador",
                    "description": "Conceitos fundamentais de visão por computador, incluindo captura e interpretação de imagens visuais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1.1",
                        "name": "Definição de Sistemas de Visão por Computador",
                        "description": "Conceito fundamental que define visão por computador como a área da inteligência artificial que permite a máquinas interpretarem e entenderem o mundo visual, simulando a visão humana em sistemas mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1.1",
                            "name": "Explicar o conceito de visão por computador",
                            "description": "Descrever visão por computador como a tecnologia que extrai informações de imagens e vídeos para tomada de decisões em sistemas automatizados, com ênfase em aplicações mecatrônicas como inspeção industrial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição básica de visão por computador",
                                  "subSteps": [
                                    "Leia a definição: Visão por computador é a tecnologia que permite a máquinas extrair informações úteis de imagens e vídeos.",
                                    "Identifique os elementos chave: extração de informações, imagens/vídeos, tomada de decisões automatizadas.",
                                    "Compare com visão humana: máquinas processam pixels, humanos interpretam semanticamente.",
                                    "Anote exemplos iniciais de uso diário, como reconhecimento facial em smartphones.",
                                    "Resuma em uma frase própria a definição focada em sistemas automatizados."
                                  ],
                                  "verification": "Escreva uma definição de 1-2 frases que inclua extração de informações de imagens para decisões automatizadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Artigo introdutório sobre visão por computador (ex: Wikipedia ou tutorial OpenCV), caderno para anotações.",
                                  "tips": "Use analogias simples como 'olhos e cérebro da máquina' para fixar o conceito.",
                                  "learningObjective": "Definir visão por computador com precisão, destacando seu papel em automação.",
                                  "commonMistakes": "Confundir com gráficos por computador (que gera imagens) em vez de processar imagens existentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os princípios fundamentais de funcionamento",
                                  "subSteps": [
                                    "Estude etapas principais: aquisição de imagem (câmeras), pré-processamento (ruído, contraste), extração de características (bordas, formas).",
                                    "Aprenda sobre segmentação e reconhecimento de padrões usando exemplos visuais.",
                                    "Entenda o papel da IA/ML: modelos treinados para classificar objetos em imagens.",
                                    "Desenhe um fluxograma simples: Imagem → Processamento → Decisão.",
                                    "Assista a um vídeo curto demonstrando o pipeline de visão por computador."
                                  ],
                                  "verification": "Crie um fluxograma de 4-5 etapas do processo de visão por computador e explique oralmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Vídeo tutorial (ex: 'Computer Vision Basics' no YouTube), software de desenho como Draw.io, exemplos de imagens reais.",
                                  "tips": "Comece com imagens simples como uma moeda para visualizar extração de características.",
                                  "learningObjective": "Descrever o pipeline básico de visão por computador de forma sequencial.",
                                  "commonMistakes": "Ignorar o pré-processamento, achando que máquinas 'veem' diretamente como humanos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar aplicações em mecatrônica, com foco em inspeção industrial",
                                  "subSteps": [
                                    "Pesquise casos: detecção de defeitos em peças automotivas via câmeras em linhas de produção.",
                                    "Descreva integração mecatrônica: câmera + PLC + atuadores para rejeitar peças defeituosas.",
                                    "Liste benefícios: velocidade, precisão 24/7, redução de erros humanos.",
                                    "Identifique componentes: lentes, iluminação controlada, software de processamento.",
                                    "Simule um cenário: inspecionar soldas em chassis de carro."
                                  ],
                                  "verification": "Desenvolva um parágrafo descrevendo uma aplicação de inspeção industrial usando visão por computador.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Vídeos de inspeção industrial (ex: YouTube 'machine vision inspection'), imagens de linhas de montagem.",
                                  "tips": "Pense em contextos locais: indústrias brasileiras como automobilística ou alimentícia.",
                                  "learningObjective": "Relacionar visão por computador a aplicações práticas em sistemas mecatrônicos automatizados.",
                                  "commonMistakes": "Focar só em apps consumer (como selfies) e ignorar contextos industriais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar visão por computador de outras tecnologias e resumir conceitos chave",
                                  "subSteps": [
                                    "Compare com sensores tradicionais: visão dá informação rica 2D/3D vs. sensores unidimensionais.",
                                    "Discuta limitações: sensibilidade a iluminação, oclusões, necessidade de treinamento.",
                                    "Resuma ênfase mecatrônica: integração com robótica e controle para decisões autônomas.",
                                    "Crie uma tabela comparativa: Visão Humana vs. Visão por Computador.",
                                    "Formule perguntas e respostas sobre o conceito para autoavaliação."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e responda 3 perguntas sobre limitações em mecatrônica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha ou papel para tabela, lista de perguntas preparadas.",
                                  "tips": "Use mnemônicos como 'AIP' (Aquisição, Processamento, Interpretação) para lembrar o fluxo.",
                                  "learningObjective": "Diferenciar visão por computador de visão humana e sensores, destacando forças em automação.",
                                  "commonMistakes": "Superestimar capacidades atuais, confundindo com visão 'perfeita' sem limitações reais."
                                }
                              ],
                              "practicalExample": "Em uma linha de produção de parafusos, uma câmera captura imagens de cada parafuso passando em esteira; o software detecta ranhuras defeituosas ou tamanhos errados, sinalizando um braço robótico para descartar o item defeituoso, garantindo qualidade sem intervenção humana.",
                              "finalVerifications": [
                                "Pode definir visão por computador em termos de extração de info de imagens para automação?",
                                "Descreve corretamente o pipeline: aquisição → processamento → decisão?",
                                "Cita pelo menos 2 aplicações mecatrônicas como inspeção industrial?",
                                "Identifica diferenças chave vs. visão humana?",
                                "Explica limitações como dependência de iluminação?",
                                "Integra conceito a sistemas mecatrônicos com PLC/robótica?"
                              ],
                              "assessmentCriteria": [
                                "Definição precisa e concisa (20%)",
                                "Descrição clara do funcionamento/pipeline (25%)",
                                "Exemplos relevantes em mecatrônica (20%)",
                                "Análise de aplicações e limitações (20%)",
                                "Uso de analogias e fluxogramas para clareza (10%)",
                                "Conexão com automação industrial (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de bibliotecas como OpenCV em Python para processamento.",
                                "Eletrônica: Integração com câmeras e interfaces como USB/I2C.",
                                "Matemática: Álgebra linear para transformações de imagens e filtros.",
                                "Física: Óptica e iluminação em aquisição de imagens.",
                                "Gestão Industrial: Otimização de processos via inspeção automatizada."
                              ],
                              "realWorldApplication": "Na indústria automotiva brasileira, sistemas de visão por computador inspecionam soldas e pinturas em linhas de montagem da Fiat ou Volkswagen, detectando defeitos em tempo real para evitar recalls caros e elevar padrões de qualidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.1.2",
                            "name": "Identificar componentes principais",
                            "description": "Listar e descrever os componentes essenciais: câmeras, processadores de imagem, software de análise e atuadores em integração mecatrônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e listar os componentes principais de um sistema de visão por computador",
                                  "subSteps": [
                                    "Acesse fontes confiáveis sobre sistemas de visão por computador, como livros de mecatrônica ou sites especializados (ex: IEEE, Robotics.org).",
                                    "Identifique os quatro componentes essenciais: câmeras/sensores, processadores de imagem, software de análise e atuadores.",
                                    "Anote definições breves para cada um em um documento ou caderno.",
                                    "Crie uma tabela simples com colunas: Componente, Função Principal, Exemplos.",
                                    "Compare com diagramas de sistemas reais para validar a lista."
                                  ],
                                  "verification": "Verifique se a lista contém exatamente os quatro componentes mencionados e se há pelo menos uma definição curta para cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Computador com internet, caderno ou editor de texto (Google Docs), diagramas de sistemas de visão (impressos ou digitais).",
                                  "tips": "Use palavras-chave como 'componentes sistema visão computacional mecatrônica' em buscas para resultados precisos.",
                                  "learningObjective": "Compreender e listar os componentes fundamentais de um sistema de visão por computador.",
                                  "commonMistakes": "Confundir sensores com atuadores ou omitir o software de análise."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever detalhadamente câmeras e processadores de imagem",
                                  "subSteps": [
                                    "Estude câmeras: tipos (CCD, CMOS), resolução, taxa de frames e papel na captura de imagens.",
                                    "Descreva processadores de imagem: hardware como FPGA ou GPU, funções de pré-processamento (filtragem, binarização).",
                                    "Registre exemplos: câmera industrial Cognex para inspeção, NVIDIA Jetson para processamento.",
                                    "Desenhe um fluxograma simples mostrando captura → processamento.",
                                    "Teste compreensão respondendo: 'Qual a diferença entre CCD e CMOS?'."
                                  ],
                                  "verification": "Crie um resumo de 100 palavras por componente e valide com uma fonte secundária.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Vídeos tutoriais (YouTube: 'câmeras visão computacional'), processadores como Raspberry Pi docs.",
                                  "tips": "Assista a um vídeo de 5 minutos sobre cada para visualização prática.",
                                  "learningObjective": "Dominar as características técnicas de câmeras e processadores de imagem.",
                                  "commonMistakes": "Ignorar diferenças de hardware ou superestimar software sem hardware dedicado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar software de análise e atuadores na integração mecatrônica",
                                  "subSteps": [
                                    "Analise software: bibliotecas como OpenCV, algoritmos (detecção de bordas, OCR), linguagens (Python, C++).",
                                    "Descreva atuadores: motores, servos, braços robóticos acionados por comandos de visão.",
                                    "Estude integração: visão detecta objeto → software processa → sinal para atuador.",
                                    "Exemplo: robô pick-and-place onde visão guia o gripper.",
                                    "Anote desafios de integração como latência e sincronização."
                                  ],
                                  "verification": "Monte um diagrama de integração com setas mostrando fluxo de dados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Documentação OpenCV, exemplos de projetos Arduino com visão.",
                                  "tips": "Instale OpenCV demo para ver análise em ação.",
                                  "learningObjective": "Entender o papel do software e atuadores na cadeia completa.",
                                  "commonMistakes": "Subestimar latência entre visão e ação ou confundir análise com captura."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e diagramar o sistema completo",
                                  "subSteps": [
                                    "Compile todas as descrições em um relatório unificado.",
                                    "Crie um diagrama esquemático do sistema: câmera → processador → software → atuador.",
                                    "Simule verbalmente o fluxo: 'Câmera captura → processa → analisa → atua'.",
                                    "Compare com um sistema real (ex: linha de montagem automotiva).",
                                    "Revise e refine descrições para clareza."
                                  ],
                                  "verification": "Apresente o diagrama e relatório a um colega ou grave uma explicação de 2 minutos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramenta de diagrama (Draw.io, Lucidchart), relatório anterior.",
                                  "tips": "Use cores no diagrama: azul para hardware, verde para software.",
                                  "learningObjective": "Integrar conhecimentos em uma visão holística do sistema.",
                                  "commonMistakes": "Diagramas desconexos ou descrições genéricas sem exemplos."
                                }
                              ],
                              "practicalExample": "Em um sistema de inspeção de qualidade em uma fábrica de eletrônicos, identifique: câmera CMOS capturando defeitos em PCBs, processador Jetson filtrando ruído, OpenCV detectando falhas via edge detection, e atuador (braço robótico) rejeitando peças ruins.",
                              "finalVerifications": [
                                "Pode listar e nomear os quatro componentes principais sem hesitação?",
                                "Descreve corretamente funções de cada componente com exemplos?",
                                "Explica integração mecatrônica com fluxo lógico?",
                                "Identifica pelo menos um exemplo real por componente?",
                                "Cria diagrama preciso mostrando interconexões?",
                                "Responde perguntas sobre diferenças entre componentes?"
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos os componentes listados e descritos (30%)",
                                "Precisão técnica: Definições corretas sem erros conceituais (25%)",
                                "Detalhe e exemplos: Inclusão de exemplos práticos e diagramas (20%)",
                                "Clareza de integração: Explicação fluida do fluxo do sistema (15%)",
                                "Originalidade: Uso de linguagem própria, não copiada (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Sensores e processadores de sinal.",
                                "Programação: Desenvolvimento em OpenCV/Python.",
                                "Mecânica: Design de atuadores e robótica.",
                                "Matemática: Algoritmos de processamento de imagem (matrizes, filtros)."
                              ],
                              "realWorldApplication": "Em indústrias automotivas, sistemas de visão identificam componentes em linhas de montagem, processam imagens para detecção de erros e acionam robôs para correções, reduzindo desperdícios em 20-30%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.1.3",
                            "name": "Relacionar com mecatrônica",
                            "description": "Explicar como sistemas de visão por computador se integram a microcontroladores e CLPs em projetos de robótica industrial, citando exemplos da bibliografia como Lyshevski.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de sistemas de visão por computador e mecatrônica",
                                  "subSteps": [
                                    "Definir sistemas de visão por computador: câmeras, sensores de imagem, processamento de sinais e algoritmos de análise.",
                                    "Explicar componentes básicos: aquisição de imagem, pré-processamento, detecção de características e interpretação.",
                                    "Descrever mecatrônica como integração de mecânica, eletrônica, controle e informática em sistemas automatizados.",
                                    "Identificar pontos de interseção: uso de visão para feedback sensorial em sistemas mecatrônicos.",
                                    "Analisar exemplos iniciais de visão em robótica, como detecção de posição de peças."
                                  ],
                                  "verification": "Criar um diagrama simples ilustrando componentes de visão e sua relação com mecatrônica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Nano and Micro Electromechanical Systems' de S. Lyshevski (capítulos iniciais)",
                                    "Vídeos introdutórios sobre visão computacional no YouTube (canal freeCodeCamp)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Comece com analogias cotidianas, como olhos humanos em máquinas.",
                                    "Use imagens reais de câmeras industriais para visualização."
                                  ],
                                  "learningObjective": "Entender os conceitos básicos e identificar sinergias entre visão computacional e mecatrônica.",
                                  "commonMistakes": [
                                    "Confundir visão computacional com visão humana simples.",
                                    "Ignorar o papel do processamento em tempo real."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar microcontroladores e CLPs em contextos industriais",
                                  "subSteps": [
                                    "Explicar microcontroladores: características (ex: Arduino, ESP32), programação em C/Python e interfaces (I2C, SPI, UART).",
                                    "Descrever CLPs: função em automação (ex: Siemens S7), linguagens (Ladder, FBD) e protocolos de comunicação (Modbus, Profibus).",
                                    "Comparar papéis: microcontroladores para processamento rápido de visão, CLPs para controle lógico de segurança.",
                                    "Explorar exemplos de Lyshevski sobre sistemas eletromecânicos integrados.",
                                    "Listar vantagens: escalabilidade e robustez em ambientes industriais."
                                  ],
                                  "verification": "Montar uma tabela comparativa entre microcontroladores e CLPs com exemplos de uso.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação Arduino oficial",
                                    "Manual de CLP Siemens (PDF gratuito)",
                                    "Capítulo de Lyshevski sobre microtecnologia e automação"
                                  ],
                                  "tips": [
                                    "Pratique com simuladores como Tinkercad para microcontroladores.",
                                    "Foque em protocolos de comunicação reais."
                                  ],
                                  "learningObjective": "Dominar as capacidades e limitações de microcontroladores e CLPs para integração.",
                                  "commonMistakes": [
                                    "Subestimar latência em comunicações entre dispositivos.",
                                    "Confundir microcontroladores com processadores de PC."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a integração técnica de sistemas de visão com microcontroladores e CLPs",
                                  "subSteps": [
                                    "Descrever fluxo de dados: câmera captura imagem → microcontrolador processa (OpenCV) → envia comandos ao CLP.",
                                    "Explicar protocolos: uso de Ethernet/IP ou serial para troca de dados em tempo real.",
                                    "Detalhar controle fechado: visão fornece feedback para atuadores controlados por CLP (ex: ajuste de posição robótica).",
                                    "Simular integração: pseudocódigo para detecção de objeto e acionamento.",
                                    "Referenciar Lyshevski: exemplos de feedback sensorial em sistemas mecatrônicos nano/micro."
                                  ],
                                  "verification": "Desenhar um fluxograma completo da integração com setas e protocolos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software OpenCV (instalação gratuita)",
                                    "Simulador CLP como PLCSIM",
                                    "Artigos sobre integração visão-PLC (IEEE Xplore)"
                                  ],
                                  "tips": [
                                    "Teste com hardware simples como Raspberry Pi + Arduino.",
                                    "Priorize processamento edge para reduzir latência."
                                  ],
                                  "learningObjective": "Mapear tecnicamente como visão se integra a microcontroladores e CLPs.",
                                  "commonMistakes": [
                                    "Ignorar sincronização temporal entre visão e controle.",
                                    "Não considerar ruído em imagens industriais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar aplicações em robótica industrial com exemplos bibliográficos",
                                  "subSteps": [
                                    "Citar Lyshevski: integração em robótica precisa para manufatura (ex: sistemas eletromecânicos com sensores visuais).",
                                    "Analisar casos: robôs pick-and-place com visão para localização de peças.",
                                    "Discutir desafios: iluminação variável, velocidade e precisão em linhas de produção.",
                                    "Relacionar a mecatrônica: otimização de sistemas híbridos para Indústria 4.0.",
                                    "Prever evoluções: IA embarcada em microcontroladores para visão avançada."
                                  ],
                                  "verification": "Redigir um parágrafo explicativo citando Lyshevski e um exemplo industrial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro completo de Lyshevski",
                                    "Casos de estudo da ABB ou Fanuc em robótica",
                                    "Vídeos de robótica industrial no YouTube"
                                  ],
                                  "tips": [
                                    "Busque citações exatas de Lyshevski para precisão acadêmica.",
                                    "Conecte teoria a vídeos reais de fábricas."
                                  ],
                                  "learningObjective": "Aplicar conhecimentos em contextos reais e bibliográficos.",
                                  "commonMistakes": [
                                    "Generalizar sem exemplos específicos.",
                                    "Não citar fontes corretamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de automóveis, uma câmera industrial captura imagens de parafusos; um microcontrolador Raspberry Pi processa a imagem com OpenCV para detectar desalinhamentos e envia sinal via Modbus para um CLP Siemens, que aciona um braço robótico para correção automática, conforme exemplos de sistemas mecatrônicos em Lyshevski.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo de integração visão-microcontrolador-CLP.",
                                "Desenhar diagrama funcional correto.",
                                "Citar pelo menos dois exemplos de Lyshevski.",
                                "Identificar um protocolo de comunicação apropriado.",
                                "Simular um cenário de falha e solução.",
                                "Relacionar a um projeto mecatrônico real."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição da integração (nota 1-10).",
                                "Profundidade de exemplos bibliográficos (Lyshevski).",
                                "Clareza no fluxograma ou diagrama.",
                                "Capacidade de identificar desafios reais (latência, ruído).",
                                "Conexão explícita com robótica industrial.",
                                "Criatividade em aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Interfaces de comunicação (I2C, Ethernet).",
                                "Programação: Algoritmos de visão (OpenCV em Python/C++).",
                                "Controle Automático: Loops de feedback com CLPs.",
                                "Física/Óptica: Princípios de imagem e sensores.",
                                "Indústria 4.0: IoT e automação inteligente."
                              ],
                              "realWorldApplication": "Na indústria automotiva (ex: fábricas da Volkswagen), sistemas de visão integrados a CLPs e microcontroladores realizam inspeção de soldas em tempo real, reduzindo defeitos em 30% e aumentando eficiência produtiva, como descrito em obras de Lyshevski sobre mecatrônica avançada."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.1.2",
                        "name": "Princípios de Captura de Imagens",
                        "description": "Processo inicial de aquisição de dados visuais por meio de sensores, fundamental para sistemas de visão em ambientes mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.2.1",
                            "name": "Descrever sensores de imagem",
                            "description": "Explicar o funcionamento de sensores CCD e CMOS, incluindo resolução, taxa de frames e ruído, aplicados em projetos aeronáuticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os princípios básicos de sensores de imagem",
                                  "subSteps": [
                                    "Pesquisar a conversão de luz em sinal elétrico por pixels sensíveis à luz.",
                                    "Identificar os componentes principais: fotodiodos, matriz de pixels e circuitry de readout.",
                                    "Comparar sensores de imagem com o olho humano para analogia.",
                                    "Estudar o processo de fotodetecção e geração de elétrons.",
                                    "Revisar unidades básicas: lux, electrons por pixel."
                                  ],
                                  "verification": "Resumir em 3 frases os princípios básicos e desenhar um diagrama simples de um pixel.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama de sensor de imagem (imprimir ou digital)",
                                    "Vídeo introdutório sobre fotodetecção (YouTube: 'How Image Sensors Work')",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias visuais como 'pixels como células receptoras de luz' para fixar conceitos.",
                                  "learningObjective": "Compreender como sensores convertem luz em dados digitais.",
                                  "commonMistakes": "Confundir fotodiodos com LEDs; ignorar a importância da matriz 2D."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o funcionamento de sensores CCD",
                                  "subSteps": [
                                    "Descrever o processo de charge transfer: acumulação, transferência e readout.",
                                    "Explicar o papel de gates de polísilício e clocks de três fases.",
                                    "Analisar blooming e smearing como artefatos comuns.",
                                    "Calcular exemplo simples de resolução em megapixels.",
                                    "Comparar eficiência quântica de CCD com sensores ideais."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o ciclo de transferência de carga em um CCD.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Animação interativa de CCD (site: howstuffworks.com)",
                                    "Datasheet de um sensor CCD (ex: Sony ICX series)",
                                    "Simulador online de charge transfer"
                                  ],
                                  "tips": "Visualize o fluxo de elétrons como uma 'fila indiana' se movendo pixel a pixel.",
                                  "learningObjective": "Dominar o mecanismo de transferência de carga no CCD.",
                                  "commonMistakes": "Achar que CCD lê todos pixels simultaneamente; subestimar impacto de ruído térmico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o funcionamento de sensores CMOS",
                                  "subSteps": [
                                    "Descrever arquitetura ativa por pixel (3T ou 4T).",
                                    "Explicar readout paralelo versus serial do CCD.",
                                    "Analisar pixel amplifiers e conversores A/D por coluna.",
                                    "Discutir fixed pattern noise (FPN) e correção.",
                                    "Comparar consumo de energia e velocidade de CMOS vs CCD."
                                  ],
                                  "verification": "Criar tabela comparativa de 5 diferenças chave entre CMOS e CCD.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Datasheet CMOS (ex: OmniVision OV series)",
                                    "Vídeo: 'CMOS vs CCD Sensors' (YouTube)",
                                    "Ferramenta de comparação online"
                                  ],
                                  "tips": "Pense em CMOS como 'cada pixel tem seu próprio amplificador' para velocidade.",
                                  "learningObjective": "Entender a arquitetura paralela e eficiência de CMOS.",
                                  "commonMistakes": "Confundir rolling shutter com global shutter; ignorar variações em eficiência quântica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar parâmetros chave: resolução, taxa de frames e ruído",
                                  "subSteps": [
                                    "Definir resolução (pixels, megapixels, densidade espacial).",
                                    "Explicar frame rate (fps) e limitações por readout.",
                                    "Classificar ruído: shot, thermal, read, FPN; calcular SNR.",
                                    "Relacionar parâmetros em trade-offs (ex: alta fps aumenta ruído).",
                                    "Simular impacto em imagens com ferramentas básicas."
                                  ],
                                  "verification": "Resolver 3 problemas numéricos: calcular fps máx, estimar ruído em low light.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou Python script simples para SNR",
                                    "Imagens de exemplo com ruído (banco de imagens)",
                                    "Tabela de specs de sensores"
                                  ],
                                  "tips": "Use fórmula SNR = sinal / sqrt(ruído) para quantificar.",
                                  "learningObjective": "Quantificar e inter-relacionar resolução, fps e ruído.",
                                  "commonMistakes": "Medir resolução só em pixels sem densidade; ignorar dependência de luz em ruído."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar conceitos em projetos aeronáuticos",
                                  "subSteps": [
                                    "Identificar usos: drones para inspeção, câmeras em UAVs.",
                                    "Escolher sensor ideal (CCD para low noise em alta altitude, CMOS para high fps).",
                                    "Analisar desafios: vibração, baixa luz, alta dinâmica.",
                                    "Estudar case: sensor em drone de vigilância.",
                                    "Propor melhoria em projeto hipotético."
                                  ],
                                  "verification": "Escrever parágrafo descrevendo escolha de sensor para drone aeronáutico com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Case study: 'Image sensors in UAVs' (artigo PDF)",
                                    "Especs de câmeras drone (DJI models)",
                                    "Vídeo de drone com visão"
                                  ],
                                  "tips": "Considere ambiente: alta altitude = mais ruído térmico.",
                                  "learningObjective": "Contextualizar sensores em aplicações aeronáuticas reais.",
                                  "commonMistakes": "Subestimar vibração afetando frame rate; escolher CCD por default sem trade-offs."
                                }
                              ],
                              "practicalExample": "Em um drone de inspeção aeronáutica, use um sensor CMOS de 1080p a 60fps para capturar frames de turbinas em movimento, minimizando ruído com correção FPN para detectar rachaduras em baixa luz.",
                              "finalVerifications": [
                                "Explicar diferença fundamental entre readout CCD e CMOS.",
                                "Calcular resolução efetiva de um sensor 1/2.3\" com 12MP.",
                                "Identificar causa principal de ruído em alta fps.",
                                "Propor sensor para UAV noturno e justificar.",
                                "Desenhar diagrama simplificado de pixel CMOS 4T.",
                                "Discutir trade-off resolução vs frame rate em aeronáutica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de mecanismos CCD/CMOS (80% corretude).",
                                "Compreensão quantitativa de resolução, fps e ruído (cálculos corretos).",
                                "Relevância de exemplos aeronáuticos (aplicação contextual).",
                                "Clareza em comparações e trade-offs.",
                                "Uso correto de terminologia técnica.",
                                "Capacidade de verificação própria via diagramas/resumos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Óptica e fotoeletricidade.",
                                "Eletrônica: Circuitos analógicos e A/D conversion.",
                                "Programação: Processamento de imagens em OpenCV.",
                                "Engenharia Aeronáutica: Sistemas embarcados em UAVs."
                              ],
                              "realWorldApplication": "Sensores CCD/CMOS são usados em câmeras de drones para monitoramento de infraestrutura aeronáutica, como inspeção de asas de aviões e navegação autônoma em UAVs militares, onde alta resolução detecta defeitos minúsculos e low ruído garante precisão em condições variáveis de luz e vibração."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2.2",
                            "name": "Entender aquisição de dados visuais",
                            "description": "Detalhar etapas de captura: iluminação, lentes e digitalização analógico-digital em sistemas embarcados com microprocessadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o impacto da iluminação na captura de imagens",
                                  "subSteps": [
                                    "Estude os tipos de iluminação: natural, artificial (LED, halogênio) e suas propriedades espectrais.",
                                    "Analise como a iluminação afeta contraste, sombras e ruído na imagem.",
                                    "Experimente variar intensidade e ângulo de luz em uma cena simples.",
                                    "Identifique fontes de iluminação ideais para sistemas embarcados (baixa potência).",
                                    "Registre observações sobre saturação e subexposição."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como diferentes iluminações alteram a qualidade da imagem, com exemplos fotográficos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Fontes de luz variadas (lanterna LED, luz ambiente), smartphone ou câmera simples, papel e caneta para anotações.",
                                  "tips": "Use um espectrômetro app no celular para medir espectro de luz.",
                                  "learningObjective": "Dominar como iluminação influencia a qualidade dos dados visuais iniciais.",
                                  "commonMistakes": "Ignorar reflexos especulares ou superestimar iluminação ambiente em ambientes escuros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o papel das lentes na formação da imagem",
                                  "subSteps": [
                                    "Descreva componentes ópticos: distância focal, abertura (f-stop) e profundidade de campo.",
                                    "Simule ou teste distorções: barrel, pincushion e aberrações cromáticas.",
                                    "Calcule campo de visão (FOV) para lentes comuns em sistemas embarcados.",
                                    "Compare lentes fixas vs. zoom em aplicações mecatrônicas.",
                                    "Monte uma configuração simples com lente removível."
                                  ],
                                  "verification": "Desenhe um diagrama óptico explicando como a lente foca a luz no sensor.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Lentes de câmera desmontáveis ou kit óptico, régua, software de simulação óptica (como OpticStudio free trial).",
                                  "tips": "Comece com equação básica: FOV = 2 * atan(sensor_width / (2 * focal_length)).",
                                  "learningObjective": "Entender como lentes moldam os dados visuais ópticos.",
                                  "commonMistakes": "Confundir distância focal com comprimento da lente ou ignorar vignetting nas bordas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o processo de digitalização analógico-digital (A/D)",
                                  "subSteps": [
                                    "Explique o funcionamento de sensores CCD/CMOS: pixels, charge transfer e readout.",
                                    "Detalhe conversores A/D: resolução (bits), taxa de amostragem e ruído de quantização.",
                                    "Simule sinal analógico para digital com ferramentas online.",
                                    "Discuta impacto de clock speed em sistemas embarcados.",
                                    "Meça SNR (signal-to-noise ratio) em uma imagem capturada."
                                  ],
                                  "verification": "Gere uma imagem e calcule sua profundidade de bits usando software como ImageJ.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Câmera digital ou módulo como OV7670, osciloscópio simulado (Multisim), computador com Python/OpenCV.",
                                  "tips": "Use fórmula de quantização: step_size = full_scale / 2^n_bits.",
                                  "learningObjective": "Compreender a conversão de sinal visual analógico em dados digitais.",
                                  "commonMistakes": "Subestimar aliasing sem filtro anti-aliasing ou ignorar crosstalk entre pixels."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar componentes em sistemas embarcados com microprocessadores",
                                  "subSteps": [
                                    "Descreva pipeline: sensor -> A/D -> microprocessador (ex: ARM Cortex em Raspberry Pi).",
                                    "Programe captura básica de frame via I2C/SPI.",
                                    "Otimize para latência e consumo em tempo real.",
                                    "Teste integração com iluminação e lentes personalizadas.",
                                    "Debugue falhas comuns como sincronização de clock."
                                  ],
                                  "verification": "Capture e exiba uma imagem processada em microprocessador, medindo tempo de aquisição.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Placa Raspberry Pi ou Arduino com câmera module, jumper wires, código Python/C++ pronto.",
                                  "tips": "Inicie com bibliotecas como picamera ou ArduCAM para prototipagem rápida.",
                                  "learningObjective": "Aplicar conhecimentos em um sistema mecatrônico completo de visão.",
                                  "commonMistakes": "Sobrecarregar buffer DMA ou ignorar gerenciamento de energia no embarcado."
                                }
                              ],
                              "practicalExample": "Monte um sistema de visão embarcado em Raspberry Pi 4 com módulo câmera OV5647: ajuste iluminação LED para detectar objetos em linha de produção simulada, usando lentes de 3.6mm para FOV de 60°, capture frames a 30fps via A/D 10-bit e processe no microprocessador para detecção de bordas simples.",
                              "finalVerifications": [
                                "Explicar pipeline completo de aquisição visual em 5 minutos.",
                                "Identificar e corrigir falhas em uma imagem de teste (ex: subexposição).",
                                "Calcular métricas: resolução espacial, profundidade de cor e latência.",
                                "Demonstrar captura em embarcado com variações de luz/lente.",
                                "Comparar qualidade de imagem antes/depois de otimizações.",
                                "Listar 3 limitações em sistemas reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de iluminação, óptica e A/D (80%+ acerto em quiz).",
                                "Qualidade da integração prática (imagem clara, sem artefatos >5%).",
                                "Profundidade dos substeps executados (todos com evidências).",
                                "Análise de erros comuns e correções aplicadas.",
                                "Tempo respeitado e eficiência no pipeline embarcado.",
                                "Criatividade em conexões interdisciplinares."
                              ],
                              "crossCurricularConnections": [
                                "Física Óptica: Leis de refração e difração de luz.",
                                "Eletrônica: Circuitos de sensores e conversores A/D.",
                                "Programação: Algoritmos de processamento de imagem em C/Python.",
                                "Matemática: Cálculos de FOV, SNR e transformadas Fourier.",
                                "Engenharia de Controle: Feedback em sistemas de visão autônomos."
                              ],
                              "realWorldApplication": "Em robôs industriais para inspeção visual de peças (ex: detecção de defeitos em linhas de montagem automotiva), drones para mapeamento topográfico com câmeras embarcadas, ou veículos autônomos processando imagens em tempo real via microprocessadores para navegação segura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2.3",
                            "name": "Analisar fatores de influência",
                            "description": "Identificar impactos de luz, distância e movimento na qualidade da imagem capturada em aplicações industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos teóricos dos fatores de influência",
                                  "subSteps": [
                                    "Estude o impacto da iluminação: explique como intensidade, cor e direção da luz afetam contraste e exposição da imagem.",
                                    "Analise o efeito da distância: descreva como a distância entre câmera e objeto altera resolução, distorção e profundidade de campo.",
                                    "Revise o influência do movimento: identifique borrões de movimento, lag e requisitos de velocidade de obturador em cenários dinâmicos.",
                                    "Relacione os fatores à qualidade da imagem: defina métricas como nitidez, ruído e precisão em aplicações industriais.",
                                    "Compile um glossário com termos chave como 'exposição', 'foco' e 'frame rate'."
                                  ],
                                  "verification": "Criar um mapa conceitual resumindo os três fatores e seus impactos, revisado por um colega ou tutor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de visão computacional, slides ou vídeo tutoriais sobre óptica básica, papel e caneta para mapa conceitual.",
                                  "tips": "Use diagramas visuais para ilustrar cada fator, facilitando a retenção.",
                                  "learningObjective": "Dominar a teoria por trás de luz, distância e movimento na captura de imagens.",
                                  "commonMistakes": "Confundir iluminação com cor da luz sem considerar espectro; ignorar interações entre fatores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar experimentos controlados com iluminação",
                                  "subSteps": [
                                    "Configure uma estação com câmera fixa e objeto imóvel, variando intensidade luminosa (baixa, média, alta).",
                                    "Capture imagens em diferentes condições de luz (direta, difusa, colorida) e anote observações qualitativas.",
                                    "Meça quantitativamente: use software para calcular contraste, brilho e ruído nas imagens.",
                                    "Compare imagens lado a lado e identifique thresholds ideais para aplicações industriais.",
                                    "Documente fotos antes/depois com anotações sobre qualidade."
                                  ],
                                  "verification": "Produzir relatório com 5 imagens comparativas e gráficos de métricas de qualidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Câmera industrial ou webcam, fontes de luz ajustáveis (LEDs), objeto de teste (peça mecânica), software como ImageJ ou OpenCV.",
                                  "tips": "Mantenha outros fatores constantes para isolar o efeito da luz.",
                                  "learningObjective": "Identificar empiricamente impactos da luz na qualidade da imagem.",
                                  "commonMistakes": "Não calibrar a câmera white balance, levando a resultados enviesados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar efeitos de distância e movimento",
                                  "subSteps": [
                                    "Teste distâncias variáveis: fixe luz e capture imagens em 10cm, 50cm e 1m de um objeto.",
                                    "Simule movimento: mova o objeto ou câmera em velocidades baixas/médias/altas, capturando sequências.",
                                    "Analise imagens para distorção, borrão e perda de resolução usando ferramentas de medição.",
                                    "Calcule métricas como resolução espacial e velocidade mínima detectável.",
                                    "Registre dados em tabela comparativa."
                                  ],
                                  "verification": "Gerar tabela de dados com pelo menos 9 cenários (3 distâncias x 3 velocidades) e conclusões.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "Câmera com suporte ajustável, trilho para movimento, cronômetro, software de análise de vídeo.",
                                  "tips": "Use marcações no objeto para quantificar borrão de movimento precisamente.",
                                  "learningObjective": "Quantificar impactos de distância e movimento na captura industrial.",
                                  "commonMistakes": "Movimento irregular sem controle de velocidade; foco manual inconsistente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar análises e propor otimizações industriais",
                                  "subSteps": [
                                    "Sintetize resultados: identifique interações entre luz, distância e movimento.",
                                    "Proponha configurações ótimas para cenários industriais (ex: linha de montagem rápida).",
                                    "Simule falhas comuns e soluções (ex: compensação de movimento via software).",
                                    "Crie um checklist de verificação para setups de visão.",
                                    "Apresente achados em formato relatorial."
                                  ],
                                  "verification": "Desenvolver um plano de otimização validado por simulação ou teste rápido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel para síntese, software de simulação de visão (opcional).",
                                  "tips": "Priorize trade-offs, como alta velocidade vs. qualidade em ambientes industriais.",
                                  "learningObjective": "Aplicar análises para melhorar sistemas de visão reais.",
                                  "commonMistakes": "Ignorar custos ou viabilidade prática das otimizações."
                                }
                              ],
                              "practicalExample": "Em uma fábrica de automóveis, analisar como variações de luz ambiente em uma linha de inspeção de soldas afetam a detecção de defeitos: testar luzes LED direcionais para reduzir sombras, ajustar distância da câmera para 30cm otimizada e sincronizar frame rate com velocidade da esteira para eliminar borrões.",
                              "finalVerifications": [
                                "Capacidade de prever qualitativamente o impacto de mudanças em luz/distância/movimento.",
                                "Produção de imagens de alta qualidade em pelo menos 80% dos testes controlados.",
                                "Checklist completo de fatores com métricas quantificadas.",
                                "Relatório com gráficos e conclusões acionáveis.",
                                "Demonstração de otimização em setup simulado industrial.",
                                "Autoavaliação correta de forças e fraquezas nos experimentos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de impactos teóricos (30%)",
                                "Qualidade e completude dos experimentos práticos (25%)",
                                "Análise quantitativa rigorosa com métricas (20%)",
                                "Relevância das otimizações para contexto industrial (15%)",
                                "Clareza e organização do relatório final (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de óptica e dinâmica (movimento).",
                                "Matemática: Cálculo de resolução e análise estatística de ruído.",
                                "Programação: Uso de bibliotecas como OpenCV para processamento de imagens.",
                                "Engenharia Industrial: Otimização de processos de manufatura."
                              ],
                              "realWorldApplication": "Em inspeções de qualidade em linhas de produção mecatrônicas, como detecção de falhas em PCBs ou montagem robótica, onde ajustes precisos em câmeras evitam falsos positivos/negativos, reduzindo desperdícios e aumentando eficiência operacional."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.1.3",
                        "name": "Princípios de Interpretação de Imagens",
                        "description": "Técnicas para processar e extrair significado das imagens capturadas, base para decisões autônomas em sistemas mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.3.1",
                            "name": "Explicar processamento básico de imagens",
                            "description": "Descrever operações como filtragem, binarização e detecção de bordas usando algoritmos simples em microcontroladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Imagens Digitais",
                                  "subSteps": [
                                    "Aprenda o conceito de pixel como unidade básica de uma imagem digital.",
                                    "Estude representações de imagens em escala de cinza e RGB.",
                                    "Compreenda matrizes de pixels e resolução de imagem.",
                                    "Explore ruído em imagens e necessidade de processamento.",
                                    "Pratique visualizando imagens em software simples."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito os componentes de uma imagem digital, incluindo um exemplo de matriz de pixels.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Computador com visualizador de imagens",
                                    "Software gratuito como GIMP ou Paint",
                                    "Imagens de exemplo em escala de cinza"
                                  ],
                                  "tips": "Use imagens pequenas (ex: 64x64 pixels) para facilitar a compreensão inicial.",
                                  "learningObjective": "Compreender a estrutura básica de imagens digitais para basear operações de processamento.",
                                  "commonMistakes": "Confundir canais RGB com escala de cinza; assumir que todas as imagens são coloridas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar Filtragem de Imagens",
                                  "subSteps": [
                                    "Defina filtragem como convolução com kernel (ex: média, gaussiano).",
                                    "Descreva filtro de média para suavização de ruído.",
                                    "Explique filtro de realce como Laplace ou high-pass.",
                                    "Implemente manualmente um filtro 3x3 em uma matriz pequena.",
                                    "Discuta impacto no desempenho em microcontroladores (custo computacional)."
                                  ],
                                  "verification": "Aplique um filtro de média manual em uma matriz 5x5 e compare antes/depois.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para cálculos manuais",
                                    "Planilha Excel ou Python simples para simulação",
                                    "Exemplos de kernels impressos"
                                  ],
                                  "tips": "Comece com kernels simétricos para evitar erros de orientação.",
                                  "learningObjective": "Dominar operações de filtragem e seu papel na pré-processamento de imagens.",
                                  "commonMistakes": "Ignorar normalização do kernel, resultando em valores incorretos; confundir suavização com realce."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Binarização de Imagens",
                                  "subSteps": [
                                    "Defina binarização como thresholding para converter em preto e branco.",
                                    "Estude métodos: threshold fixo, Otsu e adaptativo.",
                                    "Aplique threshold em imagem filtrada para segmentação.",
                                    "Discuta histograma para escolha de threshold.",
                                    "Avalie efeitos em microcontroladores com memória limitada."
                                  ],
                                  "verification": "Binarize uma imagem de exemplo usando threshold 128 e justifique a escolha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de processamento como ImageJ",
                                    "Imagens com ruído para teste",
                                    "Calculadora para histograma"
                                  ],
                                  "tips": "Sempre filtre antes de binarizar para melhorar resultados.",
                                  "learningObjective": "Compreender binarização como etapa chave para simplificação e análise.",
                                  "commonMistakes": "Escolher threshold inadequado sem histograma; binarizar imagens coloridas diretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Detecção de Bordas",
                                  "subSteps": [
                                    "Introduza detecção de bordas como identificação de mudanças abruptas de intensidade.",
                                    "Descreva operador Sobel para gradientes horizontais e verticais.",
                                    "Calcule magnitude e direção da borda.",
                                    "Aplique não-máximo supressão e threshold para bordas finas.",
                                    "Adapte para microcontroladores: use kernels 3x3 otimizados."
                                  ],
                                  "verification": "Compute manualmente Sobel em uma pequena região de imagem e desenhe as bordas detectadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Matrizes de exemplo impressas",
                                    "Ferramenta online como Sobel edge detector demo",
                                    "Código Arduino básico para simulação"
                                  ],
                                  "tips": "Combine com binarização prévia para reduzir falsos positivos.",
                                  "learningObjective": "Mestre algoritmos simples de detecção de bordas aplicáveis em hardware embarcado.",
                                  "commonMistakes": "Esquecer de calcular magnitude (sqrt(Gx^2 + Gy^2)); processar bordas sem suavização prévia."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Processamento em Microcontroladores",
                                  "subSteps": [
                                    "Discuta limitações: memória RAM, velocidade de clock.",
                                    "Esboce pipeline: captura > filtragem > binarização > bordas.",
                                    "Implemente pseudocódigo para Arduino/ESP32 com câmera OV7670.",
                                    "Otimize: use imagens de baixa resolução, kernels fixos.",
                                    "Teste com sensor real ou simulador."
                                  ],
                                  "verification": "Escreva e execute um pseudocódigo que processe uma imagem 32x32 completa.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Arduino IDE",
                                    "Câmera módulo compatível ou simulador online",
                                    "Documentação de bibliotecas como ESP32-CAM"
                                  ],
                                  "tips": "Use arrays fixos em vez de dinâmicos para economizar memória.",
                                  "learningObjective": "Aplicar conceitos de processamento em contextos reais de mecatrônica.",
                                  "commonMistakes": "Sobrecarregar o microcontrolador com imagens grandes; ignorar delays de captura."
                                }
                              ],
                              "practicalExample": "Em um robô seguidor de linha, capture imagem da linha via câmera OV7670 no ESP32, aplique filtragem média para remover ruído, binarize com threshold adaptativo para isolar a linha preta, detecte bordas com Sobel para centralizar o robô, tudo em tempo real com 320x240 pixels downscaled para 32x32.",
                              "finalVerifications": [
                                "Descreva o pipeline completo: filtragem > binarização > detecção de bordas.",
                                "Explique como um kernel 3x3 de média é aplicado via convolução.",
                                "Justifique threshold em binarização usando histograma.",
                                "Calcule Sobel em pelo menos um pixel exemplo.",
                                "Liste 3 otimizações para microcontroladores.",
                                "Desenhe diagrama de fluxo de processamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção técnica nas descrições de algoritmos.",
                                "Capacidade de relacionar operações matemáticas com implementação hardware.",
                                "Profundidade nos subpassos, com exemplos numéricos.",
                                "Clareza na explicação de verificações e erros comuns.",
                                "Integração coerente de todos os steps em uma visão unificada.",
                                "Relevância ao contexto de mecatrônica e microcontroladores."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações de convolução e gradientes (cálculo matricial).",
                                "Programação: Manipulação de arrays 2D e otimização de loops.",
                                "Eletrônica: Interfaces de sensores de imagem (I2C/SPI em microcontroladores).",
                                "Física: Princípios ópticos de formação de imagens e ruído.",
                                "Engenharia de Software: Pipelines de processamento em tempo real."
                              ],
                              "realWorldApplication": "Sistemas de inspeção industrial para detecção de defeitos em peças via câmeras embarcadas; robótica autônoma para navegação por visão (ex: drones ou AGVs); controle de qualidade em linhas de montagem mecatrônicas com microcontroladores como ESP32."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.1.3.2",
                            "name": "Identificar técnicas de segmentação",
                            "description": "Entender segmentação por limiar e regiões para separar objetos de fundo em inspeções mecatrônicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Segmentação de Imagens",
                                  "subSteps": [
                                    "Defina segmentação de imagens como o processo de dividir uma imagem em regiões ou objetos significativos.",
                                    "Explique a importância de separar objetos do fundo em inspeções mecatrônicas, como detecção de defeitos em peças.",
                                    "Identifique os desafios comuns, como variações de iluminação e ruído.",
                                    "Revise tipos principais: baseados em limiar, bordas e regiões.",
                                    "Analise um exemplo visual simples de imagem antes e depois da segmentação."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e desenhe um diagrama simples de segmentação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Apresentação de slides sobre segmentação, imagens de exemplo (JPEG/PNG), papel e caneta para diagramas.",
                                  "tips": "Use imagens reais de inspeção industrial para manter o foco prático.",
                                  "learningObjective": "Entender o propósito e os tipos básicos de segmentação para contextualizar técnicas específicas.",
                                  "commonMistakes": "Confundir segmentação com detecção de bordas; lembre-se que segmentação cria regiões homogêneas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Segmentação por Limiar (Thresholding)",
                                  "subSteps": [
                                    "Estude o histograma de uma imagem para entender distribuição de intensidades.",
                                    "Aplique limiar global: escolha um valor T onde pixels > T são objeto, ≤ T são fundo.",
                                    "Experimente limiar adaptativo para lidar com iluminação não uniforme.",
                                    "Implemente em software: use OpenCV para converter imagem em binária.",
                                    "Avalie resultados qualitativamente e com métricas como precisão de pixels."
                                  ],
                                  "verification": "Aplique thresholding em 2 imagens diferentes e compare resultados binários gerados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com OpenCV instalado, imagens de inspeção mecatrônica (ex: peças metálicas), Jupyter Notebook.",
                                  "tips": "Comece com imagens de alto contraste para sucesso inicial.",
                                  "learningObjective": "Aplicar e interpretar segmentação por limiar para separar objetos uniformes do fundo.",
                                  "commonMistakes": "Escolher limiar fixo sem analisar histograma, levando a sub ou super-segmentação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Segmentação por Regiões",
                                  "subSteps": [
                                    "Aprenda region growing: inicie de sementes e cresça regiões baseadas em similaridade.",
                                    "Estude watershed: modele como inundação para separar regiões tocantes.",
                                    "Compare com split-and-merge: divida imagem e mescle regiões semelhantes.",
                                    "Implemente region growing simples em código ou ferramenta gráfica.",
                                    "Teste em imagens com objetos irregulares ou sobrepostos."
                                  ],
                                  "verification": "Gere uma máscara segmentada por regiões em uma imagem complexa e rotule 3 regiões.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "Python/OpenCV ou ImageJ, conjunto de imagens com ruído e objetos irregulares.",
                                  "tips": "Escolha sementes manualmente primeiro para entender o processo iterativo.",
                                  "learningObjective": "Identificar e aplicar métodos regionais para segmentação em cenários com gradientes de intensidade.",
                                  "commonMistakes": "Ignorar critérios de similaridade, causando vazamento de regiões entre objetos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Técnicas e Identificar Aplicações em Mecatrônica",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: prós/contras de limiar vs. regiões (velocidade, robustez, etc.).",
                                    "Analise casos: limiar para peças uniformes, regiões para soldas irregulares.",
                                    "Simule inspeção: segmente imagem de linha de produção e identifique objetos.",
                                    "Discuta hibridizações e limitações em tempo real.",
                                    "Documente critérios para escolher técnica baseada no contexto."
                                  ],
                                  "verification": "Classifique 5 imagens mecatrônicas e justifique a técnica ideal para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela comparativa em Excel/Google Sheets, 5 imagens de inspeção industrial.",
                                  "tips": "Pense em requisitos mecatrônicos como velocidade e precisão em produção.",
                                  "learningObjective": "Diferenciar e selecionar técnicas de segmentação adequadas para inspeções específicas.",
                                  "commonMistakes": "Generalizar uma técnica para todos os casos; sempre avalie o contexto da imagem."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de motores elétricos, use segmentação por limiar para isolar rotores metálicos brilhantes do fundo escuro, e segmentação por regiões para detectar rachaduras irregulares em carcaças de alumínio, permitindo inspeção automatizada de defeitos.",
                              "finalVerifications": [
                                "Explique com precisão a diferença entre segmentação por limiar e por regiões.",
                                "Aplique ambas técnicas em uma imagem fornecida e produza máscaras corretas.",
                                "Identifique corretamente a técnica ideal para 4 cenários mecatrônicos variados.",
                                "Crie um histograma e selecione limiar ótimo para uma imagem de teste.",
                                "Descreva prós e contras de cada método em contexto industrial.",
                                "Simule uma inspeção real segmentando objetos de fundo em vídeo curto."
                              ],
                              "assessmentCriteria": [
                                "Compreensão conceitual: 25% (definições e diferenças claras).",
                                "Habilidade prática: 30% (implementação correta em software).",
                                "Análise crítica: 20% (seleção adequada de técnicas por contexto).",
                                "Precisão nos resultados: 15% (máscaras sem erros graves).",
                                "Documentação: 10% (explicações claras e tabelas comparativas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de histogramas e estatísticas de intensidade de pixels.",
                                "Programação: Implementação em Python/OpenCV para processamento de imagens.",
                                "Física: Compreensão de óptica e iluminação em sistemas de visão.",
                                "Engenharia de Controle: Integração com atuadores para rejeição de peças defeituosas."
                              ],
                              "realWorldApplication": "Na indústria automotiva, segmentação por limiar detecta parafusos ausentes em chassis, enquanto métodos regionais identificam soldas defeituosas em carrocerias, otimizando inspeção de qualidade em linhas de produção de alta velocidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3.3",
                            "name": "Aplicar reconhecimento de padrões",
                            "description": "Descrever princípios de matching de templates e features para identificação de objetos em robótica aeronáutica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios básicos de matching de templates",
                                  "subSteps": [
                                    "Estudar o conceito de template como uma imagem de referência padrão.",
                                    "Analisar como o matching compara pixels da imagem de entrada com o template usando métricas como correlação cruzada.",
                                    "Explorar variações como matching invariante a escala e rotação.",
                                    "Identificar limitações, como sensibilidade a iluminação e oclusões.",
                                    "Revisar algoritmos clássicos como Normalized Cross-Correlation (NCC)."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito os princípios e citar um exemplo de métrica de similaridade.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Slides ou vídeo tutorial sobre matching de templates, software como OpenCV.",
                                  "tips": "Visualize comparações lado a lado para entender melhor as métricas.",
                                  "learningObjective": "Dominar os fundamentos teóricos do matching de templates em visão computacional.",
                                  "commonMistakes": "Confundir matching de templates com detecção de features; ignorar normalização de iluminação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender detecção e extração de features",
                                  "subSteps": [
                                    "Estudar detectores de keypoints como Harris Corner ou SIFT.",
                                    "Implementar extração de descritores de features (ex: SURF ou ORB).",
                                    "Analisar como features são invariantes a transformações geométricas.",
                                    "Comparar features locais vs. globais em contextos aeronáuticos.",
                                    "Praticar filtragem de features irrelevantes usando thresholds."
                                  ],
                                  "verification": "Gerar um mapa de keypoints em uma imagem de teste e descrever 3 descritores extraídos.",
                                  "estimatedTime": "3 horas",
                                  "materials": "OpenCV ou MATLAB, imagens de drones ou aeronaves.",
                                  "tips": "Use imagens com ruído para testar robustez das features.",
                                  "learningObjective": "Extrair features robustas de imagens para matching posterior.",
                                  "commonMistakes": "Selecionar detectores inadequados para imagens borradas em movimento aéreo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar técnicas de matching de features",
                                  "subSteps": [
                                    "Implementar matching usando distância euclidiana ou FLANN.",
                                    "Aplicar RANSAC para eliminar matches outlier.",
                                    "Testar homografia para alinhamento de objetos.",
                                    "Otimizar matching para tempo real em robótica.",
                                    "Avaliar precisão com métricas como taxa de falsos positivos."
                                  ],
                                  "verification": "Executar código que matcha features entre duas imagens e produzir relatório de matches válidos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python com OpenCV, dataset de imagens aéreas.",
                                  "tips": "Ajuste o ratio test para filtrar matches fracos.",
                                  "learningObjective": "Realizar matching preciso de features para identificação de objetos.",
                                  "commonMistakes": "Não filtrar outliers, levando a matches incorretos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar reconhecimento de padrões em robótica aeronáutica",
                                  "subSteps": [
                                    "Adaptar templates e features para cenários aéreos (ex: identificação de obstáculos).",
                                    "Simular em ambiente virtual como Gazebo ou ROS.",
                                    "Integrar com câmeras embarcadas em drones.",
                                    "Testar em loop de controle para navegação autônoma.",
                                    "Analisar desempenho em condições reais como vento ou baixa luz."
                                  ],
                                  "verification": "Demonstrar sistema que identifica um objeto alvo em vídeo simulado.",
                                  "estimatedTime": "5 horas",
                                  "materials": "ROS, simulador de drone (Gazebo), câmera webcam.",
                                  "tips": "Comece com templates simples antes de features complexas.",
                                  "learningObjective": "Aplicar reconhecimento de padrões em contextos robóticos aeronáuticos.",
                                  "commonMistakes": "Ignorar latência computacional em sistemas embarcados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e otimizar o sistema de reconhecimento",
                                  "subSteps": [
                                    "Medir precisão, recall e F1-score em dataset de teste.",
                                    "Otimizar hiperparâmetros via grid search.",
                                    "Comparar template matching vs. feature matching.",
                                    "Documentar trade-offs em robótica aeronáutica.",
                                    "Propor melhorias como deep learning híbrido."
                                  ],
                                  "verification": "Produzir relatório com métricas e gráficos de performance.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Jupyter Notebook, métricas de avaliação em scikit-learn.",
                                  "tips": "Use cross-validation para robustez.",
                                  "learningObjective": "Avaliar criticamente e refinar sistemas de reconhecimento.",
                                  "commonMistakes": "Sobreajustar ao dataset de treinamento."
                                }
                              ],
                              "practicalExample": "Em um drone de inspeção aeronáutica, usar matching de templates para detectar cabos de alta tensão em vídeo ao vivo, e features SIFT para identificar aviões em aeroportos movimentados, evitando colisões.",
                              "finalVerifications": [
                                "Sistema identifica corretamente 90% dos objetos em teste.",
                                "Matching roda em tempo real (<100ms por frame).",
                                "Robustez demonstrada em variações de iluminação e ângulo.",
                                "Relatório explica princípios de templates e features.",
                                "Código comentado e reproduzível.",
                                "Integração simulada em ROS sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão do matching (>85% em dataset variado).",
                                "Compreensão teórica demonstrada em explicação.",
                                "Implementação eficiente e otimizada.",
                                "Tratamento de erros comuns como oclusões.",
                                "Criatividade na aplicação aeronáutica.",
                                "Documentação clara e completa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para homografias e descritores.",
                                "Programação: Python/OpenCV para implementação prática.",
                                "Física: Óptica e dinâmica de voo em robótica.",
                                "Inteligência Artificial: Transição para redes neurais convolucionais."
                              ],
                              "realWorldApplication": "Navegação autônoma de drones em inspeções de infraestrutura aeronáutica, detecção de obstáculos em UAVs militares ou sistemas de pouso automático em aeroportos, reduzindo riscos humanos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.1.1.3.4",
                            "name": "Relacionar com desenvolvimento integrado",
                            "description": "Explicar como princípios de visão se integram a times multifuncionais em projetos de produtos mecatrônicos, conforme Cross (2004).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Princípios Básicos de Sistemas de Visão por Computador",
                                  "subSteps": [
                                    "Identificar componentes principais: aquisição de imagem, pré-processamento e interpretação.",
                                    "Explicar aquisição de imagem (sensores CCD/CMOS) e seu papel em mecatrônica.",
                                    "Descrever pré-processamento (filtragem, segmentação) e interpretação (detecção de padrões).",
                                    "Relacionar com produtos mecatrônicos como inspeção de qualidade.",
                                    "Ler resumo de Cross (2004) sobre integração em design."
                                  ],
                                  "verification": "Criar um diagrama resumindo os princípios e sua relevância mecatrônica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Artigo de Cross (2004), slides de visão computacional, software de desenho (Draw.io).",
                                  "tips": "Use analogias visuais para fixar conceitos técnicos.",
                                  "learningObjective": "Compreender os fundamentos de visão para integração posterior.",
                                  "commonMistakes": "Confundir pré-processamento com interpretação; ignorar contexto mecatrônico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Desenvolvimento Integrado e Times Multifuncionais",
                                  "subSteps": [
                                    "Definir desenvolvimento integrado conforme Cross (2004): colaboração desde concepção.",
                                    "Listar funções em times multifuncionais: mecânica, eletrônica, software, visão.",
                                    "Analisar benefícios: redução de erros, otimização de ciclos.",
                                    "Estudar exemplos de Cross em produtos complexos.",
                                    "Mapear desafios como comunicação interdisciplinar."
                                  ],
                                  "verification": "Resumir em bullet points os conceitos chave de Cross e times.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro/capítulo de Cross (2004), vídeos sobre IPD (Integrated Product Development).",
                                  "tips": "Anote citações diretas de Cross para precisão.",
                                  "learningObjective": "Dominar framework de desenvolvimento integrado para contextos mecatrônicos.",
                                  "commonMistakes": "Focar só em teoria sem ligar a times reais; subestimar conflitos multidisciplinares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Pontos de Integração entre Visão e Desenvolvimento Integrado",
                                  "subSteps": [
                                    "Mapear como visão contribui em fases: design, prototipagem, teste.",
                                    "Discutir integração com mecânica (alinhamento sensores) e software (algoritmos).",
                                    "Analisar fluxos de dados em times: visão informa decisões multifuncionais.",
                                    "Usar framework de Cross para ilustrar loops de feedback.",
                                    "Criar tabela de integrações específicas."
                                  ],
                                  "verification": "Produzir tabela ou fluxograma de integrações.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Cross (2004), exemplos de projetos mecatrônicos (robótica industrial).",
                                  "tips": "Priorize interfaces físicas e de dados entre disciplinas.",
                                  "learningObjective": "Mapear sinergias entre visão e times integrados.",
                                  "commonMistakes": "Isolar visão como módulo separado; ignorar iterações conforme Cross."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceitos em um Projeto Mecatrônico Simulado",
                                  "subSteps": [
                                    "Escolher case: sistema de inspeção visual em linha de montagem.",
                                    "Simular time multifuncional e atribuir papéis.",
                                    "Desenhar plano integrado usando princípios de visão e Cross.",
                                    "Simular iterações e resoluções de conflitos.",
                                    "Documentar lições aprendidas."
                                  ],
                                  "verification": "Apresentar plano simulado com diagrama e narrativa.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ferramentas de simulação (Tinkercad, papel), Cross (2004).",
                                  "tips": "Role-play papéis do time para vivenciar integração.",
                                  "learningObjective": "Aplicar relação visão-desenvolvimento em contexto prático.",
                                  "commonMistakes": "Sobrecarregar uma disciplina; pular validações multidisciplinares."
                                }
                              ],
                              "practicalExample": "Em um projeto de braço robótico mecatrônico para pick-and-place, o engenheiro de visão integra câmeras para detecção de peças, colaborando com mecânicos para montagem de sensores e software para algoritmos, usando loops de feedback de Cross (2004) para otimizar precisão em 95%.",
                              "finalVerifications": [
                                "Diagrama completo de integração visão-times multifuncionais.",
                                "Resumo citando Cross (2004) com 3 exemplos específicos.",
                                "Tabela de papéis e contribuições interdisciplinares.",
                                "Plano simulado de projeto com fases integradas.",
                                "Lista de 5 benefícios e 3 desafios identificados.",
                                "Autoavaliação de compreensão (nota 1-10)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação e aplicação de Cross (2004) (30%).",
                                "Profundidade de mapeamento de integrações visão-mecatrônica (25%).",
                                "Clareza e completude de diagramas/planos (20%).",
                                "Identificação realista de desafios multifuncionais (15%).",
                                "Criatividade em exemplos práticos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Gerenciamento de Projetos: Agile/Scrum para times integrados.",
                                "Design Thinking: Empatia em colaboração multidisciplinar.",
                                "Engenharia de Software: Integração de APIs de visão.",
                                "Gestão da Qualidade: Inspeção visual em Lean Manufacturing."
                              ],
                              "realWorldApplication": "Na indústria automotiva, princípios de visão se integram em times multifuncionais para sistemas ADAS (Advanced Driver Assistance Systems), onde visão detecta obstáculos, mecânica ajusta atuadores e software processa dados em tempo real, reduzindo tempo de desenvolvimento em 20-30% conforme práticas de IPD."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Componentes Hardware de Sistemas de Visão",
                    "description": "Elementos como câmeras, iluminação e sensores usados em sistemas de visão mecatrônicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Câmeras em Sistemas de Visão",
                        "description": "Tipos de câmeras utilizadas em sistemas de visão por computador, incluindo suas características ópticas, sensores de imagem e interfaces de conexão para integração mecatrônica.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Identificar tipos de câmeras CCD e CMOS",
                            "description": "Diferenciar câmeras CCD (Charge-Coupled Device) e CMOS (Complementary Metal-Oxide-Semiconductor), explicando vantagens como sensibilidade à luz, custo e velocidade de captura em aplicações industriais mecatrônicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Câmeras CCD",
                                  "subSteps": [
                                    "Pesquise a definição de CCD (Charge-Coupled Device) como um sensor que transfere cargas elétricas através de pixels para leitura sequencial.",
                                    "Estude o processo de captura de luz: fótons geram elétrons que são transferidos pixel por pixel até o amplificador.",
                                    "Identifique componentes chave: matriz de pixels, registradores de transferência e amplificador de saída.",
                                    "Anote diagramas internos de um sensor CCD para visualizar o fluxo de carga.",
                                    "Compare com sensores analógicos tradicionais para contextualizar a evolução."
                                  ],
                                  "verification": "Desenhe um diagrama simples do fluxo de carga em um CCD e explique verbalmente o processo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com acesso à internet",
                                    "Artigos ou vídeos sobre sensores CCD (ex: Wikipedia, Khan Academy)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use animações online para visualizar a transferência de carga, pois é o conceito central do CCD.",
                                  "learningObjective": "Explicar o princípio de funcionamento do CCD e seus componentes principais.",
                                  "commonMistakes": [
                                    "Confundir transferência de carga com leitura paralela",
                                    "Ignorar o ruído térmico gerado pela transferência sequencial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os Fundamentos de Câmeras CMOS",
                                  "subSteps": [
                                    "Defina CMOS (Complementary Metal-Oxide-Semiconductor) como sensor com amplificadores em cada pixel para leitura paralela.",
                                    "Estude o processo: cada pixel converte luz em sinal elétrico independentemente via fotodíodo e transistor.",
                                    "Identifique componentes: fotodíodo, amplificador de pixel, ADCs (Conversores Analógico-Digital) on-chip.",
                                    "Anote diagramas de pixel CMOS (3T ou 4T) e como o rolling ou global shutter funciona.",
                                    "Compare com tecnologias de fabricação de chips lógicos para entender integração."
                                  ],
                                  "verification": "Crie um diagrama de um pixel CMOS e descreva a leitura paralela em uma frase.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com acesso à internet",
                                    "Vídeos tutoriais sobre CMOS sensors (ex: YouTube canais de eletrônica)",
                                    "Papel para esboços"
                                  ],
                                  "tips": "Foquem nos amplificadores por pixel; isso é o que permite baixa potência e alta velocidade.",
                                  "learningObjective": "Descrever o funcionamento do CMOS e suas vantagens arquiteturais.",
                                  "commonMistakes": [
                                    "Achar que CMOS é sempre inferior em qualidade de imagem",
                                    "Confundir rolling shutter com distorções em movimento rápido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças e Vantagens em Aplicações Industriais",
                                  "subSteps": [
                                    "Liste diferenças chave: sensibilidade à luz (CCD melhor em baixa luz), custo (CMOS mais barato), velocidade (CMOS mais rápida).",
                                    "Analise vantagens: CCD para alta qualidade em astronomia/inspeção precisa; CMOS para vídeo em tempo real em robótica.",
                                    "Discuta desvantagens: CCD consome mais energia e é suscetível a blooming; CMOS tem ruído fixo pattern.",
                                    "Crie uma tabela comparativa com métricas: quantum efficiency, frame rate, custo por megapixel.",
                                    "Relacione a mecatrônica: CCD em visão de precisão, CMOS em sistemas embarcados rápidos."
                                  ],
                                  "verification": "Preencha e explique uma tabela comparativa de 5 métricas entre CCD e CMOS.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Dados de especificações de câmeras industriais (ex: Basler, Allied Vision)",
                                    "Artigos comparativos"
                                  ],
                                  "tips": "Use exemplos reais de datasheets para números concretos, como frame rates >100fps em CMOS.",
                                  "learningObjective": "Diferenciar vantagens/desvantagens e selecionar o tipo ideal por aplicação.",
                                  "commonMistakes": [
                                    "Generalizar CCD como sempre superior",
                                    "Ignorar avanços recentes em CMOS que rivalizam CCD em sensibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Análise em Cenários Mecatrônicos",
                                  "subSteps": [
                                    "Examine fotos ou vídeos de câmeras industriais e identifique CCD vs CMOS por specs (ex: USB3 para alta velocidade = CMOS).",
                                    "Simule seleção: para inspeção noturna escolha CCD; para tracking de robô escolha CMOS.",
                                    "Pesquise cases: CCD em microscopia industrial, CMOS em linhas de montagem automotiva.",
                                    "Crie um fluxograma de decisão para escolher sensor baseado em requisitos.",
                                    "Teste com quiz online ou flashcards de identificação."
                                  ],
                                  "verification": "Classifique 5 câmeras industriais reais como CCD ou CMOS com justificativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Imagens de câmeras (ex: sites de fabricantes)",
                                    "Datasheets PDF",
                                    "Ferramenta de quiz como Quizlet"
                                  ],
                                  "tips": "Verifique specs como 'global shutter' (comum em CMOS industriais) ou 'cooling required' (CCD).",
                                  "learningObjective": "Identificar tipos de câmeras em contextos reais de sistemas de visão mecatrônicos.",
                                  "commonMistakes": [
                                    "Basear identificação só em preço sem specs técnicas",
                                    "Não considerar híbridos modernos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de visão para inspeção de soldas em linha de produção mecatrônica, identifique uma câmera CCD para alta sensibilidade em ambientes com pouca luz (detecção de microfissuras) versus uma CMOS para monitoramento em tempo real de movimento de peças a 60fps, comparando custos e integração com PLCs.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo de carga no CCD vs leitura paralela no CMOS.",
                                "Listar 3 vantagens de cada tipo em aplicações industriais.",
                                "Classificar corretamente 5 exemplos de câmeras como CCD ou CMOS usando specs.",
                                "Criar uma tabela comparativa com métricas chave.",
                                "Selecionar o sensor ideal para 2 cenários mecatrônicos dados.",
                                "Identificar erros comuns em seleção de sensores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição técnica de funcionamento (80%+ correto).",
                                "Completude da tabela comparativa com dados quantitativos.",
                                "Capacidade de justificar escolhas em contextos industriais.",
                                "Uso correto de terminologia (ex: quantum efficiency, shutter type).",
                                "Identificação precisa em exemplos reais (sem erros).",
                                "Demonstração de conexões com mecatrônica via exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de fotoeletricidade e geração de pares elétron-buraco.",
                                "Eletrônica: Circuitos de amplificação e conversão A/D integrados.",
                                "Programação: Processamento de imagens com OpenCV para sensores CCD/CMOS.",
                                "Engenharia Mecânica: Integração em sistemas robóticos e automação.",
                                "Matemática: Análise de ruído e eficiência quântica via estatística."
                              ],
                              "realWorldApplication": "Na indústria automotiva, câmeras CMOS são usadas em robôs para inspeção rápida de pintura em linhas de montagem (alta velocidade, baixo custo), enquanto CCDs são aplicadas em controle de qualidade de semicondutores para detecção precisa de defeitos em baixa luz, otimizando eficiência e reduzindo desperdícios em sistemas mecatrônicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Selecionar lentes e resoluções adequadas",
                            "description": "Avaliar parâmetros como distância focal, profundidade de campo e resolução espacial para escolher lentes e câmeras que atendam requisitos de inspeção em projetos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de lentes e resolução",
                                  "subSteps": [
                                    "Estude a definição e impacto da distância focal em campo de visão (FOV).",
                                    "Aprenda sobre profundidade de campo (DoF) e fatores que a influenciam (abertura, distância focal).",
                                    "Explore resolução espacial: pixels por mm, relação com sensor da câmera e requisitos de inspeção.",
                                    "Revise fórmulas básicas: FOV = (2 * atan(sensor_size / (2 * focal_length))) * (180/π).",
                                    "Analise trade-offs: lente curta amplia FOV mas reduz DoF."
                                  ],
                                  "verification": "Resuma conceitos em um diagrama anotado comparando diferentes lentes.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livros de óptica computacional, calculadora online de lentes (ex: Edmund Optics Lens Calculator), vídeos tutoriais sobre visão computacional.",
                                  "tips": "Use simulações online para visualizar mudanças em parâmetros.",
                                  "learningObjective": "Dominar terminologia e relações matemáticas entre parâmetros ópticos.",
                                  "commonMistakes": "Confundir distância focal com comprimento focal; ignorar tamanho do sensor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar requisitos do projeto de inspeção",
                                  "subSteps": [
                                    "Defina o objeto de inspeção: tamanho, distância de trabalho e precisão necessária (ex: detectar defeitos de 0.1mm).",
                                    "Determine restrições ambientais: iluminação, vibração, velocidade de inspeção.",
                                    "Especifique resolução mínima: pixels necessários por unidade de medida.",
                                    "Calcule FOV requerido baseado no tamanho do objeto e distância.",
                                    "Liste tolerâncias para DoF para cobrir variações no posicionamento."
                                  ],
                                  "verification": "Crie uma tabela de requisitos com valores numéricos para um caso hipotético.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Planilha Excel ou Google Sheets para tabela de requisitos, especificações de projeto mecatrônico.",
                                  "tips": "Comece com requisitos realistas de inspeções industriais como soldas ou componentes eletrônicos.",
                                  "learningObjective": "Mapear necessidades do projeto para parâmetros ópticos.",
                                  "commonMistakes": "Subestimar variações ambientais; definir resolução sem considerar Nyquist sampling."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular parâmetros ópticos necessários",
                                  "subSteps": [
                                    "Use fórmula de FOV para determinar distância focal mínima/máxima.",
                                    "Calcule DoF usando: DoF ≈ (2 * N * c * f^2) / (f^2 - (N * c)^2), onde N=abertura, c=coeficiente de círculo de confusão.",
                                    "Determine resolução espacial: resolução = pixel_size * (distância / focal_length).",
                                    "Selecione tamanho de sensor compatível e calcule pixels totais necessários.",
                                    "Ajuste iterações para otimizar trade-offs (FOV vs DoF)."
                                  ],
                                  "verification": "Produza relatório com cálculos mostrando valores finais para focal length, DoF e resolução.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Calculadoras ópticas online (ex: Thorlabs ou Zeiss), software como MATLAB/Octave para simulações.",
                                  "tips": "Valide cálculos com ferramentas online antes de prosseguir.",
                                  "learningObjective": "Aplicar matemática para derivar specs de lentes e câmeras.",
                                  "commonMistakes": "Esquecer fator de escala do sensor; usar unidades inconsistentes (mm vs pixels)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Pesquisar e selecionar lentes e câmeras",
                                  "subSteps": [
                                    "Consulte catálogos de fabricantes (ex: Computar, Basler, Edmund Optics).",
                                    "Filtre opções por focal length calculada, montagem (C/CS), abertura.",
                                    "Verifique compatibilidade: sensor size, resolução da câmera (MPixels).",
                                    "Compare custos, distorção e qualidade óptica (MTF charts).",
                                    "Escolha top 3 opções e justifique a seleção final."
                                  ],
                                  "verification": "Apresente datasheet das componentes selecionadas com mapeamento aos requisitos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Sites de fornecedores de visão industrial, planilhas de comparação.",
                                  "tips": "Priorize lentes com baixa distorção para inspeções precisas.",
                                  "learningObjective": "Avaliar specs reais de mercado contra cálculos teóricos.",
                                  "commonMistakes": "Ignorar compatibilidade de montagem; escolher baseado só em preço."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e testar a seleção",
                                  "subSteps": [
                                    "Simule setup com software (ex: OpenCV Image Simulator).",
                                    "Monitore métricas: FOV real, DoF efetiva, resolução medida.",
                                    "Ajuste se necessário e documente iterações.",
                                    "Planeje teste físico com protótipo.",
                                    "Registre lições aprendidas para projetos futuros."
                                  ],
                                  "verification": "Gere imagens simuladas ou reais mostrando cumprimento dos requisitos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software de simulação (OpenCV, Gazebo), câmera de teste se disponível.",
                                  "tips": "Use apps móveis com lentes variáveis para prototipagem rápida.",
                                  "learningObjective": "Iterar e validar seleção em cenários reais/simulados.",
                                  "commonMistakes": "Pular simulação; assumir cálculos perfeitos sem verificação."
                                }
                              ],
                              "practicalExample": "Em um projeto de inspeção de soldas em PCBs, com objeto de 50x50mm a 200mm de distância, precisão de 0.05mm: calcule focal length ~25mm, DoF >10mm, resolução >20 pixels/mm; selecione câmera Basler ace acA1920-155um com lente Computar M2518F2.",
                              "finalVerifications": [
                                "FOV calculado cobre o objeto inteiro sem distorção excessiva.",
                                "DoF cobre variações de ±5mm no posicionamento.",
                                "Resolução espacial atende ou excede requisito mínimo (ex: 2x Nyquist).",
                                "Componentes são compatíveis (montagem, sensor size).",
                                "Custo e disponibilidade são viáveis para projeto.",
                                "Simulação confirma performance esperada."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos ópticos (erro <10%).",
                                "Adequação da seleção aos requisitos especificados.",
                                "Documentação completa com fórmulas, tabelas e justificativas.",
                                "Identificação correta de trade-offs e otimizações.",
                                "Validação via simulação ou teste com evidências.",
                                "Clareza na apresentação de resultados."
                              ],
                              "crossCurricularConnections": [
                                "Óptica Física: Leis de refração e formação de imagens.",
                                "Eletrônica: Especificações de sensores CMOS/CCD.",
                                "Programação: Integração com OpenCV para calibração.",
                                "Matemática: Geometria analítica e álgebra para fórmulas ópticas.",
                                "Gestão de Projetos: Análise custo-benefício em seleções."
                              ],
                              "realWorldApplication": "Seleção de lentes para robôs de inspeção industrial em linhas de montagem automotiva, garantindo detecção precisa de defeitos em peças soldadas ou componentes eletrônicos, reduzindo tempo de produção e custos com retrabalho."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Integrar interfaces de câmeras em microcontroladores",
                            "description": "Configurar conexões USB, Ethernet ou MIPI para câmeras em sistemas baseados em microcontroladores ou CLPs, considerando protocolos como GigE Vision.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e Selecionar Componentes Compatíveis",
                                  "subSteps": [
                                    "Identificar o tipo de interface necessária (USB, Ethernet ou MIPI) com base no projeto",
                                    "Selecionar microcontrolador ou CLP compatível, como ESP32 para USB, Raspberry Pi para Ethernet ou STM32 para MIPI",
                                    "Escolher câmera suportada, verificando protocolos como GigE Vision para Ethernet",
                                    "Analisar especificações: resolução, frame rate, consumo de energia e pinagem",
                                    "Verificar disponibilidade de drivers e bibliotecas open-source"
                                  ],
                                  "verification": "Lista documentada de componentes com justificativa de compatibilidade e links para datasheets",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Datasheets de câmeras e microcontroladores",
                                    "Ferramentas de busca (Google, Digi-Key)",
                                    "Planilha de comparação"
                                  ],
                                  "tips": "Priorize componentes com suporte comunitário ativo para troubleshooting rápido.",
                                  "learningObjective": "Compreender critérios de compatibilidade entre câmeras e microcontroladores.",
                                  "commonMistakes": [
                                    "Ignorar requisitos de alimentação elétrica",
                                    "Escolher interfaces sem suporte de software nativo",
                                    "Subestimar largura de banda necessária"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer Conexões Físicas",
                                  "subSteps": [
                                    "Preparar cabos e adaptadores específicos para a interface (USB, Ethernet CAT6, cabos MIPI)",
                                    "Conectar pinos corretamente conforme diagrama do datasheet (dados, clock, ground)",
                                    "Conectar fonte de alimentação externa se requerida pela câmera",
                                    "Fixar componentes em protoboard ou PCB para estabilidade mecânica",
                                    "Testar continuidade e ausência de curtos com multímetro"
                                  ],
                                  "verification": "Medições elétricas confirmam conexões corretas sem interrupções",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Cabos USB/Ethernet/MIPI",
                                    "Multímetro",
                                    "Fonte de alimentação regulada 5V/12V",
                                    "Protoboard ou soldador"
                                  ],
                                  "tips": "Use cabos blindados para MIPI e Ethernet para minimizar interferências EMI.",
                                  "learningObjective": "Montar conexões hardware seguras e funcionais.",
                                  "commonMistakes": [
                                    "Inversão de pinos TX/RX",
                                    "Conexões soltas causando instabilidade",
                                    "Excesso de tensão danificando a câmera"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Software e Protocolos",
                                  "subSteps": [
                                    "Instalar IDE e bibliotecas (Arduino IDE para ESP32, Pylon SDK para GigE Vision)",
                                    "Escrever código inicial para inicializar a câmera e configurar protocolo",
                                    "Ajustar parâmetros: resolução, FPS, exposição via API da biblioteca",
                                    "Implementar captura de frame e transmissão de dados para o microcontrolador",
                                    "Compilar, fazer upload e monitorar logs via serial"
                                  ],
                                  "verification": "Logs mostram inicialização bem-sucedida sem erros de protocolo",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "IDE (PlatformIO, Arduino IDE)",
                                    "Bibliotecas (ESP32-CAM, OpenCV, GigE Vision SDK)",
                                    "Computador com USB para programação"
                                  ],
                                  "tips": "Use configurações de debug para capturar erros de handshake inicial.",
                                  "learningObjective": "Implementar drivers e protocolos para comunicação câmera-microcontrolador.",
                                  "commonMistakes": [
                                    "Bibliotecas de versão incompatível",
                                    "Endereços IP mal configurados para Ethernet",
                                    "Buffer overflow em capturas de alta resolução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Integrar o Sistema",
                                  "subSteps": [
                                    "Executar captura de imagem em loop e exibir em monitor serial ou display",
                                    "Testar sob variações: luz ambiente, ângulos e distâncias",
                                    "Integrar com CLP ou outro microcontrolador via protocolo compartilhado",
                                    "Medir latência e throughput de dados",
                                    "Otimizar código e documentar configurações finais"
                                  ],
                                  "verification": "Imagens capturadas em tempo real com qualidade visual aceitável",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Display ou software de visualização (Serial Plotter, PuTTY)",
                                    "Ambiente de teste com iluminação controlada"
                                  ],
                                  "tips": "Implemente timeout em loops para evitar travamentos em falhas de câmera.",
                                  "learningObjective": "Validar e otimizar a integração completa do sistema de visão.",
                                  "commonMistakes": [
                                    "Não testar em condições reais de uso",
                                    "Ignorar latência em aplicações tempo-real",
                                    "Falta de calibração de cor/exposição"
                                  ]
                                }
                              ],
                              "practicalExample": "Integre uma câmera USB OV7670 com um ESP32 em um sistema de inspeção de garrafas em linha de produção: o microcontrolador captura imagens via USB, processa para detectar preenchimento inadequado e aciona um CLP para rejeitar a peça defeituosa.",
                              "finalVerifications": [
                                "Câmera inicializa e responde a comandos sem timeouts",
                                "Captura de frames em pelo menos 15 FPS com resolução mínima 640x480",
                                "Protocolo (ex: GigE Vision) transmite dados sem perda de pacotes",
                                "Sistema opera estável por 30 minutos contínuos",
                                "Integração com microcontrolador/CLP permite acionamento de saídas",
                                "Qualidade de imagem permite detecção básica de bordas/objetos"
                              ],
                              "assessmentCriteria": [
                                "Hardware montado sem falhas elétricas ou mecânicas",
                                "Software compila e executa sem erros críticos",
                                "Latência de captura < 100ms em condições nominais",
                                "Tolerância a variações de tensão ±10%",
                                "Documentação inclui diagramas e código fonte comentado",
                                "Eficiência energética dentro das especificações do datasheet"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Interfaces seriais e protocolos de comunicação",
                                "Programação: Desenvolvimento embedded com C/Python",
                                "Redes: Configuração IP e GigE Vision para Ethernet",
                                "Mecânica: Design de montagens para câmeras em ambientes industriais",
                                "Processos Industriais: Integração em automação PLC/SCADA"
                              ],
                              "realWorldApplication": "Em fábricas de automotivos, câmeras integradas via Ethernet em microcontroladores monitoram soldas em tempo real, detectam defeitos via GigE Vision e acionam robôs para correções, reduzindo refugos em 20%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Sistemas de Iluminação",
                        "description": "Componentes de iluminação artificial para otimizar a captura de imagens, incluindo tipos de luz, fontes e configurações para eliminar sombras e reflexos em ambientes industriais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Classificar fontes de iluminação LED e halógenas",
                            "description": "Comparar LEDs (alta eficiência, longa vida útil), halógenas e lasers quanto a espectro luminoso, intensidade e aplicação em visão mecatrônica para detecção de defeitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os princípios fundamentais de LEDs, halógenas e lasers",
                                  "subSteps": [
                                    "Pesquise a estrutura física e o mecanismo de emissão de luz de cada fonte: semicondutores em LEDs, filamento de tungstênio em halógenas e emissão estimulada em lasers.",
                                    "Identifique características básicas: LEDs emitem luz por recombinação eletrônica, halógenas por incandescência térmica e lasers por coerência.",
                                    "Registre vantagens iniciais: LEDs (eficiência >80 lm/W, vida >50.000h), halógenas (espectro contínuo amplo), lasers (alta intensidade direcional).",
                                    "Compare dissipação de calor: LEDs frios, halógenas quentes, lasers moderados.",
                                    "Anote limitações: LEDs custo inicial alto, halógenas curta vida (~2.000h), lasers sensíveis a alinhamento."
                                  ],
                                  "verification": "Criar uma tabela comparativa com 5 colunas (fonte, mecanismo, vantagens, limitações, vida útil) preenchida corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com acesso à internet",
                                    "Folha de papel ou planilha digital",
                                    "Datasheets de LEDs, halógenas e lasers (PDFs online)"
                                  ],
                                  "tips": "Use diagramas esquemáticos para visualizar estruturas internas; foque em analogias como 'LED é como uma junção PN eficiente'.",
                                  "learningObjective": "Compreender os mecanismos físicos e características básicas de cada fonte de iluminação.",
                                  "commonMistakes": [
                                    "Confundir espectro de LEDs com halógenas (LEDs são discretos, halógenas contínuos)",
                                    "Ignorar dissipação térmica em aplicações práticas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o espectro luminoso de cada fonte",
                                  "subSteps": [
                                    "Estude o espectro: LEDs (pico estreito ~20nm, cores puras), halógenas (contínuo 400-2500nm, similar ao sol), lasers (monocromático <1nm).",
                                    "Use ferramentas online como espectrômetros virtuais para simular e plotar curvas espectrais.",
                                    "Compare uniformidade: halógenas ideais para iluminação ampla, LEDs para seletiva por cor, lasers para precisão espectral.",
                                    "Registre impacto em visão: espectro influencia contraste em detecção de defeitos (ex: LED vermelho destaca defeitos em plásticos vermelhos).",
                                    "Crie gráficos comparativos de espectro vs. comprimento de onda."
                                  ],
                                  "verification": "Gerar 3 gráficos espectrais (um por fonte) com legendas explicando picos e larguras.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software gratuito como Spectragryph ou Wolfram Alpha",
                                    "Imagens de espectros reais de fontes online"
                                  ],
                                  "tips": "Comece com luz branca vs. colorida; lembre que espectro afeta câmeras CCD/CMOS em sistemas de visão.",
                                  "learningObjective": "Diferenciar e comparar os perfis espectrais para seleção em aplicações de visão.",
                                  "commonMistakes": [
                                    "Assumir todos LEDs têm espectro amplo (varia por tipo: RGB vs. white phosphor)",
                                    "Ignorar filtro de câmera no espectro efetivo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar intensidade, eficiência e durabilidade",
                                  "subSteps": [
                                    "Meça intensidade: LEDs (alta directionalidade, 100-1000 cd/m²), halógenas (difusa, 10-100 cd/m²), lasers (>10^6 cd/m² focado).",
                                    "Calcule eficiência: LEDs (30-100 lm/W), halógenas (15-25 lm/W), lasers (baixo lm/W mas alta potência óptica).",
                                    "Avalie vida útil e manutenção: LEDs >50.000h, halógenas 1.000-2.000h, lasers 10.000-100.000h.",
                                    "Considere custo operacional: LEDs economia em longo prazo, halógenas baratas inicialmente.",
                                    "Simule cenários: calcule consumo para 8h/dia em fábrica."
                                  ],
                                  "verification": "Preencher tabela de comparação com valores numéricos para intensidade, eficiência e vida útil, incluindo cálculos de custo anual.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora ou Excel",
                                    "Dados de fabricantes (ex: Philips para LEDs, Osram para halógenas)"
                                  ],
                                  "tips": "Use lm/W como métrica principal; considere fator de forma (LEDs compactos vs. halógenas volumosas).",
                                  "learningObjective": "Quantificar diferenças em performance para otimizar seleção em projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Comparar apenas potência elétrica sem lm/W",
                                    "Subestimar aquecimento em halógenas afetando intensidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar conhecimentos em classificação para visão mecatrônica em detecção de defeitos",
                                  "subSteps": [
                                    "Classifique por aplicação: LEDs para contorno/cores, halógenas para sombreamento uniforme, lasers para superfícies reflexivas.",
                                    "Simule detecção: LED coaxial para defeitos planos, halógena difusa para texturas, laser para precisão em alta velocidade.",
                                    "Crie fluxograma de decisão: baseado em material alvo, velocidade e defeito (rachaduras, bolhas).",
                                    "Avalie trade-offs: custo vs. precisão em linha de produção.",
                                    "Teste virtual: use software como Cognex Designer para simular iluminação."
                                  ],
                                  "verification": "Desenvolver fluxograma de classificação com 3 cenários reais de detecção de defeitos.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Software de simulação visão (ex: Halcon trial, ou imagens OpenCV)",
                                    "Papel para fluxograma"
                                  ],
                                  "tips": "Pense no ângulo de incidência: 45° para halógenas em defeitos elevados; priorize ROI em eficiência.",
                                  "learningObjective": "Classificar fontes otimizando para detecção de defeitos em sistemas de visão mecatrônica.",
                                  "commonMistakes": [
                                    "Escolher laser para áreas amplas (overkill)",
                                    "Ignorar vibração afetando lasers"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de produção de PCBs, use LED vermelho para detectar soldas frias (contraste espectral), halógena difusa para inspecionar trilhas opacas e laser verde para alinhamento preciso de componentes, simulando com câmera USB e software OpenCV para validar classificação.",
                              "finalVerifications": [
                                "Classificar corretamente 5 cenários de detecção de defeitos com fonte ideal.",
                                "Explicar diferenças espectrais em 1 minuto sem consultar notas.",
                                "Calcular eficiência comparativa para um setup de 100W.",
                                "Identificar 3 erros comuns em seleção de iluminação industrial.",
                                "Montar fluxograma de decisão funcional.",
                                "Simular impacto de espectro em imagem de câmera."
                              ],
                              "assessmentCriteria": [
                                "Precisão na comparação espectral (picos, largura >90% correto).",
                                "Uso correto de métricas quantitativas (lm/W, cd/m², horas).",
                                "Relevância das aplicações à detecção de defeitos mecatrônica.",
                                "Completude do fluxograma com trade-offs.",
                                "Clareza em tabelas/gráficos comparativos.",
                                "Identificação de erros comuns e mitigação."
                              ],
                              "crossCurricularConnections": [
                                "Física Óptica: Princípios de emissão e espectroscopia.",
                                "Eletrônica: Circuitos de drive para LEDs e lasers.",
                                "Programação: Processamento de imagem em OpenCV para validação.",
                                "Engenharia de Materiais: Interação luz-matéria em defeitos.",
                                "Gestão Industrial: Custo-benefício em automação."
                              ],
                              "realWorldApplication": "Na indústria automotiva, classificar LEDs para inspeção de pintura (contraste cor), halógenas para soldas (uniformidade) e lasers para medição de gaps em montagem, reduzindo defeitos em 20% e otimizando energia em linhas de produção 24/7."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Projetar configurações de iluminação direcionais",
                            "description": "Planejar setups como luz frontal, lateral, coaxial ou em anel para melhorar contraste em superfícies metálicas ou plásticas em projetos aeronáuticos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Princípios Básicos de Iluminação em Visão Computacional",
                                  "subSteps": [
                                    "Estude os fundamentos da reflexão e refração da luz em superfícies metálicas e plásticas.",
                                    "Aprenda como o ângulo de incidência afeta o contraste e a detecção de defeitos.",
                                    "Identifique os desafios específicos em ambientes aeronáuticos, como vibrações e poeira.",
                                    "Revise conceitos de espectro luminoso e intensidade para otimização.",
                                    "Analise diagramas de propagação de luz em setups de máquina visão."
                                  ],
                                  "verification": "Resuma os princípios em um diagrama anotado e explique verbalmente para um colega.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livros ou PDFs sobre visão computacional",
                                    "Vídeos tutoriais (YouTube/Cognex/Basler)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use simulações online gratuitas como OptiSystem para visualizar reflexões.",
                                  "learningObjective": "Dominar como a luz interage com materiais para melhorar visibilidade em inspeções.",
                                  "commonMistakes": [
                                    "Ignorar propriedades especulares de metais",
                                    "Confundir difusa com direcional",
                                    "Subestimar impacto ambiental"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Classificar Tipos de Iluminação Direcional",
                                  "subSteps": [
                                    "Descreva luz frontal: posição, ângulos ideais (30-45°) e aplicações em plásticos opacos.",
                                    "Explique luz lateral: setups de 90° para detectar ranhuras em metais.",
                                    "Estude luz coaxial: uso de espelhos para superfícies reflexivas brilhantes.",
                                    "Detalhe luz em anel: uniformidade para inspeções circulares em componentes aeronáuticos.",
                                    "Compare prós e contras de cada tipo com tabelas."
                                  ],
                                  "verification": "Crie uma tabela comparativa com exemplos visuais para cada tipo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Diagramas impressos de setups (Cognex guides)",
                                    "Software gratuito como ImageJ para simulações",
                                    "Amostras de metal/plástico"
                                  ],
                                  "tips": "Desenhe setups em papel antes de simular para fixar conceitos.",
                                  "learningObjective": "Classificar corretamente cada configuração direcional e suas aplicações ideais.",
                                  "commonMistakes": [
                                    "Confundir coaxial com frontal",
                                    "Escolher anel para detecção de bordas afiadas",
                                    "Ignorar polarização da luz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Superfícies e Requisitos do Projeto Aeronáutico",
                                  "subSteps": [
                                    "Examine propriedades de superfícies: refletividade de alumínio vs. ABS plástico.",
                                    "Defina objetivos: detectar riscos, soldas ou deformações em peças de fuselagem.",
                                    "Considere restrições: tamanho do setup, consumo de energia, integração mecatrônica.",
                                    "Colete dados de inspeção: fotos reais de defeitos em componentes aeronáuticos.",
                                    "Priorize contrastes baseados em normas como AS9100 para qualidade aeroespacial."
                                  ],
                                  "verification": "Produza um relatório de análise com fotos anotadas de superfícies.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Amostras reais de metais/plásticos aeronáuticos",
                                    "Microscópio ou lupa",
                                    "Normas AS9100 PDF"
                                  ],
                                  "tips": "Use apps de análise de imagem como Fiji para medir refletividade inicial.",
                                  "learningObjective": "Avaliar superfícies específicas e mapear requisitos para iluminação otimizada.",
                                  "commonMistakes": [
                                    "Generalizar todas as plásticas como difusas",
                                    "Ignorar vibrações em setups aeronáuticos",
                                    "Subestimar sombreamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Projetar e Simular Configurações de Iluminação",
                                  "subSteps": [
                                    "Selecione o tipo baseado na análise: ex. lateral para metais com ranhuras.",
                                    "Desenhe esquemáticos: posições exatas de luzes, câmera e objeto.",
                                    "Simule em software: ajuste ângulos, intensidade e filtre ruídos.",
                                    "Integre com hardware mecatrônico: fixadores, controladores LED.",
                                    "Otimize para custo e eficiência em produção aeronáutica."
                                  ],
                                  "verification": "Gere simulações com imagens before/after e documente escolhas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software: Halcon, OpenCV ou Cognex Designer",
                                    "LEDs de teste, suportes",
                                    "Câmera webcam para protótipo"
                                  ],
                                  "tips": "Comece com protótipos de baixo custo usando Arduino para controle de LEDs.",
                                  "learningObjective": "Criar designs funcionais e simulados de setups direcionais.",
                                  "commonMistakes": [
                                    "Sobrecarregar com múltiplas luzes desnecessárias",
                                    "Não calibrar distâncias",
                                    "Esquecer integração com visão"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Avaliar e Refinar o Setup",
                                  "subSteps": [
                                    "Monte protótipo físico e capture imagens reais.",
                                    "Meça contraste: use métricas como Michelson para validar melhoria.",
                                    "Teste em cenários reais: variações de ângulo, iluminação ambiente.",
                                    "Ajuste baseado em resultados: mude ângulos ou adicione difusores.",
                                    "Documente iterações finais para relatório de projeto."
                                  ],
                                  "verification": "Apresente conjunto de imagens teste com métricas quantitativas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Protótipo montado",
                                    "Software de análise de imagem",
                                    "Ferramentas de medição (luxímetro)"
                                  ],
                                  "tips": "Registre vídeos de testes para análise posterior.",
                                  "learningObjective": "Validar e iterar designs para performance real em mecatrônica aeronáutica.",
                                  "commonMistakes": [
                                    "Testar só em condições ideais",
                                    "Não quantificar melhorias",
                                    "Ignorar escalabilidade para produção"
                                  ]
                                }
                              ],
                              "practicalExample": "Projetar um setup de iluminação lateral para inspecionar soldas em painéis de alumínio de fuselagem de aeronave: use duas luzes LED de 45° para destacar microfissuras, integrando com câmera industrial e braço robótico para automação.",
                              "finalVerifications": [
                                "O design melhora contraste em >50% em superfícies teste.",
                                "Esquemático inclui posições exatas e especificações de hardware.",
                                "Simulações mostram detecção confiável de defeitos <0.1mm.",
                                "Integração mecatrônica documentada (controle PLC/Arduino).",
                                "Relatório cobre análise, design e testes com métricas.",
                                "Setup atende normas aeronáuticas de segurança e eficiência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção do tipo de iluminação baseado em superfície.",
                                "Detalhe e realismo nos esquemáticos e simulações.",
                                "Quantificação de melhorias em contraste e detecção.",
                                "Consideração de restrições aeronáuticas (peso, vibração).",
                                "Criatividade em otimizações e iterações.",
                                "Clareza na documentação e apresentação."
                              ],
                              "crossCurricularConnections": [
                                "Óptica e Física: Reflexão especular/difusa.",
                                "Eletrônica: Controle de LEDs e drivers.",
                                "Programação: Processamento de imagem em OpenCV/Python.",
                                "Engenharia Mecânica: Design de fixadores e alinhamento.",
                                "Gestão de Projetos: Normas AS9100 e ciclos PDCA."
                              ],
                              "realWorldApplication": "Em linhas de montagem da Embraer ou Boeing, setups direcionais automatizam inspeção de qualidade em componentes metálicos/plásticos, reduzindo defeitos em 30% e acelerando produção sem contato humano em áreas críticas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Controlar intensidade via microcontroladores",
                            "description": "Implementar controle PWM (Pulse Width Modulation) em microcontroladores para ajustar brilho dinâmico de iluminação sincronizado com captura de imagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Hardware para Controle PWM",
                                  "subSteps": [
                                    "Selecionar microcontrolador com suporte PWM (ex: Arduino Uno ou ESP32).",
                                    "Conectar LED ou tira LED ao pino PWM (ex: pino 9).",
                                    "Adicionar resistor limitador de corrente (220-330Ω).",
                                    "Conectar módulo de câmera (ex: OV7670 ou ESP32-CAM) via I2C/SPI.",
                                    "Verificar alimentação (5V/3.3V) e ground comum."
                                  ],
                                  "verification": "Usar multímetro para confirmar continuidade e tensões corretas; acender LED manualmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Microcontrolador Arduino/ESP32",
                                    "LEDs ou tira LED RGB",
                                    "Resistores 220-330Ω",
                                    "Módulo câmera OV7670/ESP32-CAM",
                                    "Protoboard e cabos jumper",
                                    "Multímetro"
                                  ],
                                  "tips": "Consulte pinout do microcontrolador para pinos PWM dedicados. Evite curtos-circuitos testando seções isoladamente.",
                                  "learningObjective": "Montar circuito hardware integrado para PWM e captura de imagem de forma segura e funcional.",
                                  "commonMistakes": [
                                    "Conectar LED sem resistor, causando superaquecimento",
                                    "Usar pino não-PWM",
                                    "Incompatibilidade de tensão entre câmera e microcontrolador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Controle PWM Básico no Firmware",
                                  "subSteps": [
                                    "Instalar Arduino IDE e bibliotecas básicas.",
                                    "Configurar pino PWM como OUTPUT no setup().",
                                    "Escrever função para variar duty cycle (0-255 com analogWrite()).",
                                    "Criar loop de fade in/out com delays.",
                                    "Upload código e monitorar via Serial.",
                                    "Testar brilho em diferentes níveis."
                                  ],
                                  "verification": "Brilho do LED varia suavemente de apagado a máximo via Serial Plotter.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Computador com Arduino IDE instalada",
                                    "Cabo USB para upload"
                                  ],
                                  "tips": "Frequência PWM padrão (490Hz) é suficiente para iluminação; use map() para escalar valores.",
                                  "learningObjective": "Dominar geração de sinal PWM para controle analógico de intensidade.",
                                  "commonMistakes": [
                                    "Esquecer pinMode(pino, OUTPUT)",
                                    "Valores >255 em analogWrite()",
                                    "Delay excessivo causando flicker"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Captura e Análise de Imagem",
                                  "subSteps": [
                                    "Instalar biblioteca da câmera (ex: ESP32 Camera ou Adafruit OV7670).",
                                    "Implementar captura de frame em grayscale.",
                                    "Calcular métrica de luminosidade média dos pixels.",
                                    "Definir threshold para intensidade desejada.",
                                    "Testar captura isolada com Serial output de luminosidade.",
                                    "Ajustar parâmetros de exposição da câmera."
                                  ],
                                  "verification": "Serial monitor exibe valores de luminosidade variando com luz ambiente (0-255).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Bibliotecas Arduino: ESP32 Camera ou OV7670",
                                    "Câmera conectada"
                                  ],
                                  "tips": "Converta para grayscale para reduzir processamento: lum = 0.299*R + 0.587*G + 0.114*B.",
                                  "learningObjective": "Capturar e processar imagens em tempo real para extrair dados de iluminação.",
                                  "commonMistakes": [
                                    "Configuração errada de clock I2C/SPI",
                                    "Buffer de imagem pequeno causando corrupção",
                                    "Não flush memória após captura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sincronizar PWM com Feedback de Imagem",
                                  "subSteps": [
                                    "Integrar loop: capturar imagem → calcular lum → mapear para duty cycle PWM.",
                                    "Implementar controle proporcional simples (duty = K * (target_lum - current_lum)).",
                                    "Adicionar taxa de atualização (ex: 100ms delay).",
                                    "Testar em cenários variados (luz baixa/alta).",
                                    "Otimizar código removendo delays desnecessários e debug prints.",
                                    "Registrar logs de performance."
                                  ],
                                  "verification": "Sistema mantém luminosidade na imagem constante (±10%) apesar de mudanças externas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Serial monitor para debug"
                                  ],
                                  "tips": "Use millis() para non-blocking timing. Calibre K para evitar oscilações.",
                                  "learningObjective": "Criar laço fechado de controle dinâmico sincronizado.",
                                  "commonMistakes": [
                                    "Loop blocking por processamento pesado",
                                    "Ganho K alto causando overshoot",
                                    "Ignorar latência da câmera no timing"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Otimizar e Validar o Sistema Completo",
                                  "subSteps": [
                                    "Executar testes end-to-end por 10 minutos.",
                                    "Medir latência de resposta com osciloscópio ou timer.",
                                    "Implementar PID básico para estabilidade avançada.",
                                    "Ajustar para diferentes condições ambientais.",
                                    "Documentar código com comentários e diagrama.",
                                    "Backup do firmware final."
                                  ],
                                  "verification": "Brilho ajusta em <500ms e sistema roda estável sem crashes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Osciloscópio opcional",
                                    "Ambiente com luz variável"
                                  ],
                                  "tips": "Monitore temperatura do microcontrolador. Use profiling para bottlenecks.",
                                  "learningObjective": "Garantir robustez e performance do sistema integrado.",
                                  "commonMistakes": [
                                    "Sem calibração para cenários reais",
                                    "Código não escalável",
                                    "Falta de handling de erros na câmera"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um inspetor visual automatizado: câmera captura imagem de uma peça; se média de luminosidade <150, aumenta PWM do LED para 80% duty cycle, garantindo contraste ótimo para detecção de riscos.",
                              "finalVerifications": [
                                "PWM duty cycle varia responsivamente de 0-100% baseado em input de imagem.",
                                "Luminosidade média na imagem estabiliza em target (±10) em <1s.",
                                "Sistema opera continuamente >10min sem falhas ou superaquecimento.",
                                "Código compila e roda em hardware padrão sem warnings.",
                                "Logs mostram correlações precisas entre lum_imagem e PWM output."
                              ],
                              "assessmentCriteria": [
                                "Precisão de controle: erro <5% em duty cycle.",
                                "Latência total <500ms de captura a ajuste.",
                                "Estabilidade: oscilação <2% após convergência.",
                                "Eficiência: uso CPU <70%, sem memory leaks.",
                                "Qualidade imagem: sharpness score >80% pós-ajuste."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Geração de sinais PWM e interfaces.",
                                "Programação Embarcada: Loops de controle e processamento RT.",
                                "Física/Óptica: Propriedades de luz, reflexão e fotometria.",
                                "Matemática: Algoritmos PID e estatística de imagens.",
                                "Ciência da Computação: Visão computacional básica."
                              ],
                              "realWorldApplication": "Em manufatura inteligente, sistemas de inspeção de qualidade ajustam iluminação dinamicamente para otimizar visão artificial em detecção de defeitos em linhas de produção de eletrônicos ou automotivos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Sensores e Computação Embarcada",
                        "description": "Sensores complementares como encoders ópticos e processadores embarcados para processamento em tempo real em sistemas de visão mecatrônicos integrados.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Selecionar sensores ópticos auxiliares",
                            "description": "Escolher sensores como fotodiodos, encoders lineares ou LiDAR para calibração e feedback posicional em conjunto com câmeras em robótica mecatrônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Requisitos do Sistema de Visão",
                                  "subSteps": [
                                    "Analise o contexto do projeto robótico: precisão posicional necessária, ambiente de operação (iluminação, distância).",
                                    "Defina métricas chave: resolução angular, taxa de atualização, tolerância a ruído óptico.",
                                    "Liste limitações das câmeras principais: campos mortos, baixa precisão em baixa luz.",
                                    "Documente requisitos de calibração (ex.: alinhamento inicial) e feedback em tempo real.",
                                    "Priorize sensores auxiliares baseados em gaps das câmeras."
                                  ],
                                  "verification": "Criar um documento de requisitos com pelo menos 5 itens específicos validados por auto-revisão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Especificações do projeto robótico, planilha de requisitos (Google Sheets ou Excel), notas de aula sobre sistemas de visão.",
                                  "tips": "Use matriz de decisão para mapear requisitos vs. limitações das câmeras.",
                                  "learningObjective": "Compreender como alinhar necessidades posicionais com capacidades de sensores ópticos.",
                                  "commonMistakes": "Ignorar variações ambientais como vibração ou poeira que afetam sensores ópticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar Características de Sensores Ópticos Auxiliares",
                                  "subSteps": [
                                    "Estude fotodiodos: resposta espectral, tempo de ascensão/descida, aplicações em detecção de luz.",
                                    "Analise encoders lineares ópticos: resolução (pulso/mm), imunidade a sujeira, interfaces (quadrature).",
                                    "Investigue LiDAR: alcance, precisão (cm), FOV, consumo de energia em sistemas embarcados.",
                                    "Colete datasheets de modelos comerciais (ex.: VL53L0X para LiDAR, Honeywell encoders).",
                                    "Compare especificações quantitativas em tabela: precisão, custo, tamanho."
                                  ],
                                  "verification": "Compilar tabela comparativa com 3 sensores e 6 parâmetros chave, revisada por pares.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Datasheets online (DigiKey, Mouser), calculadora para conversões de resolução, navegador web.",
                                  "tips": "Foquem em curvas de resposta vs. frequência para feedback em tempo real.",
                                  "learningObjective": "Dominar especificações técnicas de fotodiodos, encoders e LiDAR para seleção informada.",
                                  "commonMistakes": "Confundir resolução espacial com temporal, levando a escolhas inadequadas para robótica dinâmica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Compatibilidade e Integração com Câmeras",
                                  "subSteps": [
                                    "Verifique interfaces: I2C/SPI para LiDAR, TTL para encoders, compatibilidade com MCU embarcado.",
                                    "Simule fusão de dados: como feedback do sensor auxilia calibração de pose da câmera.",
                                    "Calcule latência combinada: tempo de leitura sensor + processamento câmera.",
                                    "Considere sincronização: triggers hardware para alinhar leituras ópticas.",
                                    "Avalie consumo total de energia e impacto térmico no sistema mecatrônico."
                                  ],
                                  "verification": "Desenhar diagrama de integração (UML ou Fritzing) mostrando fluxo de dados câmera-sensor.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de simulação (Tinkercad, Proteus), Arduino IDE para proto-teste, diagramas em Draw.io.",
                                  "tips": "Teste proto com breadboard para validar comunicação real.",
                                  "learningObjective": "Avaliar sinergia entre sensores auxiliares e câmeras em sistemas embarcados.",
                                  "commonMistakes": "Subestimar overhead de comunicação, causando atrasos em loops de controle."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e Justificar Sensor Adequado",
                                  "subSteps": [
                                    "Pontue sensores usando critérios ponderados (precisão 40%, custo 20%, integração 40%).",
                                    "Justifique escolha: ex. 'Encoder linear para precisão sub-mm em atuadores lineares'.",
                                    "Planeje testes de validação: precisão posicional pós-integração.",
                                    "Documente alternativas rejeitadas e razões.",
                                    "Prepare especificação final para procurement."
                                  ],
                                  "verification": "Relatório de 1 página com escolha, pontuação e justificativa, aprovado por mentor.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha de pontuação, template de relatório, catálogo de fornecedores.",
                                  "tips": "Use método AHP (Analytic Hierarchy Process) simplificado para decisões multi-critério.",
                                  "learningObjective": "Desenvolver habilidade em tomada de decisão técnica baseada em evidências.",
                                  "commonMistakes": "Escolher pelo menor custo sem considerar TCO (custo total de propriedade)."
                                }
                              ],
                              "practicalExample": "Em um braço robótico pick-and-place, selecione um encoder linear óptico para feedback posicional preciso do efetuador final, complementando a câmera stereo que detecta objetos mas falha em precisão <1mm devido a paralaxe; integre via Arduino para calibração inicial alinhando marcas fiduciais.",
                              "finalVerifications": [
                                "Explicar verbalmente por que o sensor escolhido supera alternativas em 3 critérios chave.",
                                "Demonstrar diagrama de integração câmera-sensor sem erros lógicos.",
                                "Calcular precisão esperada do sistema híbrido com erro <5%.",
                                "Listar 2 riscos mitigados pela escolha (ex.: falha em baixa luz).",
                                "Preparar lista de peças com links de compra.",
                                "Simular leitura de dados em software e validar fusão."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na comparação de especificações (90%+ acurácia).",
                                "Justificativa robusta com dados quantitativos e qualitativos.",
                                "Compatibilidade comprovada com sistema embarcado e câmeras.",
                                "Criatividade em conexões com requisitos do projeto.",
                                "Documentação clara e profissional.",
                                "Identificação proativa de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física Óptica: Princípios de propagação de luz e detecção fotoelétrica.",
                                "Eletrônica Digital: Interfaces seriais e processamento de sinais embarcados.",
                                "Programação: Algoritmos de fusão sensorial (Kalman filter básico).",
                                "Matemática: Cálculo de resolução e erro posicional.",
                                "Gestão de Projetos: Análise custo-benefício e tomada de decisão."
                              ],
                              "realWorldApplication": "Em robôs autônomos industriais como os da ABB ou Fanuc, encoders ópticos lineares auxiliam câmeras em tarefas de soldagem precisa, enquanto LiDAR em drones DJI complementa visão para navegação em ambientes com obstruções ópticas, reduzindo erros posicionais de cm para mm."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Integrar GPUs e FPGAs para processamento",
                            "description": "Configurar hardware como NVIDIA Jetson ou FPGAs para aceleração de algoritmos de visão, otimizando latência em aplicações industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Seleção e Configuração Inicial do Hardware",
                                  "subSteps": [
                                    "Avalie requisitos do projeto: latência alvo, potência computacional e tamanho físico para visão computacional.",
                                    "Selecione hardware apropriado: NVIDIA Jetson (ex: TX2 ou Xavier) para GPUs ou FPGA (ex: Xilinx Zynq).",
                                    "Instale o hardware em uma plataforma de teste com alimentação estável e conexões de sensores (Câmeras USB/GigE).",
                                    "Conecte periféricos: câmera, rede e armazenamento externo.",
                                    "Realize boot inicial e verifique detecção de hardware via comandos básicos."
                                  ],
                                  "verification": "Execute 'nvidia-smi' (para GPU) ou 'lspci' (para FPGA) e confirme detecção sem erros.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "NVIDIA Jetson kit, FPGA dev board, cabos USB/Ethernet, multímetro, câmera industrial.",
                                  "tips": "Use kits de desenvolvimento oficiais para suporte pronto e documentação.",
                                  "learningObjective": "Entender compatibilidade de hardware para aceleração em visão computacional.",
                                  "commonMistakes": "Ignorar dissipação térmica levando a throttling; sempre monitore temperatura."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalação de Ambiente de Software e Drivers",
                                  "subSteps": [
                                    "Instale JetPack SDK (para Jetson) ou Vivado/Vitis (para FPGA) via imagem oficial.",
                                    "Configure CUDA (GPU) ou HLS (High-Level Synthesis para FPGA) para suporte a visão.",
                                    "Instale bibliotecas: OpenCV com CUDA, TensorRT para inferência acelerada.",
                                    "Compile e teste drivers de câmera com suporte GPU/FPGA.",
                                    "Configure ambiente virtual (Docker ou conda) para isolamento."
                                  ],
                                  "verification": "Compile e rode um hello-world CUDA/OpenCL ou bitstream FPGA simples sem crashes.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Computador host com Ubuntu, cartão SD/microSD, cabo serial para debug.",
                                  "tips": "Baixe imagens JetPack pré-compiladas para evitar erros de compilação.",
                                  "learningObjective": "Configurar stack de software otimizado para processamento paralelo.",
                                  "commonMistakes": "Versões incompatíveis de CUDA; verifique matriz de compatibilidade NVIDIA/Xilinx."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolvimento e Integração de Algoritmos de Visão",
                                  "subSteps": [
                                    "Porte algoritmo de visão (ex: detecção de objetos YOLO) para CUDA kernels ou HLS IP cores.",
                                    "Implemente pipeline: captura de frame → pré-processamento GPU/FPGA → inferência → pós-processamento.",
                                    "Otimize transferências de dados: use pinned memory (GPU) ou DMA (FPGA) para minimizar latência.",
                                    "Integre com sensores: buffer circular para frames em tempo real.",
                                    "Teste modular: rode cada estágio isoladamente."
                                  ],
                                  "verification": "Execute pipeline end-to-end com taxa de frames >30 FPS em vídeo teste.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "Código fonte OpenCV/TensorFlow, IDE (Nsight ou Vitis), datasets de visão (COCO).",
                                  "tips": "Profile com nvprof (GPU) ou Vitis Analyzer para identificar gargalos iniciais.",
                                  "learningObjective": "Implementar aceleração hardware para algoritmos de visão em tempo real.",
                                  "commonMistakes": "Transferências CPU-GPU desnecessárias; priorize processamento on-device."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimização de Latência e Performance",
                                  "subSteps": [
                                    "Meça latência baseline com ferramentas como TensorRT ou FPGA timers.",
                                    "Aplique otimizações: fusão de kernels (GPU), pipelining (FPGA), quantização INT8.",
                                    "Tune parâmetros: batch size, resolução de input, clock frequencies.",
                                    "Implemente multi-threading para overlap de compute e I/O.",
                                    "Monitore e ajuste para cenários industriais (vibração, variação de luz)."
                                  ],
                                  "verification": "Latência end-to-end <50ms em workload real, com uso de GPU/FPGA >80%.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Ferramentas de profiling (nvprof, JTAG debugger), osciloscópio para sinais.",
                                  "tips": "Use TensorRT para auto-otimização de modelos ONNX em Jetson.",
                                  "learningObjective": "Reduzir latência para aplicações industriais críticas.",
                                  "commonMistakes": "Overfitting em benchmarks sintéticos; teste com dados reais variáveis."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes Integrados e Deploy",
                                  "subSteps": [
                                    "Simule ambiente industrial: adicione ruído, delays de rede.",
                                    "Realize testes de estresse: 24h contínuo, variações térmicas.",
                                    "Gere relatórios de performance e logs de erro.",
                                    "Crie script de deploy: container Docker com auto-configuração.",
                                    "Documente setup para replicabilidade."
                                  ],
                                  "verification": "Sistema roda estável por 1h+ com precisão >95% em dataset de validação.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Setup de teste industrial mockup, ferramentas de logging (ROS ou custom).",
                                  "tips": "Use watchdog timers para recovery automático de falhas.",
                                  "learningObjective": "Validar integração para produção industrial.",
                                  "commonMistakes": "Subestimar consumo de energia; teste com fontes reais."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem automotiva, integre NVIDIA Jetson Xavier com câmera GigE para detectar defeitos em soldas em tempo real (latência <20ms), usando YOLOv5 acelerado por TensorRT, combinado com FPGA para pré-processamento de filtros customizados.",
                              "finalVerifications": [
                                "Pipeline processa >60 FPS com latência <50ms em hardware alvo.",
                                "Precisão do algoritmo mantida >95% pós-aceleração.",
                                "Sistema estável sob carga por 24h sem crashes.",
                                "Transferências de dados otimizadas (sem bottlenecks CPU-GPU/FPGA).",
                                "Documentação completa com scripts de deploy reproduzíveis.",
                                "Compatibilidade confirmada com sensores industriais padrão."
                              ],
                              "assessmentCriteria": [
                                "Eficiência: redução de latência >5x vs CPU baseline.",
                                "Correção: taxa de falsos positivos/negativos <5%.",
                                "Escalabilidade: adaptação a diferentes modelos de visão.",
                                "Robustez: performance sob variações ambientais.",
                                "Documentação: passos claros e código comentado.",
                                "Inovação: uso avançado de features hardware específicas."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: design de interfaces FPGA.",
                                "Programação Paralela: CUDA/OpenCL para GPUs.",
                                "Controle de Sistemas: integração em loops de feedback robótico.",
                                "Processamento de Sinais: filtros em visão computacional.",
                                "Gestão de Projetos: otimização iterativa com profiling."
                              ],
                              "realWorldApplication": "Em indústrias como automotiva e manufatura, acelera inspeção de qualidade em linhas de produção, permitindo detecção de falhas em alta velocidade (ex: robôs soldadores da Tesla ou linhas de montagem da Foxconn), reduzindo downtime e custos operacionais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Avaliar frames grabbers e interfaces",
                            "description": "Analisar dispositivos de aquisição de frames para sincronização de múltiplas câmeras em sistemas CLP ou microprocessados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Frame Grabbers e Interfaces",
                                  "subSteps": [
                                    "Estudar definições: frame grabber como hardware para capturar frames de vídeo de câmeras.",
                                    "Identificar tipos de interfaces comuns (Camera Link, GigE Vision, USB3 Vision).",
                                    "Aprender sobre sincronização: triggers externos, genlock e frame sync.",
                                    "Revisar protocolos para múltiplas câmeras em CLP/microprocessados.",
                                    "Explorar limitações de latência e taxa de frames."
                                  ],
                                  "verification": "Resumir em um diagrama os componentes e fluxos de sincronização.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação técnica de frame grabbers (NI, Matrox), vídeos tutoriais, glossário online.",
                                  "tips": "Use analogias com sincronização de relógios para entender genlock.",
                                  "learningObjective": "Dominar conceitos básicos e terminologia de frame grabbers.",
                                  "commonMistakes": "Confundir frame grabber com placa de captura simples de webcam."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Requisitos do Sistema para Sincronização",
                                  "subSteps": [
                                    "Definir número de câmeras, resolução e FPS necessários.",
                                    "Analisar ambiente: CLP (ex: Siemens S7) ou microprocessador (ex: Raspberry Pi/Arduino).",
                                    "Listar requisitos de sincronização: precisão temporal, triggers hardware/software.",
                                    "Calcular bandwidth total e latência aceitável.",
                                    "Documentar restrições de custo e compatibilidade."
                                  ],
                                  "verification": "Criar uma tabela de requisitos com métricas quantificáveis.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Planilhas Excel/Google Sheets, especificações de projeto do sistema.",
                                  "tips": "Priorize sincronização hardware para aplicações em tempo real.",
                                  "learningObjective": "Mapear necessidades específicas do sistema de visão.",
                                  "commonMistakes": "Subestimar overhead de rede em interfaces GigE."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar e Comparar Especificações de Frame Grabbers",
                                  "subSteps": [
                                    "Selecionar 3-5 modelos (ex: NI PCIe-1429, Matrox Solis).",
                                    "Comparar specs: canais de entrada, suporte a interfaces, suporte multi-câmera.",
                                    "Avaliar features de sincronização: TTL triggers, PTP/IEEE 1588.",
                                    "Verificar drivers e SDK para integração com CLP/microprocessadores.",
                                    "Pontuar opções em matriz de decisão (custo, performance, escalabilidade)."
                                  ],
                                  "verification": "Preencher matriz comparativa com scores e justificativas.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Datasheets de fabricantes, ferramentas de comparação online (ex: Matrox selector).",
                                  "tips": "Foque em throughput real vs. teórico em cenários multi-câmera.",
                                  "learningObjective": "Avaliar tecnicamente opções de hardware.",
                                  "commonMistakes": "Ignorar consumo de energia e dissipação térmica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Testar Configurações de Sincronização",
                                  "subSteps": [
                                    "Configurar simulação com software (ex: NI Vision Builder, Pleora eBUS Player).",
                                    "Testar triggers para sincronizar 2-4 câmeras virtuais.",
                                    "Medir latência e jitter com ferramentas de análise.",
                                    "Integrar mock-up com CLP simulado (ex: TIA Portal para Siemens).",
                                    "Ajustar parâmetros e registrar resultados."
                                  ],
                                  "verification": "Gravar vídeo ou logs mostrando sincronização sem drift >1ms.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Software gratuito de simulação, PC com PCIe/USB3, câmeras demo se disponível.",
                                  "tips": "Use osciloscópio virtual para visualizar sinais de trigger.",
                                  "learningObjective": "Validar performance em cenários simulados.",
                                  "commonMistakes": "Não calibrar câmeras antes do teste de sync."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar Avaliação e Recomendações de Integração",
                                  "subSteps": [
                                    "Compilar relatório com prós/contras de cada opção.",
                                    "Recomendar frame grabber ideal baseado em critérios.",
                                    "Esboçar diagrama de integração com CLP/microprocessador.",
                                    "Prever escalabilidade para mais câmeras.",
                                    "Listar próximos passos para implementação real."
                                  ],
                                  "verification": "Relatório final aprovado por checklist de completude.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de diagramação (Draw.io, Visio), template de relatório.",
                                  "tips": "Inclua análise de ROI (custo vs. ganho em precisão).",
                                  "learningObjective": "Sintetizar avaliação em decisão acionável.",
                                  "commonMistakes": "Omitir considerações de manutenção futura."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem automotiva, avaliar frame grabbers para sincronizar 4 câmeras Camera Link inspecionando soldas em tempo real, integrando com CLP Siemens para trigger preciso e detecção de defeitos sem atrasos.",
                              "finalVerifications": [
                                "Matriz comparativa completa com pelo menos 3 opções avaliadas.",
                                "Simulação bem-sucedida com sincronização <5ms de jitter.",
                                "Relatório com recomendação justificada e diagrama de integração.",
                                "Lista de riscos mitigados (ex: falha de sync).",
                                "Verificação de compatibilidade com CLP/microprocessador específico.",
                                "Cálculo de bandwidth confirmado empiricamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de specs de sincronização (90%+ acerto).",
                                "Qualidade da matriz comparativa (cobertura de todos critérios).",
                                "Resultados de simulação mensuráveis e sem erros graves.",
                                "Relatório claro, conciso e com evidências.",
                                "Compreensão demonstrada em conexões com sistemas reais.",
                                "Tempo respeitado com eficiência nos steps."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Sinais de trigger e interfaces paralelas/série.",
                                "Programação Embarcada: SDKs para CLP (Ladder/ST) e microcontroladores.",
                                "Redes Industriais: Protocolos como GigE Vision e PTP.",
                                "Processamento de Imagens: Impacto de sync em algoritmos de visão.",
                                "Gestão de Projetos: Análise custo-benefício e escalabilidade."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura (inspeção de qualidade), robótica (visão estéreo para navegação) e automação médica (cirurgias robóticas), onde sincronização precisa de múltiplas câmeras garante detecção confiável de defeitos ou posicionamento em tempo real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Processamento Básico de Imagens",
                    "description": "Etapas iniciais como aquisição, pré-processamento, segmentação e análise de imagens.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Aquisição de Imagens",
                        "description": "Etapa inicial do processamento básico de imagens, envolvendo a captura de imagens por meio de sensores ópticos em sistemas mecatrônicos de visão por computador, considerando aplicações industriais como na aeronáutica.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Identificar tipos de sensores de imagem",
                            "description": "Diferenciar sensores CCD e CMOS, explicando suas características, vantagens e aplicações em sistemas mecatrônicos para aquisição de imagens em ambientes industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos dos sensores de imagem",
                                  "subSteps": [
                                    "Pesquise o princípio básico de funcionamento de sensores de imagem, focando na conversão de luz em sinais elétricos.",
                                    "Identifique os componentes principais: pixels, matriz fotossensível e circuitry de leitura.",
                                    "Revise conceitos de óptica relacionados, como resolução e sensibilidade à luz.",
                                    "Anote definições chave: full-well capacity, quantum efficiency e noise.",
                                    "Visualize diagramas esquemáticos de sensores genéricos."
                                  ],
                                  "verification": "Crie um mapa mental resumindo os fundamentos e componentes principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagramas de sensores de imagem online (ex: Wikipedia CCD/CMOS)",
                                    "Vídeo introdutório sobre sensores de imagem (YouTube: 'Image Sensors Explained')"
                                  ],
                                  "tips": "Comece com analogias cotidianas, como como o olho humano captura luz.",
                                  "learningObjective": "Entender os princípios físicos e elétricos comuns a todos os sensores de imagem.",
                                  "commonMistakes": "Confundir sensores de imagem com lentes; foque apenas na detecção de luz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar sensores CCD em detalhes",
                                  "subSteps": [
                                    "Estude a arquitetura: charge transfer via buckets (pacotes de carga).",
                                    "Liste características: alta qualidade de imagem, baixo ruído, mas alto consumo de energia.",
                                    "Descreva vantagens: uniformidade pixel a pixel, bom para baixa luz.",
                                    "Identifique desvantagens: custo alto, velocidade lenta de leitura.",
                                    "Examine um diagrama de funcionamento do CCD."
                                  ],
                                  "verification": "Escreva um parágrafo explicando o processo de transferência de carga no CCD.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Artigo técnico: 'CCD vs CMOS' (All About Circuits)",
                                    "Simulador online de sensores CCD (PhET ou similar)"
                                  ],
                                  "tips": "Pense no CCD como uma esteira transportadora movendo 'baldes de elétrons'.",
                                  "learningObjective": "Dominar as especificações técnicas e trade-offs do sensor CCD.",
                                  "commonMistakes": "Ignorar o impacto do blooming (vazamento de carga em alta luz)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar sensores CMOS em detalhes",
                                  "subSteps": [
                                    "Estude a arquitetura: amplificadores por pixel, leitura ativa.",
                                    "Liste características: baixo consumo, alta velocidade, custo baixo.",
                                    "Descreva vantagens: integração com circuitos lógicos, rolling/ global shutter.",
                                    "Identifique desvantagens: ruído mais alto, variação pixel a pixel.",
                                    "Compare diagramas de leitura paralela no CMOS vs serial no CCD."
                                  ],
                                  "verification": "Desenhe um fluxograma do sinal de um pixel CMOS até a saída.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Datasheet de um sensor CMOS (ex: Sony IMX series)",
                                    "Vídeo: 'CMOS Image Sensors' (EEVblog)"
                                  ],
                                  "tips": "Associe CMOS a smartphones: rápido e eficiente em bateria.",
                                  "learningObjective": "Compreender as inovações que tornam o CMOS dominante em aplicações modernas.",
                                  "commonMistakes": "Subestimar fixed pattern noise; sempre mencione calibração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar CCD e CMOS diretamente",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: ruído, velocidade, custo, consumo, qualidade.",
                                    "Discuta cenários onde um supera o outro (ex: CCD para astronomia, CMOS para vídeo).",
                                    "Analise métricas quantitativas: frame rate, dynamic range.",
                                    "Resuma vantagens/desvantagens em bullet points.",
                                    "Debata trade-offs em contextos industriais."
                                  ],
                                  "verification": "Preencha e valide uma tabela de comparação com pelo menos 8 parâmetros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela comparativa pronta (Texas Instruments PDF)",
                                    "Planilha Google Sheets para customizar"
                                  ],
                                  "tips": "Use cores na tabela: verde para vantagens, vermelho para desvantagens.",
                                  "learningObjective": "Capacitar diferenciação precisa entre CCD e CMOS.",
                                  "commonMistakes": "Generalizar demais; sempre contextualize com dados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar aplicações em sistemas mecatrônicos industriais",
                                  "subSteps": [
                                    "Identifique usos de CCD: inspeção de alta precisão em baixa luz (ex: farmacêutica).",
                                    "Identifique usos de CMOS: visão em robôs de alta velocidade (ex: linhas de montagem).",
                                    "Discuta integração com PLCs e câmeras IP industriais.",
                                    "Analise cases: detecção de defeitos em solda (CCD) vs picking em armazéns (CMOS).",
                                    "Preveja tendências: CMOS híbridos com tech CCD."
                                  ],
                                  "verification": "Escreva 3 exemplos de aplicações industriais com justificativa de escolha do sensor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Case studies: 'Industrial Vision Systems' (Basler AG)",
                                    "Vídeos de aplicações mecatrônicas (YouTube: Cognex)"
                                  ],
                                  "tips": "Ligue à mecatrônica: sensor + atuador + controle.",
                                  "learningObjective": "Aplicar conhecimento de sensores a cenários reais industriais.",
                                  "commonMistakes": "Esquecer fatores ambientais como poeira/vibração afetando escolha."
                                }
                              ],
                              "practicalExample": "Em uma linha de produção de eletrônicos, use um sensor CCD para inspecionar placas de circuito em ambiente escuro com alta precisão, detectando microfissuras; para monitoramento rápido de movimento de peças, opte por CMOS em um braço robótico para evitar atrasos na produção.",
                              "finalVerifications": [
                                "Diferencie corretamente arquitetura CCD (transferência de carga) vs CMOS (leitura ativa).",
                                "Liste pelo menos 4 vantagens e 2 desvantagens de cada sensor.",
                                "Explique 2 aplicações industriais específicas para cada tipo.",
                                "Preencha uma tabela comparativa sem erros factuais.",
                                "Identifique quando escolher CCD sobre CMOS em mecatrônica.",
                                "Descreva impactos de ruído e velocidade em aquisição de imagens."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: 100% correto em definições e comparações (30%).",
                                "Completude: Cobertura de todas características, vantagens e aplicações (25%).",
                                "Profundidade: Inclusão de métricas quantitativas e trade-offs (20%).",
                                "Clareza: Explicações concisas com exemplos visuais (15%).",
                                "Aplicação contextual: Ligação forte a mecatrônica industrial (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física/Óptica: Princípios de fotodetecção e quantum efficiency.",
                                "Eletrônica: Circuitos analógicos/digitais e amplificadores.",
                                "Programação: Interfaces com bibliotecas de visão (OpenCV para processamento).",
                                "Engenharia Industrial: Integração em automação e Industry 4.0."
                              ],
                              "realWorldApplication": "Na indústria automotiva, sensores CMOS em sistemas de visão robótica detectam peças em alta velocidade para montagem; CCDs em inspeções de qualidade garantem detecção precisa de defeitos em pintura sob luz controlada, otimizando eficiência e reduzindo desperdícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Configurar captura de imagens",
                            "description": "Configurar parâmetros como resolução, taxa de frames e iluminação para aquisição de imagens em tempo real usando câmeras integradas a microcontroladores ou CLPs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar hardware e ambiente de software",
                                  "subSteps": [
                                    "Conectar a câmera ao microcontrolador ou CLP via interface apropriada (USB, I2C ou CSI).",
                                    "Instalar bibliotecas necessárias, como OpenCV para Python ou bibliotecas específicas do fabricante (ex: ESP32-CAM).",
                                    "Verificar reconhecimento do dispositivo no sistema operacional ou IDE do microcontrolador.",
                                    "Configurar o ambiente de desenvolvimento com exemplos de captura básica.",
                                    "Testar conexão inicial com comando de snapshot simples."
                                  ],
                                  "verification": "Câmera é detectada e um snapshot básico é capturado sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Microcontrolador ou CLP com suporte a câmera (ex: Raspberry Pi, ESP32-CAM)",
                                    "Câmera compatível",
                                    "Computador com IDE instalada (Arduino IDE, PlatformIO ou Thonny)",
                                    "Cabos USB ou de conexão"
                                  ],
                                  "tips": "Use um hub USB alimentado se houver múltiplos dispositivos para evitar quedas de energia.",
                                  "learningObjective": "Entender a integração física e lógica entre câmera e microcontrolador.",
                                  "commonMistakes": [
                                    "Conexões invertidas nos pinos",
                                    "Bibliotecas incompatíveis com a versão do firmware",
                                    "Falha em ativar modo de câmera no bootloader"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar parâmetros básicos de resolução e taxa de frames",
                                  "subSteps": [
                                    "Selecionar resolução desejada (ex: 640x480 para equilíbrio entre qualidade e performance).",
                                    "Definir taxa de frames (FPS) compatível com o hardware (ex: 30 FPS para tempo real).",
                                    "Implementar código para setar esses parâmetros via API da biblioteca (ex: cv2.VideoCapture.set()).",
                                    "Compilar e fazer upload do código para o microcontrolador.",
                                    "Executar captura contínua e monitorar FPS real via logs."
                                  ],
                                  "verification": "Captura ocorre na resolução e FPS configurados, confirmados por medição de dimensões da imagem e tempo entre frames.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código-fonte de exemplo para captura",
                                    "Monitor serial ou console para logs",
                                    "Ferramentas de medição de FPS (ex: cronômetro ou script)"
                                  ],
                                  "tips": "Comece com resoluções baixas para testar e aumente gradualmente para evitar sobrecarga de processamento.",
                                  "learningObjective": "Dominar configuração de parâmetros de vídeo para otimizar performance em tempo real.",
                                  "commonMistakes": [
                                    "Ignorar limitações de hardware levando a FPS instável",
                                    "Configurar resolução não suportada causando crash",
                                    "Não sincronizar FPS com clock do processador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar iluminação e parâmetros de exposição",
                                  "subSteps": [
                                    "Posicionar fontes de luz uniforme ao redor da cena de teste.",
                                    "Configurar ganho, exposição e brilho via parâmetros da câmera (ex: set(CV_CAP_PROP_GAIN, valor)).",
                                    "Calibrar white balance para condições de iluminação específicas.",
                                    "Testar em diferentes intensidades de luz e ajustar automaticamente se suportado.",
                                    "Integrar sensor de luz ambiente para ajuste dinâmico."
                                  ],
                                  "verification": "Imagens capturadas apresentam bom contraste, sem subexposição ou superexposição, medido por histograma de intensidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fontes de luz LED ajustáveis",
                                    "Alvo de calibração (padrão checkerboard)",
                                    "Software de análise de imagem (ex: ImageJ ou OpenCV histogram)"
                                  ],
                                  "tips": "Use luz difusa para evitar reflexos; teste em ciclo dia/noite simulado.",
                                  "learningObjective": "Aprender a otimizar qualidade de imagem sob variações de iluminação.",
                                  "commonMistakes": [
                                    "Luzes diretas causando saturação",
                                    "Ganho alto introduzindo ruído",
                                    "Ignorar auto-exposição em ambientes variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e otimizar captura em tempo real",
                                  "subSteps": [
                                    "Executar loop de captura contínua e processar frames em pipeline.",
                                    "Medir latência total (captura + processamento) e ajustar buffers.",
                                    "Implementar tratamento de erros para quedas de frames.",
                                    "Otimizar código removendo delays desnecessários.",
                                    "Salvar stream em vídeo para análise posterior."
                                  ],
                                  "verification": "Stream em tempo real sem lags perceptíveis (<100ms latência) e taxa de perda de frames <1%.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código otimizado para streaming",
                                    "Display ou app para visualizar stream ao vivo",
                                    "Ferramentas de profiling (ex: timeit em Python)"
                                  ],
                                  "tips": "Use threading ou async para separar captura de processamento.",
                                  "learningObjective": "Garantir robustez e performance em aplicações reais de visão.",
                                  "commonMistakes": [
                                    "Buffers cheios causando perda de frames",
                                    "Processamento síncrono bloqueando captura",
                                    "Não monitorar temperatura do hardware"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de inspeção de peças em linha de produção, configure uma câmera ESP32-CAM para capturar imagens de parafusos a 30 FPS em 320x240, com iluminação LED ajustada para detectar defeitos de superfície em tempo real, integrando ao CLP para sinalizar rejeitos.",
                              "finalVerifications": [
                                "Captura em tempo real na resolução e FPS exatos configurados.",
                                "Qualidade de imagem consistente sob variações de iluminação.",
                                "Latência total inferior a 100ms em loop contínuo.",
                                "Nenhuma perda de frames após 5 minutos de teste.",
                                "Configurações persistentes após reinicialização do dispositivo.",
                                "Integração bem-sucedida com microcontrolador sem conflitos de recursos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de resolução e FPS (100% match).",
                                "Qualidade de imagem avaliada por métricas (PSNR > 30dB).",
                                "Estabilidade do stream (variação FPS <5%).",
                                "Eficiência de uso de recursos (CPU <70%, memória estável).",
                                "Capacidade de ajuste dinâmico para iluminação.",
                                "Documentação clara do código e parâmetros usados."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Integração de sensores ópticos e interfaces de comunicação.",
                                "Programação: Uso de APIs de visão computacional e otimização de código embarcado.",
                                "Física/Óptica: Princípios de iluminação, exposição e formação de imagem.",
                                "Automação Industrial: Aplicação em CLPs para controle de processos.",
                                "Matemática: Cálculo de FPS, latência e métricas de imagem."
                              ],
                              "realWorldApplication": "Configuração de sistemas de visão em linhas de montagem automotivas para inspeção de soldas, ou em robôs agrícolas para detecção de frutos maduros, garantindo aquisição confiável de imagens para decisões autônomas em tempo real."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Entender formatos de imagem",
                            "description": "Reconhecer formatos comuns como BMP, JPEG e PNG, e suas implicações no armazenamento e processamento em projetos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceitos fundamentais de formatos de imagem",
                                  "subSteps": [
                                    "Pesquisar e definir o que é um formato de imagem digital.",
                                    "Identificar os formatos mais comuns usados em computação visual: BMP, JPEG e PNG.",
                                    "Entender os conceitos básicos de codificação sem perda (lossless) e com perda (lossy).",
                                    "Explorar a estrutura geral de um arquivo de imagem (cabeçalho, dados de pixels, metadados).",
                                    "Visualizar exemplos de imagens em diferentes formatos usando um visualizador de arquivos."
                                  ],
                                  "verification": "Criar um diagrama simples comparando lossless vs lossy e listar 3 formatos com suas classificações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com internet",
                                    "Visualizador de imagens (ex: IrfanView ou Windows Photos)",
                                    "Imagens de teste em BMP, JPEG e PNG"
                                  ],
                                  "tips": "Use diagramas para visualizar diferenças; foque em exemplos visuais para fixar conceitos.",
                                  "learningObjective": "Compreender os princípios básicos que diferenciam formatos de imagem.",
                                  "commonMistakes": [
                                    "Confundir formato com resolução",
                                    "Ignorar metadados como parte do arquivo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Análise detalhada dos formatos BMP e JPEG",
                                  "subSteps": [
                                    "Estudar BMP: formato sem compressão, bitmap puro, alto tamanho de arquivo.",
                                    "Analisar JPEG: compressão lossy, ideal para fotos, usa DCT (Transformada Cossenoidal Discreta).",
                                    "Comparar tamanhos de arquivo de uma mesma imagem em BMP e JPEG.",
                                    "Observar artefatos de compressão em JPEG ampliando imagens.",
                                    "Testar conversão de imagem de BMP para JPEG e medir redução de tamanho."
                                  ],
                                  "verification": "Medir e registrar o tamanho de uma imagem de 1MB em BMP convertida para JPEG (deve reduzir >80%).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de edição/imagem (GIMP ou Paint.NET gratuito)",
                                    "Imagens de teste de alta resolução",
                                    "Calculadora para tamanhos de arquivo"
                                  ],
                                  "tips": "Amplie imagens JPEG para ver perdas; sempre salve cópias originais.",
                                  "learningObjective": "Dominar características técnicas e trade-offs de BMP e JPEG.",
                                  "commonMistakes": [
                                    "Achar que BMP é sempre melhor qualidade",
                                    "Não notar perdas cumulativas em re-salvamentos JPEG"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Análise detalhada do formato PNG e comparações",
                                  "subSteps": [
                                    "Estudar PNG: compressão lossless, suporta transparência (alpha channel), bom para gráficos.",
                                    "Comparar PNG vs JPEG em imagens com texto ou linhas nítidas.",
                                    "Analisar suporte a transparência: converter imagem com fundo para PNG.",
                                    "Realizar benchmark de processamento: tempo de abertura/carregamento em software.",
                                    "Criar tabela comparativa: tamanho, qualidade, uso ideal para cada formato."
                                  ],
                                  "verification": "Produzir tabela comparativa com exemplos reais de tamanhos e usos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "GIMP ou Photoshop (trial)",
                                    "Imagens com transparência",
                                    "Planilha Excel para tabela"
                                  ],
                                  "tips": "Use PNG para logos/ícones; teste em hardware limitado para ver impacto no processamento.",
                                  "learningObjective": "Diferenciar PNG dos outros e identificar cenários ótimos.",
                                  "commonMistakes": [
                                    "Usar JPEG para transparência",
                                    "Subestimar overhead de PNG em imagens grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implicações em armazenamento e processamento mecatrônico",
                                  "subSteps": [
                                    "Calcular impacto no armazenamento: fórmula básica (largura x altura x profundidade de cor).",
                                    "Discutir processamento em tempo real: JPEG para vídeo em câmeras embarcadas.",
                                    "Analisar em mecatrônica: escolha de formato para visão computacional em robôs.",
                                    "Simular cenário: estimar memória RAM para buffer de imagem em BMP vs PNG.",
                                    "Pesquisar bibliotecas como OpenCV e suporte a formatos."
                                  ],
                                  "verification": "Resolver exercício: calcular tamanho de imagem 640x480 em BMP (24-bit) vs JPEG comprimido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "OpenCV instalado (opcional)",
                                    "Documentação de formatos online",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Considere constraints de embedded systems: priorize compressão para baixa latência.",
                                  "learningObjective": "Aplicar conhecimentos a contextos de projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Ignorar profundidade de cor no cálculo",
                                    "Não considerar taxa de frames em vídeo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de visão para robô seguidor de linha, capturar imagem da linha em PNG (lossless para precisão em bordas) e converter para JPEG apenas para transmissão serial, reduzindo uso de banda em 70%. Testar com câmera USB e OpenCV.",
                              "finalVerifications": [
                                "Listar prós e contras de BMP, JPEG e PNG corretamente.",
                                "Calcular tamanho aproximado de uma imagem em cada formato.",
                                "Identificar formato ideal para foto vs gráfico vetorial.",
                                "Explicar impacto de JPEG em processamento em tempo real.",
                                "Demonstrar conversão sem perda de qualidade crítica usando software.",
                                "Discutir uso em mecatrônica com exemplo concreto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição técnica de cada formato (80%+ acerto).",
                                "Capacidade de comparar tamanhos e qualidades com evidências práticas.",
                                "Correta identificação de implicações em armazenamento/processamento.",
                                "Uso adequado de terminologia (lossless, lossy, alpha channel).",
                                "Aplicação contextual a projetos mecatrônicos.",
                                "Tabela ou diagrama comparativo completo e claro."
                              ],
                              "crossCurricularConnections": [
                                "Informática: Algoritmos de compressão e estruturas de dados.",
                                "Eletrônica: Interfaces de sensores de imagem (USB, MIPI CSI).",
                                "Matemática: Cálculos de área, transformadas (DCT em JPEG).",
                                "Física: Representação digital de luz/cor (profundidade de bits).",
                                "Programação: Bibliotecas como Pillow/Python ou OpenCV para manipulação."
                              ],
                              "realWorldApplication": "Em sistemas de inspeção industrial mecatrônicos, como linhas de montagem automotivas, usar JPEG para streaming de vídeo em tempo real de câmeras (baixa latência) e PNG para imagens de referência de alta precisão em detecção de defeitos, otimizando armazenamento em SD cards embarcados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Pré-processamento de Imagens",
                        "description": "Etapa de melhoria da qualidade da imagem capturada, removendo ruídos e corrigindo distorções para preparar dados para análises subsequentes em sistemas de visão.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Aplicar filtros de redução de ruído",
                            "description": "Implementar filtros como média, mediana e gaussiano para eliminar ruídos em imagens adquiridas em condições industriais variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de ruído em imagens e tipos de filtros",
                                  "subSteps": [
                                    "Identificar tipos comuns de ruído em imagens industriais (gaussiano, sal-e-pimenta, speckle).",
                                    "Explicar o princípio de operação dos filtros de média, mediana e gaussiano.",
                                    "Analisar quando cada filtro é mais apropriado para condições variáveis industriais.",
                                    "Estudar a convolução como base matemática para filtros.",
                                    "Coletar imagens de exemplo com ruído de sensores industriais."
                                  ],
                                  "verification": "Resumir em um diagrama comparativo os filtros e tipos de ruído, com exemplos visuais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação OpenCV, imagens de teste industriais (ex: de câmeras CCD em fábrica), Jupyter Notebook.",
                                  "tips": "Use visualizações side-by-side antes/depois para intuitivamente entender o impacto.",
                                  "learningObjective": "Dominar os conceitos teóricos para seleção adequada de filtros.",
                                  "commonMistakes": "Confundir ruído gaussiano com sal-e-pimenta; ignorar o custo computacional dos filtros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o filtro de média (box filter)",
                                  "subSteps": [
                                    "Carregar imagem ruidosa usando OpenCV (cv2.imread).",
                                    "Aplicar cv2.blur() ou cv2.boxFilter() com kernel size 3x3 ou 5x5.",
                                    "Visualizar imagem original vs. filtrada com cv2.imshow() ou matplotlib.",
                                    "Calcular métricas básicas como variância do ruído reduzido.",
                                    "Testar diferentes tamanhos de kernel e registrar resultados."
                                  ],
                                  "verification": "Imagem filtrada mostra suavização uniforme sem artefatos excessivos; variância reduzida em pelo menos 30%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python 3+, OpenCV, NumPy, Matplotlib, imagem ruidosa industrial.",
                                  "tips": "Comece com kernel pequeno para evitar borrão excessivo em bordas.",
                                  "learningObjective": "Implementar e testar filtro de média para ruído gaussiano leve.",
                                  "commonMistakes": "Usar kernel muito grande, causando perda de detalhes finos; não normalizar a imagem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o filtro de mediana",
                                  "subSteps": [
                                    "Carregar a mesma imagem ruidosa.",
                                    "Aplicar cv2.medianBlur() com kernel 3x3 ou 5x5.",
                                    "Comparar visualmente com filtro de média.",
                                    "Medir tempo de execução com time.time().",
                                    "Aplicar em regiões com ruído impulsivo (sal-e-pimenta)."
                                  ],
                                  "verification": "Ruído impulsivo eliminado sem suavização excessiva; tempo de processamento registrado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmos do step anterior, mais timer Python.",
                                  "tips": "Ideal para ruído sal-e-pimenta; kernel ímpar obrigatório.",
                                  "learningObjective": "Aplicar filtro não-linear para ruídos impulsivos comuns em sensores industriais.",
                                  "commonMistakes": "Aplicar em imagens com bordas finas, distorcendo-as; confundir com filtro de média."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o filtro gaussiano e comparar filtros",
                                  "subSteps": [
                                    "Aplicar cv2.GaussianBlur() com sigma ajustável (ex: 1.0).",
                                    "Criar script comparativo plotando as três imagens filtradas.",
                                    "Calcular PSNR/SSIM para cada filtro vs. imagem original limpa.",
                                    "Selecionar o melhor filtro para cenários industriais variáveis.",
                                    "Salvar imagens finais e relatório de performance."
                                  ],
                                  "verification": "Gráfico comparativo mostra PSNR/SSIM melhorado; relatório identifica filtro ótimo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "OpenCV, scikit-image (para SSIM), imagens de referência limpas.",
                                  "tips": "Ajuste sigma baseado no nível de ruído; gaussiano preserva bordas melhor que média.",
                                  "learningObjective": "Dominar filtro gaussiano e avaliação quantitativa para otimização.",
                                  "commonMistakes": "Sigma muito alto borrando detalhes; não comparar métricas normalizadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em pipeline industrial e otimizar",
                                  "subSteps": [
                                    "Integrar filtro escolhido em um pipeline de visão (ex: detecção de defeitos).",
                                    "Testar em múltiplas imagens variáveis (iluminação/baixa luz).",
                                    "Otimizar parâmetros com loop de grid search simples.",
                                    "Documentar pipeline completo em código.",
                                    "Executar em tempo real com webcam simulando sensor industrial."
                                  ],
                                  "verification": "Pipeline processa imagens em <1s com ruído reduzido >40%; código comentado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Webcam ou vídeo industrial, OpenCV VideoCapture.",
                                  "tips": "Use multithreading para real-time; priorize mediana para ruído variável.",
                                  "learningObjective": "Integrar filtros em sistemas mecatrônicos reais.",
                                  "commonMistakes": "Ignorar latência em aplicações industriais; overfit em uma única imagem."
                                }
                              ],
                              "practicalExample": "Em uma linha de produção de peças automotivas, aplicar filtro mediana em imagens de câmera CCD com ruído sal-e-pimenta devido a vibrações, melhorando detecção de defeitos de 70% para 95% de acurácia.",
                              "finalVerifications": [
                                "PSNR/SSIM melhorado em pelo menos 5dB comparado à original.",
                                "Tempo de processamento <500ms por imagem 640x480.",
                                "Ruído visual eliminado em 90% das regiões afetadas.",
                                "Bordas preservadas (teste com Canny edge detector).",
                                "Pipeline roda em loop real-time sem crashes.",
                                "Relatório com gráficos comparativos salvo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção e implementação dos três filtros (100% funcionalidade).",
                                "Qualidade quantitativa: ganho em PSNR/SSIM >20%.",
                                "Eficiência: otimização de parâmetros para cenários variáveis.",
                                "Documentação: código limpo com comentários e visualizações.",
                                "Criatividade: adaptação para condições industriais reais.",
                                "Análise de erros: identificação e mitigação de pitfalls comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Convolução e estatística descritiva (média, mediana).",
                                "Eletrônica: Ruído em sensores CCD/CMOS e sinal-analógico-digital.",
                                "Programação: Otimização de algoritmos em Python/OpenCV.",
                                "Física: Óptica e propagação de ruído em ambientes industriais.",
                                "Gestão Industrial: Melhoria de processos de inspeção de qualidade."
                              ],
                              "realWorldApplication": "Em fábricas de manufatura, como inspeção automatizada de soldas em painéis solares ou detecção de contaminantes em linhas alimentícias, onde condições variáveis (poeira, vibração) geram ruído, permitindo decisões em tempo real sem falsos positivos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Realizar normalização de intensidade",
                            "description": "Ajustar níveis de brilho e contraste para uniformizar imagens, facilitando o processamento em robótica mecatrônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar a imagem",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias: OpenCV, NumPy e Matplotlib via pip.",
                                    "Importar as bibliotecas no script Python.",
                                    "Carregar a imagem de entrada usando cv2.imread() em escala de cinza.",
                                    "Exibir a imagem original para inspeção visual inicial.",
                                    "Verificar dimensões e tipo de dados da imagem com .shape e .dtype."
                                  ],
                                  "verification": "Imagem carregada corretamente e exibida sem erros, com shape e dtype confirmados no console.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "OpenCV (cv2)",
                                    "NumPy",
                                    "Matplotlib",
                                    "Imagem de teste em formato JPG/PNG (ex: peça mecânica sob iluminação irregular)"
                                  ],
                                  "tips": "Use imagens de domínio público ou capturadas por câmera robótica para relevância mecatrônica.",
                                  "learningObjective": "Configurar ambiente de visão computacional e manipular imagens básicas.",
                                  "commonMistakes": [
                                    "Esquecer de converter para escala de cinza (cv2.COLOR_BGR2GRAY)",
                                    "Caminho incorreto do arquivo de imagem",
                                    "Não importar bibliotecas corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar distribuição de intensidade da imagem original",
                                  "subSteps": [
                                    "Calcular estatísticas básicas: min, max, média e desvio padrão com np.min(), np.max(), np.mean() e np.std().",
                                    "Gerar e plotar histograma da intensidade com cv2.calcHist() e plt.hist().",
                                    "Identificar problemas como baixo contraste ou viés de brilho.",
                                    "Normalizar temporariamente para faixa [0,1] para análise com (img - min) / (max - min).",
                                    "Registrar valores chave em log ou print para referência."
                                  ],
                                  "verification": "Estatísticas impressas e histograma plotado mostrando distribuição não-uniforme.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código Python do Step 1",
                                    "Jupyter Notebook para visualizações interativas"
                                  ],
                                  "tips": "Use plt.subplot() para comparar histogramas lado a lado.",
                                  "learningObjective": "Interpretar estatísticas de intensidade para diagnosticar problemas de imagem.",
                                  "commonMistakes": [
                                    "Calcular histograma em imagem colorida sem conversão",
                                    "Ignorar overflow em cálculos de min/max",
                                    "Não escalar histograma para visualização clara"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar normalização de intensidade min-max",
                                  "subSteps": [
                                    "Calcular min_val e max_val da imagem.",
                                    "Aplicar fórmula: normalized = (img - min_val) * 255 / (max_val - min_val).",
                                    "Converter resultado para uint8 com .astype(np.uint8).",
                                    "Opcionalmente, aplicar equalização de histograma com cv2.equalizeHist() para melhor contraste.",
                                    "Exibir imagem normalizada lado a lado com original."
                                  ],
                                  "verification": "Imagem normalizada exibida com brilho/contraste uniformes e valores de pixel em [0,255].",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Funções NumPy para operações vetoriais"
                                  ],
                                  "tips": "Use operações vetoriais NumPy para eficiência em imagens grandes.",
                                  "learningObjective": "Implementar algoritmo de normalização min-max de forma precisa e eficiente.",
                                  "commonMistakes": [
                                    "Dividir por zero se min==max (adicionar epsilon: 1e-8)",
                                    "Esquecer de multiplicar por 255 para escala 8-bit",
                                    "Não clipar valores fora de [0,255]"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar resultado e integrar em pipeline mecatrônico",
                                  "subSteps": [
                                    "Comparar histogramas antes/depois para uniformidade.",
                                    "Medir tempo de processamento com time.time().",
                                    "Salvar imagem normalizada com cv2.imwrite().",
                                    "Testar em múltiplas imagens sob diferentes iluminações.",
                                    "Simular integração: passar imagem normalizada para detecção de bordas (cv2.Canny())."
                                  ],
                                  "verification": "Histogramas comparados mostram melhoria; imagem salva e pipeline de teste roda sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Múltiplas imagens de teste",
                                    "Script completo integrado"
                                  ],
                                  "tips": "Automatize em função reutilizável para sistemas robóticos.",
                                  "learningObjective": "Avaliar eficácia da normalização e prepará-la para processamento downstream.",
                                  "commonMistakes": [
                                    "Não testar com variações de iluminação",
                                    "Ignorar performance em tempo real",
                                    "Salvar sem verificação de qualidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um robô mecatrônico para inspeção de soldas em linha de produção, capture imagem de uma peça sob luz variável, aplique normalização para uniformizar intensidade, permitindo detecção confiável de defeitos via thresholding subsequente.",
                              "finalVerifications": [
                                "Valores de pixel da imagem normalizada estão estritamente em [0, 255].",
                                "Histograma pós-normalização exibe distribuição mais uniforme que o original.",
                                "Contraste visual aprimorado em pelo menos 20% (medido por desvio padrão).",
                                "Processamento completo em menos de 100ms para imagem 640x480.",
                                "Normalização preserva estruturas de borda originais (teste com Canny).",
                                "Funciona consistentemente em 5 imagens de teste variadas."
                              ],
                              "assessmentCriteria": [
                                "Correção da fórmula min-max aplicada sem erros numéricos.",
                                "Análise estatística completa com histograma e métricas.",
                                "Eficiência computacional com operações vetoriais.",
                                "Documentação clara do código com comentários.",
                                "Testes em cenários reais de iluminação irregular.",
                                "Integração suave em pipeline de visão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e normalização linear.",
                                "Programação: Manipulação eficiente de arrays multidimensionais em Python/NumPy.",
                                "Física: Óptica e propriedades espectrais da luz em sensores CCD/CMOS.",
                                "Engenharia de Controle: Pré-processamento para feedback visual em loops de controle robótico.",
                                "Eletrônica: Calibração de câmeras em sistemas embarcados."
                              ],
                              "realWorldApplication": "Em sistemas mecatrônicos industriais, como robôs de visão para controle de qualidade em montagem automotiva, onde normalização garante detecção robusta de componentes sob variações de iluminação fabril, reduzindo falsos positivos em 30-50%."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Executar transformações geométricas",
                            "description": "Aplicar rotações, escalas e correções de perspectiva para alinhar imagens em sistemas de inspeção aeronáutica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise da Imagem Original e Identificação de Desalinhamentos",
                                  "subSteps": [
                                    "Carregue a imagem de inspeção aeronáutica usando biblioteca como OpenCV.",
                                    "Visualize a imagem para identificar rotações, escalas e distorções de perspectiva.",
                                    "Use ferramentas de detecção de bordas ou marcadores fiduciais para quantificar desalinhamentos.",
                                    "Registre ângulos de rotação, fatores de escala e pontos de perspectiva.",
                                    "Documente os parâmetros necessários em um relatório inicial."
                                  ],
                                  "verification": "Imagem analisada exibida com anotações de desalinhamentos visíveis e parâmetros documentados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Computador com Python e OpenCV instalados, imagem de exemplo de peça aeronáutica desalinhada.",
                                  "tips": "Use escala de cinza para análise inicial para reduzir ruído de cor.",
                                  "learningObjective": "Identificar e quantificar precisamente desalinhamentos geométricos em imagens de inspeção.",
                                  "commonMistakes": "Ignorar distorções sutis de perspectiva ou confundir rotação com escala."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo das Matrizes de Transformação",
                                  "subSteps": [
                                    "Calcule a matriz de rotação usando cv2.getRotationMatrix2D com ângulo detectado.",
                                    "Determine fatores de escala e crie matriz de escala com cv2.resize ou affine transform.",
                                    "Estime matriz de perspectiva usando cv2.getPerspectiveTransform com 4 pontos correspondentes.",
                                    "Combine matrizes em uma transformação afim composta se necessário.",
                                    "Teste preliminarmente as matrizes em uma cópia da imagem."
                                  ],
                                  "verification": "Matrizes calculadas salvas como variáveis e visualizadas com transformações aplicadas parcialmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ambiente Python com NumPy e OpenCV, calculadora ou script para ângulos.",
                                  "tips": "Sempre normalize pontos de perspectiva para precisão subpixel.",
                                  "learningObjective": "Dominar o cálculo matemático de matrizes para rotações, escalas e perspectivas.",
                                  "commonMistakes": "Erro de sinal no ângulo de rotação ou pontos de perspectiva incorretos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicação das Transformações Geométricas",
                                  "subSteps": [
                                    "Aplique rotação com cv2.warpAffine na imagem.",
                                    "Ajuste escala com cv2.warpAffine ou cv2.resize após rotação.",
                                    "Corrija perspectiva com cv2.warpPerspective na imagem transformada.",
                                    "Alinhe a imagem transformada com um template de referência usando métricas como MSE.",
                                    "Salve a imagem final alinhada em formato adequado."
                                  ],
                                  "verification": "Imagem transformada comparada visualmente com template, com alinhamento preciso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Imagens de template de referência, Python/OpenCV.",
                                  "tips": "Use interpolação bilinear para suavidade em warpAffine e warpPerspective.",
                                  "learningObjective": "Executar transformações geométricas de forma sequencial e precisa em código.",
                                  "commonMistakes": "Aplicar transformações na ordem errada, causando distorções acumuladas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação e Refinamento do Alinhamento",
                                  "subSteps": [
                                    "Calcule métricas de qualidade como SSIM ou erro de alinhamento com template.",
                                    "Ajuste iterativamente parâmetros se o alinhamento for inferior a 95%.",
                                    "Compare bordas detectadas antes e depois da transformação.",
                                    "Gere relatório com antes/depois e métricas quantitativas.",
                                    "Teste robustez com ruído adicionado à imagem original."
                                  ],
                                  "verification": "Relatório gerado com métricas acima de threshold e alinhamento visual confirmado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Scripts de métricas (scikit-image para SSIM), imagens com ruído.",
                                  "tips": "Automatize iterações com loop de otimização simples como gradient descent básico.",
                                  "learningObjective": "Avaliar e otimizar transformações para qualidade de inspeção industrial.",
                                  "commonMistakes": "Aceitar alinhamento visual sem métricas quantitativas."
                                }
                              ],
                              "practicalExample": "Em um sistema de inspeção de asas de aeronaves, carregue uma imagem de câmera onde a peça está rotacionada 5 graus, escalada 10% e com perspectiva distorcida devido ao ângulo de visão. Aplique transformações para alinhá-la perfeitamente com um template CAD, permitindo detecção precisa de microfissuras.",
                              "finalVerifications": [
                                "Imagem final alinhada com template com erro MSE < 0.01.",
                                "Bordas da peça coincidem em >98% dos pontos chave.",
                                "Transformações aplicadas sem artefatos visíveis como borrões.",
                                "Processo roda em <2 segundos para imagens 1024x1024.",
                                "Robustez mantida com ±10% ruído gaussiano.",
                                "Relatório gerado com métricas e visualizações."
                              ],
                              "assessmentCriteria": [
                                "Precisão das matrizes calculadas (erro <1 grau/pixel).",
                                "Qualidade da imagem final (SSIM >0.95 com template).",
                                "Eficiência computacional (tempo de execução).",
                                "Capacidade de lidar com variações na entrada.",
                                "Documentação clara do código e processo.",
                                "Correção de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de transformação).",
                                "Programação: Manipulação de bibliotecas como OpenCV e NumPy.",
                                "Física: Óptica e geometria projetiva em visão.",
                                "Engenharia Aeronáutica: Inspeção não-destrutiva de componentes."
                              ],
                              "realWorldApplication": "Em linhas de montagem aeronáutica, como na Boeing ou Embraer, alinhar imagens de câmeras para inspeção automatizada de soldas e revestimentos, reduzindo falsos positivos em detecção de defeitos e acelerando produção."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Segmentação de Imagens",
                        "description": "Processo de divisão da imagem em regiões de interesse, separando objetos do fundo para análise em aplicações mecatrônicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Implementar threshold adaptativo",
                            "description": "Usar métodos de limiarização global e local para segmentar objetos em imagens com iluminação não uniforme.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Threshold Global e Local",
                                  "subSteps": [
                                    "Estude o conceito de limiarização global (Otsu, método de média) e suas limitações em imagens com iluminação não uniforme.",
                                    "Aprenda métodos locais adaptativos como Niblack, Sauvola e Bradley-Roth, focando em janelas deslizantes.",
                                    "Analise fórmulas matemáticas: para Niblack, T(x,y) = m(x,y) + k * σ(x,y), onde m é média e σ é desvio padrão.",
                                    "Compare exemplos visuais de imagens antes e depois da aplicação em cenários de iluminação variada.",
                                    "Identifique quando usar global vs. local baseado em histograma e gradientes de intensidade."
                                  ],
                                  "verification": "Resuma em um diagrama ou tabela comparativa os métodos global e local, incluindo prós e contras.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação OpenCV ou scikit-image",
                                    "Artigos sobre threshold adaptativo (Niblack, Sauvola)",
                                    "Imagens de teste com iluminação não uniforme"
                                  ],
                                  "tips": "Use visualizações de histograma para entender variações de iluminação.",
                                  "learningObjective": "Dominar os princípios teóricos de threshold adaptativo para segmentação em condições reais.",
                                  "commonMistakes": [
                                    "Confundir global com local",
                                    "Ignorar o impacto do parâmetro k na sensibilidade",
                                    "Não considerar ruído na imagem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Pré-processar a Imagem de Entrada",
                                  "subSteps": [
                                    "Carregue a imagem usando bibliotecas como OpenCV ou Pillow em Python.",
                                    "Converta para escala de cinza se necessário e aplique filtros de suavização (Gaussian blur) para reduzir ruído.",
                                    "Defina parâmetros iniciais: tamanho da janela local (ex: 15-50 pixels), fator k (0.2-0.5 para Niblack).",
                                    "Crie uma máscara inicial ou histograma local para análise preliminar.",
                                    "Salve imagens intermediárias para inspeção visual."
                                  ],
                                  "verification": "Gere e visualize a imagem pré-processada; confirme ausência excessiva de ruído via inspeção visual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com OpenCV instalado",
                                    "Imagens de teste (ex: peças mecânicas com sombras)",
                                    "Jupyter Notebook para experimentação"
                                  ],
                                  "tips": "Comece com janelas pequenas para bordas nítidas e aumente para áreas uniformes.",
                                  "learningObjective": "Preparar dados de imagem adequadamente para aplicação eficiente de threshold adaptativo.",
                                  "commonMistakes": [
                                    "Pular pré-processamento levando a thresholds instáveis",
                                    "Escolha inadequada de blur kernel causando perda de detalhes",
                                    "Ignorar conversão para grayscale"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Algoritmo de Threshold Adaptativo",
                                  "subSteps": [
                                    "Implemente threshold global como baseline usando cv2.threshold() com método Otsu.",
                                    "Codifique threshold local: use cv2.adaptiveThreshold() ou função customizada para Niblack/Sauvola.",
                                    "Aplique o threshold: pixels > T(x,y) viram 255 (objeto), senão 0 (fundo).",
                                    "Morphologicamente feche buracos com operações erode/dilate para refinar a segmentação.",
                                    "Teste em múltiplas imagens e ajuste parâmetros iterativamente."
                                  ],
                                  "verification": "Execute o código e compare binárias global vs. adaptativa; meça taxa de sucesso visual.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código-fonte OpenCV Python",
                                    "Exemplos de repositórios GitHub para Niblack",
                                    "Ferramentas de debug como matplotlib para plotar thresholds"
                                  ],
                                  "tips": "Use funções prontas do OpenCV para prototipagem rápida antes de customizar.",
                                  "learningObjective": "Codificar e aplicar threshold adaptativo para segmentar objetos com sucesso.",
                                  "commonMistakes": [
                                    "Valores fixos de k inadequados para diferentes imagens",
                                    "Não tratar bordas da janela",
                                    "Esquecer pós-processamento morfológico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Otimizar a Segmentação",
                                  "subSteps": [
                                    "Calcule métricas como Dice coefficient ou IoU comparando com ground truth manual.",
                                    "Visualize mapas de threshold para identificar regiões problemáticas.",
                                    "Otimize parâmetros via grid search ou otimização automática (ex: scipy.optimize).",
                                    "Teste robustez com variações de iluminação e ruído adicionado.",
                                    "Documente o pipeline final em um script reutilizável."
                                  ],
                                  "verification": "Obtenha IoU > 0.85 em pelo menos 3 imagens de teste variadas.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Ground truth annotations (ferramentas como LabelMe)",
                                    "Bibliotecas scikit-image para métricas",
                                    "Datasets públicos como BSDS500"
                                  ],
                                  "tips": "Automatize avaliação com loops para múltiplos parâmetros.",
                                  "learningObjective": "Avaliar quantitativamente e refinar implementações para precisão industrial.",
                                  "commonMistakes": [
                                    "Avaliação apenas visual sem métricas",
                                    "Overfitting de parâmetros a uma única imagem",
                                    "Ignorar tempo de computação em aplicações reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de inspeção mecatrônica, segmente uma peça metálica com sombras irregulares em uma linha de produção: aplique Niblack com janela 31x31 e k=0.2 para isolar a peça do fundo texturizado, permitindo detecção de defeitos via contornos.",
                              "finalVerifications": [
                                "Segmentação separa corretamente objeto do fundo em imagens com gradientes de iluminação.",
                                "Métricas IoU/Dice > 0.80 em conjunto de teste variado.",
                                "Tempo de processamento < 100ms por imagem em hardware padrão.",
                                "Robustez confirmada: funciona com ±20% variação de brilho.",
                                "Binária refinada sem buracos ou ruído excessivo.",
                                "Código executável e comentado para reutilização."
                              ],
                              "assessmentCriteria": [
                                "Precisão da segmentação (IoU > 0.85).",
                                "Adequação a iluminação não uniforme (comparação visual).",
                                "Eficiência computacional (otimizado para real-time).",
                                "Flexibilidade de parâmetros e generalização.",
                                "Qualidade do código (legibilidade, comentários).",
                                "Refinamento pós-threshold (morfologia aplicada)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva (média, desvio padrão em janelas).",
                                "Programação: Algoritmos de processamento de imagem em Python/OpenCV.",
                                "Física: Óptica e propriedades de luz em imagens reais.",
                                "Engenharia Mecatrônica: Integração em sistemas de visão robótica."
                              ],
                              "realWorldApplication": "Inspeção automatizada de componentes em linhas de montagem mecatrônicas, detecção de objetos em robôs autônomos sob condições de iluminação variáveis em fábricas ou veículos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Detectar bordas com operadores",
                            "description": "Aplicar operadores como Sobel e Canny para identificar contornos de objetos em sistemas de visão industrial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Detecção de Bordas",
                                  "subSteps": [
                                    "Estude o que são bordas em imagens e sua importância na segmentação.",
                                    "Aprenda sobre gradientes e como operadores detectam mudanças de intensidade.",
                                    "Revise os operadores Sobel (para gradientes horizontais e verticais) e Canny (multi-etapa com supressão de não-máximos).",
                                    "Analise fórmulas matemáticas: Sobel Gx = [-1 0 1; -2 0 2; -1 0 1], Gy similar.",
                                    "Compare Sobel (simples, ruidoso) vs Canny (robusto, com limiares)."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo as diferenças entre Sobel e Canny, com exemplos visuais de kernels.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação OpenCV, imagens de amostra (ex: Lena ou peça industrial), notebook Jupyter.",
                                  "tips": "Visualize kernels Sobel como máscaras de convolução para intuitividade.",
                                  "learningObjective": "Explicar matematicamente como operadores de borda funcionam.",
                                  "commonMistakes": "Confundir detecção de bordas com segmentação completa; ignorar ruído como falso positivo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Operador Sobel em Python com OpenCV",
                                  "subSteps": [
                                    "Carregue uma imagem grayscale usando cv2.imread e cv2.cvtColor.",
                                    "Aplique cv2.Sobel com ddepth=cv2.CV_64F para precisão.",
                                    "Calcule magnitude da borda: sqrt(Gx² + Gy²) e normalize com cv2.convertScaleAbs.",
                                    "Aplique limiar simples com cv2.threshold para binarizar.",
                                    "Exiba resultados com cv2.imshow ou matplotlib."
                                  ],
                                  "verification": "Execute o código e verifique se bordas principais da imagem são destacadas sem excesso de ruído.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python 3, OpenCV (pip install opencv-python), NumPy, imagem de teste (ex: contorno de engrenagem).",
                                  "tips": "Use ksize=3 para kernels pequenos; teste com diferentes sigmas de suavização prévia.",
                                  "learningObjective": "Implementar detecção de bordas Sobel de forma funcional e otimizada.",
                                  "commonMistakes": "Esquecer de converter para float64 causando overflow; não normalizar magnitude."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Operador Canny e Otimizações",
                                  "subSteps": [
                                    "Carregue imagem e aplique GaussianBlur para reduzir ruído (ksize=5).",
                                    "Use cv2.Canny com low_threshold=50, high_threshold=150 (ajuste baseado na imagem).",
                                    "Entenda etapas internas: gradiente, supressão não-máximos, hysteresis.",
                                    "Compare saída Canny vs Sobel na mesma imagem.",
                                    "Ajuste parâmetros para minimizar bordas falsas em contextos industriais."
                                  ],
                                  "verification": "Gere imagens lado a lado (Sobel vs Canny) mostrando bordas mais limpas no Canny.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Mesmo ambiente do Step 2, imagens com ruído adicionado (cv2.randn).",
                                  "tips": "Thresholds: low=media(gradiente), high=2-3x low para hysteresis eficaz.",
                                  "learningObjective": "Dominar Canny para detecções robustas em imagens reais.",
                                  "commonMistakes": "Thresholds fixos sem ajuste; pular blur causando bordas fragmentadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Avaliar em Contexto Industrial",
                                  "subSteps": [
                                    "Selecione imagem de peça mecânica (ex: parafuso com defeito).",
                                    "Combine Sobel/Canny para contornos e extraia com cv2.findContours.",
                                    "Meça métricas: contorno fechado, área, comprimento.",
                                    "Teste robustez adicionando ruído ou variações de iluminação.",
                                    "Documente código em função reutilizável."
                                  ],
                                  "verification": "Detecte e destaque contornos de objetos com >90% de precisão visual.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Imagens industriais (dataset público como MVTec AD), métricas OpenCV.",
                                  "tips": "Use morphology (cv2.dilate/erode) pós-detecção para limpar bordas.",
                                  "learningObjective": "Integrar detecção de bordas em pipeline de visão industrial.",
                                  "commonMistakes": "Ignorar calibração de câmera afetando precisão; sobrecarregar com parâmetros."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de parafusos, carregue imagem de uma peça via câmera industrial. Aplique Sobel para bordas rápidas e Canny para precisão, detectando contornos. Se o comprimento do contorno > threshold, sinalize 'parafuso OK'; caso contrário, 'defeituoso'. Visualize com bounding boxes.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito as diferenças matemáticas entre Sobel e Canny.",
                                "Executar código que detecta bordas em 3 imagens variadas com sucesso.",
                                "Identificar e corrigir ruído em detecções reais.",
                                "Comparar outputs e justificar escolha de operador por cenário.",
                                "Extrair métricas de contornos (área, perímetro) corretamente.",
                                "Adaptar thresholds para novas imagens industriais."
                              ],
                              "assessmentCriteria": [
                                "Precisão da detecção: bordas contínuas e mínimas falsas (>85%).",
                                "Qualidade do código: comentado, modular, sem erros.",
                                "Compreensão conceitual: explicação correta de gradientes e etapas.",
                                "Otimização: tempo de execução <1s por imagem, robustez a ruído.",
                                "Aplicação prática: integração em pipeline com métricas.",
                                "Documentação: relatório com imagens antes/depois."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de gradientes e convolução.",
                                "Programação: Manipulação de arrays NumPy e funções OpenCV.",
                                "Eletrônica: Integração com PLCs para acionamento em robótica.",
                                "Física: Óptica e iluminação em visão computacional.",
                                "Estatística: Análise de thresholds e métricas de precisão."
                              ],
                              "realWorldApplication": "Em fábricas de automóveis, detectar bordas de soldas em chassis para inspeção de qualidade; em farmacêuticas, contornar pílulas para verificar integridade e dosagem em linhas de produção de alta velocidade."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Realizar segmentação por regiões",
                            "description": "Utilizar técnicas de crescimento de regiões para agrupar pixels semelhantes em imagens mecatrônicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação da Imagem e Seleção de Sementes",
                                  "subSteps": [
                                    "Carregue a imagem mecatrônica utilizando bibliotecas como OpenCV.",
                                    "Aplique pré-processamento: redução de ruído com filtro Gaussiano e normalização de intensidade.",
                                    "Identifique manualmente ou automaticamente pixels sementes em regiões de interesse (ex: peças metálicas).",
                                    "Defina uma máscara inicial para limitar o crescimento.",
                                    "Salve a imagem preparada para verificação visual."
                                  ],
                                  "verification": "Verifique visualmente se a imagem está limpa e sementes estão marcadas corretamente em um visualizador de imagens.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com OpenCV e NumPy",
                                    "Imagem de teste mecatrônica (ex: placa de circuito)",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Escolha sementes em áreas homogêneas para evitar propagação errada desde o início.",
                                  "learningObjective": "Compreender a importância do pré-processamento e seleção precisa de sementes para o sucesso da segmentação.",
                                  "commonMistakes": [
                                    "Selecionar sementes em bordas ruidosas",
                                    "Ignorar ruído na imagem original",
                                    "Não normalizar intensidades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definição de Critérios de Similaridade e Parâmetros",
                                  "subSteps": [
                                    "Defina métrica de similaridade: diferença absoluta de intensidade ou média estatística (threshold ΔI).",
                                    "Estabeleça threshold de similaridade (ex: ΔI < 10) e tamanho mínimo de região.",
                                    "Implemente fila de espera (queue) para pixels candidatos vizinhos (8-conectividade).",
                                    "Teste parâmetros em uma pequena região para calibração.",
                                    "Documente os valores escolhidos e justifique com base na imagem."
                                  ],
                                  "verification": "Execute um teste unitário em uma semente única e confirme que pixels vizinhos atendem ao critério.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python inicial",
                                    "Documentação OpenCV",
                                    "Calculadora para testes de threshold"
                                  ],
                                  "tips": "Use histograma da região semente para definir threshold adaptativo.",
                                  "learningObjective": "Aprender a quantificar similaridade pixel a pixel para crescimento controlado.",
                                  "commonMistakes": [
                                    "Threshold muito baixo causando oversegmentação",
                                    "Ignorar conectividade de 4 vs 8 vizinhos",
                                    "Parâmetros fixos sem calibração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação do Algoritmo de Crescimento de Regiões",
                                  "subSteps": [
                                    "Inicie com sementes na fila e marque como pertencentes à região.",
                                    "Em loop: retire pixel da fila, verifique vizinhos não visitados com critério de similaridade.",
                                    "Adicione vizinhos qualificados à região e à fila; atualize média da região se necessário.",
                                    "Pare quando fila esvaziar ou máximo iterações atingido.",
                                    "Repita para múltiplas sementes, atribuindo rótulos únicos."
                                  ],
                                  "verification": "Inspecione o mapa de rótulos gerado: regiões devem ser contíguas e homogêneas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca OpenCV para operações morfológicas",
                                    "Estruturas de dados: queue (collections.deque)",
                                    "Imagem preparada do step 1"
                                  ],
                                  "tips": "Use rótulos numéricos para regiões múltiplas e evite vazamentos com máscara.",
                                  "learningObjective": "Implementar iterativamente o crescimento regional garantindo eficiência computacional.",
                                  "commonMistakes": [
                                    "Loop infinito por threshold inadequado",
                                    "Não marcar pixels visitados",
                                    "Erro em conectividade de vizinhos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Pós-processamento, Avaliação e Visualização",
                                  "subSteps": [
                                    "Aplique morfologia: closing para preencher buracos e opening para remover ruído.",
                                    "Calcule métricas: área das regiões, uniformidade de intensidade.",
                                    "Visualize segmentação sobreposta à original com cores diferentes por região.",
                                    "Compare com ground truth manual se disponível (ex: Dice coefficient).",
                                    "Otimize parâmetros iterativamente com base em métricas."
                                  ],
                                  "verification": "Gere relatório com imagens antes/depois e métricas > 85% de precisão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções OpenCV: dilate, erode",
                                    "Métricas scikit-image",
                                    "Ferramenta de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Salve resultados em múltiplos formatos para análise posterior.",
                                  "learningObjective": "Refinar segmentação e quantificar qualidade para aplicações práticas.",
                                  "commonMistakes": [
                                    "Pós-processamento excessivo borrando bordas",
                                    "Métricas sem comparação baseline",
                                    "Visualização sem sobreposição"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de inspeção mecatrônica, aplique segmentação por crescimento de regiões em uma imagem de uma engrenagem para isolar a região dentada defeituosa, agrupando pixels com intensidades semelhantes e detectando irregularidades.",
                              "finalVerifications": [
                                "Regiões segmentadas são homogêneas em intensidade (desvio padrão < threshold).",
                                "Não há vazamento para regiões adjacentes diferentes.",
                                "Todas sementes cresceram para regiões completas sem undersegmentação.",
                                "Tempo de processamento < 5 segundos para imagem 512x512.",
                                "Visualização mostra bordas nítidas e rótulos corretos.",
                                "Métricas de validação (ex: Dice > 0.85) atendidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da segmentação: >90% de pixels corretamente agrupados.",
                                "Eficiência algorítmica: complexidade O(N) com N pixels.",
                                "Robustez a ruído: mantém qualidade após adição de 5% ruído Gaussiano.",
                                "Documentação: código comentado e justificativa de parâmetros.",
                                "Criatividade: adaptação para múltiplas sementes automáticas.",
                                "Apresentação: relatório com imagens e métricas claras."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva para métricas de similaridade e validação.",
                                "Programação: Estruturas de dados (fila, arrays) e algoritmos iterativos.",
                                "Eletrônica: Integração com câmeras em sistemas embarcados para visão em tempo real.",
                                "Física: Compreensão de propriedades ópticas e reflexão em materiais mecatrônicos.",
                                "Engenharia de Controle: Feedback em otimização de thresholds."
                              ],
                              "realWorldApplication": "Na indústria mecatrônica, utilizado em linhas de montagem robóticas para inspeção automática de defeitos em componentes como soldas, superfícies usinadas ou alinhamento de peças, integrando com braços robóticos para ações corretivas em tempo real."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.4",
                        "name": "Análise Básica de Imagens",
                        "description": "Extração e interpretação de características das regiões segmentadas para tomada de decisões em projetos mecatrônicos integrados.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.4.1",
                            "name": "Extrair características geométricas",
                            "description": "Calcular área, perímetro, centroide e momentos de formas segmentadas para análise em robótica aeronáutica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Geométricos Fundamentais",
                                  "subSteps": [
                                    "Estude a definição de área como o número de pixels na máscara segmentada.",
                                    "Aprenda perímetro como o comprimento da borda da forma usando contorno.",
                                    "Entenda centroide como o ponto médio ponderado (média das coordenadas x e y).",
                                    "Revise momentos como somas de produtos de coordenadas (m00, m10, m01, etc.).",
                                    "Relacione com robótica aeronáutica: propriedades para estabilidade de voo."
                                  ],
                                  "verification": "Resuma cada conceito em uma frase e identifique uma aplicação em drones.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação OpenCV Moments",
                                    "Artigos sobre análise de imagem em UAVs",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use diagramas visuais para visualizar centroide e momentos em formas simples.",
                                  "learningObjective": "Definir precisamente área, perímetro, centroide e momentos em contextos de imagens binárias.",
                                  "commonMistakes": [
                                    "Confundir área em pixels com unidades físicas",
                                    "Ignorar normalização de momentos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Imagem Segmentada e Contorno",
                                  "subSteps": [
                                    "Carregue uma imagem segmentada (máscara binária de uma forma, ex: asa de drone).",
                                    "Aplique findContours do OpenCV para extrair o contorno externo.",
                                    "Filtre contornos por área mínima para remover ruído.",
                                    "Converta contorno para array de pontos (x,y).",
                                    "Visualize a máscara e contorno para validação visual."
                                  ],
                                  "verification": "Exiba a imagem com contorno desenhado e confirme que matches a forma esperada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python 3",
                                    "OpenCV",
                                    "NumPy",
                                    "Matplotlib",
                                    "Imagem de teste de drone segmentada"
                                  ],
                                  "tips": "Use cv2.RETR_EXTERNAL para contornos simples e evite hierarquias complexas.",
                                  "learningObjective": "Preparar dados de entrada prontos para cálculos geométricos.",
                                  "commonMistakes": [
                                    "Selecionar contorno errado em imagens com múltiplas formas",
                                    "Não tratar buracos na segmentação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Área, Perímetro e Centroide",
                                  "subSteps": [
                                    "Calcule área com cv2.contourArea(contorno).",
                                    "Calcule perímetro com cv2.arcLength(contorno, True).",
                                    "Use cv2.moments(contorno) para obter m00, m10, m01.",
                                    "Compute centroide: cx = m10/m00, cy = m01/m00.",
                                    "Armazene resultados em um dicionário para análise."
                                  ],
                                  "verification": "Compare resultados com cálculo manual em uma forma quadrada conhecida (erro <1%).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código OpenCV de exemplo",
                                    "Formas geométricas sintéticas para teste"
                                  ],
                                  "tips": "Teste com formas regulares (círculo, retângulo) antes de irregulares.",
                                  "learningObjective": "Implementar fórmulas exatas para propriedades básicas usando bibliotecas.",
                                  "commonMistakes": [
                                    "Dividir por zero se m00=0",
                                    "Usar perímetro sem fechar contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Momentos e Integrar Análise",
                                  "subSteps": [
                                    "Extraia momentos espaciais de cv2.moments (m20, m02, m11, etc.).",
                                    "Calcule momentos normalizados (ex: mu20 = m20/m00).",
                                    "Implemente função unificada que retorna dict com todas as características.",
                                    "Teste em imagem real de robótica (ex: detecção de obstáculo aéreo).",
                                    "Gere relatório com valores e visualizações (bounding box no centroide)."
                                  ],
                                  "verification": "Execute em 3 imagens diferentes e verifique consistência (ex: centroide no centro visual).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Imagens de UAVs segmentadas",
                                    "Jupyter Notebook para prototipagem"
                                  ],
                                  "tips": "Salve momentos em JSON para reutilização em pipelines de ML.",
                                  "learningObjective": "Computar e interpretar momentos para análise avançada em visão.",
                                  "commonMistakes": [
                                    "Não normalizar momentos para independência de escala",
                                    "Ignorar momentos centrais vs. espaciais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Aplicar em Contexto Aeronáutico",
                                  "subSteps": [
                                    "Simule cenário: analise forma segmentada de hélice de drone.",
                                    "Compare características com specs conhecidas (área esperada).",
                                    "Integre com pipeline de visão: segmentação -> extração -> decisão (ex: voo seguro).",
                                    "Otimize código para tempo real (threshold em contornos).",
                                    "Documente pipeline completo com comentários."
                                  ],
                                  "verification": "Demonstre em vídeo ou simulação que características guiam ação robótica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Vídeos de drones",
                                    "Simulador Gazebo opcional"
                                  ],
                                  "tips": "Use profiling para garantir <30ms por frame em embedded.",
                                  "learningObjective": "Aplicar extração geométrica em fluxos reais de robótica.",
                                  "commonMistakes": [
                                    "Sobrepor ruído em cálculos",
                                    "Não calibrar pixels para metros"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma imagem de câmera de drone, segmente a forma de um obstáculo (pedra). Calcule área=1500 pixels, perímetro=180 px, centroide=(320,240), momentos normalizados mu20=1e6, para decidir desvio de rota evitando colisão.",
                              "finalVerifications": [
                                "Área e perímetro coincidem com medida manual (±5%).",
                                "Centroide visualmente central na forma desenhada.",
                                "Momentos normalizados independentes de escala (teste zoom).",
                                "Função executa em <50ms em hardware embarcado.",
                                "Resultados consistentes em 5 imagens de teste variadas.",
                                "Integração com segmentação sem erros de propagação."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos (erro <2% em formas conhecidas).",
                                "Eficiência computacional (tempo de execução).",
                                "Robustez a ruído e variações de segmentação.",
                                "Clareza do código e documentação.",
                                "Correta interpretação física das características.",
                                "Aplicação contextual em robótica aeronáutica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e propriedades geométricas.",
                                "Física: Aerodinâmica (área/perímetro afetam arrasto em UAVs).",
                                "Programação: Algoritmos de processamento de imagem (OpenCV).",
                                "Engenharia: Design de sistemas embarcados para visão.",
                                "Inteligência Artificial: Features para ML em detecção de objetos."
                              ],
                              "realWorldApplication": "Em drones autônomos, extrair características geométricas de obstáculos segmentados permite estimar tamanho/distância para navegação segura, otimização de trajetórias e inspeção de estruturas aéreas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3"
                            ]
                          },
                          {
                            "id": "10.1.2.3.4.2",
                            "name": "Classificar objetos simples",
                            "description": "Aplicar regras básicas de classificação baseadas em features extraídas para inspeção de qualidade em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Extrair Features Básicas de Objetos nas Imagens",
                                  "subSteps": [
                                    "Carregue imagens de objetos simples usando biblioteca de visão computacional (ex: OpenCV).",
                                    "Aplique segmentação básica (thresholding ou contornos) para isolar o objeto do fundo.",
                                    "Calcule features como cor média (em HSV), área do objeto (pixels), perímetro e circularidade.",
                                    "Armazene features em um vetor numérico para cada objeto.",
                                    "Visualize as features extraídas em gráficos ou overlays na imagem."
                                  ],
                                  "verification": "Exibir vetores de features para 10 imagens de teste e confirmar valores consistentes com inspeção visual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com OpenCV e NumPy",
                                    "Conjunto de 20 imagens de objetos mecatrônicos (ex: parafusos, engrenagens)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Converta imagens para espaço de cor HSV para melhor separação de cor; normalize features para escala 0-1.",
                                  "learningObjective": "Identificar e extrair features quantitativas relevantes (cor, tamanho, forma) de imagens para basear classificações.",
                                  "commonMistakes": [
                                    "Ignorar variações de iluminação levando a features inconsistentes",
                                    "Não segmentar corretamente o objeto do fundo",
                                    "Usar features irrelevantes como posição absoluta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Regras de Classificação Baseadas em Features",
                                  "subSteps": [
                                    "Analise amostras rotuladas de objetos bons/defeituosos para identificar thresholds (ex: área > 500 pixels = bom).",
                                    "Crie regras if-then simples: se cor média H > 20 e área < 400 então 'defeituoso'.",
                                    "Defina 3-5 regras cobrindo combinações de features (ex: cor E tamanho, forma E cor).",
                                    "Teste regras manualmente em 5 imagens rotuladas.",
                                    "Documente regras em pseudocódigo ou tabela."
                                  ],
                                  "verification": "Regras aplicadas manualmente classificam corretamente 80% das amostras de validação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para thresholds",
                                    "Imagens rotuladas com labels (bom/defeituoso)"
                                  ],
                                  "tips": "Use histograma de features para encontrar thresholds naturais; priorize regras mutuamente exclusivas.",
                                  "learningObjective": "Estabelecer critérios quantitativos claros para classificação binária ou multiclasse baseada em features.",
                                  "commonMistakes": [
                                    "Regras muito rígidas sem margem para variação",
                                    "Sobreposição de regras causando ambiguidades",
                                    "Ignorar correlações entre features"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Classificador Simples em Código",
                                  "subSteps": [
                                    "Escreva função para extrair features e aplicar regras sequencialmente.",
                                    "Implemente loop para processar múltiplas imagens em batch.",
                                    "Adicione output: label previsto, confiança (baseada em quão bem matches a regra) e imagem anotada.",
                                    "Integre em pipeline de visão: captura > features > classificação > log.",
                                    "Debugue com prints de features e decisões intermediárias."
                                  ],
                                  "verification": "Código roda sem erros e produz labels corretos para conjunto de teste conhecido.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/OpenCV",
                                    "Código base de extração de features do Step 1",
                                    "10 imagens de teste rotuladas"
                                  ],
                                  "tips": "Use funções modulares para fácil teste; adicione logging para rastrear decisões.",
                                  "learningObjective": "Codificar lógica de regras if-then em um classificador automatizado para inspeção em tempo real.",
                                  "commonMistakes": [
                                    "Erros de indexação em vetores de features",
                                    "Não tratar casos edge (ex: objeto não detectado)",
                                    "Código não escalável para batch"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Avaliar e Refinar o Classificador",
                                  "subSteps": [
                                    "Execute classificador em 50 imagens de teste (25 boas, 25 defeituosas).",
                                    "Calcule métricas: acurácia, precisão, recall e matriz de confusão.",
                                    "Identifique falsos positivos/negativos e ajuste thresholds das regras.",
                                    "Teste robustez: varie iluminação, rotação e ruído nas imagens.",
                                    "Otimize para velocidade e gere relatório de performance."
                                  ],
                                  "verification": "Acurácia > 90% em conjunto de teste independente; relatório gerado com métricas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Conjunto de validação com 50 imagens rotuladas",
                                    "Biblioteca scikit-learn para métricas",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use cross-validation simples dividindo dados; priorize recall para defeitos (não perder nenhum).",
                                  "learningObjective": "Avaliar performance do classificador e iterar para melhoria em cenários reais de inspeção.",
                                  "commonMistakes": [
                                    "Overfitting a conjunto de treino sem teste independente",
                                    "Ignorar impacto de ruído real",
                                    "Não documentar mudanças nos thresholds"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de placas eletrônicas mecatrônicas, classifique resistores como 'bons' (cor marrom uniforme, tamanho 2x1mm) ou 'defeituosos' (cor desbotada ou tamanho irregular) usando features de cor média HSV e área projetada, aplicando regras como: se área < 1.8mm² OU saturação < 0.3 então 'defeituoso'.",
                              "finalVerifications": [
                                "Classificador processa 100 imagens em <5 segundos total.",
                                "Acurácia geral >92% em conjunto de teste misto.",
                                "Nenhum falso negativo em 20 defeitos conhecidos.",
                                "Robustez mantida com ±10% variação de iluminação.",
                                "Relatório com matriz de confusão e thresholds finais gerado.",
                                "Código comentado e reutilizável para novas regras."
                              ],
                              "assessmentCriteria": [
                                "Precisão e recall >90% para classes principal.",
                                "Regras lógicas, mutuamente exclusivas e baseadas em dados.",
                                "Extração de features consistente e visualizável.",
                                "Implementação modular, eficiente e livre de bugs.",
                                "Análise de erros com refinamentos iterativos.",
                                "Documentação clara de pipeline completo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e thresholds (percentis, médias).",
                                "Programação: Estruturas condicionais, funções e processamento de arrays.",
                                "Física/Óptica: Princípios de imagem digital e segmentação.",
                                "Engenharia Industrial: Controle estatístico de processo (SPC).",
                                "Inteligência Artificial: Introdução a regras-based vs machine learning."
                              ],
                              "realWorldApplication": "Inspeção automatizada de qualidade em linhas de produção mecatrônicas, como detectar soldas defeituosas em PCBs ou peças usinadas irregulares em fábricas de automação, reduzindo desperdício e tempo de inspeção manual em 80%."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3"
                            ]
                          },
                          {
                            "id": "10.1.2.3.4.3",
                            "name": "Integrar análise com microcontroladores",
                            "description": "Conectar resultados de análise a microcontroladores ou CLPs para ações automatizadas em projetos integrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Saída de Dados da Análise de Imagem",
                                  "subSteps": [
                                    "Identifique os resultados chave da análise (ex: detecção de objeto, posição, defeito).",
                                    "Converta resultados em formato compatível (ex: sinal binário, valor numérico ou string JSON).",
                                    "Implemente função de exportação no código de processamento de imagem (ex: OpenCV com Python).",
                                    "Teste a saída em console ou arquivo para validar dados.",
                                    "Adicione timestamp e ID de frame para rastreabilidade."
                                  ],
                                  "verification": "Execute o script de análise e confirme que os dados são gerados corretamente no formato esperado via print ou log.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Computador com Python e OpenCV instalados",
                                    "Código fonte da análise de imagem"
                                  ],
                                  "tips": "Use bibliotecas como serial ou socket para preparar comunicação futura.",
                                  "learningObjective": "Mapear outputs analíticos para sinais acionáveis de controle.",
                                  "commonMistakes": [
                                    "Formatos incompatíveis com microcontrolador",
                                    "Dados sem validação de integridade",
                                    "Overhead excessivo no processamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Hardware do Microcontrolador",
                                  "subSteps": [
                                    "Escolha e configure o microcontrolador (ex: Arduino Uno ou ESP32).",
                                    "Conecte pinos de entrada (ex: digital para sinal binário, analógico para valores).",
                                    "Instale firmware básico com bibliotecas de comunicação (ex: Serial, Wire para I2C).",
                                    "Teste alimentação e LEDs para confirmar operação básica.",
                                    "Defina baud rate e protocolo de comunicação compatível com o software de visão."
                                  ],
                                  "verification": "Carregue sketch de teste e verifique comunicação serial via monitor serial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Microcontrolador (Arduino/ESP32)",
                                    "Cabos jumper",
                                    "Protoboard",
                                    "IDE Arduino"
                                  ],
                                  "tips": "Use pinos interrupt-driven para respostas rápidas em aplicações tempo-real.",
                                  "learningObjective": "Preparar hardware para recepção e processamento de comandos de visão.",
                                  "commonMistakes": [
                                    "Baud rate mismatch",
                                    "Pinos incorretos",
                                    "Falta de pull-up resistors em I2C"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer Comunicação entre Software e Hardware",
                                  "subSteps": [
                                    "Implemente protocolo de comunicação (ex: serial USB, MQTT para wireless).",
                                    "No software de visão: abra porta serial e envie dados formatados.",
                                    "No microcontrolador: configure loop para ler e parsear dados recebidos.",
                                    "Adicione handshaking (ex: ACK/NACK) para confiabilidade.",
                                    "Teste envio de comandos simples (ex: 'DEFECTO_DETECTADO')."
                                  ],
                                  "verification": "Envie comando do PC e confirme recepção no monitor serial do microcontrolador.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Cabo USB para serial",
                                    "Biblioteca pyserial (Python)",
                                    "Código de ambos os lados"
                                  ],
                                  "tips": "Bufferize dados para evitar perda em altas taxas de frame.",
                                  "learningObjective": "Criar ponte bidirecional confiável entre análise de imagem e controle.",
                                  "commonMistakes": [
                                    "Timeout não configurado",
                                    "Formato de pacote inconsistente",
                                    "Interferência em comunicação wireless"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Lógica de Controle Automatizado",
                                  "subSteps": [
                                    "Mapeie sinais recebidos para ações (ex: ligar motor se defeito detectado).",
                                    "Programe sequências de controle (ex: PWM para servo, relé para atuador).",
                                    "Adicione lógica de segurança (ex: debounce, limites de segurança).",
                                    "Integre feedback sensorial no microcontrolador (ex: sensor de posição).",
                                    "Teste em loop fechado com simulação de visão."
                                  ],
                                  "verification": "Execute análise completa e observe ação física no hardware (ex: LED acende ou motor gira).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Atuadores (servo, relé, motor)",
                                    "Sensores auxiliares",
                                    "Fonte de alimentação externa"
                                  ],
                                  "tips": "Use finite state machines (FSM) para lógica complexa.",
                                  "learningObjective": "Transformar insights de visão em ações mecatrônicas automatizadas.",
                                  "commonMistakes": [
                                    "Ações sem debounce",
                                    "Sobrecarga de atuadores",
                                    "Falta de estados de erro"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Otimizar Integração Completa",
                                  "subSteps": [
                                    "Rode testes end-to-end com cenários reais (ex: objetos passando por câmera).",
                                    "Meça latência total (visão -> análise -> controle).",
                                    "Otimize código para reduzir delays (ex: threading em Python).",
                                    "Registre logs para debugging e análise de performance.",
                                    "Implemente watchdog para reset em falhas."
                                  ],
                                  "verification": "Sistema responde corretamente a 95% dos casos em 10 execuções consecutivas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Câmera USB",
                                    "Objetos de teste",
                                    "Cronômetro para latência"
                                  ],
                                  "tips": "Use osciloscópio ou logic analyzer para debug de sinais.",
                                  "learningObjective": "Garantir robustez e performance em sistemas integrados.",
                                  "commonMistakes": [
                                    "Testes insuficientes em edge cases",
                                    "Ignorar latência acumulada",
                                    "Sem logging"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem, a câmera detecta uma peça defeituosa via análise de contorno. O software envia 'REJEITAR' via serial para Arduino, que aciona um servo para desviar a peça para a bandeja de rejeitos, enquanto um LED pisca para alertar o operador.",
                              "finalVerifications": [
                                "Dados da análise são recebidos corretamente pelo microcontrolador em <100ms.",
                                "Ações de controle são executadas de forma consistente e segura.",
                                "Sistema lida com falhas de comunicação via retry ou fallback.",
                                "Logs completos registram todas as interações para auditoria.",
                                "Integração não impacta performance da análise de imagem (>15 FPS).",
                                "Testes com variações de iluminação e velocidade confirmam robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão na transmissão e parsing de dados (>99%).",
                                "Latência end-to-end <200ms.",
                                "Confiabilidade em 100 execuções (zero falhas críticas).",
                                "Código modular e comentado para manutenção.",
                                "Segurança: sem ações perigosas em estados inválidos.",
                                "Eficiência: uso <80% de CPU/RAM em ambos os lados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Python para visão, C++ para embedded.",
                                "Eletrônica: Protocolos de comunicação e atuadores.",
                                "Automação Industrial: Integração com CLPs e Industry 4.0.",
                                "Matemática: Processamento de sinais e controle PID básico.",
                                "Física: Cinemática de atuadores e óptica em visão."
                              ],
                              "realWorldApplication": "Em indústrias de manufatura, como automotiva ou farmacêutica, para inspeção visual automatizada que rejeita defeitos em tempo real, reduzindo desperdícios e aumentando throughput em linhas de produção robóticas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3",
                              "10.1.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.4.4",
                            "name": "Avaliar métricas de desempenho",
                            "description": "Medir precisão e recall da análise básica, referenciando métodos de design engineering (CROSS, 2004).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de precisão e recall",
                                  "subSteps": [
                                    "Estude as definições: Precisão = TP / (TP + FP), Recall = TP / (TP + FN)",
                                    "Revise matriz de confusão: True Positives (TP), False Positives (FP), False Negatives (FN), True Negatives (TN)",
                                    "Leia seção relevante de CROSS (2004) sobre avaliação de desempenho em design engineering",
                                    "Compare precisão e recall em contextos de análise de imagens",
                                    "Identifique trade-offs entre precisão e recall em sistemas de visão"
                                  ],
                                  "verification": "Explique em suas palavras as fórmulas e forneça um exemplo simples com números",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Engineering Design Methods' de Nigel Cross (2004), notas ou slides sobre métricas de ML",
                                  "tips": "Use diagramas visuais para matriz de confusão para fixar conceitos",
                                  "learningObjective": "Dominar definições e fórmulas de precisão e recall aplicadas a análise de imagens",
                                  "commonMistakes": "Confundir precisão (detecção correta entre positivas) com recall (cobertura de reais positivas)"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar dados de ground truth e predições",
                                  "subSteps": [
                                    "Colete conjunto de imagens de teste com anotações manuais (ground truth)",
                                    "Execute análise básica de imagens para gerar predições automáticas",
                                    "Crie tabelas ou arrays com TP, FP, FN, TN para cada imagem",
                                    "Valide consistência dos dados comparando manual e automático",
                                    "Armazene dados em formato tabular (Excel ou CSV)"
                                  ],
                                  "verification": "Verifique se a matriz de confusão soma corretamente para o total de instâncias",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Imagens de teste, software de anotação (LabelImg), Python com OpenCV ou NumPy",
                                  "tips": "Comece com um pequeno dataset (10-20 imagens) para prática rápida",
                                  "learningObjective": "Preparar dados confiáveis para cálculo de métricas em visão computacional",
                                  "commonMistakes": "Incluir ambiguidades nas anotações manuais sem resolução prévia"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular precisão e recall",
                                  "subSteps": [
                                    "Implemente fórmulas em código ou planilha: precisão = TP / (TP + FP), recall = TP / (TP + FN)",
                                    "Calcule métricas para o dataset completo e por imagem individual",
                                    "Gere F1-score como média harmônica: 2 * (precisão * recall) / (precisão + recall)",
                                    "Visualize resultados com gráficos (barras ou curvas ROC básicas)",
                                    "Teste com variações de threshold para observar mudanças"
                                  ],
                                  "verification": "Compare cálculos manuais com código para validar precisão numérica",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (scikit-learn para métricas), Jupyter Notebook, planilhas Excel",
                                  "tips": "Use bibliotecas prontas como sklearn.metrics para automação e verificação",
                                  "learningObjective": "Executar cálculos precisos de métricas de desempenho",
                                  "commonMistakes": "Dividir por zero quando não há predições positivas; sempre cheque denominadores"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados no contexto de design engineering",
                                  "subSteps": [
                                    "Analise resultados: alta precisão baixa recall indica falsos negativos excessivos",
                                    "Referencie CROSS (2004) para mapear métricas a critérios de design (eficácia, robustez)",
                                    "Proponha melhorias baseadas em métricas (ajustar thresholds, filtrar ruído)",
                                    "Documente relatório com tabelas, gráficos e recomendações",
                                    "Compare com benchmarks industriais em mecatrônica"
                                  ],
                                  "verification": "Escreva um parágrafo resumindo interpretação e ações corretivas",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Relatório template, gráficos gerados no step 3",
                                  "tips": "Priorize recall em aplicações críticas como detecção de falhas de segurança",
                                  "learningObjective": "Aplicar avaliação de métricas a decisões de design em sistemas mecatrônicos",
                                  "commonMistakes": "Ignorar contexto: métricas isoladas sem ligação a objetivos do sistema"
                                }
                              ],
                              "practicalExample": "Em um sistema de visão para detectar rachaduras em peças mecatrônicas: anote 50 imagens (ground truth), processe com detecção de bordas, calcule precisão (90% das detecções são rachaduras reais) e recall (85% das rachaduras reais foram detectadas), interpretando para otimizar threshold.",
                              "finalVerifications": [
                                "Matriz de confusão construída corretamente sem erros aritméticos",
                                "Precisão e recall calculados com exatidão numérica",
                                "Interpretação referenciada a métodos de CROSS (2004)",
                                "Gráficos ou tabelas gerados para visualização",
                                "Recomendações práticas para melhoria propostas",
                                "Relatório documentado com todos os cálculos"
                              ],
                              "assessmentCriteria": [
                                "Exatidão das fórmulas e cálculos (90%+ precisão)",
                                "Qualidade da preparação de dados (consistência ground truth)",
                                "Profundidade da interpretação no contexto de design engineering",
                                "Uso adequado de ferramentas e visualizações",
                                "Identificação de trade-offs e melhorias acionáveis",
                                "Referência explícita a CROSS (2004) e mecatrônica"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Matrizes de confusão e medidas de associação",
                                "Programação: Implementação em Python/OpenCV para automação",
                                "Engenharia Mecânica: Avaliação de qualidade em manufatura",
                                "Design de Produto: Métodos iterativos de validação (CROSS)",
                                "Inteligência Artificial: Métricas em aprendizado de máquina"
                              ],
                              "realWorldApplication": "Na indústria mecatrônica, validar sistemas de visão computacional para inspeção automatizada de linhas de produção, garantindo detecção precisa de defeitos em componentes, reduzindo desperdícios e melhorando eficiência conforme padrões de design engineering."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Aplicações em Robótica Mecatrônica",
                    "description": "Integração de visão por computador em robôs e automação, com foco na indústria aeronáutica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Integração de Visão por Computador em Robôs Mecatrônicos",
                        "description": "Conceitos fundamentais sobre a incorporação de sistemas de visão computacional em plataformas robóticas mecatrônicas, incluindo interfaces com microcontroladores e processamento de imagens em tempo real.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar componentes de visão em sistemas robóticos",
                            "description": "Reconhecer e descrever os principais componentes de hardware e software necessários para integrar câmeras, processadores de imagem e atuadores em robôs mecatrônicos, com ênfase em microcontroladores como Arduino ou Raspberry Pi.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar componentes de hardware para captura de imagem",
                                  "subSteps": [
                                    "Pesquise tipos de câmeras usadas em robótica, como USB cameras, Raspberry Pi Camera Module e câmeras IP.",
                                    "Estude acessórios ópticos: lentes fixas, lentes varifocais, filtros IR e housings protetores.",
                                    "Liste sensores complementares: iluminadores LED, microfones para áudio sincronizado e suportes mecânicos.",
                                    "Desenhe um diagrama simples mostrando a conexão da câmera ao microcontrolador.",
                                    "Compare especificações de câmeras para Arduino vs Raspberry Pi (resolução, FPS, interface)."
                                  ],
                                  "verification": "Crie uma lista com pelo menos 5 componentes de hardware e suas funções, com diagrama anexado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Computador com internet",
                                    "Documentação oficial Raspberry Pi Camera",
                                    "Diagramas de pinos Arduino"
                                  ],
                                  "tips": "Priorize componentes open-source e de baixo custo para prototipagem rápida.",
                                  "learningObjective": "Reconhecer hardware essencial para captura de imagens em sistemas robóticos.",
                                  "commonMistakes": [
                                    "Ignorar limitações de interface (ex: I2C vs USB)",
                                    "Confundir resolução com campo de visão",
                                    "Esquecer proteção ambiental para câmeras externas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar processadores de imagem e hardware de processamento",
                                  "subSteps": [
                                    "Identifique processadores dedicados: Intel RealSense, NVIDIA Jetson ou DSPs em microcontroladores.",
                                    "Estude módulos como OV2640 para Arduino e como eles processam dados brutos.",
                                    "Aprenda sobre buffers de memória e pipelines de processamento em Raspberry Pi.",
                                    "Liste software inicial: bibliotecas como OpenCV para detecção de bordas e blobs.",
                                    "Simule fluxo de dados: câmera → processador → análise."
                                  ],
                                  "verification": "Explique em um parágrafo o pipeline de processamento de uma imagem capturada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tutoriais OpenCV para Raspberry Pi",
                                    "Datasheets de módulos como ESP32-CAM",
                                    "Software simulador como Tinkercad"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o processamento em tempo real.",
                                  "learningObjective": "Descrever hardware e software para processamento de imagens em robôs.",
                                  "commonMistakes": [
                                    "Subestimar latência em processadores de baixa potência",
                                    "Misturar processamento edge com cloud",
                                    "Ignorar consumo de energia em embedded systems"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar integração com microcontroladores Arduino e Raspberry Pi",
                                  "subSteps": [
                                    "Configure bibliotecas: ESP32 Camera para Arduino IDE ou picamera para Python no RPi.",
                                    "Teste conexões: CSI para RPi, serial/USB para Arduino.",
                                    "Implemente código básico para capturar e transmitir frames.",
                                    "Integre com shields ou HATs específicos para visão.",
                                    "Verifique compatibilidade com shields de motor e sensores."
                                  ],
                                  "verification": "Escreva e execute um sketch simples que liste dispositivos de câmera conectados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Arduino IDE ou Raspberry Pi OS",
                                    "Câmera USB genérica",
                                    "Cabo jumper wires"
                                  ],
                                  "tips": "Comece com exemplos prontos da biblioteca oficial para evitar erros de configuração.",
                                  "learningObjective": "Entender como conectar visão a microcontroladores comuns em mecatrônica.",
                                  "commonMistakes": [
                                    "Conexões erradas de pinos (ex: 3.3V vs 5V)",
                                    "Bibliotecas incompatíveis com versão do firmware",
                                    "Falta de drivers no OS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar atuadores e interfaces controladas por visão",
                                  "subSteps": [
                                    "Liste atuadores: servos, motores DC, braços robóticos acionados por detecção visual.",
                                    "Estude protocolos: PWM para servos via Arduino, GPIO para RPi.",
                                    "Simule feedback loop: visão detecta objeto → processa → comanda atuador.",
                                    "Explore exemplos: robô seguidor de linha ou detetor de obstáculos.",
                                    "Crie um fluxograma completo do sistema de visão integrado."
                                  ],
                                  "verification": "Monte um fluxograma mostrando visão → processamento → atuador.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e caneta para fluxograma",
                                    "Vídeos de projetos robóticos no YouTube",
                                    "Documentação Adafruit para servos"
                                  ],
                                  "tips": "Pense em closed-loop control para sistemas responsivos.",
                                  "learningObjective": "Reconhecer como visão controla atuadores em robôs mecatrônicos.",
                                  "commonMistakes": [
                                    "Desacoplamento de visão e atuadores sem sincronização",
                                    "Sobrecarga de processamento levando a delays",
                                    "Ignorar calibração de atuadores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um robô seguidor de linha com detecção de obstáculos usando Raspberry Pi: a Pi Camera captura imagens, OpenCV processa para detectar linha e obstáculos no RPi 4, enviando comandos PWM para motores DC via GPIO, evitando colisões em tempo real.",
                              "finalVerifications": [
                                "Liste corretamente 8+ componentes de hardware e software de visão.",
                                "Desenhe e explique um diagrama de integração completo.",
                                "Identifique diferenças entre setups Arduino e Raspberry Pi.",
                                "Simule um pipeline de visão para atuadores.",
                                "Explique 3 limitações comuns em sistemas robóticos de visão.",
                                "Compare com sistemas comerciais como drones DJI."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (90% correto).",
                                "Detalhe nos fluxos de integração e processamento.",
                                "Uso correto de terminologia técnica (ex: CSI, OpenCV).",
                                "Criatividade em diagramas e exemplos práticos.",
                                "Compreensão de limitações reais (latência, energia).",
                                "Conexões lógicas entre hardware, software e atuadores."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Interfaces de comunicação (I2C, SPI, USB).",
                                "Programação: Bibliotecas Python/C++ para visão (OpenCV).",
                                "Física/Óptica: Princípios de lentes e captura de luz.",
                                "Matemática: Algoritmos de processamento de imagem (matrizes, filtros).",
                                "Engenharia de Controle: Loops de feedback visão-atuador."
                              ],
                              "realWorldApplication": "Em robôs industriais para inspeção de qualidade (ex: detecção de defeitos em linhas de montagem via câmeras e atuadores corretivos), drones autônomos para mapeamento ou veículos autônomos como Tesla usando visão para navegação e frenagem emergencial."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Configurar interfaces de comunicação visão-robô",
                            "description": "Implementar protocolos de comunicação (ex.: I2C, SPI, USB) entre módulos de visão por computador e controladores mecatrônicos para troca de dados em tempo real durante operações robóticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Planejar o Protocolo de Comunicação Adequado",
                                  "subSteps": [
                                    "Analise os requisitos do sistema: velocidade de dados, distância, número de dispositivos e consumo de energia.",
                                    "Compare protocolos (I2C: multi-dispositivo, curto alcance; SPI: alta velocidade, full-duplex; USB: plug-and-play, alta taxa).",
                                    "Escolha o protocolo baseado no contexto robótico (ex.: I2C para proximidade em robôs compactos).",
                                    "Defina o formato de dados a trocar (ex.: coordenadas x,y de objeto detectado como bytes).",
                                    "Crie um diagrama esquemático da conexão visão-controlador."
                                  ],
                                  "verification": "Diagrama completo e justificativa escrita do protocolo escolhido.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de protocolos (datasheets I2C/SPI/USB)",
                                    "Ferramentas de diagramação (Draw.io ou papel)"
                                  ],
                                  "tips": "Priorize I2C/SPI para embedded; USB para protótipos rápidos.",
                                  "learningObjective": "Compreender trade-offs de protocolos para seleção otimizada em robótica.",
                                  "commonMistakes": [
                                    "Ignorar limitações de distância/velocidade",
                                    "Não considerar clock sharing em I2C"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Conexões de Hardware",
                                  "subSteps": [
                                    "Identifique pinos: SDA/SCL para I2C, MOSI/MISO/SCK/CS para SPI, D+/D-/VBUS para USB.",
                                    "Conecte fisicamente módulos: câmera/RPi ao controlador (ex.: Arduino).",
                                    "Adicione resistores pull-up (4.7kΩ para I2C SDA/SCL).",
                                    "Alimente corretamente (3.3V/5V compatível).",
                                    "Teste continuidade com multímetro."
                                  ],
                                  "verification": "Continuidade confirmada e alimentação estável (sem sobreaquecimento).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Placa visão (RPi com câmera)",
                                    "Controlador (Arduino/ESP32)",
                                    "Jumpers, protoboard, multímetro, resistores pull-up"
                                  ],
                                  "tips": "Use níveis lógicos compatíveis (3.3V vs 5V com level shifter se necessário).",
                                  "learningObjective": "Dominar conexões físicas seguras para comunicação serial.",
                                  "commonMistakes": [
                                    "Pinos invertidos",
                                    "Falta de pull-ups em I2C",
                                    "Incompatibilidade de tensão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Software no Módulo de Visão",
                                  "subSteps": [
                                    "Instale bibliotecas: Wire.h para I2C/SPI no RPi/Arduino IDE.",
                                    "Programe captura de imagem e processamento (ex.: OpenCV para detecção de objeto).",
                                    "Codifique envio de dados: função para serializar coordenadas em buffer e transmitir.",
                                    "Configure endereço slave/master (ex.: visão como master I2C).",
                                    "Adicione loop de envio periódico (ex.: 30 FPS)."
                                  ],
                                  "verification": "Código compila e simula envio via Serial Monitor.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "IDE (Arduino IDE, Thonny para RPi)",
                                    "Bibliotecas OpenCV/PiCamera"
                                  ],
                                  "tips": "Use delays mínimos para tempo real; bufferize dados para evitar perda.",
                                  "learningObjective": "Desenvolver código para processamento de visão e transmissão serial.",
                                  "commonMistakes": [
                                    "Não flush buffer antes de enviar",
                                    "Loop bloqueante em processamento de imagem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Software no Controlador e Testar Integração",
                                  "subSteps": [
                                    "Programe recepção: configure como slave, leia dados no buffer.",
                                    "Parse dados recebidos (ex.: extrair x,y para controle de motor).",
                                    "Implemente handshake/ACK para confirmação de recebimento.",
                                    "Teste end-to-end: envie dados da visão e atue no robô (ex.: mover servo para objeto).",
                                    "Monitore latência com osciloscópio ou logs."
                                  ],
                                  "verification": "Dados recebidos corretamente e ação robótica executada em <100ms.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Osciloscópio lógico ou Serial Plotter",
                                    "Servo/motores para teste"
                                  ],
                                  "tips": "Use interrupções para recepção em tempo real.",
                                  "learningObjective": "Integrar comunicação bidirecional com controle mecatrônico.",
                                  "commonMistakes": [
                                    "Não tratar erros de timeout",
                                    "Endianness mismatch em multi-byte"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e Validar em Tempo Real",
                                  "subSteps": [
                                    "Meça taxa de perda de pacotes e latência sob carga.",
                                    "Ajuste baud rate, buffer sizes ou protocolo (ex.: SPI se I2C lento).",
                                    "Integre em operação robótica completa (ex.: tracking de objeto).",
                                    "Registre logs para depuração.",
                                    "Documente configuração final."
                                  ],
                                  "verification": "Comunicação estável com perda <1% em 10min de teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Câmera em movimento",
                                    "Robô montado"
                                  ],
                                  "tips": "Teste em ruído real; considere EMI shielding.",
                                  "learningObjective": "Otimizar comunicação para aplicações robóticas robustas.",
                                  "commonMistakes": [
                                    "Testes só em idle",
                                    "Ignorar jitter de clock"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um robô seguidor de linha com detecção de obstáculos: Raspberry Pi com câmera OpenCV detecta obstáculo via visão, envia coordenadas x,y via I2C para Arduino, que ajusta motores para desvio em tempo real.",
                              "finalVerifications": [
                                "Troca de dados bidirecional sem perda em 5 minutos contínuos.",
                                "Latência <50ms para processamento visão-controle.",
                                "Sistema opera corretamente com ruído elétrico simulado.",
                                "Handshake ACK confirma 100% das mensagens.",
                                "Documentação inclui pinout, código e diagramas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção de protocolo (justificada por requisitos).",
                                "Conexões hardware sem erros elétricos.",
                                "Código funcional com tratamento de erros.",
                                "Desempenho em tempo real (latência e taxa de perda).",
                                "Integração completa em cenário robótico.",
                                "Documentação clara e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Protocolos seriais e sinais.",
                                "Programação Embarcada: Bibliotecas Wire/SPI.",
                                "Processamento de Imagens: OpenCV para visão.",
                                "Controle Automático: Uso de dados para feedback.",
                                "Engenharia de Software: Modularidade e depuração."
                              ],
                              "realWorldApplication": "Em robôs industriais de pick-and-place, onde câmeras enviam posições de peças via SPI para controladores PLC, ou em drones autônomos detectando alvos e comunicando via USB para flight controllers."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Processar imagens básicas para controle robótico",
                            "description": "Aplicar algoritmos simples de processamento de imagem (detecção de bordas, segmentação) usando bibliotecas como OpenCV para gerar comandos de movimento em robôs mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de desenvolvimento com OpenCV e hardware robótico",
                                  "subSteps": [
                                    "Instalar Python e bibliotecas necessárias (OpenCV, NumPy) via pip.",
                                    "Configurar conexão com câmera (webcam ou câmera do robô).",
                                    "Estabelecer comunicação serial ou API com o robô mecatrônico (ex: Arduino ou Raspberry Pi).",
                                    "Testar captura básica de imagem e envio de comando simples ao robô.",
                                    "Criar script base para processamento em loop."
                                  ],
                                  "verification": "Executar script que captura imagem da câmera e envia comando 'parar' ao robô com sucesso.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Computador com Python 3.8+",
                                    "OpenCV (cv2)",
                                    "Câmera USB ou integrada",
                                    "Robô mecatrônico com interface serial",
                                    "Cabo USB/serial"
                                  ],
                                  "tips": "Use ambientes virtuais (venv) para isolar dependências; teste conexões em modo debug primeiro.",
                                  "learningObjective": "Configurar um pipeline básico de visão e controle robótico funcional.",
                                  "commonMistakes": [
                                    "Esquecer de instalar dependências corretas",
                                    "Portas seriais incorretas",
                                    "Ignorar permissões de câmera no SO"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Capturar e pré-processar imagens da câmera",
                                  "subSteps": [
                                    "Implementar captura de frames em tempo real usando cv2.VideoCapture().",
                                    "Aplicar redimensionamento e conversão para escala de cinza.",
                                    "Adicionar filtros de suavização (Gaussian Blur) para reduzir ruído.",
                                    "Exibir imagem pré-processada em janela OpenCV.",
                                    "Otimizar taxa de frames para desempenho em tempo real (FPS > 15)."
                                  ],
                                  "verification": "Janela OpenCV mostra imagem em cinza suavizada atualizando em tempo real sem lags.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python com OpenCV",
                                    "Câmera conectada"
                                  ],
                                  "tips": "Use cv2.waitKey(1) para loop responsivo; ajuste resolução para balancear qualidade e velocidade.",
                                  "learningObjective": "Preparar imagens para algoritmos de processamento eficientemente.",
                                  "commonMistakes": [
                                    "Captura em alta resolução causando lentidão",
                                    "Não liberar captura com release()",
                                    "Ignorar conversão BGR para grayscale"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar detecção de bordas com algoritmo Canny",
                                  "subSteps": [
                                    "Aplicar detecção de bordas Canny com thresholds adaptativos.",
                                    "Ajustar parâmetros (threshold baixo/alto, apertureSize) baseado em testes.",
                                    "Dilatar ou erodir bordas para reforçar features.",
                                    "Visualizar bordas sobrepostas na imagem original.",
                                    "Medir tempo de processamento por frame."
                                  ],
                                  "verification": "Bordas claras detectadas em objetos conhecidos (ex: linhas ou formas geométricas) na visualização.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Script Python expandido",
                                    "Imagens de teste com bordas nítidas"
                                  ],
                                  "tips": "Use trackbars do OpenCV para tuning interativo de thresholds; teste com diferentes iluminções.",
                                  "learningObjective": "Detectar contornos e bordas relevantes para navegação robótica.",
                                  "commonMistakes": [
                                    "Thresholds fixos ruins em variações de luz",
                                    "Não pré-processar antes de Canny",
                                    "Excesso de bordas ruidosas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar segmentação de imagem e extração de features",
                                  "subSteps": [
                                    "Aplicar threshold adaptativo ou Otsu para segmentação binária.",
                                    "Encontrar contornos usando findContours() nos bordas segmentados.",
                                    "Calcular centroide ou bounding box dos contornos principais.",
                                    "Filtrar contornos por área/tamanho para ignorar ruído.",
                                    "Desenhar features extraídas (centroide, caixa) na imagem."
                                  ],
                                  "verification": "Contornos segmentados com centroides marcados corretamente em múltiplos objetos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código com funções de contorno",
                                    "Objetos de teste (linhas, bolas)"
                                  ],
                                  "tips": "Combine Canny com threshold para segmentação robusta; use momentos para centroides precisos.",
                                  "learningObjective": "Isolar regiões de interesse e extrair métricas espaciais para controle.",
                                  "commonMistakes": [
                                    "Threshold global falhando em sombras",
                                    "Não filtrar pequenos contornos",
                                    "Cálculo errado de momentos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Gerar comandos de movimento robótico e integrar em loop de controle",
                                  "subSteps": [
                                    "Mapear posição do centroide para comandos (ex: erro em X/Y para virar/avançar).",
                                    "Implementar controlador PID simples baseado em features.",
                                    "Enviar comandos seriais (ex: 'MOVER_ESQUERDA 50') ao robô.",
                                    "Criar loop fechado: processar -> comandar -> aguardar feedback.",
                                    "Testar em simulação e hardware real com segurança."
                                  ],
                                  "verification": "Robô responde a detecção movendo-se corretamente em direção ao alvo (ex: seguir linha).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Robô mecatrônico funcional",
                                    "Código serial com pyserial",
                                    "Espaço de teste seguro"
                                  ],
                                  "tips": "Comece com ganhos PID baixos para evitar oscilações; logue erros para debug.",
                                  "learningObjective": "Fechar o loop de visão-controle para comportamento autônomo.",
                                  "commonMistakes": [
                                    "Comandos sem debounce causando jitter",
                                    "PID sem tuning",
                                    "Falta de timeout em loops"
                                  ]
                                }
                              ],
                              "practicalExample": "Implementar um robô seguidor de linha: detectar bordas da linha preta em fundo branco, calcular desvio do centroide em relação ao centro da imagem e enviar comandos para os motores diferenciais ajustarem o curso.",
                              "finalVerifications": [
                                "Sistema processa frames >10 FPS com detecção precisa de bordas e segmentação.",
                                "Robô segue linha reta/curva com erro <5cm em 1m de percurso.",
                                "Comandos gerados corretamente baseados em features extraídas.",
                                "Sistema robusto a variações leves de iluminação.",
                                "Logs mostram tempo de processamento e erros PID estáveis.",
                                "Integração serial sem perda de pacotes."
                              ],
                              "assessmentCriteria": [
                                "Precisão da detecção de bordas e segmentação (>90% de acerto em testes).",
                                "Latência total do pipeline <100ms por frame.",
                                "Estabilidade do controle robótico (sem oscilações excessivas).",
                                "Robustez a ruído e mudanças ambientais.",
                                "Código modular, comentado e reproduzível.",
                                "Eficiência computacional (CPU <70% em hardware padrão)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos em Python e bibliotecas científicas.",
                                "Matemática: Geometria analítica para centroides e vetores de direção.",
                                "Eletrônica: Interfaces seriais e atuadores em robótica.",
                                "Física: Cinemática de robôs móveis e controle de feedback.",
                                "Engenharia de Software: Desenvolvimento de sistemas em tempo real."
                              ],
                              "realWorldApplication": "Em linhas de montagem industriais, robôs usam visão para seguir caminhos, inspecionar peças ou evitar obstáculos; em drones/AGVs para navegação autônoma em armazéns."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Aplicações em Automação Mecatrônica",
                        "description": "Exploração de usos práticos da visão por computador em processos de automação robótica, com integração em sistemas mecatrônicos para inspeção e manipulação.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Desenvolver sistemas de inspeção visual automatizada",
                            "description": "Projetar fluxos de automação onde visão por computador detecta defeitos em peças, integrando com CLPs e microprocessadores para decisões em tempo real em linhas de produção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise de Requisitos e Planejamento do Sistema",
                                  "subSteps": [
                                    "Analisar o processo de produção e identificar os defeitos visuais comuns (ex.: rachaduras, manchas, dimensões incorretas).",
                                    "Definir especificações técnicas: resolução da câmera, velocidade da linha de produção, taxa de falsos positivos aceitável.",
                                    "Elaborar diagrama de fluxo do sistema, incluindo captura de imagem, processamento e ação de controle.",
                                    "Realizar estudo de viabilidade, considerando ambiente (iluminação, vibrações).",
                                    "Documentar requisitos funcionais e não funcionais."
                                  ],
                                  "verification": "Aprovação do documento de requisitos por stakeholders simulados ou professor.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Computador com software de diagramação (Draw.io ou Visio)",
                                    "Documentos do processo industrial",
                                    "Folhas de cálculo para especificações"
                                  ],
                                  "tips": "Priorize defeitos críticos que impactam a segurança ou custo; use fotos reais do processo para análise.",
                                  "learningObjective": "Compreender e documentar os requisitos para um sistema de inspeção visual eficaz.",
                                  "commonMistakes": [
                                    "Ignorar variações ambientais como iluminação variável",
                                    "Subestimar a velocidade da linha de produção",
                                    "Não considerar integração com sistemas existentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção e Configuração de Hardware",
                                  "subSteps": [
                                    "Selecionar câmera industrial (ex.: USB3 ou GigE) com resolução adequada e lente apropriada.",
                                    "Configurar sistema de iluminação LED para eliminar sombras e reflexos.",
                                    "Integrar sensores de posição e triggers para sincronização com a linha de produção.",
                                    "Conectar hardware a CLP (ex.: Siemens S7) e microprocessador (ex.: Raspberry Pi ou Arduino).",
                                    "Testar comunicação básica entre componentes."
                                  ],
                                  "verification": "Hardware montado e testado com captura de imagens estáveis e triggers funcionais.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Câmera industrial ou webcam de alta resolução",
                                    "Kits de iluminação LED",
                                    "CLP/microprocessador",
                                    "Cabos e suportes mecânicos"
                                  ],
                                  "tips": "Use iluminação difusa para peças metálicas reflexivas; teste em condições reais de produção.",
                                  "learningObjective": "Selecionar e configurar hardware otimizado para visão computacional industrial.",
                                  "commonMistakes": [
                                    "Escolha de câmera com baixa taxa de frames",
                                    "Iluminação inadequada causando falsos negativos",
                                    "Falta de sincronização com trigger"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolvimento do Algoritmo de Visão Computacional",
                                  "subSteps": [
                                    "Instalar bibliotecas (OpenCV, Python) e capturar imagens de amostras boas/ruins.",
                                    "Pré-processar imagens: correção de iluminação, filtragem de ruído, segmentação.",
                                    "Implementar detecção de defeitos usando thresholding, contornos ou ML simples (ex.: classificadores SVM).",
                                    "Treinar modelo com dataset anotado e otimizar para tempo real.",
                                    "Desenvolver interface para visualização de resultados (bounding boxes, alertas)."
                                  ],
                                  "verification": "Algoritmo detecta defeitos em conjunto de teste com acurácia >90%.",
                                  "estimatedTime": "12 horas",
                                  "materials": [
                                    "Computador com Python/OpenCV",
                                    "Dataset de imagens (próprio ou público como Kaggle)",
                                    "IDE como VS Code"
                                  ],
                                  "tips": "Comece com métodos simples antes de ML; use ROI (Region of Interest) para acelerar processamento.",
                                  "learningObjective": "Desenvolver algoritmos robustos de detecção de defeitos via visão computacional.",
                                  "commonMistakes": [
                                    "Dataset desbalanceado",
                                    "Processamento lento sem otimização",
                                    "Sobreajuste ao ruído de treinamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração com Sistemas de Controle",
                                  "subSteps": [
                                    "Implementar comunicação via protocolos (Modbus, OPC UA) entre software de visão e CLP.",
                                    "Programar lógica no CLP para ações baseadas em detecção (parar linha, rejeitar peça).",
                                    "Configurar microprocessador para edge computing e decisões em tempo real.",
                                    "Sincronizar timestamps para rastreabilidade.",
                                    "Testar loop fechado: detecção → sinal → ação."
                                  ],
                                  "verification": "Sistema integrado responde corretamente a defeitos simulados em <100ms.",
                                  "estimatedTime": "10 horas",
                                  "materials": [
                                    "Software de programação CLP (TIA Portal)",
                                    "Microcontrolador programável",
                                    "Simulador de linha de produção"
                                  ],
                                  "tips": "Use threads para processamento paralelo; monitore latência com tools como Wireshark.",
                                  "learningObjective": "Integrar visão computacional com automação industrial para controle em tempo real.",
                                  "commonMistakes": [
                                    "Protocolos incompatíveis",
                                    "Latência excessiva em comunicação",
                                    "Falta de tratamento de falhas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes, Calibração e Validação Final",
                                  "subSteps": [
                                    "Executar testes em ambiente simulado com peças reais boas/defeituosas.",
                                    "Calibrar sistema ajustando thresholds e iluminação para maximizar acurácia.",
                                    "Medir métricas: precisão, recall, F1-score, tempo de ciclo.",
                                    "Realizar testes de estresse (alta velocidade, variações ambientais).",
                                    "Documentar relatório com logs e recomendações de manutenção."
                                  ],
                                  "verification": "Relatório de testes com métricas acima de benchmarks definidos.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Peças de teste reais",
                                    "Ferramentas de medição (cronômetro, software de análise)",
                                    "Log de eventos"
                                  ],
                                  "tips": "Automatize testes com scripts; registre vídeos de falhas para análise posterior.",
                                  "learningObjective": "Validar e otimizar o sistema para deployment industrial.",
                                  "commonMistakes": [
                                    "Testes insuficientes em variações reais",
                                    "Ignorar manutenção preditiva",
                                    "Não documentar calibrações"
                                  ]
                                }
                              ],
                              "practicalExample": "Projeto de um sistema para inspeção de soldas em placas de circuito impresso (PCB) em linha de produção eletrônica: câmera captura imagem a 30 FPS, OpenCV detecta soldas frias ou pontes, CLP rejeita peça defeituosa e ativa alarme.",
                              "finalVerifications": [
                                "Sistema detecta defeitos com acurácia ≥95% em testes reais.",
                                "Tempo de processamento total <50ms por peça.",
                                "Integração com CLP ativa ações corretas em 100% dos casos simulados.",
                                "Robustez comprovada em variações de iluminação (±20%) e velocidade da linha.",
                                "Relatório de validação inclui métricas e logs rastreáveis.",
                                "Interface permite monitoramento remoto de desempenho."
                              ],
                              "assessmentCriteria": [
                                "Precisão e recall da detecção de defeitos (>90%).",
                                "Latência e desempenho em tempo real.",
                                "Qualidade da integração hardware-software-controle.",
                                "Documentação completa e clara de requisitos e testes.",
                                "Robustez a condições variáveis do ambiente industrial.",
                                "Criatividade na resolução de problemas comuns."
                              ],
                              "crossCurricularConnections": [
                                "Programação e Visão Computacional (OpenCV/Python).",
                                "Eletrônica e Automação Industrial (CLPs, protocolos).",
                                "Inteligência Artificial e Machine Learning básico.",
                                "Mecânica e Design de Sistemas Embutidos.",
                                "Gestão de Projetos e Qualidade Industrial (Six Sigma)."
                              ],
                              "realWorldApplication": "Aplicado em indústrias automotiva (inspeção de peças fundidas), farmacêutica (verificação de comprimidos) e alimentícia (detecção de contaminantes), reduzindo rejeitos em até 30% e custos de mão de obra inspeção manual."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Implementar navegação robótica baseada em visão",
                            "description": "Configurar robôs móveis para navegação autônoma usando visão computacional (SLAM básico), com feedback mecatrônico para correção de trajetória via atuadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Hardware do Robô Móvel",
                                  "subSteps": [
                                    "Montar chassis do robô com rodas diferenciais e motores DC.",
                                    "Instalar câmera USB ou Raspberry Pi Camera no topo para visão frontal.",
                                    "Conectar IMU (Inertial Measurement Unit) e encoders de roda para odometria.",
                                    "Integrar microcontrolador (ex: Arduino ou Raspberry Pi) com drivers de motor.",
                                    "Testar conexões elétricas e comunicação serial/I2C."
                                  ],
                                  "verification": "Robô se move suavemente em comandos manuais via joystick ou código simples; câmera captura vídeo sem distorções.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Chassis robô",
                                    "Câmera USB/RPi",
                                    "IMU MPU6050",
                                    "Motores DC com encoders",
                                    "Raspberry Pi 4",
                                    "Arduino Uno",
                                    "Cabos jumper, protoboard"
                                  ],
                                  "tips": "Use braçadeiras para fixar componentes firmemente; calibre IMU em superfície plana.",
                                  "learningObjective": "Entender integração de sensores mecatrônicos para base de navegação.",
                                  "commonMistakes": [
                                    "Conexões soltas causando falhas intermitentes",
                                    "Polaridade invertida em motores",
                                    "Câmera mal alinhada obstruindo visão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e Configurar Software de Visão Computacional",
                                  "subSteps": [
                                    "Instalar ROS (Robot Operating System) Noetic ou ROS2 Humble no Raspberry Pi.",
                                    "Configurar pacotes OpenCV e GStreamer para streaming de vídeo da câmera.",
                                    "Calibrar câmera usando chessboard pattern para parâmetros intrínsecos.",
                                    "Testar detecção de features com ORB ou SIFT em imagens reais.",
                                    "Publicar tópicos ROS para imagem raw e processed."
                                  ],
                                  "verification": "Node ROS publica imagens calibradas e detecta keypoints consistentemente em loop de teste.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Raspberry Pi com Ubuntu",
                                    "Chessboard impresso",
                                    "Terminal SSH",
                                    "Documentação ROS/OpenCV"
                                  ],
                                  "tips": "Use virtualenv para isolar dependências; teste em baixa resolução primeiro para debug.",
                                  "learningObjective": "Dominar pipeline de visão em ROS para processamento em tempo real.",
                                  "commonMistakes": [
                                    "Versão incompatível de OpenCV",
                                    "Falta de calibração causando distorção",
                                    "Tópicos ROS não mapeados corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar SLAM Básico para Mapeamento e Localização",
                                  "subSteps": [
                                    "Instalar pacote SLAM como RTAB-Map ou Cartographer no ROS.",
                                    "Configurar launch file para SLAM usando odometria de encoders e odom visual.",
                                    "Executar SLAM em ambiente conhecido (sala com markers) para gerar mapa 2D/3D.",
                                    "Visualizar mapa em RViz e salvar como .yaml/.pgm.",
                                    "Adicionar loop closure para correção de drift."
                                  ],
                                  "verification": "Mapa gerado coincide com ambiente real (erro <5cm); pose estimada é consistente após loop.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ambiente de teste com paredes/marcadores",
                                    "RViz",
                                    "Pacotes ROS SLAM"
                                  ],
                                  "tips": "Ilumine bem o ambiente; reduza velocidade inicial para convergência estável.",
                                  "learningObjective": "Aplicar SLAM para navegação autônoma simultânea de localização e mapeamento.",
                                  "commonMistakes": [
                                    "Pouca textura no ambiente falhando features",
                                    "Alta velocidade causando blur",
                                    "Ignorar covariância de odometria"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Feedback Mecatrônico para Correção de Trajetória",
                                  "subSteps": [
                                    "Criar nó ROS para controle PID usando pose SLAM e setpoint de trajetória.",
                                    "Mapear erros de pose (x,y,theta) para comandos de velocidade diferencial.",
                                    "Implementar atuadores: ajuste PWM motores baseado em feedback IMU/encoders.",
                                    "Adicionar safety stops para obstáculos detectados via visão.",
                                    "Testar em trajetórias retas e curvas com correção em tempo real."
                                  ],
                                  "verification": "Robô segue trajetória com erro médio <10cm; responde a desvios em <1s.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código PID em Python/C++",
                                    "Tuner PID online",
                                    "Trajetórias pré-definidas"
                                  ],
                                  "tips": "Comece com ganhos PID baixos; logue erros para tuning iterativo.",
                                  "learningObjective": "Fundir visão com controle mecatrônico para navegação robusta.",
                                  "commonMistakes": [
                                    "PID overshooting por ganhos altos",
                                    "Falta de filtro low-pass em feedback",
                                    "Desacoplamento pose-atuadores"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Otimizar Sistema Completo",
                                  "subSteps": [
                                    "Executar navegação autônoma em percurso desconhecido gerando mapa online.",
                                    "Medir métricas: tempo de convergência SLAM, precisão trajetória, taxa de falha.",
                                    "Otimizar parâmetros: threshold features, gains PID, resolução mapa.",
                                    "Adicionar logging e replay para análise pós-teste.",
                                    "Documentar setup e resultados."
                                  ],
                                  "verification": "Robô completa missão sem intervenção humana; métricas dentro de thresholds (ex: ATE <0.1m).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Percurso de teste (labirinto simples)",
                                    "Ferramentas métricas ROS (evaleval)"
                                  ],
                                  "tips": "Grave vídeos para análise qualitativa; teste em variações de luz.",
                                  "learningObjective": "Validar e refinar sistema de navegação integrada.",
                                  "commonMistakes": [
                                    "Testes só em condições ideais",
                                    "Ignorar latência de processamento",
                                    "Falta de baselines comparativos"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um robô TurtleBot3 ou similar para navegar autonomamente em um labirinto de 2x2m com paredes de papelão, usando câmera para SLAM e motores para corrigir desvios, alcançando o goal em <2min com mapa preciso.",
                              "finalVerifications": [
                                "SLAM gera mapa coerente com ambiente real (erro <5cm).",
                                "Robô localiza pose corretamente após loop closure.",
                                "Trajetória segue setpoints com correção mecatrônica em tempo real.",
                                "Sistema roda a >10FPS sem crashes.",
                                "Detecção de obstáculos via visão ativa safety stop.",
                                "Logs mostram drift <10% em sessões longas."
                              ],
                              "assessmentCriteria": [
                                "Precisão de mapeamento (ATE RMSE <0.1m).",
                                "Tempo de resposta a desvios (<0.5s).",
                                "Robustez a variações de iluminação (sucesso >80%).",
                                "Eficiência computacional (CPU <70% em RPi).",
                                "Integração sem erros de comunicação ROS.",
                                "Documentação clara de setup e tuning."
                              ],
                              "crossCurricularConnections": [
                                "Programação: ROS nodes em Python/C++.",
                                "Inteligência Artificial: Processamento de features e SLAM.",
                                "Controle Automático: PID e feedback loops.",
                                "Eletrônica: Interfaces sensores/atuadores.",
                                "Matemática: Transformações homogêneas e geometria computacional."
                              ],
                              "realWorldApplication": "Navegação de AGVs (Automated Guided Vehicles) em armazéns como Amazon, drones de inspeção em fábricas, ou veículos autônomos em logística urbana para entregas precisas e seguras."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Integrar visão com equipes multifuncionais em projetos",
                            "description": "Aplicar técnicas de desenvolvimento integrado de produtos (conforme Cross, 2004) para times que combinam visão, mecânica e eletrônica em projetos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar os Princípios de Desenvolvimento Integrado de Produtos (IPD) conforme Cross (2004)",
                                  "subSteps": [
                                    "Ler os capítulos relevantes sobre IPD em 'Engineering Design' de Cross (2004), focando em integração multifuncional.",
                                    "Identificar os pilares chave: colaboração simultânea, compartilhamento de informações e iteração contínua.",
                                    "Mapear como IPD se aplica a equipes visão-mecânica-eletrônica em mecatrônica.",
                                    "Criar um diagrama conceitual dos fluxos de IPD para projetos mecatrônicos.",
                                    "Resumir em bullet points os benefícios para integração de visão computacional."
                                  ],
                                  "verification": "Produzir um resumo de 1 página com diagrama e pillars identificados, revisado por um colega.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Engineering Design' de Cross (2004)",
                                    "Ferramentas de diagramação (ex: Draw.io)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Priorize exemplos de produtos mecatrônicos para contextualizar os conceitos.",
                                  "learningObjective": "Compreender os fundamentos teóricos de IPD para aplicação em equipes multifuncionais.",
                                  "commonMistakes": [
                                    "Ler superficialmente sem mapear para mecatrônica",
                                    "Ignorar aspectos de comunicação interpessoal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Papéis e Responsabilidades nas Equipes Multifuncionais",
                                  "subSteps": [
                                    "Listar membros da equipe: especialistas em visão, mecânica, eletrônica e gerente de projeto.",
                                    "Definir responsabilidades claras usando matriz RACI (Responsible, Accountable, Consulted, Informed).",
                                    "Identificar interfaces críticas: dados de visão para controle eletrônico, feedback mecânico para calibração de visão.",
                                    "Realizar reunião inicial para validar o mapeamento com a equipe.",
                                    "Documentar em um organograma compartilhado."
                                  ],
                                  "verification": "Matriz RACI aprovada por todos os membros da equipe e organograma acessível.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel para RACI",
                                    "Ferramenta de videoconferência (ex: Zoom)",
                                    "Template de organograma"
                                  ],
                                  "tips": "Inclua um 'ponto focal' por interface para agilizar decisões.",
                                  "learningObjective": "Estabelecer estrutura colaborativa para integração eficaz.",
                                  "commonMistakes": [
                                    "Sobrecarregar um papel com múltiplas responsabilidades",
                                    "Não consultar a equipe no mapeamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Protocolos de Comunicação e Interfaces Integradas",
                                  "subSteps": [
                                    "Definir protocolos de dados: formatos (ex: ROS topics para visão, CAN bus para eletrônica).",
                                    "Criar APIs ou middlewares para troca de dados entre visão, mecânica e eletrônica.",
                                    "Simular fluxos de dados em software (ex: MATLAB/Simulink ou Gazebo).",
                                    "Testar comunicação em ambiente simulado com dados reais de visão.",
                                    "Documentar protocolos em um repositório compartilhado (ex: GitHub)."
                                  ],
                                  "verification": "Simulação bem-sucedida com logs de dados trocados sem erros.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Software ROS ou similar",
                                    "Simulador Gazebo/MATLAB",
                                    "Repositório Git"
                                  ],
                                  "tips": "Use mensagens padronizadas como JSON para facilitar depuração.",
                                  "learningObjective": "Implementar canais de comunicação robustos entre disciplinas.",
                                  "commonMistakes": [
                                    "Escolher protocolos incompatíveis entre hardware",
                                    "Não versionar documentos de interface"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, Testar e Iterar a Integração no Projeto",
                                  "subSteps": [
                                    "Integrar componentes físicos: câmera de visão com atuadores mecânicos e controladores eletrônicos.",
                                    "Executar testes unitários por disciplina e testes integrados.",
                                    "Coletar métricas: latência de visão, precisão mecânica, estabilidade eletrônica.",
                                    "Realizar reuniões de revisão com feedback multifuncional e ajustes via IPD.",
                                    "Finalizar relatório de integração com lições aprendidas."
                                  ],
                                  "verification": "Sistema integrado opera com sucesso em cenário real por 30 minutos sem falhas.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Hardware mecatrônico (câmera, atuadores, PLCs)",
                                    "Ferramentas de teste (osciloscópio, software de logging)",
                                    "Relatório template"
                                  ],
                                  "tips": "Comece com cenários simples e escale para complexos.",
                                  "learningObjective": "Validar integração prática usando ciclos de IPD.",
                                  "commonMistakes": [
                                    "Pular testes unitários",
                                    "Ignorar feedback não-técnico da equipe"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de braço robótico pick-and-place para automação industrial: a visão computacional detecta objetos via câmera OpenCV; dados são enviados via ROS para o controlador eletrônico (PLC) que aciona servos mecânicos. A equipe multifuncional usa IPD para iterar calibrações em tempo real, garantindo precisão de 95% em picking.",
                              "finalVerifications": [
                                "Sistema integrado processa dados de visão e aciona mecânica/eletrônica sem atrasos >100ms.",
                                "Equipe relata alinhamento de responsabilidades via pesquisa de satisfação (>80% positivo).",
                                "Protocolos documentados e versionados no repositório.",
                                "Testes finais mostram taxa de sucesso >90% em cenários reais.",
                                "Relatório de lições aprendidas inclui pelo menos 3 iterações de IPD.",
                                "Métricas de desempenho (latência, precisão) atendem especificações do projeto."
                              ],
                              "assessmentCriteria": [
                                "Profundidade na aplicação de princípios IPD de Cross (2004): 30%.",
                                "Efetividade dos protocolos de comunicação: 25%.",
                                "Qualidade da colaboração multifuncional (feedback da equipe): 20%.",
                                "Robustez da integração testada (métricas quantitativas): 15%.",
                                "Documentação completa e acionável: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Uso de metodologias ágeis como Scrum para iterações IPD.",
                                "Comunicação e Liderança: Técnicas de facilitação em reuniões multifuncionais.",
                                "Programação de Sistemas Embarcados: Integração de software de visão com firmware eletrônico.",
                                "Design Mecânico: Considerações ergonômicas na montagem de componentes visuais."
                              ],
                              "realWorldApplication": "Na indústria automotiva, integrar sistemas de visão para inspeção de soldas em linhas de montagem, onde equipes combinam visão (detecção de defeitos), mecânica (posicionadores robóticos) e eletrônica (sensores de feedback), reduzindo defeitos em 40% e acelerando produção via IPD colaborativo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Aplicações Específicas na Indústria Aeronáutica",
                        "description": "Foco em casos de uso da visão por computador em robótica mecatrônica para montagem, inspeção e qualidade na manufatura aeronáutica.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Analisar casos de inspeção de componentes aeronáuticos",
                            "description": "Estudar aplicações de visão para detecção de trincas e alinhamentos em fuselagens e asas, integrando com sistemas mecatrônicos (Lyshevski, 1999; Shetty & Kolk, 1997).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Desafios de Inspeção em Componentes Aeronáuticos",
                                  "subSteps": [
                                    "Pesquisar tipos comuns de defeitos como trincas por fadiga e desalinhamentos em fuselagens e asas.",
                                    "Estudar as referências principais: Lyshevski (1999) sobre sistemas mecatrônicos e Shetty & Kolk (1997) sobre aplicações industriais.",
                                    "Analisar imagens reais de componentes aeronáuticos danificados disponíveis em bancos de dados públicos.",
                                    "Identificar impactos de falhas não detectadas na segurança de voo.",
                                    "Mapear requisitos regulatórios (ex: FAA standards) para inspeções visuais."
                                  ],
                                  "verification": "Criar um relatório de 1 página resumindo 5 defeitos principais e suas causas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livros: Lyshevski (1999), Shetty & Kolk (1997)",
                                    "Bancos de dados: NASA defect image repository",
                                    "Artigos: FAA advisory circulars on NDT"
                                  ],
                                  "tips": "Use diagramas anotados para visualizar defeitos em 3D.",
                                  "learningObjective": "Identificar e classificar defeitos estruturais comuns em aeronaves.",
                                  "commonMistakes": [
                                    "Confundir trincas superficiais com defeitos críticos.",
                                    "Ignorar contexto de fadiga cíclica em voos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Técnicas de Visão Computacional para Detecção de Defeitos",
                                  "subSteps": [
                                    "Aprender algoritmos de detecção de bordas (Canny, Sobel) e segmentação (thresholding adaptativo).",
                                    "Explorar processamento de imagens para identificação de trincas (morphological operations).",
                                    "Estudar alinhamento geométrico usando feature matching (SIFT, ORB).",
                                    "Simular detecção em software como OpenCV com datasets de imagens aeronáuticas.",
                                    "Analisar métricas de performance: precisão, recall e F1-score para detecção."
                                  ],
                                  "verification": "Implementar um script simples em Python/OpenCV que detecta uma trinca simulada em uma imagem.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software: OpenCV, Python, Jupyter Notebook",
                                    "Datasets: Kaggle aircraft defect images",
                                    "Tutoriais: OpenCV documentation on edge detection"
                                  ],
                                  "tips": "Teste com ruído gaussiano para simular condições reais de iluminação.",
                                  "learningObjective": "Aplicar técnicas de visão computacional específicas para defeitos aeronáuticos.",
                                  "commonMistakes": [
                                    "Usar thresholds fixos em vez de adaptativos.",
                                    "Não calibrar câmera para distorções em superfícies curvas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Casos Reais de Inspeção",
                                  "subSteps": [
                                    "Selecionar 3-5 casos de estudo de inspeções em fuselagens e asas (ex: Boeing 737 incidents).",
                                    "Descrever setup de visão: câmeras, iluminação e posicionamento robótico.",
                                    "Avaliar resultados: taxa de detecção vs. inspeção manual.",
                                    "Comparar com métodos tradicionais (ultrassom, raio-X).",
                                    "Documentar lições aprendidas e limitações observadas."
                                  ],
                                  "verification": "Produzir uma tabela comparativa de 3 casos com métricas de sucesso.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Relatórios: NTSB aviation accident database",
                                    "Vídeos: YouTube demos de inspeção robótica aeronáutica",
                                    "Papers: IEEE on computer vision in aerospace"
                                  ],
                                  "tips": "Priorize casos recentes para relevância tecnológica.",
                                  "learningObjective": "Criticar e extrair insights de aplicações reais de visão em inspeções.",
                                  "commonMistakes": [
                                    "Generalizar um caso sem considerar variações de material (alumínio vs. compósitos).",
                                    "Subestimar falsos positivos em texturas pintadas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar com Sistemas Mecatrônicos e Sintetizar Análise",
                                  "subSteps": [
                                    "Explorar integração: visão + atuadores robóticos para inspeção automatizada.",
                                    "Modelar feedback loops mecatrônicos (sensores, controladores PID).",
                                    "Propor um sistema híbrido para inspeção em tempo real.",
                                    "Simular integração em software (ROS para robótica).",
                                    "Avaliar escalabilidade para linhas de produção aeronáuticas."
                                  ],
                                  "verification": "Desenhar um diagrama de fluxo do sistema integrado e listar componentes chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software: ROS (Robot Operating System), Gazebo simulator",
                                    "Livros: Lyshevski on mechatronic systems",
                                    "Hardware simulado: Arduino kits para protótipos"
                                  ],
                                  "tips": "Use blocos funcionais para visualizar integração.",
                                  "learningObjective": "Conectar visão computacional a subsistemas mecatrônicos para inspeção.",
                                  "commonMistakes": [
                                    "Ignorar latência em loops de feedback real-time.",
                                    "Não considerar vibrações em plataformas robóticas móveis."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem da Embraer, um sistema de visão montado em braço robótico escaneia asas de E-Jets, detectando trincas de 0.5mm usando edge detection e alertando o operador via integração mecatrônica, reduzindo tempo de inspeção em 40%.",
                              "finalVerifications": [
                                "Lista precisa de 5 técnicas de visão para trincas e alinhamentos.",
                                "Análise crítica de pelo menos 2 casos reais com métricas.",
                                "Diagrama completo de integração mecatrônica.",
                                "Identificação de 3 limitações e soluções propostas.",
                                "Simulação funcional de detecção em OpenCV.",
                                "Relatório coeso conectando teoria a prática."
                              ],
                              "assessmentCriteria": [
                                "Profundidade na compreensão de defeitos aeronáuticos (30%).",
                                "Precisão técnica em visão computacional (25%).",
                                "Qualidade da análise de casos reais (20%).",
                                "Criatividade na integração mecatrônica (15%).",
                                "Clareza e estrutura do relatório final (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Aeronáutica: Normas de manutenção estrutural.",
                                "Inteligência Artificial: Machine learning para classificação de defeitos.",
                                "Robótica: Controle de manipuladores para inspeção.",
                                "Processamento de Sinais: Filtragem de imagens ruidosas.",
                                "Gestão de Qualidade: ISO standards em inspeções industriais."
                              ],
                              "realWorldApplication": "Implementação em hangares de companhias aéreas como LATAM ou American Airlines para inspeções preventivas diárias, detectando falhas precocemente e evitando grounded fleets, economizando milhões em downtime e melhorando segurança."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Projetar robôs para montagem precisa com visão",
                            "description": "Elaborar projetos de robôs mecatrônicos que usam visão para posicionamento milimétrico de rebites e parafusos em estruturas aeronáuticas, incluindo simulações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise de Requisitos e Definição do Escopo",
                                  "subSteps": [
                                    "Identificar tolerâncias de posicionamento milimétrico para rebites e parafusos em estruturas aeronáuticas (ex.: ±0.1mm).",
                                    "Mapear ambiente de montagem: iluminação, vibrações, materiais de superfície (alumínio composto).",
                                    "Definir restrições: tamanho do robô, payload, velocidade de operação e integração com linhas de produção.",
                                    "Especificar saídas do sistema de visão: detecção de furos, alinhamento em tempo real.",
                                    "Documentar requisitos em um documento de especificação técnica."
                                  ],
                                  "verification": "Revisar documento de requisitos assinado por stakeholders simulados, confirmando cobertura de todos parâmetros críticos.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": [
                                    "Software de gerenciamento de projetos (ex.: Trello ou MS Project)",
                                    "Normas aeronáuticas (ex.: FAA AC 43.13)",
                                    "Planilhas Excel para tolerâncias"
                                  ],
                                  "tips": "Priorize requisitos de segurança e precisão; use diagramas de fluxo para visualizar o processo de montagem.",
                                  "learningObjective": "Compreender e documentar requisitos funcionais e não-funcionais para projetos de robótica de precisão.",
                                  "commonMistakes": [
                                    "Subestimar variações ambientais como reflexos de luz.",
                                    "Ignorar integração com sistemas existentes da linha de produção.",
                                    "Definir tolerâncias muito amplas incompatíveis com padrões aeronáuticos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Design Conceitual Mecânico e Cinemático do Robô",
                                  "subSteps": [
                                    "Selecionar arquitetura robótica (ex.: SCARA ou delta para alta precisão).",
                                    "Calcular graus de liberdade necessários para alcance e orientação do efetuador final.",
                                    "Dimensionar atuadores, juntas e estrutura para suportar payload de ferramentas de montagem.",
                                    "Integrar suporte para câmeras de visão (calibração de posição relativa).",
                                    "Criar esboços CAD iniciais com foco em acessibilidade para inspeção visual."
                                  ],
                                  "verification": "Gerar modelo 3D conceitual exportável e simular alcance básico sem colisões.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": [
                                    "Software CAD (ex.: SolidWorks ou Fusion 360)",
                                    "Bibliotecas de componentes robóticos (ex.: URDF para ROS)",
                                    "Tabelas de especificações de atuadores lineares/rotativos"
                                  ],
                                  "tips": "Use análise cinemática inversa para validar trajetórias; considere redundância em DOFs para correções de visão.",
                                  "learningObjective": "Projetar mecanismos robóticos otimizados para tarefas de montagem precisa.",
                                  "commonMistakes": [
                                    "Escolher atuadores com resolução insuficiente para milimétricos.",
                                    "Negligenciar rigidez estrutural contra vibrações.",
                                    "Sobre-dimensionar o robô, aumentando custo e inércia."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Design do Sistema de Visão Computacional",
                                  "subSteps": [
                                    "Selecionar câmeras e lentes (ex.: alta resolução, lente telecêntrica para distorção zero).",
                                    "Definir pipeline de processamento: aquisição, pré-processamento (filtro gaussiano), detecção de features (Hough para furos).",
                                    "Implementar algoritmos de tracking e pose estimation (ex.: PnP para alinhamento 6D).",
                                    "Calibrar sistema para precisão sub-milimétrica usando padrões conhecidos.",
                                    "Otimizar para tempo real (FPS >30) com bibliotecas como OpenCV."
                                  ],
                                  "verification": "Testar protótipo de visão em setup de bancada medindo erro de detecção em mockups aeronáuticos.",
                                  "estimatedTime": "8-10 horas",
                                  "materials": [
                                    "Biblioteca OpenCV ou Halcon",
                                    "Câmeras industriais simuladas (ex.: webcams para protótipo)",
                                    "Padrões de calibração impressos",
                                    "Computador com GPU para processamento"
                                  ],
                                  "tips": "Use iluminação LED controlada para consistência; teste com superfícies reflexivas comuns em alumínio.",
                                  "learningObjective": "Integrar visão computacional para feedback de posicionamento em robótica.",
                                  "commonMistakes": [
                                    "Escolher câmeras com profundidade de campo inadequada.",
                                    "Ignorar latência de processamento afetando controle em loop fechado.",
                                    "Falta de calibração robusta a variações térmicas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolvimento de Algoritmos de Controle e Integração",
                                  "subSteps": [
                                    "Implementar controlador híbrido: PID para trajetória + servo-visão para correções finas.",
                                    "Desenvolver lógica de segurança: detecção de falhas de visão e fallback manual.",
                                    "Integrar comunicação: ROS nodes para visão, movimento e I/O de ferramentas.",
                                    "Programar sequências de montagem: approach, align, insert, verify.",
                                    "Testar em simulação integrada (Gazebo ou CoppeliaSim)."
                                  ],
                                  "verification": "Executar simulação end-to-end sem erros de convergência em posicionamento.",
                                  "estimatedTime": "10-12 horas",
                                  "materials": [
                                    "Framework ROS2 ou MATLAB Robotics Toolbox",
                                    "Simuladores (Gazebo, Webots)",
                                    "Linguagens: Python/C++ para nodes"
                                  ],
                                  "tips": "Implemente filtros Kalman para fusão de dados de visão e encoders; priorize modularidade para debug.",
                                  "learningObjective": "Criar sistemas de controle autônomos baseados em feedback visual.",
                                  "commonMistakes": [
                                    "Controladores PID mal tunados causando oscilações.",
                                    "Falta de handling de occlusões na visão.",
                                    "Integração sem timeouts levando a travamentos."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simulação Completa, Otimização e Documentação",
                                  "subSteps": [
                                    "Construir modelo digital twin completo do robô e ambiente aeronáutico.",
                                    "Executar simulações Monte Carlo para variabilidade (iluminação, vibração).",
                                    "Otimizar parâmetros via algoritmos genéticos ou gradient descent.",
                                    "Gerar relatórios de performance: taxa de sucesso, tempo ciclo, precisão.",
                                    "Documentar blueprint final com arquivos CAD, código e especificações."
                                  ],
                                  "verification": "Relatório final mostrando >99% de precisão em 100 simulações repetidas.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": [
                                    "Simulador avançado (Gazebo com plugins visão)",
                                    "Ferramentas de otimização (MATLAB Optimization Toolbox)",
                                    "Templates de relatórios técnicos"
                                  ],
                                  "tips": "Varie condições extremas nas simulações; use versionamento Git para iterações.",
                                  "learningObjective": "Validar e refinar designs robóticos via simulação realista.",
                                  "commonMistakes": [
                                    "Simulações sem ruído realista superestimando performance.",
                                    "Otimização local em vez de global.",
                                    "Documentação incompleta impedindo fabricação."
                                  ]
                                }
                              ],
                              "practicalExample": "Projeto de um robô SCARA para montagem de painéis de fuselagem: usa duas câmeras para detectar furos de ±0.05mm, corrige trajetória em tempo real e insere rebites em sequência, simulando ciclo de 20s por peça em ambiente Gazebo com vibrações simuladas.",
                              "finalVerifications": [
                                "Simulação atinge precisão <0.1mm em 95% dos casos.",
                                "Tempo de ciclo atende especificações industriais (<30s por inserção).",
                                "Sistema de visão robusto a variações de iluminação ±20%.",
                                "Controles convergem sem oscilações em <1s.",
                                "Documentação completa permite prototipagem física imediata.",
                                "Análise de falhas identifica <1% de cenários não cobertos."
                              ],
                              "assessmentCriteria": [
                                "Precisão do design mecânico e cinemático (alcance, rigidez).",
                                "Robustez e latência do pipeline de visão.",
                                "Estabilidade e responsividade dos algoritmos de controle.",
                                "Qualidade das simulações (realismo, cobertura de edge cases).",
                                "Completude da documentação e relatórios.",
                                "Integração interdisciplinar (mecânica-visão-controle)."
                              ],
                              "crossCurricularConnections": [
                                "Programação e IA: Algoritmos de visão e machine learning para detecção.",
                                "Matemática: Cinemática, geometria computacional e otimização.",
                                "Física: Dinâmica de robôs e óptica para visão.",
                                "Engenharia de Materiais: Propriedades de ligas aeronáuticas.",
                                "Gestão de Projetos: Análise de requisitos e validação."
                              ],
                              "realWorldApplication": "Montagem automatizada de aeronaves na Boeing ou Embraer, reduzindo erros humanos em 90%, acelerando produção de fuselagens e asas com precisão certificável para aviação comercial."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Avaliar desempenho de sistemas visão-mecatrônicos aeronáuticos",
                            "description": "Realizar análises de métricas como precisão, latência e robustez em ambientes industriais aeronáuticos, com base em métodos de design engineering.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir métricas e critérios de avaliação",
                                  "subSteps": [
                                    "Identificar métricas chave: precisão (accuracy, precision, recall), latência (tempo de processamento) e robustez (desempenho sob variações como iluminação ou vibração).",
                                    "Estabelecer benchmarks baseados em padrões aeronáuticos (ex: FAA ou EASA guidelines).",
                                    "Definir thresholds aceitáveis para cada métrica em contextos industriais.",
                                    "Documentar plano de teste com métodos de design engineering (ex: DOE - Design of Experiments).",
                                    "Revisar literatura técnica para validação de métricas."
                                  ],
                                  "verification": "Plano de métricas documentado e aprovado por revisor, com pelo menos 5 métricas definidas e benchmarks justificados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação de padrões aeronáuticos (FAA/EASA PDFs)",
                                    "Software de planejamento como Excel ou MATLAB",
                                    "Literatura em visão computacional (artigos IEEE)"
                                  ],
                                  "tips": "Priorize métricas relevantes ao contexto aeronáutico, como robustez a vibrações de turbinas.",
                                  "learningObjective": "Compreender e selecionar métricas adequadas para avaliação de sistemas visão-mecatrônicos.",
                                  "commonMistakes": [
                                    "Escolher métricas genéricas sem contexto aeronáutico",
                                    "Ignorar variações ambientais industriais",
                                    "Definir thresholds irrealistas sem benchmarks"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de teste simulado ou real",
                                  "subSteps": [
                                    "Montar setup de teste replicando ambiente aeronáutico (ex: esteira com vibração simulada, iluminação variável).",
                                    "Integrar hardware: câmeras, processadores mecatrônicos e atuadores.",
                                    "Calibrar sistema de visão usando padrões como tabuleiros de xadrez.",
                                    "Implementar scripts de automação para testes repetitivos.",
                                    "Testar conectividade e segurança do setup."
                                  ],
                                  "verification": "Setup operacional com logs de calibração confirmando precisão <1mm erro e testes iniciais rodando sem falhas.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Câmera industrial (ex: Basler), Computador com GPU",
                                    "Software: OpenCV, ROS para mecatrônica",
                                    "Simulador aeronáutico (ex: Gazebo com vibração)"
                                  ],
                                  "tips": "Use vibração controlada para simular condições de montagem de aeronaves.",
                                  "learningObjective": "Configurar ambientes de teste realistas para sistemas visão-mecatrônicos industriais.",
                                  "commonMistakes": [
                                    "Não calibrar adequadamente levando a erros sistemáticos",
                                    "Ignorar ruído ambiental como poeira ou umidade",
                                    "Setup instável causando latência artificial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar testes e coletar dados",
                                  "subSteps": [
                                    "Rodar suítes de testes variando condições (iluminação, velocidade, obstruções).",
                                    "Registrar dados em tempo real: imagens, timestamps, outputs do sistema.",
                                    "Executar pelo menos 100 iterações por cenário para estatística robusta.",
                                    "Monitorar falhas e anomalias durante execução.",
                                    "Backup dados em formato estruturado (CSV/JSON)."
                                  ],
                                  "verification": "Dataset coletado com >1000 amostras, logs completos e sem perdas de dados.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Hardware de teste montado",
                                    "Scripts Python/OpenCV para automação",
                                    "Ferramentas de logging (ex: Pandas)"
                                  ],
                                  "tips": "Varie condições gradualmente para capturar thresholds de falha.",
                                  "learningObjective": "Coletar dados empíricos de forma sistemática e reprodutível.",
                                  "commonMistakes": [
                                    "Amostragem insuficiente levando a variância alta",
                                    "Não registrar metadados ambientais",
                                    "Parar testes prematuramente em falhas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar dados e interpretar resultados",
                                  "subSteps": [
                                    "Calcular métricas: precisão via confusion matrix, latência via histograms, robustez via testes estatísticos (t-test).",
                                    "Visualizar dados com gráficos (ROC curves, boxplots).",
                                    "Comparar com benchmarks e identificar gargalos.",
                                    "Aplicar métodos de design engineering para otimização (ex: análise de regressão).",
                                    "Documentar insights e recomendações."
                                  ],
                                  "verification": "Relatório de análise com gráficos, cálculos validados e conclusões suportadas por dados.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Software: MATLAB/Python (Scikit-learn, Matplotlib)",
                                    "Datasets coletados",
                                    "Ferramentas estatísticas (R ou SciPy)"
                                  ],
                                  "tips": "Use normalização para comparar métricas em escalas diferentes.",
                                  "learningObjective": "Interpretar dados de desempenho usando ferramentas analíticas avançadas.",
                                  "commonMistakes": [
                                    "Confundir precisão com accuracy",
                                    "Ignorar outliers que indicam falta de robustez",
                                    "Análise sem testes estatísticos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Gerar relatório final e validar avaliação",
                                  "subSteps": [
                                    "Compilar relatório com executive summary, resultados, análises e recomendações.",
                                    "Validar com simulações adicionais ou peer review.",
                                    "Propor melhorias baseadas em design engineering (ex: trade-offs precisão vs. latência).",
                                    "Arquivar resultados para auditoria aeronáutica.",
                                    "Apresentar findings em formato profissional."
                                  ],
                                  "verification": "Relatório completo aprovado, com todas métricas acima de thresholds e recomendações acionáveis.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Templates de relatório LaTeX/Word",
                                    "Ferramentas de apresentação (PowerPoint)"
                                  ],
                                  "tips": "Inclua fotos do setup e gráficos para impacto visual.",
                                  "learningObjective": "Comunicar resultados de avaliação de forma clara e profissional.",
                                  "commonMistakes": [
                                    "Relatório vago sem dados quantitativos",
                                    "Omitir limitações do estudo",
                                    "Recomendações não viáveis industrialmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de fuselagens aeronáuticas, avalie um sistema de visão mecatrônico que detecta microfissuras em soldas: colete dados de 500 inspeções sob vibração simulada (50Hz), calcule precisão de 98%, latência <50ms e robustez >95% em baixa luz, recomendando upgrade de lente para otimizar.",
                              "finalVerifications": [
                                "Calcula precisão, latência e robustez com fórmulas corretas em dataset de teste.",
                                "Interpreta resultados contra benchmarks aeronáuticos com justificativa.",
                                "Identifica e mitiga pelo menos 3 gargalos comuns em ambientes industriais.",
                                "Gera relatório com visualizações e recomendações acionáveis.",
                                "Valida setup de teste replicando condições reais com erro <5%.",
                                "Aplica métodos DOE para análise estatística robusta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculo de métricas (>90% acurácia nos testes).",
                                "Qualidade do setup de teste e reprodutibilidade dos resultados.",
                                "Profundidade da análise estatística e visualizações claras.",
                                "Relevância das recomendações ao contexto aeronáutico industrial.",
                                "Completude do relatório com todos elementos obrigatórios.",
                                "Gestão de tempo e eficiência no processo completo."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Aeronáutica: Conformidade com normas de segurança FAA/EASA.",
                                "Inteligência Artificial: Algoritmos de visão computacional e ML.",
                                "Estatística e Probabilidade: Análise de dados e testes de hipótese.",
                                "Design de Experimentos: Otimização via DOE em engenharia.",
                                "Gestão de Projetos: Relatórios e validação em contextos industriais."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Boeing ou Embraer, esses sistemas avaliam qualidade em montagem automatizada de componentes, reduzindo defeitos em 30% e tempo de inspeção, garantindo conformidade regulatória e prevenindo falhas catastróficas em voo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Integração com Microcontroladores e CLPs",
                    "description": "Conexão de sistemas de visão com microprocessadores e controladores lógicos programáveis em projetos mecatrônicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Fundamentos de Conexão de Sistemas de Visão com Microcontroladores",
                        "description": "Princípios básicos para conectar câmeras e processadores de visão computacional a microcontroladores, incluindo seleção de hardware e configuração inicial em projetos mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Selecionar Microcontroladores Compatíveis",
                            "description": "Identificar e escolher microcontroladores como Arduino, ESP32 ou STM32 adequados para processar dados de sistemas de visão, considerando pinos GPIO, velocidade de clock e suporte a bibliotecas de imagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Requisitos do Sistema de Visão",
                                  "subSteps": [
                                    "Analise o tipo de câmera ou sensor de visão a ser usado (ex: OV7670, Raspberry Pi Camera).",
                                    "Liste os dados a processar (resolução, taxa de frames, processamento de imagem como detecção de bordas).",
                                    "Identifique restrições de energia, tamanho e ambiente de operação.",
                                    "Especifique necessidades de I/O: número de GPIOs para controle, interfaces como SPI/I2C para câmera.",
                                    "Documente velocidade mínima de clock necessária para processamento em tempo real."
                                  ],
                                  "verification": "Criar uma tabela de requisitos com pelo menos 5 itens chave documentados e revisados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha ou documento (Google Sheets/Excel)",
                                    "Datasheets de sensores de visão comuns"
                                  ],
                                  "tips": "Priorize requisitos críticos como latência para aplicações em tempo real.",
                                  "learningObjective": "Mapear necessidades do sistema de visão para specs de hardware.",
                                  "commonMistakes": [
                                    "Ignorar consumo de energia levando a superaquecimento",
                                    "Subestimar taxa de frames necessária"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar Especificações de Microcontroladores Comuns",
                                  "subSteps": [
                                    "Consulte datasheets oficiais de Arduino Uno/Nano, ESP32 e STM32 (ex: STM32F4 series).",
                                    "Registre clock speed (MHz), memória RAM/Flash, número de GPIOs e periféricos (SPI, I2C, UART).",
                                    "Verifique suporte a bibliotecas de imagem (ex: ESP32-CAM libs, Arduino ESP32 core, STM32 Cube).",
                                    "Anote suporte a aceleração de hardware como DMA ou FPU para processamento de imagem.",
                                    "Colete benchmarks de performance em tarefas de visão (ex: tempo de processamento de frame)."
                                  ],
                                  "verification": "Compilar uma tabela comparativa com specs de pelo menos 3 microcontroladores.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Datasheets oficiais (Arduino.cc, Espressif.com, ST.com)",
                                    "Navegador web para fóruns como Reddit/StackOverflow"
                                  ],
                                  "tips": "Use ferramentas como DigiKey ou Mouser para filtros rápidos de specs.",
                                  "learningObjective": "Extrair e organizar dados técnicos relevantes de fontes primárias.",
                                  "commonMistakes": [
                                    "Confundir clock speed com frequência efetiva de processamento",
                                    "Ignorar overhead de bibliotecas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Opções Baseado em Critérios Chave",
                                  "subSteps": [
                                    "Pontue cada microcontrolador em uma escala de 1-10 para GPIO count, clock speed e suporte a libs de imagem.",
                                    "Calcule pontuação ponderada considerando pesos (ex: 40% clock speed, 30% GPIOs, 30% libs).",
                                    "Avalie custo, disponibilidade e comunidade (ex: ESP32 tem WiFi integrado útil para visão remota).",
                                    "Simule cenários: teste compatibilidade com câmera via diagramas de pinout.",
                                    "Identifique trade-offs (ex: STM32 mais rápido mas curva de aprendizado maior)."
                                  ],
                                  "verification": "Gerar relatório de comparação com pontuações e trade-offs destacados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha de comparação",
                                    "Ferramentas de diagramação como Draw.io para pinouts"
                                  ],
                                  "tips": "Use matriz de decisão para visualização clara.",
                                  "learningObjective": "Aplicar análise quantitativa e qualitativa para seleção técnica.",
                                  "commonMistakes": [
                                    "Pontuação subjetiva sem pesos definidos",
                                    "Esquecer suporte futuro para upgrades"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e Justificar a Escolha Final",
                                  "subSteps": [
                                    "Escolha o top 1-2 microcontroladores baseado na comparação.",
                                    "Escreva justificativa detalhada ligando specs aos requisitos.",
                                    "Planeje protótipo inicial: liste pinagem sugerida e bibliotecas iniciais.",
                                    "Verifique compatibilidade com CLPs ou outros sistemas no contexto mecatrônico.",
                                    "Documente alternativas e razões de descarte."
                                  ],
                                  "verification": "Produzir documento final de seleção com justificativa e plano de protótipo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documento final (Word/Google Docs)",
                                    "Exemplos de projetos open-source no GitHub"
                                  ],
                                  "tips": "Sempre inclua plano B para contingências.",
                                  "learningObjective": "Sintetizar análise em decisão acionável e documentada.",
                                  "commonMistakes": [
                                    "Seleção sem justificativa mensurável",
                                    "Ignorar escalabilidade para projetos maiores"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de visão em um braço robótico detectando objetos (OV2640 camera, 320x240@30fps), selecione ESP32: 240MHz clock suporta processamento, 30+ GPIOs para câmera/SPI, libs como esp32-camera prontas, WiFi para envio de dados.",
                              "finalVerifications": [
                                "Tabela de requisitos mapeados corretamente aos specs do microcontrolador escolhido.",
                                "Comparação de pelo menos 3 opções com pontuações quantitativas.",
                                "Justificativa escrita cobrindo GPIO, clock e suporte a libs.",
                                "Diagrama de pinout preliminar viável.",
                                "Lista de trade-offs e alternativas consideradas.",
                                "Benchmark ou referência de performance confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de specs técnicas (GPIO, clock, libs).",
                                "Profundidade da comparação (mínimo 3 critérios ponderados).",
                                "Relevância da seleção aos requisitos de visão computacional.",
                                "Qualidade da documentação e justificativa.",
                                "Consideração de fatores práticos (custo, comunidade, escalabilidade).",
                                "Ausência de erros comuns em specs ou compatibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Leitura de datasheets e pinouts.",
                                "Programação: Avaliação de bibliotecas e APIs.",
                                "Matemática: Cálculos de pontuação ponderada e performance.",
                                "Gestão de Projetos: Tomada de decisão baseada em trade-offs.",
                                "Física: Considerações de energia e sinal para sensores."
                              ],
                              "realWorldApplication": "Em linhas de produção industriais, selecionar ESP32 para inspeção visual automatizada de peças, processando imagens em tempo real via câmeras conectadas por SPI, integrando com CLPs para controle de esteiras robóticas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Configurar Comunicação Serial UART",
                            "description": "Implementar comunicação UART entre câmera de visão (ex: OV7670) e microcontrolador para transmissão de frames de imagem, incluindo baud rate, paridade e tratamento de buffers.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Conectar Hardware para Comunicação UART",
                                  "subSteps": [
                                    "Identifique os pinos TX e RX da câmera OV7670 (ou módulo UART) e do microcontrolador (ex: ESP32 ou STM32).",
                                    "Conecte TX da câmera ao RX do microcontrolador e RX da câmera ao TX do microcontrolador.",
                                    "Adicione resistores pull-up se necessário e conecte GND comum.",
                                    "Alimente a câmera com 3.3V e verifique tensões com multímetro.",
                                    "Use osciloscópio ou logic analyzer para inspecionar sinais iniciais."
                                  ],
                                  "verification": "Conexões físicas confirmadas com multímetro (continuidade) e ausência de curtos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Câmera OV7670 ou módulo UART",
                                    "Microcontrolador (ex: ESP32)",
                                    "Jumpers, protoboard",
                                    "Multímetro",
                                    "Osciloscópio opcional"
                                  ],
                                  "tips": "Use fios curtos para minimizar ruído; prefira 3.3V logic levels para compatibilidade.",
                                  "learningObjective": "Entender pinagem e conexões seguras para UART entre câmera e MCU.",
                                  "commonMistakes": [
                                    "Inversão de TX/RX",
                                    "Diferentes níveis lógicos (5V vs 3.3V)",
                                    "Falta de GND comum"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Parâmetros UART no Microcontrolador",
                                  "subSteps": [
                                    "Selecione biblioteca UART (ex: HardwareSerial no Arduino/ESP32).",
                                    "Defina baud rate comum (ex: 115200), 8 bits de dados, sem paridade, 1 stop bit.",
                                    "Inicialize UART no código: Serial.begin(115200);",
                                    "Configure buffer de recepção com tamanho adequado (ex: 64KB para frames).",
                                    "Adicione interrupções para recepção eficiente."
                                  ],
                                  "verification": "Compile e upload do código; verifique mensagens de debug no monitor serial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE Arduino ou PlatformIO",
                                    "Cabo USB para programação",
                                    "Monitor serial"
                                  ],
                                  "tips": "Comece com baud rates baixos (9600) para testes iniciais e aumente gradualmente.",
                                  "learningObjective": "Configurar corretamente parâmetros UART para sincronia com câmera.",
                                  "commonMistakes": [
                                    "Baud rate mismatch",
                                    "Buffer pequeno causando overflow",
                                    "Não habilitar interrupções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Transmissão de Frames na Câmera OV7670",
                                  "subSteps": [
                                    "Configure OV7670 via SCCB/I2C para resolução (ex: QVGA 320x240) e formato (ex: RGB565).",
                                    "Ative modo de transmissão serial UART no firmware da câmera ou módulo.",
                                    "Defina baud rate idêntico ao MCU, com paridade none e headers para frames (ex: SOF/EOF).",
                                    "Teste captura de frame único e transmissão via UART.",
                                    "Ajuste timing de clock para estabilidade."
                                  ],
                                  "verification": "Sinais UART visíveis no osciloscópio com dados válidos em idle.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Biblioteca OV7670 (ex: para Arduino)",
                                    "Código de configuração SCCB"
                                  ],
                                  "tips": "Use exemplos de bibliotecas prontas para OV7670 UART; monitore corrente de alimentação.",
                                  "learningObjective": "Integrar configuração de câmera com protocolo UART para frames.",
                                  "commonMistakes": [
                                    "Configuração I2C errada",
                                    "Formato de frame incompatível",
                                    "Sem delimitadores de frame"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Tratamento de Buffers e Recepção no MCU",
                                  "subSteps": [
                                    "Crie buffer circular ou DMA para receber dados continuamente.",
                                    "Implemente parser para detectar headers (SOF), payload de imagem e EOF.",
                                    "Trate erros: checksum, timeout, overflow de buffer.",
                                    "Armazene frame recebido em array e processe (ex: tamanho verificado).",
                                    "Adicione callback para frame completo."
                                  ],
                                  "verification": "Frame recebido completo no monitor serial (ex: dump hex).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código fonte do MCU",
                                    "Logic analyzer para debug"
                                  ],
                                  "tips": "Use DMA se disponível para alta velocidade; teste com frames pequenos primeiro.",
                                  "learningObjective": "Gerenciar buffers eficientemente para transmissão de dados em tempo real.",
                                  "commonMistakes": [
                                    "Buffer overflow sem handling",
                                    "Parser falhando em sync",
                                    "Ignorar checksum"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Debugar Comunicação Completa",
                                  "subSteps": [
                                    "Execute captura e transmissão simultânea de múltiplos frames.",
                                    "Compare frames recebidos com esperados (ex: checksum ou visualização).",
                                    "Meça taxa de transferência e latência.",
                                    "Otimize baud rate e buffers para performance.",
                                    "Documente configurações finais."
                                  ],
                                  "verification": "100 frames transmitidos sem perda, visualizável em software (ex: Processing).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de visualização de imagem",
                                    "Logic analyzer"
                                  ],
                                  "tips": "Grave sinais UART para análise offline; use printf para debug.",
                                  "learningObjective": "Validar e otimizar sistema UART end-to-end.",
                                  "commonMistakes": [
                                    "Testes insuficientes em alta carga",
                                    "Ignorar jitter de timing"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure UART a 115200 baud entre OV7670 (QVGA RGB565) e ESP32 para transmitir 30 FPS; receba frames no ESP32, valide com checksum e exiba via WiFi em app mobile.",
                              "finalVerifications": [
                                "Frames de imagem transmitidos e recebidos sem perda de dados.",
                                "Baud rate e paridade sincronizados (sem garbage).",
                                "Buffers tratados corretamente (sem overflow).",
                                "Taxa de transferência sustentável (>10 FPS).",
                                "Sistema estável por 10 minutos contínuos.",
                                "Checksum válido em 99% dos frames."
                              ],
                              "assessmentCriteria": [
                                "Conexões hardware corretas e seguras.",
                                "Parâmetros UART idênticos em ambos os lados.",
                                "Implementação robusta de buffers e parser.",
                                "Tratamento completo de erros (timeout, parity).",
                                "Testes end-to-end com métricas quantificáveis.",
                                "Código limpo e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Protocolos seriais e pinagem.",
                                "Programação Embarcada: Interrupções e DMA.",
                                "Processamento de Sinais: Compressão e headers de frames.",
                                "Redes de Computadores: Protocolos assíncronos.",
                                "Sistemas Embarcados: Integração sensor-MCU."
                              ],
                              "realWorldApplication": "Em robôs autônomos para transmissão de vídeo de câmeras a controladores centrais, drones para streaming FPV, ou inspeção industrial com visão embarcada."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Processar Dados de Visão em Tempo Real",
                            "description": "Desenvolver código para extrair features simples (ex: detecção de bordas) de imagens recebidas e enviar comandos de controle ao microcontrolador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Captura de Imagens em Tempo Real",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias como OpenCV para Python.",
                                    "Configurar câmera ou stream de vídeo como fonte de entrada.",
                                    "Implementar loop principal para captura contínua de frames.",
                                    "Adicionar controle de FPS para processamento em tempo real.",
                                    "Testar captura básica exibindo frames em uma janela."
                                  ],
                                  "verification": "Frames são capturados e exibidos em tempo real sem atrasos significativos (FPS > 15).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "OpenCV (cv2)",
                                    "Câmera USB ou webcam",
                                    "IDE como VS Code ou Jupyter Notebook"
                                  ],
                                  "tips": "Use cv2.VideoCapture(0) para webcam padrão; ajuste resolução para otimizar performance.",
                                  "learningObjective": "Configurar um pipeline de captura de vídeo em tempo real usando OpenCV.",
                                  "commonMistakes": [
                                    "Não liberar a câmera após uso (causa vazamento de memória)",
                                    "Ignorar verificação de frame válido",
                                    "Resolução alta causando lag"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Extração de Features Simples (Detecção de Bordas)",
                                  "subSteps": [
                                    "Converter frame para escala de cinza.",
                                    "Aplicar filtro Gaussiano para redução de ruído.",
                                    "Usar detector de bordas Canny com thresholds ajustáveis.",
                                    "Armazenar imagem de bordas resultante para processamento posterior.",
                                    "Visualizar bordas sobrepostas no frame original para depuração."
                                  ],
                                  "verification": "Bordas são detectadas corretamente em objetos de teste, como linhas ou formas geométricas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "OpenCV",
                                    "Imagens de teste com bordas conhecidas (ex: linhas pretas em fundo branco)"
                                  ],
                                  "tips": "Ajuste thresholds do Canny (50, 150) baseado no ambiente de iluminação.",
                                  "learningObjective": "Extrair features de bordas de frames de vídeo usando algoritmos de processamento de imagem.",
                                  "commonMistakes": [
                                    "Thresholds fixos inadequados para diferentes luzes",
                                    "Pular filtro Gaussiano causando bordas falsas",
                                    "Não converter para grayscale"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar Features Extraídas para Decisões de Controle",
                                  "subSteps": [
                                    "Detectar linhas ou contornos principais nas bordas usando HoughLines ou findContours.",
                                    "Calcular métricas simples como posição central ou ângulo da linha detectada.",
                                    "Definir lógica de decisão: ex. se linha à esquerda, comando 'direita'.",
                                    "Criar variáveis de estado para comandos de controle baseados nas métricas.",
                                    "Otimizar processamento para manter tempo real (máx 50ms por frame)."
                                  ],
                                  "verification": "Métricas de posição/ângulo são calculadas corretamente e mapeadas para comandos lógicos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "OpenCV funções HoughLinesP e findContours",
                                    "Exemplos de vídeo com linhas/objetos móveis"
                                  ],
                                  "tips": "Use ROI (Region of Interest) para focar processamento em área relevante da imagem.",
                                  "learningObjective": "Transformar dados de visão em sinais de controle acionáveis.",
                                  "commonMistakes": [
                                    "Processamento lento devido a operações desnecessárias em toda imagem",
                                    "Lógica de decisão rígida sem thresholds de confiança",
                                    "Ignorar frames vazios"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Envio de Comandos ao Microcontrolador",
                                  "subSteps": [
                                    "Configurar comunicação serial ou socket com microcontrolador (ex: Arduino via USB).",
                                    "Mapear comandos processados para strings ou bytes (ex: 'L' para esquerda).",
                                    "Implementar envio no loop principal após processamento de cada frame.",
                                    "Adicionar debounce ou filtro para evitar comandos erráticos.",
                                    "Testar loop fechado com microcontrolador respondendo a comandos."
                                  ],
                                  "verification": "Comandos são enviados corretamente e microcontrolador responde (ex: LED pisca ou motor move).",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Microcontrolador como Arduino/ESP32",
                                    "Cabo USB/serial",
                                    "Biblioteca pyserial para Python"
                                  ],
                                  "tips": "Use try-except para lidar com falhas de comunicação; envie comandos a cada N frames para estabilidade.",
                                  "learningObjective": "Integrar processamento de visão com hardware de controle em tempo real.",
                                  "commonMistakes": [
                                    "Taxa de envio muito alta sobrecarregando serial",
                                    "Não flush buffer serial",
                                    "Formato de comando incompatível com firmware do MC"
                                  ]
                                }
                              ],
                              "practicalExample": "Implementar um seguidor de linha: câmera detecta bordas de uma linha preta em pista branca, calcula posição da linha no frame, e envia comandos 'F' (frente), 'L' (esquerda) ou 'R' (direita) para um robô com Arduino controlar motores.",
                              "finalVerifications": [
                                "Sistema processa >20 FPS em tempo real sem travamentos.",
                                "Detecção de bordas identifica features corretamente em 90% dos frames de teste.",
                                "Comandos são enviados e microcontrolador responde consistentemente.",
                                "Loop completo mantém sincronia entre visão e controle.",
                                "Sistema ignora ruído e mantém estabilidade em condições variáveis de luz.",
                                "Memória e CPU não excedem 70% durante execução prolongada."
                              ],
                              "assessmentCriteria": [
                                "Precisão da detecção de bordas (>85% em testes padronizados).",
                                "Latência total do pipeline (<100ms por frame).",
                                "Robustez a variações de iluminação e ruído.",
                                "Correção da lógica de mapeamento features -> comandos.",
                                "Eficiência de comunicação com microcontrolador (sem perdas).",
                                "Qualidade do código: modular, comentado e otimizado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos de visão computacional em Python.",
                                "Eletrônica: Protocolos de comunicação serial/I2C com microcontroladores.",
                                "Matemática: Processamento de imagens com filtros e transformadas (ex: Hough).",
                                "Física: Cinemática de robôs e controle PID básico.",
                                "Engenharia de Software: Otimização de performance em tempo real."
                              ],
                              "realWorldApplication": "Em robótica industrial para inspeção visual automatizada, como detecção de defeitos em linhas de produção, ou em veículos autônomos para seguimento de faixas e navegação reativa."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Protocolos e Interfaces para Integração",
                        "description": "Protocolos de comunicação comuns usados para integrar sistemas de visão com microcontroladores e CLPs, como I2C, SPI e Ethernet.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Implementar Protocolo I2C/SPI",
                            "description": "Configurar interfaces I2C ou SPI para troca de dados entre sensores de visão e microcontroladores, incluindo master-slave e gerenciamento de interrupções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de I2C e SPI",
                                  "subSteps": [
                                    "Estude as diferenças entre I2C (2 fios: SDA, SCL; multi-slave) e SPI (4 fios: MOSI, MISO, SCK, CS; full-duplex).",
                                    "Revise conceitos de master-slave, clock, endereços I2C e modos SPI (CPOL/CPHA).",
                                    "Analise pinouts de microcontroladores (ex: Arduino/ESP32) e sensores de visão (ex: OV7670 para SPI).",
                                    "Identifique requisitos para sensores de visão: baud rate, interrupções para dados prontos.",
                                    "Desenhe diagramas de conexão para ambos protocolos."
                                  ],
                                  "verification": "Crie um diagrama comparativo de I2C vs SPI e liste 3 vantagens/desvantagens cada.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Datasheets de Arduino/ESP32 e sensor OV7670 ou similar",
                                    "Papel e caneta ou software de diagrama (Draw.io)"
                                  ],
                                  "tips": "Comece com I2C para simplicidade em sensores de visão; SPI é mais rápido para câmeras.",
                                  "learningObjective": "Diferenciar e selecionar protocolo adequado para integração de sensores de visão.",
                                  "commonMistakes": [
                                    "Confundir pinos I2C com SPI",
                                    "Ignorar pull-up resistors em I2C",
                                    "Não considerar clock stretching em I2C"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Hardware e Conexões",
                                  "subSteps": [
                                    "Monte breadboard com microcontrolador (master) e sensor de visão (slave).",
                                    "Conecte fios para I2C: VCC, GND, SDA (A4 Arduino), SCL (A5 Arduino); adicione pull-ups 4.7kΩ.",
                                    "Para SPI: conecte MOSI (11), MISO (12), SCK (13), CS (10); verifique níveis lógicos (3.3V/5V).",
                                    "Alimente componentes e meça tensões com multímetro.",
                                    "Teste continuidade e configure jumpers se necessário."
                                  ],
                                  "verification": "Use multímetro para confirmar continuidade e tensões estáveis (3.3V/5V).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Breadboard",
                                    "Fios jumper",
                                    "Arduino/ESP32",
                                    "Sensor de visão com I2C/SPI (ex: VL53L1X ou OV7670)",
                                    "Resistores pull-up 4.7kΩ",
                                    "Multímetro"
                                  ],
                                  "tips": "Sempre use conversor de nível lógico se 5V e 3.3V misturados para evitar danos.",
                                  "learningObjective": "Realizar conexões seguras e funcionais para comunicação serial.",
                                  "commonMistakes": [
                                    "Pinos errados",
                                    "Falta de pull-ups em I2C",
                                    "Polaridade invertida de alimentação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Código no Master (Microcontrolador)",
                                  "subSteps": [
                                    "Instale bibliotecas Wire (I2C) ou SPI no Arduino IDE.",
                                    "Escreva sketch para inicializar interface: Wire.begin() ou SPI.begin().",
                                    "Implemente leitura/escrita: para I2C Wire.write/register; para SPI SPI.transfer().",
                                    "Configure endereço slave (I2C scan) ou CS pin (SPI).",
                                    "Adicione loop para ler dados do sensor de visão continuamente."
                                  ],
                                  "verification": "Compile e upload código; monitore Serial.print de dados recebidos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Arduino IDE",
                                    "Computador com USB",
                                    "Cabo USB"
                                  ],
                                  "tips": "Use scanner I2C primeiro para confirmar endereço do sensor.",
                                  "learningObjective": "Programar master para iniciar e gerenciar troca de dados com slave.",
                                  "commonMistakes": [
                                    "Não chamar begin()",
                                    "Endereço I2C errado (7-bit vs 8-bit)",
                                    "Clock speed muito alto causando falhas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Slave e Gerenciar Interrupções",
                                  "subSteps": [
                                    "Configure sensor como slave ou use segundo MC como slave simulando sensor.",
                                    "Implemente ISR (Interrupt Service Routine) para sinal de dados prontos do sensor.",
                                    "No master, configure pin de interrupção (attachInterrupt) ligado a INT do sensor.",
                                    "Sincronize leitura via interrupção em vez de polling.",
                                    "Otimize buffer para frames de imagem de visão."
                                  ],
                                  "verification": "Trigger interrupção manualmente e confirme callback via Serial.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Bibliotecas específicas do sensor (ex: Adafruit para VL53)",
                                    "Osciloscópio lógico opcional"
                                  ],
                                  "tips": "Use FALLING edge para interrupções; debounce se necessário.",
                                  "learningObjective": "Integrar interrupções para comunicação eficiente e em tempo real.",
                                  "commonMistakes": [
                                    "ISR muito longa bloqueando loop",
                                    "Pinos de interrupção errados",
                                    "Não habilitar global interrupts"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Depurar e Validar Integração",
                                  "subSteps": [
                                    "Execute comunicação full-duplex e valide dados (ex: valores de imagem).",
                                    "Use Serial Plotter ou LCD para visualizar dados em tempo real.",
                                    "Depure com oscilloscope lógico ou printf-style logs.",
                                    "Teste cenários de falha: desconectar slave, alta taxa de dados.",
                                    "Documente configuração final e performance (taxa de transferência)."
                                  ],
                                  "verification": "Troca de dados estável por 10min sem erros; throughput > 100kB/s em SPI.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Serial monitor",
                                    "Logic analyzer (opcional)"
                                  ],
                                  "tips": "Aumente clock gradualmente; monitore temperatura de chips.",
                                  "learningObjective": "Garantir robustez da integração para aplicações mecatrônicas.",
                                  "commonMistakes": [
                                    "Não testar multi-slave",
                                    "Ignorar EMI/ruído em fios longos",
                                    "Buffer overflow"
                                  ]
                                }
                              ],
                              "practicalExample": "Conecte um sensor de distância VL53L1X (I2C) ou câmera OV7670 (SPI) a um ESP32. O master lê frames de imagem via interrupção, processa detecção de bordas e envia via WiFi para monitoramento remoto em robô autônomo.",
                              "finalVerifications": [
                                "Comunicação I2C/SPI estabelecida sem erros de ACK/NAK.",
                                "Dados do sensor de visão lidos corretamente (ex: valores RGB ou distâncias).",
                                "Interrupções triggeram leituras em <1ms.",
                                "Sistema opera estável por 30min com carga variável.",
                                "Throughput atende specs do sensor (>1Mbps em SPI).",
                                "Nenhuma perda de dados em buffer cheio."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração hardware (sem curtos ou conexões erradas).",
                                "Código funcional, legível e comentado.",
                                "Uso correto de interrupções vs polling.",
                                "Tratamento de erros (timeouts, retries).",
                                "Documentação de testes e métricas de performance.",
                                "Seleção adequada de protocolo baseada em requisitos."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Análise de sinais seriais.",
                                "Programação Embarcada: Bibliotecas HAL e RTOS basics.",
                                "Processamento de Sinais: Filtragem de dados de visão.",
                                "Redes Industriais: Comparação com Modbus/Ethernet.",
                                "Projeto Mecatrônico: Integração em sistemas de controle."
                              ],
                              "realWorldApplication": "Em linhas de montagem automatizadas, onde câmeras de visão conectadas via SPI/I2C a PLCs/microcontroladores detectam defeitos em produtos em tempo real, acionando atuadores para correção."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Utilizar Ethernet/IP para Redes Industriais",
                            "description": "Estabelecer comunicação Ethernet/IP entre sistema de visão e dispositivos, simulando ambientes industriais com bibliotecas como Socket ou Modbus TCP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Protocolo Ethernet/IP",
                                  "subSteps": [
                                    "Estude a arquitetura CIP (Common Industrial Protocol) e como ela opera sobre Ethernet.",
                                    "Identifique as diferenças entre Ethernet/IP e protocolos como Modbus TCP.",
                                    "Revise conceitos de rede industrial: IP addressing, portas (44818 para Ethernet/IP), e mensagens explícitas/implícitas.",
                                    "Analise exemplos de pacotes Ethernet/IP usando Wireshark.",
                                    "Documente os componentes chave: Originator e Target."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes e fluxo de Ethernet/IP, confirmando com uma checklist de conceitos chave.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação oficial ODVA Ethernet/IP",
                                    "Wireshark instalado",
                                    "Tutoriais online sobre CIP"
                                  ],
                                  "tips": "Use Wireshark para capturar tráfego real de exemplos públicos para visualização prática.",
                                  "learningObjective": "Dominar os princípios teóricos do Ethernet/IP para aplicação em simulações industriais.",
                                  "commonMistakes": [
                                    "Confundir Ethernet/IP com Modbus TCP",
                                    "Ignorar distinção entre mensagens explícitas e implícitas",
                                    "Subestimar requisitos de rede determinística"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Ambiente de Simulação",
                                  "subSteps": [
                                    "Instale bibliotecas Python como pycomm3 ou socket para simulação de Ethernet/IP.",
                                    "Configure IPs estáticos em máquinas virtuais ou Raspberry Pi simulando PLC e sistema de visão.",
                                    "Instale e configure um simulador de PLC como PLC Simulator ou Node-OPCUA com suporte Ethernet/IP.",
                                    "Teste conectividade básica com ping e telnet na porta 44818.",
                                    "Prepare scripts iniciais para servidor e cliente Ethernet/IP."
                                  ],
                                  "verification": "Execute ping e telnet bem-sucedidos entre dispositivos simulados; liste configurações de rede.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: pycomm3, pip install pycomm3",
                                    "VirtualBox ou Raspberry Pi",
                                    "PLC Simulator software"
                                  ],
                                  "tips": "Use VMs para isolar redes industriais e evitar conflitos com rede local.",
                                  "learningObjective": "Preparar um ambiente funcional para testes de comunicação Ethernet/IP.",
                                  "commonMistakes": [
                                    "IPs dinâmicos causando falhas",
                                    "Portas bloqueadas por firewall",
                                    "Versões incompatíveis de bibliotecas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Comunicação Ethernet/IP entre Sistema de Visão e Dispositivos",
                                  "subSteps": [
                                    "Desenvolva um cliente Ethernet/IP no sistema de visão (ex: Python com OpenCV) para enviar dados de imagem processada.",
                                    "Crie um servidor no dispositivo simulado (PLC) para receber e processar comandos via sockets TCP/UDP.",
                                    "Implemente mensagens explícitas para leitura/escrita de tags (ex: posição de objeto detectado).",
                                    "Integre com visão: capture frame, processe (ex: detecção de bordas), envie via Ethernet/IP.",
                                    "Adicione autenticação básica e timeouts para robustez."
                                  ],
                                  "verification": "Execute script e confirme troca de dados bidirecional via logs e Wireshark.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Código Python exemplo de pycomm3",
                                    "OpenCV para visão",
                                    "Wireshark para monitoramento"
                                  ],
                                  "tips": "Comece com mensagens simples como 'ping' antes de dados complexos de visão.",
                                  "learningObjective": "Estabelecer comunicação funcional simulando cenários industriais reais.",
                                  "commonMistakes": [
                                    "Endianness incorreto em dados",
                                    "Tamanhos de buffer inadequados",
                                    "Falta de handling de erros de conexão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Otimizar a Comunicação",
                                  "subSteps": [
                                    "Simule falhas de rede e verifique recuperação automática.",
                                    "Meça latência e throughput com múltiplas trocas de dados de visão.",
                                    "Otimize para tempo real: reduza payloads e use conexões persistentes.",
                                    "Integre logging e alertas para erros comuns.",
                                    "Valide em cenário completo: visão detecta defeito e PLC aciona resposta."
                                  ],
                                  "verification": "Relatório de testes mostrando 100% sucesso em 100 iterações, latência <50ms.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Scripts de teste automatizados",
                                    "Ferramentas de profiling como timeit",
                                    "Logs de Wireshark"
                                  ],
                                  "tips": "Use multiprocessamento para simular carga industrial alta.",
                                  "learningObjective": "Garantir confiabilidade e performance da integração Ethernet/IP.",
                                  "commonMistakes": [
                                    "Ignorar jitter de rede",
                                    "Sobrecarga de CPU em processamento de visão",
                                    "Falta de validação de checksums"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Integrar em Projeto Mecatrônico Maior",
                                  "subSteps": [
                                    "Crie documentação: diagramas de rede, API de tags, scripts comentados.",
                                    "Integre com microcontrolador (ex: ESP32) ou CLP real via Ethernet/IP.",
                                    "Teste em loop fechado: visão -> Ethernet/IP -> CLP -> atuador.",
                                    "Prepare para escalabilidade: múltiplos dispositivos.",
                                    "Revise e refine baseado em feedback simulado."
                                  ],
                                  "verification": "Documentação completa e demo funcional em vídeo ou relatório.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de diagrama como Draw.io",
                                    "Git para versionamento"
                                  ],
                                  "tips": "Padronize nomes de tags conforme convenções industriais (ex: PLC.Tags.Vision.Data).",
                                  "learningObjective": "Consolidar conhecimento em um módulo reutilizável para projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Documentação incompleta",
                                    "Falta de modularidade no código",
                                    "Integração sem testes de regressão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem simulada, o sistema de visão (câmera com OpenCV) detecta a posição de uma peça defeituosa e envia coordenadas via Ethernet/IP para um PLC simulado, que aciona um braço robótico para remoção. Use pycomm3 para o cliente visão escrever tag 'Defeito_PosX' no PLC.",
                              "finalVerifications": [
                                "Comunicação bidirecional estabelecida sem perda de pacotes em 100 trocas.",
                                "Dados de visão processados e transmitidos corretamente (ex: coordenadas precisas).",
                                "Latência média abaixo de 50ms em ambiente simulado.",
                                "Recuperação automática de desconexões em menos de 5 segundos.",
                                "Logs mostram ausência de erros CIP ou timeouts.",
                                "Integração com CLP/microcontrolador funcional em loop fechado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação de mensagens Ethernet/IP (100% conformidade com spec).",
                                "Robustez: handling de erros e falhas de rede.",
                                "Performance: throughput e latência adequados para industrial (<100ms).",
                                "Clareza do código: modular, comentado e documentado.",
                                "Validação prática: sucesso em cenários simulados reais.",
                                "Escalabilidade: suporte a múltiplos dispositivos."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos TCP/UDP e análise de pacotes.",
                                "Programação: Python avançado, sockets e bibliotecas industriais.",
                                "Automação Industrial: Integração com CLPs e protocolos como OPC-UA.",
                                "Visão Computacional: Processamento de imagens em tempo real.",
                                "Eletrônica: Configuração de redes em microcontroladores."
                              ],
                              "realWorldApplication": "Em indústrias automotivas ou farmacêuticas, integra sistemas de visão para inspeção de qualidade com CLPs via Ethernet/IP, permitindo monitoramento em tempo real, redução de defeitos e automação de linhas de produção sem interrupções."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Gerenciar Latência em Transmissões",
                            "description": "Otimizar protocolos para minimizar latência na transmissão de dados de visão, utilizando timestamps e buffers FIFO em microcontroladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Latência em Transmissões de Dados de Visão",
                                  "subSteps": [
                                    "Estude os componentes da latência: processamento de imagem, transmissão e recepção.",
                                    "Analise impactos da latência em sistemas de visão por computador em tempo real.",
                                    "Identifique fontes comuns de latência em microcontroladores (ex.: interrupções, overhead de protocolo).",
                                    "Revise protocolos básicos como UART, SPI e I2C para transmissão de dados de visão.",
                                    "Calcule latência teórica usando fórmulas: latência_total = tempo_processamento + tempo_transmissão + jitter."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes de latência e calcule exemplo prático com valores numéricos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de microcontroladores (ex.: STM32 ou ESP32)",
                                    "Artigos sobre latência em visão computacional",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Use osciloscópio virtual (ex.: Tinkercad) para visualizar latência em simulações iniciais.",
                                  "learningObjective": "Identificar e quantificar fontes de latência em transmissões de dados de visão.",
                                  "commonMistakes": [
                                    "Ignorar jitter de rede",
                                    "Confundir latência com throughput",
                                    "Subestimar overhead de protocolos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Timestamps para Sincronização Temporal",
                                  "subSteps": [
                                    "Configure um timer de alta resolução no microcontrolador para gerar timestamps precisos.",
                                    "Inclua timestamp no cabeçalho de cada frame de dados de visão (ex.: 32-bit UNIX timestamp).",
                                    "Sincronize relógios entre câmera/microcontrolador e receptor via protocolo NTP simplificado.",
                                    "Adicione checksum ao pacote para validar integridade do timestamp.",
                                    "Teste em loopback: envie e receba dados medindo drift temporal."
                                  ],
                                  "verification": "Registre 100 pacotes e verifique que drift de timestamp < 1ms em 95% dos casos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Microcontrolador com timer (ex.: Arduino Nano ou STM32)",
                                    "Câmera OV7670 ou similar",
                                    "IDE como Arduino IDE ou STM32CubeIDE"
                                  ],
                                  "tips": "Use interrupções de timer para evitar bloqueio no loop principal.",
                                  "learningObjective": "Incorporar timestamps precisos para compensar latência variável em transmissões.",
                                  "commonMistakes": [
                                    "Overflow de timestamp sem reset",
                                    "Falta de sincronização inicial",
                                    "Ignorar precisão do clock do microcontrolador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Buffers FIFO para Gerenciamento de Dados",
                                  "subSteps": [
                                    "Implemente uma fila FIFO circular no microcontrolador usando arrays ou bibliotecas prontas.",
                                    "Defina tamanho do buffer baseado em taxa de frames (ex.: 10 frames para 30 FPS).",
                                    "Configure interrupções para push/pop: enfileirar dados da câmera, desenfileirar para transmissão.",
                                    "Adicione flags de overflow/underflow com recuperação automática (descartar frames antigos).",
                                    "Otimize leitura/escrita com DMA se disponível no hardware."
                                  ],
                                  "verification": "Simule carga alta e confirme zero perdas de frames com buffer de 256 bytes.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Biblioteca FreeRTOS ou implementação manual de FIFO",
                                    "Osciloscópio lógico (ex.: Saleae Logic)",
                                    "Código-fonte de exemplo para DMA"
                                  ],
                                  "tips": "Monitore taxa de fill do buffer via serial para debug.",
                                  "learningObjective": "Usar buffers FIFO para suavizar bursts de dados de visão e reduzir latência efetiva.",
                                  "commonMistakes": [
                                    "Buffer muito pequeno causando perdas",
                                    "Race conditions sem mutex",
                                    "Não limpar buffer em inicialização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar Protocolo de Transmissão e Integrar Componentes",
                                  "subSteps": [
                                    "Combine timestamps e FIFO em um protocolo customizado: header (timestamp + seq) + payload + checksum.",
                                    "Ajuste baud rate e priorize pacotes críticos via QoS simples.",
                                    "Integre com CLP via Modbus ou Ethernet/IP para transmissão downstream.",
                                    "Aplique compressão básica (ex.: downsampling de frames) se latência persistir.",
                                    "Compile e flash o firmware no microcontrolador."
                                  ],
                                  "verification": "Transmita stream contínuo de 10min e meça latência end-to-end < 50ms.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "CLP simulado (ex.: PLC Simulator)",
                                    "Ferramentas de profiling como perf ou serial plotter"
                                  ],
                                  "tips": "Use perfis de energia para reduzir latência em modos sleep.",
                                  "learningObjective": "Criar protocolo otimizado integrando timestamps e FIFO para baixa latência.",
                                  "commonMistakes": [
                                    "Header muito grande inflando pacotes",
                                    "Sem retry em falhas de checksum",
                                    "Incompatibilidade de endianness"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Medir e Refinar o Sistema",
                                  "subSteps": [
                                    "Meça latência com ferramentas: tempo entre captura e recepção via high-res timer.",
                                    "Simule cenários de estresse: alta taxa de frames, ruído, perda de pacotes.",
                                    "Compare before/after: reduza latência em pelo menos 40%.",
                                    "Documente métricas e ajuste parâmetros (ex.: buffer size).",
                                    "Valide em hardware real com visão ativa (ex.: detecção de objeto)."
                                  ],
                                  "verification": "Relatório com gráficos de latência média, max e jitter; todos < thresholds definidos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Cronômetro de precisão ou Wireshark para serial",
                                    "Câmera real e atuador para demo"
                                  ],
                                  "tips": "Automatize testes com scripts Python para estatísticas.",
                                  "learningObjective": "Avaliar e iterar otimizações para desempenho em tempo real.",
                                  "commonMistakes": [
                                    "Testes só em idle",
                                    "Ignorar latência de software no receptor",
                                    "Sem baseline inicial"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de inspeção industrial, uma câmera em um microcontrolador STM32 captura imagens de peças em linha de montagem. Usando timestamps e FIFO, os dados são transmitidos para um CLP com latência <30ms, permitindo parada imediata de defeitos detectados sem atrasos.",
                              "finalVerifications": [
                                "Latência end-to-end média abaixo de 50ms em stream de 20 FPS.",
                                "Zero perdas de frames em buffer sob carga máxima por 5 minutos.",
                                "Drift de timestamp <2ms após 1 hora de operação.",
                                "Checksum falha detectada e recuperada em 100% dos casos simulados.",
                                "Sistema resiste a jitter de 10ms sem perda de sincronia.",
                                "Integração com CLP confirmada via Modbus poll bem-sucedido."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta de timestamps com precisão de microssegundos.",
                                "Buffer FIFO funcional sem overflows/underflows em testes de estresse.",
                                "Redução mensurável de latência (pelo menos 30% vs baseline).",
                                "Código limpo, comentado e modular.",
                                "Relatório de testes com métricas quantitativas e gráficos.",
                                "Demonstração prática em hardware real."
                              ],
                              "crossCurricularConnections": [
                                "Programação Embarcada: Uso de interrupções e DMA.",
                                "Redes e Comunicação: Protocolos serial e QoS.",
                                "Processamento de Sinais: Compressão e sincronização temporal.",
                                "Controle Automático: Integração com CLPs em malhas de feedback.",
                                "Análise de Dados: Estatísticas de latência e profiling."
                              ],
                              "realWorldApplication": "Em robôs autônomos para manufatura, veículos semiautônomos ou drones de vigilância, onde baixa latência em dados de visão garante respostas seguras e precisas, evitando colisões ou falhas em inspeções de alta velocidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Integração com CLPs em Projetos Mecatrônicos",
                        "description": "Estratégias para conectar sistemas de visão a Controladores Lógicos Programáveis (CLPs) em aplicações industriais, incluindo programação ladder e validação de sistemas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Programar CLPs com Dados de Visão",
                            "description": "Integrar sinais de visão em lógica ladder de CLPs (ex: Siemens S7 ou Allen-Bradley), mapeando detecções para atuadores mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Comunicação entre Sistema de Visão e CLP",
                                  "subSteps": [
                                    "Instalar drivers e protocolos necessários (ex: OPC UA, Modbus TCP para Siemens S7 ou Allen-Bradley).",
                                    "Configurar IP e portas no sistema de visão (ex: câmera com software Cognex ou Keyence).",
                                    "Estabelecer conexão teste enviando um sinal simples do visão para CLP.",
                                    "Verificar logs de comunicação em ambos os lados.",
                                    "Ajustar timeouts e buffers para estabilidade."
                                  ],
                                  "verification": "Conexão bem-sucedida: ping ou handshake confirmado no software do CLP (TIA Portal ou Studio 5000).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "CLP (Siemens S7-1200 ou AB MicroLogix), PC com TIA Portal/Studio 5000, Câmera de visão industrial, Cabos Ethernet"
                                  ],
                                  "tips": "Use ferramentas como Wireshark para monitorar pacotes de rede durante testes iniciais.",
                                  "learningObjective": "Entender e implementar protocolos de comunicação industrial para integração visão-CLP.",
                                  "commonMistakes": [
                                    "IPs conflitantes",
                                    "Firewalls bloqueando portas",
                                    "Versões incompatíveis de protocolos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Dados de Detecção de Visão para Variáveis do CLP",
                                  "subSteps": [
                                    "Identificar saídas do sistema de visão (ex: posição X/Y, presença de objeto, código QR lido).",
                                    "Criar tags/variáveis no CLP correspondentes (BOOL para detecção, REAL para coordenadas).",
                                    "Configurar mapeamento no software de visão para enviar dados via protocolo escolhido.",
                                    "Testar envio de dados simulados do visão para tags do CLP.",
                                    "Definir escalas e unidades (ex: pixels para mm)."
                                  ],
                                  "verification": "Tags no CLP atualizam em tempo real com dados simulados do visão (monitor de watch no TIA/Studio).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de visão (VisionPro ou In-Sight Explorer), Documentação de tags do CLP"
                                  ],
                                  "tips": "Padronize nomes de variáveis com prefixos como 'Vision_DetectObj1' para clareza.",
                                  "learningObjective": "Mapear sinais analógicos/digitais de visão para estrutura de dados do CLP.",
                                  "commonMistakes": [
                                    "Tipos de dados incompatíveis (INT vs REAL)",
                                    "Falta de sincronização de amostragem",
                                    "Ignorar ranges de valores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Programar Lógica Ladder no CLP Usando Dados de Visão",
                                  "subSteps": [
                                    "Criar rede ladder inicial com inputs de visão (ex: se DetectObj=TRUE, ativar atuador).",
                                    "Adicionar timers e counters baseados em coordenadas (ex: delay se posição > threshold).",
                                    "Implementar lógica de segurança (ex: reset se perda de visão).",
                                    "Usar blocos de função para processamento avançado (ex: PID para posicionamento).",
                                    "Compilar e fazer download para o CLP."
                                  ],
                                  "verification": "Simulação no software do CLP mostra ativação correta de outputs com inputs de visão mockados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "TIA Portal ou Studio 5000, Exemplos de ladder logic para visão"
                                  ],
                                  "tips": "Use scan time optimization: coloque lógica crítica de visão no topo do programa.",
                                  "learningObjective": "Desenvolver lógica ladder que responde dinamicamente a dados de visão computacional.",
                                  "commonMistakes": [
                                    "Loops infinitos em ladders",
                                    "Falta de debounce em sinais digitais",
                                    "Sobrecarga de CPU por polling excessivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Depurar Integração Visão-CLP-Atuadores",
                                  "subSteps": [
                                    "Montar setup físico: câmera → CLP → atuador (ex: esteira com cilindro pneumático).",
                                    "Executar testes unitários: detecção → ação.",
                                    "Medir latência total (visão a atuador) com osciloscópio ou HMI.",
                                    "Depurar falhas: usar force tables e breakpoints no CLP.",
                                    "Registrar anomalias e ajustes em log."
                                  ],
                                  "verification": "Atuador responde corretamente a 95% das detecções em 10 ciclos reais.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Atuadores mecatrônicos (servo, relê), HMI para monitoramento, Multímetro"
                                  ],
                                  "tips": "Teste em velocidades reais de produção para capturar latências ocultas.",
                                  "learningObjective": "Validar integração end-to-end com depuração sistemática.",
                                  "commonMistakes": [
                                    "Testes só em simulação",
                                    "Ignorar ruído ambiental na visão",
                                    "Falta de testes de falha"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar, Documentar e Validar o Sistema",
                                  "subSteps": [
                                    "Otimizar código ladder para reduzir ciclo de scan.",
                                    "Adicionar HMI para visualização de dados de visão.",
                                    "Documentar mapeamento, lógica e parâmetros.",
                                    "Realizar validação final com cenários edge-case.",
                                    "Backup do projeto e exportar relatórios."
                                  ],
                                  "verification": "Sistema opera estável por 30min contínuos; documentação cobre 100% dos componentes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Template de documentação, Ferramentas de backup do CLP"
                                  ],
                                  "tips": "Use version control no software do CLP para rastrear mudanças.",
                                  "learningObjective": "Garantir robustez, manutenibilidade e conformidade industrial.",
                                  "commonMistakes": [
                                    "Otimização prematura sem testes",
                                    "Documentação incompleta",
                                    "Falta de backups"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem, a câmera detecta a presença e posição de uma peça defeituosa (ex: coordenadas X=150mm, Y=200mm). O CLP recebe esses dados via OPC UA, ativa um braço robótico para remover a peça se X>100mm, e para a esteira por 2s via timer ladder.",
                              "finalVerifications": [
                                "CLP recebe e processa dados de visão sem perda de pacotes (>99% uptime).",
                                "Lógica ladder ativa atuadores corretamente em <500ms de latência.",
                                "Sistema lida com falhas de visão (ex: timeout reseta outputs).",
                                "HMI exibe status real-time de detecções e ações.",
                                "Testes de estresse com 100 ciclos confirmam estabilidade.",
                                "Documentação permite replicação por terceiro."
                              ],
                              "assessmentCriteria": [
                                "Precisão do mapeamento de dados: 100% correspondência visão-CLP.",
                                "Eficiência da lógica ladder: ciclo de scan <50ms.",
                                "Robustez a falhas: recuperação automática em <5s.",
                                "Latência end-to-end: <1s de detecção a ação.",
                                "Clareza da documentação: checklist completo.",
                                "Integração segura: sem riscos a equipamentos."
                              ],
                              "crossCurricularConnections": [
                                "Visão Computacional: Processamento de imagens e detecção de objetos.",
                                "Programação Industrial: Ladder logic e PLC programming.",
                                "Redes Industriais: Protocolos como OPC UA e Ethernet/IP.",
                                "Mecatrônica: Controle de atuadores pneumáticos/elétricos.",
                                "Qualidade e Manutenção: Estratégias de depuração e otimização."
                              ],
                              "realWorldApplication": "Inspeção automatizada em fábricas de automotiva (detecção de soldas defeituosas ativando rejeição), linhas de embalagem (classificação por cor/tamanho via visão para sorting robótico), e farmacêutica (verificação de rótulos acionando alarmes ou paradas)."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Desenvolver Projetos Integrados",
                            "description": "Elaborar um projeto completo de sistema mecatrônico com visão, microcontrolador e CLP, seguindo metodologias de design como as de Cross (2004) e Shetty & Kolk (1997).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definição de Requisitos e Planejamento Inicial",
                                  "subSteps": [
                                    "Analise as necessidades do projeto com base em metodologias de design de Cross (2004), identificando problemas e stakeholders.",
                                    "Defina requisitos funcionais e não funcionais para visão computacional, microcontrolador e CLP.",
                                    "Crie um diagrama de requisitos e cronograma preliminar usando ferramentas como Gantt.",
                                    "Estude referências de Shetty & Kolk (1997) para alinhar com princípios de design de produtos mecatrônicos.",
                                    "Realize uma sessão de brainstorming para gerar ideias iniciais."
                                  ],
                                  "verification": "Documento de requisitos aprovado com diagrama e cronograma revisados por pares.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livros de Cross (2004) e Shetty & Kolk (1997)",
                                    "Software de diagramação (ex: Lucidchart)",
                                    "Notebook"
                                  ],
                                  "tips": "Priorize requisitos SMART (Specific, Measurable, Achievable, Relevant, Time-bound).",
                                  "learningObjective": "Compreender e aplicar metodologias de design para definir escopo de projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Ignorar restrições de custo/tempo",
                                    "Requisitos vagos sem métricas de sucesso"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Design e Modelagem do Sistema",
                                  "subSteps": [
                                    "Desenhe arquiteturas modulares para visão (câmera + processamento), microcontrolador (ex: Arduino/ESP32) e CLP (ex: Siemens S7).",
                                    "Crie diagramas UML ou SysML para fluxos de dados e controle.",
                                    "Modele simulações iniciais usando software como MATLAB/Simulink para visão e controle.",
                                    "Defina interfaces de comunicação (ex: Modbus, Ethernet/IP entre micro e CLP).",
                                    "Valide design com análise de falhas (FMEA)."
                                  ],
                                  "verification": "Diagramas e modelos aprovados em revisão técnica com simulação funcional básica.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink",
                                    "Ferramentas UML (ex: Draw.io)",
                                    "Documentação de CLPs e microcontroladores"
                                  ],
                                  "tips": "Use design iterativo: prototipe virtualmente antes de hardware.",
                                  "learningObjective": "Desenvolver modelos integrados que suportem integração de visão, micro e CLP.",
                                  "commonMistakes": [
                                    "Interfaces incompatíveis",
                                    "Sobredimensionamento de componentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação dos Componentes Individuais",
                                  "subSteps": [
                                    "Configure o sistema de visão com OpenCV para detecção de objetos.",
                                    "Programe o microcontrolador para processar dados de visão e enviar comandos.",
                                    "Desenvolva ladder logic no CLP para controle de atuadores baseado em sinais recebidos.",
                                    "Teste cada módulo isoladamente com casos de teste unitários.",
                                    "Otimize código para performance em tempo real."
                                  ],
                                  "verification": "Cada componente passa em testes unitários com logs de performance.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Câmera USB",
                                    "Microcontrolador (Arduino/ESP32)",
                                    "CLP com software de programação (TIA Portal)",
                                    "OpenCV instalado"
                                  ],
                                  "tips": "Use versionamento de código (Git) para rastrear mudanças.",
                                  "learningObjective": "Implementar módulos funcionais independentes seguindo boas práticas de programação embarcada.",
                                  "commonMistakes": [
                                    "Códigos não otimizados causando delays",
                                    "Falta de tratamento de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração e Testes do Sistema Completo",
                                  "subSteps": [
                                    "Integre visão ao microcontrolador via USB/Serial e micro ao CLP via protocolo industrial.",
                                    "Execute testes de integração com cenários reais (ex: detecção e acionamento).",
                                    "Ajuste parâmetros para sincronização temporal.",
                                    "Realize testes de estresse e depuração com osciloscópio/multímetro.",
                                    "Aplique ciclos de feedback baseados em Cross (2004)."
                                  ],
                                  "verification": "Sistema completo opera sem falhas em 95% dos testes integrados.",
                                  "estimatedTime": "10 horas",
                                  "materials": [
                                    "Hardware completo montado",
                                    "Ferramentas de depuração (oscilloscópio)",
                                    "Protocolos de comunicação configurados"
                                  ],
                                  "tips": "Teste incrementalmente: visão primeiro, depois micro, por fim CLP.",
                                  "learningObjective": "Integrar componentes mecatrônicos em um sistema coeso e funcional.",
                                  "commonMistakes": [
                                    "Problemas de latência não previstos",
                                    "Integração sem testes prévios"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação Final, Documentação e Apresentação",
                                  "subSteps": [
                                    "Valide o projeto contra requisitos iniciais com métricas quantitativas.",
                                    "Documente código, diagramas e lições aprendidas.",
                                    "Prepare relatório final seguindo Shetty & Kolk (1997).",
                                    "Apresente demo ao grupo com vídeo gravado.",
                                    "Planeje melhorias futuras."
                                  ],
                                  "verification": "Relatório completo e demo aprovada por avaliador.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de edição de vídeo",
                                    "Templates de relatório",
                                    "Hardware final"
                                  ],
                                  "tips": "Use imagens e vídeos para ilustrar o funcionamento.",
                                  "learningObjective": "Finalizar projetos com documentação profissional e validação rigorosa.",
                                  "commonMistakes": [
                                    "Documentação incompleta",
                                    "Ignorar lições aprendidas"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver um sistema de inspeção de qualidade para linha de montagem: câmera detecta defeitos em peças (visão), microcontrolador processa imagem e classifica, CLP rejeita peças defeituosas acionando atuador pneumático.",
                              "finalVerifications": [
                                "Sistema detecta e responde a eventos de visão em <500ms.",
                                "Integração sem perda de dados entre visão, micro e CLP.",
                                "Sistema opera estável por 1 hora contínua.",
                                "Todos requisitos iniciais atendidos com evidências.",
                                "Documentação completa disponível.",
                                "Demo funcional gravada."
                              ],
                              "assessmentCriteria": [
                                "Adequação ao design metodológico (Cross/Shetty: 20%)",
                                "Funcionalidade da integração (30%)",
                                "Qualidade da implementação e testes (25%)",
                                "Documentação e apresentação (15%)",
                                "Inovação e robustez (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos de visão (OpenCV/Python).",
                                "Eletrônica: Interfaces de comunicação industrial.",
                                "Gestão de Projetos: Metodologias ágeis e planejamento.",
                                "Matemática: Processamento de imagens e controle PID.",
                                "Sustentabilidade: Otimização energética no design."
                              ],
                              "realWorldApplication": "Em indústrias automotivas (inspeção de soldas), farmacêuticas (controle de embalagens) e manufatura (robótica colaborativa), onde sistemas mecatrônicos integrados aumentam eficiência e reduzem erros humanos."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Testar e Validar Integração",
                            "description": "Realizar testes de integração, verificando sincronização, robustez e desempenho em cenários reais, com análise de falhas e calibração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente de Teste de Integração",
                                  "subSteps": [
                                    "Configurar hardware: conectar câmera de visão, CLP e microcontrolador via interfaces apropriadas (ex: Ethernet/IP ou Modbus).",
                                    "Instalar e configurar software: carregar firmware no CLP, bibliotecas de visão (ex: OpenCV) e scripts de comunicação.",
                                    "Definir cenários de teste: listar inputs esperados (imagens, triggers) e outputs (comandos CLP, respostas).",
                                    "Verificar conexões físicas e rede: usar ping e ferramentas de diagnóstico para confirmar comunicação.",
                                    "Criar checklist inicial de componentes funcionais."
                                  ],
                                  "verification": "Todas as conexões respondem a comandos básicos (ex: ping <1s, leitura de status OK).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Câmera industrial, CLP (ex: Siemens S7), microcontrolador (ex: Arduino/ESP32), cabos Ethernet/RS485, PC com IDE (Ladder Logic, Python).",
                                  "tips": "Use diagramas de rede para mapear conexões antes de ligar; isole seções para testes incrementais.",
                                  "learningObjective": "Entender e configurar infraestrutura para testes de integração sem falhas de comunicação.",
                                  "commonMistakes": "Ignorar versionamento de firmware; conexões soltas ou IPs conflitantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar Testes de Sincronização",
                                  "subSteps": [
                                    "Simular triggers: enviar sinal da visão para CLP e vice-versa (ex: detecção de objeto ativa atuador).",
                                    "Medir latência: cronometrar tempo entre trigger e resposta usando osciloscópio ou logs.",
                                    "Testar ciclos repetidos: rodar 100 ciclos e registrar desvios >5%.",
                                    "Ajustar buffers de comunicação: otimizar tamanhos de pacotes para sincronia em tempo real.",
                                    "Registrar logs: capturar timestamps de eventos em arquivo CSV."
                                  ],
                                  "verification": "Latência média <50ms em 95% dos ciclos; sem perda de pacotes.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Software de logging (ex: Wireshark, Python logger), osciloscópio, objetos de teste para visão.",
                                  "tips": "Inicie com velocidades baixas e acelere gradualmente; use threads dedicadas para comunicação.",
                                  "learningObjective": "Garantir sincronização temporal precisa entre visão e CLP.",
                                  "commonMistakes": "Não sincronizar clocks; sobrecarga de rede por logs excessivos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Robustez e Desempenho em Cenários Reais",
                                  "subSteps": [
                                    "Introduzir ruídos: variar iluminação, vibrações e falhas simuladas (ex: perda de frame).",
                                    "Medir throughput: contar taxa de processamento (FPS) sob carga máxima.",
                                    "Testar limites: sobrecarregar com múltiplos objetos ou velocidades altas.",
                                    "Monitorar consumo: verificar CPU/RAM do CLP e visão durante picos.",
                                    "Gerar relatórios gráficos: plotar métricas vs. cenários."
                                  ],
                                  "verification": "Sistema mantém >90% acurácia e FPS >15 em condições adversas.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": "Fontes de ruído (luzes LED variáveis, vibrador), software de monitoramento (ex: Grafana).",
                                  "tips": "Defina thresholds de falha antecipadamente; pause testes em sobre-aquecimento.",
                                  "learningObjective": "Identificar e quantificar limites de robustez do sistema integrado.",
                                  "commonMistakes": "Testes só em condições ideais; ignorar aquecimento de componentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Falhas, Calibrar e Validar Final",
                                  "subSteps": [
                                    "Analisar logs: identificar padrões de falha (ex: root cause com fishbone diagram).",
                                    "Calibrar parâmetros: ajustar gains de visão, timeouts de CLP baseado em dados.",
                                    "Re-testar pós-calibração: repetir cenários críticos.",
                                    "Documentar melhorias: registrar antes/depois métricas.",
                                    "Emitir relatório final com recomendações."
                                  ],
                                  "verification": "Falhas reduzidas >80%; todas verificações finais passadas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Ferramentas de análise (ex: Excel, MATLAB), templates de relatório.",
                                  "tips": "Priorize falhas mais frequentes; versionar calibrações.",
                                  "learningObjective": "Dominar diagnóstico e otimização iterativa de integrações.",
                                  "commonMistakes": "Atribuir falhas a hardware sem checar software; não documentar."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de parafusos, a câmera detecta parafuso desalinhado e envia trigger ao CLP para parar o conveyor. Teste: simular 500 peças com vibração; medir se para em <100ms 98% das vezes, calibrar para ruído de fábrica.",
                              "finalVerifications": [
                                "Sincronização: latência <50ms em 1000 ciclos.",
                                "Robustez: acurácia >95% com ruídos reais.",
                                "Desempenho: FPS estável >20 sob carga.",
                                "Falhas: zero crashes em 2h contínuo.",
                                "Calibração: parâmetros otimizados documentados.",
                                "Relatório: análise completa com gráficos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração inicial (sem erros de conexão).",
                                "Qualidade dos testes (cobertura de cenários reais).",
                                "Análise de dados quantitativa e qualitativa.",
                                "Efetividade da calibração (melhoria mensurável).",
                                "Documentação clara e acionável.",
                                "Tempo respeitado e segurança mantida."
                              ],
                              "crossCurricularConnections": [
                                "Programação: scripts Python para visão e comunicação.",
                                "Eletrônica: sinais analógicos/digitais e filtros.",
                                "Gestão de Projetos: planejamento de testes e relatórios.",
                                "Estatística: análise de variância em métricas."
                              ],
                              "realWorldApplication": "Em fábricas automotivas, validar integração de visão computacional com CLPs para inspeção de soldas, garantindo qualidade e reduzindo paradas não planejadas em 30%."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Introdução à Robótica",
                "description": "Conceitos básicos de robótica com foco em aplicações mecatrônicas na indústria aeronáutica.",
                "totalSkills": 50,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Definição e Princípios Fundamentais da Robótica",
                    "description": "Conceitos básicos que definem um robô, suas características essenciais e princípios operacionais.",
                    "individualConcepts": [
                      {
                        "id": "46.1.1.1",
                        "name": "Definição de Robô",
                        "description": "Conceito básico que define o que é um robô segundo padrões internacionais como a ISO 8373, enfatizando sua capacidade de manipulação programável em múltiplos eixos, com aplicações em sistemas mecatrônicos industriais.",
                        "specificSkills": [
                          {
                            "id": "46.1.1.1.1",
                            "name": "Reconhecer a definição padrão de robô pela ISO",
                            "description": "Identificar e explicar a definição de robô como um manipulador programável multifuncional operando em três ou mais eixos, diferenciando de máquinas-ferramenta tradicionais, com exemplos de referências como Lyshevski em sistemas eletromecânicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Acessar e ler a definição oficial de robô pela ISO 8373",
                                  "subSteps": [
                                    "Pesquise o documento ISO 8373:2012 ou versão mais recente no site oficial da ISO ou em bases acadêmicas como IEEE Xplore.",
                                    "Localize a seção de definições e extraia o texto exato da definição de 'robô industrial'.",
                                    "Leia a definição completa pelo menos duas vezes, destacando termos chave como 'manipulador programável', 'multifuncional' e 'três ou mais eixos'.",
                                    "Anote a data da norma e qualquer atualização relevante.",
                                    "Registre a fonte exata para citação futura."
                                  ],
                                  "verification": "Confirme que você pode citar verbatim a definição ISO e identificar sua fonte oficial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Documento ISO 8373 (PDF gratuito ou via biblioteca acadêmica)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use termos de busca exatos como 'ISO 8373 robot definition' para resultados precisos. Evite wikis não oficiais.",
                                  "learningObjective": "Compreender a origem e o texto preciso da definição padrão de robô pela ISO.",
                                  "commonMistakes": [
                                    "Confundir com definições genéricas de sites como Wikipedia.",
                                    "Ignorar atualizações da norma (ex: ISO 8373:2012 vs. 2021).",
                                    "Não anotar a citação completa."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dissecar os componentes chave da definição ISO",
                                  "subSteps": [
                                    "Identifique e defina 'manipulador programável': um braço ou estrutura controlada por software.",
                                    "Explique 'multifuncional': capacidade de realizar múltiplas tarefas via reprogramação.",
                                    "Descreva 'operando em três ou mais eixos': graus de liberdade para movimentos complexos.",
                                    "Registre outros elementos como 'reprogramável' e 'autônomo em alguns casos'.",
                                    "Crie um mapa mental ou tabela com cada termo, definição e importância."
                                  ],
                                  "verification": "Liste verbalmente ou por escrito os 4-5 componentes principais com explicações corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel ou ferramenta digital como MindMeister",
                                    "Texto da definição ISO anotado"
                                  ],
                                  "tips": "Use cores diferentes no mapa mental para cada componente para melhor retenção visual.",
                                  "learningObjective": "Analisar e internalizar os elementos constitutivos da definição de robô.",
                                  "commonMistakes": [
                                    "Confundir programável com autônomo (robôs podem ser semi-autônomos).",
                                    "Subestimar a importância dos 'eixos' como diferenciador.",
                                    "Omitir 'multifuncional' ao focar só em movimento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar robôs de máquinas-ferramenta tradicionais",
                                  "subSteps": [
                                    "Defina máquinas-ferramenta: equipamentos com caminhos de ferramenta fixos ou limitados (ex: fresadoras CNC de 3 eixos fixos).",
                                    "Compare: robôs têm reprogramabilidade e multifuncionalidade vs. máquinas com tarefas dedicadas.",
                                    "Crie uma tabela de comparação com colunas: Característica, Robô ISO, Máquina-Ferramenta.",
                                    "Inclua exemplos: braço robótico ABB vs. torno CNC.",
                                    "Explique por que a ISO exclui máquinas-ferramenta da definição de robô."
                                  ],
                                  "verification": "Explique a diferença em uma frase concisa e preencha corretamente uma tabela de comparação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Exemplos visuais de robôs e máquinas-ferramenta (imagens online)"
                                  ],
                                  "tips": "Busque imagens reais para visualizar a diferença em graus de liberdade.",
                                  "learningObjective": "Distinguir conceitualmente robôs de outras máquinas automatizadas.",
                                  "commonMistakes": [
                                    "Classificar CNC multifuncionais como robôs (eles não são reprogramáveis em eixos variáveis).",
                                    "Ignorar o critério de 'multifuncionalidade'.",
                                    "Confundir com cobôs sem verificar conformidade ISO."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar exemplos e referências como Lyshevski",
                                  "subSteps": [
                                    "Pesquise referências em Sergei Lyshevski, como 'Electromechanical Systems in Microtechnology and Nanotechnology'.",
                                    "Identifique exemplos de robôs ISO-conformes: IRB 120 (ABB), UR5 (Universal Robots).",
                                    "Relacione com sistemas eletromecânicos: atuadores, sensores em manipuladores.",
                                    "Crie 2-3 exemplos de não-robôs (ex: impressora 3D) e justifique.",
                                    "Escreva um parágrafo integrando definição ISO, diferenças e referências."
                                  ],
                                  "verification": "Produza um resumo escrito de 150 palavras com exemplos corretos e citação de Lyshevski.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro ou artigos de Lyshevski (via Google Scholar)",
                                    "Catálogos de fabricantes de robôs"
                                  ],
                                  "tips": "Use DOI para citar Lyshevski precisamente; foque em capítulos sobre atuadores eletromecânicos.",
                                  "learningObjective": "Aplicar a definição em contextos reais e acadêmicos.",
                                  "commonMistakes": [
                                    "Citar Lyshevski sem contexto específico em robótica.",
                                    "Classificar drones ou AGVs como robôs sem verificar eixos/manipulador.",
                                    "Faltar exemplos concretos."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma apresentação de 5 slides explicando a definição ISO para um colega de mecatrônica, incluindo tabela de comparação com máquina-ferramenta e exemplo de braço robótico IRB 140 da ABB operando em 6 eixos para soldagem, diferenciando de uma fresadora CNC.",
                              "finalVerifications": [
                                "Recitar a definição ISO verbatim.",
                                "Listar 4 componentes chave corretamente.",
                                "Explicar diferença de máquinas-ferramenta em uma frase.",
                                "Citar um exemplo de robô ISO e um não-robô com justificativa.",
                                "Referenciar Lyshevski em contexto eletromecânico.",
                                "Preencher tabela de comparação sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação da definição ISO (100% exata).",
                                "Profundidade na dissecação de componentes (todos cobertos).",
                                "Clareza na diferenciação de máquinas-ferramenta.",
                                "Relevância e correção de exemplos/referências.",
                                "Capacidade de síntese em resumo escrito ou verbal.",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Mecânica: Estudo de graus de liberdade e cinemática.",
                                "Programação: Conceitos de reprogramabilidade e controle.",
                                "Normas e Ética: Importância de padrões internacionais em design.",
                                "História da Tecnologia: Evolução de manipuladores industriais.",
                                "Física: Dinâmica de sistemas multi-eixos."
                              ],
                              "realWorldApplication": "Em indústrias automotivas, usar a definição ISO para certificar robôs de soldagem (ex: FANUC), garantindo conformidade regulatória, diferenciando de CNCs em fábricas, e aplicando em design de sistemas eletromecânicos como descrito por Lyshevski para otimizar linhas de produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "46.1.1.1.2",
                            "name": "Diferenciar robô de sistemas automatizados",
                            "description": "Comparar robôs com sistemas de automação fixa, destacando a reprogramabilidade e flexibilidade dos robôs em contextos mecatrônicos, como na indústria aeronáutica para montagem de componentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Sistemas Automatizados Fixos",
                                  "subSteps": [
                                    "Pesquisar a definição de sistemas automatizados fixos em fontes de mecatrônica.",
                                    "Identificar características principais: programação rígida para uma única tarefa, falta de flexibilidade e mobilidade limitada.",
                                    "Analisar exemplos como linhas de montagem conveyor ou máquinas CNC dedicadas.",
                                    "Registrar as limitações em termos de adaptação a mudanças.",
                                    "Comparar superficialmente com sistemas manuais."
                                  ],
                                  "verification": "Listar pelo menos 4 características e 2 exemplos de sistemas fixos em um resumo escrito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet ou livro-texto de mecatrônica",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use diagramas simples para visualizar a rigidez do sistema.",
                                  "learningObjective": "Dominar os conceitos fundamentais de automação fixa e suas restrições.",
                                  "commonMistakes": [
                                    "Confundir automação fixa com robótica móvel",
                                    "Ignorar a dependência de programação específica para uma tarefa única"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Definição de Robô",
                                  "subSteps": [
                                    "Estudar a definição padrão de robô (ex: ISO 8373: manipulador programável com múltiplos eixos).",
                                    "Listar componentes essenciais: sensores, atuadores, controladores e reprogramabilidade.",
                                    "Destacar atributos como flexibilidade, autonomia e capacidade de aprendizado/adaptação.",
                                    "Exemplificar com braços robóticos industriais.",
                                    "Diferenciar de outros dispositivos automatizados."
                                  ],
                                  "verification": "Escrever uma definição própria de robô com pelo menos 5 atributos chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Vídeos introdutórios sobre robótica (YouTube ou Khan Academy)",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Associe a definição a imagens mentais de robôs em ação para melhor retenção.",
                                  "learningObjective": "Entender os princípios que definem um robô como entidade flexível.",
                                  "commonMistakes": [
                                    "Reduzir robô apenas a 'máquinas que se movem'",
                                    "Esquecer a ênfase na reprogramabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Chave entre Robôs e Sistemas Fixos",
                                  "subSteps": [
                                    "Criar uma tabela comparativa: colunas para automação fixa vs. robô (linhas: reprogramabilidade, flexibilidade, custo, aplicação).",
                                    "Enfatizar reprogramabilidade (robôs mudam tarefas via software) vs. rigidez (fixos requerem hardware novo).",
                                    "Discutir flexibilidade em cenários variáveis e mobilidade.",
                                    "Analisar vantagens/desvantagens em contextos industriais.",
                                    "Priorizar diferenças em mecatrônica: integração de mecânica, eletrônica e software."
                                  ],
                                  "verification": "Preencher tabela comparativa com pelo menos 5 diferenças detalhadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado",
                                    "Referências online sobre comparações"
                                  ],
                                  "tips": "Use setas ou ícones na tabela para destacar diferenças visuais.",
                                  "learningObjective": "Capacitar a diferenciação precisa baseada em critérios técnicos.",
                                  "commonMistakes": [
                                    "Superestimar similaridades superficiais",
                                    "Não considerar custos de adaptação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceitos em Contexto Mecatrônico",
                                  "subSteps": [
                                    "Pesquisar aplicações na indústria aeronáutica (ex: montagem de fuselagens).",
                                    "Simular cenário: sistema fixo para parafusar painéis vs. robô reprogramável para componentes variados.",
                                    "Avaliar impactos: tempo de setup, eficiência em produção em lote pequeno.",
                                    "Discutir integração mecatrônica em robôs (sensores para precisão).",
                                    "Concluir com tabela de prós/contras no contexto específico."
                                  ],
                                  "verification": "Desenvolver um caso de estudo curto com exemplos aeronáuticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigos sobre robótica aeronáutica (ex: sites da Boeing ou Embraer)",
                                    "Computador para pesquisa"
                                  ],
                                  "tips": "Busque vídeos reais de linhas de produção para contextualizar.",
                                  "learningObjective": "Aplicar diferenciação em cenários reais de mecatrônica industrial.",
                                  "commonMistakes": [
                                    "Generalizar sem contexto específico",
                                    "Ignorar fatores econômicos como ROI"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de aviões, um sistema automatizado fixo parafusaria painéis de asas sempre na mesma posição e tamanho, exigindo redesign para novos modelos. Um robô industrial, como o KUKA KR AGILUS, pode ser reprogramado via software em horas para montar componentes variados, como fuselagens ou hélices, adaptando-se a mudanças de produção.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças principais entre robô e automação fixa.",
                                "Criar tabela comparativa precisa sem erros conceituais.",
                                "Identificar corretamente um robô vs. sistema fixo em 2 exemplos industriais.",
                                "Descrever aplicação em montagem aeronáutica com reprogramabilidade.",
                                "Listar 4 vantagens de robôs em cenários flexíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual nas definições e diferenças (peso: 30%).",
                                "Profundidade na tabela comparativa e exemplos (peso: 25%).",
                                "Relevância ao contexto mecatrônico/aeronáutico (peso: 20%).",
                                "Clareza e organização na comunicação (peso: 15%).",
                                "Uso de verificações e tips para autoavaliação (peso: 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Conceitos de software reprogramável em linguagens como ROS.",
                                "Mecânica: Estudo de atuadores e graus de liberdade em robôs.",
                                "Eletrônica: Integração de sensores para feedback em sistemas mecatrônicos.",
                                "Gestão Industrial: Análise de custos e eficiência em produção lean."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, robôs diferenciam-se de sistemas fixos ao permitir montagem flexível de componentes como painéis compostos ou estruturas de titânio, reduzindo tempo de reconfiguração de semanas para horas, otimizando produção para modelos personalizados como o Boeing 787."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "46.1.1.1.3",
                            "name": "Identificar aplicações iniciais em mecatrônica",
                            "description": "Listar e descrever aplicações básicas de robôs em projetos mecatrônicos, referenciando Shetty e Kolk para design de sistemas integrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de mecatrônica e robótica",
                                  "subSteps": [
                                    "Ler a definição de mecatrônica como integração de mecânica, eletrônica e controle.",
                                    "Revisar a definição de robô conforme padrões industriais (ex: ISO 8373).",
                                    "Identificar princípios básicos de sistemas integrados de Shetty e Kolk.",
                                    "Anotar exemplos iniciais de integração em projetos mecatrônicos.",
                                    "Mapear como robôs se encaixam nessa integração."
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras conectando mecatrônica e robótica, citando Shetty e Kolk.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Mechatronics System Design' de Shetty e Kolk (capítulos iniciais), caderno de notas, acesso online a definições ISO.",
                                  "tips": "Use diagramas para visualizar a integração de subsistemas.",
                                  "learningObjective": "Dominar as bases conceituais para identificar aplicações robóticas em mecatrônica.",
                                  "commonMistakes": "Confundir mecatrônica apenas com mecânica, ignorando eletrônica e controle."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar referências específicas de Shetty e Kolk sobre design integrado",
                                  "subSteps": [
                                    "Localizar seções no livro sobre aplicações robóticas em sistemas mecatrônicos.",
                                    "Ler exemplos de design integrado envolvendo robôs (ex: braços manipuladores).",
                                    "Extrair princípios chave para projetos iniciais.",
                                    "Comparar com aplicações básicas como automação industrial.",
                                    "Registrar citações diretas relevantes."
                                  ],
                                  "verification": "Criar uma tabela com 3 princípios de Shetty e Kolk e suas aplicações robóticas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro Shetty e Kolk (capítulos 1-3 e seções de robótica), marcador de texto, software de tabelas (Excel ou Google Sheets).",
                                  "tips": "Priorize exemplos práticos no livro para facilitar a conexão com projetos reais.",
                                  "learningObjective": "Aplicar referências teóricas para embasar identificação de aplicações.",
                                  "commonMistakes": "Ignorar contextos integrados, focando só em componentes isolados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Listar aplicações básicas de robôs em projetos mecatrônicos",
                                  "subSteps": [
                                    "Brainstorm de 5-7 aplicações iniciais (ex: pick-and-place, soldagem).",
                                    "Classificar cada uma por subsistemas mecatrônicos envolvidos.",
                                    "Referenciar Shetty e Kolk para cada item da lista.",
                                    "Priorizar aplicações simples e escaláveis.",
                                    "Validar lista com critérios de integração sistêmica."
                                  ],
                                  "verification": "Produzir uma lista numerada com pelo menos 5 aplicações, cada uma com breve justificativa.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Lista brainstorm em papel ou digital, livro Shetty e Kolk aberto.",
                                  "tips": "Use mind maps para conectar aplicações aos princípios do livro.",
                                  "learningObjective": "Gerar uma lista acionável de aplicações iniciais.",
                                  "commonMistakes": "Listar aplicações genéricas sem referência mecatrônica específica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever aplicações com foco em design integrado",
                                  "subSteps": [
                                    "Para cada aplicação da lista, descrever integração de mecânica, eletrônica e software.",
                                    "Incluir diagramas simples de fluxo sistêmico.",
                                    "Explicar benefícios conforme Shetty e Kolk.",
                                    "Avaliar limitações iniciais e melhorias.",
                                    "Sintetizar em parágrafos concisos."
                                  ],
                                  "verification": "Elaborar descrições completas para todas as aplicações listadas, totalizando 300-500 palavras.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Software de desenho (Draw.io ou papel), livro para referências, processador de texto.",
                                  "tips": "Estruture descrições com: introdução, integração, benefícios e referência.",
                                  "learningObjective": "Transformar lista em descrições detalhadas e integradas.",
                                  "commonMistakes": "Descrições superficiais sem menção explícita a Shetty e Kolk."
                                }
                              ],
                              "practicalExample": "Em um projeto mecatrônico de braço robótico para linha de montagem (pick-and-place), o robô integra atuadores mecânicos (juntas), sensores eletrônicos (visão e força) e controlador PID (software), conforme o design de sistemas integrados descrito por Shetty e Kolk no Capítulo 2, permitindo automação precisa e escalável.",
                              "finalVerifications": [
                                "Lista contém pelo menos 5 aplicações básicas de robôs em mecatrônica.",
                                "Cada aplicação referenciada corretamente a Shetty e Kolk.",
                                "Descrições incluem integração de pelo menos 3 subsistemas (mecânica, eletrônica, controle).",
                                "Diagramas ou fluxos visuais presentes para 80% das aplicações.",
                                "Total de descrições ultrapassa 400 palavras com linguagem clara.",
                                "Identificadas limitações e benefícios para cada aplicação."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual e fidelidade às referências de Shetty e Kolk (peso 30%).",
                                "Completude da lista e descrições detalhadas (peso 25%).",
                                "Clareza e estrutura das descrições (peso 20%).",
                                "Uso de exemplos integrados e diagramas (peso 15%).",
                                "Identificação de benefícios e limitações reais (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aplicação de cinemática e dinâmica em movimentos robóticos.",
                                "Matemática: Modelagem de transformações homogêneas para planejamento de trajetórias.",
                                "Informática: Algoritmos de controle e programação de PLCs.",
                                "Engenharia de Materiais: Seleção de componentes para atuadores e sensores."
                              ],
                              "realWorldApplication": "Na indústria automotiva, robôs mecatrônicos como os usados pela Tesla em linhas de montagem de baterias integram sensores, atuadores e IA para soldagem e montagem precisa, reduzindo erros humanos em 90% e aumentando eficiência, alinhado aos princípios de design integrado de Shetty e Kolk."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "46.1.1.2",
                        "name": "Características Essenciais de um Robô",
                        "description": "Elementos fundamentais que compõem um robô, incluindo sensores, atuadores e controladores, integrados em times multifuncionais para desenvolvimento de produtos.",
                        "specificSkills": [
                          {
                            "id": "46.1.1.2.1",
                            "name": "Descrever componentes sensoriais básicos",
                            "description": "Explicar o papel de sensores em robôs, incluindo introdução a sistemas de visão por computador para detecção ambiental, com exemplos aeronáuticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel fundamental dos sensores em robôs",
                                  "subSteps": [
                                    "Defina sensores como dispositivos que detectam e medem estímulos ambientais.",
                                    "Explique como sensores fornecem feedback para o sistema de controle do robô.",
                                    "Discuta a importância da percepção sensorial para autonomia robótica.",
                                    "Classifique sensores em categorias básicas: proprioceptivos (internos) e exteroceptivos (externos).",
                                    "Relacione sensores ao ciclo de percepção-ação-decisão em robótica."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o papel dos sensores e liste 3 funções principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de robótica básica, vídeo introdutório sobre sensores (YouTube: 'Robot Sensors Explained').",
                                  "tips": "Use analogias humanas, como olhos e pele, para facilitar a compreensão.",
                                  "learningObjective": "Identificar e explicar o papel dos sensores como entrada sensorial essencial para robôs.",
                                  "commonMistakes": "Confundir sensores com atuadores (atuadores executam ações, sensores detectam)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever sensores sensoriais básicos não-visuais",
                                  "subSteps": [
                                    "Descreva sensores táteis (ex: bumpers, strain gauges) para detecção de contato.",
                                    "Explique sensores de proximidade (ultrassom, infravermelho) para medição de distâncias.",
                                    "Apresente sensores ambientais (temperatura, umidade, luz) com exemplos de uso.",
                                    "Compare vantagens e limitações de cada tipo em cenários robóticos.",
                                    "Monte um diagrama simples mostrando integração de sensores em um robô móvel."
                                  ],
                                  "verification": "Crie uma tabela comparativa de 4 sensores com função, princípio e exemplo de aplicação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta para diagramas, simulador online como Tinkercad para sensores virtuais.",
                                  "tips": "Teste sensores reais com Arduino se disponível para hands-on learning.",
                                  "learningObjective": "Listar e diferenciar sensores básicos táteis e de proximidade com exemplos práticos.",
                                  "commonMistakes": "Ignorar limitações como alcance do ultrassom em ambientes com eco."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir sistemas de visão por computador para detecção ambiental",
                                  "subSteps": [
                                    "Defina visão computacional como processamento de imagens para extração de informações.",
                                    "Explique componentes: câmera, processamento de imagem (filtros, detecção de bordas).",
                                    "Descreva algoritmos básicos como detecção de objetos via OpenCV (ex: contornos, matching de templates).",
                                    "Discuta aplicações em robótica: navegação, reconhecimento de obstáculos.",
                                    "Implemente um exemplo simples de detecção de cor em software gratuito."
                                  ],
                                  "verification": "Execute um script básico de visão computacional e capture uma screenshot do resultado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Computador com Python e OpenCV instalado, webcam, tutorial OpenCV.org.",
                                  "tips": "Comece com imagens estáticas antes de vídeo para depuração fácil.",
                                  "learningObjective": "Compreender e demonstrar princípios básicos de visão computacional em detecção.",
                                  "commonMistakes": "Confundir resolução da câmera com precisão algorítmica de detecção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar conceitos a exemplos aeronáuticos",
                                  "subSteps": [
                                    "Analise sensores em drones: LIDAR para mapeamento 3D, câmeras para evasão de obstáculos.",
                                    "Descreva visão computacional em UAVs para detecção de alvos ou inspeção de fuselagem.",
                                    "Compare com aviões autônomos: uso de câmeras térmicas para navegação noturna.",
                                    "Crie um fluxograma de um sistema sensorial em um drone aeronáutico.",
                                    "Discuta desafios como vibração e condições climáticas em aplicações aéreas."
                                  ],
                                  "verification": "Desenhe e explique um diagrama de sensores em um drone com legendas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Vídeos de drones (ex: DJI Phantom sensores), software de desenho como Draw.io.",
                                  "tips": "Pesquise casos reais como drones da NASA para inspiração autêntica.",
                                  "learningObjective": "Integrar sensores e visão em contextos aeronáuticos específicos.",
                                  "commonMistakes": "Subestimar impacto de ruído ambiental em sensores aéreos."
                                }
                              ],
                              "practicalExample": "Em um drone de inspeção aeronáutica, sensores ultrassom detectam proximidade de turbinas, enquanto visão computacional via câmera identifica rachaduras na fuselagem processando imagens em tempo real com OpenCV para alertar o operador.",
                              "finalVerifications": [
                                "Pode listar e explicar 5 tipos de sensores robóticos com exemplos?",
                                "Descreve corretamente o pipeline de visão computacional para detecção?",
                                "Fornece exemplos aeronáuticos precisos envolvendo sensores?",
                                "Diferencia sensores proprioceptivos de exteroceptivos?",
                                "Explica limitações de sensores em ambientes reais?",
                                "Integra sensores ao ciclo de controle robótico?"
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas definições e funções de sensores (30%)",
                                "Profundidade na explicação de visão computacional (25%)",
                                "Relevância e acurácia de exemplos aeronáuticos (20%)",
                                "Completude de diagramas e comparações (15%)",
                                "Clareza e estrutura na descrição verbal (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de ondas sonoras (ultrassom) e óptica (visão)",
                                "Computação: Algoritmos de processamento de imagem e programação em Python/OpenCV",
                                "Matemática: Vetores para distâncias e matrizes em processamento de imagens",
                                "Engenharia Aeronáutica: Integração sensorial em UAVs e sistemas autônomos"
                              ],
                              "realWorldApplication": "Desenvolvimento de drones autônomos para inspeção de aeronaves em aeroportos, usando sensores e visão para detectar falhas estruturais sem intervenção humana, reduzindo tempo de inatividade e custos em companhias aéreas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "46.1.1.1.1"
                            ]
                          },
                          {
                            "id": "46.1.1.2.2",
                            "name": "Identificar atuadores e estruturas mecânicas",
                            "description": "Detalhar atuadores elétricos, hidráulicos e pneumáticos em robôs, relacionando com máquinas elétricas de Lyshevski em contextos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de atuadores e estruturas mecânicas em robôs",
                                  "subSteps": [
                                    "Definir atuador como dispositivo que converte energia em movimento mecânico.",
                                    "Classificar atuadores por tipo de energia: elétrica, hidráulica e pneumática.",
                                    "Identificar estruturas mecânicas básicas: chassis, juntas, links e engrenagens.",
                                    "Explicar o papel dos atuadores nas estruturas mecânicas de um robô.",
                                    "Revisar princípios mecatrônicos básicos envolvendo integração de componentes."
                                  ],
                                  "verification": "Criar um diagrama simples rotulando atuadores e estruturas em um robô genérico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagrama de robô impresso ou digital",
                                    "Vídeo introdutório sobre robótica (YouTube: 'Robotics Basics')",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias cotidianas, como comparar atuadores a músculos humanos.",
                                  "learningObjective": "Entender a função e classificação básica de atuadores e estruturas mecânicas.",
                                  "commonMistakes": [
                                    "Confundir atuadores com sensores",
                                    "Ignorar a integração mecatrônica",
                                    "Não diferenciar energia de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detalhar atuadores elétricos e relação com máquinas elétricas de Lyshevski",
                                  "subSteps": [
                                    "Estudar motores DC, servomotores e motores de passo como atuadores elétricos comuns em robôs.",
                                    "Ler excertos de 'Electromechanical Systems' de Lyshevski sobre conversão eletromecânica.",
                                    "Analisar torque, velocidade e controle PID em atuadores elétricos.",
                                    "Comparar eficiência e aplicações em robôs móveis vs. manipuladores.",
                                    "Simular um motor elétrico simples usando software como Tinkercad."
                                  ],
                                  "verification": "Desenhar e explicar o diagrama de um servomotor em um braço robótico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro ou PDF de Lyshevski (capítulos sobre máquinas elétricas)",
                                    "Software Tinkercad ou Fritzing",
                                    "Vídeos sobre servomotores Arduino"
                                  ],
                                  "tips": "Foque em equações básicas de torque (τ = Kt * I) para compreensão profunda.",
                                  "learningObjective": "Dominar atuadores elétricos e sua base teórica em Lyshevski.",
                                  "commonMistakes": [
                                    "Confundir motores DC com AC",
                                    "Subestimar perdas térmicas",
                                    "Ignorar controle de feedback"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar atuadores hidráulicos e pneumáticos em contextos robóticos",
                                  "subSteps": [
                                    "Descrever atuadores hidráulicos: cilindros e motores hidráulicos, vantagens em força alta.",
                                    "Explicar atuadores pneumáticos: pistões e válvulas, ideais para velocidade e segurança.",
                                    "Comparar com elétricos: potência, precisão e manutenção.",
                                    "Analisar sistemas de controle: válvulas solenoides e compressores.",
                                    "Identificar exemplos em robôs industriais como braços hidráulicos."
                                  ],
                                  "verification": "Listar prós e contras de cada tipo em uma tabela comparativa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagramas hidráulicos/pneumáticos (de manuais Fanuc)",
                                    "Vídeos de robôs pneumáticos (ex: Festo)",
                                    "Marcadores e papel para tabela"
                                  ],
                                  "tips": "Pense em fluidos incompressíveis (hidráulico) vs. compressíveis (pneumático).",
                                  "learningObjective": "Diferenciar e aplicar atuadores não-elétricos em robótica.",
                                  "commonMistakes": [
                                    "Confundir vazamentos hidráulicos com pneumáticos",
                                    "Superestimar precisão pneumática",
                                    "Esquecer requisitos de bomba/compressor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar identificação de atuadores com estruturas mecânicas em mecatrônica",
                                  "subSteps": [
                                    "Mapear atuadores em estruturas: elétricos em juntas rotativas, hidráulicos em lifts.",
                                    "Relacionar com Lyshevski: modelagem dinâmica de sistemas mecatrônicos.",
                                    "Analisar um robô completo: identificar todos os atuadores e estruturas.",
                                    "Discutir trade-offs em design mecatrônico (custo, peso, precisão).",
                                    "Criar um checklist para identificação em projetos reais."
                                  ],
                                  "verification": "Anotar componentes em foto de um robô real (ex: UR5 ou kit LEGO Mindstorms).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Fotos/vídeos de robôs reais",
                                    "Checklist template",
                                    "Software de modelagem como SolidWorks (trial)"
                                  ],
                                  "tips": "Sempre considere o ciclo completo: energia → atuador → estrutura → movimento.",
                                  "learningObjective": "Integrar conhecimento para identificação holística em mecatrônica.",
                                  "commonMistakes": [
                                    "Focar só em atuadores, ignorar estruturas",
                                    "Não relacionar com dinâmica de Lyshevski",
                                    "Generalizar sem contexto específico"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando um kit Arduino Robot Arm, desmonte o braço, identifique o servomotor elétrico na junta rotativa (relacione com DC de Lyshevski), o pistão pneumático opcional para extensão, e estruturas como links de alumínio e chassis base. Teste movimentos e anote funções.",
                              "finalVerifications": [
                                "Listar corretamente 3 tipos de atuadores com exemplos robóticos.",
                                "Explicar relação de atuadores elétricos com máquinas de Lyshevski.",
                                "Diferenciar hidráulico vs. pneumático em uma aplicação.",
                                "Identificar estruturas mecânicas em diagrama de robô.",
                                "Criar mapa de integração mecatrônica.",
                                "Simular falha em atuador e propor solução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de atuadores (90% correto).",
                                "Profundidade na relação com Lyshevski (citações ou equações).",
                                "Qualidade do diagrama/mapas (clareza e rotulagem).",
                                "Análise comparativa completa (prós/contras).",
                                "Checklist prático e acionável.",
                                "Integração interdisciplinar demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de Newton e dinâmica de fluidos.",
                                "Engenharia Elétrica: Controle de motores e eletrônica de potência.",
                                "Matemática: Equações diferenciais para modelagem (Lyshevski).",
                                "Design Industrial: Cinemática e análise de estruturas.",
                                "Informática: Simulações em Python/MATLAB para atuadores."
                              ],
                              "realWorldApplication": "Em fábricas automotivas como a Tesla, atuadores pneumáticos movem painéis em linhas de montagem, enquanto elétricos (baseados em princípios de Lyshevski) controlam precisão em soldagem robótica, integrando estruturas mecânicas leves para eficiência."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "46.1.1.1.1"
                            ]
                          },
                          {
                            "id": "46.1.1.2.3",
                            "name": "Explicar integração com microcontroladores",
                            "description": "Descrever como microprocessadores e microcontroladores formam o cérebro do robô, preparando para projetos de sistemas microcontrolados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Microprocessadores e Microcontroladores",
                                  "subSteps": [
                                    "Pesquise definições básicas: microprocessador como CPU standalone e microcontrolador como SoC integrado.",
                                    "Identifique componentes principais: CPU, memória, periféricos em microcontroladores.",
                                    "Compare arquitetura: microprocessador precisa de hardware externo; microcontrolador é autônomo.",
                                    "Visualize diagramas de pinout de exemplos como Intel 8085 (microprocessador) e Arduino Uno (microcontrolador).",
                                    "Anote analogia com cérebro humano: processamento central e integração sensorial."
                                  ],
                                  "verification": "Crie um diagrama simples comparando os dois e explique em voz alta as diferenças principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagramas impressos ou digitais de microprocessadores/microcontroladores",
                                    "Vídeo introdutório (ex: Khan Academy ou YouTube sobre embedded systems)"
                                  ],
                                  "tips": "Use analogias cotidianas como smartphone (microcontrolador) vs. PC desktop (microprocessador) para fixar conceitos.",
                                  "learningObjective": "Compreender definições e diferenças fundamentais entre microprocessadores e microcontroladores.",
                                  "commonMistakes": [
                                    "Confundir os termos como sinônimos",
                                    "Ignorar periféricos integrados no microcontrolador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar Papel como 'Cérebro' do Robô",
                                  "subSteps": [
                                    "Descreva funções: processar sensores, controlar atuadores e executar lógica de controle.",
                                    "Liste entradas/saídas: sensores (ADC), motores (PWM), comunicação (UART/I2C).",
                                    "Explique ciclo de operação: ler sensor → processar → atuar.",
                                    "Discuta real-time processing: por que microcontroladores são ideais para robótica.",
                                    "Simule fluxo com fluxograma simples de um robô seguidor de linha."
                                  ],
                                  "verification": "Desenhe um fluxograma mostrando o ciclo de processamento em um robô e narre seu funcionamento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para fluxogramas",
                                    "Simulador online como Tinkercad para visualização"
                                  ],
                                  "tips": "Pense no microcontrolador como o 'piloto automático' que reage instantaneamente a estímulos.",
                                  "learningObjective": "Identificar como esses chips atuam como núcleo de processamento em robôs.",
                                  "commonMistakes": [
                                    "Subestimar latência em microprocessadores standalone",
                                    "Esquecer comunicação com outros módulos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar Integração com Componentes do Robô",
                                  "subSteps": [
                                    "Mapeie conexões: sensores a portas digitais/analógicas, atuadores a PWM/GPIO.",
                                    "Explique barramentos: I2C/SPI para múltiplos dispositivos.",
                                    "Descreva firmware: código que roda no microcontrolador para integração.",
                                    "Discuta power management: tensão, corrente e isolamento.",
                                    "Analise exemplo de shield Arduino para robótica móvel."
                                  ],
                                  "verification": "Monte um esquema elétrico básico conectando sensor, microcontrolador e motor em papel ou software.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Datasheet de Arduino ou STM32",
                                    "Ferramenta de diagrama como Fritzing ou Draw.io"
                                  ],
                                  "tips": "Sempre verifique pinagem no datasheet para evitar curtos-circuitos em projetos reais.",
                                  "learningObjective": "Mapear integrações físicas e lógicas com outros componentes robóticos.",
                                  "commonMistakes": [
                                    "Ignorar limites de corrente nos pinos GPIO",
                                    "Confundir protocolos de comunicação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preparar para Projetos de Sistemas Microcontrolados",
                                  "subSteps": [
                                    "Revise ciclo de desenvolvimento: esquemático → código → teste → debug.",
                                    "Discuta ferramentas: IDEs como Arduino IDE, PlatformIO; debuggers.",
                                    "Planeje projeto simples: robô com LED controlado por sensor.",
                                    "Identifique escalabilidade: de hobby a industrial (ex: ROS com microcontroladores).",
                                    "Liste boas práticas: modularidade, comentários no código, versionamento."
                                  ],
                                  "verification": "Esboce um plano de projeto para um robô básico usando microcontrolador e liste 3 ferramentas necessárias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Arduino IDE instalado",
                                    "Exemplos de código open-source de GitHub"
                                  ],
                                  "tips": "Comece com breadboard para protótipos rápidos antes de soldar PCBs.",
                                  "learningObjective": "Aplicar conhecimentos para iniciar projetos práticos com microcontroladores em robótica.",
                                  "commonMistakes": [
                                    "Pular debug sem multímetro/oscilloscópio",
                                    "Código monolítico sem funções modulares"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um robô seguidor de linha, o Arduino Uno (microcontrolador) lê sensores IR nas entradas analógicas, processa a lógica de PID no firmware e envia sinais PWM aos motores DC via pontes H, formando o 'cérebro' que integra percepção, decisão e ação.",
                              "finalVerifications": [
                                "Explicar diferença entre microprocessador e microcontrolador com exemplo.",
                                "Desenhar diagrama de integração em um robô simples.",
                                "Identificar 3 periféricos comuns em microcontroladores para robótica.",
                                "Simular ciclo de processamento de um sensor para atuador.",
                                "Listar ferramentas para desenvolvimento de projeto microcontrolado."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%)",
                                "Clareza na integração: diagramas e fluxos lógicos precisos (25%)",
                                "Profundidade prática: menção a protocolos, pinos e ferramentas (20%)",
                                "Preparação para projetos: plano viável e boas práticas (15%)",
                                "Comunicação: explicação oral/escrita fluida e estruturada (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de firmware em C/C++.",
                                "Eletrônica: Leitura de datasheets e esquemáticos.",
                                "Física: Controle de sistemas dinâmicos (PID, cinemática).",
                                "Matemática: Lógica booleana e algoritmos de processamento.",
                                "Engenharia de Software: Ciclo de vida de desenvolvimento embarcado."
                              ],
                              "realWorldApplication": "Em drones como DJI Phantom, microcontroladores como STM32 integram IMU, GPS e motores para voo autônomo estável; em linhas de montagem industriais, controlam braços robóticos da ABB para precisão milimétrica."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "46.1.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "46.1.1.3",
                        "name": "Princípios Operacionais Fundamentais",
                        "description": "Princípios que regem o funcionamento de robôs, como controle em malha fechada, autonomia e integração em projetos multifuncionais.",
                        "specificSkills": [
                          {
                            "id": "46.1.1.3.1",
                            "name": "Compreender controle e feedback",
                            "description": "Explicar princípios de controle em loop fechado usando sensores e atuadores, com ênfase em CLPs e microcontroladores para estabilidade operacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Sistemas de Controle Aberto e Fechado",
                                  "subSteps": [
                                    "Defina sistema de controle aberto e cite um exemplo simples, como um timer em um forno.",
                                    "Defina sistema de controle fechado e explique o papel do feedback.",
                                    "Compare vantagens e desvantagens de cada tipo usando um diagrama básico.",
                                    "Identifique cenários onde o loop fechado é essencial para precisão.",
                                    "Desenhe um fluxograma simples ilustrando a diferença entre os dois."
                                  ],
                                  "verification": "Criar um diagrama comparativo e explicá-lo oralmente ou por escrito sem erros conceituais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, caneta, acesso a vídeo introdutório sobre controle (YouTube ou Khan Academy).",
                                  "tips": "Use analogias cotidianas, como dirigir um carro (feedback visual) vs. soltar uma bola (aberto).",
                                  "learningObjective": "Diferenciar controle aberto e fechado, reconhecendo a necessidade de feedback para precisão.",
                                  "commonMistakes": "Confundir feedback com mera medição; ignorar que aberto não corrige erros automaticamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Sensores e Atuadores como Componentes Essenciais",
                                  "subSteps": [
                                    "Liste tipos comuns de sensores (ex: encoders, ultrassônicos) e sua função em feedback.",
                                    "Descreva atuadores (motores DC, servos, pneumáticos) e como respondem a comandos.",
                                    "Explique como sensores medem variáveis (posição, velocidade) e enviam dados para o controlador.",
                                    "Simule uma interação sensor-atuador com um sketch simples no Tinkercad.",
                                    "Discuta calibração básica de sensores para precisão."
                                  ],
                                  "verification": "Montar um circuito virtual simples com sensor e atuador e demonstrar leitura de dados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador Tinkercad ou Fritzing, Arduino IDE básico.",
                                  "tips": "Sempre verifique a faixa de operação do sensor para evitar leituras inválidas.",
                                  "learningObjective": "Identificar e descrever funções de sensores e atuadores no loop de controle.",
                                  "commonMistakes": "Subestimar ruído em sensores; escolher atuadores incompatíveis com a carga."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender o Loop de Controle Fechado e Mecanismos de Feedback",
                                  "subSteps": [
                                    "Desenhe o diagrama de bloco de um loop fechado: referência, controlador, atuador, sensor, comparação.",
                                    "Explique o processo de comparação de erro (setpoint vs. medida) e correção PID básica.",
                                    "Simule um loop fechado controlando temperatura com um diagrama animado.",
                                    "Discuta tipos de feedback: positivo vs. negativo, e impacto na estabilidade.",
                                    "Calcule um erro simples manualmente para um setpoint de 50 e medição de 45."
                                  ],
                                  "verification": "Explicar e diagramar um loop fechado completo, incluindo cálculo de erro.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software de simulação como MATLAB Simulink (versão gratuita) ou Python com Matplotlib.",
                                  "tips": "Comece com ganhos PID baixos para observar oscilações e ajuste iterativamente.",
                                  "learningObjective": "Modelar e explicar o funcionamento de um loop de controle fechado com feedback.",
                                  "commonMistakes": "Confundir setpoint com saída real; ignorar atrasos que causam instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Princípios em CLPs e Microcontroladores para Estabilidade Operacional",
                                  "subSteps": [
                                    "Descreva arquitetura de um CLP (ladder logic) vs. microcontrolador (Arduino/Raspberry Pi).",
                                    "Implemente um loop fechado simples em Arduino: ler sensor, calcular PID, atuar.",
                                    "Programe um CLP virtual (usando OpenPLC) para controle de motor com feedback.",
                                    "Analise estabilidade: overshoot, tempo de assentamento, usando gráficos de resposta.",
                                    "Teste e ajuste parâmetros para minimizar oscilações em simulação."
                                  ],
                                  "verification": "Executar código em simulador ou hardware real, mostrando estabilidade em gráfico.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Arduino IDE, OpenPLC editor, osciloscópio virtual ou multímetro.",
                                  "tips": "Use bibliotecas PID prontas (como Arduino PID Library) para focar no conceito.",
                                  "learningObjective": "Implementar e otimizar loops de controle em CLPs/microcontroladores para estabilidade.",
                                  "commonMistakes": "Ignorar deadbands ou filtros; sobrecarregar o loop com amostragem muito rápida."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Otimizar Estabilidade em Sistemas Mecatrônicos",
                                  "subSteps": [
                                    "Estude critérios de estabilidade (Routh-Hurwitz básico ou root locus introdutório).",
                                    "Simule cenários de instabilidade (ex: ganho alto causando oscilação).",
                                    "Aplique técnicas de tuning PID (Ziegler-Nichols método simples).",
                                    "Compare desempenho em CLP vs. microcontrolador para mesma tarefa.",
                                    "Documente lições aprendidas em um relatório curto."
                                  ],
                                  "verification": "Gerar gráficos de resposta estável e instável, explicando ajustes feitos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (control library) ou Simulink para análise.",
                                  "tips": "Registre todos os parâmetros testados em uma tabela para rastrear melhorias.",
                                  "learningObjective": "Avaliar e melhorar estabilidade operacional usando ferramentas de análise.",
                                  "commonMistakes": "Ajustar apenas um parâmetro PID isoladamente; negligenciar modelagem do sistema."
                                }
                              ],
                              "practicalExample": "Em um braço robótico industrial, um encoder (sensor) mede a posição angular do joint, envia dados para um microcontrolador Arduino que calcula o erro PID em relação ao setpoint desejado, e ajusta um motor servo (atuador) para corrigir, garantindo precisão de ±0.5° mesmo com cargas variáveis.",
                              "finalVerifications": [
                                "Explicar verbalmente um loop fechado completo com sensores e atuadores.",
                                "Diagramar princípios de controle em CLP vs. microcontrolador.",
                                "Simular e demonstrar correção de erro em software/hardware.",
                                "Identificar fontes de instabilidade em um cenário dado.",
                                "Calcular ganho PID básico para estabilidade.",
                                "Comparar aplicações reais de feedback em robótica."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção de aberto/fechado e componentes (30%).",
                                "Profundidade prática: Implementação funcional em simulação (25%).",
                                "Análise de estabilidade: Identificação e correção de problemas (20%).",
                                "Clareza de explicação: Diagramas e relatórios bem estruturados (15%).",
                                "Criatividade em exemplos: Aplicações relevantes e originais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica e leis de movimento em atuadores.",
                                "Eletrônica: Circuitos de sensores e amplificação de sinais.",
                                "Programação: Algoritmos PID e lógica de controle em linguagens como Ladder ou C++.",
                                "Matemática: Equações diferenciais e análise de sistemas lineares.",
                                "Engenharia de Software: Debugging e otimização de loops de controle."
                              ],
                              "realWorldApplication": "Em linhas de montagem automotivas, CLPs com feedback de sensores visuais controlam soldadoras robóticas para precisão milimétrica, reduzindo defeitos e aumentando eficiência operacional em 20-30%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "46.1.1.2.1",
                              "46.1.1.2.2"
                            ]
                          },
                          {
                            "id": "46.1.1.3.2",
                            "name": "Analisar níveis de autonomia robótica",
                            "description": "Classificar robôs por graus de autonomia (de teleoperado a totalmente autônomo), relacionando com visão por computador e aplicações aeronáuticas industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os níveis básicos de autonomia robótica",
                                  "subSteps": [
                                    "Estude a definição de autonomia robótica como capacidade de operação independente de intervenção humana.",
                                    "Identifique os quatro níveis principais: teleoperado (nível 0), semi-autônomo (nível 1-2), supervisionado (nível 3) e totalmente autônomo (nível 4).",
                                    "Revise exemplos clássicos para cada nível, como controle remoto para teleoperado.",
                                    "Anote as características chave de cada nível em um diagrama.",
                                    "Compare autonomia com dependência de sensores e algoritmos."
                                  ],
                                  "verification": "Criar um quadro comparativo com definições e exemplos para cada nível.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de robótica",
                                    "Vídeos introdutórios sobre níveis SAE de autonomia (YouTube)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use mnemônicos como 'T-S-S-T' (Teleoperado, Semi, Supervisionado, Total) para memorizar.",
                                  "learningObjective": "Definir e diferenciar os quatro níveis de autonomia robótica.",
                                  "commonMistakes": [
                                    "Confundir semi-autônomo com totalmente autônomo",
                                    "Ignorar o papel da supervisão humana no nível 3"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar robôs por graus de autonomia",
                                  "subSteps": [
                                    "Selecione 5 robôs reais ou fictícios (ex: Roomba, drone DJI, braço industrial).",
                                    "Avalie cada um com base em critérios: intervenção humana, uso de sensores, tomada de decisão.",
                                    "Atribua o nível de autonomia e justifique com evidências.",
                                    "Crie uma tabela de classificação com colunas para robô, nível e justificativa.",
                                    "Discuta variações em cenários diferentes (ex: Roomba em casa vs. fábrica)."
                                  ],
                                  "verification": "Tabela completa com classificações corretas e justificativas para pelo menos 5 robôs.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Lista de robôs online (Wikipedia Robótica)",
                                    "Planilha Excel ou Google Sheets",
                                    "Imagens de robôs"
                                  ],
                                  "tips": "Considere o ciclo OODA (Observe, Orient, Decide, Act) para avaliar decisão autônoma.",
                                  "learningObjective": "Aplicar classificação de autonomia a exemplos concretos de robôs.",
                                  "commonMistakes": [
                                    "Superestimar autonomia baseada só em movimento",
                                    "Não considerar contexto operacional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar níveis de autonomia com visão por computador",
                                  "subSteps": [
                                    "Explique como visão por computador (detecção de objetos, SLAM) habilita níveis mais altos.",
                                    "Mapeie tecnologias de visão para cada nível: básico em teleoperado, avançado em autônomo.",
                                    "Estude casos como OpenCV para detecção em robôs semi-autônomos.",
                                    "Desenhe um fluxograma mostrando progressão de autonomia via visão.",
                                    "Identifique limitações da visão em baixa autonomia."
                                  ],
                                  "verification": "Fluxograma que liga visão por computador aos níveis de autonomia.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Tutoriais OpenCV básicos",
                                    "Artigos sobre SLAM em robótica",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Foquem em como câmeras reduzem necessidade de input humano.",
                                  "learningObjective": "Conectar visão computacional como enabler de autonomia robótica.",
                                  "commonMistakes": [
                                    "Achar que visão sozinha torna robô autônomo",
                                    "Ignorar fusão com outros sensores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar análise a contextos aeronáuticos industriais",
                                  "subSteps": [
                                    "Pesquise robôs/drones em aviação: inspeção de fuselagem, pintura autônoma.",
                                    "Classifique exemplos aeronáuticos por autonomia (ex: drone teleoperado vs. autônomo).",
                                    "Analise vantagens/desvantagens em aplicações industriais.",
                                    "Relacione com visão: detecção de defeitos via IA.",
                                    "Proponha um cenário híbrido (nível 3) para otimização."
                                  ],
                                  "verification": "Relatório curto (1 página) com 3 exemplos aeronáuticos classificados e analisados.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Artigos sobre drones na aviação (FAA reports)",
                                    "Vídeos de inspeção robótica aeronáutica",
                                    "Editor de texto"
                                  ],
                                  "tips": "Priorize segurança: autonomia alta reduz riscos humanos em hangares.",
                                  "learningObjective": "Integrar análise de autonomia em aplicações aeronáuticas reais.",
                                  "commonMistakes": [
                                    "Generalizar exemplos sem contexto industrial",
                                    "Subestimar regulamentações FAA/EASA"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise um drone de inspeção de aeronaves da Boeing: teleoperado para voo inicial (nível 0), usa visão computacional para detectar rachaduras autonomamente (nível 3), reduzindo tempo de inspeção de dias para horas em manutenção industrial.",
                              "finalVerifications": [
                                "Classificar corretamente os 4 níveis de autonomia com exemplos.",
                                "Explicar papel da visão por computador em pelo menos 2 níveis.",
                                "Identificar 3 robôs aeronáuticos com níveis apropriados.",
                                "Criar diagrama ou tabela de classificação precisa.",
                                "Discutir limitações em aplicações industriais.",
                                "Propor melhoria de autonomia em um cenário real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e classificação dos níveis (30%)",
                                "Profundidade na relação com visão por computador (25%)",
                                "Relevância de exemplos aeronáuticos industriais (20%)",
                                "Qualidade de fluxogramas/tabelas/visuais (15%)",
                                "Análise crítica de vantagens/limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Inteligência Artificial: Algoritmos de visão para autonomia.",
                                "Engenharia Aeronáutica: Drones em manutenção de aviões.",
                                "Programação: Implementação de SLAM com Python/OpenCV.",
                                "Segurança do Trabalho: Redução de riscos humanos em indústrias."
                              ],
                              "realWorldApplication": "Em fábricas aeronáuticas como Embraer, robôs de nível 3-4 usam visão para inspecionar fuselagens autonomamente, acelerando produção, reduzindo custos e melhorando precisão em conformidade com normas ISO 9001."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "46.1.1.2.3"
                            ]
                          },
                          {
                            "id": "46.1.1.3.3",
                            "name": "Relacionar princípios a métodos de design",
                            "description": "Aplicar princípios robóticos a técnicas de projeto integrado de produtos de Cross, em times multifuncionais para sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Princípios Robóticos Fundamentais",
                                  "subSteps": [
                                    "Identificar princípios chave: cinemática, dinâmica, controle, sensores e atuadores.",
                                    "Analisar como esses princípios interagem em sistemas robóticos.",
                                    "Documentar exemplos de aplicação em robôs industriais ou móveis.",
                                    "Mapear limitações e requisitos de cada princípio.",
                                    "Discutir trade-offs entre precisão, velocidade e robustez."
                                  ],
                                  "verification": "Criar um mapa conceitual conectando princípios com diagramas de fluxo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livros de robótica (ex: 'Introduction to Robotics' de Craig), slides de aula, software de diagramação (Draw.io).",
                                  "tips": "Use analogias cotidianas, como comparar cinemática a movimentos humanos, para fixar conceitos.",
                                  "learningObjective": "Compreender os princípios operacionais fundamentais da robótica e suas interdependências.",
                                  "commonMistakes": "Confundir cinemática (posição/velocidade) com dinâmica (forças/aceleração); ignorar integrações sensoriais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Métodos de Design Integrado para Produtos Cross-Funcionais",
                                  "subSteps": [
                                    "Estudar modelos como V-Model, Design Thinking e Agile adaptados para mecatrônica.",
                                    "Analisar fases: requisitos, conceitual, detalhamento, integração e validação.",
                                    "Identificar papéis multifuncionais: mecânica, elétrica, software e manufatura.",
                                    "Revisar ferramentas colaborativas como SysML ou Jira para times.",
                                    "Avaliar critérios de integração em projetos mecatrônicos."
                                  ],
                                  "verification": "Elaborar um fluxograma de um método de design com papéis multifuncionais destacados.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Artigos sobre V-Model em mecatrônica, vídeos tutoriais de Design Thinking, acesso a ferramentas como Lucidchart.",
                                  "tips": "Comece com um caso simples para visualizar fluxos antes de complexificar.",
                                  "learningObjective": "Dominar técnicas de projeto integrado que suportam colaboração multifuncional em mecatrônica.",
                                  "commonMistakes": "Subestimar iterações entre disciplinas; tratar design como linear em vez de iterativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Princípios Robóticos aos Métodos de Design",
                                  "subSteps": [
                                    "Criar matriz de mapeamento: alinhar cada princípio robótico a fases de design.",
                                    "Exemplificar: cinemática na fase conceitual, controle na integração.",
                                    "Definir métricas de sucesso para cada mapeamento (ex: precisão < 1mm).",
                                    "Simular conflitos interdisciplinares e resoluções.",
                                    "Documentar guidelines para aplicação em times multifuncionais."
                                  ],
                                  "verification": "Produzir uma tabela de mapeamento com pelo menos 5 princípios e 4 fases de design.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Planilhas Excel/Google Sheets, exemplos de projetos mecatrônicos reais (ex: relatórios ABB ou Fanuc).",
                                  "tips": "Use cores para destacar conexões fortes vs. fracas no mapeamento.",
                                  "learningObjective": "Desenvolver habilidade de relacionar princípios robóticos diretamente a etapas de design integrado.",
                                  "commonMistakes": "Mapeamentos genéricos sem métricas quantificáveis; ignorar feedback loops entre princípios."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Validar em Simulação de Time Multifuncional",
                                  "subSteps": [
                                    "Formar time simulado com papéis (mecânico, eletricista, programador).",
                                    "Desenvolver um protótipo conceitual usando o mapeamento.",
                                    "Realizar revisão de design simulada com checkpoints.",
                                    "Iterar baseado em feedback multifuncional.",
                                    "Avaliar viabilidade para sistemas mecatrônicos reais."
                                  ],
                                  "verification": "Gerar relatório de simulação com decisões tomadas e lições aprendidas.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Ferramentas colaborativas (Microsoft Teams/Miro), software de simulação (MATLAB/Simulink básico).",
                                  "tips": "Atribua papéis reais a colegas para simular dinâmicas de time.",
                                  "learningObjective": "Praticar aplicação prática do mapeamento em contexto colaborativo multifuncional.",
                                  "commonMistakes": "Falta de comunicação simulada levando a desalinhamentos; pular validações prematuras."
                                }
                              ],
                              "practicalExample": "Em um projeto de braço robótico pick-and-place para linha de montagem automotiva, mapear princípio de cinemática para fase conceitual (definir DOFs), dinâmica para detalhamento (calcular torques), e controle para integração (implementar PID com sensores), colaborando com times de mecânica (estrutura), elétrica (atuadores) e software (algoritmos).",
                              "finalVerifications": [
                                "Matriz de mapeamento cobre todos princípios chave com métricas.",
                                "Fluxograma de design inclui loops multifuncionais.",
                                "Relatório de simulação demonstra resoluções de conflitos.",
                                "Exemplo prático é quantificável e alinhado a mecatrônica.",
                                "Guidelines para times estão claras e acionáveis.",
                                "Autoavaliação confirma compreensão integrada."
                              ],
                              "assessmentCriteria": [
                                "Precisão do mapeamento (90% de alinhamentos corretos).",
                                "Profundidade dos substeps (mínimo 4 por step com detalhes acionáveis).",
                                "Criatividade em conexões interdisciplinares.",
                                "Viabilidade prática no exemplo (alinhado a casos reais).",
                                "Qualidade do relatório (clareza, visualizações, lições).",
                                "Gestão de tempo e cobertura de verificações."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Mecânica: Cinemática e dinâmica em modelagem CAD.",
                                "Engenharia Elétrica: Integração de sensores e atuadores.",
                                "Ciência da Computação: Algoritmos de controle e IA.",
                                "Gestão de Projetos: Metodologias Agile/Scrum para times.",
                                "Manufatura: Otimização de processos industriais."
                              ],
                              "realWorldApplication": "Na indústria automotiva (ex: fábricas Tesla ou BMW), relacionar princípios robóticos a designs integrados para robôs de soldagem colaborativa, reduzindo tempo de desenvolvimento em 30% via equipes multifuncionais usando V-Model adaptado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "46.1.1.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Componentes Mecatrônicos de Sistemas Robóticos",
                    "description": "Elementos como sensores, atuadores, microcontroladores e estruturas mecânicas em robôs.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Sensores em Sistemas Robóticos",
                        "description": "Componentes que detectam e medem variáveis ambientais ou internas do robô, como posição, velocidade, força e presença de objetos, essenciais para a percepção do ambiente.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar tipos de sensores comuns",
                            "description": "Classificar sensores como ópticos (fotocélulas, câmeras), táteis (botões, encoders), ultrassônicos e infravermelhos, com exemplos de aplicação em robótica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de sensores",
                                  "subSteps": [
                                    "Definir o que é um sensor e sua função principal em sistemas robóticos (detectar e converter estímulos ambientais em sinais elétricos).",
                                    "Explicar a diferença entre sensores analógicos e digitais.",
                                    "Identificar componentes comuns de um sensor: elemento sensível, amplificador e saída.",
                                    "Discutir a importância da calibração e precisão em aplicações robóticas.",
                                    "Revisar classificações gerais de sensores por tipo de entrada (luz, toque, som, etc.)."
                                  ],
                                  "verification": "Resumir em um diagrama simples os componentes de um sensor e listar 3 funções principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro branco ou papel e caneta",
                                    "Vídeo introdutório sobre sensores (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use analogias cotidianas, como os olhos humanos para sensores ópticos, para fixar conceitos.",
                                  "learningObjective": "Entender os fundamentos de sensores para classificar corretamente tipos específicos.",
                                  "commonMistakes": "Confundir sensor com atuador (atuador age, sensor detecta); ignorar a necessidade de calibração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar sensores ópticos e táteis",
                                  "subSteps": [
                                    "Descrever sensores ópticos: fotocélulas (detectam luz/intensidade) e câmeras (visão computacional).",
                                    "Exemplificar aplicações: fotocélula em seguidores de linha, câmera em reconhecimento de objetos.",
                                    "Analisar sensores táteis: botões (pressão simples) e encoders (posição/rotação).",
                                    "Exemplificar: botão para start/stop, encoder em rodas para odometria.",
                                    "Comparar características: alcance, precisão e sensibilidade ambiental."
                                  ],
                                  "verification": "Listar 2 exemplos de cada subtipo e suas aplicações em robótica, com esboço de circuito básico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Imagens ou diagramas de sensores ópticos e táteis",
                                    "Simulador Tinkercad ou Fritzing"
                                  ],
                                  "tips": "Visualize com fotos reais de Arduino para associar teoria à prática.",
                                  "learningObjective": "Classificar e exemplificar sensores ópticos e táteis com precisão.",
                                  "commonMistakes": "Confundir fotocélula com infravermelho (fotocélula é luz visível); achar que encoder é só tátil (mede movimento)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar sensores ultrassônicos e infravermelhos",
                                  "subSteps": [
                                    "Explicar sensores ultrassônicos: uso de ondas sonoras para medir distância (ex: HC-SR04).",
                                    "Detalhar aplicações: detecção de obstáculos em robôs móveis.",
                                    "Descrever sensores infravermelhos: emissão/recepção de IR para proximidade ou linha (ex: TCRT5000).",
                                    "Exemplificar: IR em robôs evitadores de obstáculo, ultrassônico em mapeamento.",
                                    "Comparar limitações: ultrassônico afetado por ar úmido, IR por luz solar."
                                  ],
                                  "verification": "Montar tabela comparativa com alcance, precisão e exemplos para cada sensor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Datasheets de HC-SR04 e TCRT5000 (PDF)",
                                    "Vídeos demonstrativos de montagem"
                                  ],
                                  "tips": "Teste mentalmente: 'O que acontece se o sensor ultrassônico apontar para o teto?' para entender ângulo.",
                                  "learningObjective": "Diferenciar e aplicar sensores de distância baseados em ondas.",
                                  "commonMistakes": "Misturar ultrassônico (som) com infravermelho (luz IR); subestimar interferências ambientais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar classificação e aplicações em robótica",
                                  "subSteps": [
                                    "Classificar uma lista de 10 sensores comuns em categorias (ópticos, táteis, ultrassônicos, IR).",
                                    "Associar cada tipo a pelo menos 2 aplicações robóticas reais.",
                                    "Criar fluxograma de seleção de sensor baseado em necessidade (ex: distância vs. cor).",
                                    "Simular falhas comuns e soluções (ex: sujeira em fotocélula).",
                                    "Discutir integração em sistemas mecatrônicos completos."
                                  ],
                                  "verification": "Quiz autoavaliativo: classificar 5 sensores aleatórios corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de sensores para classificação (impressa)",
                                    "Plataforma Arduino IDE para simulação virtual"
                                  ],
                                  "tips": "Agrupe por 'tipo de onda/estímulo' para memorizar: luz, toque, som, IR.",
                                  "learningObjective": "Aplicar classificação em cenários robóticos práticos.",
                                  "commonMistakes": "Classificar encoder como óptico só (pode ser, mas é tátil por rotação); ignorar contexto robótico."
                                }
                              ],
                              "practicalExample": "Em um robô seguidor de linha com Arduino: fotocélula (óptico) detecta linha preta por reflexão de luz; encoder nas rodas (tátil) mede distância percorrida; sensor ultrassônico frontal evita colisões; IR laterais detectam paredes próximas.",
                              "finalVerifications": [
                                "Classificar corretamente pelo menos 8/10 sensores comuns listados.",
                                "Explicar princípio de funcionamento de cada tipo com um exemplo robótico.",
                                "Montar tabela comparativa de vantagens/desvantagens.",
                                "Identificar sensor ideal para 3 cenários robóticos dados.",
                                "Demonstrar calibração básica de um sensor óptico ou ultrassônico em simulação.",
                                "Listar 3 erros comuns de uso em robótica para cada categoria."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de sensores (90% acerto mínimo).",
                                "Profundidade nos exemplos de aplicação robótica (relevância e variedade).",
                                "Compreensão de limitações e interferências ambientais.",
                                "Capacidade de seleção contextualizada de sensores.",
                                "Clareza na explicação oral ou escrita de princípios.",
                                "Integração de conceitos em fluxogramas ou diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Ondas sonoras (ultrassônico), eletromagnetismo (ópticos e IR).",
                                "Eletrônica: Leitura de sinais analógicos/digitais e interfaces com microcontroladores.",
                                "Programação: Código Arduino para leitura e processamento de dados de sensores.",
                                "Matemática: Cálculo de distâncias e filtros de sinal."
                              ],
                              "realWorldApplication": "Em robôs aspiradores como Roomba (ultrassônicos e IR para navegação e obstáculos), drones para mapeamento aéreo (câmeras ópticas e ultrassônicos) ou braços robóticos industriais (encoders táteis para precisão posicional)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Explicar princípios de funcionamento de sensores",
                            "description": "Descrever como sensores convertem estímulos físicos em sinais elétricos, incluindo linearidade, precisão e ruído, com foco em integração mecatrônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de sensores e transdução",
                                  "subSteps": [
                                    "Definir sensor como dispositivo que converte estímulos físicos em sinais elétricos.",
                                    "Explicar transdução: processo de conversão de energia física (luz, temperatura, pressão) em elétrica.",
                                    "Classificar sensores por tipo de estímulo (ópticos, térmicos, mecânicos).",
                                    "Identificar componentes principais: elemento sensível, amplificador e saída.",
                                    "Estudar exemplos iniciais como fotodiodo e termistor."
                                  ],
                                  "verification": "Explicar em 3 frases o que é transdução e dar um exemplo de sensor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Vídeos introdutórios sobre sensores (YouTube/Khan Academy), diagrama de transdução básica.",
                                  "tips": "Use analogias cotidianas, como termômetro convertendo calor em leitura.",
                                  "learningObjective": "Identificar e descrever o processo fundamental de transdução em sensores.",
                                  "commonMistakes": "Confundir sensor com atuador (que converte elétrico em físico)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar mecanismos de conversão de estímulos físicos em sinais elétricos",
                                  "subSteps": [
                                    "Estudar efeito fotoelétrico em sensores ópticos: fótons geram elétrons.",
                                    "Explicar variação de resistência em sensores resistivos (ex: termistor com temperatura).",
                                    "Descrever mudança de capacitância em sensores capacitivos (ex: proximidade).",
                                    "Analisar piezoelectricidade: pressão gera voltagem.",
                                    "Montar diagrama esquemático de conversão para um sensor específico."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama de conversão para um sensor resistivo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador online (Tinkercad/PhET), folhas de papel e caneta para diagramas.",
                                  "tips": "Comece com equações simples como R = R0 * (1 + αΔT) para termistor.",
                                  "learningObjective": "Mapear mecanismos físicos que produzem sinais elétricos em diferentes sensores.",
                                  "commonMistakes": "Ignorar o papel do amplificador na saída fraca do elemento sensível."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar características de desempenho: linearidade, precisão e ruído",
                                  "subSteps": [
                                    "Definir linearidade: relação proporcional estímulo-saída (gráfico linear).",
                                    "Explicar precisão: proximidade da medida ao valor real (erro sistemático).",
                                    "Analisar ruído: variações aleatórias no sinal (térmico, shot noise).",
                                    "Calcular exemplos: histerese, resolução e faixa dinâmica.",
                                    "Interpretar curvas de calibração com desvios não-lineares."
                                  ],
                                  "verification": "Plotar gráfico de linearidade e identificar ruído em dados simulados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel/Google Sheets para gráficos, dados de sensores reais (datasheets).",
                                  "tips": "Use SNR (Signal-to-Noise Ratio) para quantificar ruído: SNR = 20 log(S/N).",
                                  "learningObjective": "Avaliar e quantificar métricas chave de performance de sensores.",
                                  "commonMistakes": "Confundir precisão com acurácia (precisão é repetibilidade)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar princípios na integração mecatrônica de sensores",
                                  "subSteps": [
                                    "Descrever interfaces: ADC para digitalização do sinal analógico.",
                                    "Explicar filtragem de ruído (média móvel, filtros passa-baixa).",
                                    "Integrar em loop de controle: sensor > microcontrolador > atuador.",
                                    "Analisar impacto de não-linearidades em sistemas robóticos.",
                                    "Simular falhas: ruído excessivo afetando navegação."
                                  ],
                                  "verification": "Desenhar fluxograma de integração de um sensor em um sistema mecatrônico.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Arduino IDE ou simulador (Proteus), datasheet de sensor (ex: HC-SR04).",
                                  "tips": "Teste com código simples: ler sensor e plotar dados seriais.",
                                  "learningObjective": "Integrar sensores em contextos mecatrônicos considerando limitações.",
                                  "commonMistakes": "Subestimar calibração necessária para precisão em aplicações reais."
                                }
                              ],
                              "practicalExample": "Em um robô móvel, um sensor ultrassônico HC-SR04 converte ondas sonoras (eco) em pulsos elétricos via efeito piezoelétrico; analise linearidade na distância medida (2-400cm), precisão (±3mm) e ruído de vibrações, integrando via Arduino para evitar colisões.",
                              "finalVerifications": [
                                "Diagramar completo processo de transdução de um sensor escolhido.",
                                "Explicar verbalmente linearidade, precisão e ruído com exemplos numéricos.",
                                "Identificar 3 fontes de ruído em um sistema mecatrônico.",
                                "Montar esquema de integração sensor-microcontrolador.",
                                "Calcular SNR para dados simulados de sensor.",
                                "Discutir impacto de não-linearidade em robótica."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual de transdução (0-5 pontos).",
                                "Correta distinção e exemplos de linearidade/precisão/ruído (0-5).",
                                "Qualidade de diagramas e fluxogramas (0-5).",
                                "Profundidade na integração mecatrônica (0-5).",
                                "Uso correto de termos técnicos e equações (0-5).",
                                "Criatividade em exemplos práticos (0-5)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de eletromagnetismo e ondas.",
                                "Matemática: Análise gráfica de funções lineares e estatística de ruído.",
                                "Programação: Leitura de dados analógicos via ADC em microcontroladores.",
                                "Engenharia de Controle: Feedback com sensores em laços fechados."
                              ],
                              "realWorldApplication": "Sensores em veículos autônomos (LIDAR para mapeamento preciso apesar de ruído), drones para estabilização (giroscópios com alta linearidade) e linhas de produção industriais (sensores de proximidade para automação mecatrônica segura)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Aplicar sensores em projetos robóticos",
                            "description": "Selecionar e integrar sensores para tarefas como navegação autônoma ou detecção de obstáculos, considerando interfaces com microcontroladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar requisitos e selecionar sensores adequados",
                                  "subSteps": [
                                    "Analise a tarefa robótica (ex: detecção de obstáculos ou navegação).",
                                    "Liste parâmetros necessários (alcance, precisão, ambiente).",
                                    "Pesquise tipos de sensores (ultrassônico, infravermelho, LIDAR).",
                                    "Compare especificações de sensores disponíveis (datasheets).",
                                    "Selecione o sensor ideal e justifique a escolha."
                                  ],
                                  "verification": "Documente uma tabela de comparação com o sensor escolhido destacado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Datasheets de sensores",
                                    "Planilha ou documento de comparação"
                                  ],
                                  "tips": "Priorize sensores com boa relação custo-benefício e compatibilidade com o microcontrolador.",
                                  "learningObjective": "Compreender como mapear requisitos a sensores específicos.",
                                  "commonMistakes": [
                                    "Ignorar condições ambientais como luz ou umidade",
                                    "Escolher sensor sem verificar interface (I2C, analogico)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conectar o sensor ao microcontrolador",
                                  "subSteps": [
                                    "Verifique pinagem do sensor e microcontrolador (ex: Arduino, Raspberry Pi).",
                                    "Monte o circuito em protoboard ou PCB (inclua resistores/pull-ups se necessário).",
                                    "Conecte alimentação (VCC, GND) e sinais (SDA/SCL para I2C, analogico para HC-SR04).",
                                    "Adicione capacitores de desacoplamento para estabilidade.",
                                    "Teste continuidade com multímetro."
                                  ],
                                  "verification": "Meça tensões nos pinos com multímetro e confirme ausência de curtos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Microcontrolador (ex: Arduino Uno)",
                                    "Sensor (ex: HC-SR04 ultrassônico)",
                                    "Protoboard, fios jumper, multímetro"
                                  ],
                                  "tips": "Use diagramas Fritzing para visualizar conexões antes de montar.",
                                  "learningObjective": "Dominar interfaces elétricas entre sensores e microcontroladores.",
                                  "commonMistakes": [
                                    "Inverter VCC/GND",
                                    "Esquecer pull-ups em I2C",
                                    "Exceder corrente do microcontrolador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Programar a leitura e processamento de dados do sensor",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias (ex: NewPing para HC-SR04).",
                                    "Escreva código para inicializar o sensor e ler dados em loop.",
                                    "Implemente calibração e filtros (média móvel para ruído).",
                                    "Adicione mapeamento de dados (distância em cm para ação).",
                                    "Teste com Serial Monitor exibindo valores reais."
                                  ],
                                  "verification": "Serial Monitor mostra leituras consistentes e precisas (varie distância manualmente).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "IDE Arduino ou PlatformIO",
                                    "Computador com USB"
                                  ],
                                  "tips": "Use delay() mínimo para evitar sobrecarga; prefira millis() para não-bloqueante.",
                                  "learningObjective": "Desenvolver firmware para aquisição e tratamento de sinais sensoriais.",
                                  "commonMistakes": [
                                    "Não calibrar offsets",
                                    "Ignorar debounce para sensores digitais",
                                    "Loop bloqueante"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, testar e otimizar o sensor no projeto robótico",
                                  "subSteps": [
                                    "Integre o código do sensor ao controle principal do robô (ex: PID para navegação).",
                                    "Teste em cenários reais (obstáculos móveis, superfícies variadas).",
                                    "Colete dados de performance e ajuste thresholds.",
                                    "Implemente fusão de sensores se múltiplos (ex: ultrassônico + IR).",
                                    "Documente o sistema e simule falhas."
                                  ],
                                  "verification": "Robô responde corretamente a estímulos em 95% dos testes (log de 20 trials).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Robô base com motores",
                                    "Obstáculos de teste",
                                    "Osciloscópio opcional"
                                  ],
                                  "tips": "Grave vídeos de testes para análise posterior.",
                                  "learningObjective": "Aplicar sensores em sistemas robóticos completos com depuração.",
                                  "commonMistakes": [
                                    "Testar só em condições ideais",
                                    "Sobrecarregar loop principal",
                                    "Não considerar latência"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um robô evitador de obstáculos: integre sensor HC-SR04 ao Arduino, programe para parar/frear a 20cm de parede, testando em labirinto simples.",
                              "finalVerifications": [
                                "Sensor detecta objetos em faixa especificada com precisão ±5cm.",
                                "Integração não causa crashes ou resets no microcontrolador.",
                                "Resposta do robô é suave sem oscilações excessivas.",
                                "Dados calibrados em diferentes ambientes (luz, som).",
                                "Código comentado e modular para reutilização.",
                                "Relatório de testes com métricas quantitativas."
                              ],
                              "assessmentCriteria": [
                                "Seleção de sensor justificada e otimizada (30%)",
                                "Circuito montado sem erros elétricos (20%)",
                                "Código funcional, eficiente e bem documentado (25%)",
                                "Testes abrangentes com otimização (15%)",
                                "Integração holística no projeto robótico (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de ondas ultrassônicas e reflexão.",
                                "Programação: Algoritmos de controle e filtros digitais.",
                                "Eletrônica: Protocolos de comunicação (I2C, UART).",
                                "Matemática: Cálculo de distâncias e estatística para calibração."
                              ],
                              "realWorldApplication": "Em robôs aspiradores como Roomba para mapeamento de ambientes, drones para evasão de colisões, ou veículos autônomos para sensores LIDAR em navegação urbana."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Atuadores em Sistemas Robóticos",
                        "description": "Elementos que convertem sinais elétricos em movimento ou força mecânica, como motores e cilindros, fundamentais para a ação e manipulação no robô.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Classificar tipos de atuadores",
                            "description": "Diferenciar motores DC, passo a passo, servomotores, pneumáticos e hidráulicos, destacando torque, velocidade e controle em robótica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de atuadores",
                                  "subSteps": [
                                    "Pesquisar a definição de atuador e seu papel em sistemas robóticos.",
                                    "Estudar as métricas chave: torque (força rotacional), velocidade (RPM ou taxa de movimento) e tipos de controle (posição, velocidade ou força).",
                                    "Assistir a um vídeo introdutório sobre atuadores em robótica.",
                                    "Anotar exemplos de aplicações iniciais para cada métrica.",
                                    "Criar um glossário pessoal com definições."
                                  ],
                                  "verification": "Capacidade de explicar torque, velocidade e controle em uma frase cada, sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Internet, vídeo no YouTube sobre 'atuadores robótica', caderno para anotações.",
                                  "tips": "Use analogias: torque como força para girar uma chave, velocidade como quão rápido ela gira.",
                                  "learningObjective": "Dominar as métricas essenciais para comparar atuadores.",
                                  "commonMistakes": "Confundir torque com potência total ou velocidade com aceleração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar motores elétricos DC e suas características",
                                  "subSteps": [
                                    "Pesquisar funcionamento de motores DC: rotação contínua via corrente contínua.",
                                    "Identificar características: alto torque em baixas velocidades, controle via PWM para velocidade.",
                                    "Estudar diagrama de um motor DC e suas conexões.",
                                    "Comparar variações (brushed vs brushless).",
                                    "Simular controle básico com Arduino (se disponível)."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama simples de motor DC com torque/velocidade indicados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Internet, imagens/diagramas de motores DC, software Tinkercad para simulação.",
                                  "tips": "Lembre-se: DC é versátil e barato, ideal para rodas de robôs móveis.",
                                  "learningObjective": "Diferenciar motor DC por torque inicial alto e controle simples de velocidade.",
                                  "commonMistakes": "Ignorar perdas de eficiência em altas velocidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar motores de passo e servomotores",
                                  "subSteps": [
                                    "Explicar motor de passo: movimento em passos discretos para precisão posicional.",
                                    "Analisar servomotores: controle angular preciso via sinal PWM.",
                                    "Comparar torque (médio em passo, preciso em servo) e velocidade (baixa em passo, controlada em servo).",
                                    "Assistir demonstração de controle de stepper e servo.",
                                    "Listar comandos típicos em programação (ex: biblioteca Stepper no Arduino)."
                                  ],
                                  "verification": "Explicar diferença entre passo e servo com exemplo de aplicação robótica.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Vídeos tutoriais Arduino, diagramas de stepper/servo.",
                                  "tips": "Stepper para impressoras 3D; servo para braços robóticos.",
                                  "learningObjective": "Classificar atuadores de precisão posicional.",
                                  "commonMistakes": "Confundir controle de posição de servo com rotação ilimitada de DC."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar atuadores pneumáticos e hidráulicos",
                                  "subSteps": [
                                    "Descrever pneumáticos: uso de ar comprimido para movimento linear/rápido.",
                                    "Analisar hidráulicos: fluido oleoso para alto torque e força.",
                                    "Comparar: pneumático (alta velocidade, baixo torque preciso), hidráulico (alto torque, velocidade média).",
                                    "Estudar componentes: cilindros, válvulas e compressores.",
                                    "Pesquisar exemplos em robótica industrial."
                                  ],
                                  "verification": "Criar tabela resumida com torque/velocidade/controle para pneumático e hidráulico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Internet, imagens de cilindros pneumáticos/hidráulicos.",
                                  "tips": "Pense em pneumático para pinças rápidas; hidráulico para prensas pesadas.",
                                  "learningObjective": "Diferenciar atuadores não-elétricos por meio de transmissão.",
                                  "commonMistakes": "Subestimar necessidade de manutenção em sistemas fluidos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e classificar todos os tipos de atuadores",
                                  "subSteps": [
                                    "Criar tabela comparativa: colunas para tipo, torque, velocidade, controle, prós/contras.",
                                    "Classificar atuadores por cenários robóticos (ex: mobilidade vs precisão).",
                                    "Simular escolha de atuador para um projeto simples.",
                                    "Revisar anotações anteriores para integração.",
                                    "Testar conhecimento com quiz online sobre atuadores."
                                  ],
                                  "verification": "Preencher tabela completa sem consultar fontes e explicar 3 escolhas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel/Google Sheets, quiz online sobre atuadores.",
                                  "tips": "Use cores na tabela para destacar forças (verde torque alto).",
                                  "learningObjective": "Classificar atuadores com base em requisitos robóticos.",
                                  "commonMistakes": "Generalizar sem considerar contexto (ex: custo vs performance)."
                                }
                              ],
                              "practicalExample": "Em um robô de linha de montagem, classifique e escolha: motor DC para rodas de transporte rápido (alta velocidade), servo para posicionamento preciso de peças (controle angular), hidráulico para prensagem forte (alto torque). Crie uma tabela e justifique.",
                              "finalVerifications": [
                                "Lista corretamente os 5 tipos de atuadores (DC, passo, servo, pneumático, hidráulico).",
                                "Descreve torque, velocidade e controle para cada tipo sem erros.",
                                "Cria tabela comparativa com pelo menos 4 colunas precisas.",
                                "Explica escolha de atuador para 2 cenários robóticos diferentes.",
                                "Identifica prós/contras de cada tipo.",
                                "Responde quiz com 90% de acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de características (torque, velocidade, controle) - 30%.",
                                "Completude da tabela comparativa e classificações - 25%.",
                                "Capacidade de aplicar em exemplos práticos - 20%.",
                                "Clareza e organização das explicações - 15%.",
                                "Identificação correta de erros comuns evitados - 10%."
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de mecânica rotacional, fluidos e eletricidade.",
                                "Eletrônica: Controle PWM e circuitos de acionamento.",
                                "Matemática: Cálculos de torque (τ = F × r) e conversão de unidades.",
                                "Programação: Bibliotecas para controle de servos e steppers.",
                                "Engenharia: Seleção de componentes em design de sistemas."
                              ],
                              "realWorldApplication": "Na indústria automotiva, hidráulicos em robôs de solda para alto torque; em drones, motores DC leves para velocidade; servos em próteses robóticas para controle preciso de movimentos humanos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Analisar controle de atuadores",
                            "description": "Explicar técnicas de controle como PWM para motores e feedback de posição, com exemplos de aplicações industriais aeronáuticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios básicos de atuadores e técnicas de controle",
                                  "subSteps": [
                                    "Identificar tipos de atuadores comuns em robótica, como motores DC, servomotores e steppers.",
                                    "Explicar a diferença entre controle aberto e fechado (com feedback).",
                                    "Descrever o papel do PWM (Pulse Width Modulation) como técnica de controle de potência.",
                                    "Analisar a importância do feedback para precisão em sistemas mecatrônicos.",
                                    "Estudar diagramas de blocos de sistemas de controle básicos."
                                  ],
                                  "verification": "Criar um diagrama de blocos de um sistema de controle simples e explicá-lo oralmente ou por escrito.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro-texto de mecatrônica, software de desenho como Draw.io, vídeos tutoriais sobre PWM.",
                                  "tips": "Comece com analogias cotidianas, como dimmer de luz para PWM, para fixar conceitos.",
                                  "learningObjective": "Entender os fundamentos teóricos de atuadores e controle para análise posterior.",
                                  "commonMistakes": "Confundir PWM com variação de tensão contínua; PWM varia duty cycle, não tensão média diretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o controle PWM para motores",
                                  "subSteps": [
                                    "Calcular duty cycle para controlar velocidade e torque de motores DC.",
                                    "Simular PWM em software como MATLAB/Simulink ou Tinkercad.",
                                    "Implementar PWM em microcontrolador (ex: Arduino) para um motor simples.",
                                    "Medir resposta do motor (velocidade vs. duty cycle) com tacômetro ou osciloscópio.",
                                    "Otimizar frequência PWM para minimizar ruído e vibrações."
                                  ],
                                  "verification": "Gerar gráfico de velocidade do motor vs. duty cycle e discutir resultados.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Arduino ou simulador online (Tinkercad), motor DC pequeno, multímetro, protoboard.",
                                  "tips": "Use frequências acima de 1kHz para audibilidade baixa em aplicações reais.",
                                  "learningObjective": "Aplicar PWM na prática para controle preciso de atuadores rotativos.",
                                  "commonMistakes": "Escolher frequência PWM muito baixa, causando ruído audível e perda de eficiência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar feedback de posição em atuadores",
                                  "subSteps": [
                                    "Estudar sensores de posição: encoders incrementais/absolutos, potenciômetros e resolvers.",
                                    "Configurar loop de feedback PID básico para correção de posição.",
                                    "Integrar encoder com microcontrolador e testar precisão de posicionamento.",
                                    "Analisar erros de histerese e backlash em sistemas reais.",
                                    "Simular sistema com feedback em software para prever comportamento."
                                  ],
                                  "verification": "Executar teste onde atuador atinge posição alvo com erro < 1 grau, registrando dados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Servomotor com encoder, Arduino, osciloscópio ou software de monitoramento serial.",
                                  "tips": "Calibre o encoder no início para zero preciso e evite sobrecarga no loop PID.",
                                  "learningObjective": "Integrar feedback para controle fechado estável e preciso.",
                                  "commonMistakes": "Ignorar ruído no sinal do encoder, levando a oscilações; filtre adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar aplicações industriais aeronáuticas",
                                  "subSteps": [
                                    "Pesquisar casos reais: controle de flaps, slats e trem de pouso em aeronaves.",
                                    "Comparar PWM + feedback em drones vs. aviões comerciais (ex: Boeing 787).",
                                    "Avaliar requisitos de redundância e certificação (DO-178C).",
                                    "Calcular desempenho: tempo de resposta, precisão e confiabilidade.",
                                    "Discutir falhas potenciais e mitigações (ex: watchdog timers)."
                                  ],
                                  "verification": "Elaborar relatório com 2 exemplos aeronáuticos, incluindo diagramas e cálculos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Artigos técnicos (IEEE, FAA docs), vídeos de sistemas fly-by-wire.",
                                  "tips": "Foque em métricas como MTBF (Mean Time Between Failures) para contexto industrial.",
                                  "learningObjective": "Conectar teoria à prática industrial aeronáutica.",
                                  "commonMistakes": "Subestimar vibrações aeronáuticas; considere filtros e amortecedores."
                                }
                              ],
                              "practicalExample": "Em um drone de inspeção aeronáutica, usar PWM para controlar a velocidade de um servomotor que ajusta a câmera (gimbal), com encoder óptico fornecendo feedback de posição para manter ângulo preciso apesar de vibrações do voo.",
                              "finalVerifications": [
                                "Explicar PWM e seu impacto em torque/velocidade com equações.",
                                "Montar e testar circuito PWM + feedback com precisão < 2%.",
                                "Desenhar laço de controle para aplicação aeronáutica.",
                                "Identificar 3 falhas comuns e soluções.",
                                "Calcular duty cycle para velocidade alvo em motor DC.",
                                "Discutir normas de segurança aeronáutica (ex: RTCA DO-160)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (80% correto em explicações teóricas).",
                                "Qualidade da implementação prática (funcionamento sem erros).",
                                "Profundidade da análise aeronáutica (exemplos reais citados).",
                                "Criatividade em verificações e otimizações.",
                                "Clareza em relatórios e diagramas.",
                                "Integração de feedback (estabilidade demonstrada)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Circuitos de potência e sensores.",
                                "Física: Dinâmica rotacional e controle proporcional.",
                                "Programação: Algoritmos PID em C++/Arduino.",
                                "Engenharia Aeronáutica: Sistemas fly-by-wire.",
                                "Matemática: Análise de sinais e transformadas de Fourier para PWM."
                              ],
                              "realWorldApplication": "No controle de superfícies aerodinâmicas de aviões comerciais, como ailerons em um Airbus A350, onde PWM modula atuadores hidráulicos/elétricos e encoders garantem posicionamento preciso para manobras seguras, reduzindo peso e consumo de combustível."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Dimensionar atuadores para projetos",
                            "description": "Calcular potência e torque necessários para atuadores em sistemas robóticos, considerando eficiência e integração mecatrônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Requisitos Cinemáticos e Dinâmicos do Projeto",
                                  "subSteps": [
                                    "Analise o movimento desejado: velocidade linear/angular, aceleração e carga (massa/força).",
                                    "Defina o raio ou comprimento de alavanca para conversão de torque.",
                                    "Estime ciclos de operação e duty cycle (tempo ligado/desligado).",
                                    "Registre forças gravitacionais, de inércia e atrito no sistema.",
                                    "Crie um diagrama esquemático do mecanismo com vetores de força."
                                  ],
                                  "verification": "Checklist completo de requisitos com valores numéricos e diagrama aprovado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou software de desenho (ex: Draw.io)",
                                    "Especificações do projeto robótico"
                                  ],
                                  "tips": [
                                    "Comece com valores conservadores para cargas; use fotos ou vídeos de sistemas semelhantes como referência."
                                  ],
                                  "learningObjective": "Compreender como traduzir especificações funcionais em parâmetros físicos mensuráveis.",
                                  "commonMistakes": [
                                    "Ignorar atrito ou inércia dinâmica",
                                    "Subestimar massa total do sistema móvel"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Torque Necessário",
                                  "subSteps": [
                                    "Calcule torque de carga: τ_carga = F × r, onde F é força e r é raio.",
                                    "Adicione torque de aceleração: τ_acel = I × α, com I momento de inércia e α aceleração angular.",
                                    "Some torque de atrito: τ_atrito = μ × F_n × r.",
                                    "Aplique fator de segurança: τ_total = (τ_carga + τ_acel + τ_atrito) × SF (SF=1.5-2).",
                                    "Verifique unidades: Nm para torque."
                                  ],
                                  "verification": "Cálculos revisados com unidades corretas e valores plausíveis comparados a tabelas de referência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou software (ex: MATLAB, Python com SymPy)",
                                    "Tabelas de momentos de inércia padrão"
                                  ],
                                  "tips": [
                                    "Use aproximações para formas geométricas simples; teste com cenários extremos."
                                  ],
                                  "learningObjective": "Dominar fórmulas de torque estático e dinâmico aplicadas a atuadores.",
                                  "commonMistakes": [
                                    "Esquecer fator de segurança",
                                    "Confundir torque com força linear"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Potência Necessária",
                                  "subSteps": [
                                    "Calcule potência: P = τ_total × ω, onde ω é velocidade angular (rad/s).",
                                    "Considere potência de pico vs. contínua baseada no duty cycle.",
                                    "Converta para unidades de potência elétrica: P_elétrica = P_mecânica / η (η=e eficiência).",
                                    "Estime perdas térmicas e correntes de partida.",
                                    "Compare com curvas de desempenho de motores candidatos."
                                  ],
                                  "verification": "Gráfico de potência vs. velocidade gerado e torque/potência dentro de limites operacionais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilhas Excel ou Python (NumPy)",
                                    "Datasheets de motores DC/servo/stepper"
                                  ],
                                  "tips": [
                                    "ω = 2π n /60 para RPM; priorize motores com margem de 20% na potência."
                                  ],
                                  "learningObjective": "Relacionar torque, velocidade e potência com eficiência energética.",
                                  "commonMistakes": [
                                    "Usar RPM em vez de rad/s",
                                    "Ignorar eficiência do redutor/embalagem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar por Eficiência e Integrar na Mecatrônica",
                                  "subSteps": [
                                    "Calcule eficiência total: η_total = η_motor × η_redução × η_transmissão.",
                                    "Selecione atuador com τ_stall > 2×τ_total e P_contínua adequada.",
                                    "Avalie integração: tamanho, peso, fixação, encoder/feedback.",
                                    "Simule no software (ex: Simulink ou Gazebo) para validar.",
                                    "Documente trade-offs (custo vs. performance)."
                                  ],
                                  "verification": "Simulação rodando sem sobrecarga e relatório de seleção com justificativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB Simulink, ROS/Gazebo)",
                                    "Catálogos de fornecedores (ex: Maxon, Faulhaber)"
                                  ],
                                  "tips": [
                                    "Prefira servos para precisão; steppers para torque holding baixo custo."
                                  ],
                                  "learningObjective": "Otimizar seleção considerando sistema mecatrônico integrado.",
                                  "commonMistakes": [
                                    "Sobredimensionar levando a ineficiência",
                                    "Não considerar backlash ou vibrações"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Otimizar o Dimensionamento",
                                  "subSteps": [
                                    "Construa protótipo parcial ou teste em bancada.",
                                    "Meça torque/potência real com dinamômetro ou sensores.",
                                    "Ajuste parâmetros baseados em dados empíricos.",
                                    "Calcule margem de segurança final e eficiência medida.",
                                    "Gere relatório com todos os cálculos e lições aprendidas."
                                  ],
                                  "verification": "Testes empíricos confirmam cálculos teóricos (±10% de erro).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Sensores de torque/força (ex: strain gauge)",
                                    "Multímetro, osciloscópio",
                                    "Protótipo básico"
                                  ],
                                  "tips": [
                                    "Registre dados em tempo real; itere se necessário."
                                  ],
                                  "learningObjective": "Aplicar validação experimental ao dimensionamento teórico.",
                                  "commonMistakes": [
                                    "Pular testes por 'confiança nos cálculos'",
                                    "Não calibrar sensores"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um braço robótico que levanta 1kg a 30cm em 2 segundos: calcule torque ≈ 0.3Nm (gravidade + inércia), potência ≈ 5W a 50RPM, selecione motor DC 12V 10W com redutor 10:1 e eficiência 70%, validado em simulação.",
                              "finalVerifications": [
                                "Torque e potência calculados atendem requisitos com fator de segurança >1.5.",
                                "Eficiência total >60% e integração física viável.",
                                "Simulação confirma performance sem sobrecarga térmica.",
                                "Seleção de atuador matches datasheets e orçamento.",
                                "Relatório documenta todos cálculos e trade-offs.",
                                "Teste protótipo valida teoria (±15% erro aceitável)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: fórmulas corretas e unidades consistentes (30%).",
                                "Consideração de eficiência e segurança: perdas e SF incluídos (25%).",
                                "Seleção realista: atuador comercial viável (20%).",
                                "Integração mecatrônica: peso, tamanho, controle (15%).",
                                "Documentação e validação: clara e com sim/testes (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica newtoniana, energia e potência.",
                                "Matemática: Cálculo diferencial (aceleração), vetores.",
                                "Eletrônica: Características de motores e drivers.",
                                "Programação: Simulações em Python/MATLAB para otimização.",
                                "Engenharia de Materiais: Seleção de redutores e engrenagens."
                              ],
                              "realWorldApplication": "Em linhas de montagem robóticas (ex: braços da ABB), drones para payload preciso, próteses biomecânicas e veículos autônomos, garantindo eficiência energética e confiabilidade em operação contínua."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Microcontroladores e CLPs",
                        "description": "Unidades de processamento que controlam sensores e atuadores, incluindo microcontroladores como Arduino e CLPs para automação industrial.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Comparar microcontroladores e CLPs",
                            "description": "Diferenciar arquiteturas, linguagens de programação (C/Arduino vs ladder logic) e aplicações em robótica mecatrônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e documentar características fundamentais dos microcontroladores",
                                  "subSteps": [
                                    "Identificar definição e componentes principais (CPU, memória, I/O pins)",
                                    "Estudar arquiteturas comuns (ex: AVR no Arduino, ARM em ESP32)",
                                    "Listar linguagens de programação suportadas (C/C++, Arduino IDE)",
                                    "Documentar aplicações típicas em robótica (controle de sensores, atuadores)",
                                    "Coletar exemplos de microcontroladores populares (Arduino Uno, Raspberry Pi Pico)"
                                  ],
                                  "verification": "Criar um documento ou mindmap com pelo menos 10 características listadas e fontes citadas",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Computador com internet",
                                    "Documentação Arduino oficial",
                                    "Vídeos tutoriais sobre microcontroladores"
                                  ],
                                  "tips": "Use tabelas para organizar informações; foque em aspectos relevantes para robótica mecatrônica",
                                  "learningObjective": "Compreender a arquitetura e capacidades básicas dos microcontroladores",
                                  "commonMistakes": [
                                    "Confundir microcontroladores com microprocessadores",
                                    "Ignorar limitações de memória e processamento",
                                    "Não citar fontes confiáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar e documentar características fundamentais dos CLPs",
                                  "subSteps": [
                                    "Definir CLP (Controlador Lógico Programável) e seus componentes (CPU, módulos I/O, rack)",
                                    "Analisar arquiteturas típicas (scan cycle, ladder logic execution)",
                                    "Explorar linguagens de programação (Ladder Logic, FBD, STL)",
                                    "Listar aplicações industriais em robótica (controle de linhas de produção, segurança)",
                                    "Exemplificar CLPs comuns (Siemens S7, Allen-Bradley PLC)"
                                  ],
                                  "verification": "Produzir um documento ou mindmap paralelo ao do Step 1 com pelo menos 10 características",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Computador com internet",
                                    "Manuais de CLPs Siemens/Allen-Bradley",
                                    "Simuladores gratuitos como PLC Fiddle"
                                  ],
                                  "tips": "Compare o ciclo de scan dos CLPs com loops em microcontroladores desde já",
                                  "learningObjective": "Dominar a estrutura e programação dos CLPs em contextos industriais",
                                  "commonMistakes": [
                                    "Subestimar robustez industrial dos CLPs",
                                    "Confundir linguagens gráficas com textuais",
                                    "Omitir certificações de segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar arquiteturas e linguagens de programação",
                                  "subSteps": [
                                    "Criar tabela comparativa de arquiteturas (processador, memória, I/O, robustez)",
                                    "Analisar diferenças em linguagens (C/Arduino vs Ladder Logic: textual vs gráfica)",
                                    "Destacar prós/contras: flexibilidade de microcontroladores vs determinismo de CLPs",
                                    "Simular um loop simples em Arduino IDE e Ladder Logic",
                                    "Identificar cenários onde uma supera a outra (prototipagem vs produção)"
                                  ],
                                  "verification": "Gerar tabela comparativa com pelo menos 8 categorias e simulações executadas",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Arduino IDE",
                                    "Simulador Ladder Logic online (ex: PLC Simulator)",
                                    "Planilha Excel ou Google Sheets"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar diferenças no ciclo de execução",
                                  "learningObjective": "Diferenciar tecnicamente arquiteturas e linguagens para escolhas informadas",
                                  "commonMistakes": [
                                    "Ignorar tempo real vs não real-time",
                                    "Generalizar sem exemplos concretos",
                                    "Não testar simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar aplicações em robótica mecatrônica e sintetizar comparação",
                                  "subSteps": [
                                    "Mapear aplicações: microcontroladores em robôs hobby/protótipos; CLPs em robótica industrial",
                                    "Discutir integração (ex: microcontrolador para visão + CLP para controle)",
                                    "Criar relatório final com recomendações por cenário",
                                    "Avaliar custos, escalabilidade e manutenção",
                                    "Preparar apresentação ou infográfico resumido"
                                  ],
                                  "verification": "Produzir relatório de 1-2 páginas com tabela final e 3 cenários recomendados",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Ferramentas de edição (Word/Google Docs)",
                                    "Exemplos de projetos robóticos reais"
                                  ],
                                  "tips": "Priorize robótica mecatrônica: pense em braços robóticos ou AGVs",
                                  "learningObjective": "Aplicar comparação a contextos reais de robótica para decisões práticas",
                                  "commonMistakes": [
                                    "Focar só em teoria sem aplicações",
                                    "Não considerar híbridos microcontrolador+CLP",
                                    "Relatório desorganizado"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um braço robótico mecatrônico: use Arduino (microcontrolador) para protótipo rápido com sensores via C++; migre para CLP Siemens com Ladder Logic para produção industrial, garantindo scan cycle determinístico e segurança SIL3.",
                              "finalVerifications": [
                                "Lista precisa de 5 diferenças chave em arquiteturas",
                                "Explicação correta de Ladder Logic vs C/Arduino com exemplos",
                                "Tabela comparativa completa com aplicações em robótica",
                                "Identificação de 3 cenários ideais para cada tecnologia",
                                "Simulações executadas sem erros",
                                "Relatório sintetizando prós/contras"
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas descrições (arquiteturas, linguagens)",
                                "Profundidade da comparação (múltiplas dimensões cobertas)",
                                "Uso de exemplos práticos e simulações",
                                "Clareza e organização (tabelas, diagramas)",
                                "Conexão explícita com robótica mecatrônica",
                                "Ausência de erros comuns identificados"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Comparação de paradigmas imperativos vs lógicos",
                                "Eletrônica: Integração de I/O e sensores/atuadores",
                                "Engenharia de Software: Ciclo de vida (prototipagem vs deploy industrial)",
                                "Gestão de Projetos: Escolha de ferramentas por custo/escalabilidade"
                              ],
                              "realWorldApplication": "Na indústria automotiva, microcontroladores como ESP32 controlam protótipos de veículos autônomos, enquanto CLPs gerenciam linhas de montagem robóticas, otimizando eficiência e segurança em fábricas como as da Tesla ou Volkswagen."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Programar microcontroladores básicos",
                            "description": "Desenvolver código simples para leitura de sensores e controle de atuadores, usando IDEs como Arduino IDE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento",
                                  "subSteps": [
                                    "Baixar e instalar a Arduino IDE do site oficial.",
                                    "Conectar o microcontrolador (ex: Arduino Uno) via USB e instalar drivers necessários.",
                                    "Selecionar a placa correta no menu Tools > Board e a porta COM no Tools > Port.",
                                    "Testar a conexão abrindo o Serial Monitor.",
                                    "Verificar se o LED onboard pisca com o exemplo Blink carregado."
                                  ],
                                  "verification": "Arduino IDE reconhece a placa e carrega o sketch Blink sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Computador com Windows/Linux/Mac",
                                    "Arduino Uno ou similar",
                                    "Cabo USB",
                                    "Arduino IDE"
                                  ],
                                  "tips": [
                                    "Use a versão mais recente da IDE para compatibilidade.",
                                    "Desative antivírus temporariamente se houver problemas de porta."
                                  ],
                                  "learningObjective": "Configurar hardware e software para programação de microcontroladores.",
                                  "commonMistakes": [
                                    "Selecionar placa ou porta errada",
                                    "Não instalar drivers CH340/FTDI",
                                    "Conectar cabo USB defeituoso"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender e implementar estrutura básica de código",
                                  "subSteps": [
                                    "Estudar funções setup() e loop().",
                                    "Configurar pinos como input/output com pinMode().",
                                    "Usar digitalWrite() e delay() para controlar LED.",
                                    "Adicionar comentários e variáveis para clareza.",
                                    "Compilar e carregar o código no microcontrolador."
                                  ],
                                  "verification": "LED pisca a cada 1 segundo conforme o código.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Arduino Uno",
                                    "LED externo opcional",
                                    "Protoboard",
                                    "Jumpers"
                                  ],
                                  "tips": [
                                    "Sempre use const int para pinos.",
                                    "Teste em modo verbose para depuração."
                                  ],
                                  "learningObjective": "Dominar a estrutura fundamental de sketches Arduino.",
                                  "commonMistakes": [
                                    "Confundir setup() com loop()",
                                    "Esquecer pinMode()",
                                    "Usar delay() excessivo bloqueando o loop"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Programar leitura de sensores analógicos e digitais",
                                  "subSteps": [
                                    "Conectar um sensor (ex: potenciômetro) ao pino A0.",
                                    "Usar analogRead() para capturar valores (0-1023).",
                                    "Mapear valores com map() para faixas úteis (ex: 0-100).",
                                    "Exibir leituras no Serial Monitor com Serial.print().",
                                    "Adicionar calibração básica comparando com multímetro."
                                  ],
                                  "verification": "Valores do sensor variam corretamente no Serial Monitor ao girar o potenciômetro.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Potenciômetro 10kΩ",
                                    "Protoboard",
                                    "Jumpers",
                                    "Multímetro opcional"
                                  ],
                                  "tips": [
                                    "Use Serial.begin(9600) no setup().",
                                    "Leia múltiplas vezes e faça média para estabilidade."
                                  ],
                                  "learningObjective": "Capturar e processar dados de sensores em tempo real.",
                                  "commonMistakes": [
                                    "Conectar sensor em pino digital ao invés de analógico",
                                    "Não inicializar Serial",
                                    "Ignorar ruído nos sensores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Controlar atuadores baseados em leituras de sensores",
                                  "subSteps": [
                                    "Conectar um LED ou servo ao pino PWM (ex: pino 9).",
                                    "Usar if/else para lógica: se sensor > threshold, ativar atuador.",
                                    "Implementar analogWrite() para PWM em atuadores.",
                                    "Integrar sensor e atuador em um loop condicional.",
                                    "Testar thresholds e ajustar com Serial Monitor."
                                  ],
                                  "verification": "Atuador responde corretamente às mudanças no sensor (ex: LED acende quando potenciômetro > 512).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "LED + resistor 220Ω",
                                    "Servo SG90 opcional",
                                    "Protoboard",
                                    "Jumpers"
                                  ],
                                  "tips": [
                                    "Use thresholds com histerese para evitar oscilações.",
                                    "Comente o código explicando a lógica."
                                  ],
                                  "learningObjective": "Implementar controle reativo baseado em feedback sensorial.",
                                  "commonMistakes": [
                                    "Resistor errado causando queima de LED",
                                    "Lógica invertida no if",
                                    "PWM em pino não-PWM"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Depurar, otimizar e documentar o projeto",
                                  "subSteps": [
                                    "Usar Serial.print() para debug de variáveis.",
                                    "Identificar e corrigir erros comuns como wiring ou lógica.",
                                    "Otimizar código removendo delays desnecessários.",
                                    "Adicionar funções personalizadas para modularidade.",
                                    "Documentar o código com comentários e diagrama Fritzing."
                                  ],
                                  "verification": "Projeto roda estável por 10 minutos sem falhas, código comentado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Fritzing software",
                                    "Câmera para fotos do circuito"
                                  ],
                                  "tips": [
                                    "Sempre reset a placa após upload.",
                                    "Backup do código em .ino."
                                  ],
                                  "learningObjective": "Aplicar boas práticas de depuração e manutenção de código embarcado.",
                                  "commonMistakes": [
                                    "Não flush Serial buffer",
                                    "Código spaghetti sem funções",
                                    "Ignorar warnings do compilador"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um alarme simples: um sensor de luz (LDR) lê a luminosidade; se abaixo de 300, acende um LED vermelho e ativa um buzzer por 2 segundos, demonstrando leitura, lógica e controle integrado.",
                              "finalVerifications": [
                                "Código compila e carrega sem erros.",
                                "Sensor responde linearmente a estímulos (valores variam 0-1023).",
                                "Atuador ativa/desativa baseado em threshold correto.",
                                "Sistema estável sem travamentos por 5 minutos.",
                                "Serial Monitor mostra dados legíveis e debug.",
                                "Circuito montado sem curtos ou superaquecimento."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, indentado e comentado (80% cobertura).",
                                "Lógica correta com thresholds calibrados.",
                                "Uso eficiente de pinos e recursos (sem desperdício).",
                                "Tratamento de erros (ex: bounds checking).",
                                "Modularidade com funções auxiliares.",
                                "Documentação inclui esquema e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Mapeamento linear (map()), lógica booleana.",
                                "Física: Leis de Ohm, conceitos de sinal analógico/digital.",
                                "Informática: Algoritmos condicionais, depuração.",
                                "Eletrônica: Circuito série/paralelo, PWM.",
                                "Projeto: Design thinking para prototipagem rápida."
                              ],
                              "realWorldApplication": "Em robótica industrial, automação residente (ex: irrigação automática baseada em umidade do solo) ou IoT (sensores remotos controlando relés em casas inteligentes), permitindo sistemas autônomos e eficientes."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Integrar em sistemas mecatrônicos",
                            "description": "Conectar microcontroladores a sensores e atuadores em um loop de controle fechado, com exemplos de projetos robóticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e preparar componentes para integração",
                                  "subSteps": [
                                    "Identifique os componentes necessários: microcontrolador (ex: Arduino Uno), sensor (ex: sensor ultrassônico HC-SR04), atuador (ex: servo motor SG90).",
                                    "Verifique especificações técnicas: tensão, pinos de entrada/saída, protocolos de comunicação (PWM, I2C).",
                                    "Monte uma bancada de testes com protoboard, fios jumper e fonte de alimentação estável (5V).",
                                    "Instale software necessário: IDE Arduino, bibliotecas para sensores e atuadores.",
                                    "Crie um diagrama esquemático simples usando ferramentas como Fritzing."
                                  ],
                                  "verification": "Componentes listados com especificações corretas e diagrama esquemático completo sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Arduino Uno",
                                    "HC-SR04",
                                    "SG90",
                                    "Protoboard",
                                    "Fios jumper",
                                    "Fonte 5V",
                                    "Computador com IDE Arduino"
                                  ],
                                  "tips": "Sempre priorize componentes compatíveis para evitar danos; teste alimentação individualmente.",
                                  "learningObjective": "Compreender as especificações e compatibilidades entre microcontroladores, sensores e atuadores.",
                                  "commonMistakes": [
                                    "Ignorar limites de corrente do microcontrolador",
                                    "Usar pinos errados sem consultar datasheet",
                                    "Esquecer de instalar bibliotecas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar conexões físicas em protoboard",
                                  "subSteps": [
                                    "Conecte o sensor ao microcontrolador: VCC a 5V, GND a GND, Trig a pino digital 9, Echo a pino 10.",
                                    "Conecte o atuador: sinal do servo a pino PWM 11, VCC a 5V, GND a GND.",
                                    "Adicione resistores pull-up se necessário para I2C ou sinais digitais.",
                                    "Teste continuidade com multímetro em todos os fios.",
                                    "Alimente o circuito e verifique ausência de curtos ou aquecimento excessivo."
                                  ],
                                  "verification": "Circuito montado sem erros de fiação, medido com multímetro e energizado sem falhas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Protoboard",
                                    "Fios jumper",
                                    "Multímetro",
                                    "Componentes do Step 1"
                                  ],
                                  "tips": "Use cores diferentes para fios (vermelho=5V, preto=GND) para facilitar debug; isole conexões com fita isolante.",
                                  "learningObjective": "Dominar conexões seguras e precisas para evitar danos e garantir funcionamento.",
                                  "commonMistakes": [
                                    "Inversão de VCC/GND",
                                    "Conexões soltas em protoboard",
                                    "Exceder corrente em pinos do microcontrolador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Programar o loop de controle fechado",
                                  "subSteps": [
                                    "Escreva código para ler dados do sensor: função setup() e loop() com pulseIn() para distância.",
                                    "Implemente lógica de controle: se distância < 20cm, ative servo para posição 90°; senão, 0°.",
                                    "Adicione controle proporcional simples (map(distância, 0, 100, 0, 180)).",
                                    "Inclua delays, serial.print para debug e tratamento de erros (leituras inválidas).",
                                    "Compile e faça upload do código no microcontrolador."
                                  ],
                                  "verification": "Código compila sem erros e saída serial mostra leituras corretas do sensor.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Computador com IDE Arduino",
                                    "Cabo USB para Arduino"
                                  ],
                                  "tips": "Use Serial Monitor para debug em tempo real; comece com código simples e adicione complexidade gradualmente.",
                                  "learningObjective": "Implementar feedback de sensor para controle de atuador em loop fechado.",
                                  "commonMistakes": [
                                    "Falta de pinMode() nos pinos",
                                    "Delays excessivos bloqueando loop",
                                    "Ignorar calibração do sensor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e integrar em projeto robótico",
                                  "subSteps": [
                                    "Teste unitário: sensor lê distâncias precisas (teste com objeto móvel).",
                                    "Teste integrado: observe resposta do atuador a mudanças de distância.",
                                    "Depure problemas: ajuste thresholds, calibre sensor, verifique ruído elétrico.",
                                    "Integre em chassi robótico simples: monte rodas ou braço com o loop de controle.",
                                    "Registre vídeo ou logs de funcionamento estável por 5 minutos."
                                  ],
                                  "verification": "Sistema responde corretamente a estímulos em pelo menos 95% dos testes, com logs/vídeo comprovando.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Chassi robótico básico",
                                    "Ferramentas de montagem",
                                    "Objetos para teste"
                                  ],
                                  "tips": "Registre variáveis em array para análise posterior; use osciloscópio se disponível para sinais PWM.",
                                  "learningObjective": "Validar e refinar sistema mecatrônico completo para aplicação robótica.",
                                  "commonMistakes": [
                                    "Testes insuficientes em cenários reais",
                                    "Sobrecalentamento por loops infinitos",
                                    "Falta de calibração ambiental"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um 'guarda de obstáculo' robótico: um carrinho com rodas DC controladas por H-bridge, onde sensor ultrassônico detecta obstáculo e servo desvia o carrinho em 90° para evitar colisão.",
                              "finalVerifications": [
                                "O loop de controle responde em <500ms a mudanças no sensor.",
                                "Sistema opera estável por 10 minutos sem falhas.",
                                "Atuador atinge posições exatas baseadas em leituras do sensor (±5° erro).",
                                "Nenhum dano aos componentes após testes extensos.",
                                "Código inclui comentários explicando lógica de controle.",
                                "Diagrama e código versionados em repositório Git."
                              ],
                              "assessmentCriteria": [
                                "Precisão das conexões físicas (sem erros de fiação: 25%).",
                                "Funcionalidade do código de controle fechado (lógica correta: 30%).",
                                "Estabilidade e resposta do sistema integrado (testes: 20%).",
                                "Documentação: diagramas, código comentado e relatório (15%).",
                                "Criatividade na aplicação robótica (10%).",
                                "Segurança e boas práticas (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos de controle e depuração em C++.",
                                "Eletrônica: Análise de circuitos e sinais analógicos/digitais.",
                                "Matemática: Funções de mapeamento e controle proporcional (PID básico).",
                                "Física: Sensores baseados em ultrassom e torque em atuadores.",
                                "Engenharia de Software: Versionamento e testes unitários."
                              ],
                              "realWorldApplication": "Em linhas de produção industriais, robôs colaborativos (cobots) usam loops de controle fechado com sensores de proximidade e atuadores para montagem precisa e segura, evitando colisões em ambientes fabris como automotiva ou farmacêutica."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.4",
                        "name": "Estruturas Mecânicas",
                        "description": "Chassis, braços e juntas que suportam e transmitem movimento, projetados com princípios de engenharia mecânica para robótica.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.4.1",
                            "name": "Desenhar estruturas mecânicas básicas",
                            "description": "Aplicar métodos de projeto como os de Cross (2004) para chassis e links robóticos, considerando rigidez e peso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender princípios fundamentais de estruturas mecânicas",
                                  "subSteps": [
                                    "Estudar conceitos de rigidez, peso e estabilidade em estruturas robóticas.",
                                    "Analisar exemplos de chassis e links de robôs reais (ex: robôs LEGO ou Arduino).",
                                    "Revisar métodos de projeto de Nigel Cross (2004), focando em análise de requisitos e conceitualização.",
                                    "Identificar trade-offs entre rigidez e peso.",
                                    "Mapear forças atuantes em estruturas robóticas básicas."
                                  ],
                                  "verification": "Resumo escrito dos princípios chave com diagramas simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Engineering Design Methods' de Cross (2004)",
                                    "Vídeos tutoriais sobre mecânica robótica",
                                    "Papel e lápis para anotações"
                                  ],
                                  "tips": "Use diagramas de forças livres para visualizar conceitos.",
                                  "learningObjective": "Entender os fundamentos de rigidez e peso em design mecânico robótico.",
                                  "commonMistakes": [
                                    "Ignorar trade-offs entre rigidez e peso",
                                    "Não considerar forças dinâmicas em robôs móveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir requisitos do projeto usando métodos de Cross",
                                  "subSteps": [
                                    "Listar requisitos funcionais para chassis e links (ex: suportar 2kg, rigidez mínima de 100N/mm).",
                                    "Priorizar critérios: rigidez > peso > custo.",
                                    "Criar matriz de requisitos vs. soluções potenciais.",
                                    "Esboçar fluxograma do processo de design iterativo de Cross.",
                                    "Consultar normas básicas de engenharia mecânica (ex: ISO para robótica)."
                                  ],
                                  "verification": "Matriz de requisitos completa e assinada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado",
                                    "Referências de Cross (2004)",
                                    "Exemplos de projetos robóticos online"
                                  ],
                                  "tips": "Comece com requisitos SMART (Específicos, Mensuráveis, Alcançáveis, Relevantes, Temporais).",
                                  "learningObjective": "Aplicar métodos sistemáticos para definir specs de estruturas mecânicas.",
                                  "commonMistakes": [
                                    "Requisitos vagos ou não quantificáveis",
                                    "Omitir análise de falhas potenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Esboçar estruturas mecânicas básicas para chassis e links",
                                  "subSteps": [
                                    "Desenhar esboços iniciais em 2D de chassis retangular e links articulados.",
                                    "Incorporar elementos para rigidez: vigas em I, triangulações.",
                                    "Calcular peso aproximado usando densidades de materiais (alumínio, acrílico).",
                                    "Usar software simples como FreeCAD ou papel para vistas ortográficas.",
                                    "Iterar 2-3 versões baseadas em feedback autoavaliado."
                                  ],
                                  "verification": "Conjunto de 3 esboços com anotações de dimensões e materiais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software FreeCAD ou Tinkercad",
                                    "Papel milimetrado",
                                    "Tabelas de propriedades de materiais"
                                  ],
                                  "tips": "Mantenha proporções realistas; escale para um robô de 30cm.",
                                  "learningObjective": "Produzir desenhos preliminares otimizados para robótica.",
                                  "commonMistakes": [
                                    "Desenhos não escalados",
                                    "Ignorar pontos de fixação para atuadores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e refinar o design considerando rigidez e peso",
                                  "subSteps": [
                                    "Simular rigidez com cálculos simples (ex: momento de inércia de seções).",
                                    "Otimizar peso removendo material desnecessário sem comprometer rigidez.",
                                    "Testar protótipo virtual ou físico com carga simulada.",
                                    "Comparar com benchmarks de projetos robóticos existentes.",
                                    "Documentar iterações finais com justificativas."
                                  ],
                                  "verification": "Relatório de avaliação com métricas finais (rigidez, peso total).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou Python para simulações básicas",
                                    "Impressora 3D opcional para protótipo",
                                    "Balança para medir peso"
                                  ],
                                  "tips": "Use fator de segurança de 1.5 para rigidez em aplicações robóticas.",
                                  "learningObjective": "Refinar designs iterativamente para performance ótima.",
                                  "commonMistakes": [
                                    "Sobreengenharia levando a peso excessivo",
                                    "Cálculos incorretos de rigidez"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenhar o chassis de um robô seguidor de linha com links para rodas, usando alumínio de 3mm para rigidez e furos otimizados para reduzir peso em 20%, suportando bateria e sensores IR.",
                              "finalVerifications": [
                                "Desenho final quantifica rigidez mínima e peso total.",
                                "Estrutura resiste a torção simulada de 50N sem deformação >1mm.",
                                "Materiais selecionados equilibram custo, peso e rigidez.",
                                "Vistas múltiplas (frente, lateral, superior) completas.",
                                "Documentação inclui trade-offs e iterações realizadas.",
                                "Compatibilidade com componentes robóticos padrão confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de métodos de Cross (30%).",
                                "Otimização de rigidez vs. peso (25%).",
                                "Qualidade e completude dos desenhos (20%).",
                                "Uso correto de cálculos e verificações (15%).",
                                "Criatividade em soluções interdisciplinares (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estática e dinâmica de estruturas.",
                                "Matemática: Cálculo de áreas e momentos de inércia.",
                                "Informática: Simulação em CAD e programação de análise.",
                                "Química: Propriedades de materiais (densidade, resistência)."
                              ],
                              "realWorldApplication": "Projeto de chassis para drones ou braços robóticos industriais, como em linhas de montagem automotivas, onde rigidez garante precisão e leveza reduz consumo energético."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.4.2",
                            "name": "Analisar cinemática de estruturas",
                            "description": "Calcular graus de liberdade e trajetórias em braços robóticos, integrando com atuadores e sensores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Cinemática Robótica",
                                  "subSteps": [
                                    "Estudar a definição de cinemática como estudo do movimento sem forças.",
                                    "Aprender sobre graus de liberdade (DOF) e mobilidade em mecanismos.",
                                    "Identificar tipos de juntas: rotativa, prismática e esférica.",
                                    "Revisar matrizes de transformação homogênea (Denavit-Hartenberg).",
                                    "Explorar diferenças entre cinemática direta e inversa."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito os conceitos de DOF e cinemática direta/inversa com exemplos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Introdução à Robótica' de Craig",
                                    "Vídeos Khan Academy sobre cinemática",
                                    "Software MATLAB ou Python (SymPy)"
                                  ],
                                  "tips": "Use diagramas simples para visualizar juntas e DOF.",
                                  "learningObjective": "Dominar os princípios básicos da cinemática em sistemas robóticos.",
                                  "commonMistakes": [
                                    "Confundir DOF com número de atuadores",
                                    "Ignorar restrições de mobilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a Estrutura Mecânica do Braço Robótico",
                                  "subSteps": [
                                    "Desenhar o diagrama esquemático do braço com juntas e elos.",
                                    "Atribuir parâmetros Denavit-Hartenberg (DH) a cada junta.",
                                    "Construir a cadeia cinemática serial.",
                                    "Validar o modelo com software de simulação.",
                                    "Documentar o modelo em tabela DH."
                                  ],
                                  "verification": "Apresentar tabela DH completa e diagrama validado em software.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Software RoboDK ou MATLAB Robotics Toolbox",
                                    "Modelos 3D de braços robóticos"
                                  ],
                                  "tips": "Comece com braços de 2-3 DOF para praticar.",
                                  "learningObjective": "Criar modelos cinemáticos precisos de estruturas robóticas.",
                                  "commonMistakes": [
                                    "Erro na convenção DH (eixos errados)",
                                    "Esquecer offsets entre elos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Graus de Liberdade (DOF)",
                                  "subSteps": [
                                    "Aplicar fórmula de Grübler-Kutzbach para mobilidade.",
                                    "Contar juntas e restrições em planos (x, y, z).",
                                    "Verificar DOF para planos 2D e 3D.",
                                    "Simular reduções por singularidades.",
                                    "Comparar com DOF teórico e real."
                                  ],
                                  "verification": "Calcular e justificar DOF para um mecanismo exemplo com resultado correto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora ou Python para fórmulas",
                                    "Exemplos de mecanismos planar e espacial"
                                  ],
                                  "tips": "Lembre-se: DOF = 6(N-1) - Σ restrições para 3D.",
                                  "learningObjective": "Determinar precisamente a mobilidade de estruturas robóticas.",
                                  "commonMistakes": [
                                    "Contar mal as restrições passivas",
                                    "Aplicar fórmula errada para dimensões"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Trajetórias Cinemáticas",
                                  "subSteps": [
                                    "Implementar cinemática direta: posição final via produto de matrizes DH.",
                                    "Resolver cinemática inversa analiticamente ou numericamente.",
                                    "Gerar trajetórias suaves (polinomiais ou trapezoidais).",
                                    "Simular trajetórias em software.",
                                    "Analisar velocidades e acelerações jacobianas."
                                  ],
                                  "verification": "Gerar gráfico de trajetória e posição final correta para ângulos dados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB/Python com bibliotecas Robotics",
                                    "Planilhas Excel para cálculos manuais"
                                  ],
                                  "tips": "Use Jacobiano para velocidades lineares/angulares.",
                                  "learningObjective": "Prever e controlar movimentos de braços robóticos.",
                                  "commonMistakes": [
                                    "Singularidades não detectadas",
                                    "Inversão matricial incorreta"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar com Atuadores e Sensores",
                                  "subSteps": [
                                    "Mapear DOF a atuadores (motores servo, steppers).",
                                    "Incorporar feedback de sensores (encoders, IMUs).",
                                    "Simular controle de trajetória com PID simples.",
                                    "Verificar limites de atuadores na trajetória.",
                                    "Testar em protótipo virtual."
                                  ],
                                  "verification": "Demonstrar simulação integrada com atuadores controlando trajetória.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Arduino IDE para simulação",
                                    "Modelos de sensores em Gazebo/ROS"
                                  ],
                                  "tips": "Garanta que resolução de sensores suporte precisão da cinemática.",
                                  "learningObjective": "Conectar análise cinemática a sistemas mecatrônicos reais.",
                                  "commonMistakes": [
                                    "Sobrecarga de atuadores por trajetórias inválidas",
                                    "Ignorar ruído de sensores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um braço robótico de 3 DOF para tarefa pick-and-place, calcular DOF=3 usando Grübler, modelar com DH, gerar trajetória de (0,0,0) a (0.5,0.3,0.2)m via cinemática direta, e integrar servomotores com encoders para feedback fechado.",
                              "finalVerifications": [
                                "DOF calculado corretamente para o modelo.",
                                "Matrizes DH validadas com simulação.",
                                "Trajetória gerada sem singularidades.",
                                "Posição final coincide com alvo (<1% erro).",
                                "Integração com atuadores simulada funcionalmente.",
                                "Relatório documenta todos os cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de DOF e matrizes (90%+ correto).",
                                "Qualidade do modelo DH e diagramas.",
                                "Correção na cinemática direta/inversa.",
                                "Análise de trajetórias realista e suave.",
                                "Integração mecatrônica coerente.",
                                "Documentação clara e completa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e trigonometria para matrizes.",
                                "Física: Mecânica clássica de movimento rígido.",
                                "Programação: Simulações em Python/MATLAB.",
                                "Eletrônica: Interfaces de sensores e atuadores."
                              ],
                              "realWorldApplication": "Projeto de braços robóticos industriais para soldagem, montagem automotiva ou robôs cirúrgicos, otimizando precisão e eficiência em linhas de produção."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.4.3",
                            "name": "Integrar em times multifuncionais",
                            "description": "Colaborar em projetos integrados, usando técnicas de Shetty & Kolk (1997) para estruturas mecatrônicas em aplicações aeronáuticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Papéis e Técnicas de Integração Multifuncional",
                                  "subSteps": [
                                    "Estude os princípios de Shetty & Kolk (1997) para integração mecatrônica, focando em estruturas modulares.",
                                    "Identifique papéis chave: mecânicos, eletrônicos, de software e aeronáuticos.",
                                    "Analise exemplos de projetos aeronáuticos onde falhas de integração ocorreram.",
                                    "Mapeie contribuições interdisciplinares para estruturas mecatrônicas.",
                                    "Crie um diagrama de fluxos de trabalho colaborativos."
                                  ],
                                  "verification": "Diagrama completo de papéis e fluxos submetido e revisado por pares.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livro Shetty & Kolk (1997), artigos sobre mecatrônica aeronáutica, software de diagramação (Draw.io).",
                                  "tips": "Use mind maps para visualizar interdependências entre funções.",
                                  "learningObjective": "Dominar fundamentos teóricos de integração multifuncional em mecatrônica.",
                                  "commonMistakes": "Ignorar dependências entre disciplinas, subestimando complexidade aeronáutica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formar e Estruturar Equipe Multifuncional",
                                  "subSteps": [
                                    "Selecione membros simulados ou reais com perfis multifuncionais (mecânica, eletrônica, software).",
                                    "Defina regras de comunicação baseadas em Shetty & Kolk, como reuniões iterativas.",
                                    "Estabeleça ferramentas colaborativas (Trello, Slack).",
                                    "Crie um charter de equipe com objetivos, papéis e métricas.",
                                    "Realize icebreaker focado em projetos aeronáuticos."
                                  ],
                                  "verification": "Charter de equipe aprovado por todos os membros e ferramentas configuradas.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ferramentas colaborativas (Trello, Slack, Zoom), template de charter de equipe.",
                                  "tips": "Priorize diversidade de backgrounds para inovação em estruturas.",
                                  "learningObjective": "Habilitar formação eficaz de equipes para projetos integrados.",
                                  "commonMistakes": "Escolha de membros sem expertise complementar, falta de clareza em papéis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Técnicas em Projeto Integrado Aeronáutico",
                                  "subSteps": [
                                    "Desenhe estrutura mecatrônica para aplicação aeronáutica (ex: suporte de atuador em UAV).",
                                    "Integre componentes usando métodos modulares de Shetty & Kolk.",
                                    "Realize iterações colaborativas: prototipagem virtual e feedback multifuncional.",
                                    "Teste interfaces mecânicas-eletrônicas em simulação.",
                                    "Documente decisões colaborativas e trade-offs."
                                  ],
                                  "verification": "Protótipo virtual funcional com relatório de integração.",
                                  "estimatedTime": "8 horas",
                                  "materials": "Software CAD (SolidWorks), simuladores mecatrônicos (MATLAB/Simulink), hardware básico para mockup.",
                                  "tips": "Use version control (Git) para rastrear mudanças colaborativas.",
                                  "learningObjective": "Executar colaboração prática em estruturas mecatrônicas aeronáuticas.",
                                  "commonMistakes": "Falta de iterações, dominância de uma disciplina sobre outras."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Refinar Integração da Equipe",
                                  "subSteps": [
                                    "Colete feedback via survey pós-projeto sobre efetividade da integração.",
                                    "Analise métricas: tempo de ciclo, erros de interface, satisfação da equipe.",
                                    "Compare resultados com benchmarks de Shetty & Kolk.",
                                    "Identifique lições aprendidas e plano de melhoria.",
                                    "Apresente relatório final à equipe e stakeholders simulados."
                                  ],
                                  "verification": "Relatório de avaliação com métricas e plano de ação aprovado.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Templates de survey (Google Forms), planilhas de métricas.",
                                  "tips": "Foque em métricas quantitativas para objetividade.",
                                  "learningObjective": "Desenvolver habilidades de avaliação contínua em times multifuncionais.",
                                  "commonMistakes": "Subjetividade em avaliações, ignorar feedback negativo."
                                }
                              ],
                              "practicalExample": "Em um projeto de UAV para monitoramento ambiental, integre estrutura mecânica leve (alumínio composto) com atuadores eletrônicos e controle de software, usando módulos plug-and-play de Shetty & Kolk para reduzir peso em 15% e tempo de montagem em 30%.",
                              "finalVerifications": [
                                "Estrutura mecatrônica integrada sem falhas de interface.",
                                "Relatório colaborativo documenta todas contribuições multifuncionais.",
                                "Equipe atinge 80% de satisfação em survey de integração.",
                                "Protótipo atende specs aeronáuticas (peso, vibração).",
                                "Trade-offs documentados e justificados.",
                                "Plano de escalabilidade para produção real."
                              ],
                              "assessmentCriteria": [
                                "Profundidade na aplicação de técnicas Shetty & Kolk (nota 1-10).",
                                "Efetividade da comunicação multifuncional (observada em reuniões).",
                                "Qualidade do protótipo integrado (testes funcionais).",
                                "Análise de riscos e mitigação colaborativa.",
                                "Reflexão crítica sobre lições aprendidas.",
                                "Alinhamento com aplicações aeronáuticas."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Ferramentas ágeis para iterações.",
                                "Comunicação: Técnicas de feedback interdisciplinar.",
                                "Engenharia Aeronáutica: Normas de estruturas leves.",
                                "Design Thinking: Empatia em equipes multifuncionais.",
                                "Ética Profissional: Colaboração responsável."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Embraer ou Boeing, equipes multifuncionais integram estruturas mecatrônicas em aeronaves autônomas, otimizando peso e confiabilidade para missões de longo alcance, reduzindo custos de desenvolvimento em até 20%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Classificação e Tipos de Robôs",
                    "description": "Categorização de robôs por configuração, graus de liberdade e aplicações industriais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Configurações Geométricas de Robôs",
                        "description": "Categorização dos robôs industriais com base em sua geometria mecânica, incluindo robôs cartesianos, cilíndricos, esféricos, articulados, SCARA e paralelos, destacando suas estruturas cinemáticas e alcances de trabalho.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Identificar configurações principais de robôs",
                            "description": "Reconhecer e descrever as características geométricas das configurações cartesianas (3 eixos lineares), cilíndricas (rotação + 2 lineares), esféricas (2 rotações + linear), articuladas (6 DOF rotacionais), SCARA (3 rotações + 1 linear) e paralelos (múltiplos braços paralelos).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Configurações Geométricas e Graus de Liberdade (DOF)",
                                  "subSteps": [
                                    "Defina configuração geométrica como o arranjo de juntas e elos que define o workspace do robô.",
                                    "Explique DOF como o número de movimentos independentes (lineares ou rotacionais).",
                                    "Classifique juntas em lineares (prismáticas) e rotacionais (revolutas).",
                                    "Identifique como DOF afeta alcance, precisão e complexidade.",
                                    "Revise exemplos iniciais de robôs com 3-6 DOF."
                                  ],
                                  "verification": "Resuma em um diagrama simples os conceitos de DOF e tipos de juntas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Vídeos introdutórios sobre robótica (YouTube: 'Robot Kinematics Basics'), papel e caneta para diagramas.",
                                  "tips": "Use analogias como braços humanos (múltiplas rotações) vs. mesas deslizantes (lineares).",
                                  "learningObjective": "Compreender os princípios básicos que diferenciam configurações de robôs.",
                                  "commonMistakes": "Confundir DOF com número de eixos; lembrar que DOF inclui rotações e translações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Configurações Cartesianas, Cilíndricas e Esféricas",
                                  "subSteps": [
                                    "Descreva cartesiana: 3 eixos lineares (X, Y, Z); workspace cúbico; alta precisão.",
                                    "Analise cilíndrica: 1 rotação (θ) + 2 lineares (R, Z); workspace cilíndrico; bom para pick-and-place.",
                                    "Detalhe esférica: 2 rotações (θ, φ) + 1 linear (R); workspace esférico; alcance amplo mas singularidades.",
                                    "Compare vantagens/desvantagens: rigidez vs. envelope.",
                                    "Desenhe diagramas esquemáticos de cada uma."
                                  ],
                                  "verification": "Crie tabela comparativa com geometria, DOF e aplicações de cada configuração.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Diagramas de robôs (imagens de Google: 'Cartesian robot diagram'), software gratuito como TinkerCAD para modelagem.",
                                  "tips": "Visualize coordenadas: cartesiana como impressora 3D, cilíndrica como torno.",
                                  "learningObjective": "Reconhecer e descrever características geométricas das configurações lineares e polares.",
                                  "commonMistakes": "Ignorar singularidades na esférica; elas ocorrem quando braços se alinham."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Configurações Articuladas, SCARA e Paralelas",
                                  "subSteps": [
                                    "Descreva articulada: 6 DOF rotacionais; workspace complexo; flexibilidade humana-like.",
                                    "Analise SCARA: 3 rotações + 1 linear (Z); workspace planar rápido; ideal para montagem.",
                                    "Detalhe paralela (Delta): múltiplos braços paralelos; alta velocidade/precisão; workspace limitado.",
                                    "Liste aplicações típicas: soldagem (articulada), eletrônicos (SCARA), picking (Delta).",
                                    "Identifique diferenças em cinemática: serial vs. paralela."
                                  ],
                                  "verification": "Liste 3 aplicações reais para cada configuração com justificativa geométrica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Vídeos de robôs industriais (YouTube: 'SCARA vs Articulated robots'), fotos de braços robóticos.",
                                  "tips": "Pense em SCARA como 'braço seletivo compliant assembly robot arm' para montagens rápidas.",
                                  "learningObjective": "Diferenciar configurações rotacionais e paralelas por suas geometrias únicas.",
                                  "commonMistakes": "Confundir SCARA com articulada; SCARA tem menos DOF e foco planar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Descrição de Configurações",
                                  "subSteps": [
                                    "Colete 10 imagens de robôs reais e classifique cada configuração.",
                                    "Descreva verbalmente ou por escrito a geometria observada.",
                                    "Simule cenários: 'Qual usar para solda em 3D?' (articulada).",
                                    "Crie quiz autoavaliativo com misturas de tipos.",
                                    "Discuta limitações em contextos industriais."
                                  ],
                                  "verification": "Acertar 90% em um quiz de identificação de 20 imagens.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Banco de imagens (sites como Robotics.org), app de quiz como Quizlet.",
                                  "tips": "Foque em juntas visíveis: lineares são deslizantes, rotacionais são giratórias.",
                                  "learningObjective": "Aplicar conhecimento para identificar configurações em exemplos reais.",
                                  "commonMistakes": "Julgar só pelo tamanho; geometria é pelo arranjo de juntas."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de smartphones, identifique um robô SCARA (3 rotações + Z linear) usado para inserir parafusos precisamente em plano XY, contrastando com um cartesiano para movimentação em 3D de peças grandes.",
                              "finalVerifications": [
                                "Lista corretamente os 6 tipos de configurações com suas geometrias principais.",
                                "Descreve DOF e workspace para cada tipo sem erros.",
                                "Identifica configurações em pelo menos 8/10 imagens reais.",
                                "Compara vantagens/desvantagens de pelo menos 3 pares de configurações.",
                                "Explica uma aplicação real para cada tipo.",
                                "Desenha diagramas esquemáticos precisos para todos os tipos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição geométrica (90% correto).",
                                "Compreensão de DOF e tipos de juntas (rubrica 1-5).",
                                "Capacidade de identificação visual (acertos em quiz).",
                                "Profundidade em comparações e aplicações (exemplos relevantes).",
                                "Clareza em diagramas e explicações escritas.",
                                "Criatividade em conexões práticas (pontos extras)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria analítica e coordenadas (cartesianas, polares, esféricas).",
                                "Física: Cinemática e dinâmica de mecanismos.",
                                "Engenharia Mecânica: Projeto de juntas e elos.",
                                "Informática: Simulações em software como ROS ou MATLAB.",
                                "Indústria 4.0: Integração com IoT e automação."
                              ],
                              "realWorldApplication": "Na indústria automotiva, engenheiros usam robôs articulados (6 DOF) para solda de carrocerias complexas, enquanto SCARA acelera montagem de componentes eletrônicos em painéis, otimizando precisão e velocidade em linhas de produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Comparar vantagens e desvantagens das configurações",
                            "description": "Analisar prós e contras de cada configuração, como precisão alta do cartesiano vs. flexibilidade do articulado, considerando payload, velocidade e envelope de trabalho em aplicações mecatrônicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Descrever Configurações Geométricas Comuns de Robôs",
                                  "subSteps": [
                                    "Liste as principais configurações: cartesiano, cilíndrico, esférico, articulado (SCARA e antropomórfico).",
                                    "Descreva a estrutura geométrica de cada uma, incluindo número de eixos e alcance de movimento.",
                                    "Pesquise diagramas ou vídeos demonstrando o movimento de cada configuração.",
                                    "Registre o envelope de trabalho (espaço alcançável) para cada tipo.",
                                    "Anote aplicações típicas iniciais para contextualizar."
                                  ],
                                  "verification": "Criar uma tabela ou infográfico resumindo as 4-6 configurações principais com descrições e diagramas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Acesso à internet, papel ou software de desenho (ex: Draw.io), vídeos tutoriais sobre robótica.",
                                  "tips": "Use imagens 3D interativas online para visualizar melhor os envelopes de trabalho.",
                                  "learningObjective": "Compreender as diferenças estruturais fundamentais entre configurações geométricas de robôs.",
                                  "commonMistakes": "Confundir configurações semelhantes, como SCARA com articulado serial; sempre verificar número de graus de liberdade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vantagens e Desvantagens Individuais de Cada Configuração",
                                  "subSteps": [
                                    "Para cada configuração, liste 3-5 vantagens (ex: precisão alta no cartesiano).",
                                    "Liste 3-5 desvantagens correspondentes (ex: envelope limitado no cartesiano).",
                                    "Considere critérios chave: precisão, flexibilidade, payload, velocidade e custo.",
                                    "Classifique cada critério em uma escala qualitativa (alta/média/baixa).",
                                    "Documente com referências de fontes confiáveis."
                                  ],
                                  "verification": "Produzir uma matriz de prós e contras para pelo menos 4 configurações, com justificativas baseadas em critérios.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilhas (Google Sheets ou Excel), artigos acadêmicos ou manuais de robôs industriais.",
                                  "tips": "Priorize dados quantitativos quando possível, como payload máximo de modelos reais (ex: ABB IRB).",
                                  "learningObjective": "Desenvolver capacidade de avaliação crítica isolada de cada configuração.",
                                  "commonMistakes": "Ignorar trade-offs reais; evite generalizações sem exemplos concretos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Configurações em Critérios Específicos e Aplicações Mecatrônicas",
                                  "subSteps": [
                                    "Crie uma tabela comparativa lado a lado para payload, velocidade, precisão, flexibilidade e envelope.",
                                    "Compare pares específicos (ex: cartesiano vs. articulado em precisão vs. flexibilidade).",
                                    "Avalie suitability para aplicações mecatrônicas como soldagem, pick-and-place ou montagem.",
                                    "Pontue cada configuração por critério (1-10) e calcule médias.",
                                    "Discuta cenários onde uma supera outra."
                                  ],
                                  "verification": "Gerar relatório comparativo com tabela pontuada e 2-3 cenários de aplicação recomendados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de planilhas avançado, exemplos de casos industriais (ex: vídeos da Fanuc ou KUKA).",
                                  "tips": "Use gráficos de radar para visualização intuitiva das comparações.",
                                  "learningObjective": "Dominar comparações quantitativas e qualitativas entre configurações.",
                                  "commonMistakes": "Focar apenas em um critério; equilibre todos os aspectos mencionados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Recomendações para Aplicações Mecatrônicas",
                                  "subSteps": [
                                    "Selecione uma aplicação mecatrônica hipotética e justifique a melhor configuração.",
                                    "Identifique limitações e possíveis mitigações (ex: sensores para melhorar precisão).",
                                    "Resuma os trade-offs principais em um parágrafo conclusivo.",
                                    "Crie um fluxograma de decisão para escolha de configuração.",
                                    "Revise e refine com base em feedback autoavaliado."
                                  ],
                                  "verification": "Produzir fluxograma de decisão e recomendação escrita para uma aplicação específica.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas de fluxograma (Lucidchart ou papel), exemplos reais de projetos mecatrônicos.",
                                  "tips": "Pense em custos totais, incluindo manutenção, para recomendações realistas.",
                                  "learningObjective": "Aplicar comparações a decisões práticas em projetos mecatrônicos.",
                                  "commonMistakes": "Recomendações absolutas; sempre destaque context-dependência."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de smartphones, compare cartesiano (alta precisão para colocação de chips pequenos, mas envelope limitado) vs. articulado (flexibilidade para múltiplas estações, maior velocidade, mas menor precisão sem calibração avançada); recomende cartesiano para tarefas de alta precisão estática.",
                              "finalVerifications": [
                                "Pode listar pelo menos 3 prós e 3 contras precisos para cartesiano, articulado e SCARA?",
                                "Consegue criar uma tabela comparativa com critérios quantitativos (ex: payload >10kg)?",
                                "Identifica corretamente quando articulado é preferível sobre cartesiano em aplicações dinâmicas?",
                                "Explica trade-offs em envelope de trabalho vs. velocidade?",
                                "Recomenda configuração adequada para 2 aplicações mecatrônicas distintas?",
                                "Demonstra compreensão via fluxograma de decisão funcional?"
                              ],
                              "assessmentCriteria": [
                                "Profundidade da análise: Cobertura completa de todos critérios (precisão, payload, etc.) - 25%",
                                "Precisão factual: Uso correto de termos e dados reais de robôs - 20%",
                                "Comparação equilibrada: Evidência de trade-offs sem viés - 20%",
                                "Visualizações eficazes: Tabelas, gráficos ou diagramas claros - 15%",
                                "Aplicação prática: Recomendações contextualizadas e justificadas - 10%",
                                "Clareza e organização: Estrutura lógica e linguagem técnica apropriada - 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cinemática direta/inversa e geometria descritiva para envelopes.",
                                "Física: Dinâmica de movimento, forças e torque em payloads.",
                                "Engenharia de Materiais: Impacto de materiais em rigidez e precisão.",
                                "Gestão de Projetos: Análise custo-benefício em seleções industriais."
                              ],
                              "realWorldApplication": "Na indústria automotiva, como na fábrica da Tesla, robôs articulados (ex: KUKA) são escolhidos por flexibilidade em soldagem de carrocerias (grande envelope, alta velocidade), enquanto cartesianos são usados em usinagem de precisão para componentes motores (alta repetibilidade, payload estável)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Exemplificar robôs por configuração em indústrias",
                            "description": "Associar exemplos reais, como robôs cartesianos em pick-and-place ou articulados em soldagem automotiva, relacionando com projetos mecatrônicos na indústria aeronáutica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e descrever as principais configurações geométricas de robôs",
                                  "subSteps": [
                                    "Estudar a configuração cartesiana (3 eixos lineares ortogonais).",
                                    "Analisar configuração cilíndrica (rotação + 2 eixos lineares).",
                                    "Descrever configuração esférica (2 rotações + 1 linear radial).",
                                    "Explicar configuração articulada (múltiplos eixos rotacionais, como braços humanos).",
                                    "Comparar com configurações paralelas (SCARA e Delta) para contexto."
                                  ],
                                  "verification": "Criar uma tabela resumindo cada configuração com graus de liberdade e movimento característico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de robótica, vídeos tutoriais no YouTube (ex: canais de mecatrônica), diagrama de configurações.",
                                  "tips": "Desenhe esboços simples para visualizar o espaço de trabalho de cada configuração.",
                                  "learningObjective": "Compreender as diferenças cinemáticas e geométricas entre configurações de robôs.",
                                  "commonMistakes": "Confundir configuração cartesiana (lineares) com SCARA (híbrida rotacional-linear)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar exemplos reais de robôs por configuração em indústrias",
                                  "subSteps": [
                                    "Buscar exemplos de robôs cartesianos em pick-and-place (ex: montagem de PCBs).",
                                    "Identificar robôs articulados em soldagem (ex: indústria automotiva como ABB IRB).",
                                    "Listar robôs cilíndricos em manuseio de materiais cilíndricos (ex: embalagens).",
                                    "Encontrar robôs esféricos em aplicações de alcance radial (ex: inspeção).",
                                    "Coletar imagens ou vídeos de cada exemplo."
                                  ],
                                  "verification": "Compilar uma lista com 4-6 exemplos, incluindo fabricante e aplicação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Sites de fabricantes (ABB, Fanuc, KUKA), artigos acadêmicos, banco de dados IEEE Xplore.",
                                  "tips": "Use palavras-chave como 'robô cartesiano pick-and-place' em buscas no Google Scholar.",
                                  "learningObjective": "Associar configurações geométricas a tarefas industriais específicas.",
                                  "commonMistakes": "Ignorar limitações do espaço de trabalho, como alcance reduzido em articulados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar configurações com indústrias específicas, focando em mecatrônica aeronáutica",
                                  "subSteps": [
                                    "Analisar uso de cartesianos em montagem precisa de componentes aeronáuticos.",
                                    "Estudar articulados em soldagem e pintura de fuselagens (ex: Boeing).",
                                    "Explorar cilíndricos/esféricos em testes de materiais compostos.",
                                    "Mapear vantagens: precisão cartesiana vs. flexibilidade articulada.",
                                    "Discutir integração mecatrônica (sensores, atuadores)."
                                  ],
                                  "verification": "Elaborar um diagrama de Venn ou mapa mental ligando configurações a indústrias.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Casos de estudo da Embraer ou Airbus, relatórios da Indústria 4.0.",
                                  "tips": "Priorize exemplos brasileiros para relevância local.",
                                  "learningObjective": "Relacionar escolhas de configuração a demandas industriais mecatrônicas.",
                                  "commonMistakes": "Generalizar sem considerar fatores como payload ou velocidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e exemplificar em um projeto mecatrônico simulado",
                                  "subSteps": [
                                    "Criar um case study: linha de montagem aeronáutica com múltiplas configurações.",
                                    "Desenhar fluxograma de operação com robôs específicos.",
                                    "Simular falhas e soluções baseadas em configuração.",
                                    "Preparar apresentação com exemplos visuais.",
                                    "Autoavaliar com critérios de precisão."
                                  ],
                                  "verification": "Produzir um relatório ou slide deck com exemplos exemplificados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de desenho (Draw.io, PowerPoint), simulador Roboguide ou Gazebo.",
                                  "tips": "Inclua métricas como precisão (±0.1mm) para realismo.",
                                  "learningObjective": "Aplicar conhecimento em um contexto projetual integrado.",
                                  "commonMistakes": "Sobrecarregar um tipo de robô em tarefas inadequadas."
                                }
                              ],
                              "practicalExample": "Em uma fábrica automotiva como a Volkswagen, robôs articulados da KUKA (6 eixos) executam soldagem MIG em chassis de carros, enquanto robôs cartesianos da Epson realizam pick-and-place de parafusos em linhas de montagem; na aeronáutica da Embraer, articulados pintam fuselagens com precisão robótica.",
                              "finalVerifications": [
                                "Citar corretamente 4 configurações geométricas com exemplos industriais.",
                                "Associar pelo menos 2 exemplos à indústria aeronáutica mecatrônica.",
                                "Explicar vantagens/desvantagens de cada configuração em aplicações reais.",
                                "Demonstrar via diagrama ou tabela a relação configuração-tarefa-indústria.",
                                "Identificar integração com outros sistemas mecatrônicos (ex: visão computacional)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica das descrições e exemplos (30%)",
                                "Relevância e variedade de aplicações industriais (25%)",
                                "Qualidade visual e clareza de diagramas/mapas (20%)",
                                "Profundidade na análise mecatrônica/aeronáutica (15%)",
                                "Criatividade em exemplos práticos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Mecânica: Cinemática e dinâmica de robôs.",
                                "Engenharia Elétrica: Controle e atuadores em configurações.",
                                "Programação: Cinemática inversa para trajetórias industriais.",
                                "Gestão Industrial: Otimização de linhas de produção com robótica."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Embraer, robôs cartesianos garantem montagem precisa de painéis compostos em pick-and-place, enquanto articulados executam soldagem e inspeção em fuselagens, reduzindo tempo de produção em 40% e erros humanos, integrando-se a projetos mecatrônicos completos com IA e sensores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Graus de Liberdade (DOF) em Robôs",
                        "description": "Conceito de graus de liberdade como o número de movimentos independentes de um robô, influenciando sua capacidade de posicionamento e orientação no espaço, com fórmulas básicas de cálculo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Definir e calcular graus de liberdade",
                            "description": "Explicar DOF como dimensões de movimento (translacional/rotacional) e aplicar fórmula Grübler para mecanismos planares/espaciais: M = 6(N-1-J) para 3D, identificando em robôs comuns (ex: 6 DOF para manipulação completa).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de Graus de Liberdade (DOF)",
                                  "subSteps": [
                                    "Defina DOF como o número de movimentos independentes que um corpo rígido pode realizar no espaço.",
                                    "Identifique os 6 DOF possíveis em 3D: 3 translacionais (x, y, z) e 3 rotacionais (roll, pitch, yaw).",
                                    "Diferencie DOF translacional (deslocamento linear) de rotacional (rotação em eixos).",
                                    "Explique como restrições (joints) reduzem os DOF totais.",
                                    "Visualize DOF em exemplos cotidianos, como uma porta (1 DOF rotacional)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os 6 DOF de um corpo livre e dê um exemplo de restrição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre cinemática (YouTube: 'Degrees of Freedom Explained')",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Use analogias como 'mãos livres vs. presas' para fixar o conceito.",
                                  "learningObjective": "Entender DOF como dimensões independentes de movimento.",
                                  "commonMistakes": "Confundir DOF com número de joints; lembrar que DOF é o resultado após restrições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar componentes de mecanismos: Links (N) e Joints (J)",
                                  "subSteps": [
                                    "Defina links como corpos rígidos conectores (N = número total).",
                                    "Classifique joints comuns: revolute (1 DOF rotacional), prismatic (1 DOF translacional).",
                                    "Conte N e J em diagramas simples de mecanismos planares e espaciais.",
                                    "Desenhe um mecanismo com 3 links e 2 joints, rotulando cada um.",
                                    "Discuta como joints de múltiplos DOF afetam a contagem (assumir 1 DOF por joint inicialmente)."
                                  ],
                                  "verification": "Anote N e J corretamente em um diagrama fornecido de um mecanismo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagramas de mecanismos (impressos ou online: four-bar linkage)",
                                    "Software gratuito como GeoGebra para desenhos"
                                  ],
                                  "tips": "Comece contando do base frame; inclua o chassi como link 1.",
                                  "learningObjective": "Reconhecer e contar links e joints em estruturas robóticas.",
                                  "commonMistakes": "Esquecer o link base ou contar joints fixos incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender e aplicar a fórmula de Grübler para DOF",
                                  "subSteps": [
                                    "Memorize fórmulas: Planar M = 3(N-1-J); Espacial M = 6(N-1-J) (para joints 1 DOF).",
                                    "Derive intuitivamente: corpo livre tem 6 DOF, cada joint remove 1, mas ajuste por conectividade.",
                                    "Calcule DOF para mecanismo planar simples: N=4, J=4 → M=3(4-1-4)=0 (estrutura).",
                                    "Calcule para espacial: N=2, J=1 → M=6(2-1-1)=0 (corpo rígido).",
                                    "Pratique com 5 exemplos variados, verificando resultados."
                                  ],
                                  "verification": "Resolva 3 problemas de cálculo de DOF com fórmulas corretas e resultados exatos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets com fórmulas prontas",
                                    "Lista de exercícios de DOF (de livros como 'Robot Modeling and Control')"
                                  ],
                                  "tips": "Sempre subtraia 1 primeiro para contabilidade do frame fixo.",
                                  "learningObjective": "Aplicar fórmulas Grübler para calcular DOF em mecanismos.",
                                  "commonMistakes": "Usar fórmula errada (planar vs. espacial) ou esquecer parênteses em N-1-J."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar cálculo de DOF em robôs comuns",
                                  "subSteps": [
                                    "Analise robô serial 6 DOF: 6 revolute joints → M=6(7-1-6)=6.",
                                    "Calcule para robô planar 3 DOF (ex: SCARA simplificado).",
                                    "Identifique DOF em robôs reais: braços industriais (6 DOF manipulação), drones (6 DOF).",
                                    "Desenhe e calcule DOF de um gripper paralelo (mecanismo paralelo).",
                                    "Compare DOF teórico com especificações de catálogos de robôs."
                                  ],
                                  "verification": "Calcule e justifique DOF de 2 robôs reais com diagramas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Imagens/fotos de robôs (UR5, Delta robot)",
                                    "Catálogos online de ABB/Fanuc"
                                  ],
                                  "tips": "Foco em manipuladores: 6 DOF para posição+orientação completa.",
                                  "learningObjective": "Calcular e interpretar DOF em contextos robóticos práticos.",
                                  "commonMistakes": "Ignorar joints passivas ou assumir todos joints são equivalentes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e refinar cálculos de DOF",
                                  "subSteps": [
                                    "Teste mecanismo físico simples (ex: linkage de papelão).",
                                    "Use simulação para validar: mova joints e conte movimentos independentes.",
                                    "Identifique redundâncias ou singularidades que afetam DOF efetivo.",
                                    "Documente um relatório com cálculo, diagrama e verificação.",
                                    "Discuta limitações da fórmula Grübler (joints >1 DOF, passivas)."
                                  ],
                                  "verification": "Simule ou demonstre um mecanismo com DOF calculado matching movimentos reais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador gratuito (CoppeliaSim ou Linkage app)",
                                    "Materiais para modelo físico opcional"
                                  ],
                                  "tips": "Se DOF calculado ≠ movimentos observados, rever contagem de N/J.",
                                  "learningObjective": "Validar cálculos de DOF empiricamente.",
                                  "commonMistakes": "Não considerar overconstrained mechanisms onde DOF real < calculado."
                                }
                              ],
                              "practicalExample": "Calcule os DOF de um braço robótico serial com 6 juntas revolute: N=7 links (base + 6 segmentos), J=6. Usando fórmula espacial: M = 6(7-1-6) = 6 DOF, permitindo manipulação completa em 3D (posição e orientação da end-effector). Desenhe o kinematic chain e mova joints para verificar 6 movimentos independentes.",
                              "finalVerifications": [
                                "Explicar corretamente os 6 DOF de um corpo rígido livre.",
                                "Calcular DOF usando Grübler para 3 mecanismos planares e 2 espaciais com acurácia.",
                                "Identificar N e J em diagramas de robôs reais.",
                                "Demonstrar aplicação em robô 6 DOF comum.",
                                "Reconhecer limitações da fórmula em casos avançados.",
                                "Validar cálculo com simulação ou modelo físico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição conceitual de DOF (20%)",
                                "Correção na contagem de N e J (25%)",
                                "Aplicação precisa da fórmula Grübler (30%)",
                                "Análise contextual em robôs (15%)",
                                "Validação e verificação prática (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Cinemática e dinâmica de corpos rígidos.",
                                "Matemática: Álgebra linear para transformações de coordenadas.",
                                "Engenharia Mecânica: Análise de mecanismos e linkages.",
                                "Programação: Simulações em Python (SymPy para cinemática).",
                                "Design Industrial: Ergonomia em manipuladores robóticos."
                              ],
                              "realWorldApplication": "Em robótica industrial, calcular DOF garante que braços como UR5 (6 DOF) alcancem qualquer pose em espaço de trabalho, otimizando tarefas de pick-and-place, soldagem ou montagem em fábricas automotivas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Relacionar DOF com tarefas robóticas",
                            "description": "Associar DOF mínimos necessários para tarefas como pick-and-place (3 DOF) vs. soldagem (6 DOF), considerando redundância em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Graus de Liberdade (DOF)",
                                  "subSteps": [
                                    "Defina DOF como o número de movimentos independentes que um robô pode realizar.",
                                    "Explique os 6 DOF básicos: 3 translações (X, Y, Z) e 3 rotações (roll, pitch, yaw).",
                                    "Discuta como DOF é calculado em manipuladores robóticos usando fórmula de Grübler-Kutzbach.",
                                    "Identifique DOF em exemplos simples como um braço planar (2-3 DOF).",
                                    "Diferencie DOF mínimo necessário de DOF total em robôs reais."
                                  ],
                                  "verification": "Resuma em um diagrama os 6 DOF e liste 3 exemplos de robôs com DOF variados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Vídeo introdutório sobre DOF (YouTube ou Khan Academy), papel e caneta para diagramas.",
                                  "tips": "Use analogias como juntas humanas para visualizar DOF.",
                                  "learningObjective": "Compreender a base matemática e física dos DOF em robótica.",
                                  "commonMistakes": "Confundir DOF com número de juntas; lembrar que DOF é movimentos independentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Tarefas Robóticas Comuns e Seus Requisitos de DOF",
                                  "subSteps": [
                                    "Liste tarefas como pick-and-place, soldagem, pintura e inspeção.",
                                    "Para pick-and-place plano: identifique 3 DOF mínimos (2 translações + 1 rotação).",
                                    "Para soldagem 3D: justifique 6 DOF (posicionamento completo + orientação da tocha).",
                                    "Calcule DOF mínimo para cada tarefa considerando o workspace.",
                                    "Registre em uma tabela: Tarefa | DOF Mínimo | Motivo."
                                  ],
                                  "verification": "Crie uma tabela com 5 tarefas e seus DOF mínimos corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou Google Sheets, imagens de robôs industriais (ex: UR5, FANUC).",
                                  "tips": "Pense no end-effector: o que ele precisa alcançar no espaço?",
                                  "learningObjective": "Mapear requisitos espaciais de tarefas a DOF específicos.",
                                  "commonMistakes": "Ignorar orientação; pick-and-place simples não precisa de yaw completo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Tarefas e Introduzir Conceito de Redundância",
                                  "subSteps": [
                                    "Compare pick-and-place (3 DOF) vs. soldagem (6 DOF) em termos de precisão e flexibilidade.",
                                    "Defina redundância: DOF extras para evitar singularidades ou otimizar trajetórias.",
                                    "Exemplo: Robô de 7 DOF para soldagem permite redundância para alcance maior.",
                                    "Discuta trade-offs: mais DOF aumenta complexidade e custo.",
                                    "Simule cenários onde redundância é essencial em mecatrônica."
                                  ],
                                  "verification": "Explique em 2 parágrafos por que um robô de 6 DOF é insuficiente para tarefas complexas sem redundância.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de simulação gratuito como RoboDK ou CoppeliaSim, artigos sobre robôs redundantes.",
                                  "tips": "Visualize singularidades com vídeos de robôs colidindo.",
                                  "learningObjective": "Avaliar impactos de DOF e redundância em desempenho robótico.",
                                  "commonMistakes": "Achar que mais DOF sempre é melhor; considerar custo e controle."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conhecimento a Casos Práticos e Verificar",
                                  "subSteps": [
                                    "Escolha uma tarefa personalizada (ex: montagem de eletrônicos) e determine DOF.",
                                    "Inclua redundância se necessário e justifique.",
                                    "Crie um fluxograma: Tarefa → DOF Mínimo → Configuração Real.",
                                    "Debata com pares ou autoavalie limitações.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Apresente análise de uma tarefa nova com DOF justificado e redundância proposta.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramentas de desenho online (Draw.io), exemplos reais de catálogos industriais.",
                                  "tips": "Comece com tarefas familiares para construir confiança.",
                                  "learningObjective": "Sintetizar relacionamentos DOF-tarefa em contextos mecatrônicos.",
                                  "commonMistakes": "Subestimar DOF para tarefas 3D; sempre verificar orientação."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem automotiva, um robô SCARA com 4 DOF realiza pick-and-place de parafusos (3 DOF efetivos + 1 prismatico), enquanto um robô antropomórfico de 6 DOF faz soldagem de carroceria, usando redundância para evitar obstáculos.",
                              "finalVerifications": [
                                "Explicar corretamente DOF mínimo para pick-and-place (3 DOF) e soldagem (6 DOF).",
                                "Identificar quando redundância é necessária em uma tarefa dada.",
                                "Calcular DOF usando fórmula básica para um manipulador simples.",
                                "Listar 3 trade-offs de aumentar DOF em sistemas mecatrônicos.",
                                "Aplicar conceito a uma nova tarefa com 90% de precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de DOF mínimos (80% correto).",
                                "Profundidade na justificativa de redundância (inclui singularidades e otimização).",
                                "Qualidade da tabela/comparação de tarefas (clara e completa).",
                                "Criatividade na aplicação a casos reais.",
                                "Ausência de erros comuns como confundir juntas com DOF.",
                                "Completude da documentação e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cinemática e geometria espacial (matrizes de transformação).",
                                "Física: Dinâmica de corpos rígidos e forças em juntas.",
                                "Engenharia Mecânica: Design de mecanismos e análise de mobilidade.",
                                "Programação: Simulações em Python (ROS ou MATLAB Robotics Toolbox)."
                              ],
                              "realWorldApplication": "Na indústria manufatureira, engenheiros usam essa relação para selecionar robôs como os da ABB ou KUKA, otimizando custos em linhas de produção automotiva ou eletrônica, onde DOF inadequados levam a falhas ou ineficiências."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Analisar impacto de DOF em controle mecatrônico",
                            "description": "Discutir como DOF afeta atuadores, sensores e microcontroladores em projetos, com exemplos de simplificação para aplicações industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Graus de Liberdade (DOF)",
                                  "subSteps": [
                                    "Definir DOF como o número de movimentos independentes independentes de um sistema robótico.",
                                    "Classificar DOF em translacionais (x, y, z) e rotacionais (roll, pitch, yaw).",
                                    "Relacionar DOF com a mobilidade de robôs usando a fórmula de Grübler para mecanismos.",
                                    "Identificar como DOF influencia a configuração cinemática direta e inversa.",
                                    "Explorar exemplos básicos de robôs com 1 a 6 DOF."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o que é DOF e dar um exemplo de um robô com 3 DOF.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro texto de robótica (ex: 'Introduction to Robotics' de Craig)",
                                    "Vídeos tutoriais sobre DOF no YouTube",
                                    "Software de simulação como RoboDK (versão gratuita)"
                                  ],
                                  "tips": [
                                    "Use modelos físicos ou virtuais para visualizar movimentos.",
                                    "Comece com sistemas 2D antes de 3D."
                                  ],
                                  "learningObjective": "Dominar o conceito básico de DOF e sua relação com a mobilidade robótica.",
                                  "commonMistakes": [
                                    "Confundir DOF com o número total de juntas.",
                                    "Ignorar redundâncias em DOF.",
                                    "Não diferenciar DOF ativos de passivos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Impacto de DOF nos Atuadores",
                                  "subSteps": [
                                    "Determinar o número mínimo de atuadores necessário baseado no DOF do sistema.",
                                    "Calcular requisitos de torque e potência para cada DOF considerando cargas e velocidades.",
                                    "Selecionar tipos de atuadores (motores DC, servos, pneumáticos) adequados ao DOF.",
                                    "Avaliar trade-offs: mais DOF aumenta complexidade e consumo de energia.",
                                    "Simular dimensionamento de atuadores para um braço robótico com 4 DOF."
                                  ],
                                  "verification": "Dimensionar atuadores para um exemplo específico e justificar escolhas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilhas Excel para cálculos de torque",
                                    "Catálogos de atuadores (ex: Maxon, Faulhaber)",
                                    "Software MATLAB/Simulink para simulação"
                                  ],
                                  "tips": [
                                    "Considere fatores de segurança 1.5-2x no dimensionamento.",
                                    "Priorize atuadores com feedback integrado para DOF altos."
                                  ],
                                  "learningObjective": "Entender como DOF dita seleção e dimensionamento de atuadores.",
                                  "commonMistakes": [
                                    "Subestimar torque devido a inércias dinâmicas.",
                                    "Ignorar limitações de velocidade em atuadores para múltiplos DOF.",
                                    "Selecionar atuadores sem considerar peso total do sistema."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar o Impacto de DOF nos Sensores",
                                  "subSteps": [
                                    "Identificar sensores necessários por DOF (encoders para posição, IMU para orientação).",
                                    "Calcular resolução e precisão requerida baseada no número de DOF.",
                                    "Analisar fusão de sensores para feedback em sistemas multi-DOF.",
                                    "Discutir ruído e calibração em configurações com alto DOF.",
                                    "Mapear sensores para um robô com 6 DOF vs 3 DOF."
                                  ],
                                  "verification": "Listar sensores para um sistema específico e explicar sua função por DOF.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Datasheets de sensores (ex: encoders ópticos, acelerômetros)",
                                    "Ferramentas de calibração como Arduino IDE",
                                    "Simulador Gazebo/ROS"
                                  ],
                                  "tips": [
                                    "Use sensores redundantes em DOF críticos para confiabilidade.",
                                    "Teste calibração em movimento real."
                                  ],
                                  "learningObjective": "Compreender a relação entre DOF e requisitos de sensoriamento.",
                                  "commonMistakes": [
                                    "Usar sensores de baixa resolução para DOF altos.",
                                    "Não considerar latência em feedback multi-sensor.",
                                    "Ignorar interferências eletromagnéticas em setups complexos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Impacto de DOF no Controle com Microcontroladores e Simplificações Industriais",
                                  "subSteps": [
                                    "Analisar complexidade computacional de controle (ex: inversa cinemática para 6 DOF).",
                                    "Selecionar microcontroladores (Arduino, STM32) baseado em DOF e loops de controle.",
                                    "Implementar algoritmos simplificados para redução de DOF em aplicações industriais.",
                                    "Estudar exemplos: robô SCARA (4 DOF) vs antropomórfico (6 DOF).",
                                    "Otimizar controle para eficiência em cenários industriais."
                                  ],
                                  "verification": "Desenvolver um diagrama de controle para um projeto com DOF variável e discutir simplificações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Plataforma Arduino/Raspberry Pi",
                                    "Bibliotecas de controle (ROS, Arduino Servo)",
                                    "Estudos de caso industriais (ex: relatórios ABB/KUKA)"
                                  ],
                                  "tips": [
                                    "Use controle hierárquico para DOF altos.",
                                    "Simule antes de implementar hardware."
                                  ],
                                  "learningObjective": "Integrar análise de DOF no design de sistemas de controle mecatrônicos.",
                                  "commonMistakes": [
                                    "Escolher microcontroladores subpotentes para DOF altos.",
                                    "Não otimizar algoritmos levando a instabilidade.",
                                    "Ignorar simplificações viáveis em contextos industriais."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um braço robótico de pick-and-place industrial, reduzir de 6 DOF para 4 DOF simplifica o controle: requer menos atuadores (4 servos vs 6), sensores (4 encoders vs 6 + IMU) e processamento no microcontrolador (cinemática inversa mais rápida), reduzindo custo em 30% e tempo de ciclo em 20%.",
                              "finalVerifications": [
                                "Explicar como aumentar DOF afeta potência de atuadores em um exemplo numérico.",
                                "Listar sensores mínimos para um robô com 5 DOF e justificar.",
                                "Comparar complexidade de código de controle para 3 vs 6 DOF.",
                                "Identificar simplificações DOF em 3 robôs industriais reais.",
                                "Simular um sistema e verificar estabilidade de controle."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de impactos de DOF em componentes (atuadores, sensores, controle).",
                                "Uso de cálculos e exemplos quantitativos corretos.",
                                "Profundidade na discussão de trade-offs e simplificações industriais.",
                                "Clareza na integração de conceitos mecatrônicos.",
                                "Criatividade em aplicações práticas e verificações.",
                                "Ausência de erros conceituais comuns sobre DOF."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Matrizes de transformação e cinemática (algebralinear).",
                                "Física: Dinâmica de sistemas multi-corpo e leis de Newton.",
                                "Programação: Algoritmos de controle (PID, inversa cinemática em Python/C++).",
                                "Engenharia Elétrica: Interfaces de sensores e drivers de atuadores.",
                                "Gestão Industrial: Otimização de custos em automação."
                              ],
                              "realWorldApplication": "Na indústria automotiva, robôs de solda com DOF otimizados (ex: 6 DOF para alcance, mas controlados como 4 DOF em tarefas lineares) reduzem complexidade de programação em microcontroladores, minimizam falhas de sensores e aumentam throughput em linhas de montagem da Tesla ou BMW."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Aplicações Industriais de Robôs",
                        "description": "Classificação de robôs por uso em indústrias, focando em automação mecatrônica como manufatura, montagem e inspeção, com ênfase em aeronáutica.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Classificar robôs por aplicações industriais",
                            "description": "Categorizar em handling (transporte), welding (soldagem), assembly (montagem), machining (usinagem) e inspection (inspeção), usando normas como ISO 8373.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as categorias principais de aplicações industriais de robôs",
                                  "subSteps": [
                                    "Liste as cinco categorias principais: handling (transporte), welding (soldagem), assembly (montagem), machining (usinagem) e inspection (inspeção).",
                                    "Defina cada categoria com base em funções específicas: handling para manipulação de materiais, welding para junção de peças, etc.",
                                    "Identifique características comuns, como graus de liberdade e precisão requerida para cada uma.",
                                    "Crie um mapa mental ou tabela comparativa das categorias.",
                                    "Pesquise imagens ou vídeos curtos de robôs em cada aplicação para visualização."
                                  ],
                                  "verification": "Conferir se a tabela ou mapa mental inclui definições precisas e exemplos visuais para todas as cinco categorias.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de mind mapping (ex: MindMeister), acesso à internet para vídeos"
                                  ],
                                  "tips": "Use cores diferentes para cada categoria no mapa mental para facilitar a memorização visual.",
                                  "learningObjective": "Dominar as definições e distinções entre as cinco categorias de aplicações industriais de robôs.",
                                  "commonMistakes": [
                                    "Confundir handling com assembly (manipulação vs. montagem fina)",
                                    "Ignorar variações dentro de uma categoria, como spot welding vs. arc welding"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a norma ISO 8373 e sua relação com a classificação",
                                  "subSteps": [
                                    "Acesse e leia a seção relevante da ISO 8373 sobre terminologia de robôs industriais.",
                                    "Identifique como a norma define 'robô industrial' e classifica aplicações por tarefas.",
                                    "Compare as categorias da norma com handling, welding, assembly, machining e inspection.",
                                    "Anote termos chave como 'manipulador' e 'workspace' e sua aplicação nas categorias.",
                                    "Resuma em bullet points como a ISO 8373 padroniza a classificação globalmente."
                                  ],
                                  "verification": "Criar um resumo de 1 página que cite pelo menos 3 termos da ISO 8373 e os relacione às categorias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documento ISO 8373 (versão gratuita ou resumo online), bloco de notas"
                                  ],
                                  "tips": "Foque apenas nas seções de definição e classificação para evitar sobrecarga de informações técnicas.",
                                  "learningObjective": "Entender o papel da ISO 8373 na padronização da classificação de robôs industriais.",
                                  "commonMistakes": [
                                    "Ler a norma inteira sem foco (é extensa)",
                                    "Confundir classificações funcionais com estruturais (ex: serial vs. parallel)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos reais de robôs em cada aplicação",
                                  "subSteps": [
                                    "Selecione 2-3 exemplos de robôs para cada categoria (ex: ABB IRB para handling).",
                                    "Descreva o ambiente industrial e tarefas específicas de cada exemplo.",
                                    "Registre especificações técnicas como payload, alcance e sensores usados.",
                                    "Classifique cada exemplo usando as categorias e valide com ISO 8373.",
                                    "Discuta em grupo ou anote por que um robô se encaixa em uma categoria específica."
                                  ],
                                  "verification": "Montar um portfólio digital com fotos/vídeos e classificações justificadas para 10+ robôs.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Internet para catálogos de fabricantes (ABB, Fanuc, KUKA), Google Slides ou PowerPoint"
                                  ],
                                  "tips": "Busque vídeos do YouTube de fábricas reais para contextualizar as aplicações.",
                                  "learningObjective": "Associar robôs reais às categorias através de análise técnica.",
                                  "commonMistakes": [
                                    "Escolher exemplos genéricos sem specs técnicas",
                                    "Classificar incorretamente robôs multifuncionais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar classificação de robôs em cenários industriais simulados",
                                  "subSteps": [
                                    "Crie ou baixe 10 cenários industriais descritivos (ex: linha de montagem de carros).",
                                    "Classifique robôs hipotéticos ou reais em cada cenário nas cinco categorias.",
                                    "Justifique cada classificação com referências à ISO 8373 e características.",
                                    "Autoavalie acertos/erros e corrija classificações erradas.",
                                    "Simule uma apresentação explicando 3 classificações para um 'supervisor'."
                                  ],
                                  "verification": "Completar um quiz de 10 itens com 90% de acerto em classificações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel para cenários e classificações, timer para simulação"
                                  ],
                                  "tips": "Use um sistema de pontuação para autoavaliação para gamificar o aprendizado.",
                                  "learningObjective": "Aplicar o conhecimento para classificar robôs de forma autônoma e justificada.",
                                  "commonMistakes": [
                                    "Superestimar multifuncionalidade (um robô tem aplicação primária)",
                                    "Ignorar contexto industrial na classificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma fábrica de automóveis, classifique os robôs: o que levanta chassis pesados é handling; o que solda portas é welding; o que parafusar assentos é assembly; o que fresa peças é machining; o que verifica soldas com câmeras é inspection, conforme ISO 8373.",
                              "finalVerifications": [
                                "Listar corretamente as 5 categorias com definições precisas.",
                                "Citar pelo menos 2 termos chave da ISO 8373 e aplicá-los.",
                                "Classificar 8/10 robôs de exemplos reais sem erros.",
                                "Explicar diferenças entre categorias em uma apresentação de 2 minutos.",
                                "Identificar aplicação primária em robôs multifuncionais.",
                                "Mapear conexões com normas internacionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e distinção das 5 categorias (30%)",
                                "Uso correto de ISO 8373 em justificativas (25%)",
                                "Qualidade de exemplos reais e análise técnica (20%)",
                                "Desempenho em prática de classificação (15%)",
                                "Clareza na comunicação de classificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos de cinemática e precisão (graus de liberdade).",
                                "Informática: Programação de trajetórias para aplicações como welding.",
                                "Física: Dinâmica de manipulação em handling e machining.",
                                "Gestão Industrial: Otimização de layouts para assembly e inspection."
                              ],
                              "realWorldApplication": "Na indústria automotiva (ex: Ford ou Volkswagen), engenheiros classificam robôs para selecionar modelos ideais, reduzindo custos e aumentando eficiência em linhas de produção automatizadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Exemplificar aplicações na indústria aeronáutica",
                            "description": "Descrever uso de robôs articulados em pintura e montagem de fuselagens, integrando visão computacional e CLPs em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender robôs articulados e seu papel na indústria aeronáutica",
                                  "subSteps": [
                                    "Pesquisar definição e características de robôs articulados (6 eixos de liberdade)",
                                    "Identificar fabricantes como KUKA, ABB e Fanuc usados na aviação",
                                    "Analisar vantagens: precisão, repetibilidade e redução de fadiga humana",
                                    "Estudar casos iniciais de uso em montagem e pintura de aeronaves",
                                    "Mapear componentes principais: braços, juntas e controladores"
                                  ],
                                  "verification": "Listar 5 características chave e 3 fabricantes com exemplos de modelos usados na aeronáutica",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Internet para pesquisa, vídeos de robôs KUKA na Boeing, notas em documento digital",
                                  "tips": "Foque em vídeos reais de fábricas para visualização prática",
                                  "learningObjective": "Entender anatomia e benefícios de robôs articulados em contextos aeronáuticos",
                                  "commonMistakes": "Confundir com robôs cartesianos; ignorar limitações como alcance em fuselagens grandes"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever aplicação em pintura de fuselagens",
                                  "subSteps": [
                                    "Explicar processo: aplicação uniforme de primer e tinta em superfícies curvas",
                                    "Detalhar trajetórias programadas para evitar sobreposições e bolhas",
                                    "Discutir redução de VOCs (compostos orgânicos voláteis) e conformidade com normas FAA",
                                    "Analisar velocidade: até 1m/s com precisão de 0.1mm",
                                    "Comparar com pintura manual: economia de 30-50% em tempo"
                                  ],
                                  "verification": "Esboçar diagrama de um ciclo de pintura robótica com legendas",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de desenho (Draw.io), artigos da Aviation Week, imagens de fuselagens pintadas",
                                  "tips": "Use simulações 3D online para visualizar trajetórias",
                                  "learningObjective": "Dominar o processo específico de pintura automatizada em fuselagens",
                                  "commonMistakes": "Subestimar desafios de superfícies irregulares; omitir normas de segurança"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar aplicação em montagem de fuselagens",
                                  "subSteps": [
                                    "Descrever tarefas: posicionamento de painéis, rebite e solda automatizada",
                                    "Explicar precisão para alinhamento: tolerâncias <0.5mm em estruturas de 30m",
                                    "Analisar integração com ferramentas de fim de braço (EOAT) como grampos",
                                    "Estudar fluxo de produção: robôs em células flexíveis para modelos variados",
                                    "Quantificar ganhos: aumento de 40% na taxa de montagem por hora"
                                  ],
                                  "verification": "Criar fluxograma de montagem com 5 etapas robóticas sequenciais",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Vídeos da Airbus A350 montagem, planilhas Excel para fluxos, fotos de linhas de produção",
                                  "tips": "Assista tours virtuais de fábricas da Embraer para contexto real",
                                  "learningObjective": "Mapear processos de montagem robótica em fuselagens grandes",
                                  "commonMistakes": "Ignorar colaboração homem-robô; exagerar capacidades sem dados reais"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar visão computacional e CLPs nos sistemas mecatrônicos",
                                  "subSteps": [
                                    "Explicar visão computacional: câmeras 3D para detecção de defeitos e alinhamento",
                                    "Detalhar CLPs (Controladores Lógicos Programáveis): Siemens S7 para coordenação em tempo real",
                                    "Descrever arquitetura: robô + visão + CLP + HMI em rede EtherCAT",
                                    "Analisar feedback loops: correção de trajetória baseada em visão",
                                    "Simular falhas: como CLP gerencia paradas de emergência"
                                  ],
                                  "verification": "Montar esquema de integração com fluxos de dados entre componentes",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Diagramas Ladder para CLP, tutoriais de visão Cognex, software de simulação gratuita como RoboDK",
                                  "tips": "Teste simulações simples para ver integração em ação",
                                  "learningObjective": "Compreender sinergia de visão, CLPs e robôs em mecatrônica aeronáutica",
                                  "commonMistakes": "Confundir visão 2D com 3D; negligenciar latência em loops de controle"
                                }
                              ],
                              "practicalExample": "Na produção do Boeing 787 Dreamliner, robôs articulados KUKA KR QUANTEC aplicam pintura em fuselagens de compósito, usando câmeras de visão Keyence para inspecionar uniformidade em tempo real, enquanto CLPs Rockwell ControlLogix sincronizam 6 robôs em célula, reduzindo retrabalho em 70%.",
                              "finalVerifications": [
                                "Descrever com precisão o ciclo de pintura robótica em fuselagem",
                                "Explicar alinhamento via visão computacional em montagem",
                                "Listar 3 funções chave do CLP na integração mecatrônica",
                                "Comparar eficiência robótica vs. manual com dados quantitativos",
                                "Identificar 2 normas aeronáuticas relevantes (ex: FAA AC 20-148)",
                                "Montar diagrama completo de sistema integrado"
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: uso correto de termos como '6 eixos' e 'EtherCAT' (30%)",
                                "Detalhe prático: inclusão de exemplos reais e métricas (25%)",
                                "Estrutura lógica: sequência clara de processos (20%)",
                                "Integração interdisciplinar: ligação visão/CLP/robô (15%)",
                                "Criatividade em verificações: diagramas e simulações originais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Aeroespacial: normas de fabricação de fuselagens",
                                "Programação Industrial: linguagens Ladder e visão em Python/OpenCV",
                                "Materiais: compósitos em fuselagens e pinturas especiais",
                                "Gestão de Produção: lean manufacturing em linhas robóticas"
                              ],
                              "realWorldApplication": "Em fábricas da Embraer (Brasil) e Airbus (Europa), esses sistemas reduzem custos de produção em 25-40%, aceleram entregas de aeronaves comerciais e militares, e atendem demandas de alta precisão para segurança de voo, com escalabilidade para Industry 4.0 via IoT."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.1",
                              "10.1.3.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Avaliar integração mecatrônica em aplicações",
                            "description": "Analisar times multifuncionais para projetos de robôs industriais, considerando microprocessadores e desenvolvimento integrado de produtos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar componentes mecatrônicos chave em robôs industriais",
                                  "subSteps": [
                                    "Listar os principais componentes: atuadores, sensores, microcontroladores e estruturas mecânicas.",
                                    "Descrever funções individuais de cada componente em um robô industrial.",
                                    "Mapear interdependências entre componentes mecânicos, eletrônicos e de software.",
                                    "Analisar diagramas de blocos de um robô industrial exemplo.",
                                    "Documentar limitações e requisitos de cada componente."
                                  ],
                                  "verification": "Criar um diagrama completo de componentes com funções e interdependências descritas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Diagramas de robôs industriais, software de desenho (ex: Draw.io), apostilas de mecatrônica.",
                                  "tips": "Comece pelos componentes mecânicos e avance para os eletrônicos para visualizar fluxos.",
                                  "learningObjective": "Compreender a composição básica de sistemas mecatrônicos em robótica industrial.",
                                  "commonMistakes": "Ignorar interdependências, focando apenas em componentes isolados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar integração de microprocessadores nos sistemas",
                                  "subSteps": [
                                    "Estudar arquitetura de microprocessadores comuns (ex: Arduino, ARM) em robôs.",
                                    "Examinar interfaces de comunicação (I2C, SPI, CAN) com sensores e atuadores.",
                                    "Simular controle em tempo real de movimentos robóticos via microprocessador.",
                                    "Avaliar consumo de energia e processamento para aplicações industriais.",
                                    "Identificar protocolos de segurança integrados ao microprocessador."
                                  ],
                                  "verification": "Desenvolver um fluxograma da integração do microprocessador com outros componentes.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Simulador Tinkercad ou Proteus, documentação de microcontroladores, osciloscópio virtual.",
                                  "tips": "Teste simulações com cenários de falha para entender robustez.",
                                  "learningObjective": "Dominar o papel central dos microprocessadores na integração mecatrônica.",
                                  "commonMistakes": "Subestimar latência em comunicações, levando a análises imprecisas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar times multifuncionais para projetos robóticos",
                                  "subSteps": [
                                    "Definir papéis: engenheiros mecânicos, eletrônicos, programadores e integradores.",
                                    "Analisar fluxos de comunicação e ferramentas colaborativas (ex: Jira, Git).",
                                    "Estudar casos de conflitos interdisciplinares e resoluções.",
                                    "Mapear responsabilidades em fases de projeto: design, prototipagem, testes.",
                                    "Avaliar métricas de desempenho de equipe em projetos reais."
                                  ],
                                  "verification": "Elaborar organograma de equipe com responsabilidades e fluxos de interação.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Estudos de caso de projetos robóticos, ferramentas de gestão (ex: Miro), vídeos de teams ágeis.",
                                  "tips": "Use exemplos reais como projetos da ABB ou Fanuc para contextualizar.",
                                  "learningObjective": "Entender dinâmicas de times multifuncionais em mecatrônica.",
                                  "commonMistakes": "Focar apenas em habilidades técnicas, ignorando soft skills."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar desenvolvimento integrado de produtos mecatrônicos",
                                  "subSteps": [
                                    "Descrever metodologias ágeis e V-model para integração.",
                                    "Analisar ciclos de iteração: protótipo, teste, refinamento.",
                                    "Avaliar ferramentas CAD/CAM integradas com simulação (ex: SolidWorks + MATLAB).",
                                    "Estudar certificações industriais (ISO 10218 para robôs).",
                                    "Realizar análise de risco integrada ao desenvolvimento."
                                  ],
                                  "verification": "Produzir relatório de ciclo de desenvolvimento com timeline e riscos.",
                                  "estimatedTime": "2,5 horas",
                                  "materials": "Software CAD gratuito (Fusion 360), normas ISO, templates de relatórios.",
                                  "tips": "Integre feedback loops em cada iteração para simular realismo.",
                                  "learningObjective": "Aplicar processos integrados ao desenvolvimento de produtos robóticos.",
                                  "commonMistakes": "Pular testes de integração, causando falhas tardias."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar avaliação integrada da aplicação mecatrônica",
                                  "subSteps": [
                                    "Sintetizar análise de componentes, microprocessadores, times e desenvolvimento.",
                                    "Pontuar forças, fraquezas, oportunidades e ameaças (SWOT).",
                                    "Simular cenário completo de aplicação industrial.",
                                    "Propor melhorias baseadas na avaliação.",
                                    "Documentar recomendações finais."
                                  ],
                                  "verification": "Apresentar relatório SWOT e plano de melhorias validado por pares.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Planilhas SWOT, simulador robótico (Gazebo/ROS), gravador de tela.",
                                  "tips": "Use métricas quantitativas (ex: tempo de ciclo, taxa de falha) na avaliação.",
                                  "learningObjective": "Sintetizar conhecimentos para uma avaliação holística.",
                                  "commonMistakes": "Fazer avaliação superficial sem dados quantitativos."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem automotiva, avalie a integração mecatrônica de um robô de soldagem: analise como o microprocessador controla sensores de visão e atuadores pneumáticos, com um time multifuncional iterando no desenvolvimento para reduzir tempo de ciclo em 20%.",
                              "finalVerifications": [
                                "Diagrama completo de integração mecatrônica com microprocessadores.",
                                "Organograma de time multifuncional com fluxos claros.",
                                "Relatório SWOT da aplicação com métricas quantitativas.",
                                "Simulação funcional de um cenário industrial.",
                                "Lista de recomendações acionáveis com prazos.",
                                "Autoavaliação alinhada aos critérios de assessment."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes e interdependências (0-20%).",
                                "Profundidade na análise de microprocessadores e interfaces (0-20%).",
                                "Compreensão de dinâmicas de times multifuncionais (0-20%).",
                                "Qualidade do processo de desenvolvimento integrado descrito (0-20%).",
                                "Avaliação holística com SWOT e recomendações viáveis (0-20%)."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Elétrica: Circuitos e controle de microprocessadores.",
                                "Gestão de Projetos: Metodologias ágeis para times multifuncionais.",
                                "Programação: Algoritmos de controle em tempo real (ROS/Python).",
                                "Normas e Segurança: ISO para robótica industrial."
                              ],
                              "realWorldApplication": "Na indústria automotiva (ex: fábricas da Volkswagen), avaliar integração mecatrônica otimiza robôs de pintura e montagem, reduzindo downtime em 30% e custos de manutenção via times colaborativos e desenvolvimento integrado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.4",
                        "name": "Integração de Classificações",
                        "description": "Síntese das classificações por configuração, DOF e aplicações para seleção de robôs em projetos mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.4.1",
                            "name": "Selecionar robô adequado por critérios combinados",
                            "description": "Combinar configuração, DOF e aplicação para escolher robô ideal, ex: SCARA 4 DOF para montagem de precisão em eletrônicos aeronáuticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e priorizar os critérios de seleção",
                                  "subSteps": [
                                    "Analise a tarefa ou aplicação proposta (ex: montagem de precisão em eletrônicos aeronáuticos).",
                                    "Liste os critérios principais: configuração (SCARA, articulada, etc.), graus de liberdade (DOF), payload, alcance, precisão e ambiente de operação.",
                                    "Atribua pesos ou prioridades aos critérios com base na aplicação (ex: precisão > velocidade para eletrônicos).",
                                    "Documente os requisitos em uma tabela ou matriz de decisão.",
                                    "Consulte especificações técnicas de aplicações semelhantes."
                                  ],
                                  "verification": "Verifique se há uma lista completa e priorizada de critérios documentada, com pelo menos 5 itens principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel ou planilha digital (Excel/Google Sheets), exemplos de aplicações industriais.",
                                  "tips": "Use o método SMART para definir critérios (Specific, Measurable, Achievable, Relevant, Time-bound).",
                                  "learningObjective": "Compreender como extrair e priorizar requisitos funcionais para seleção de robôs.",
                                  "commonMistakes": "Ignorar critérios secundários como custo ou manutenção; priorizar subjetivamente sem justificativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar e listar opções de robôs compatíveis",
                                  "subSteps": [
                                    "Revise classificações de robôs: configurações (cartesiana, cilíndrica, polar, SCARA, articulada) e faixas de DOF (3-7 DOF).",
                                    "Pesquise catálogos de fabricantes (ex: ABB, Fanuc, Universal Robots) para robôs que atendam aos critérios iniciais.",
                                    "Liste 4-6 opções viáveis com specs chave: DOF, configuração, precisão, payload.",
                                    "Crie uma tabela comparativa inicial com colunas para cada critério.",
                                    "Elimine opções obviamente inadequadas (ex: robô de 6 DOF para tarefa planar simples)."
                                  ],
                                  "verification": "Confirme a existência de uma tabela com pelo menos 4 robôs listados e specs básicas preenchidas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Catálogos online de robôs (sites de ABB, KUKA), tabela comparativa digital.",
                                  "tips": "Filtre por DOF primeiro: 4 DOF para SCARA em pick-and-place planar.",
                                  "learningObjective": "Mapear classificações de robôs a requisitos práticos.",
                                  "commonMistakes": "Listar robôs irrelevantes sem filtro inicial; copiar specs sem verificar fontes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar e comparar opções usando matriz de decisão",
                                  "subSteps": [
                                    "Pontue cada robô em uma escala de 1-10 para cada critério priorizado.",
                                    "Calcule pontuações ponderadas multiplicando por pesos dos critérios.",
                                    "Some as pontuações totais e rankeie as opções.",
                                    "Identifique trade-offs (ex: SCARA 4 DOF alta precisão mas alcance limitado).",
                                    "Discuta qualitativamente aspectos como integração e custo."
                                  ],
                                  "verification": "Verifique a matriz completa com pontuações, pesos e ranking final.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha com fórmulas para pontuação automática (Excel), calculadora.",
                                  "tips": "Use 0.3 para precisão, 0.25 para DOF, etc., somando a 1.0 para pesos.",
                                  "learningObjective": "Aplicar análise quantitativa e qualitativa para comparação de sistemas mecatrônicos.",
                                  "commonMistakes": "Pontuações enviesadas por preferência pessoal; ignorar trade-offs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar o robô ideal e justificar a escolha",
                                  "subSteps": [
                                    "Escolha o robô com maior pontuação total, confirmando adequação a todos critérios chave.",
                                    "Escreva uma justificativa detalhada ligando specs à aplicação (ex: SCARA 4 DOF para montagem precisa).",
                                    "Simule cenários de falha: o que acontece se DOF for insuficiente?",
                                    "Proponha testes iniciais de viabilidade.",
                                    "Documente a seleção final com referências."
                                  ],
                                  "verification": "Leia a justificativa: deve cobrir todos critérios e explicar por que outros foram descartados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentador (Word/Google Docs), simulações básicas (papel ou software gratuito como RoboDK).",
                                  "tips": "Estruture justificativa como: 'Critério X atendido por Y porque Z'.",
                                  "learningObjective": "Desenvolver habilidades de tomada de decisão baseada em evidências em robótica.",
                                  "commonMistakes": "Selecionar sem justificativa clara; subestimar integração com outros sistemas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar a seleção com verificações finais",
                                  "subSteps": [
                                    "Verifique compatibilidade com ambiente (espaço, segurança, normas ISO 10218).",
                                    "Consulte cases reais ou simulações para aplicações similares.",
                                    "Avalie custo-benefício e escalabilidade.",
                                    "Peça feedback de pares ou tutor sobre a escolha.",
                                    "Atualize a documentação com lições aprendidas."
                                  ],
                                  "verification": "Checklist de validação preenchida com todas caixas marcadas e notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Checklist impresso/digital, acesso a cases de estudo online.",
                                  "tips": "Use normas como ISO/TS 15066 para cobots em validação.",
                                  "learningObjective": "Garantir robustez na seleção através de validação iterativa.",
                                  "commonMistakes": "Pular validação ambiental; aceitar seleção sem revisão externa."
                                }
                              ],
                              "practicalExample": "Para montagem de precisão em eletrônicos aeronáuticos: requisitos incluem alta precisão (±0.01mm), operação planar, payload 5kg. Opções: SCARA 4 DOF (selecionado: Epson T3-401S, precisão ideal para pick-and-place), vs. articulado 6 DOF (descartado: excesso DOF aumenta custo sem benefício). Justificativa: 4 DOF otimiza para movimentos XY-Z simples.",
                              "finalVerifications": [
                                "O robô selecionado atende a todos os critérios priorizados com specs verificadas?",
                                "A matriz de decisão está completa com pontuações ponderadas?",
                                "Justificativa explica eliminação de alternativas?",
                                "Compatibilidade com ambiente e normas de segurança confirmada?",
                                "Trade-offs documentados e mitigados?",
                                "Simulação ou case real suporta a escolha?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de critérios (cobertura >90% dos requisitos relevantes).",
                                "Qualidade da matriz comparativa (pontuações lógicas, pesos somam 100%).",
                                "Profundidade da justificativa (liga specs diretamente à aplicação).",
                                "Número de opções avaliadas (mínimo 4 viáveis).",
                                "Validação final abrangente (inclui normas e trade-offs).",
                                "Documentação clara e profissional."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Mecânica: Cinemática e dinâmica de robôs.",
                                "Programação: Integração com linguagens como ROS para simulação.",
                                "Gestão de Projetos: Análise custo-benefício e matriz de decisão.",
                                "Segurança Industrial: Normas ISO para robótica colaborativa.",
                                "Eletrônica: Interfaces para sensores em montagem precisa."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica (ex: Boeing), SCARA 4 DOF é usado para montagem de circuitos impressos precisos, reduzindo erros humanos em 95% e aumentando throughput em linhas de produção automatizadas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.2",
                              "10.1.3.3.2.1",
                              "10.1.3.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.4.2",
                            "name": "Mapear classificações a projetos reais",
                            "description": "Relacionar com bibliografia (ex: Shetty & Kolk) para casos de estudo em mecatrônica industrial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar classificações de robôs e bibliografia relevante",
                                  "subSteps": [
                                    "Ler capítulos sobre classificação de robôs em Shetty & Kolk.",
                                    "Listar classificações principais: por configuração (Cartesian, SCARA, Articulado, Delta), por aplicação (industrial, móvel, colaborativo) e por grau de liberdade.",
                                    "Anotar exemplos teóricos da bibliografia.",
                                    "Identificar lacunas em exemplos reais industriais.",
                                    "Criar tabela resumida das classificações com definições."
                                  ],
                                  "verification": "Tabela de classificações completada e revisada.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro Shetty & Kolk, caderno ou ferramenta digital (Notion, Google Docs)",
                                  "tips": "Priorize classificações aplicáveis à mecatrônica industrial.",
                                  "learningObjective": "Dominar as classificações padrão de robôs com base bibliográfica.",
                                  "commonMistakes": "Confundir classificações por configuração com as por aplicação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar projetos reais em mecatrônica industrial",
                                  "subSteps": [
                                    "Buscar cases de estudo em bases como IEEE Xplore, ResearchGate ou sites de fabricantes (ABB, Fanuc).",
                                    "Selecionar 8-10 projetos representativos de robótica industrial.",
                                    "Documentar para cada um: tipo de robô, aplicação, specs técnicas e fabricante.",
                                    "Classificar preliminarmente cada projeto com base no Step 1.",
                                    "Coletar evidências visuais (fotos, vídeos, diagramas)."
                                  ],
                                  "verification": "Lista documentada de pelo menos 8 projetos com classificações preliminares.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Acesso à internet, artigos acadêmicos pagos ou gratuitos",
                                  "tips": "Foquem em projetos recentes (pós-2015) para relevância atual.",
                                  "learningObjective": "Identificar exemplos concretos de robôs em contextos industriais.",
                                  "commonMistakes": "Selecionar projetos não industriais ou irrelevantes para mecatrônica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar o mapeamento de classificações a projetos",
                                  "subSteps": [
                                    "Criar matriz em planilha: linhas para classificações, colunas para projetos.",
                                    "Atribuir pelo menos 2 projetos por classificação, justificando com specs.",
                                    "Referenciar Shetty & Kolk para validação teórica.",
                                    "Destacar padrões (ex: SCARA em montagem de eletrônicos).",
                                    "Adicionar notas sobre adaptações industriais."
                                  ],
                                  "verification": "Matriz de mapeamento preenchida com justificativas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Google Sheets ou Excel, livro Shetty & Kolk",
                                  "tips": "Use cores na matriz para facilitar visualização.",
                                  "learningObjective": "Estabelecer relações precisas entre teoria e prática.",
                                  "commonMistakes": "Forçar mapeamentos sem evidências técnicas sólidas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar, validar e documentar o mapeamento",
                                  "subSteps": [
                                    "Verificar consistência cruzando com bibliografia adicional.",
                                    "Identificar hibridizações ou exceções nos projetos.",
                                    "Criar diagrama visual do mapeamento (ex: mindmap).",
                                    "Escrever relatório resumido com insights chave.",
                                    "Realizar autoavaliação respondendo: 'Por que esse robô é ideal para essa aplicação?'."
                                  ],
                                  "verification": "Relatório final e diagrama produzidos.",
                                  "estimatedTime": "1,5 horas",
                                  "materials": "Ferramenta de diagramação (Draw.io, Lucidchart), processador de texto",
                                  "tips": "Inclua citações APA para profissionalismo.",
                                  "learningObjective": "Validar e comunicar o mapeamento de forma clara e acionável.",
                                  "commonMistakes": "Ignorar exceções que enriquecem a análise."
                                }
                              ],
                              "practicalExample": "Mapear robô SCARA (classificação por configuração) ao projeto de montagem de smartphones da Foxconn, referenciado em Shetty & Kolk para precisão em tarefas de pick-and-place, com specs de 4 graus de liberdade e integração mecatrônica.",
                              "finalVerifications": [
                                "Todas classificações mapeadas com pelo menos 2 projetos reais.",
                                "Justificativas técnicas alinhadas à bibliografia.",
                                "Matriz e diagrama visuais completos e legíveis.",
                                "Relatório sem erros factuais ou inconsistências.",
                                "Insights sobre tendências industriais incluídos.",
                                "Referências bibliográficas corretas e citadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das classificações e mapeamentos (90%+ de acurácia).",
                                "Completude: cobertura de todas classes principais.",
                                "Profundidade das justificativas e referências.",
                                "Clareza e qualidade visual dos artefatos (matriz, diagrama).",
                                "Relevância aos casos de mecatrônica industrial.",
                                "Originalidade nos insights e análise de padrões."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Mecânica: Cinemática e design de manipuladores.",
                                "Engenharia Elétrica: Sistemas de controle e atuadores.",
                                "Ciência da Computação: Programação de trajetórias robóticas.",
                                "Gestão Industrial: Otimização de linhas de produção."
                              ],
                              "realWorldApplication": "Facilita a seleção otimizada de robôs em projetos mecatrônicos industriais, como automação de fábricas, reduzindo custos de prototipagem e acelerando integração em linhas de produção, conforme cases em Shetty & Kolk."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Aplicações Mecatrônicas na Indústria Aeronáutica",
                    "description": "Exemplos de robótica em processos de fabricação, inspeção e montagem aeronáutica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Robótica Mecatrônica em Fabricação Aeronáutica",
                        "description": "Exploração de robôs mecatrônicos utilizados em processos de fabricação de componentes aeronáuticos, integrando microcontroladores, atuadores e sensores para automação de corte, usinagem e conformação de materiais compostos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Identificar robôs de fabricação em aviões",
                            "description": "Reconhecer exemplos de robôs articulados e cartesianos aplicados na fabricação de fuselagens e asas, destacando integração mecatrônica com microprocessadores para precisão em lay-up de compósitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos básicos de robôs industriais: articulados e cartesianos",
                                  "subSteps": [
                                    "Estude a definição e características de robôs articulados (juntas rotativas semelhantes a braços humanos).",
                                    "Analise robôs cartesianos (movimento linear em eixos X, Y, Z).",
                                    "Compare graus de liberdade, alcance e precisão de cada tipo.",
                                    "Visualize diagramas de anatomia robótica para ambos.",
                                    "Identifique símbolos padronizados em desenhos técnicos."
                                  ],
                                  "verification": "Desenhe ou descreva diferenças entre um robô articulado e cartesiano com precisão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagramas de robôs (impressos ou digitais), vídeo introdutório sobre cinemática robótica.",
                                  "tips": "Use analogias: articulado como braço humano, cartesiano como impressora 3D.",
                                  "learningObjective": "Diferenciar anatomicamente robôs articulados de cartesianos.",
                                  "commonMistakes": "Confundir alcance flexível do articulado com precisão linear do cartesiano."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar aplicações na fabricação aeronáutica de fuselagens e asas",
                                  "subSteps": [
                                    "Pesquise uso de robôs cartesianos em lay-up automatizado de fuselagens.",
                                    "Identifique robôs articulados em montagem de asas para pintura e soldagem.",
                                    "Analise cases de empresas como Boeing ou Airbus.",
                                    "Mapeie processos: corte, laminação e posicionamento de painéis compostos.",
                                    "Registre vantagens como repetibilidade em grandes estruturas."
                                  ],
                                  "verification": "Liste 3 aplicações específicas por tipo de robô em aviões.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Vídeos de linhas de produção aeronáutica (YouTube ou sites de fabricantes), catálogos de robôs ABB/KUKA.",
                                  "tips": "Foquem em escala: cartesianos para áreas planas grandes, articulados para curvas.",
                                  "learningObjective": "Associar tipos de robôs a componentes aeronáuticos específicos.",
                                  "commonMistakes": "Ignorar limitações de payload em estruturas leves de compósitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar integração mecatrônica com microprocessadores para precisão",
                                  "subSteps": [
                                    "Estude sensores (visão, força) integrados a microcontroladores como Arduino ou PLC.",
                                    "Compreenda feedback loops para precisão em lay-up de compósitos (tolerância <0.1mm).",
                                    "Simule controle PID via software simples.",
                                    "Examine interfaces homem-máquina (HMI) em estações robóticas.",
                                    "Discuta segurança: intertravamentos e zonas de exclusão."
                                  ],
                                  "verification": "Explique como um microprocessador corrige desvios em tempo real.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Simulador Tinkercad ou ROS para robótica, diagramas de sistemas mecatrônicos.",
                                  "tips": "Pense em camadas: mecânica + eletrônica + software = mecatrônica.",
                                  "learningObjective": "Reconhecer componentes mecatrônicos que garantem precisão robótica.",
                                  "commonMistakes": "Subestimar vibrações em compósitos afetando precisão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em exemplos reais de fabricação de aviões",
                                  "subSteps": [
                                    "Observe imagens/vídeos de robôs em ação na Embraer ou Boeing.",
                                    "Classifique 5 robôs como articulados ou cartesianos e justifique.",
                                    "Identifique sinais de integração mecatrônica (câmeras, cabos de dados).",
                                    "Crie um fluxograma de identificação rápida.",
                                    "Teste com quiz de imagens rotuladas."
                                  ],
                                  "verification": "Acertar 90% em identificação de 10 exemplos mistos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Banco de imagens de robôs aeronáuticos, ferramenta Quizlet ou Google Forms.",
                                  "tips": "Procure por trilhos lineares (cartesiano) vs bases rotativas (articulado).",
                                  "learningObjective": "Identificar robôs em contextos reais de fabricação aeronáutica.",
                                  "commonMistakes": "Confundir manipuladores colaborativos com industriais puros."
                                }
                              ],
                              "practicalExample": "Em uma linha de produção da Boeing 787, robôs cartesianos posicionam camadas de fibra de carbono na fuselagem com precisão de 0.05mm, controlados por microprocessadores Siemens que ajustam via sensores de visão, enquanto robôs articulados KUKA aplicam resina em asas curvas.",
                              "finalVerifications": [
                                "Diferencia corretamente robôs articulados de cartesianos em imagens.",
                                "Cita aplicações específicas em fuselagens e asas.",
                                "Explica papel de microprocessadores na precisão de lay-up.",
                                "Identifica pelo menos 3 componentes mecatrônicos visíveis.",
                                "Descreve vantagens na fabricação de compósitos.",
                                "Realiza classificação precisa em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de tipos robóticos (30%)",
                                "Compreensão de aplicações aeronáuticas (25%)",
                                "Conhecimento de integração mecatrônica (20%)",
                                "Capacidade de identificação prática (15%)",
                                "Clareza em explicações e justificativas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Materiais Avançados: Propriedades de compósitos em lay-up.",
                                "Eletrônica: Programação de microprocessadores e sensores.",
                                "Física: Cinemática e dinâmica robótica.",
                                "Informática: Simulações em ROS ou MATLAB."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Embraer ou Airbus, engenheiros usam essa habilidade para otimizar linhas de produção, reduzindo defeitos em fuselagens compostas e acelerando montagem de asas, economizando milhões em retrabalho."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Analisar controle de robôs em usinagem",
                            "description": "Estudar o uso de CLPs e microcontroladores em robôs para controle de trajetória em fresagem de peças aeronáuticas, considerando feedback de sensores para tolerâncias submiligimétricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de CLPs e Microcontroladores em Robótica",
                                  "subSteps": [
                                    "Estudar a arquitetura de CLPs (Controladores Lógicos Programáveis) e suas linguagens de programação como Ladder Logic e Structured Text.",
                                    "Analisar microcontroladores como Arduino ou STM32 usados em robôs industriais, focando em pinos I/O e comunicação serial.",
                                    "Comparar CLPs vs. microcontroladores em termos de robustez, tempo real e custo para aplicações de usinagem.",
                                    "Identificar interfaces comuns como Ethernet/IP e Modbus para integração com robôs.",
                                    "Revisar exemplos de código básico para controle de motores passo a passo."
                                  ],
                                  "verification": "Desenhar um diagrama simples de um sistema CLP-microcontrolador controlando um atuador robótico.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação de CLPs (Siemens S7), tutoriais Arduino, software PLC Simulator (como PLCSIM).",
                                  "tips": "Comece com simulações gratuitas para evitar hardware caro inicialmente.",
                                  "learningObjective": "Dominar os componentes básicos de controle em robótica industrial.",
                                  "commonMistakes": "Confundir CLPs com microcontroladores sem considerar certificações industriais de CLPs."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Controle de Trajetória em Fresagem Robótica",
                                  "subSteps": [
                                    "Aprender interpolação linear e circular para trajetórias de fresagem CNC em robôs de 6 eixos.",
                                    "Analisar algoritmos de cinemática direta e inversa para posicionamento de ferramentas em fresadoras robóticas.",
                                    "Estudar planejamento de caminhos (path planning) evitando colisões em peças complexas aeronáuticas.",
                                    "Explorar G-code e adaptações para robôs como ABB ou KUKA.",
                                    "Simular uma trajetória simples de fresagem em software CAD/CAM."
                                  ],
                                  "verification": "Gerar e simular um G-code para fresar um contorno retangular em uma peça teste.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software RoboDK ou ROS (Robot Operating System), tutoriais KUKA Sim.",
                                  "tips": "Use visualizações 3D para validar trajetórias antes de codificar.",
                                  "learningObjective": "Capacitar-se a planejar e controlar movimentos precisos de robôs em usinagem.",
                                  "commonMistakes": "Ignorar singularidades cinemáticas que causam desvios em trajetórias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Feedback de Sensores para Controle Preciso",
                                  "subSteps": [
                                    "Identificar sensores chave: encoders ópticos, LVDTs, lasers para medição de posição e força.",
                                    "Estudar loops de feedback fechado (PID controllers) implementados em CLPs para correção de trajetória.",
                                    "Analisar fusão de sensores (sensor fusion) para tolerâncias submiligimétricas (ex: <0.01mm).",
                                    "Configurar interruptores de segurança e sensores de vibração em cenários de fresagem.",
                                    "Testar um loop PID simulado para correção de desvio em tempo real."
                                  ],
                                  "verification": "Implementar e testar um controlador PID em simulador, medindo erro de tracking <1%.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "MATLAB/Simulink para PID, sensores simulados em Tinkercad ou Multisim.",
                                  "tips": "Ajuste gains PID iterativamente: comece com P, adicione I e D.",
                                  "learningObjective": "Implementar sistemas de feedback para precisão submiligimétrica.",
                                  "commonMistakes": "Saturação do atuador por gains PID mal tunados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Aplicação em Fresagem de Peças Aeronáuticas",
                                  "subSteps": [
                                    "Revisar requisitos de tolerâncias em peças aeronáuticas (ex: flanges de turbinas com ±0.005mm).",
                                    "Diagramar um sistema completo: robô + CLP + sensores para fresagem de alumínio ou titânio.",
                                    "Avaliar impactos de vibrações e dilatação térmica no controle.",
                                    "Estudar casos reais de falhas e correções em indústrias como Embraer ou Boeing.",
                                    "Propor melhorias como IA para predição de desvios."
                                  ],
                                  "verification": "Elaborar relatório com diagrama e análise de um caso de fresagem aeronáutica.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Artigos IEEE sobre robótica aeronáutica, CATIA ou SolidWorks para modelos 3D.",
                                  "tips": "Foquem em normas como AS9100 para qualidade aeronáutica.",
                                  "learningObjective": "Aplicar conhecimentos a contextos industriais reais de alta precisão.",
                                  "commonMistakes": "Subestimar efeitos térmicos em materiais exóticos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simular e Validar o Sistema de Controle",
                                  "subSteps": [
                                    "Construir simulação integrada em software unificado (ex: ROS + Gazebo).",
                                    "Executar cenários com ruídos de sensores e falhas para testar robustez.",
                                    "Medir métricas: precisão de trajetória, tempo de ciclo, estabilidade.",
                                    "Otimizar parâmetros baseados em resultados de simulação.",
                                    "Documentar lições aprendidas e plano de implementação real."
                                  ],
                                  "verification": "Demonstrar simulação com erro médio <0.01mm em trajetória complexa.",
                                  "estimatedTime": "3 horas",
                                  "materials": "ROS/Gazebo, Python para scripts de análise.",
                                  "tips": "Grave vídeos da simulação para análise posterior.",
                                  "learningObjective": "Validar holisticamente o controle robótico antes de hardware.",
                                  "commonMistakes": "Não simular condições reais como latência de rede."
                                }
                              ],
                              "practicalExample": "Em uma linha de produção da Embraer, um robô KUKA KR AGILUS usa CLP Siemens S7-1500 e microcontrolador Raspberry Pi para fresar furos em flanges de titânio de motor a jato. Sensores laser medem desvios em tempo real, aplicando correções PID para manter tolerâncias de 0.008mm, reduzindo refugos em 30%.",
                              "finalVerifications": [
                                "Diagramar sistema completo com CLP, microcontrolador, sensores e robô.",
                                "Simular trajetória de fresagem com feedback, medindo precisão submiligimétrica.",
                                "Explicar PID tuning para correção de desvios em usinagem aeronáutica.",
                                "Identificar 3 riscos e mitigações em cenários reais.",
                                "Comparar performance com métodos CNC tradicionais.",
                                "Propor otimização para peça aeronáutica específica."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de componentes e algoritmos (30%).",
                                "Profundidade na análise de feedback e tolerâncias (25%).",
                                "Qualidade da simulação e verificações práticas (20%).",
                                "Relevância a aplicações aeronáuticas (15%).",
                                "Clareza e estrutura do relatório/diagrama (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Ladder Logic e Python para ROS.",
                                "Física: Cinemática, dinâmica e controle PID.",
                                "Engenharia de Materiais: Propriedades de ligas aeronáuticas.",
                                "Inteligência Artificial: Machine Learning para predição de erros.",
                                "Gestão de Projetos: Normas AS9100 e ciclos de produção."
                              ],
                              "realWorldApplication": "Na fabricação de componentes de aeronaves como asas e turbinas pela Boeing ou Airbus, onde robôs controlados por CLPs com feedback sensorial garantem precisão submiligimétrica, reduzindo custos de retrabalho e atendendo certificações FAA/EASA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Avaliar eficiência mecatrônica na produção",
                            "description": "Comparar robótica mecatrônica versus métodos manuais em fabricação aeronáutica, usando métricas de produtividade e redução de desperdício baseadas em referências como Shetty e Kolk.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais e referências chave",
                                  "subSteps": [
                                    "Ler capítulos relevantes de Shetty e Kolk sobre eficiência em mecatrônica aeronáutica.",
                                    "Identificar definições de produtividade (ex.: peças/hora) e redução de desperdício (ex.: % de material perdido).",
                                    "Anotar diferenças entre métodos manuais e robótica mecatrônica em fabricação de componentes aeronáuticos.",
                                    "Mapear métricas padrão usadas na indústria aeronáutica.",
                                    "Resumir em um quadro comparativo inicial os prós e contras conceituais."
                                  ],
                                  "verification": "Quadro comparativo completo com pelo menos 5 métricas definidas e resumo de 1 página.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livros de Shetty e Kolk (PDF ou físico), caderno ou software de notas (ex.: Notion), acesso à internet para resumos acadêmicos.",
                                  "tips": "Use highlights para citações diretas para facilitar referências futuras.",
                                  "learningObjective": "Dominar os fundamentos teóricos de eficiência mecatrônica baseados em referências padrão.",
                                  "commonMistakes": "Ignorar contexto aeronáutico específico, confundindo com indústrias gerais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e quantificar métricas de avaliação",
                                  "subSteps": [
                                    "Selecionar 4-6 métricas chave: tempo de ciclo, taxa de defeitos, consumo de energia, custo por unidade, desperdício de material e taxa de produção.",
                                    "Estabelecer baselines numéricas para métodos manuais baseadas em dados industriais (ex.: 10 peças/hora manual).",
                                    "Adaptar métricas às referências de Shetty e Kolk para fabricação aeronáutica.",
                                    "Criar uma planilha com fórmulas para cálculo (ex.: produtividade = output / input).",
                                    "Validar métricas com exemplos reais de casos de estudo aeronáuticos."
                                  ],
                                  "verification": "Planilha pronta com fórmulas testadas e baselines definidas para pelo menos 5 métricas.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Excel ou Google Sheets, artigos de Shetty e Kolk, dados públicos de Boeing/Embraer.",
                                  "tips": "Padronize unidades (ex.: kg de desperdício por peça) para comparações precisas.",
                                  "learningObjective": "Capacitar-se a selecionar e quantificar métricas relevantes para comparações industriais.",
                                  "commonMistakes": "Escolher métricas irrelevantes ou sem baselines realistas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Coletar e analisar dados de métodos manuais",
                                  "subSteps": [
                                    "Pesquisar dados reais ou simulados de linhas manuais em fabricação aeronáutica (ex.: montagem de fuselagem).",
                                    "Registrar valores para cada métrica (ex.: 15% desperdício manual).",
                                    "Calcular estatísticas descritivas (média, desvio padrão) usando planilha.",
                                    "Identificar limitações humanas como fadiga e variabilidade.",
                                    "Comparar preliminarmente com benchmarks de Shetty e Kolk."
                                  ],
                                  "verification": "Relatório parcial com dados tabulados e gráficos para métodos manuais.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Planilha do Step 2, bases de dados industriais (ex.: relatórios FAA), calculadora gráfica.",
                                  "tips": "Use gráficos de barras para visualização inicial de dados.",
                                  "learningObjective": "Adquirir habilidades em coleta e análise de dados empíricos para processos manuais.",
                                  "commonMistakes": "Usar dados genéricos sem foco aeronáutico, ignorando variabilidade humana."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Coletar e analisar dados de robótica mecatrônica",
                                  "subSteps": [
                                    "Pesquisar casos de robótica mecatrônica em aeronáutica (ex.: robôs KUKA na Boeing).",
                                    "Registrar métricas (ex.: 5% desperdício robótico, 30 peças/hora).",
                                    "Calcular estatísticas e comparar diretamente com dados manuais na planilha.",
                                    "Destacar integrações mecatrônicas como sensores e automação.",
                                    "Referenciar Shetty e Kolk para validação de ganhos."
                                  ],
                                  "verification": "Gráficos comparativos completos com dados robóticos vs. manuais.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Planilha atualizada, vídeos de robôs industriais, artigos técnicos.",
                                  "tips": "Inclua sensibilidade a cenários (ex.: alto vs. baixo volume de produção).",
                                  "learningObjective": "Analisar quantitativamente vantagens da robótica mecatrônica.",
                                  "commonMistakes": "Superestimar benefícios sem dados reais, negligenciar custos iniciais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar comparação final e gerar relatório",
                                  "subSteps": [
                                    "Executar testes estatísticos simples (ex.: teste t para diferenças significativas).",
                                    "Calcular percentuais de melhoria (ex.: 40% redução em desperdício).",
                                    "Discutir implicações qualitativas como escalabilidade.",
                                    "Redigir relatório com introdução, análise, conclusões e referências.",
                                    "Preparar apresentação visual com dashboards."
                                  ],
                                  "verification": "Relatório final de 5-10 páginas com gráficos, cálculos e conclusões claras.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Planilha final, software de apresentação (PowerPoint), referências bibliográficas.",
                                  "tips": "Use executive summary para destacar ganhos chave.",
                                  "learningObjective": "Sintetizar análises em recomendações acionáveis para eficiência industrial.",
                                  "commonMistakes": "Focar só em números sem contexto qualitativo ou referências."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de painéis de asas na Embraer, métodos manuais produzem 20 painéis/dia com 12% desperdício de compósito; robótica mecatrônica com braços robóticos integrados sensores reduz para 50 painéis/dia e 4% desperdício, calculado via métricas de Shetty e Kolk.",
                              "finalVerifications": [
                                "Relatório mostra pelo menos 20-50% melhoria em produtividade robótica vs. manual.",
                                "Todas métricas têm baselines e cálculos validados com fórmulas.",
                                "Referências a Shetty e Kolk citadas em pelo menos 3 pontos chave.",
                                "Gráficos comparativos evidenciam reduções de desperdício >30%.",
                                "Conclusões incluem recomendações práticas para implementação.",
                                "Análise considera limitações como custo inicial de robôs."
                              ],
                              "assessmentCriteria": [
                                "Precisão e relevância das métricas escolhidas (30%).",
                                "Qualidade da coleta e análise de dados (25%).",
                                "Uso correto de referências teóricas (20%).",
                                "Clareza de gráficos e relatórios (15%).",
                                "Profundidade da comparação quantitativa/qualitativa (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística e análise de dados (testes de hipótese).",
                                "Engenharia Industrial: Otimização de processos lean.",
                                "Economia: Análise custo-benefício de automação.",
                                "Gestão de Projetos: Avaliação de ROI em investimentos mecatrônicos."
                              ],
                              "realWorldApplication": "Na Boeing, robôs mecatrônicos avaliam eficiência na fabricação de fuselagem do 787 Dreamliner, reduzindo tempo de produção em 35% e desperdício em 28%, permitindo entregas mais rápidas e competitividade global."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Robótica Mecatrônica em Inspeção Aeronáutica",
                        "description": "Aplicações de sistemas robóticos com visão por computador para inspeção não destrutiva de estruturas aeronáuticas, integrando câmeras, lasers e inteligência embarcada em microcontroladores.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Descrever sistemas de visão em inspeção",
                            "description": "Explicar o funcionamento de robôs com visão por computador para detecção de defeitos em soldas e compósitos aeronáuticos, processando imagens via algoritmos em microprocessadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes fundamentais de sistemas de visão por computador em robótica",
                                  "subSteps": [
                                    "Identificar os principais componentes: câmeras, lentes, iluminação e sensores.",
                                    "Explicar o papel do hardware em robôs para inspeção aeronáutica.",
                                    "Descrever a integração com braços robóticos para posicionamento preciso.",
                                    "Analisar exemplos de sensores CCD/CMOS usados em ambientes industriais.",
                                    "Mapear o fluxo básico de dados de imagem para processamento."
                                  ],
                                  "verification": "Criar um diagrama simples dos componentes e rotular suas funções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Computador com software de diagramação (ex: Draw.io), imagens de robôs de inspeção.",
                                  "tips": "Use analogias como 'olhos e cérebro' para visualizar melhor.",
                                  "learningObjective": "Compreender a arquitetura hardware de sistemas de visão em inspeção robótica.",
                                  "commonMistakes": "Confundir sensores de imagem com atuadores robóticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Captura e pré-processamento de imagens para detecção de defeitos",
                                  "subSteps": [
                                    "Explicar técnicas de captura: resolução, taxa de frames e calibração de câmera.",
                                    "Descrever filtros para remoção de ruído (ex: Gaussian blur) em imagens de soldas.",
                                    "Aplicar segmentação de imagem para isolar regiões de interesse em compósitos.",
                                    "Realizar normalização de contraste para condições variáveis de iluminação.",
                                    "Testar pré-processamento em imagens simuladas de defeitos aeronáuticos."
                                  ],
                                  "verification": "Processar uma imagem de amostra e mostrar antes/depois do pré-processamento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software OpenCV ou Python com bibliotecas de visão (cv2), imagens de soldas/compósitos.",
                                  "tips": "Sempre calibre a câmera para evitar distorções em superfícies curvas.",
                                  "learningObjective": "Dominar etapas iniciais de tratamento de imagens para inspeção precisa.",
                                  "commonMistakes": "Ignorar variações de iluminação, levando a falsos positivos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Algoritmos de detecção de defeitos em soldas e compósitos",
                                  "subSteps": [
                                    "Estudar detecção de bordas (Canny) para rachaduras em soldas.",
                                    "Aplicar análise de textura para porosidade em compósitos aeronáuticos.",
                                    "Implementar classificação com machine learning básico (ex: SVM para defeitos).",
                                    "Explicar thresholds adaptativos para diferentes materiais.",
                                    "Simular detecção de trincas e delaminação em cenários reais."
                                  ],
                                  "verification": "Executar um script simples que detecta um defeito em uma imagem de teste.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python com OpenCV e scikit-learn, dataset de imagens de defeitos (ex: Kaggle).",
                                  "tips": "Comece com algoritmos simples antes de ML para entender limitações.",
                                  "learningObjective": "Aplicar algoritmos específicos para identificar defeitos em contextos aeronáuticos.",
                                  "commonMistakes": "Usar thresholds fixos em materiais heterogêneos como compósitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Processamento em microprocessadores e integração robótica completa",
                                  "subSteps": [
                                    "Descrever execução de algoritmos em microcontroladores (ex: Raspberry Pi, NVIDIA Jetson).",
                                    "Explicar paralelismo e otimização para tempo real em inspeção.",
                                    "Integrar feedback: robô ajusta posição baseado em detecção.",
                                    "Discutir comunicação via ROS (Robot Operating System) para sistemas mecatrônicos.",
                                    "Simular ciclo completo: captura > processamento > decisão > relatório."
                                  ],
                                  "verification": "Desenhar um fluxograma do sistema completo e narrar seu funcionamento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Documentação ROS, simulador Gazebo, fluxogramas prontos como referência.",
                                  "tips": "Foco em latência baixa para inspeções em linha de produção.",
                                  "learningObjective": "Integrar visão computacional em sistemas robóticos embarcados.",
                                  "commonMistakes": "Subestimar consumo de processamento em dispositivos embarcados."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem da Embraer, um robô com câmera industrial captura imagens de uma solda em fuselagem, aplica filtro Canny no Raspberry Pi para detectar rachaduras >0.5mm, classifica via SVM e aciona alarme se defeito for confirmado, evitando recalls caros.",
                              "finalVerifications": [
                                "Diagramar corretamente o fluxo completo de um sistema de visão em inspeção.",
                                "Explicar verbalmente o papel de pelo menos 3 algoritmos em detecção de defeitos.",
                                "Simular pré-processamento e detecção em uma imagem real de solda/compósito.",
                                "Identificar limitações em microprocessadores para processamento em tempo real.",
                                "Descrever integração robótica com exemplos de feedback loop.",
                                "Listar 3 aplicações específicas na indústria aeronáutica."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de componentes e algoritmos (30%).",
                                "Clareza e estrutura na explicação do fluxo completo (25%).",
                                "Uso de exemplos práticos e verificáveis (20%).",
                                "Profundidade em detecção de defeitos específicos (soldas/compósitos) (15%).",
                                "Conexão com processamento embarcado e robótica (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de algoritmos em Python/OpenCV.",
                                "Inteligência Artificial: Modelos de ML para classificação de defeitos.",
                                "Engenharia de Materiais: Conhecimento de soldas e compósitos aeronáuticos.",
                                "Eletrônica Embarcada: Otimização em microprocessadores.",
                                "Gestão Industrial: Impacto na qualidade e redução de custos."
                              ],
                              "realWorldApplication": "Na inspeção automatizada de aeronaves na Boeing ou Embraer, esses sistemas reduzem tempo de verificação de horas para minutos, detectam defeitos microscópicos em soldas e compósitos, garantindo segurança e conformidade com normas FAA/EASA, economizando milhões em retrabalhos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Implementar inspeção robótica simulada",
                            "description": "Simular o uso de drones e crawlers robóticos para inspeção ultrassônica em fuselagens, configurando loops de controle com CLPs conforme Lyshevski.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de simulação robótica",
                                  "subSteps": [
                                    "Instalar software de simulação como ROS (Robot Operating System) e Gazebo.",
                                    "Configurar um workspace ROS para o projeto de inspeção aeronáutica.",
                                    "Criar um modelo básico de fuselagem de aeronave usando URDF ou SDF.",
                                    "Testar a visualização inicial do ambiente simulado.",
                                    "Integrar bibliotecas para simulação de PLCs (ex: OpenPLC ou PLCsim)."
                                  ],
                                  "verification": "Ambiente roda sem erros e fuselagem é visualizada corretamente no Gazebo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Computador com Ubuntu 20.04 ou superior",
                                    "ROS Noetic instalado",
                                    "Gazebo 11",
                                    "OpenPLC Editor"
                                  ],
                                  "tips": "Use containers Docker para isolar o ambiente e evitar conflitos de dependências.",
                                  "learningObjective": "Dominar a configuração inicial de simuladores robóticos para aplicações industriais.",
                                  "commonMistakes": [
                                    "Ignorar dependências de pacotes ROS",
                                    "Não calibrar a escala da fuselagem",
                                    "Esquecer de sourcar o workspace ROS"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o drone ou crawler robótico e a fuselagem",
                                  "subSteps": [
                                    "Desenhar modelo 3D do drone/crawler no Blender ou SolidWorks e exportar para URDF.",
                                    "Definir juntas, links e propriedades físicas (massa, inércia) do robô.",
                                    "Posicionar a fuselagem como um modelo estático com defeitos simulados (fissuras).",
                                    "Adicionar texturas e materiais realistas para simulação ultrassônica.",
                                    "Spawnar os modelos no Gazebo e testar mobilidade básica."
                                  ],
                                  "verification": "Robô navega suavemente ao redor da fuselagem sem colisões indesejadas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Blender ou FreeCAD",
                                    "URDF tutorials",
                                    "Modelos 3D de fuselagem aeronáutica (ex: Thingiverse)"
                                  ],
                                  "tips": "Comece com um crawler simples para iniciantes antes de drones volantes.",
                                  "learningObjective": "Aprender modelagem cinemática e dinâmica de robôs para inspeção.",
                                  "commonMistakes": [
                                    "Escala incorreta do modelo",
                                    "Falta de fricção nas rodas do crawler",
                                    "Juntas mal definidas causando instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar sensores de inspeção ultrassônica simulados",
                                  "subSteps": [
                                    "Adicionar plugin de sensor ultrassônico no URDF do robô (range finder ou custom ultrasonic).",
                                    "Configurar ruído e precisão do sensor para simular condições reais.",
                                    "Criar tópicos ROS para publicar dados de ultrassom (ex: /ultrasound_data).",
                                    "Implementar filtro para detectar defeitos na fuselagem (threshold-based).",
                                    "Visualizar dados em tempo real com RViz."
                                  ],
                                  "verification": "Dados de ultrassom são publicados corretamente e detectam 'defeitos' simulados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "ROS plugins para sensores",
                                    "RViz",
                                    "Documentação Gazebo sensors"
                                  ],
                                  "tips": "Simule variações de espessura da fuselagem para testar sensibilidade.",
                                  "learningObjective": "Entender integração de sensores não destrutivos em robótica.",
                                  "commonMistakes": [
                                    "Frequência de amostragem muito baixa",
                                    "Não calibrar offset do sensor",
                                    "Ignorar reflexões espúrias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar loops de controle com CLPs simulados conforme Lyshevski",
                                  "subSteps": [
                                    "Estudar princípios de controle de Lyshevski (controle digital em sistemas embarcados).",
                                    "Programar ladder logic no OpenPLC para loops de posição/velocidade do robô.",
                                    "Integrar PLC com ROS via Modbus ou ROS-Industrial.",
                                    "Definir setpoints para trajetória de inspeção (ex: scan linear na fuselagem).",
                                    "Testar loop fechado: ajuste PID para estabilidade."
                                  ],
                                  "verification": "Robô segue trajetória prescrita com erro < 5% em posição.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Nanoscale Electrodynamics' de Lyshevski (capítulos relevantes)",
                                    "OpenPLC runtime",
                                    "PID tuner tools"
                                  ],
                                  "tips": "Use gains conservadores iniciais para PID para evitar oscilações.",
                                  "learningObjective": "Aplicar teoria de controle digital de Lyshevski em CLPs para robótica.",
                                  "commonMistakes": [
                                    "Loop aberto em vez de fechado",
                                    "Gains PID mal tunados",
                                    "Não sincronizar clocks PLC-ROS"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar simulação completa de inspeção e análise de resultados",
                                  "subSteps": [
                                    "Executar missão completa: navegação, scan ultrassônico e mapeamento de defeitos.",
                                    "Gravar dados (bags ROS) e gerar relatório de inspeção.",
                                    "Analisar precisão de detecção e tempo de ciclo.",
                                    "Otimizar trajetória para cobertura total da fuselagem.",
                                    "Exportar mapa de defeitos para formato visual (heatmap)."
                                  ],
                                  "verification": "Relatório gerado identifica todos defeitos simulados com precisão >90%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "rosbag tools",
                                    "Matplotlib ou Octave para análise",
                                    "Heatmap generators"
                                  ],
                                  "tips": "Automatize com launch files para repetibilidade.",
                                  "learningObjective": "Validar sistemas robóticos completos em cenários industriais.",
                                  "commonMistakes": [
                                    "Cobertura incompleta da fuselagem",
                                    "Não logar dados para debug",
                                    "Sobrecarga computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Simular um crawler robótico inspecionando a fuselagem de um Boeing 737, detectando uma fissura simulada de 2mm na seção central usando ultrassom, com controle PID via PLC para manter distância de 5cm.",
                              "finalVerifications": [
                                "Simulação executa sem crashes por 10 minutos contínuos.",
                                "Todos defeitos simulados são detectados com precisão >90%.",
                                "Loops de controle mantêm erro de trajetória <3cm.",
                                "Dados de ultrassom são processados em tempo real (<100ms latency).",
                                "Relatório de inspeção é gerado automaticamente.",
                                "Cobertura de 100% da área de fuselagem alvo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de defeitos (métrica: taxa de falsos positivos/negativos).",
                                "Estabilidade dos loops de controle (overshoot <10%, settling time <2s).",
                                "Eficiência temporal (tempo total de inspeção <15min para fuselagem padrão).",
                                "Qualidade do modelo e simulação (realismo visual e físico).",
                                "Documentação e reprodutibilidade do código.",
                                "Integração correta de sensores e PLC."
                              ],
                              "crossCurricularConnections": [
                                "Programação: ROS nodes e ladder logic em PLC.",
                                "Eletrônica: Simulação de sensores ultrassônicos e atuadores.",
                                "Aeronáutica: Modelagem de estruturas de fuselagem e NDT (Non-Destructive Testing).",
                                "Matemática: Cinemática, PID control e processamento de sinais.",
                                "Física: Dinâmica de robôs e propagação de ondas ultrassônicas."
                              ],
                              "realWorldApplication": "Em manutenção aeronáutica, drones e crawlers realizam inspeções ultrassônicas em fuselagens de aviões como Airbus A320, reduzindo tempo de downtime de dias para horas e melhorando segurança ao detectar microfissuras precocemente, conforme normas FAA/EASA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Interpretar dados de inspeção mecatrônica",
                            "description": "Analisar relatórios gerados por robôs mecatrônicos em inspeções, identificando anomalias como rachaduras via integração de sensores e software de processamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Formato e Estrutura dos Relatórios de Inspeção",
                                  "subSteps": [
                                    "Estudar o cabeçalho do relatório: identificar ID da missão, tipo de robô, data/hora e parâmetros de inspeção.",
                                    "Analisar seções de dados: timestamps, coordenadas 3D, leituras de sensores (ultrassom, câmera, laser).",
                                    "Revisar metadados: calibração de sensores, condições ambientais e software de processamento utilizado.",
                                    "Mapear abreviações e unidades: ex. 'US' para ultrassom em mm, 'VIS' para visão em pixels.",
                                    "Comparar relatórios normais com exemplos contendo anomalias conhecidas."
                                  ],
                                  "verification": "Descrever verbalmente ou por escrito a estrutura completa de um relatório de amostra, identificando todas as seções principais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Relatórios de inspeção de amostra (PDF/JSON)",
                                    "Manual do robô mecatrônico",
                                    "Glossário de termos técnicos"
                                  ],
                                  "tips": "Use um marcador para destacar seções enquanto lê, facilitando referências futuras.",
                                  "learningObjective": "Dominar a organização dos dados para navegação eficiente nos relatórios.",
                                  "commonMistakes": [
                                    "Ignorar metadados ambientais que afetam leituras",
                                    "Confundir unidades de sensores diferentes",
                                    "Pular o glossário e interpretar termos errados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Dados Brutos de Sensores Individuais",
                                  "subSteps": [
                                    "Selecionar um sensor específico (ex: ultrassom) e plotar leituras vs. coordenadas.",
                                    "Identificar padrões normais: faixas de valores esperados baseadas em especificações da aeronave.",
                                    "Detectar desvios iniciais: valores fora de ±10% da média nominal.",
                                    "Usar ferramentas de visualização para gerar gráficos de linha ou heatmaps.",
                                    "Documentar observações preliminares com screenshots anotados."
                                  ],
                                  "verification": "Gerar um gráfico simples de dados de um sensor e listar 3 desvios potenciais com justificativa.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de análise de dados (Excel, Python com Matplotlib ou similar)",
                                    "Dados brutos de sensores de amostra",
                                    "Especificações técnicas de componentes aeronáuticos"
                                  ],
                                  "tips": "Filtre ruídos iniciais aplicando médias móveis para leituras mais claras.",
                                  "learningObjective": "Interpretar saídas isoladas de sensores para identificar irregularidades básicas.",
                                  "commonMistakes": [
                                    "Não calibrar escalas nos gráficos",
                                    "Interpretar ruído como anomalia",
                                    "Esquecer de normalizar dados por coordenadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Dados de Múltiplos Sensores para Detecção de Anomalias",
                                  "subSteps": [
                                    "Correlacionar dados: ex. combinar ultrassom (espessura) com visão (imagens de rachaduras).",
                                    "Aplicar fusão de dados: usar software para overlay de leituras e destacar sobreposições anômalas.",
                                    "Classificar anomalias: rachaduras (visão + ultrassom), corrosão (espessura reduzida), deformações (laser).",
                                    "Calcular scores de risco: baseados em magnitude e localização crítica (ex. juntas de asas).",
                                    "Simular cenários: processar relatório com anomalias injetadas."
                                  ],
                                  "verification": "Produzir um relatório integrado identificando pelo menos 2 anomalias compostas de sensores diferentes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de processamento mecatrônico (ex. ROS ou custom viewer)",
                                    "Relatórios multi-sensor de amostra",
                                    "Tabelas de thresholds de anomalias"
                                  ],
                                  "tips": "Priorize áreas críticas da aeronave definidas no cabeçalho do relatório.",
                                  "learningObjective": "Sintetizar informações de sensores para diagnóstico preciso de falhas.",
                                  "commonMistakes": [
                                    "Não sincronizar timestamps entre sensores",
                                    "Sobrestimar correlações sem evidência",
                                    "Ignorar falsos positivos em fusões"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar Relatório Final e Recomendações",
                                  "subSteps": [
                                    "Resumir achados: listar anomalias com evidências, localização e severidade.",
                                    "Propor ações: inspeção manual, reparo ou monitoramento contínuo.",
                                    "Validar com normas: referenciar standards aeronáuticos (ex. FAA, EASA).",
                                    "Exportar relatório formatado: com visuals, tabelas e assinatura digital.",
                                    "Realizar auto-revisão: checar consistência e completude."
                                  ],
                                  "verification": "Entregar um relatório final completo para um caso simulado, aprovado por checklist.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Templates de relatório final",
                                    "Normas de inspeção aeronáutica (PDF)",
                                    "Ferramentas de edição (Word, LaTeX)"
                                  ],
                                  "tips": "Use bullet points para clareza e inclua visuals sempre que possível.",
                                  "learningObjective": "Comunicar interpretações de forma profissional e acionável.",
                                  "commonMistakes": [
                                    "Omitir evidências quantitativas",
                                    "Recomendações vagas sem base",
                                    "Não citar normas regulatórias"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma inspeção de asa de Boeing 737 por robô mecatrônico, o relatório mostra ultrassom com espessura de 2.8mm (nominal 3.2mm) correlacionado a imagem de visão revelando rachadura de 5mm na borda de ataque; integração confirma anomalia crítica requerendo grounded imediato.",
                              "finalVerifications": [
                                "Identifica corretamente 95% das anomalias em relatórios simulados.",
                                "Gera relatórios integrados com evidências multi-sensor.",
                                "Explica fusão de dados para pares de sensores comuns.",
                                "Aplica thresholds corretos para classificação de risco.",
                                "Valida achados contra normas aeronáuticas.",
                                "Documenta recomendações acionáveis e priorizadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de anomalias (>90%).",
                                "Qualidade da integração multi-sensor (correlações lógicas).",
                                "Clareza e completude do relatório final.",
                                "Tempo de processamento eficiente (<4 horas por relatório).",
                                "Uso correto de ferramentas e normas.",
                                "Capacidade de lidar com dados ruidosos ou incompletos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Detecção de outliers e análise de variância em dados sensoriais.",
                                "Programação: Scripts Python para automação de processamento e visualização.",
                                "Física: Princípios de propagação de ondas ultrassônicas e óptica em sensores.",
                                "Matemática: Geometria 3D para mapeamento de coordenadas.",
                                "Gestão de Projetos: Planejamento de inspeções e relatórios regulados."
                              ],
                              "realWorldApplication": "Na manutenção aeronáutica, robôs mecatrônicos inspecionam fuselagens e asas detectando rachaduras microscópicas precocemente, permitindo reparos preditivos que evitam falhas catastróficas, reduzem custos em 30% e minimizam tempo de aeronaves em solo em companhias como Airbus e Boeing."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Robótica Mecatrônica em Montagem Aeronáutica",
                        "description": "Robôs colaborativos e industriais em linhas de montagem de aeronaves, utilizando times multifuncionais e desenvolvimento integrado de produtos para fixação de componentes com alta precisão.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Exemplificar robôs em montagem de asas",
                            "description": "Detalhar robôs de 6 eixos na montagem de painéis de asas, integrando atuadores elétricos e controle PID via microcontroladores para alinhamento preciso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura e cinemática de robôs de 6 eixos",
                                  "subSteps": [
                                    "Estudar os 6 graus de liberdade (3 translacionais e 3 rotacionais) e suas juntas articulares.",
                                    "Analisar diagramas de Denavit-Hartenberg para modelagem cinemática.",
                                    "Identificar componentes principais: base, braços, punho e end-effector.",
                                    "Visualizar trajetórias de movimento em simulações 3D.",
                                    "Comparar robôs industriais como KUKA KR AGILUS e ABB IRB 6700."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama completo de um robô de 6 eixos com explicação oral ou escrita.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Vídeos tutoriais (YouTube: 'Robot 6-axis kinematics'), software RoboDK ou ROS (gratuito), papel e caneta para diagramas.",
                                  "tips": "Use visualizações 3D para fixar conceitos espaciais; comece com movimentos simples antes de complexos.",
                                  "learningObjective": "Dominar os princípios cinemáticos que permitem precisão na manipulação de peças aeronáuticas.",
                                  "commonMistakes": "Confundir juntas rotacionais com translacionais; ignorar singularidades cinemáticas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar atuadores elétricos em robôs industriais",
                                  "subSteps": [
                                    "Classificar atuadores: servomotores DC/AC, motores brushless e steppers.",
                                    "Estudar especificações: torque, velocidade, precisão e eficiência energética.",
                                    "Analisar integração com redutores harmônicos para alta precisão.",
                                    "Simular controle de posição em software como MATLAB Simulink.",
                                    "Examinar casos reais em robôs para montagem de painéis leves."
                                  ],
                                  "verification": "Listar 3 atuadores comuns com specs e justificar escolha para montagem de asas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Datasheets de servomotores (KUKA/FANUC), MATLAB Student (gratuito) ou Tinkercad para simulação.",
                                  "tips": "Priorize atuadores com feedback encoder para alinhamento sub-milimétrico.",
                                  "learningObjective": "Selecionar e justificar atuadores adequados para tarefas de alta precisão em aeronáutica.",
                                  "commonMistakes": "Subestimar perdas por calor em atuadores de alta torque; ignorar compatibilidade com microcontroladores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar controle PID via microcontroladores",
                                  "subSteps": [
                                    "Revisar equação PID: Kp*e + Ki*∫e + Kd*de/dt.",
                                    "Configurar microcontrolador (ex: Arduino Mega ou STM32) com bibliotecas PID.",
                                    "Ajustar gains (Kp, Ki, Kd) via método Ziegler-Nichols em simulação.",
                                    "Testar loop de feedback com sensores de posição (encoders/IMU).",
                                    "Otimizar para overshoot mínimo e tempo de estabilização <1s."
                                  ],
                                  "verification": "Executar simulação PID com gráfico de resposta (setpoint vs. tempo) mostrando estabilidade.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Arduino IDE, biblioteca PID_v1, osciloscópio virtual (Tinkercad), tutoriais PID (Brian Douglas YouTube).",
                                  "tips": "Comece com Kp baixo para evitar oscilações; use anti-windup para integrador.",
                                  "learningObjective": "Projetar loops PID para controle preciso de alinhamento em robótica.",
                                  "commonMistakes": "Gains mal tunados causando instabilidade; esquecer normalização de erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar componentes na montagem de painéis de asas",
                                  "subSteps": [
                                    "Modelar trajetória de colagem/parafusamento de painéis compostos.",
                                    "Simular end-effector com ventosas e ferramentas de alinhamento.",
                                    "Integrar PID multi-eixo para correção em tempo real.",
                                    "Analisar segurança: limites de força e detecção de colisões.",
                                    "Documentar fluxo completo: pick, align, place, fasten."
                                  ],
                                  "verification": "Criar fluxograma ou vídeo simulado da montagem completa.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "RoboDK ou Gazebo ROS para simulação aeronáutica, blueprints de painéis de asas (imagens Boeing/Airbus).",
                                  "tips": "Foque em tolerâncias <0.1mm para composites; integre visão computacional para feedback.",
                                  "learningObjective": "Aplicar integração mecatrônica em cenários industriais reais de montagem aeronáutica.",
                                  "commonMistakes": "Ignorar vibrações em atuadores leves; subestimar tempo de ciclo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Exemplificar e validar o sistema robótico",
                                  "subSteps": [
                                    "Escolher case study: Robô KUKA em linha Boeing 787.",
                                    "Desenvolver apresentação com vídeos reais e dados de performance.",
                                    "Calcular métricas: precisão, throughput, ROI.",
                                    "Discutir escalabilidade para produção em massa.",
                                    "Preparar relatório com diagramas e conclusões."
                                  ],
                                  "verification": "Apresentar exemplo completo com Q&A simulada ou gravada.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Vídeos industriais (Boeing YouTube), PowerPoint/Google Slides, calculadora para métricas.",
                                  "tips": "Use métricas reais de literatura para credibilidade; destaque redução de erros humanos.",
                                  "learningObjective": "Comunicar efetivamente aplicações robóticas em contextos aeronáuticos.",
                                  "commonMistakes": "Focar só teoria sem exemplos visuais; exagerar capacidades sem dados."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem da Boeing 787, um robô ABB IRB 6700 de 6 eixos usa servomotores elétricos controlados por PID em um microcontrolador Beckhoff para alinhar painéis de asas compostos com precisão de 0.05mm, aplicando adesivo e fixando rebites automaticamente, reduzindo tempo de ciclo em 40%.",
                              "finalVerifications": [
                                "Diagrama cinemático completo e correto de robô de 6 eixos.",
                                "Simulação PID estável com resposta dentro de specs (overshoot <5%).",
                                "Fluxograma de montagem integrando todos componentes.",
                                "Apresentação com case study real e métricas quantificadas.",
                                "Relatório destacando conexões mecatrônicas.",
                                "Auto-avaliação de compreensão via quiz interno (90% acerto)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nos conceitos de cinemática e PID (30%).",
                                "Qualidade e completude das simulações/integrações (25%).",
                                "Relevância e detalhe do exemplo prático aeronáutico (20%).",
                                "Clareza na comunicação e visualizações (15%).",
                                "Identificação de erros comuns e soluções (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial para derivadas em PID e matrizes de transformação.",
                                "Programação: Código em C++/Python para microcontroladores e ROS.",
                                "Física: Dinâmica de rigidez e forças em atuadores.",
                                "Engenharia de Materiais: Propriedades de composites em asas.",
                                "Gestão Industrial: Otimização de linhas de produção Lean."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como nas fábricas da Embraer ou Airbus, robôs de 6 eixos com PID otimizam a montagem de asas, garantindo alinhamento preciso de painéis de carbono, reduzindo desperdícios, defeitos e tempo de produção em até 50%, essencial para aviões comerciais e militares."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Planejar projetos de montagem robótica",
                            "description": "Elaborar fluxogramas de projetos mecatrônicos para montagem de cabos e sistemas hidráulicos em aeronaves, aplicando métodos de Cross para times multifuncionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise Inicial de Requisitos do Projeto",
                                  "subSteps": [
                                    "Identificar os componentes específicos: cabos elétricos, conectores e tubulações hidráulicas para aeronaves.",
                                    "Mapear restrições técnicas: dimensões da aeronave, normas de segurança (ex: FAA ou EASA) e integração robótica.",
                                    "Consultar stakeholders para definir objetivos: precisão de montagem, tempo de ciclo e tolerâncias.",
                                    "Documentar requisitos em uma tabela inicial de especificações.",
                                    "Avaliar riscos iniciais relacionados à montagem automatizada."
                                  ],
                                  "verification": "Tabela de requisitos completa e aprovada por stakeholders iniciais.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Software de documentação (Excel ou Google Sheets), normas aeronáuticas (PDFs), diagramas de aeronaves.",
                                  "tips": "Priorize requisitos críticos de segurança para evitar retrabalho posterior.",
                                  "learningObjective": "Compreender e documentar requisitos funcionais e não-funcionais de projetos mecatrônicos aeronáuticos.",
                                  "commonMistakes": "Ignorar normas regulatórias ou subestimar complexidades hidráulicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturação da Equipe Multifuncional com Métodos Cross",
                                  "subSteps": [
                                    "Definir papéis cross-functional: engenheiros mecatrônicos, robótica, hidráulica, elétricos e gerentes de projeto.",
                                    "Aplicar método Cross-Functional: mapear fluxos de comunicação e responsabilidades compartilhadas.",
                                    "Criar organograma da equipe com ferramentas como RACI matrix.",
                                    "Planejar reuniões cross-team para alinhamento inicial.",
                                    "Estabelecer canais de comunicação (ex: Slack ou Microsoft Teams)."
                                  ],
                                  "verification": "Organograma e RACI matrix assinados por membros da equipe.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Ferramentas de colaboração (Lucidchart para organogramas, RACI templates), lista de contatos da equipe.",
                                  "tips": "Inclua um facilitador cross-functional para mediar conflitos iniciais.",
                                  "learningObjective": "Aplicar métodos cross-functional para otimizar colaboração em times multidisciplinares.",
                                  "commonMistakes": "Sobrecarregar um único departamento, ignorando expertise hidráulica ou robótica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Elaboração do Fluxograma Principal do Projeto",
                                  "subSteps": [
                                    "Desenhar fluxograma de alto nível: etapas de montagem (preparo, posicionamento robótico, conexão, teste).",
                                    "Incorporar ramificações para montagem de cabos (crimpagem, roteamento) e sistemas hidráulicos (vedação, pressurização).",
                                    "Usar símbolos padrão (ISO 10628) para mecatrônica e robótica.",
                                    "Integrar checkpoints de qualidade e inspeção robótica.",
                                    "Simular fluxo com software para detectar gargalos."
                                  ],
                                  "verification": "Fluxograma draft revisado e sem erros lógicos.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "Software de fluxogramas (Draw.io, Visio), templates mecatrônicos, exemplos de projetos aeronáuticos.",
                                  "tips": "Use cores para diferenciar fluxos de cabos (elétricos) vs. hidráulicos.",
                                  "learningObjective": "Criar fluxogramas precisos que representem processos mecatrônicos complexos.",
                                  "commonMistakes": "Fluxogramas lineares demais, sem loops de feedback ou contingências."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração de Métodos Cross e Otimização Robótica",
                                  "subSteps": [
                                    "Mapear interações cross-team no fluxograma: aprovações hidráulicas antes de montagem robótica.",
                                    "Incorporar programação robótica: caminhos de braço robótico para montagem precisa.",
                                    "Otimizar com simulações: tempo de ciclo, eficiência energética.",
                                    "Adicionar métricas KPIs: taxa de defeitos <1%, tempo de montagem <5min por unidade.",
                                    "Revisar com equipe para feedback cross-functional."
                                  ],
                                  "verification": "Fluxograma otimizado com anotações de equipe e simulação executada.",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "Software de simulação robótica (ROS, Gazebo), KPIs templates.",
                                  "tips": "Teste simulações com cenários de falha para robustez.",
                                  "learningObjective": "Integrar equipes multifuncionais e robótica em fluxogramas acionáveis.",
                                  "commonMistakes": "Isolar fluxos robóticos sem sincronia com hidráulica/elétrica."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Revisão Final e Validação do Plano",
                                  "subSteps": [
                                    "Realizar walkthrough cross-team do fluxograma completo.",
                                    "Validar contra normas aeronáuticas e requisitos iniciais.",
                                    "Gerar relatório executivo com cronograma Gantt integrado.",
                                    "Planejar protótipo piloto de montagem.",
                                    "Documentar plano final em formato compartilhável."
                                  ],
                                  "verification": "Plano aprovado por todos os leads cross-functional.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Ferramentas de projeto (MS Project para Gantt), relatório template.",
                                  "tips": "Use versionamento (Git para diagramas) para rastrear mudanças.",
                                  "learningObjective": "Finalizar planos de projeto validados e prontos para execução.",
                                  "commonMistakes": "Pular validação cross-team, levando a desalinhamentos."
                                }
                              ],
                              "practicalExample": "Planejar a montagem robótica de cabos elétricos e tubos hidráulicos no trem de pouso de um Boeing 737: fluxograma inicia com análise de 50 cabos (20m totais), ramifica para braço robótico UR10 crimpar conectores, integra teste hidráulico de 200bar, com equipe de 8 membros cross-functional reduzindo tempo de 12h para 4h por unidade.",
                              "finalVerifications": [
                                "Fluxograma cobre 100% dos requisitos de cabos e hidráulicos.",
                                "RACI matrix alocada para todos os papéis cross-functional.",
                                "Simulação robótica sem colisões ou atrasos >10%.",
                                "KPIs definidos e mensuráveis (ex: precisão ±0.1mm).",
                                "Plano aprovado por pelo menos 80% da equipe multifuncional.",
                                "Cronograma Gantt com milestones claras."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão do fluxograma (sem ambiguidades).",
                                "Integração efetiva de métodos cross-functional.",
                                "Adequação às normas aeronáuticas e mecatrônicas.",
                                "Otimização de tempo e recursos robóticos.",
                                "Cobertura completa de riscos e contingências.",
                                "Qualidade da documentação e usabilidade para equipe."
                              ],
                              "crossCurricularConnections": [
                                "Gerenciamento de Projetos (PMBOK para fluxogramas e Gantt).",
                                "Engenharia Hidráulica (cálculos de pressão e vedação).",
                                "Programação Robótica (ROS para simulações de montagem).",
                                "Gestão de Equipes (teoria cross-functional e RACI).",
                                "Normas de Qualidade Aeronáutica (AS9100)."
                              ],
                              "realWorldApplication": "Na montagem final de aeronaves como Airbus A350, fluxogramas cross-functional guiam robôs para instalar milhares de cabos e sistemas hidráulicos, reduzindo erros humanos em 70%, acelerando produção em linhas da Boeing e Embraer, e garantindo conformidade com certificações FAA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Avaliar segurança em robótica colaborativa",
                            "description": "Discutir protocolos de segurança em cobots para montagem aeronáutica, incluindo sensores de força e paradas de emergência integradas a CLPs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de robótica colaborativa (cobots)",
                                  "subSteps": [
                                    "Definir cobots e diferenciar de robôs industriais tradicionais.",
                                    "Estudar os pilares da segurança colaborativa: velocidade, separação e força limitada.",
                                    "Analisar normas ISO/TS 15066 para colaboração homem-robô.",
                                    "Identificar riscos em ambientes de montagem aeronáutica.",
                                    "Mapear componentes de segurança básicos em cobots."
                                  ],
                                  "verification": "Resumir em um diagrama os pilares de segurança e normas aplicáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Norma ISO/TS 15066 (PDF)",
                                    "Vídeos introdutórios sobre cobots (YouTube/Universidade)",
                                    "Slides de apresentação sobre robótica colaborativa"
                                  ],
                                  "tips": "Use analogias com ferramentas manuais para entender limites de força.",
                                  "learningObjective": "Entender os fundamentos teóricos da segurança em cobots.",
                                  "commonMistakes": [
                                    "Confundir cobots com robôs autônomos",
                                    "Ignorar diferenças contextuais da indústria aeronáutica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar sensores de força e torque em cobots",
                                  "subSteps": [
                                    "Explicar funcionamento de sensores de força/torque multicomponentes.",
                                    "Estudar calibração e thresholds de detecção de colisão.",
                                    "Simular detecção de contato humano via software (ex: ROS ou CoppeliaSim).",
                                    "Discutir integração com algoritmos de redução de velocidade.",
                                    "Avaliar precisão em cenários de montagem de peças leves aeronáuticas."
                                  ],
                                  "verification": "Demonstrar em simulação uma detecção de força e ajuste de velocidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação ROS/Gazebo",
                                    "Documentação de sensores ATI ou Robotiq",
                                    "Kit de sensores virtuais"
                                  ],
                                  "tips": "Teste thresholds variados para observar respostas em tempo real.",
                                  "learningObjective": "Dominar o papel dos sensores na prevenção de acidentes.",
                                  "commonMistakes": [
                                    "Subestimar ruído ambiental nos sensores",
                                    "Não calibrar corretamente em simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar paradas de emergência e integração com CLPs",
                                  "subSteps": [
                                    "Descrever circuitos de parada de emergência (E-stop) categóricos (ISO 13850).",
                                    "Estudar programação de CLPs para monitoramento de segurança (ex: Siemens TIA Portal).",
                                    "Implementar lógica de intertravamento entre cobot e CLP.",
                                    "Simular falhas e respostas de emergência em montagem aeronáutica.",
                                    "Verificar redundância em sistemas de segurança (SIL levels)."
                                  ],
                                  "verification": "Criar e testar um ladder logic simples no CLP simulator.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software TIA Portal ou Codesys",
                                    "Documentação CLP Siemens/Allen-Bradley",
                                    "Simulador PLC Fiddle"
                                  ],
                                  "tips": "Sempre priorize failsafe em programação de CLP.",
                                  "learningObjective": "Integrar hardware de emergência com controle lógico.",
                                  "commonMistakes": [
                                    "Esquecer redundância em E-stops",
                                    "Programar sem considerar tempo de ciclo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar protocolos completos de segurança em contexto aeronáutico",
                                  "subSteps": [
                                    "Elaborar um protocolo de risco (RA - Risk Assessment) para célula de montagem.",
                                    "Combinar sensores, E-stops e CLPs em um workflow integrado.",
                                    "Discutir validação via testes físicos/virtuais (FMEA).",
                                    "Analisar casos reais de falhas em montagem (ex: Boeing incidents).",
                                    "Propor melhorias para conformidade FAA/EASA."
                                  ],
                                  "verification": "Apresentar relatório de avaliação com protocolo proposto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Templates FMEA/RA",
                                    "Casos de estudo aeronáuticos (relatórios NTSB)",
                                    "Ferramentas de modelagem como Visio"
                                  ],
                                  "tips": "Use matriz de risco para priorizar ameaças.",
                                  "learningObjective": "Aplicar avaliação holística de segurança colaborativa.",
                                  "commonMistakes": [
                                    "Focar só em hardware, ignorar procedimentos humanos",
                                    "Não contextualizar para aeronáutica"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma célula de montagem de painéis de fuselagem, o cobot UR10 com sensor de força detecta contato com o operador, reduz velocidade para 250mm/s e ativa E-stop via CLP se força exceder 150N, evitando lesões durante inserção de rebites.",
                              "finalVerifications": [
                                "Diagrama completo de arquitetura de segurança desenhado.",
                                "Simulação bem-sucedida de detecção de colisão e E-stop.",
                                "Relatório de RA com pelo menos 5 riscos identificados e mitigados.",
                                "Explicação oral de integração CLP-cobot.",
                                "Lista de conformidades com normas ISO/TS 15066."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes de segurança (30%)",
                                "Qualidade da simulação e testes (25%)",
                                "Profundidade da análise de riscos aeronáuticos (20%)",
                                "Clareza no protocolo proposto (15%)",
                                "Integração interdisciplinar demonstrada (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Industrial: Sensores e CLPs",
                                "Programação: Lógica ladder e ROS",
                                "Gestão de Projetos: Análise FMEA/RA",
                                "Normas e Regulamentação: ISO e FAA/EASA"
                              ],
                              "realWorldApplication": "Na linha de montagem do Boeing 787, cobots com sensores de força e CLPs integrados permitem operação colaborativa segura, reduzindo tempo de montagem em 20% sem comprometer a segurança dos técnicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Integração com Sistemas de Visão Computacional",
                    "description": "Uso básico de visão por computador em tarefas robóticas mecatrônicas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Fundamentos de Sistemas de Visão Computacional",
                        "description": "Princípios básicos de visão por computador, incluindo aquisição de imagens e processamento inicial, aplicados a tarefas robóticas mecatrônicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Aquisição de Imagens com Câmeras",
                            "description": "Configurar e capturar imagens de câmeras USB ou integradas em sistemas robóticos, utilizando bibliotecas como OpenCV para ambientes mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Hardware e Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Conecte a câmera USB ou integrada ao sistema robótico (ex: Raspberry Pi ou PC mecatrônico).",
                                    "Verifique a detecção do dispositivo no sistema operacional usando comandos como 'lsusb' (Linux) ou Gerenciador de Dispositivos (Windows).",
                                    "Instale Python 3.x e crie um ambiente virtual com 'python -m venv cv_env'.",
                                    "Ative o ambiente virtual e instale OpenCV com 'pip install opencv-python'.",
                                    "Teste a importação básica executando 'python -c \"import cv2; print(cv2.__version__)\"'."
                                  ],
                                  "verification": "OpenCV é importado sem erros e versão é exibida no terminal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Computador ou Raspberry Pi com SO Linux/Windows",
                                    "Câmera USB ou integrada",
                                    "Acesso à internet para pip"
                                  ],
                                  "tips": "Use um ambiente virtual para evitar conflitos de dependências em projetos mecatrônicos.",
                                  "learningObjective": "Configurar hardware e software essenciais para aquisição de imagens em sistemas embarcados.",
                                  "commonMistakes": [
                                    "Conectar câmera em porta USB com baixa energia",
                                    "Instalar OpenCV sem ativar ambiente virtual",
                                    "Ignorar drivers de câmera específicos do SO"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar e Inicializar a Câmera",
                                  "subSteps": [
                                    "Crie um script Python básico e liste câmeras disponíveis com cv2.VideoCapture(index) em loop de 0 a 5.",
                                    "Identifique o índice correto da câmera testando abertura com cap = cv2.VideoCapture(0).",
                                    "Configure propriedades iniciais: cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640); cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480).",
                                    "Adicione verificação de abertura: if not cap.isOpened(): print('Erro ao abrir câmera').",
                                    "Libere a captura com cap.release() após testes."
                                  ],
                                  "verification": "Índice da câmera é identificado e cap.isOpened() retorna True.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Script Python criado no passo 1"
                                  ],
                                  "tips": "Em sistemas robóticos, teste múltiplos índices pois webcams podem variar.",
                                  "learningObjective": "Detectar e acessar câmeras USB/integradas programaticamente com OpenCV.",
                                  "commonMistakes": [
                                    "Usar índice fixo sem testar",
                                    "Não configurar resolução levando a frames distorcidos",
                                    "Esquecer de liberar captura causando travamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Capturar e Exibir Frames em Tempo Real",
                                  "subSteps": [
                                    "Inicie um loop de captura: while True: ret, frame = cap.read().",
                                    "Verifique ret == True para frame válido; senão, break.",
                                    "Exiba o frame com cv2.imshow('Câmera', frame).",
                                    "Adicione controle de saída: if cv2.waitKey(1) & 0xFF == ord('q'): break.",
                                    "Finalize com cv2.destroyAllWindows() e cap.release()."
                                  ],
                                  "verification": "Janela exibe vídeo ao vivo da câmera sem lags ou erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Câmera conectada",
                                    "Script Python expandido"
                                  ],
                                  "tips": "Ajuste cv2.waitKey(1) para 30ms em sistemas lentos para reduzir carga de CPU.",
                                  "learningObjective": "Implementar captura contínua de frames para monitoramento em robótica.",
                                  "commonMistakes": [
                                    "Loop infinito sem tecla de saída",
                                    "Não verificar ret levando a frames None",
                                    "Alta resolução causando lentidão em hardware embarcado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Salvar Imagens e Integrar em Sistema Robótico",
                                  "subSteps": [
                                    "Capture frame único: ret, frame = cap.read(); if ret: cv2.imwrite('imagem_capturada.jpg', frame).",
                                    "Adicione timestamp: import datetime; cv2.putText(frame, str(datetime.datetime.now()), ...).",
                                    "Teste em contexto robótico: integre com GPIO no Raspberry Pi para trigger por sensor.",
                                    "Verifique qualidade da imagem salva abrindo o arquivo.",
                                    "Otimize para robótica: reduza frame para 320x240 se necessário."
                                  ],
                                  "verification": "Imagem é salva corretamente no disco e abre sem artefatos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script Python",
                                    "Espaço em disco",
                                    "Opcional: Raspberry Pi com GPIO"
                                  ],
                                  "tips": "Use formato JPEG para economia de espaço em logs robóticos.",
                                  "learningObjective": "Persistir imagens capturadas e preparar para integração mecatrônica.",
                                  "commonMistakes": [
                                    "Salvar sem verificar ret",
                                    "Caminho de arquivo inválido",
                                    "Ignorar compressão levando a arquivos grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Realizar Troubleshooting",
                                  "subSteps": [
                                    "Execute script completo em loop e monitore erros com try-except.",
                                    "Teste sob condições reais: iluminação variável, movimento.",
                                    "Ajuste parâmetros como exposure: cap.set(cv2.CAP_PROP_EXPOSURE, 0.5).",
                                    "Registre logs com print ou logging module.",
                                    "Documente configuração funcional para replicação em outros robôs."
                                  ],
                                  "verification": "Sistema captura imagens estáveis por 5 minutos sem crashes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Script final",
                                    "Ambiente de teste robótico"
                                  ],
                                  "tips": "Use cv2.getBuildInformation() para verificar suporte a backends de câmera.",
                                  "learningObjective": "Garantir robustez da aquisição de imagens em cenários mecatrônicos reais.",
                                  "commonMistakes": [
                                    "Não testar em hardware alvo",
                                    "Ignorar warnings de backend",
                                    "Falta de handling de exceções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um robô móvel mecatrônico, configure uma câmera USB no Raspberry Pi para capturar imagens de obstáculos a cada 10s, salvando-as com timestamp para análise posterior de navegação autônoma, usando OpenCV para trigger via sensor ultrassônico.",
                              "finalVerifications": [
                                "Câmera é detectada e inicializada consistentemente (cap.isOpened() == True).",
                                "Frames são capturados sem erros (ret == True em 100% dos testes).",
                                "Imagens salvas exibem qualidade visual adequada (sem borrões ou ruído excessivo).",
                                "Script roda por 5 minutos em loop sem memory leaks ou crashes.",
                                "Configurações funcionam em hardware robótico embarcado (ex: Raspberry Pi).",
                                "Propriedades como resolução e FPS são configuráveis e estáveis."
                              ],
                              "assessmentCriteria": [
                                "Código é limpo, comentado e segue boas práticas Python/OpenCV.",
                                "Todas as verificações de erro são implementadas (if not ret, etc.).",
                                "Tempo de execução atende requisitos (FPS > 15 em hardware padrão).",
                                "Integração com sistemas robóticos é demonstrada (ex: GPIO trigger).",
                                "Documentação inclui troubleshooting para cenários comuns.",
                                "Eficiência: uso < 50% CPU em captura contínua."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loop e manipulação de bibliotecas Python.",
                                "Eletrônica: Conexão e alimentação de periféricos USB em placas embarcadas.",
                                "Matemática: Arrays matriciais para representação de imagens (NumPy/OpenCV).",
                                "Física: Óptica básica e efeitos de iluminação na captura.",
                                "Engenharia de Software: Tratamento de exceções e logging em sistemas reais."
                              ],
                              "realWorldApplication": "Em inspeção industrial robótica, câmeras capturam imagens de peças em linha de produção para detecção de defeitos via OpenCV; em drones autônomos, adquirem frames para navegação e mapeamento ambiental em tempo real."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Processamento Básico de Imagens",
                            "description": "Aplicar filtros e transformações simples em imagens, como conversão para escala de cinza e detecção de bordas, preparando dados para controle robótico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do Ambiente de Processamento de Imagens",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: OpenCV e NumPy via pip.",
                                    "Importe as bibliotecas no script Python: import cv2 e import numpy as np.",
                                    "Crie um diretório de trabalho e baixe uma imagem de teste (ex: uma foto de um objeto robótico).",
                                    "Verifique a instalação executando cv2.__version__.",
                                    "Configure um visualizador básico com cv2.imshow."
                                  ],
                                  "verification": "Bibliotecas importadas sem erros e versão do OpenCV exibida no console.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "pip",
                                    "imagem de teste (JPEG/PNG)",
                                    "editor de código como VS Code"
                                  ],
                                  "tips": "Use um ambiente virtual (venv) para evitar conflitos de dependências.",
                                  "learningObjective": "Configurar um ambiente funcional para processamento de imagens com OpenCV.",
                                  "commonMistakes": [
                                    "Esquecer de instalar dependências",
                                    "Usar caminhos absolutos incorretos para imagens",
                                    "Não importar numpy como np"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Carregamento e Análise da Imagem Original",
                                  "subSteps": [
                                    "Carregue a imagem usando cv2.imread('imagem.jpg').",
                                    "Converta para array NumPy e verifique dimensões com .shape.",
                                    "Exiba a imagem original com cv2.imshow e cv2.waitKey(0).",
                                    "Salve uma cópia da imagem original para backup.",
                                    "Calcule estatísticas básicas como média de pixels."
                                  ],
                                  "verification": "Imagem carregada corretamente e exibida em uma janela sem erros de shape mismatch.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Script Python",
                                    "Imagem de teste"
                                  ],
                                  "tips": "Sempre use cv2.waitKey(0) e cv2.destroyAllWindows() para fechar janelas adequadamente.",
                                  "learningObjective": "Entender a representação de imagens como arrays matriciais em OpenCV.",
                                  "commonMistakes": [
                                    "Carregar imagem com caminho errado (retorna None)",
                                    "Esquecer de destruir janelas causando travamentos",
                                    "Confundir canais BGR com RGB"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicação de Conversão para Escala de Cinza",
                                  "subSteps": [
                                    "Aplique cv2.cvtColor(imagem, cv2.COLOR_BGR2GRAY) para converter.",
                                    "Exiba a imagem em escala de cinza lado a lado com a original usando np.hstack.",
                                    "Verifique o shape: deve ter apenas 2 dimensões (altura, largura).",
                                    "Salve a imagem cinza com cv2.imwrite('imagem_gray.jpg', gray_img).",
                                    "Compare histogramas antes e depois com cv2.calcHist."
                                  ],
                                  "verification": "Imagem em escala de cinza exibida corretamente com shape (H, W) e salva no disco.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script Python atualizado",
                                    "OpenCV"
                                  ],
                                  "tips": "Escala de cinza reduz dados de 3 canais para 1, acelerando processamento robótico.",
                                  "learningObjective": "Dominar transformações de cor para simplificação de dados de imagem.",
                                  "commonMistakes": [
                                    "Usar COLOR_RGB2GRAY em vez de COLOR_BGR2GRAY",
                                    "Não normalizar exibição com cv2.imshow",
                                    "Perder referência à imagem original"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detecção de Bordas com Filtro Canny",
                                  "subSteps": [
                                    "Aplique cv2.Canny(gray_img, 50, 150) com thresholds ajustáveis.",
                                    "Exiba bordas detectadas lado a lado com a imagem cinza.",
                                    "Ajuste thresholds para otimizar detecção (ex: lower=30, upper=100).",
                                    "Salve a imagem de bordas com cv2.imwrite.",
                                    "Extraia contornos com cv2.findContours para preview robótico."
                                  ],
                                  "verification": "Bordas nítidas detectadas e exibidas, com pelo menos 80% de contornos visíveis no objeto alvo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Script Python",
                                    "Imagem cinza processada"
                                  ],
                                  "tips": "Thresholds baixos detectam mais bordas (ruído); altos filtram melhor.",
                                  "learningObjective": "Implementar detecção de bordas para extração de features em visão robótica.",
                                  "commonMistakes": [
                                    "Thresholds inadequados causando imagem vazia ou ruidosa",
                                    "Aplicar Canny diretamente em colorida",
                                    "Não usar imagem cinza como input"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integração e Preparação para Controle Robótico",
                                  "subSteps": [
                                    "Combine resultados em um pipeline: load -> gray -> edges.",
                                    "Gere uma máscara binária de bordas com thresholding.",
                                    "Simule input robótico: calcule centroide de contornos com cv2.moments.",
                                    "Exporte dados (ex: coordenadas) para um arquivo JSON ou variável global.",
                                    "Teste pipeline completo em múltiplas imagens."
                                  ],
                                  "verification": "Pipeline executa end-to-end produzindo coordenadas utilizáveis sem crashes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Script completo",
                                    "Múltiplas imagens de teste"
                                  ],
                                  "tips": "Use funções modulares para reutilizar em loops robóticos reais.",
                                  "learningObjective": "Preparar dados processados de imagem para integração com controladores robóticos.",
                                  "commonMistakes": [
                                    "Não binarizar bordas adequadamente",
                                    "Erros em moments() com contornos vazios",
                                    "Ignorar escala de resolução para robô"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue uma imagem de uma linha preta em fundo branco simulando pista de robô. Converta para cinza, detecte bordas e extraia o centro da pista para enviar como comando de direção ao robô via serial.",
                              "finalVerifications": [
                                "Pipeline completo processa imagem em <2s.",
                                "Escala de cinza tem shape correto (H,W).",
                                "Bordas detectadas destacam features principais sem excesso de ruído.",
                                "Coordenadas de centroide calculadas e exportadas.",
                                "Resultados salvos em disco e visualizáveis.",
                                "Funciona com 3 imagens de teste diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão da conversão cinza: PSNR > 30dB comparado a referência.",
                                "Qualidade de bordas: Taxa de falsos positivos <10%.",
                                "Eficiência: Tempo total <90s para pipeline.",
                                "Robustez: Sucesso em 90% das imagens teste.",
                                "Código limpo: Comentado, modular e sem warnings.",
                                "Integração: Dados prontos para mock de controlador robótico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações matriciais e convolução (álgebra linear).",
                                "Programação: Estruturas de dados (arrays NumPy) e funções modulares.",
                                "Física: Modelos de luz e gradientes de intensidade.",
                                "Engenharia: Preparação de sensores para feedback em malhas de controle."
                              ],
                              "realWorldApplication": "Em robôs autônomos para navegação por visão (ex: detecção de linhas em AGVs), inspeção industrial de peças ou reconhecimento de obstáculos em drones, reduzindo dependência de sensores caros como LIDAR."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Extração de Características Visuais",
                            "description": "Identificar formas, cores e contornos básicos em imagens para reconhecimento de objetos em cenários industriais mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Características Visuais",
                                  "subSteps": [
                                    "Estude definições de formas geométricas básicas (círculos, retângulos, triângulos) em imagens.",
                                    "Aprenda sobre representação de cores no espaço RGB e HSV.",
                                    "Identifique contornos como bordas detectadas por gradientes de intensidade.",
                                    "Revise exemplos de imagens industriais com objetos mecatrônicos (parafusos, engrenagens).",
                                    "Anote diferenças entre ruído e características reais em cenários industriais."
                                  ],
                                  "verification": "Crie um diagrama anotado de uma imagem de exemplo destacando formas, cores e contornos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com visualizador de imagens",
                                    "Imagens de teste industriais (parafusos, peças mecatrônicas)",
                                    "Documentação básica de visão computacional (PDF ou site)"
                                  ],
                                  "tips": "Use imagens de alta resolução para melhor visualização; comece com objetos isolados antes de cenários complexos.",
                                  "learningObjective": "Dominar terminologia e identificação visual manual de características básicas.",
                                  "commonMistakes": [
                                    "Confundir sombras com contornos reais",
                                    "Ignorar variações de iluminação em cores",
                                    "Subestimar o impacto do ruído industrial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Extração de Cores em Imagens",
                                  "subSteps": [
                                    "Instale bibliotecas Python: OpenCV e NumPy.",
                                    "Carregue uma imagem e converta de RGB para HSV.",
                                    "Defina máscaras de cor para um objeto específico (ex: vermelho de uma peça).",
                                    "Aplique morfologia para remover ruído (erosão e dilatação).",
                                    "Visualize e salve a imagem segmentada por cor."
                                  ],
                                  "verification": "Execute o código e gere uma imagem segmentada onde apenas o objeto alvo é destacado pela cor.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "OpenCV e NumPy",
                                    "Imagens de peças industriais coloridas"
                                  ],
                                  "tips": "Ajuste thresholds de HSV iterativamente com trackbars no OpenCV para precisão.",
                                  "learningObjective": "Aplicar segmentação por cor para isolar objetos em imagens mecatrônicas.",
                                  "commonMistakes": [
                                    "Thresholds fixos sem considerar iluminação variável",
                                    "Esquecer conversão HSV para melhor segmentação",
                                    "Não aplicar operações morfológicas para ruído"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair Formas e Contornos Básicos",
                                  "subSteps": [
                                    "Aplique detecção de bordas com Canny no OpenCV.",
                                    "Encontre contornos usando findContours na imagem de bordas.",
                                    "Aproximem contornos a polígonos simples (ex: retângulo para engrenagem).",
                                    "Calcule propriedades como área, perímetro e bounding box.",
                                    "Filtre contornos por tamanho para ignorar ruído industrial."
                                  ],
                                  "verification": "Desenhe bounding boxes e labels nos contornos detectados em uma imagem de teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ambiente Python com OpenCV",
                                    "Imagens de objetos mecatrônicos com formas distintas"
                                  ],
                                  "tips": "Use sigma baixo no Canny para bordas nítidas em peças metálicas; teste com diferentes thresholds.",
                                  "learningObjective": "Detectar e caracterizar formas e contornos para reconhecimento de objetos.",
                                  "commonMistakes": [
                                    "Parâmetros Canny inadequados causando bordas fragmentadas",
                                    "Não filtrar contornos pequenos",
                                    "Ignorar hierarquia de contornos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Extração de Características em um Fluxo Completo",
                                  "subSteps": [
                                    "Combine segmentação por cor com detecção de contornos.",
                                    "Classifique objetos baseados em features (cor dominante + forma aproximada).",
                                    "Teste em múltiplas imagens industriais simulando linha de produção.",
                                    "Meça precisão com métricas simples (ex: taxa de detecção correta).",
                                    "Otimize o pipeline para tempo real (reduza resolução se necessário)."
                                  ],
                                  "verification": "Crie um script que processe uma sequência de imagens e output um relatório de objetos detectados.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Dataset de 10+ imagens mecatrônicas variadas",
                                    "Jupyter Notebook para experimentação"
                                  ],
                                  "tips": "Estruture o código em funções modulares para reutilização em robótica.",
                                  "learningObjective": "Construir um pipeline integrado de extração de features visuais acionável.",
                                  "commonMistakes": [
                                    "Pipeline não robusto a rotações ou escalas",
                                    "Sobrecarga computacional sem otimização",
                                    "Falta de validação cruzada com múltiplas imagens"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem mecatrônica, use o pipeline para detectar parafusos vermelhos retangulares: segmente por cor HSV, detecte contornos Canny, filtre por área e forma, e sinalize para o robô pegar apenas peças corretas, ignorando detritos.",
                              "finalVerifications": [
                                "Segmenta corretamente objetos por cor em imagens com ruído industrial.",
                                "Detecta e classifica formas básicas (círculo, retângulo) com >80% precisão.",
                                "Extrai contornos robustos sob variações de iluminação.",
                                "Integra features em um classificador simples de objetos mecatrônicos.",
                                "Processa imagens em <1 segundo por frame para aplicação em tempo real.",
                                "Gera relatórios visuais com bounding boxes e labels precisos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na segmentação de cores (>90% overlap com ground truth).",
                                "Qualidade de detecção de contornos (IoU >0.7 para formas principais).",
                                "Robustez a ruído e oclusões industriais (sucesso em 8/10 imagens teste).",
                                "Eficiência computacional (tempo de processamento adequado para robótica).",
                                "Clareza e modularidade do código implementado.",
                                "Capacidade de generalização para novos objetos similares."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria analítica para aproximação de formas e cálculo de propriedades.",
                                "Programação: Algoritmos de processamento de imagens em Python/OpenCV.",
                                "Física: Óptica e propriedades de luz/cor em materiais industriais.",
                                "Engenharia Mecânica: Identificação de componentes mecatrônicos por features visuais.",
                                "Inteligência Artificial: Bases para machine learning em visão computacional."
                              ],
                              "realWorldApplication": "Em fábricas de automação mecatrônica, sistemas de visão extraem features para inspeção de qualidade de peças (ex: detectar parafusos defeituosos por forma irregular ou cor oxidada), guiando robôs em montagem precisa e reduzindo erros humanos em linhas de produção."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Integração com Microcontroladores e Hardware Robótico",
                        "description": "Conexão de sistemas de visão computacional com microprocessadores, microcontroladores e CLPs em projetos mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Interfaces de Comunicação Visão-Hardware",
                            "description": "Implementar comunicação via USB, I2C ou serial entre câmeras de visão e microcontroladores como Arduino ou Raspberry Pi em robôs mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Configurar Hardware para Comunicação",
                                  "subSteps": [
                                    "Escolha a interface: USB para alta velocidade, I2C para comunicação mestre-escravo curta distância, ou serial (UART) para simplicidade.",
                                    "Selecione componentes: câmera como Raspberry Pi Camera ou OV2640, microcontrolador Arduino Uno ou Raspberry Pi Pico.",
                                    "Monte conexões físicas: Para I2C, conecte SDA/SCL com resistores pull-up 4.7kΩ; para serial, TX/RX e GND; para USB, use cabo direto.",
                                    "Alimente corretamente: Verifique tensões (3.3V ou 5V) e evite curtos.",
                                    "Teste conexões com multímetro para continuidade."
                                  ],
                                  "verification": "Hardware conectado sem erros de solda ou curto-circuito, medido com multímetro.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Câmera de visão (ex: OV7670 ou Pi Camera)",
                                    "Microcontrolador (Arduino/RPi)",
                                    "Fios jumper, protoboard, resistores pull-up",
                                    "Multímetro"
                                  ],
                                  "tips": "Use diagramas Fritzing para esquemas visuais e comece com serial para depuração fácil.",
                                  "learningObjective": "Entender pinouts e requisitos elétricos de interfaces de comunicação.",
                                  "commonMistakes": [
                                    "Inverter TX/RX em serial",
                                    "Esquecer pull-ups em I2C",
                                    "Misturar níveis lógicos 3.3V/5V"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar Bibliotecas e Configurar Ambiente de Software",
                                  "subSteps": [
                                    "Instale IDEs: Arduino IDE ou PlatformIO para microcontrolador; Thonny ou VSCode para RPi.",
                                    "Adicione bibliotecas: Para Arduino, Adafruit_Sensor para I2C ou SoftwareSerial; para câmeras, esp32-camera ou raspicam.",
                                    "Configure baud rate comum (ex: 9600 para serial) e endereços I2C (ex: 0x3C para câmeras).",
                                    "Teste bibliotecas com sketches de exemplo: I2C scanner ou serial echo.",
                                    "Compile e suba firmware básico para verificar detecção do dispositivo."
                                  ],
                                  "verification": "Bibliotecas instaladas e sketch de teste roda sem erros de compilação ou 'device not found'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com IDE instalada",
                                    "Cabos USB para programação"
                                  ],
                                  "tips": "Use gerenciador de bibliotecas do Arduino IDE para evitar versões incompatíveis.",
                                  "learningObjective": "Dominar setup de ambientes para comunicação embarcada.",
                                  "commonMistakes": [
                                    "Baud rates diferentes entre sender/receiver",
                                    "Bibliotecas erradas para o hardware específico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Código de Envio de Dados na Câmera",
                                  "subSteps": [
                                    "Capture imagem: Use funções como camera_fb_get() para frames.",
                                    "Processe dados: Reduza resolução ou extraia features simples (ex: média de pixels para detecção de luz).",
                                    "Formate pacote: Adicione header (ex: 'IMG'), dados binários ou ASCII, checksum CRC.",
                                    "Envie via interface: Serial.print() ou Wire.write() em loop não-bloqueante.",
                                    "Adicione delay ou buffer para evitar overflow."
                                  ],
                                  "verification": "Monitor serial mostra pacotes saindo da câmera com dados válidos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código fonte editável no IDE"
                                  ],
                                  "tips": "Comece enviando dados simples como 'Hello' antes de imagens para validar link.",
                                  "learningObjective": "Codificar transmissão de dados de visão de forma eficiente.",
                                  "commonMistakes": [
                                    "Enviar frames full HD sem compressão (overhead alto)",
                                    "Loop bloqueante que trava comunicação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Código de Recebimento no Microcontrolador",
                                  "subSteps": [
                                    "Inicialize receptor: Serial.begin() ou Wire.begin() como slave.",
                                    "Leia pacotes: Use buffer circular para receber bytes até header/checksum.",
                                    "Valide dados: Verifique checksum e tamanho.",
                                    "Processe: Acione LEDs, motores ou salve em SD baseado nos dados de visão.",
                                    "Envie ACK/NACK de volta para handshake bidirecional."
                                  ],
                                  "verification": "Microcontrolador recebe e processa dados corretamente, acionando output visível (ex: LED pisca).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código no microcontrolador"
                                  ],
                                  "tips": "Use interrupções para serial rápida; debug com Serial Monitor.",
                                  "learningObjective": "Gerenciar recepção e parsing de dados em tempo real.",
                                  "commonMistakes": [
                                    "Buffer overflow sem flush",
                                    "Ignorar erros de checksum"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Depurar e Otimizar Integração",
                                  "subSteps": [
                                    "Teste end-to-end: Rode ambos códigos e verifique latência/dados corretos.",
                                    "Monitore com osciloscópio ou logic analyzer para sinais.",
                                    "Otimize: Aumente baud rate, reduza dados enviados.",
                                    "Adicione timeouts e retry para robustez.",
                                    "Integre em robô: Conecte a atuadores para demo completa."
                                  ],
                                  "verification": "Comunicação bidirecional estável por 10 minutos sem perda de pacotes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Logic analyzer opcional",
                                    "Robô base para integração"
                                  ],
                                  "tips": "Registre logs em ambos sides para comparar timestamps.",
                                  "learningObjective": "Garantir sistema robusto para aplicações robóticas.",
                                  "commonMistakes": [
                                    "Ruído em cabos longos sem shielding",
                                    "Sobreaquecimento por loops intensivos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um robô seguidor de linha, conecte uma ESP32-CAM via serial (9600 baud) a um Arduino Uno. A câmera detecta a linha preta (média pixels <100) e envia 'LINE_LEFT' ou 'LINE_RIGHT'. Arduino recebe e ajusta motores para seguir.",
                              "finalVerifications": [
                                "Dados de imagem são transmitidos sem corrupção (checksum OK).",
                                "Latência <500ms entre captura e ação no microcontrolador.",
                                "Comunicação persiste por 30min sem falhas.",
                                "Handshake ACK/NACK funciona bilateralmente.",
                                "Integração com atuadores robóticos responde corretamente.",
                                "Níveis de tensão compatíveis sem danos ao hardware."
                              ],
                              "assessmentCriteria": [
                                "Código modular e comentado (80% cobertura).",
                                "Eficiência: Uso <70% CPU em ambos devices.",
                                "Robustez: Recupera de 90% das falhas de transmissão.",
                                "Documentação: Diagrama de pinos e protocolo de dados.",
                                "Escalabilidade: Funciona com múltiplas câmeras/interfaces.",
                                "Segurança: Sem vazamento de memória ou overflows."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Protocolos de barramento (I2C/USB).",
                                "Programação: Estruturas de dados e comunicação assíncrona.",
                                "Física: Sinais elétricos e ruído em transmissão.",
                                "Matemática: Checksums e processamento de imagem básico.",
                                "Engenharia de Software: Protocolos cliente-servidor embarcados."
                              ],
                              "realWorldApplication": "Em drones autônomos para inspeção, onde câmeras enviam frames processados via I2C para flight controller; ou em braços robóticos industriais usando USB para visão de qualidade em linhas de montagem."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Processamento em Tempo Real com Microcontroladores",
                            "description": "Otimizar algoritmos de visão para execução em microcontroladores, integrando resultados visuais ao loop de controle de atuadores robóticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Otimização de Algoritmos de Visão para Recursos Limitados",
                                  "subSteps": [
                                    "Analise o algoritmo de visão atual (ex: detecção de objetos via thresholding ou edge detection) e identifique gargalos como operações de ponto flutuante ou loops ineficientes.",
                                    "Converta operações complexas para inteiros fixos (fixed-point arithmetic) para compatibilidade com microcontroladores sem FPU.",
                                    "Reduza a resolução da imagem de entrada e aplique downsampling ou ROI (Region of Interest) para minimizar processamento.",
                                    "Implemente paralelismo simples ou pipelining onde possível, usando interrupções para captura de frames.",
                                    "Teste o algoritmo otimizado em simulador (ex: MATLAB/Simulink ou OpenCV em PC) medindo ciclos de CPU."
                                  ],
                                  "verification": "O algoritmo otimizado executa em menos de 50ms por frame em simulação, com precisão mantida acima de 90%.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Computador com IDE (Arduino IDE ou PlatformIO)",
                                    "Bibliotecas: OpenCV ou CMSIS-DSP",
                                    "Câmera simulada ou webcam"
                                  ],
                                  "tips": "Priorize subsampling bilinear para manter qualidade visual sem custo computacional alto.",
                                  "learningObjective": "Compreender técnicas de otimização para embutir visão computacional em hardware restrito.",
                                  "commonMistakes": [
                                    "Ignorar overflow em aritmética fixed-point",
                                    "Processar frames inteiros sem ROI",
                                    "Usar bibliotecas floating-point em MCUs sem suporte"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração do Microcontrolador para Processamento de Imagem em Tempo Real",
                                  "subSteps": [
                                    "Selecione e configure o microcontrolador (ex: ESP32-CAM ou STM32 com DCMI) com clock alto e DMA para captura de imagem.",
                                    "Integre drivers de câmera (OV2640 ou similar) e configure interrupções para sincronização de frames.",
                                    "Porte o algoritmo otimizado para C/C++ embarcado, usando bibliotecas como ESP-IDF ou HAL.",
                                    "Implemente buffer circular para frames para evitar perda de dados durante processamento.",
                                    "Compile e flash o código, monitorando uso de RAM/Flash via ferramentas de profiling."
                                  ],
                                  "verification": "Captura e processa 10-30 FPS estáveis, confirmado via serial monitor ou LED de status.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Microcontrolador com câmera (ESP32-CAM)",
                                    "Cabo USB",
                                    "Osciloscópio ou logic analyzer opcional"
                                  ],
                                  "tips": "Use DMA para transferência de imagem para reduzir carga na CPU principal.",
                                  "learningObjective": "Configurar hardware embarcado para pipelines de visão em tempo real.",
                                  "commonMistakes": [
                                    "Configurar pinos errados para câmera",
                                    "Subestimar consumo de RAM por buffers de imagem",
                                    "Ignorar jitter de timing sem RTOS"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integração de Resultados Visuais ao Loop de Controle de Atuadores",
                                  "subSteps": [
                                    "Defina interface de dados: resultados visuais (ex: posição de objeto) como variáveis globais ou queue compartilhada.",
                                    "Estruture o loop principal com prioridades: captura visão -> processa -> atualiza controle PID ou FSM -> comanda atuadores (motores via PWM).",
                                    "Implemente controle baseado em visão (ex: seguir linha detectada ajustando velocidade de rodas).",
                                    "Adicione filtros (Kalman ou média móvel) para suavizar saídas visuais ruidosas.",
                                    "Sincronize com RTOS tasks (FreeRTOS) se disponível para evitar bloqueios."
                                  ],
                                  "verification": "Atuadores respondem corretamente a comandos visuais em <100ms de latência total, testado com osciloscópio.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Robô chassis com motores DC/servos",
                                    "Driver de motor (L298N)",
                                    "Sensores adicionais para feedback"
                                  ],
                                  "tips": "Use flags de sincronização atômicas para comunicação entre tasks de visão e controle.",
                                  "learningObjective": "Integrar feedback sensorial de visão em loops de controle fechado.",
                                  "commonMistakes": [
                                    "Bloqueio mútuo entre visão e controle",
                                    "Falta de debounce em detecções visuais",
                                    "Sobrecarga de loop principal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testes, Depuração e Otimização Final em Tempo Real",
                                  "subSteps": [
                                    "Execute testes unitários para visão e controle separadamente, depois integrados.",
                                    "Meça performance real: FPS, latência end-to-end, precisão de tracking com cronômetro e vídeo.",
                                    "Depure com printf serial, breakpoints ou JTAG; otimize hotspots via profiling (ex: perf counters).",
                                    "Adicione modos de fallback (controle sem visão) para robustez.",
                                    "Valide em cenários reais: iluminação variável, velocidades diferentes."
                                  ],
                                  "verification": "Sistema completo opera a 15+ FPS com erro de tracking <5cm em ambiente controlado.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ambiente de teste (pista de linha ou objetos móveis)",
                                    "Multímetro",
                                    "Software de análise de vídeo"
                                  ],
                                  "tips": "Grave logs de timing para identificar bottlenecks pós-teste.",
                                  "learningObjective": "Garantir robustez e performance em sistemas mecatrônicos integrados.",
                                  "commonMistakes": [
                                    "Testar só em condições ideais",
                                    "Ignorar consumo de energia em bateria",
                                    "Não calibrar thresholds de visão"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um robô seguidor de linha que usa câmera no ESP32 para detectar linha preta em fundo branco, otimizando detecção por thresholding binário fixed-point, e ajusta PWM dos motores para correção proporcional à posição da linha detectada, mantendo 20 FPS.",
                              "finalVerifications": [
                                "Processamento de frames a pelo menos 15 FPS em hardware real.",
                                "Latência total de visão a atuador <100ms.",
                                "Precisão de controle mantida em variações de iluminação (±20%).",
                                "Uso de RAM/CPU abaixo de 80% em operação contínua.",
                                "Robustez a falhas: graceful degradation sem visão.",
                                "Logs de depuração confirmam ausência de overflows ou crashes."
                              ],
                              "assessmentCriteria": [
                                "Eficiência: Ciclos de CPU otimizados para tempo real (métricas quantificáveis).",
                                "Precisão: Erro médio de tracking <10% em testes repetidos.",
                                "Integração: Comunicação sem conflitos entre módulos visão/controle.",
                                "Robustez: Funciona em 90% dos cenários reais testados.",
                                "Documentação: Código comentado com profiling results.",
                                "Escalabilidade: Fácil adaptação para novos algoritmos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Embarcada: Uso de C/C++ e RTOS para tasks paralelas.",
                                "Controle Automático: Integração de PID/FSM com feedback sensorial.",
                                "Eletrônica Digital: DMA, interrupções e periféricos de microcontroladores.",
                                "Processamento de Sinais: Filtros e otimização numérica.",
                                "Física Aplicada: Cinemática de robôs e dinâmica de atuadores."
                              ],
                              "realWorldApplication": "Em robôs industriais para inspeção de linhas de montagem (ex: detecção de defeitos em tempo real controlando braços robóticos), drones autônomos para navegação visual, ou veículos AGV em armazéns otimizando caminhos via visão embarcada."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Integração com CLPs em Sistemas Industriais",
                            "description": "Conectar sistemas de visão a CLPs para automação mecatrônica, utilizando protocolos como Modbus para feedback visual em linhas de produção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreensão de Conceitos Fundamentais de CLPs e Protocolos",
                                  "subSteps": [
                                    "Estude a arquitetura de um CLP típico (CPU, I/O, comunicação).",
                                    "Aprenda os princípios do protocolo Modbus RTU/TCP, incluindo frames de dados e comandos (read/write coils/registers).",
                                    "Identifique papéis de sistemas de visão em automação: detecção de objetos, inspeção de qualidade.",
                                    "Revise exemplos de integração visão-CLP em cenários mecatrônicos.",
                                    "Desenhe um diagrama de fluxo de dados entre câmera, processador de visão e CLP."
                                  ],
                                  "verification": "Crie um diagrama esquemático da integração e explique verbalmente ou por escrito os fluxos de dados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação Modbus oficial",
                                    "Manuais de CLPs (ex: Siemens S7, Allen-Bradley)",
                                    "Software de desenho (Draw.io)"
                                  ],
                                  "tips": "Comece com Modbus TCP para simplicidade em redes Ethernet; evite RTU inicialmente se possível.",
                                  "learningObjective": "Entender os componentes e protocolos necessários para comunicação entre visão e CLP.",
                                  "commonMistakes": [
                                    "Confundir Modbus RTU com TCP",
                                    "Ignorar paridade e baud rate em configurações seriais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração de Hardware e Conexões Físicas",
                                  "subSteps": [
                                    "Monte o hardware: conecte câmera de visão ao PC/processador via USB/Ethernet.",
                                    "Conecte o CLP ao PC via porta serial (RS485 para RTU) ou Ethernet (para TCP).",
                                    "Configure endereços IP ou IDs de escravo/master no CLP e software de visão.",
                                    "Teste conexões físicas com multímetro ou ping para Ethernet.",
                                    "Instale drivers e firmwares necessários para hardware."
                                  ],
                                  "verification": "Confirme continuidade elétrica e ping bem-sucedido entre dispositivos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "CLP com suporte Modbus",
                                    "Câmera industrial (ex: Cognex ou similar)",
                                    "Cabos RS485/Ethernet",
                                    "Multímetro"
                                  ],
                                  "tips": "Use conversores USB-RS485 de qualidade para evitar ruído; isole terras para prevenir loops de terra.",
                                  "learningObjective": "Estabelecer conexões físicas seguras e funcionais entre sistemas de visão e CLP.",
                                  "commonMistakes": [
                                    "Cabos mal terminados causando ruído",
                                    "Endereços IP conflitantes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Programação do Software de Visão e CLP para Comunicação",
                                  "subSteps": [
                                    "No software de visão (ex: Halcon, OpenCV), programe detecção de objetos e gere triggers baseados em resultados.",
                                    "Configure o CLP (Ladder Logic ou Structured Text) para ler/gravar registros Modbus como master/escravo.",
                                    "Implemente lógica: visão envia sinal de defeito via Modbus write para coil no CLP.",
                                    "Adicione timers e buffers para sincronização.",
                                    "Compile e faça upload do programa no CLP."
                                  ],
                                  "verification": "Execute simulação no software do CLP mostrando leitura de dados simulados da visão.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de programação CLP (TIA Portal, RSLogix)",
                                    "SDK de visão computacional",
                                    "Simulador Modbus (ModRSsim)"
                                  ],
                                  "tips": "Use funções Modbus prontas no CLP para agilizar; teste com simulador antes do hardware real.",
                                  "learningObjective": "Desenvolver código que habilite troca de dados via Modbus entre visão e CLP.",
                                  "commonMistakes": [
                                    "Timeouts não configurados levando a falhas",
                                    "Endianness errada em registradores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testes, Integração e Depuração em Ambiente Real",
                                  "subSteps": [
                                    "Execute teste end-to-end: detecte objeto na visão e verifique ação no CLP (ex: acender LED ou parar motor).",
                                    "Monitore tráfego Modbus com Wireshark ou ferramentas do CLP.",
                                    "Depure erros comuns como falhas de CRC ou timeouts.",
                                    "Otimize latência para feedback em tempo real (<500ms).",
                                    "Documente configurações e logs de testes."
                                  ],
                                  "verification": "Registre vídeo ou log mostrando detecção visual levando a resposta do CLP sem erros.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Equipamento de teste (motores, LEDs simulando linha)",
                                    "Ferramentas de monitoramento (Wireshark, CLP diagnostics)"
                                  ],
                                  "tips": "Comece com velocidades baixas de polling; aumente gradualmente; use watchdogs no CLP.",
                                  "learningObjective": "Validar e refinar a integração para operação confiável em cenários industriais.",
                                  "commonMistakes": [
                                    "Ignorar latência de rede",
                                    "Não testar edge cases como perda de sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicação em Linha de Produção e Otimização Final",
                                  "subSteps": [
                                    "Integre em mockup de linha de produção: visão inspeciona peças, CLP controla esteiras base no feedback.",
                                    "Colete métricas: taxa de detecção, tempo de resposta, taxa de falsos positivos.",
                                    "Ajuste thresholds e parâmetros para robustez.",
                                    "Implemente redundâncias (ex: fallback manual).",
                                    "Crie relatório de performance e plano de manutenção."
                                  ],
                                  "verification": "Demonstre operação contínua por 30 minutos sem falhas em ambiente simulado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Mockup de linha (esteiras, sensores)",
                                    "Ferramentas de medição (oscilloscópio)"
                                  ],
                                  "tips": "Calibre visão sob diferentes iluminações; priorize safety interlocks.",
                                  "learningObjective": "Aplicar a integração em contexto real e otimizar para produção industrial.",
                                  "commonMistakes": [
                                    "Sobrecarga de rede por polling excessivo",
                                    "Falta de calibração ambiental"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de embalagens, uma câmera detecta rótulos mal posicionados e envia um sinal Modbus para o CLP parar a esteira e ativar alarme, evitando desperdício de material.",
                              "finalVerifications": [
                                "Comunicação Modbus estabelecida com taxa de erro <1%.",
                                "Feedback visual resulta em ação correta no CLP em <300ms.",
                                "Sistema opera estável por 1 hora em condições variáveis.",
                                "Logs mostram detecção precisa de pelo menos 95% dos casos.",
                                "Depuração identifica e corrige falhas simuladas.",
                                "Integração compatível com expansão futura (ex: múltiplas câmeras)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de protocolos e hardware (90%+ sucesso em testes).",
                                "Eficiência do código: latência baixa e uso otimizado de recursos.",
                                "Robustez: handling de erros e recuperação automática.",
                                "Documentação clara de passos, configurações e troubleshooting.",
                                "Criatividade em conexões interdisciplinares demonstradas.",
                                "Capacidade de depuração independente."
                              ],
                              "crossCurricularConnections": [
                                "Programação Industrial (Ladder Logic, PLC programming).",
                                "Redes Industriais (Ethernet/IP, Profibus).",
                                "Processamento de Imagens (OpenCV, visão computacional).",
                                "Controle Automático (PID, lógica fuzzy para feedback).",
                                "Segurança Industrial (ISO 13849 para interlocks)."
                              ],
                              "realWorldApplication": "Indústrias automotiva e farmacêutica usam essa integração para inspeção de qualidade em tempo real, reduzindo defeitos em 30-50% e aumentando throughput em linhas de produção de alta velocidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Aplicações em Tarefas Robóticas Mecatrônicas",
                        "description": "Uso prático de visão computacional em robótica para aplicações industriais, como na aeronáutica, com ênfase em projetos integrados.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Detecção de Objetos para Pick-and-Place",
                            "description": "Desenvolver sistema de visão para localizar e guiar braços robóticos em tarefas de montagem, simulando cenários aeronáuticos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do Ambiente de Visão Computacional",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias como OpenCV, NumPy e ROS (Robot Operating System).",
                                    "Conectar e calibrar a câmera (ex: webcam ou câmera industrial) com o braço robótico simulado.",
                                    "Configurar o ambiente de simulação (ex: Gazebo para cenários aeronáuticos) com peças de montagem virtuais.",
                                    "Testar aquisição de imagem em tempo real e salvar amostras.",
                                    "Definir coordenadas de referência para o espaço de trabalho do robô."
                                  ],
                                  "verification": "Imagem capturada e exibida corretamente com overlay de coordenadas de referência.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Computador com Python 3.8+, OpenCV 4.x, ROS Noetic, Câmera USB, Braço robótico simulado (ex: URDF em Gazebo)"
                                  ],
                                  "tips": "Use iluminação uniforme para evitar sombras; calibre a câmera com tabuleiro de xadrez para precisão.",
                                  "learningObjective": "Configurar hardware e software para visão computacional integrada a robótica.",
                                  "commonMistakes": [
                                    "Ignorar calibração da câmera levando a distorções",
                                    "Bibliotecas incompatíveis causando erros de importação",
                                    "Espaço de trabalho mal definido resultando em coordenadas erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aquisição e Pré-processamento de Imagens",
                                  "subSteps": [
                                    "Capturar frames em tempo real da cena com peças aeronáuticas (ex: parafusos, porcas).",
                                    "Aplicar filtros: conversão para escala de cinza, remoção de ruído com Gaussian Blur, equalização de histograma.",
                                    "Segmentar imagem usando thresholding adaptativo ou detecção de bordas com Canny.",
                                    "Identificar regiões de interesse (ROI) baseadas em contornos.",
                                    "Normalizar imagens para consistência em diferentes condições de luz."
                                  ],
                                  "verification": "Imagens pré-processadas mostram objetos segmentados claramente sem ruído excessivo.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código Python com OpenCV, Imagens de teste de peças mecatrônicas aeronáuticas"
                                  ],
                                  "tips": "Ajuste parâmetros de threshold dinamicamente baseado na média de intensidade da imagem.",
                                  "learningObjective": "Preparar imagens para detecção robusta em ambientes industriais variáveis.",
                                  "commonMistakes": [
                                    "Threshold fixo falhando em variações de luz",
                                    "Blur excessivo apagando bordas finas",
                                    "ROI muito amplo incluindo fundo irrelevante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolvimento do Algoritmo de Detecção e Localização de Objetos",
                                  "subSteps": [
                                    "Treinar ou usar modelo pré-treinado (ex: YOLOv5 ou template matching) para detectar objetos específicos.",
                                    "Calcular centroide e orientação do objeto detectado usando momentos de Hu.",
                                    "Converter coordenadas de pixel para coordenadas 3D do robô via transformação homográfica.",
                                    "Filtrar detecções falsas com bounding box confidence > 0.8 e tamanho mínimo.",
                                    "Publicar coordenadas via tópicos ROS para o controlador do robô."
                                  ],
                                  "verification": "Sistema publica coordenadas precisas de objetos detectados em tempo real (latência < 100ms).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Modelos YOLO pré-treinados, Dataset de imagens aeronáuticas anotadas, ROS topics configurados"
                                  ],
                                  "tips": "Use non-max suppression para evitar múltiplas detecções do mesmo objeto.",
                                  "learningObjective": "Implementar detecção precisa e conversão de coordenadas para orientação robótica.",
                                  "commonMistakes": [
                                    "Erro na homografia causando desalinhamento 3D",
                                    "Confidence baixo aceitando falsos positivos",
                                    "Ignorar rotação do objeto afetando pick preciso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração com Braço Robótico e Controle Pick-and-Place",
                                  "subSteps": [
                                    "Subscrever coordenadas de visão no nó ROS do braço robótico.",
                                    "Gerar trajetória de pick: mover para posição acima, descer com gripper, fechar garra.",
                                    "Executar place: mover para posição de montagem, abrir garra, confirmar inserção.",
                                    "Implementar feedback visual para correções em loop fechado.",
                                    "Simular falhas (ex: objeto escorregadio) e adicionar recuperação."
                                  ],
                                  "verification": "Robô pega e coloca objeto corretamente em 5 tentativas consecutivas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Simulador Gazebo com UR5 ou similar, ROS MoveIt para planejamento de trajetória"
                                  ],
                                  "tips": "Adicione velocidades seguras (0.2 m/s) para evitar colisões.",
                                  "learningObjective": "Integrar visão com controle robótico para tarefas autônomas.",
                                  "commonMistakes": [
                                    "Trajetória colidindo com obstáculos",
                                    "Gripper não calibrado soltando objeto cedo",
                                    "Falta de feedback causando loops infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes, Otimização e Validação",
                                  "subSteps": [
                                    "Executar testes em cenários variados: diferentes ângulos, velocidades, oclusões parciais.",
                                    "Medir métricas: taxa de sucesso (>90%), precisão de localização (<2mm erro), tempo ciclo.",
                                    "Otimizar hiperparâmetros com grid search ou tuning manual.",
                                    "Registrar logs e vídeos para análise.",
                                    "Documentar sistema com diagrama de fluxo e código comentado."
                                  ],
                                  "verification": "Relatório com métricas atingindo thresholds e demo em vídeo funcionando.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de logging ROS (rqt, rosbag), Scripts de métrica"
                                  ],
                                  "tips": "Teste com peças reais aeronáuticas para validar simulação.",
                                  "learningObjective": "Avaliar e refinar sistema para robustez industrial.",
                                  "commonMistakes": [
                                    "Testes só em condições ideais falhando no real",
                                    "Métricas não quantificadas",
                                    "Otimização prematura sem baseline"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de montagem de fuselagem aeronáutica, o sistema detecta uma porca M6 em uma esteira, calcula sua posição 3D, guia o braço UR5 para pegá-la e colocá-la precisamente em um parafuso de estrutura de alumínio, repetindo para 10 ciclos com sucesso de 95%.",
                              "finalVerifications": [
                                "Sistema detecta e localiza objetos com precisão < 2mm em coordenadas 3D.",
                                "Integração ROS publica/subscribe coordenadas em <50ms latência.",
                                "Taxa de sucesso pick-and-place >90% em 20 tentativas variadas.",
                                "Sistema opera em tempo real a 10 FPS mínimo.",
                                "Logs mostram ausência de erros críticos em operação contínua.",
                                "Demo gravada confirma montagem simulada aeronáutica completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão da detecção e localização (pontuação por erro métrico).",
                                "Robustez a variações (luz, ângulo, oclusão) em testes padronizados.",
                                "Eficiência temporal: latência e taxa de frames.",
                                "Qualidade do código: modularidade, comentários e versionamento.",
                                "Integração completa visão-robô sem falhas manuais.",
                                "Relatório técnico com métricas, análise e melhorias propostas."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python/ROS: algoritmos de visão e controle.",
                                "Matemática: transformações geométricas, álgebra linear para homografias.",
                                "Física/Mecânica: cinemática robótica e dinâmica de gripper.",
                                "Inteligência Artificial: modelos de detecção deep learning.",
                                "Engenharia Aeronáutica: simulação de montagem de componentes precisos."
                              ],
                              "realWorldApplication": "Em fábricas de aeronaves como Embraer ou Boeing, robôs com visão computacional realizam pick-and-place de milhares de parafusos e rebites diários em fuselagens, reduzindo erros humanos e acelerando produção em 30%."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Navegação e Evitação de Obstáculos",
                            "description": "Implementar visão para mapeamento básico e correção de trajetória em robôs móveis mecatrônicos, usando feedback visual em tempo real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do Hardware e Software de Visão Computacional",
                                  "subSteps": [
                                    "Selecionar e montar câmera compatível no robô móvel mecatrônico (ex: Raspberry Pi Camera ou USB Webcam).",
                                    "Instalar bibliotecas essenciais como OpenCV e ROS (Robot Operating System) no controlador do robô.",
                                    "Calibrar a câmera para corrigir distorções e definir parâmetros de imagem (resolução, FPS).",
                                    "Testar captura de vídeo em tempo real e integrar com o loop de controle do robô.",
                                    "Configurar transmissão de frames para processamento em tempo real."
                                  ],
                                  "verification": "Captura de vídeo estável em tempo real exibida no monitor, sem lags ou erros de calibração.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Câmera USB ou Pi Camera",
                                    "Raspberry Pi ou Arduino com shield",
                                    "OpenCV instalado",
                                    "Cabo USB/CSI",
                                    "Computador para testes"
                                  ],
                                  "tips": "Use iluminação uniforme para evitar falsos positivos na detecção inicial; teste em ambiente controlado.",
                                  "learningObjective": "Configurar sistema de visão integrado ao robô para captura confiável de dados visuais.",
                                  "commonMistakes": [
                                    "Ignorar calibração da câmera levando a distorções",
                                    "FPS muito alto causando sobrecarga no processador",
                                    "Conexões soltas na montagem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementação de Detecção Básica de Obstáculos",
                                  "subSteps": [
                                    "Processar frames para detecção de bordas usando filtros como Canny Edge Detection.",
                                    "Aplicar segmentação de imagem para identificar regiões de obstáculos (ex: thresholding HSV).",
                                    "Definir bounding boxes ou contornos ao redor de objetos detectados.",
                                    "Filtrar detecções falsas com base em tamanho, forma e distância mínima.",
                                    "Publicar coordenadas de obstáculos via tópicos ROS ou variáveis globais."
                                  ],
                                  "verification": "Obstáculos reais (caixas) são detectados e destacados em vídeo ao vivo com >80% de acurácia.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código OpenCV template",
                                    "Ambiente com obstáculos variados (caixas, garrafas)",
                                    "Monitor para debug visual"
                                  ],
                                  "tips": "Ajuste thresholds dinamicamente baseado na iluminação; use ROI (Region of Interest) para foco frontal.",
                                  "learningObjective": "Desenvolver algoritmo de visão para identificar e localizar obstáculos em tempo real.",
                                  "commonMistakes": [
                                    "Thresholds fixos falhando em diferentes luzes",
                                    "Detecção de sombras como obstáculos",
                                    "Processamento lento sem otimização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolvimento de Mapeamento Básico do Ambiente",
                                  "subSteps": [
                                    "Criar grade 2D ocupacional (occupancy grid) para representar o ambiente próximo.",
                                    "Atualizar mapa incrementalmente com posições de obstáculos detectados, usando odometria do robô.",
                                    "Integrar sensor de distância (ultrassom/lidar) para validar detecções visuais.",
                                    "Implementar fusão de dados (visão + odometria) para mapa consistente.",
                                    "Visualizar mapa em tempo real usando RViz ou Matplotlib."
                                  ],
                                  "verification": "Mapa 2D atualizado reflete corretamente posições de obstáculos móveis e fixos durante navegação.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "ROS Navigation Stack básico",
                                    "Sensores auxiliares (ultrassom)",
                                    "Software RViz para visualização"
                                  ],
                                  "tips": "Limite o tamanho da grade para performance; use probabilidades para células ocupadas.",
                                  "learningObjective": "Construir representação espacial básica do ambiente usando feedback visual.",
                                  "commonMistakes": [
                                    "Desalinhamento odométrico causando mapa distorcido",
                                    "Mapa muito grande consumindo memória",
                                    "Ignorar obstáculos móveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Correção de Trajetória com Feedback Visual",
                                  "subSteps": [
                                    "Calcular vetor de direção livre baseado no mapa (ex: espaço vazio à frente).",
                                    "Implementar controlador PID para ajuste de velocidade/motor baseado em desvios detectados.",
                                    "Gerar comandos de movimento: girar/evitar quando obstáculo < threshold de distância.",
                                    "Testar loop fechado: detecção → planejamento → execução → feedback.",
                                    "Adicionar histerese para evitar oscilações em borda de obstáculos."
                                  ],
                                  "verification": "Robô corrige trajetória automaticamente ao detectar obstáculo, mantendo distância mínima de 30cm.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Motores DC com encoders",
                                    "Código PID template",
                                    "Pista de teste com obstáculos"
                                  ],
                                  "tips": "Tune gains PID com Ziegler-Nichols; priorize segurança com velocidades baixas iniciais.",
                                  "learningObjective": "Integrar visão para controle reativo de navegação e evitação.",
                                  "commonMistakes": [
                                    "PID mal tunado causando overshoot",
                                    "Resposta lenta a obstáculos rápidos",
                                    "Loop sem taxa de amostragem fixa"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integração, Testes e Otimização",
                                  "subSteps": [
                                    "Executar simulação em Gazebo antes de hardware real.",
                                    "Realizar testes em cenários variados: obstáculos estáticos, móveis, baixa luz.",
                                    "Medir métricas: taxa de sucesso, tempo de evitação, falsos positivos.",
                                    "Otimizar código para latência <100ms (downsampling, paralelismo).",
                                    "Documentar pipeline completo e parâmetros otimizados."
                                  ],
                                  "verification": "Robô completa percurso com obstáculos sem colisões em 95% das tentativas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador Gazebo/ROS",
                                    "Espaço de teste físico",
                                    "Cronômetro e logs de performance"
                                  ],
                                  "tips": "Grave vídeos de falhas para análise; use profiling tools como cProfile.",
                                  "learningObjective": "Validar e refinar sistema completo de navegação visual.",
                                  "commonMistakes": [
                                    "Pular simulação levando a danos no hardware",
                                    "Testes só em condições ideais",
                                    "Ignorar latência acumulada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um robô móvel mecatrônico equipado com Raspberry Pi e câmera, implemente detecção de caixas em uma sala de 3x3m. O robô deve mapear obstáculos, corrigir trajetória para manter 50cm de distância e alcançar um alvo oposto sem colisões, processando 15 FPS.",
                              "finalVerifications": [
                                "Robô detecta e evita obstáculos em tempo real sem colisões físicas.",
                                "Mapa ocupacional atualiza corretamente com movimento do robô.",
                                "Trajetória corrigida mantém distância mínima configurada (>90% do tempo).",
                                "Sistema roda a <100ms de latência em hardware embarcado.",
                                "Sucesso em cenários variados: luz baixa, obstáculos móveis.",
                                "Logs mostram <5% falsos positivos em detecções."
                              ],
                              "assessmentCriteria": [
                                "Precisão de detecção de obstáculos (>85% recall/precision).",
                                "Latência total do pipeline (<200ms end-to-end).",
                                "Robustez em variações ambientais (iluminação, texturas).",
                                "Eficiência computacional (CPU <70% em Raspberry Pi).",
                                "Qualidade do mapa (erro posicional <10cm).",
                                "Taxa de sucesso em navegação completa (>90%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos de processamento de imagem em Python/C++.",
                                "Matemática: Geometria vetorial e transformações afins para mapeamento.",
                                "Física: Cinemática de robôs e controle PID.",
                                "Informática: Sistemas embarcados e ROS para integração.",
                                "Engenharia: Design mecatrônico de sensores e atuadores."
                              ],
                              "realWorldApplication": "Desenvolvimento de robôs aspiradores como Roomba, drones de inspeção industrial ou veículos autônomos para logística em armazéns, onde evitação de obstáculos via visão garante operação segura e eficiente em ambientes dinâmicos."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Qualidade e Inspeção Visual em Indústria",
                            "description": "Aplicar visão computacional para inspeção de defeitos em componentes aeronáuticos, integrando com times multifuncionais em projetos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos de Visão Computacional para Inspeção de Qualidade",
                                  "subSteps": [
                                    "Estude conceitos básicos de processamento de imagens: filtros, segmentação e detecção de bordas.",
                                    "Aprenda técnicas específicas para detecção de defeitos como rachaduras, deformações e inclusões em componentes aeronáuticos.",
                                    "Analise padrões de defeitos comuns em peças mecatrônicas aeronáuticas usando datasets públicos.",
                                    "Revise métricas de avaliação como precisão, recall e F1-score para inspeção visual.",
                                    "Explore bibliotecas como OpenCV e scikit-image para tarefas de visão."
                                  ],
                                  "verification": "Resuma os conceitos chave em um diagrama mental e teste com quiz de 10 perguntas sobre defeitos aeronáuticos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Documentação OpenCV, datasets Kaggle de defeitos industriais, Jupyter Notebook.",
                                  "tips": "Comece com imagens reais de componentes para contextualizar os conceitos.",
                                  "learningObjective": "Compreender os princípios de visão computacional aplicados à detecção de defeitos em peças aeronáuticas.",
                                  "commonMistakes": "Confundir ruído com defeitos reais sem pré-processamento adequado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração de Hardware e Aquisição de Imagens",
                                  "subSteps": [
                                    "Selecione e configure câmeras industriais (ex: USB3 ou GigE) compatíveis com ambientes mecatrônicos.",
                                    "Instale iluminação controlada para minimizar sombras e reflexos em superfícies metálicas.",
                                    "Configure software de captura de imagens em tempo real integrado a robôs.",
                                    "Colete um dataset inicial de 100+ imagens de componentes aeronáuticos saudáveis e defeituosos.",
                                    "Calibre a câmera usando padrões como xadrez para precisão métrica."
                                  ],
                                  "verification": "Capture 20 imagens de teste e verifique resolução e foco com métricas de nitidez.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Câmera industrial, tripé, fontes de luz LED, software como OpenCV ou Halcon.",
                                  "tips": "Use iluminação difusa para peças brilhantes como turbinas.",
                                  "learningObjective": "Configurar um sistema de aquisição de imagens otimizado para inspeção industrial.",
                                  "commonMistakes": "Ignorar calibração, levando a distorções em medições."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolvimento do Algoritmo de Detecção de Defeitos",
                                  "subSteps": [
                                    "Pré-processe imagens: aplique filtros Gaussianos e binarização adaptativa.",
                                    "Implemente detecção de defeitos usando thresholding, contornos e morfologia matemática.",
                                    "Treine um modelo simples de ML (ex: SVM ou CNN básica) com dataset rotulado.",
                                    "Defina thresholds para classificação de defeitos (crítico, menor, aceitável).",
                                    "Otimize para tempo real (<100ms por imagem) com paralelismo."
                                  ],
                                  "verification": "Teste o algoritmo em 50 imagens novas e atinja >90% de acurácia.",
                                  "estimatedTime": "8 horas",
                                  "materials": "Python, OpenCV, TensorFlow/Keras, dataset customizado.",
                                  "tips": "Use augmentação de dados (rotações, ruído) para robustez.",
                                  "learningObjective": "Criar um algoritmo funcional para inspeção automática de defeitos.",
                                  "commonMistakes": "Overfitting sem validação cruzada em variações de iluminação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração com Sistemas Mecatrônicos e Robótica",
                                  "subSteps": [
                                    "Integre o módulo de visão a um braço robótico via ROS (Robot Operating System).",
                                    "Desenvolva interface para acionamento: visão detecta defeito → robô para ou marca.",
                                    "Teste comunicação em rede com PLCs e sensores mecatrônicos.",
                                    "Implemente feedback loop: visão ajusta posição robótica dinamicamente.",
                                    "Documente APIs para integração futura."
                                  ],
                                  "verification": "Execute ciclo completo: aquisição → detecção → ação robótica em simulação e hardware.",
                                  "estimatedTime": "7 horas",
                                  "materials": "ROS, Arduino/PLC simulator, braço robótico ou simulador Gazebo.",
                                  "tips": "Use topics ROS para comunicação assíncrona e baixa latência.",
                                  "learningObjective": "Integrar visão computacional em fluxos mecatrônicos automatizados.",
                                  "commonMistakes": "Sincronização falha entre visão e movimento robótico."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação Multifuncional e Implantação",
                                  "subSteps": [
                                    "Apresente o sistema a times de qualidade, engenharia e produção para feedback.",
                                    "Realize testes de campo em linha de produção simulada com componentes reais.",
                                    "Colete métricas de desempenho e ajuste baseado em input multidisciplinar.",
                                    "Crie relatório de validação com ROI (redução de falsos positivos/negativos).",
                                    "Planeje escalabilidade para produção em massa."
                                  ],
                                  "verification": "Obtenha aprovação assinada de 3 membros do time multifuncional.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Componentes aeronáuticos reais, planilhas de métricas, ferramentas de apresentação.",
                                  "tips": "Use reuniões ágeis para iterações rápidas com stakeholders.",
                                  "learningObjective": "Colaborar em equipes multifuncionais para validar e implantar soluções de inspeção.",
                                  "commonMistakes": "Isolar o desenvolvimento sem input precoce de usuários finais."
                                }
                              ],
                              "practicalExample": "Inspecionar visualmente uma pala de turbina aeronáutica por microfissuras: câmera montada em braço robótico captura imagem durante rotação, algoritmo detecta rachadura >0.1mm, robô marca peça para quarentena, alertando time de qualidade via dashboard integrado.",
                              "finalVerifications": [
                                "Sistema detecta defeitos com >95% precisão em dataset de validação.",
                                "Integração robótica executa sem falhas em 100 ciclos consecutivos.",
                                "Relatório multifuncional aprovado com métricas de ROI positivo.",
                                "Tempo de inspeção <2s por componente.",
                                "Robustez testada em variações de iluminação e ângulos.",
                                "Documentação completa incluindo código fonte e manuais."
                              ],
                              "assessmentCriteria": [
                                "Precisão e recall do algoritmo (>90%).",
                                "Latência de processamento em tempo real.",
                                "Qualidade da integração mecatrônica (estabilidade e sincronia).",
                                "Eficácia da colaboração multifuncional (feedback incorporado).",
                                "Documentação e reprodutibilidade do sistema.",
                                "Adaptabilidade a novos tipos de defeitos."
                              ],
                              "crossCurricularConnections": [
                                "Inteligência Artificial: Treinamento de modelos de deep learning para detecção avançada.",
                                "Engenharia Aeronáutica: Normas AS9100 para qualidade em aviação.",
                                "Gestão de Projetos: Metodologias ágeis para integração multifuncional.",
                                "Eletrônica Industrial: Interfaces com PLCs e sensores IoT."
                              ],
                              "realWorldApplication": "Em fábricas como Embraer ou Boeing, sistemas de visão computacional inspecionam milhares de componentes diários, reduzindo recalls em 30% e acelerando produção, integrando com linhas robóticas para zero defeitos em montagem de aeronaves."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Microprocessadores, Microcontroladores e CLPs",
                "description": "Estudo de microprocessadores, microcontroladores e Controladores Lógicos Programáveis (CLPs) em sistemas mecatrônicos.",
                "totalSkills": 61,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Arquitetura de Microprocessadores",
                    "description": "Estudo da estrutura interna, barramentos, ciclo de instrução e evolução histórica dos microprocessadores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Estrutura Interna do Microprocessador",
                        "description": "Análise dos componentes principais que compõem o interior de um microprocessador, incluindo unidade lógica aritmética (ALU), unidade de controle e registradores.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Identificar componentes da ALU",
                            "description": "Descrever o funcionamento da Unidade Lógica Aritmética (ALU), responsável por operações aritméticas e lógicas, e listar seus principais elementos como somadores, multiplicadores e portas lógicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito e função da ALU",
                                  "subSteps": [
                                    "Pesquise a definição de ALU como Unidade Lógica Aritmética em microprocessadores.",
                                    "Identifique o papel principal: realizar operações aritméticas (soma, subtração) e lógicas (AND, OR, NOT).",
                                    "Analise o fluxo de dados: entradas A e B, sinal de controle, saída resultado e flags (zero, carry).",
                                    "Desenhe um diagrama de blocos simples da ALU destacando entradas e saídas.",
                                    "Compare ALU com unidades semelhantes em outros dispositivos como GPUs."
                                  ],
                                  "verification": "Crie um resumo de 100 palavras explicando a função da ALU e valide com uma fonte confiável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de ALU básico (impresso ou digital)",
                                    "Vídeo introdutório sobre arquitetura de CPU (YouTube ou Khan Academy)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'a ALU é o cérebro matemático do processador' para fixar o conceito.",
                                  "learningObjective": "Entender o propósito e o fluxo operacional da ALU no contexto de microprocessadores.",
                                  "commonMistakes": [
                                    "Confundir ALU com registradores ou unidade de controle",
                                    "Ignorar sinais de flags como carry ou overflow"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar portas lógicas como componentes fundamentais",
                                  "subSteps": [
                                    "Liste as portas básicas: AND, OR, NOT, XOR, NAND, NOR.",
                                    "Descreva a função de cada uma com tabelas-verdade simples.",
                                    "Explique como portas lógicas formam a base para operações bitwise na ALU.",
                                    "Monte circuitos lógicos simples usando simuladores online (ex: Logisim).",
                                    "Identifique onde essas portas são usadas na ALU para operações lógicas."
                                  ],
                                  "verification": "Construa e teste um circuito XOR em simulador e capture screenshot do funcionamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador lógico como Logisim ou Tinkercad",
                                    "Tabelas-verdade impressas",
                                    "Computador com acesso à internet"
                                  ],
                                  "tips": "Comece com portas simples como AND/OR antes de compostas para construir confiança.",
                                  "learningObjective": "Reconhecer portas lógicas e seu papel na seção lógica da ALU.",
                                  "commonMistakes": [
                                    "Memorizar tabelas sem entender a lógica booleana",
                                    "Confundir saída de XOR com OR"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar componentes aritméticos da ALU",
                                  "subSteps": [
                                    "Estude somadores: half-adder e full-adder, explicando carry-in e carry-out.",
                                    "Aprenda sobre multiplicadores básicos (shift-and-add) e divisores.",
                                    "Identifique outros: comparadores, shift registers e muxers (multiplexadores).",
                                    "Desenhe o circuito de um full-adder e simule-o.",
                                    "Relacione esses componentes ao seletor de operações da ALU."
                                  ],
                                  "verification": "Simule um somador de 4 bits e verifique soma de 5+3=8 com carry correto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulador Logisim ou Falstad Circuit Simulator",
                                    "Diagramas de somadores",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Visualize somadores como 'caixas pretas' com entradas/saídas antes de mergulhar nos gates internos.",
                                  "learningObjective": "Listar e descrever componentes aritméticos principais da ALU.",
                                  "commonMistakes": [
                                    "Esquecer o carry propagation em somadores múltiplos",
                                    "Confundir multiplicador com shifter"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar componentes e descrever o funcionamento completo",
                                  "subSteps": [
                                    "Liste todos os componentes principais: portas lógicas, somadores, multiplicadores, muxers, flags.",
                                    "Descreva o processo de uma operação: seleção via opcode, execução e armazenamento de flags.",
                                    "Crie um mapa mental conectando componentes à ALU inteira.",
                                    "Compare ALUs reais (ex: 6502 vs. modernas como ARM).",
                                    "Teste conhecimento respondendo perguntas sobre fluxos de operação."
                                  ],
                                  "verification": "Produza um diagrama completo da ALU rotulado com todos componentes e explique oralmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de mind mapping (MindMeister ou papel)",
                                    "Referências de ALUs históricas",
                                    "Gravador de áudio para autoexplicação"
                                  ],
                                  "tips": "Use cores diferentes no diagrama para diferenciar lógica vs. aritmética.",
                                  "learningObjective": "Sintetizar todos os componentes em uma visão holística da ALU.",
                                  "commonMistakes": [
                                    "Sobrecarregar com detalhes desnecessários",
                                    "Ignorar o papel do multiplexador na seleção de operações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um microcontrolador Arduino, a ALU interna soma valores de sensores (ex: temperatura + offset) para controle de motores, usando somadores para precisão e portas lógicas para condições if-then em assembly.",
                              "finalVerifications": [
                                "Liste corretamente pelo menos 8 componentes principais da ALU.",
                                "Desenhe e explique um diagrama funcional da ALU.",
                                "Simule uma operação aritmética e uma lógica em ferramenta digital.",
                                "Explique o papel das flags em uma operação de soma.",
                                "Compare ALU com uma calculadora simples.",
                                "Responda quiz com 90% de acerto sobre componentes e funções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (portas, somadores, etc.) - 30%",
                                "Compreensão do fluxo operacional da ALU - 25%",
                                "Capacidade de simular e verificar circuitos - 20%",
                                "Clareza em diagramas e explicações - 15%",
                                "Integração de conceitos lógicos e aritméticos - 10%"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Construção de circuitos com portas lógicas.",
                                "Programação: Operações bitwise em C/Assembly para otimização.",
                                "Física: Lógica booleana e propagação de sinais elétricos.",
                                "Matemática: Álgebra booleana e aritmética binária."
                              ],
                              "realWorldApplication": "Na indústria mecatrônica, a ALU de um PLC (ex: Siemens S7) executa cálculos em tempo real para controle de robôs, somando velocidades de motores e aplicando lógicas de segurança para evitar colisões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Explicar a Unidade de Controle",
                            "description": "Detalhar o papel da Unidade de Controle na geração de sinais de controle para coordenar a execução de instruções, incluindo decodificação de opcodes e gerenciamento de registradores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico da Unidade de Controle",
                                  "subSteps": [
                                    "Defina a Unidade de Controle (UC) como o 'cérebro diretor' do microprocessador.",
                                    "Identifique sua localização na estrutura interna: recebe instruções da memória e gera sinais para outras unidades.",
                                    "Diferencie UC da ALU (Unidade Lógica Aritmética), focando no papel de coordenação vs. processamento.",
                                    "Estude um diagrama simples da arquitetura von Neumann destacando a UC.",
                                    "Anote as entradas principais da UC: opcode da instrução e sinais de status (flags)."
                                  ],
                                  "verification": "Desenhe um diagrama rotulado da UC e explique verbalmente suas funções básicas para um colega.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama de arquitetura de microprocessador (impresso ou digital), livro de arquitetura de computadores (ex: Tanenbaum).",
                                  "tips": "Use analogias como 'maestro de orquestra' para visualizar a coordenação.",
                                  "learningObjective": "Entender o papel fundamental da UC na orquestração do processador.",
                                  "commonMistakes": "Confundir UC com a CPU inteira; lembre que UC é uma subunidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Geração de Sinais de Controle",
                                  "subSteps": [
                                    "Liste os tipos de sinais gerados: controle de registradores, ALU, memória e barramentos.",
                                    "Explique como a UC ativa sequencialmente essas unidades durante o ciclo de instrução.",
                                    "Simule com um exemplo: sinal 'Read' para memória ou 'Enable ALU'.",
                                    "Analise o microcódigo ou lógica combinacional usada para gerar esses sinais.",
                                    "Discuta variações: hardwired vs. microprogramada."
                                  ],
                                  "verification": "Crie uma tabela com 5 sinais de controle, sua função e quando são ativados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador de microprocessador (ex: Logisim), vídeo tutorial sobre ciclo de máquina.",
                                  "tips": "Pense em sinais como 'interruptores' que ligam/desligam partes do processador.",
                                  "learningObjective": "Dominar como a UC coordena hardware via sinais específicos.",
                                  "commonMistakes": "Ignorar dependência de flags de status; sempre verifique condições."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar a Decodificação de Opcodes",
                                  "subSteps": [
                                    "Explique o opcode como o 'código de operação' extraído da instrução.",
                                    "Descreva o decodificador: circuito que mapeia opcode binário para sinais de controle.",
                                    "Exemplo prático: opcode 0001 = ADD → ativa ALU para soma.",
                                    "Estude multiplexadores e decodificadores em diagramas lógicos.",
                                    "Discuta extensibilidade: como novos opcodes são adicionados em ISAs."
                                  ],
                                  "verification": "Decodifique 3 opcodes de exemplo e liste os sinais gerados para cada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabela de instruções de um microprocessador simples (ex: 8085), software de simulação lógica.",
                                  "tips": "Memorize opcodes comuns associando a ações reais, como ADD a soma diária.",
                                  "learningObjective": "Compreender o processo de interpretação de instruções pela UC.",
                                  "commonMistakes": "Confundir opcode com operando; opcode é só o comando."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Gerenciamento de Registradores e Coordenação Geral",
                                  "subSteps": [
                                    "Descreva como UC seleciona registradores via sinais de endereço (ex: MAR, MDR).",
                                    "Explique o fluxo: fetch → decode → execute, com UC no centro.",
                                    "Simule gerenciamento: carregar PC, incrementar, pular condicional.",
                                    "Integre com pipeline básico: como UC gerencia estágios.",
                                    "Avalie interrupções: UC pausa execução normal."
                                  ],
                                  "verification": "Desenhe o ciclo completo de uma instrução ADD, destacando ações da UC.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta de simulação como Tinkercad ou MARS (MIPS), notas de aula.",
                                  "tips": "Visualize o ciclo como uma linha de produção fabril coordenada pela UC.",
                                  "learningObjective": "Integrar todas as funções da UC no contexto do ciclo de instrução.",
                                  "commonMistakes": "Esquecer gerenciamento de PC; UC sempre atualiza contador de programa."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Aplicar Conhecimento",
                                  "subSteps": [
                                    "Resuma o fluxo completo: IR → UC → sinais → execução.",
                                    "Compare UC em microprocessadores reais (ex: 8086 vs. ARM).",
                                    "Crie um fluxograma da UC em ação.",
                                    "Discuta falhas: o que acontece se UC falhar (hang do sistema).",
                                    "Planeje uma mini-apresentação explicando UC."
                                  ],
                                  "verification": "Apresente uma explicação de 2 minutos gravada ou ao vivo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Papel/flipchart para fluxograma, gravador de vídeo.",
                                  "tips": "Pratique explicando para leigos para fixar conceitos.",
                                  "learningObjective": "Sintetizar o conhecimento para explicação fluida.",
                                  "commonMistakes": "Sobrecarregar detalhes; foque no essencial."
                                }
                              ],
                              "practicalExample": "Em um microcontrolador Arduino simulando uma instrução 'MOV R1, #5': UC decodifica opcode MOV, gera sinal para carregar imediato no registrador R1, ativa barramento de dados e verifica flags de overflow.",
                              "finalVerifications": [
                                "Explicar verbalmente o ciclo fetch-decode-execute com foco na UC.",
                                "Desenhar diagrama da UC com entradas/saídas corretas.",
                                "Listar 5 sinais de controle e suas funções.",
                                "Simular decodificação de 2 opcodes em papel.",
                                "Identificar papel da UC em um diagrama de microprocessador.",
                                "Diferenciar UC de outras unidades sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de funções da UC (90% correto).",
                                "Clareza na explicação de decodificação de opcode.",
                                "Correta identificação de sinais de controle gerados.",
                                "Uso de exemplos práticos relevantes.",
                                "Compreensão de coordenação com registradores e ciclo de instrução.",
                                "Capacidade de diagramação lógica sem falhas."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Circuitos combinacionais para decodificadores.",
                                "Programação: Entender assembly e como opcodes viram código máquina.",
                                "Sistemas Embarcados: UC em microcontroladores como PIC ou AVR.",
                                "Engenharia de Software: Similaridades com controladores de fluxo em linguagens.",
                                "Física: Sinais como pulsos elétricos em portas lógicas."
                              ],
                              "realWorldApplication": "Na indústria automotiva, a UC de um ECU (Electronic Control Unit) em um carro coordena injeção de combustível lendo sensores, decodificando instruções e gerenciando atuadores em tempo real, evitando falhas críticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Descrever registradores internos",
                            "description": "Listar e explicar tipos de registradores como acumulador, contador de programa (PC), registrador de instrução (IR) e sua importância no armazenamento temporário de dados durante o processamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito geral de registradores internos",
                                  "subSteps": [
                                    "Defina o que é um registrador: memória de alta velocidade dentro da CPU para armazenamento temporário.",
                                    "Diferencie registradores de memória principal (RAM): velocidade, tamanho e localização.",
                                    "Identifique funções principais: armazenar operandos, resultados e endereços durante execução de instruções.",
                                    "Revise o papel no ciclo de fetch-decode-execute.",
                                    "Anote exemplos iniciais de registradores em arquiteturas simples como 8085."
                                  ],
                                  "verification": "Escreva uma definição clara de registrador e liste 3 funções principais em um parágrafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de arquitetura de microprocessador (impresso ou digital)",
                                    "Livro-texto sobre microprocessadores (capítulo de estrutura interna)"
                                  ],
                                  "tips": "Use analogias como 'caixas rápidas na mesa de trabalho da CPU' para fixar o conceito.",
                                  "learningObjective": "Entender o registrador como componente essencial para processamento eficiente de dados.",
                                  "commonMistakes": [
                                    "Confundir registradores com cache ou RAM",
                                    "Ignorar a limitação de tamanho (geralmente 8-64 bits)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o registrador acumulador (AC)",
                                  "subSteps": [
                                    "Explique o acumulador como registrador principal para operações aritméticas e lógicas.",
                                    "Liste operações típicas: ADD, SUB, MUL, AND, OR.",
                                    "Descreva como dados são carregados (LDA) e armazenados (STA) no acumulador.",
                                    "Analise um exemplo: soma de dois números usando AC.",
                                    "Registre a importância: centraliza resultados intermediários."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o fluxo de uma operação ADD usando o acumulador.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de microprocessador online (ex: 8085 simulator)",
                                    "Folha para diagramas manuais"
                                  ],
                                  "tips": "Sempre pense no acumulador como o 'coração' das operações ALU.",
                                  "learningObjective": "Dominar o papel do acumulador nas operações de processamento de dados.",
                                  "commonMistakes": [
                                    "Achar que AC armazena apenas resultados finais",
                                    "Esquecer flags de status associadas (zero, carry)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever contador de programa (PC) e registrador de instrução (IR)",
                                  "subSteps": [
                                    "Defina PC: armazena endereço da próxima instrução a ser executada.",
                                    "Explique IR: armazena a instrução fetchada da memória para decodificação.",
                                    "Descreva o ciclo: PC → fetch IR → incrementar PC.",
                                    "Compare funções: PC gerencia sequência, IR gerencia conteúdo.",
                                    "Simule um ciclo de instrução com incrementação de PC."
                                  ],
                                  "verification": "Desenhe um diagrama do ciclo fetch-decode mostrando PC e IR.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Vídeo tutorial sobre ciclo de instrução (YouTube ou Khan Academy)",
                                    "Papel e caneta para fluxogramas"
                                  ],
                                  "tips": "Visualize PC como um 'ponteiro de livro' que avança página por página.",
                                  "learningObjective": "Compreender como PC e IR controlam o fluxo de execução de programas.",
                                  "commonMistakes": [
                                    "Confundir PC com endereço de dados",
                                    "Pensar que IR armazena dados, não instruções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar importância e interações dos registradores",
                                  "subSteps": [
                                    "Explique interdependência: AC para dados, PC/IR para controle.",
                                    "Discuta vantagens: velocidade (ns vs µs da RAM), redução de acessos à memória.",
                                    "Relacione com pipeline moderno e registradores bank.",
                                    "Crie uma tabela comparativa: tipo, função, tamanho típico.",
                                    "Reflita sobre falhas: overflow em AC ou loop infinito por PC errado."
                                  ],
                                  "verification": "Elabore um resumo de 1 página listando registradores, funções e importância coletiva.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela modelo em Excel ou papel",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Conecte tudo ao ciclo de instrução para visão holística.",
                                  "learningObjective": "Integrar conhecimentos para explicar o ecossistema de registradores na CPU.",
                                  "commonMistakes": [
                                    "Subestimar impacto na performance geral",
                                    "Isolar registradores sem contexto de ciclo"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando um simulador de 8085, carregue instruções LDA 2050 (carrega dado no AC), MVI A,05 (move para AC), ADD B (soma com AC). Observe PC incrementando e IR capturando opcodes, rotulando mudanças em um diagrama passo a passo.",
                              "finalVerifications": [
                                "Lista corretamente acumulador, PC e IR com funções precisas.",
                                "Explica ciclo de fetch envolvendo PC e IR.",
                                "Descreve uso do AC em pelo menos duas operações aritméticas.",
                                "Identifica importância no armazenamento temporário e performance.",
                                "Desenha diagrama simples da interação entre registradores.",
                                "Diferencia registradores de outros componentes de memória."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas definições e funções (80% correto).",
                                "Clareza e organização na explicação escrita ou verbal.",
                                "Uso de exemplos concretos e diagramas.",
                                "Compreensão de interações e ciclo de instrução.",
                                "Identificação de erros comuns e prevenções.",
                                "Profundidade na importância para processamento."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Implementação com flip-flops e portas lógicas.",
                                "Programação em Assembly: Instruções diretas para manipular registradores.",
                                "Física: Tempos de propagação de sinais em circuitos integrados.",
                                "Engenharia de Software: Otimização de código para uso eficiente de registradores."
                              ],
                              "realWorldApplication": "Em microcontroladores como PIC ou AVR em sistemas mecatrônicos (robôs industriais), registradores como AC processam sensores em tempo real, PC/IR executam loops de controle PID, otimizando eficiência energética e resposta rápida em automação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Barramentos em Microprocessadores",
                        "description": "Estudo dos barramentos de dados, endereço e controle, que interligam os componentes internos e externos do microprocessador.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Classificar tipos de barramentos",
                            "description": "Diferenciar barramento de dados (bidirecional para transferência de informações), barramento de endereços (unidirecional para seleção de memória) e barramento de controle (sinais como read/write).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos fundamentais de barramentos em microprocessadores",
                                  "subSteps": [
                                    "Defina o que é um barramento em arquitetura de computadores.",
                                    "Identifique as funções principais dos barramentos: transferência de dados, endereçamento e controle.",
                                    "Diferencie barramentos paralelos de seriais no contexto de microprocessadores.",
                                    "Analise um diagrama genérico de barramentos conectando CPU, memória e periféricos.",
                                    "Liste as vantagens de usar barramentos dedicados em sistemas mecatrônicos."
                                  ],
                                  "verification": "Crie um mapa mental resumindo os conceitos fundamentais e suas funções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama de barramentos de microprocessador (impresso ou digital)",
                                    "Livro-texto de arquitetura de computadores",
                                    "Acesso a simulador online como Logisim"
                                  ],
                                  "tips": "Comece visualizando diagramas reais para fixar as conexões físicas.",
                                  "learningObjective": "Compreender o papel geral dos barramentos como canais de comunicação na arquitetura de microprocessadores.",
                                  "commonMistakes": "Confundir barramento com sinal individual; lembrar que é um conjunto de linhas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o barramento de dados",
                                  "subSteps": [
                                    "Descreva o barramento de dados como bidirecional para transferência de informações entre CPU e memória/periféricos.",
                                    "Explique como dados são enviados e recebidos simultaneamente em ambos os sentidos.",
                                    "Calcule a largura típica (ex: 8, 16 ou 32 bits) e seu impacto na taxa de transferência.",
                                    "Identifique pinos relacionados em um microprocessador exemplo (ex: Intel 8085).",
                                    "Simule uma transferência de dados usando um diagrama de timing."
                                  ],
                                  "verification": "Desenhe um fluxograma mostrando uma operação de leitura e escrita no barramento de dados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de pinout de microprocessador 8085",
                                    "Software de simulação como Tinkercad ou Multisim",
                                    "Vídeos tutoriais sobre barramento de dados"
                                  ],
                                  "tips": "Use setas duplas para representar bidirecionalidade em diagramas.",
                                  "learningObjective": "Diferenciar as características únicas do barramento de dados, enfatizando sua bidirecionalidade.",
                                  "commonMistakes": "Achar que é unidirecional; sempre verificar direção em exemplos reais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o barramento de endereços",
                                  "subSteps": [
                                    "Defina o barramento de endereços como unidirecional, saindo da CPU para selecionar locais de memória ou I/O.",
                                    "Explique como endereços binários são codificados para acessar bytes específicos.",
                                    "Discuta decodificação de endereços em chips de memória (ex: RAM, ROM).",
                                    "Compare larguras de endereços com espaço de memória endereçável (ex: 20 bits para 1MB).",
                                    "Simule seleção de endereço em um circuito simples."
                                  ],
                                  "verification": "Liste 5 endereços exemplo e indique qual memória eles selecionariam em um sistema de 64KB.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Tabela de endereçamento de microcontrolador PIC ou AVR",
                                    "Osciloscópio virtual ou Logic Analyzer software",
                                    "Diagramas de decodificador de endereços"
                                  ],
                                  "tips": "Converta números decimais para binários para visualizar o barramento.",
                                  "learningObjective": "Reconhecer o barramento de endereços como seletor unidirecional de recursos.",
                                  "commonMistakes": "Confundir com barramento de dados; endereços só saem da CPU."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o barramento de controle e realizar classificação",
                                  "subSteps": [
                                    "Descreva o barramento de controle como conjunto de sinais unidirecionais (ex: RD, WR, ALE).",
                                    "Explique funções de sinais como Read (ler memória), Write (escrever) e outros controles.",
                                    "Compare os três barramentos em uma tabela: direção, função, exemplos de sinais.",
                                    "Classifique exemplos de operações misturando os barramentos.",
                                    "Crie um quiz autoavaliativo para diferenciar os tipos."
                                  ],
                                  "verification": "Preencha uma tabela comparativa dos três barramentos com pelo menos 3 características cada.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Tabela comparativa em branco",
                                    "Datasheet de microprocessador 8086",
                                    "Ferramentas de diagramação como Draw.io"
                                  ],
                                  "tips": "Use cores diferentes para cada barramento em diagramas para facilitar memorização.",
                                  "learningObjective": "Classificar corretamente os barramentos de dados, endereços e controle com base em suas características.",
                                  "commonMistakes": "Misturar controle com dados; controle é apenas sinais de comando."
                                }
                              ],
                              "practicalExample": "Em um sistema mecatrônico com microcontrolador Arduino Uno, o barramento de endereços seleciona o registrador de um sensor (ex: endereço 0x20), o de dados transfere o valor lido (bidirecional), e o de controle ativa o sinal RD para leitura, permitindo monitorar temperatura em tempo real.",
                              "finalVerifications": [
                                "Classifique corretamente 5 exemplos de linhas de barramento como dados, endereço ou controle.",
                                "Desenhe um diagrama completo de barramentos conectando CPU a RAM e I/O.",
                                "Explique verbalmente a sequência de uma operação de escrita em memória.",
                                "Simule uma falha em um barramento e diagnostique o tipo afetado.",
                                "Compare barramentos em dois microprocessadores diferentes (ex: 8085 vs ARM)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições: bidirecional para dados, unidirecional para endereços e controle (30%)",
                                "Uso correto de exemplos e diagramas com sinais específicos (25%)",
                                "Capacidade de classificação em cenários mistos (20%)",
                                "Análise de impactos em performance do sistema (15%)",
                                "Clareza na tabela comparativa e verificações finais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Decodificadores e multiplexadores para barramentos.",
                                "Programação Embarcada: Acesso a registradores via Assembly (LDR/STR).",
                                "Física: Sinais elétricos e temporização em linhas paralelas.",
                                "Projeto Mecatrônico: Integração em PLCs para automação industrial."
                              ],
                              "realWorldApplication": "Nos PLCs industriais da Siemens S7, barramentos classificados otimizam comunicação entre CPU e módulos I/O, reduzindo latência em linhas de produção mecatrônicas como robôs soldadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Analisar largura e velocidade dos barramentos",
                            "description": "Explicar como a largura em bits (ex: 8, 16, 32 bits) afeta a capacidade de transferência de dados e como o clock influencia a velocidade de comunicação entre componentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de barramento e largura em bits",
                                  "subSteps": [
                                    "Defina o que é um barramento em microprocessadores: conjunto de linhas para transferência de dados, endereço e controle.",
                                    "Explique largura em bits: número de linhas de dados paralelas (ex: 8 bits = 1 byte por ciclo).",
                                    "Identifique exemplos comuns: 8 bits (antigos), 16 bits, 32 bits, 64 bits em arquiteturas modernas.",
                                    "Diferencie barramentos de dados, endereço e controle.",
                                    "Visualize diagrama de um barramento de 32 bits transferindo dados em paralelo."
                                  ],
                                  "verification": "Desenhe um diagrama simples de barramento de 16 bits e explique sua largura corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de barramento impresso ou digital",
                                    "Caneta e papel"
                                  ],
                                  "tips": "Pense na largura como 'pistas de rodovia': mais pistas permitem mais dados simultâneos.",
                                  "learningObjective": "Entender que a largura determina a quantidade de dados transferidos por ciclo de clock.",
                                  "commonMistakes": [
                                    "Confundir largura de dados com linhas de endereço",
                                    "Achar que mais bits significa sempre mais velocidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o impacto da largura na capacidade de transferência de dados",
                                  "subSteps": [
                                    "Calcule dados por ciclo: largura em bits / 8 = bytes por ciclo (ex: 32 bits = 4 bytes).",
                                    "Discuta bandwidth: largura × frequência de clock = taxa de transferência teórica.",
                                    "Compare exemplos: barramento 8 bits vs 32 bits no mesmo clock (32 bits transfere 4x mais dados).",
                                    "Considere overhead: nem todo ciclo é usado para dados puros.",
                                    "Resolva exercício: quanto dados em 1 ciclo para 64 bits?"
                                  ],
                                  "verification": "Resolva 3 cálculos de capacidade e acerte todos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de unidades (bits, bytes, Mbps)"
                                  ],
                                  "tips": "Use fórmula: Throughput (bytes/s) = (largura_bits × clock_Hz) / 8.",
                                  "learningObjective": "Calcular e explicar como largura aumenta a capacidade sem alterar clock.",
                                  "commonMistakes": [
                                    "Esquecer divisão por 8 para converter bits em bytes",
                                    "Ignorar que largura afeta apenas volume por ciclo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender o papel do clock na velocidade de comunicação",
                                  "subSteps": [
                                    "Defina clock: sinal periódico que sincroniza transferências (ex: 100 MHz = 100 milhões de ciclos/s).",
                                    "Explique taxa de transferência: largura × clock rate.",
                                    "Discuta limitações: clock alto aumenta velocidade mas pode causar interferência ou consumo de energia.",
                                    "Compare clocks: 50 MHz vs 200 MHz em barramento de 16 bits.",
                                    "Calcule exemplo: 16 bits a 100 MHz = ? bytes/s."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como clock dobra a velocidade mantendo largura fixa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Cronograma de clock digital ou simulador online",
                                    "Calculadora"
                                  ],
                                  "tips": "Clock é como 'batidas por minuto': mais batidas = mais transferências por segundo.",
                                  "learningObjective": "Relacionar frequência do clock diretamente à velocidade de comunicação.",
                                  "commonMistakes": [
                                    "Confundir clock com largura",
                                    "Achar que clock alto sempre é melhor sem trade-offs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e comparar largura e velocidade em cenários reais",
                                  "subSteps": [
                                    "Compare barramentos: 32 bits@50 MHz vs 16 bits@100 MHz (calcule qual é mais rápido).",
                                    "Avalie trade-offs: largura maior = mais pinos/custo; clock maior = mais calor/EMI.",
                                    "Simule falha: reduza largura ou clock e veja impacto no throughput.",
                                    "Aplique em microprocessador: ex. AVR 8 bits@16 MHz vs ARM 32 bits@1 GHz.",
                                    "Conclua análise: otimize para aplicação específica."
                                  ],
                                  "verification": "Crie tabela comparativa de 3 barramentos e identifique o melhor para uma tarefa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para tabela",
                                    "Especificações de microcontroladores"
                                  ],
                                  "tips": "Sempre calcule throughput efetivo: largura × clock / 8 / 1e6 para MB/s.",
                                  "learningObjective": "Integrar largura e clock para analisar performance global de barramentos.",
                                  "commonMistakes": [
                                    "Não considerar unidades (MHz vs GHz)",
                                    "Ignorar limitações físicas como capacitância"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de mecatrônica, compare um microcontrolador PIC 16 bits@20 MHz (throughput ~5 MB/s) com ESP32 32 bits@240 MHz (~960 MB/s) para transferência de dados de sensores. Calcule e justifique qual usar para vídeo em tempo real.",
                              "finalVerifications": [
                                "Calcular corretamente throughput para 3 exemplos dados.",
                                "Explicar impacto de dobrar largura vs dobrar clock.",
                                "Identificar trade-offs em cenários reais.",
                                "Criar diagrama explicando transferência em barramento.",
                                "Comparar barramentos históricos vs modernos.",
                                "Resolver problema: 'Qual barramento transfere 1 MB em menos tempo?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de taxa de transferência (100% correto).",
                                "Clareza na explicação de conceitos (sem confusões entre largura e clock).",
                                "Uso correto de unidades (bits/bytes, Hz/MHz).",
                                "Identificação de pelo menos 2 trade-offs por análise.",
                                "Aplicação prática em exemplos mecatrônicos.",
                                "Completude da tabela comparativa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos de multiplicação, conversão de unidades e taxas.",
                                "Física: Propagação de sinais elétricos e interferência em linhas paralelas.",
                                "Informática: Arquitetura de computadores e programação de periféricos.",
                                "Engenharia Elétrica: Design de PCBs para barramentos de alta velocidade."
                              ],
                              "realWorldApplication": "No design de sistemas embarcados como robôs mecatrônicos, analisar barramentos otimiza comunicação entre CPU e sensores/atuadores, reduzindo latência em controles em tempo real, como em drones ou linhas de produção industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Identificar arquiteturas de barramento",
                            "description": "Comparar arquiteturas como Von Neumann (barramento compartilhado) e Harvard (barramentos separados para instruções e dados), destacando vantagens em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Arquitetura Von Neumann",
                                  "subSteps": [
                                    "Estude o conceito básico: barramento único compartilhado para instruções e dados.",
                                    "Analise o fluxo de dados: CPU acessa memória via um barramento comum.",
                                    "Identifique componentes principais: CPU, memória unificada, dispositivos de E/S.",
                                    "Desenhe um diagrama simples da arquitetura.",
                                    "Revise gargalos potenciais devido ao compartilhamento."
                                  ],
                                  "verification": "Desenhar e rotular corretamente um diagrama da Von Neumann sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou software de diagramação como Draw.io; vídeo tutorial sobre Von Neumann.",
                                  "tips": "Use setas para mostrar o fluxo bidirecional no barramento compartilhado.",
                                  "learningObjective": "Explicar os princípios fundamentais da arquitetura Von Neumann e seu barramento compartilhado.",
                                  "commonMistakes": "Confundir com Harvard achando que há barramentos separados; ignorar o gargalo de von Neumann."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Arquitetura Harvard",
                                  "subSteps": [
                                    "Estude o conceito: barramentos separados para instruções (IM) e dados (DM).",
                                    "Analise o fluxo paralelo: CPU busca instruções e dados simultaneamente.",
                                    "Identifique componentes: CPU, memória de instruções, memória de dados, E/S.",
                                    "Desenhe um diagrama destacando os dois barramentos.",
                                    "Revise vantagens em velocidade de execução."
                                  ],
                                  "verification": "Desenhar diagrama da Harvard mostrando barramentos distintos e explicar paralelismo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou Draw.io; exemplos de microcontroladores como PIC.",
                                  "tips": "Destaque cores diferentes para barramentos de instruções e dados nos diagramas.",
                                  "learningObjective": "Descrever a arquitetura Harvard e as diferenças em barramentos em relação à Von Neumann.",
                                  "commonMistakes": "Achar que Harvard usa memória unificada; subestimar complexidade de hardware."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar as Duas Arquiteturas",
                                  "subSteps": [
                                    "Liste vantagens da Von Neumann: simplicidade, menor custo, flexibilidade de memória.",
                                    "Liste desvantagens: gargalo no barramento compartilhado, menor velocidade.",
                                    "Liste vantagens da Harvard: execução paralela, maior velocidade, melhor para DSP.",
                                    "Liste desvantagens: maior complexidade, custo mais alto, memória fixa.",
                                    "Crie uma tabela comparativa com colunas para cada arquitetura."
                                  ],
                                  "verification": "Preencher tabela comparativa com pelo menos 4 prós e contras por arquitetura.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou papel para tabela; artigos comparativos online.",
                                  "tips": "Use exemplos numéricos, como taxa de clock, para ilustrar diferenças de performance.",
                                  "learningObjective": "Comparar objetivamente Von Neumann e Harvard, focando em barramentos.",
                                  "commonMistakes": "Ignorar contexto de aplicação; generalizar sem evidências."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Sistemas Mecatrônicos",
                                  "subSteps": [
                                    "Identifique usos em mecatrônica: Von Neumann em PCs industriais; Harvard em microcontroladores como AVR.",
                                    "Analise vantagens: Harvard em controle real-time (ex: robótica).",
                                    "Pesquise exemplos: Arduino (modificado Harvard), PLCs Von Neumann.",
                                    "Discuta trade-offs em projetos mecatrônicos: custo vs. performance.",
                                    "Crie um fluxograma de decisão para escolher arquitetura."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que Harvard é preferida em atuadores rápidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Datasheets de microcontroladores (ex: ATmega); vídeos de mecatrônica.",
                                  "tips": "Relacione com ciclos de controle em loops fechados.",
                                  "learningObjective": "Destacar vantagens de cada arquitetura em contextos mecatrônicos.",
                                  "commonMistakes": "Aplicar fora de contexto, como usar Harvard em aplicações de baixo custo."
                                }
                              ],
                              "practicalExample": "Em um projeto de braço robótico mecatrônico, use arquitetura Harvard (como em ESP32) para processar instruções de controle motor simultaneamente com leitura de sensores de dados, evitando gargalos da Von Neumann e garantindo resposta em tempo real.",
                              "finalVerifications": [
                                "Desenhar diagramas precisos de ambas arquiteturas.",
                                "Preencher tabela comparativa com vantagens/desvantagens corretas.",
                                "Explicar gargalo de Von Neumann com exemplo numérico.",
                                "Identificar 3 aplicações mecatrônicas por arquitetura.",
                                "Criar fluxograma de escolha baseado em requisitos.",
                                "Quiz: Diferenciar barramentos em 5 perguntas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos diagramas e descrições de barramentos (30%).",
                                "Profundidade na comparação de vantagens/desvantagens (25%).",
                                "Relevância ao contexto mecatrônico (20%).",
                                "Qualidade da tabela e fluxograma (15%).",
                                "Clareza na explicação oral/escrita (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Design de barramentos físicos (sinais, timing).",
                                "Programação: Assembly para acessar memórias separadas.",
                                "Física: Análise de sinais em barramentos (ruído, capacitância).",
                                "Engenharia de Controle: Tempo real em loops de feedback."
                              ],
                              "realWorldApplication": "Em PLCs industriais (Von Neumann para flexibilidade em programação ladder) vs. microcontroladores em drones mecatrônicos (Harvard para processamento paralelo de comandos e telemetria, melhorando estabilidade e resposta rápida)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Ciclo de Instrução",
                        "description": "Descrição das fases sequenciais de busca, decodificação, execução e escrita de resultados em uma instrução de máquina.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Descrever fase de busca (Fetch)",
                            "description": "Explicar o processo de busca da instrução na memória usando o contador de programa (PC), barramento de endereços e registrador de instrução (IR).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o papel do Program Counter (PC)",
                                  "subSteps": [
                                    "Identifique o PC como registrador que armazena o endereço da próxima instrução a ser executada.",
                                    "Explique que o PC é inicializado com o endereço de início do programa.",
                                    "Descreva como o PC aponta para a memória onde as instruções estão armazenadas.",
                                    "Discuta o tamanho típico do PC (ex: 16 ou 32 bits) e seu impacto no espaço de endereçamento.",
                                    "Visualize o PC em um diagrama simples de arquitetura de Von Neumann."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando o PC conectado ao barramento de endereços e confirme verbalmente sua função.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama de arquitetura de microprocessador impresso ou software de simulação como Logisim.",
                                  "tips": "Lembre-se: PC é como um 'ponteiro de livro' que indica a página atual do código.",
                                  "learningObjective": "Compreender o PC como origem do endereço da instrução.",
                                  "commonMistakes": "Confundir PC com IR; PC guarda endereço, não a instrução."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Envio do endereço via barramento de endereços",
                                  "subSteps": [
                                    "Coloque o conteúdo do PC no barramento de endereços.",
                                    "Ative o sinal de leitura (READ) no barramento de controle.",
                                    "Aguarde o tempo de acesso à memória (latência típica de 1-2 ciclos de clock).",
                                    "Confirme que o barramento de endereços transmite o endereço para o chip de memória (RAM/ROM).",
                                    "Monitore sinais de controle como chip select (CS) e output enable (OE)."
                                  ],
                                  "verification": "Simule em software o envio do endereço e verifique se a memória responde corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Simulador de microprocessador (ex: MARS para MIPS ou Tinkercad para 8085).",
                                  "tips": "Pense no barramento como uma 'estrada' que leva o endereço até a memória.",
                                  "learningObjective": "Dominar a transmissão do endereço do PC para a memória.",
                                  "commonMistakes": "Ignorar sinais de controle; sem READ, a memória não libera dados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Leitura da instrução e armazenamento no Instruction Register (IR)",
                                  "subSteps": [
                                    "A memória coloca a instrução no barramento de dados quando recebe o endereço.",
                                    "Transfira os dados do barramento de dados para o IR via sinal de load.",
                                    "Decode inicial: IR armazena a opcode e operandos para uso posterior.",
                                    "Verifique integridade dos dados (paridade ou ECC em sistemas avançados).",
                                    "Confirme que o IR agora contém a instrução completa (ex: 32 bits)."
                                  ],
                                  "verification": "Registre o valor lido na memória e compare com o esperado no IR.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesma simulação do step anterior; osciloscópio virtual para barramentos.",
                                  "tips": "IR é o 'cofre' temporário da instrução antes da decodificação.",
                                  "learningObjective": "Entender o fluxo de dados da memória para o IR.",
                                  "commonMistakes": "Confundir barramento de dados com endereços; dados vêm do barramento de dados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incremento do PC para a próxima instrução",
                                  "subSteps": [
                                    "Adicione o tamanho da instrução atual ao PC (ex: +4 bytes para 32-bit).",
                                    "Execute a operação PC = PC + instruction_length usando ALU auxiliar.",
                                    "Atualize o PC no final do ciclo de fetch para preparar o próximo fetch.",
                                    "Considere branches/jumps que modificam o PC de forma não sequencial.",
                                    "Teste em loop: execute múltiplos fetches sequenciais."
                                  ],
                                  "verification": "Após fetch, verifique se PC avançou corretamente para o próximo endereço.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Simulador com trace de registradores; papel e lápis para cálculo manual.",
                                  "tips": "Sempre incremente PC no fetch para pipelines lineares.",
                                  "learningObjective": "Compreender a preparação sequencial para o próximo ciclo.",
                                  "commonMistakes": "Esquecer incremento; leva a loops infinitos no mesmo endereço."
                                }
                              ],
                              "practicalExample": "Em um microprocessador 8085, PC=1000h contém instrução MOV A,B (opcode 78h na memória[1000h]). PC envia 1000h pelo barramento de endereços, memória retorna 78h pelo barramento de dados para IR, então PC incrementa para 1001h.",
                              "finalVerifications": [
                                "Descreva verbalmente o fluxo completo: PC → Barramento Endereços → Memória → Barramento Dados → IR → PC++.",
                                "Simule um fetch completo em software e capture screenshots dos registradores.",
                                "Desenhe um timing diagram mostrando sinais RD, ALE e clocks.",
                                "Explique o que acontece se o PC não for incrementado.",
                                "Compare fetch em arquiteturas CISC (8086) vs RISC (ARM).",
                                "Identifique componentes envolvidos em um diagrama rotulado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do papel de PC, barramento e IR (90% correto).",
                                "Capacidade de simular e debugar um ciclo de fetch (sem erros).",
                                "Uso correto de terminologia técnica (ex: READ, latência).",
                                "Diagrama claro e completo do fluxo de fetch.",
                                "Explicação de erros comuns e prevenções.",
                                "Integração com ciclo completo de instrução (fetch-decode-execute)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Sinais de barramento e temporização.",
                                "Programação: Assembly e endereçamento de memória.",
                                "Física: Propagação de sinais e clocks síncronos.",
                                "Engenharia de Software: Pipelines e prefetching em CPUs modernas."
                              ],
                              "realWorldApplication": "Na execução de programas em smartphones ou PLCs industriais, o fetch garante que instruções sejam carregadas sequencialmente da memória flash/RAM, essencial para controle em tempo real em robótica mecatrônica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Explicar fase de decodificação (Decode)",
                            "description": "Detalhar como a unidade de controle interpreta o opcode e operandos da instrução para gerar sinais de controle apropriados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e Propósito da Fase de Decodificação",
                                  "subSteps": [
                                    "Defina a fase de decodificação como o segundo estágio do ciclo de instrução fetch-decode-execute.",
                                    "Explique que nesta fase a instrução fetchada é analisada pela unidade de controle.",
                                    "Identifique o objetivo principal: interpretar opcode e operandos para preparar execução.",
                                    "Diferencie decode de fetch (busca) e execute (execução).",
                                    "Descreva o formato típico de uma instrução: opcode + operandos."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o propósito da fase decode e recite sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama do ciclo de instrução de microprocessador (ex: 8085), vídeo introdutório sobre pipeline CPU.",
                                  "tips": "Use analogia: decode é como ler uma receita (opcode) e ingredientes (operandos) antes de cozinhar.",
                                  "learningObjective": "Entender o papel da fase decode no fluxo geral do ciclo de instrução.",
                                  "commonMistakes": "Confundir decode com fetch (busca física da memória)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Estrutura da Instrução: Opcode e Operandos",
                                  "subSteps": [
                                    "Identifique o opcode como os bits iniciais que definem a operação (ex: ADD = 1000).",
                                    "Classifique operandos: imediato, direto, indireto ou registrador.",
                                    "Extraia campos da instrução usando máscara de bits ou decodificador de hardware.",
                                    "Estude tabela de opcodes de um microprocessador específico (ex: Intel 8085).",
                                    "Pratique dividindo instruções binárias em opcode e operandos."
                                  ],
                                  "verification": "Divida corretamente 3 instruções binárias exemplo em opcode/operandos em um papel.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de opcodes 8085, simulador online como Tinkercad ou Logisim.",
                                  "tips": "Comece com instruções simples de 8 bits para visualizar campos claramente.",
                                  "learningObjective": "Dominar a identificação e extração de opcode e operandos de uma instrução.",
                                  "commonMistakes": "Ignorar modo de endereçamento, confundindo operandos com dados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Opcode e Gerar Sinais de Controle Preliminares",
                                  "subSteps": [
                                    "Descreva como o decodificador de opcode mapeia binário para tipo de instrução (aritmética, lógica, etc.).",
                                    "Explique geração de sinais micro-operações (ex: ALuOp=1 para soma).",
                                    "Trace o caminho: registrador de instrução (IR) → decodificador → lógica de controle.",
                                    "Liste sinais comuns: Read/Write memória, enable registradores, select MUX.",
                                    "Simule interpretação para uma instrução específica."
                                  ],
                                  "verification": "Liste 5 sinais de controle gerados para instrução 'MOV A,B' e justifique.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Diagrama de unidade de controle hardwired, software de simulação como MARS para MIPS.",
                                  "tips": "Desenhe fluxograma do decodificador para visualizar ativações.",
                                  "learningObjective": "Explicar como opcode ativa sinais específicos de controle.",
                                  "commonMistakes": "Assumir controle microprogramado sem diferenciar de hardwired."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Decodificação com Operandos e Preparar Execução",
                                  "subSteps": [
                                    "Analise operandos para determinar endereçamento e preparar caminhos de dados.",
                                    "Gere sinais adicionais baseados em operandos (ex: PC increment para jump).",
                                    "Descreva handshaking com datapath: controle envia sinais para ALU, registradores.",
                                    "Verifique dependências: flags de condição para branch instructions.",
                                    "Teste com ciclo completo: fetch → decode → execute simulado."
                                  ],
                                  "verification": "Simule decode completo de uma instrução ADD e liste todos sinais gerados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de simulação CPU (ex: 6502 simulator), bloco de notas para tracing.",
                                  "tips": "Use debug mode em simulador para pausar na fase decode e inspecionar IR.",
                                  "learningObjective": "Conectar interpretação de operandos à geração final de sinais para execução.",
                                  "commonMistakes": "Esquecer operandos afetarem sinais (ex: imediato vs registrador)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Sintetizar o Processo de Decodificação",
                                  "subSteps": [
                                    "Resuma diferenças entre decodificação hardwired e microprogramada.",
                                    "Compare decode em arquiteturas CISC vs RISC.",
                                    "Identifique otimizações como pipeline decode stage.",
                                    "Crie diagrama pessoal do fluxo decode.",
                                    "Explique impacto de erros de decode (ex: instrução inválida)."
                                  ],
                                  "verification": "Crie e explique um diagrama completo do processo decode para revisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramentas de desenho (Draw.io), resumo de notas anteriores.",
                                  "tips": "Revise com timer para reforçar memória ativa.",
                                  "learningObjective": "Sintetizar conhecimentos para explicar decode de forma integrada.",
                                  "commonMistakes": "Generalizar sem exemplos específicos de hardware."
                                }
                              ],
                              "practicalExample": "Em um microprocessador 8085, a instrução binária 47H (MOV B,A) é fetchada para IR. Decode: opcode 47H → decodificador ativa 'enable REG B write' e 'select REG A to bus'. Operandos implícitos (registradores). Sinais gerados: RegWrite=1, ALUSrc=0, MemRead=0, preparando transferência A→B.",
                              "finalVerifications": [
                                "Descreva verbalmente o fluxo completo de decode para uma instrução dada sem consultar notas.",
                                "Identifique opcode e operandos corretamente em 5 instruções binárias aleatórias.",
                                "Liste sinais de controle para instruções ADD, MOV e JMP.",
                                "Trace decode em um simulador e capture screenshot de IR e sinais.",
                                "Explique diferença entre decode hardwired e microprogramado com exemplo.",
                                "Crie fluxograma pessoal e valide com diagrama padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de opcode/operandos (90% correto).",
                                "Profundidade na explicação de geração de sinais de controle.",
                                "Uso correto de terminologia técnica (IR, datapath, micro-operações).",
                                "Capacidade de traçar processo em exemplos concretos.",
                                "Integração com ciclo de instrução completo.",
                                "Criatividade em analogias e diagramas para clareza."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Portas lógicas e decodificadores (PLA/PROM na unidade de controle).",
                                "Programação: Assembly language e debugging de instruções.",
                                "Engenharia de Software: Projeto de FSM para controle sequencial.",
                                "Física: Temporização e clocks em circuitos síncronos.",
                                "Matemática: Operações binárias e máscaras de bits."
                              ],
                              "realWorldApplication": "Na decodificação de instruções em microcontroladores como Arduino (ATmega), permite execução eficiente de código em robótica mecatrônica, otimizando controle de motores e sensores em tempo real, evitando delays em sistemas embarcados industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Analisar fase de execução (Execute)",
                            "description": "Descrever a realização da operação especificada pela instrução, envolvendo ALU, registradores e possivelmente acesso à memória externa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a operação e operandos da instrução",
                                  "subSteps": [
                                    "Analisar o opcode decodificado da instrução para determinar a operação (ex: ADD, SUB, MOV).",
                                    "Identificar os operandos fonte e destino (registradores ou endereços de memória).",
                                    "Verificar o modo de endereçamento (imediato, direto, indireto).",
                                    "Consultar a documentação do microprocessador para confirmar a semântica da instrução.",
                                    "Mapear os registradores envolvidos (ex: acumulador, índice)."
                                  ],
                                  "verification": "Lista correta de operação, operandos e modo de endereçamento anotada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de instruções do microprocessador",
                                    "Diagrama de decodificação",
                                    "Simulador de microprocessador (ex: Logisim ou MARS)"
                                  ],
                                  "tips": "Use sempre o opcode binário/hex para precisão; ignore comentários irrelevantes.",
                                  "learningObjective": "Compreender como a instrução define a operação a ser executada.",
                                  "commonMistakes": [
                                    "Confundir opcode com operando",
                                    "Ignorar modo de endereçamento",
                                    "Assumir registradores sem verificar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar dados para a ALU e registradores",
                                  "subSteps": [
                                    "Carregar operandos dos registradores fonte para as entradas da ALU.",
                                    "Verificar se há necessidade de extensão de sinal para operandos.",
                                    "Configurar barramentos internos para transferência de dados.",
                                    "Identificar registradores auxiliares (ex: temporários ou flags).",
                                    "Simular o fluxo de dados no diagrama de blocos do microprocessador."
                                  ],
                                  "verification": "Diagrama anotado mostrando dados preparados nos barramentos e entradas da ALU.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de blocos da ALU e registradores",
                                    "Ferramenta de simulação (ex: Tinkercad ou Proteus)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Visualize o barramento como 'estradas' para dados; priorize registradores principais.",
                                  "learningObjective": "Dominar o fluxo de dados entre registradores e ALU.",
                                  "commonMistakes": [
                                    "Esquecer extensão de sinal em operações aritméticas",
                                    "Confundir fonte e destino",
                                    "Ignorar registradores de status"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a operação na ALU",
                                  "subSteps": [
                                    "Aplicar a lógica da operação na ALU (ex: soma bit a bit para ADD).",
                                    "Processar carry/overflow se aplicável.",
                                    "Atualizar registradores de flags (Zero, Carry, Sign, Overflow).",
                                    "Simular ciclo de clock para a operação.",
                                    "Verificar se a operação requer múltiplos ciclos."
                                  ],
                                  "verification": "Resultado da ALU e flags atualizadas calculados corretamente em simulação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Especificação da ALU (portas lógicas)",
                                    "Simulador digital (ex: Logisim)",
                                    "Exemplos de instruções binárias"
                                  ],
                                  "tips": "Teste com valores pequenos primeiro (ex: 1+1) para validar lógica.",
                                  "learningObjective": "Analisar o processamento lógico/aritmético na ALU.",
                                  "commonMistakes": [
                                    "Não propagar carry corretamente",
                                    "Esquecer atualização de flags",
                                    "Assumir operação síncrona sem clock"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar resultado e acesso à memória",
                                  "subSteps": [
                                    "Transferir resultado da ALU para registrador destino.",
                                    "Verificar se há store na memória externa (ex: via barramento de dados).",
                                    "Atualizar PC se for instrução de salto condicional.",
                                    "Confirmar conclusão da fase Execute no ciclo de instrução.",
                                    "Documentar mudanças no estado da máquina (snapshot de registradores)."
                                  ],
                                  "verification": "Estado final dos registradores e memória simulado e comparado com esperado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mapa de memória do microprocessador",
                                    "Debugger de assembly (ex: emu8086)",
                                    "Folha de rastreamento de estados"
                                  ],
                                  "tips": "Sempre capture 'antes/depois' para rastrear mudanças.",
                                  "learningObjective": "Entender o armazenamento de resultados e integração com memória.",
                                  "commonMistakes": [
                                    "Não atualizar PC corretamente",
                                    "Confundir read/write na memória",
                                    "Ignorar latência de memória"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a instrução ADD R0, R1 em um microprocessador 8-bit: R0=0x05 (5), R1=0x03 (3). Carrega R0 e R1 nas entradas ALU, soma resulta em 0x08, armazena em R0, flag Zero=0, Carry=0. Se overflow, Carry=1. Simule em ferramenta como Logisim.",
                              "finalVerifications": [
                                "Descreve precisamente o fluxo de dados da ALU para registradores/memória.",
                                "Identifica corretamente atualizações de flags para diferentes operações.",
                                "Simula execução sem erros em pelo menos 3 instruções variadas.",
                                "Explica impacto de modos de endereçamento na fase Execute.",
                                "Rastreia mudanças no estado da CPU de forma consistente.",
                                "Diferencia operações puramente registrador vs. memória."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de operandos e operações (30%).",
                                "Correção no fluxo ALU-registradores-memória (25%).",
                                "Atualização precisa de flags e status (20%).",
                                "Uso correto de simulações e diagramas (15%).",
                                "Clareza na descrição escrita e verbal (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Portas lógicas e ALU.",
                                "Programação em Assembly: Execução de código máquina.",
                                "Lógica Programável: Comportamento de FPGAs em ciclos de clock.",
                                "Sistemas Embarcados: Integração em microcontroladores como Arduino."
                              ],
                              "realWorldApplication": "Em sistemas mecatrônicos como CLPs industriais ou controladores de robôs, a fase Execute realiza cálculos em tempo real para controle de motores, PID e monitoramento de sensores, garantindo precisão em automação fabril."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.4",
                            "name": "Entender ciclo completo e pipelines",
                            "description": "Representar o ciclo completo de instrução e introduzir conceitos de pipeline para sobreposição de fases, otimizando desempenho em microprocessadores modernos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Ciclo de Instrução Clássico",
                                  "subSteps": [
                                    "Estude as cinco fases principais: Fetch (busca da instrução), Decode (decodificação), Execute (execução), Memory Access (acesso à memória) e Write Back (escrita de volta).",
                                    "Analise o fluxo sequencial em um diagrama de ciclo simples de um microprocessador como o 8086.",
                                    "Identifique o tempo total de uma instrução sem sobreposição.",
                                    "Compare com ciclos mais simples de 3 ou 4 fases.",
                                    "Registre anotações sobre dependências entre fases."
                                  ],
                                  "verification": "Desenhe um diagrama do ciclo clássico e explique cada fase oralmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de arquitetura de computadores, diagrama impresso do ciclo de instrução, papel e caneta.",
                                  "tips": "Use setas para mostrar o fluxo sequencial e destaque o clock cycle em cada fase.",
                                  "learningObjective": "Dominar as fases fundamentais do ciclo de instrução sequencial.",
                                  "commonMistakes": "Confundir Decode com Execute; ignorar Write Back como fase opcional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar o Ciclo Completo em Microprocessadores Modernos",
                                  "subSteps": [
                                    "Explore variações em arquiteturas RISC vs CISC, focando em exemplos como MIPS ou ARM.",
                                    "Desenhe um diagrama temporal mostrando múltiplos ciclos de clock para uma instrução completa.",
                                    "Inclua elementos como ALU, registradores e barramentos de dados/instruções.",
                                    "Simule uma instrução ADD em um ciclo completo usando pseudocódigo.",
                                    "Discuta impactos de cache e branch predictions no ciclo."
                                  ],
                                  "verification": "Crie um diagrama temporal de uma instrução específica e valide com um simulador online.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador de MIPS online (ex: MARS), software de desenho como Draw.io, vídeo tutorial sobre ciclo MIPS.",
                                  "tips": "Marque ciclos de clock verticalmente para visualizar duração total.",
                                  "learningObjective": "Visualizar e representar graficamente o ciclo completo em contextos modernos.",
                                  "commonMistakes": "Subestimar acessos à memória como fase longa; omitir interações com pipeline stages."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Conceitos de Pipeline",
                                  "subSteps": [
                                    "Defina pipeline como sobreposição de fases de múltiplas instruções em estágios paralelos.",
                                    "Estude um pipeline de 5 estágios clássico: IF (Instruction Fetch), ID (Decode), EX (Execute), MEM (Memory), WB (Write Back).",
                                    "Analise speedup ideal: número de estágios para throughput.",
                                    "Identifique tipos de pipelines: scalar, superscalar.",
                                    "Use analogia de linha de produção fabril para ilustrar."
                                  ],
                                  "verification": "Explique a diferença entre execução sequencial e pipelined com um exemplo numérico de throughput.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Apresentação em slides sobre pipelines, calculadora para speedup, quadro branco.",
                                  "tips": "Calcule speedup: Throughput pipelined = 1 instrução por ciclo vs 5 ciclos sequenciais.",
                                  "learningObjective": "Entender os fundamentos de pipelining e seus benefícios teóricos.",
                                  "commonMistakes": "Confundir latência (tempo por instrução) com throughput (instruções por ciclo)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Sobreposição de Fases e Otimizações",
                                  "subSteps": [
                                    "Desenhe um diagrama de pipeline mostrando sobreposição de 4 instruções.",
                                    "Estude hazards: structural, data e control, com exemplos.",
                                    "Explore soluções: forwarding, stalling, branch prediction.",
                                    "Simule um pipeline com hazard e aplique forwarding.",
                                    "Discuta otimizações em microprocessadores modernos como out-of-order execution."
                                  ],
                                  "verification": "Simule um pipeline com 3 instruções em um papel ou ferramenta, identificando e resolvendo um hazard.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Ferramenta de simulação de pipeline (ex: LC-3 simulator), exemplos de código assembly simples.",
                                  "tips": "Use cores diferentes para cada instrução no diagrama para visualizar sobreposição.",
                                  "learningObjective": "Dominar desafios e otimizações em pipelines para desempenho otimizado.",
                                  "commonMistakes": "Ignorar data hazards em dependências de registradores; superestimar speedup sem considerar stalls."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e Aplicar Conceitos em Exemplos Reais",
                                  "subSteps": [
                                    "Compare ciclo sem pipeline vs pipelined em termos de CPI (Cycles Per Instruction).",
                                    "Analise pipelines reais: Intel Core i7 (14-20 estágios) vs ARM Cortex (8-13).",
                                    "Otimize um snippet de código assembly para melhor fluxo de pipeline.",
                                    "Discuta impacto no design de sistemas mecatrônicos.",
                                    "Crie um relatório resumindo ganhos de performance."
                                  ],
                                  "verification": "Resolva um problema de otimização de pipeline e apresente métricas de melhoria.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Documentação de processadores reais (Intel/ARM manuals), compilador assembly.",
                                  "tips": "Foquem em reordenar instruções para minimizar stalls.",
                                  "learningObjective": "Aplicar conhecimentos de ciclo e pipeline a cenários reais e comparativos.",
                                  "commonMistakes": "Não considerar overheads como flush em branches."
                                }
                              ],
                              "practicalExample": "Em um microcontrolador ARM Cortex-M4 usado em um robô mecatrônico, uma sequência de instruções para controle de motor (fetch LDR, ADD velocidade, STR saída) é pipelined: enquanto a primeira instrução está em Execute, a segunda entra em Decode, reduzindo tempo total de 15 para 5 ciclos de clock, permitindo resposta em tempo real.",
                              "finalVerifications": [
                                "Desenhar corretamente um diagrama de pipeline de 5 estágios com sobreposição.",
                                "Explicar e resolver um data hazard com forwarding.",
                                "Calcular speedup ideal e real para um exemplo dado.",
                                "Identificar fases em um ciclo de instrução de um processador específico.",
                                "Discutir pelo menos duas otimizações modernas de pipeline.",
                                "Simular uma sequência de 4 instruções sem stalls."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação gráfica do ciclo e pipeline (30%).",
                                "Compreensão de hazards e soluções (25%).",
                                "Cálculos corretos de performance e speedup (20%).",
                                "Uso de exemplos reais e contextualizados (15%).",
                                "Clareza na explicação oral/escrita e identificação de erros comuns (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: Otimização de código para pipelines.",
                                "Eletrônica Digital: Design de hardware para estágios de pipeline.",
                                "Engenharia de Software: Análise de desempenho em sistemas embarcados.",
                                "Matemática: Modelagem de throughput e latência com equações.",
                                "Física: Analogias com fluxo de energia em sistemas mecatrônicos."
                              ],
                              "realWorldApplication": "No design de drones autônomos, pipelines em microprocessadores como STM32 permitem processar sensores (IMU, GPS) em tempo real, sobrepondo fetch de dados de visão com execução de algoritmos de controle, otimizando bateria e resposta a obstáculos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.4",
                        "name": "Evolução Histórica dos Microprocessadores",
                        "description": "Visão cronológica das gerações de microprocessadores, desde os primeiros modelos até arquiteturas modernas aplicadas em mecatrônica.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.4.1",
                            "name": "Traçar gerações iniciais (4-bit a 8-bit)",
                            "description": "Descrever microprocessadores como Intel 4004 (1971), 8008 e 8080, destacando aumento de transistores e aplicações iniciais em calculadoras e controle industrial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e compreender o Intel 4004",
                                  "subSteps": [
                                    "Identificar o ano de lançamento (1971) e o contexto de desenvolvimento pela Intel para a calculadora Busicom.",
                                    "Analisar especificações técnicas: processador 4-bit, 2.300 transistores, clock de 740 kHz e 92 instruções.",
                                    "Estudar a arquitetura: registradores, ALU e barramento de dados.",
                                    "Explorar aplicações iniciais: calculadoras e controle simples de máquinas.",
                                    "Coletar imagens ou diagramas do chip para visualização."
                                  ],
                                  "verification": "Criar um resumo de 1 página com specs e aplicações, comparando com fontes confiáveis como site da Intel.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Acesso à internet",
                                    "Documentos históricos da Intel (PDFs ou wiki)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use fontes primárias como patentes ou artigos de Federico Faggin para maior precisão.",
                                  "learningObjective": "Compreender o primeiro microprocessador comercial e suas limitações iniciais.",
                                  "commonMistakes": [
                                    "Confundir com 8008 (sucessor)",
                                    "Ignorar o papel da Busicom no financiamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Intel 8008",
                                  "subSteps": [
                                    "Localizar o lançamento (1972) como evolução do 4004 para aplicações gerais.",
                                    "Detalhar specs: 8-bit, cerca de 3.500 transistores, clock de 800 kHz e suporte a mais memória.",
                                    "Examinar melhorias: barramento separado para dados e endereços, maior conjunto de instruções.",
                                    "Identificar aplicações: primeiros sistemas embarcados e controle industrial básico.",
                                    "Comparar quantitativamente com o 4004 (aumento de transistores e bits)."
                                  ],
                                  "verification": "Montar uma tabela comparativa com o 4004, verificando números exatos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Fontes online (Wikipedia, Intel Museum)",
                                    "Planilha Excel ou Google Sheets",
                                    "Cronograma histórico impresso"
                                  ],
                                  "tips": "Foque no aumento de transistores como métrica chave de evolução.",
                                  "learningObjective": "Reconhecer a transição de 4-bit para 8-bit e ganhos em capacidade.",
                                  "commonMistakes": [
                                    "Subestimar limitações de pinos (18 pinos insuficientes para expansão)",
                                    "Confundir com 8080"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o Intel 8080",
                                  "subSteps": [
                                    "Pesquisar lançamento (1974) e design por Masatoshi Shima e Federico Faggin.",
                                    "Listar specs: 8-bit aprimorado, 6.000 transistores, clock de 2 MHz, 40 pinos e modos de interrupção.",
                                    "Analisar inovações: maior velocidade, suporte a DMA e compatibilidade com 8008.",
                                    "Destacar aplicações: Altair 8800 (primeiro PC pessoal), controle industrial e terminais.",
                                    "Mapear o aumento progressivo de transistores (4004 → 8008 → 8080)."
                                  ],
                                  "verification": "Desenhar um diagrama de blocos da arquitetura e explicar verbalmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagramas de pinout (imagens online)",
                                    "Vídeos educativos no YouTube",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Assista simulações de código assembly para visualizar funcionamento.",
                                  "learningObjective": "Identificar avanços que pavimentaram o caminho para microcomputadores.",
                                  "commonMistakes": [
                                    "Ignorar impacto no hobby computing via Altair",
                                    "Erro em contagem de transistores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Traçar a evolução geral e aplicações iniciais",
                                  "subSteps": [
                                    "Criar uma linha do tempo visual com datas, transistores e aplicações.",
                                    "Comparar métricas: bits, transistores, clock speed e shift de calculadoras para controle industrial.",
                                    "Discutir impacto: redução de custos e miniaturização em mecatrônica.",
                                    "Relacionar com contexto histórico: Lei de Moore inicial.",
                                    "Preparar um relatório síntese destacando gerações iniciais."
                                  ],
                                  "verification": "Apresentar linha do tempo e relatório para revisão por pares ou professor.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Ferramenta de design (Canva, PowerPoint)",
                                    "Dados compilados dos steps anteriores",
                                    "Livro de história da computação (opcional)"
                                  ],
                                  "tips": "Use gráficos de barras para visualização de crescimento de transistores.",
                                  "learningObjective": "Sintetizar a evolução de 4-bit a 8-bit e suas implicações práticas.",
                                  "commonMistakes": [
                                    "Focar só em specs técnicas sem aplicações",
                                    "Datas ou números imprecisos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma linha do tempo interativa no Canva comparando Intel 4004, 8008 e 8080, incluindo número de transistores, aplicações (ex: Busicom 141-PF para 4004, Altair para 8080) e um fluxograma mostrando evolução arquitetural, para uso em apresentação de projeto mecatrônico.",
                              "finalVerifications": [
                                "Pode listar corretamente specs (transistores, bits, clock) dos três processadores.",
                                "Descreve aplicações iniciais com exemplos precisos (calculadoras para 4004, controle para 8080).",
                                "Traça aumento de transistores quantitativamente (2.300 → 3.500 → 6.000).",
                                "Explica transições arquiteturais (4-bit para 8-bit e melhorias).",
                                "Identifica impacto na mecatrônica inicial.",
                                "Apresenta linha do tempo sem erros factuais."
                              ],
                              "assessmentCriteria": [
                                "Precisão histórica e técnica (100% das specs corretas).",
                                "Completude da descrição evolutiva (aumento de transistores e aplicações).",
                                "Clareza na comunicação (diagramas e resumos legíveis).",
                                "Profundidade analítica (comparações e contexto).",
                                "Criatividade no exemplo prático (visualizações inovadoras).",
                                "Ausência de erros comuns (datas, confusões entre chips)."
                              ],
                              "crossCurricularConnections": [
                                "História da Computação: Contexto da revolução digital dos anos 70.",
                                "Eletrônica Digital: Entendimento de arquitetura von Neumann básica.",
                                "Engenharia Mecatrônica: Aplicações em automação industrial inicial.",
                                "Física: Princípios de transistores MOS e Lei de Moore.",
                                "Programação: Introdução a assembly para esses processadores."
                              ],
                              "realWorldApplication": "Essa compreensão permite projetar sistemas mecatrônicos modernos, otimizando microcontroladores como Arduino (herdeiros do 8080) para controle industrial, robótica e IoT, prevendo evoluções em eficiência energética e integração."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.4.2",
                            "name": "Analisar era 16-bit e 32-bit",
                            "description": "Explicar avanços em Intel 8086/8088, 80286, 80386, com suporte a memória protegida, multitasking e integração em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar a arquitetura do Intel 8086/8088",
                                  "subSteps": [
                                    "Pesquisar especificações técnicas: barramento de 16 bits, registradores e modos de endereçamento.",
                                    "Analisar o conjunto de instruções básico e ciclo de máquina.",
                                    "Diagramar o modelo de memória segmentada (64KB por segmento).",
                                    "Comparar 8086 (bus externo 16-bit) com 8088 (bus externo 8-bit).",
                                    "Identificar limitações iniciais em sistemas reais."
                                  ],
                                  "verification": "Criar um diagrama da arquitetura e listar 5 características principais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Datasheet Intel 8086/8088 (PDF online), emulador como DOSBox ou EMU8086.",
                                  "tips": "Use diagramas visuais para entender segmentação de memória.",
                                  "learningObjective": "Compreender os fundamentos da era 16-bit inicial.",
                                  "commonMistakes": "Confundir barramento interno/externo ou ignorar diferenças 8086/8088."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Intel 80286 e introdução à memória protegida",
                                  "subSteps": [
                                    "Estudar modos de operação: Real Mode e Protected Mode.",
                                    "Explicar descritores de segmento e tabela de páginas virtuais.",
                                    "Detalhar suporte inicial a multitasking com privilégios de ring.",
                                    "Comparar com 8086: expansão para 16MB de memória.",
                                    "Simular transição de Real para Protected Mode."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras sobre Protected Mode e listar benefícios.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Datasheet 80286, tutoriais Bochs emulator, vídeos Khan Academy sobre memória.",
                                  "tips": "Pratique com código assembly em emulador para ver modos.",
                                  "learningObjective": "Dominar conceitos de proteção de memória e modos operacionais.",
                                  "commonMistakes": "Misturar Real Mode com Protected Mode sem destacar diferenças."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Intel 80386 e avanços para 32-bit",
                                  "subSteps": [
                                    "Descrever arquitetura 32-bit: registradores estendidos (EAX, etc.) e paging completo.",
                                    "Analisar modos: Real, Protected e Virtual 8086.",
                                    "Estudar pipeline e cache integrado para performance.",
                                    "Comparar suporte a multitasking preemptivo e multiprocessamento.",
                                    "Diagramar modelo de memória plana de 4GB."
                                  ],
                                  "verification": "Montar tabela comparativa 8086/80286/80386 com colunas de bits, memória e modos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Datasheet 80386, simulador PCem ou 86Box, documentação OSDev wiki.",
                                  "tips": "Foque em como 32-bit resolveu limitações de 16-bit.",
                                  "learningObjective": "Entender transição para arquiteturas modernas.",
                                  "commonMistakes": "Subestimar impacto do paging na virtualização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir avanços chave e integração em mecatrônica",
                                  "subSteps": [
                                    "Explicar memória protegida e multitasking em contextos operacionais (DOS para Windows).",
                                    "Analisar impacto em sistemas embarcados e CLPs.",
                                    "Estudar exemplos de integração: controladores industriais baseados em x86.",
                                    "Criar linha do tempo de evoluções e aplicações mecatrônicas.",
                                    "Debater limitações e sucessores (80486)."
                                  ],
                                  "verification": "Produzir relatório de 1 página com exemplos mecatrônicos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Artigos IEEE sobre história x86, manuais CLPs Siemens/Allen-Bradley.",
                                  "tips": "Relacione com projetos reais como PLCs x86-compatíveis.",
                                  "learningObjective": "Conectar evolução histórica a aplicações práticas em mecatrônica.",
                                  "commonMistakes": "Ignorar contexto mecatrônico e focar só em PCs."
                                }
                              ],
                              "practicalExample": "Usando um emulador como Bochs, compile e execute um programa assembly simples em Protected Mode no 80286, simulando multitasking com dois processos trocando registradores, e diagrame como isso se integra a um sistema mecatrônico de controle de motor via interface paralela.",
                              "finalVerifications": [
                                "Lista precisa de avanços: 8086/8088 (16-bit básico), 80286 (memória protegida), 80386 (32-bit full).",
                                "Diagrama comparativo de modelos de memória.",
                                "Explicação correta de multitasking e rings de proteção.",
                                "Exemplo de aplicação em CLP ou sistema embarcado.",
                                "Identificação de 3 limitações resolvidas na era.",
                                "Simulação bem-sucedida em emulador."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas descrições de processadores (90%+ acurácia).",
                                "Profundidade nos substeps e verificações práticas.",
                                "Clareza em diagramas e comparações.",
                                "Relevância à mecatrônica e integração real.",
                                "Completude da linha do tempo evolutiva.",
                                "Criatividade no practical example.",
                                "Ausência de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "História da Computação: Evolução de arquiteturas.",
                                "Eletrônica Digital: Barramentos e interfaces.",
                                "Programação: Assembly e modos operacionais.",
                                "Engenharia de Controle: Aplicações em CLPs e automação.",
                                "Física: Sinais e temporização em sistemas mecatrônicos."
                              ],
                              "realWorldApplication": "Esses avanços possibilitaram PCs IBM e sistemas embarcados robustos, usados hoje em PLCs industriais para multitasking em linhas de produção mecatrônicas, como controle simultâneo de múltiplos atuadores e sensores em robótica automotiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.4.3",
                            "name": "Discutir microprocessadores modernos (64-bit e RISC)",
                            "description": "Apresentar evoluções como Pentium, ARM e x86-64, enfatizando redução de consumo energético, paralelismo e aplicações em robótica aeronáutica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a evolução histórica para microprocessadores 64-bit",
                                  "subSteps": [
                                    "Estudar a linha Pentium (ex: Pentium Pro) e sua transição para x86-64 pela AMD em 2003",
                                    "Comparar limitações de 32-bit (4GB RAM) com capacidades de 64-bit (ex: 2^64 bytes endereçáveis)",
                                    "Analisar impacto em performance para aplicações modernas como multitarefa",
                                    "Listar sucessores como Intel Core i-series baseados em x86-64",
                                    "Explorar documentação oficial da Intel/AMD sobre extensões 64-bit"
                                  ],
                                  "verification": "Criar um timeline visual resumindo a evolução de Pentium a x86-64 e explicar verbalmente",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação Intel/AMD x86-64",
                                    "Vídeos educativos sobre história de CPUs",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use analogias como 'endireçar uma rua de 4 faixas para 8' para visualizar expansão de registradores",
                                  "learningObjective": "Compreender as motivações técnicas e históricas para adoção de 64-bit em microprocessadores",
                                  "commonMistakes": [
                                    "Confundir x86 (CISC) com RISC prematuramente",
                                    "Ignorar o papel da AMD na introdução de x86-64",
                                    "Subestimar impacto na compatibilidade de software legado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar arquiteturas RISC modernas como ARM",
                                  "subSteps": [
                                    "Definir princípios RISC (instruções simples, pipeline eficiente) vs CISC (x86)",
                                    "Estudar evolução do ARM: de 32-bit para ARMv8-A (64-bit AArch64)",
                                    "Comparar ARM com x86-64 em termos de conjunto de instruções e licenciamento",
                                    "Analisar variantes como Cortex-A series usados em dispositivos embarcados",
                                    "Pesquisar cases de uso em smartphones e IoT"
                                  ],
                                  "verification": "Montar uma tabela comparativa ARM vs x86-64 destacando diferenças chave em RISC",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Site oficial ARM Developer",
                                    "Livro 'ARM System Developer's Guide'",
                                    "Simulador online como QEMU para ARM"
                                  ],
                                  "tips": "Lembre-se: RISC prioriza velocidade de execução sobre complexidade de instruções",
                                  "learningObjective": "Dominar conceitos fundamentais de RISC e sua implementação em ARM 64-bit",
                                  "commonMistakes": [
                                    "Achar que todos os ARM são 32-bit",
                                    "Confundir ARM com processadores proprietários como Apple M1 (baseado em ARM)",
                                    "Ignorar otimizações de pipeline em RISC"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar avanços em redução de consumo energético e paralelismo",
                                  "subSteps": [
                                    "Investigar técnicas como clock gating, dynamic voltage scaling em ARM e x86-64",
                                    "Estudar paralelismo: multi-core (ex: 4-8 cores em chips modernos), SIMD (NEON em ARM, AVX em x86)",
                                    "Quantificar reduções: ARM consome ~1W vs x86 desktop ~100W em idle",
                                    "Explorar trade-offs: eficiência energética vs performance bruta",
                                    "Simular cenários com ferramentas de profiling de energia"
                                  ],
                                  "verification": "Calcular e comparar consumo estimado para tarefas simples em ARM vs x86 usando benchmarks públicos",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Benchmarks SPECpower",
                                    "Ferramentas como PowerTOP para Linux",
                                    "Artigos IEEE sobre low-power design"
                                  ],
                                  "tips": "Foque em métricas como DMIPS/W (performance por watt) para comparações objetivas",
                                  "learningObjective": "Explicar como designs modernos otimizam energia e habilitam paralelismo",
                                  "commonMistakes": [
                                    "Atribuir toda eficiência ao RISC sem considerar fabricação (ex: 7nm)",
                                    "Confundir threads lógicos com cores físicos",
                                    "Ignorar impacto térmico em aplicações embarcadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir aplicações em robótica aeronáutica",
                                  "subSteps": [
                                    "Analisar uso de ARM 64-bit em drones (ex: Qualcomm Snapdragon em DJI drones)",
                                    "Explorar x86-64 em estações de controle ou UAVs industriais",
                                    "Mapear requisitos: baixo peso/energia para autonomia de voo, paralelismo para visão/AI",
                                    "Estudar cases reais como PX4 autopilot (ARM-based)",
                                    "Prever tendências: edge computing em drones autônomos"
                                  ],
                                  "verification": "Preparar uma apresentação de 5min sobre um drone específico e seu microprocessador",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação PX4/ArduPilot",
                                    "Vídeos de teardown de drones",
                                    "Specs de processadores em UAVs"
                                  ],
                                  "tips": "Conecte specs técnicas a problemas reais como 'bateria limitada em voos longos'",
                                  "learningObjective": "Aplicar conhecimentos a contextos práticos de mecatrônica aeronáutica",
                                  "commonMistakes": [
                                    "Generalizar todos os drones como ARM sem verificar modelos",
                                    "Subestimar necessidade de RTOS em aplicações reais",
                                    "Ignorar certificações de segurança em aviação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de drone para inspeção agrícola, utilize um Raspberry Pi 4 (ARM 64-bit Cortex-A72) para processar imagens de câmeras em tempo real com OpenCV, aproveitando paralelismo multi-core para detecção de pragas enquanto mantém consumo abaixo de 5W, permitindo 30+ min de voo autônomo.",
                              "finalVerifications": [
                                "Explicar diferenças entre x86-64 (CISC evoluído) e ARM (RISC puro)",
                                "Listar 3 técnicas de redução energética em microprocessadores modernos",
                                "Descrever como paralelismo suporta aplicações em robótica",
                                "Identificar exemplos reais de uso em aeronáutica",
                                "Criar diagrama comparativo de performance/energia",
                                "Discutir limitações futuras como fim de scaling de Moore"
                              ],
                              "assessmentCriteria": [
                                "Precisão factual na evolução histórica (Pentium a modernos)",
                                "Profundidade na distinção RISC vs CISC com exemplos técnicos",
                                "Análise quantitativa de energia e paralelismo",
                                "Relevância de aplicações em robótica aeronáutica",
                                "Clareza na comunicação de conceitos complexos",
                                "Criatividade em conexões interdisciplinares"
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de termodinâmica e eficiência energética em semicondutores",
                                "Programação: Assembly ARM/x86 e otimização de código para multi-core",
                                "Engenharia Aeronáutica: Sistemas embarcados e controle de voo em UAVs",
                                "Matemática: Modelagem de pipelines e paralelismo (grafos de dependência)",
                                "Inteligência Artificial: Processamento edge em drones para visão computacional"
                              ],
                              "realWorldApplication": "Microprocessadores 64-bit RISC como ARM revolucionam robótica aeronáutica em drones autônomos para entregas (Amazon Prime Air), inspeções industriais e monitoramento ambiental, onde baixa energia estende missões e paralelismo habilita IA embarcada para navegação segura em tempo real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Características de Microcontroladores",
                    "description": "Análise de microcontroladores como sistemas integrados com CPU, memória, periféricos e interfaces para aplicações embarcadas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Unidade Central de Processamento (CPU)",
                        "description": "Características da CPU integrada nos microcontroladores, incluindo arquitetura (Von Neumann ou Harvard modificada), clock speed, conjunto de instruções (RISC/CISC) e modos de operação para otimização em aplicações embarcadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Identificar arquiteturas de CPU em microcontroladores comuns",
                            "description": "Diferenciar arquiteturas Von Neumann e Harvard em exemplos como AVR e ARM, explicando vantagens para separação de memória de programa e dados em sistemas embarcados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos das Arquiteturas Von Neumann e Harvard",
                                  "subSteps": [
                                    "Estude a definição de arquitetura Von Neumann: memória única compartilhada para programa e dados.",
                                    "Analise a arquitetura Harvard: memórias separadas para programa (ex: Flash/ROM) e dados (ex: RAM).",
                                    "Desenhe diagramas simples comparando os fluxos de barramento de endereço e dados em cada uma.",
                                    "Revise o gargalo de Von Neumann (bottleneck) causado pelo compartilhamento de memória.",
                                    "Liste as principais diferenças em uma tabela comparativa."
                                  ],
                                  "verification": "Crie um diagrama comparativo e explique verbalmente ou por escrito as diferenças principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de arquitetura de computadores, diagramas online (ex: Wikipedia Von Neumann/Harvard), papel e caneta para desenhos.",
                                  "tips": "Use cores diferentes nos diagramas para destacar memórias separadas vs. compartilhadas.",
                                  "learningObjective": "Diferenciar conceitualmente Von Neumann e Harvard, identificando fluxos de memória.",
                                  "commonMistakes": "Confundir Harvard com cache separado; lembrar que Harvard tem barramentos paralelos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Exemplos em Microcontroladores Comuns: AVR e ARM",
                                  "subSteps": [
                                    "Pesquise especificações do AVR (ex: ATmega328 em Arduino): confirme arquitetura Harvard com Flash para programa e SRAM para dados.",
                                    "Analise ARM (ex: Cortex-M em STM32): identifique como Von Neumann ou Harvard modificada, com bus unificado em alguns modelos.",
                                    "Consulte datasheets oficiais (Microchip para AVR, ST para ARM) para diagramas de memória.",
                                    "Compare endereçamento de memória em ferramentas como Atmel Studio ou STM32Cube.",
                                    "Anote exemplos de endereços: AVR programa 0x0000-0xFFFF Flash, dados 0x0100+ SRAM."
                                  ],
                                  "verification": "Extraia trechos de datasheets mostrando mapas de memória e classifique cada arquitetura.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Datasheets PDF (ATmega328, STM32F103), simuladores como Tinkercad ou Proteus.",
                                  "tips": "Busque seções 'Memory Architecture' nos datasheets para confirmação rápida.",
                                  "learningObjective": "Associar AVR a Harvard e ARM a Von Neumann/modificada com evidências de hardware.",
                                  "commonMistakes": "Assumir todos ARM como Harvard; verificar modelos específicos (ex: Cortex-M0 é Von Neumann)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Vantagens da Separação de Memória em Sistemas Embarcados",
                                  "subSteps": [
                                    "Discuta vantagens Harvard: execução simultânea de fetch e dados, maior velocidade em embarcados.",
                                    "Compare com Von Neumann: latência em acessos concorrentes, menos ideal para real-time.",
                                    "Calcule exemplo simples: tempo de ciclo em Harvard vs. Von Neumann para instrução + dado.",
                                    "Relacione a embarcados: Flash não-volátil para programa, SRAM volátil para variáveis.",
                                    "Debata cenários onde Von Neumann é preferida (flexibilidade de código como dados)."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que Harvard é comum em microcontroladores de baixo custo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigos sobre 'Harvard vs Von Neumann in embedded systems', calculadora para tempos de ciclo.",
                                  "tips": "Pense em clocks altos: Harvard permite pipelining melhor sem conflitos de bus.",
                                  "learningObjective": "Justificar vantagens de Harvard para eficiência em sistemas embarcados.",
                                  "commonMistakes": "Ignorar que Harvard aumenta custo de hardware; equilibrar prós e contras."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Análise em Exemplos Reais",
                                  "subSteps": [
                                    "Carregue um sketch no Arduino IDE e inspecione memória usada (programa vs. dados).",
                                    "Use STM32CubeIDE para um projeto ARM e compare alocações de memória.",
                                    "Crie um fluxograma de como a CPU acessa memória em cada arquitetura durante execução.",
                                    "Simule um programa simples e observe conflitos potenciais em Von Neumann.",
                                    "Documente conclusões em um relatório curto com screenshots."
                                  ],
                                  "verification": "Demonstre em simulador ou hardware real a alocação de memória e classifique a arquitetura.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Arduino Uno (AVR), STM32 Nucleo (ARM), IDEs gratuitas (Arduino IDE, STM32CubeIDE).",
                                  "tips": "Use Serial.print para monitorar uso de RAM em runtime.",
                                  "learningObjective": "Aplicar conhecimento para identificar arquiteturas em hardware prático.",
                                  "commonMistakes": "Confundir RAM com Flash; verificar seções de memória no linker script."
                                }
                              ],
                              "practicalExample": "Em um projeto de controle de motor com Arduino (AVR Harvard), o programa fica na Flash (execução rápida) enquanto variáveis de sensor ficam na SRAM (acesso paralelo), evitando gargalos em loops de controle real-time. Compare com STM32 (ARM Von Neumann modificado), onde código e dados competem pelo bus AHBS.",
                              "finalVerifications": [
                                "Descreva corretamente Von Neumann como memória unificada e Harvard como separada.",
                                "Identifique AVR como Harvard e ARM Cortex-M como Von Neumann/Harvard modificada com exemplos.",
                                "Explique pelo menos duas vantagens de Harvard em embarcados.",
                                "Desenhe diagrama preciso de barramentos para ambas.",
                                "Analise um datasheet e extraia mapa de memória.",
                                "Diferencie impactos em performance real-time."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (Von Neumann vs Harvard): 25%",
                                "Correta identificação em AVR/ARM com evidências: 25%",
                                "Explicação clara de vantagens e desvantagens: 20%",
                                "Uso de diagramas e exemplos práticos: 15%",
                                "Análise de impacto em sistemas embarcados: 10%",
                                "Clareza e organização da resposta: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Programação Embarcada: Otimização de código considerando arquitetura de memória.",
                                "Eletrônica Digital: Design de barramentos e interfaces de memória.",
                                "Engenharia de Software: Gerenciamento de recursos limitados em RTOS.",
                                "Física/Controle: Aplicação em loops de feedback real-time sem latência."
                              ],
                              "realWorldApplication": "Em robótica industrial, microcontroladores Harvard como AVR em Arduinos garantem resposta rápida em controladores PID, separando firmware imutável de dados sensoriais voláteis, essencial para segurança em linhas de montagem automotivas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Analisar impacto do clock e pipeline na performance",
                            "description": "Calcular ciclos de clock e throughput em microcontroladores como PIC ou STM32, considerando pipeline e fatores de eficiência energética para aplicações mecatrônicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Clock e sua Relação com Performance",
                                  "subSteps": [
                                    "Definir clock como sinal de sincronização que determina a taxa de execução de instruções em microcontroladores como PIC e STM32.",
                                    "Explicar frequência de clock em MHz e ciclos de clock por instrução (CPI).",
                                    "Identificar fontes de clock: interno (RC), externo (cristal) e PLL para multiplicação.",
                                    "Analisar impacto inicial: performance proporcional à frequência, mas limitada por fatores como latência.",
                                    "Comparar clocks típicos: PIC18F (4-48MHz) vs STM32F4 (até 168MHz)."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como clock afeta execução de 100 instruções simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Datasheets de PIC18F4550 e STM32F407, calculadora, simulador MPLAB X ou STM32CubeIDE.",
                                  "tips": "Use diagramas de timing para visualizar pulsos de clock.",
                                  "learningObjective": "Dominar fundamentos do clock e sua influência direta na velocidade de processamento.",
                                  "commonMistakes": "Confundir frequência de clock com velocidade de barramento ou ignorar overhead de inicialização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Pipeline e seus Estágios em Microcontroladores",
                                  "subSteps": [
                                    "Descrever pipeline como técnica de sobreposição de execução de instruções (fetch, decode, execute).",
                                    "Identificar pipelines típicos: PIC (3-4 estágios simples), STM32 ARM Cortex-M (3 estágios: Fetch, Decode, Execute).",
                                    "Explicar stall e hazard: dependências de dados que pausam o pipeline.",
                                    "Calcular ganho ideal: throughput = 1 instrução por ciclo em pipeline cheio.",
                                    "Simular pipeline em fluxo de instruções sequenciais vs branches."
                                  ],
                                  "verification": "Desenhar diagrama de pipeline para 5 instruções e identificar stalls.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de diagramação (Draw.io), exemplos de assembly ARM Thumb e PIC.",
                                  "tips": "Pense no pipeline como uma linha de montagem: gargalos ocorrem em dependências.",
                                  "learningObjective": "Entender como pipeline aumenta throughput reduzindo tempo médio por instrução.",
                                  "commonMistakes": "Assumir pipeline sempre ideal, ignorando branches que causam flush."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Ciclos de Clock, Throughput e Eficiência sem e com Pipeline",
                                  "subSteps": [
                                    "Calcular ciclos totais para programa: soma de CPI * número de instruções.",
                                    "Definir throughput: instruções por segundo = frequência / CPI médio.",
                                    "Comparar sem pipeline (CPI=1 por estágio) vs com pipeline (CPI<1 em steady-state).",
                                    "Incorporar fatores: wait states em memória flash, interrupções.",
                                    "Exemplo numérico: loop de 10 instruções a 72MHz com pipeline de 3 estágios."
                                  ],
                                  "verification": "Resolver exercício: calcular throughput para programa de 50 instruções com 20% stalls.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Planilha Excel para cálculos, debugger integrado no IDE.",
                                  "tips": "Meça CPI real com ciclo counters em hardware ou simulador.",
                                  "learningObjective": "Realizar cálculos precisos de performance considerando pipeline.",
                                  "commonMistakes": "Esquecer de dividir por estágios ou ignorar overhead de memória."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto na Eficiência Energética e Trade-offs",
                                  "subSteps": [
                                    "Relacionar clock com consumo: P = C * V² * f (frequência dinâmica).",
                                    "Calcular eficiência: MIPS/Watt ou DMIPS/mJ para PIC vs STM32.",
                                    "Avaliar trade-offs: clock alto = alta performance/baixa bateria em aplicações mecatrônicas.",
                                    "Otimizar: modos low-power (sleep, clock gating) com pipeline.",
                                    "Simular cenários: controle de motor com clock variável."
                                  ],
                                  "verification": "Calcular consumo para dois clocks e propor otimização.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramentas de profiling energético (STM32 Power Shield), fórmulas de potência.",
                                  "tips": "Priorize clock mínimo viável para tarefas mecatrônicas cíclicas.",
                                  "learningObjective": "Integrar performance com eficiência energética em análises.",
                                  "commonMistakes": "Ignorar consumo estático ou vazamento em clocks baixos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar Análise em Caso Prático de Microcontrolador",
                                  "subSteps": [
                                    "Selecionar exemplo: PID controller em STM32 para servo motor.",
                                    "Medir ciclos reais com timer ou HAL_GetTick().",
                                    "Comparar performance: clock 72MHz vs 168MHz com pipeline.",
                                    "Ajustar código para minimizar stalls e maximizar throughput.",
                                    "Documentar relatório com gráficos de performance vs energia."
                                  ],
                                  "verification": "Executar simulação/hardware e apresentar métricas calculadas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Placa STM32 Nucleo ou PIC dev board, osciloscópio, software Keil/MikroC.",
                                  "tips": "Use otimização -O2 para código assembly eficiente no pipeline.",
                                  "learningObjective": "Aplicar conceitos em projeto mecatrônico real.",
                                  "commonMistakes": "Não calibrar clock PLL corretamente, levando a erros de frequência."
                                }
                              ],
                              "practicalExample": "Em um braço robótico mecatrônico com STM32F407 a 168MHz (pipeline 3 estágios), um loop de controle PID de 200 instruções executa em ~1.5µs (CPI=1.2 devido a 10% stalls). Reduzindo para 72MHz, tempo dobra para 3.3µs, mas consumo cai 50%, permitindo 2x mais ciclos em bateria para monitoramento contínuo.",
                              "finalVerifications": [
                                "Calcular corretamente throughput para programa com pipeline e stalls.",
                                "Identificar e quantificar impacto de clock em eficiência energética.",
                                "Simular/diagrama pipeline sem erros em hazards.",
                                "Propor trade-off clock/performance para aplicação mecatrônica específica.",
                                "Medir ciclos reais em simulador ou hardware com precisão <5%.",
                                "Documentar análise com fórmulas e resultados numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de CPI, throughput e consumo (erro <10%).",
                                "Compreensão demonstrada de stalls e otimização de pipeline.",
                                "Integração correta de fatores energéticos em análises de performance.",
                                "Uso adequado de ferramentas/simuladores com resultados verificáveis.",
                                "Clareza em diagramas, exemplos e relatórios.",
                                "Capacidade de propor otimizações práticas para cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Estágios de pipeline e lógica sequencial.",
                                "Física: Cálculo de potência dinâmica e eficiência térmica.",
                                "Programação Embarcada: Otimização de assembly e profiling.",
                                "Controle e Automação: Aplicação em loops de controle mecatrônicos.",
                                "Gestão de Energia: Trade-offs em sistemas embarcados IoT."
                              ],
                              "realWorldApplication": "Em sistemas mecatrônicos industriais como drones autônomos ou linhas de montagem com CLPs, otimizar clock e pipeline permite controle em tempo real (ex: 1kHz PID) com bateria estendida, reduzindo custos operacionais em 30% via eficiência energética."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Comparar conjuntos de instruções RISC vs CISC",
                            "description": "Avaliar microcontroladores RISC (ex: ARM Cortex-M) versus CISC (ex: 8051), focando em densidade de código e consumo de energia em projetos embarcados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de RISC e CISC",
                                  "subSteps": [
                                    "Pesquisar e definir RISC (Reduced Instruction Set Computing) como arquitetura com instruções simples e de tamanho fixo.",
                                    "Definir CISC (Complex Instruction Set Computing) como arquitetura com instruções complexas e de tamanho variável.",
                                    "Identificar características principais: RISC usa mais registradores e pipeline otimizado; CISC foca em instruções de alto nível.",
                                    "Estudar exemplos iniciais: ARM Cortex-M (RISC) vs. 8051 (CISC).",
                                    "Criar uma tabela comparativa básica de 5 atributos chave (ex: número de instruções, formato)."
                                  ],
                                  "verification": "Produzir uma tabela comparativa com definições e 5 atributos corretos, sem erros conceituais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Datasheet ARM Cortex-M",
                                    "Datasheet 8051",
                                    "Artigos Wikipedia ou tutorials sobre RISC/CISC"
                                  ],
                                  "tips": "Use diagramas de fluxo de instruções para visualizar pipelines simples vs. complexos.",
                                  "learningObjective": "Diferenciar conceitualmente RISC e CISC, identificando suas filosofias de design.",
                                  "commonMistakes": [
                                    "Confundir RISC com 'menos instruções totais' (RISC tem menos tipos, mas otimizadas)",
                                    "Ignorar que CISC moderno usa microcódigo para simular RISC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Conjuntos de Instruções e Características Técnicas",
                                  "subSteps": [
                                    "Listar 10 instruções típicas de RISC (ex: MOV, ADD, LDR em ARM) e comparar com CISC (ex: MUL, ADD em 8051).",
                                    "Comparar tamanho das instruções: fixo 32-bit em RISC vs. variável 8-24 bits em CISC.",
                                    "Estudar pipeline: RISC com 3-5 estágios vs. CISC com decodificação complexa.",
                                    "Analisar uso de registradores: RISC (16+ load/store) vs. CISC (poucos, memory operands).",
                                    "Simular execução de uma instrução ADD em ambos via ferramentas online."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como uma instrução ADD difere em execução entre ARM e 8051.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simuladores online como ARM Mbed ou 8051 IDE",
                                    "Manuais de instruções ARM/8051"
                                  ],
                                  "tips": "Foque em contagem de ciclos de clock por instrução para medir eficiência.",
                                  "learningObjective": "Comparar detalhes técnicos dos conjuntos de instruções e seu impacto no desempenho.",
                                  "commonMistakes": [
                                    "Assumir que todas as instruções CISC são 'melhores' para tarefas complexas sem considerar overhead",
                                    "Não considerar otimizações modernas em CISC"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Impacto na Densidade de Código em Projetos Embarcados",
                                  "subSteps": [
                                    "Escrever um programa assembly simples (ex: somar array de 10 números) em ARM Cortex-M.",
                                    "Escrever o mesmo programa em assembly 8051.",
                                    "Contar bytes de código gerado e calcular densidade (bytes por funcionalidade).",
                                    "Analisar razões: RISC gera código maior mas mais previsível; CISC mais compacto mas irregular.",
                                    "Otimizar ambos e recontar, notando ganhos relativos."
                                  ],
                                  "verification": "Apresentar códigos lado a lado com contagem de bytes e gráfico comparativo (RISC ~20% maior).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Compiladores/Assemblers: Keil para 8051, GCC ARM",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Use .hex dumps para medir tamanho exato; teste em emulador.",
                                  "learningObjective": "Quantificar densidade de código e trade-offs para memória limitada em embarcados.",
                                  "commonMistakes": [
                                    "Medir apenas linhas de código em vez de bytes reais",
                                    "Ignorar alinhamento de memória em RISC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar Consumo de Energia e Aplicações Práticas",
                                  "subSteps": [
                                    "Calcular ciclos de clock para o programa exemplo em ambos (RISC: mais instruções mas pipeline eficiente).",
                                    "Estimar consumo: Energia = Volts * Corrente * Tempo; comparar mJ por tarefa.",
                                    "Analisar cenários embarcados: RISC melhor para baixa potência (ex: sleep modes em ARM).",
                                    "Comparar benchmarks reais de datasheets (ex: MIPS/Watt para Cortex-M vs. 8051).",
                                    "Discutir seleção: RISC para IoT battery-powered; CISC para legacy compacto."
                                  ],
                                  "verification": "Produzir relatório com cálculos de energia mostrando RISC ~30-50% mais eficiente em cenários modernos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Datasheets com curvas de consumo",
                                    "Ferramentas de profiling como oscilloscope simulado"
                                  ],
                                  "tips": "Priorize frequência de clock baixa para comparação justa.",
                                  "learningObjective": "Avaliar trade-offs de energia em contextos de microcontroladores embarcados.",
                                  "commonMistakes": [
                                    "Focar só em clock speed sem considerar instruções por ciclo",
                                    "Não ajustar por voltagem típica (ARM 1.8V vs. 8051 5V)"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um contador LED piscante: Em ARM Cortex-M (RISC), código de 25 bytes leva ~100 ciclos; em 8051 (CISC), 15 bytes mas ~150 ciclos. RISC usa mais memória mas menos energia em 3.3V/8MHz.",
                              "finalVerifications": [
                                "Lista precisa de 5 diferenças chave entre RISC e CISC com exemplos de instruções.",
                                "Cálculo correto de densidade de código para um programa exemplo (bytes e % diferença).",
                                "Estimativa de consumo energético comparativa com justificativa baseada em ciclos/voltagem.",
                                "Explicação de quando escolher RISC vs. CISC em um projeto embarcado específico.",
                                "Tabela de benchmarks reais de ARM Cortex-M vs. 8051 de datasheets.",
                                "Identificação de 3 otimizações modernas que borram linhas RISC/CISC."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Definições e características sem erros (30%).",
                                "Análise quantitativa: Cálculos de densidade e energia corretos (25%).",
                                "Exemplos práticos: Códigos funcionais e comparáveis (20%).",
                                "Profundidade comparativa: Trade-offs discutidos com contexto embarcado (15%).",
                                "Clareza e organização: Tabelas/gráficos usados efetivamente (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly e Otimização de Código (Ciência da Computação).",
                                "Eletrônica Digital e Design de Circuitos Embarcados (Engenharia Elétrica).",
                                "Eficiência Energética e Sustentabilidade (Engenharia Ambiental).",
                                "Análise de Dados e Benchmarks (Estatística e Matemática Aplicada)."
                              ],
                              "realWorldApplication": "Em dispositivos IoT como sensores wearables, RISC (ARM Cortex-M) é preferido por baixo consumo de energia em bateria limitada, enquanto CISC (8051) persiste em controles industriais legados por densidade de código em memórias pequenas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Sistemas de Memória Integrados",
                        "description": "Tipos de memória em microcontroladores: Flash (programa), SRAM (dados), EEPROM (não-volátil), incluindo tamanhos, acesso e gerenciamento para aplicações de tempo real.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Classificar tipos de memória e suas funções",
                            "description": "Descrever Flash para firmware, SRAM para variáveis runtime e EEPROM para configurações persistentes, com exemplos de capacidades em famílias como MSP430.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de memória volátil e não-volátil",
                                  "subSteps": [
                                    "Defina memória volátil (perde dados sem energia) e não-volátil (mantém dados sem energia).",
                                    "Identifique exemplos comuns: SRAM como volátil e Flash/EEPROM como não-volátil.",
                                    "Explique o papel geral da memória em microcontroladores: armazenamento de código, dados temporários e configurações.",
                                    "Compare velocidade, custo e densidade entre tipos voláteis e não-voláteis.",
                                    "Revise hierarquia de memória em sistemas embarcados."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças entre volátil e não-volátil, incluindo exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Datasheet MSP430 (seção de memória), diagrama de hierarquia de memória impresso ou digital.",
                                  "tips": "Use analogias como quadro negro (volátil) vs caderno permanente (não-volátil) para fixar conceitos.",
                                  "learningObjective": "Diferenciar memórias voláteis e não-voláteis e seu impacto em microcontroladores.",
                                  "commonMistakes": "Confundir volatilidade com velocidade; SRAM é rápida mas volátil, Flash é mais lenta mas persistente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a memória Flash para firmware",
                                  "subSteps": [
                                    "Descreva Flash como memória não-volátil de alta capacidade para código de firmware.",
                                    "Explique ciclo de vida: programação em bloco, erase antes de write.",
                                    "Discuta limitações: número finito de ciclos de erase/write (tipicamente 10k-100k).",
                                    "Analise uso em bootloaders e programas principais.",
                                    "Identifique seção de info Flash em MSP430 para dados semi-permanentes."
                                  ],
                                  "verification": "Escreva uma tabela com características da Flash: capacidade típica (ex: 16-256 KB em MSP430), velocidade e ciclos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Datasheet MSP430FR series (seção 5.x Memória Flash), calculadora para converter tamanhos.",
                                  "tips": "Pense na Flash como o 'HD' do microcontrolador: grande, mas requer formatação periódica.",
                                  "learningObjective": "Explicar função da Flash em armazenar firmware executável de forma persistente.",
                                  "commonMistakes": "Achar que Flash é editável byte a byte como RAM; requer erase de setor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar SRAM para variáveis runtime e EEPROM para configurações persistentes",
                                  "subSteps": [
                                    "Descreva SRAM como RAM volátil para dados temporários durante execução (variáveis, stack).",
                                    "Explique EEPROM como não-volátil para dados editáveis byte a byte (calibrações, IDs).",
                                    "Compare capacidades: SRAM pequena (ex: 0.5-16 KB em MSP430), EEPROM limitada (ex: 256 bytes-2 KB).",
                                    "Discuta emulação de EEPROM via Flash em MSP430 para maior durabilidade.",
                                    "Liste cenários: SRAM para contadores em loop, EEPROM para thresholds de sensores."
                                  ],
                                  "verification": "Crie um fluxograma mostrando alocação de dados: código em Flash, vars em SRAM, configs em EEPROM.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Datasheet MSP430 (tabelas de memória), software simulador como Code Composer Studio.",
                                  "tips": "Visualize SRAM como 'memória de trabalho' que zera no reset, EEPROM como 'notas salvas'.",
                                  "learningObjective": "Classificar SRAM e EEPROM por função e persistência em runtime.",
                                  "commonMistakes": "Ignorar consumo de energia: SRAM drena corrente constante quando ativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar memórias com exemplos de capacidades em MSP430",
                                  "subSteps": [
                                    "Consulte datasheet MSP430: ex. MSP430FR2311 tem 8KB Flash, 2KB SRAM, 0B EEPROM (usa FRAM/Flash).",
                                    "Classifique: Flash (firmware 8KB), SRAM (runtime 2KB), emulada EEPROM via info Flash.",
                                    "Compare famílias: MSP430G2xx (Flash 1-32KB, SRAM 0.125-2KB), MSP430F5xx (até 256KB Flash).",
                                    "Crie tabela de classificação por função, capacidade e exemplos de uso.",
                                    "Simule alocação em um projeto simples (ex: contador persistente)."
                                  ],
                                  "verification": "Preencha tabela comparativa para 2 modelos MSP430, justificando classificações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Datasheets múltiplos MSP430 (G2, FR, F5 series), planilha Excel para tabelas.",
                                  "tips": "Sempre cheque seção 'Memory' no datasheet; capacidades variam por modelo exato.",
                                  "learningObjective": "Aplicar classificação prática com capacidades reais em MSP430.",
                                  "commonMistakes": "Generalizar capacidades sem modelo específico; MSP430 varia amplamente."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de motor MSP430FR2355 (32KB Flash, 4KB SRAM), armazene firmware de PID no Flash, variáveis de velocidade runtime na SRAM e configurações de ganho persistente na info Flash emulada como EEPROM. Ao reset, código e configs sobrevivem, mas velocidades zeram.",
                              "finalVerifications": [
                                "Liste corretamente os 3 tipos de memória e suas funções principais.",
                                "Cite capacidades típicas para MSP430G2553 (Flash 16KB, SRAM 512B, EEPROM emulada).",
                                "Explique por que não usar SRAM para configs persistentes.",
                                "Desenhe mapa de memória simples para um MSP430.",
                                "Diferencie erase/write de Flash vs byte-write de EEPROM.",
                                "Identifique uso de info Flash em MSP430 para dados não-voláteis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação: Flash=firmware, SRAM=runtime, EEPROM=persistente (100% correto).",
                                "Uso de exemplos reais MSP430 com capacidades exatas do datasheet.",
                                "Clareza em comparações volátil/não-volátil e funções.",
                                "Profundidade em limitações (ciclos, tamanho, energia).",
                                "Capacidade de criar tabelas/diagramas visuais acionáveis.",
                                "Aplicação contextual em mecatrônica (ex: sensores, controles)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Endereçamento e barramentos de memória.",
                                "Programação Embarcada: Alocação de variáveis em C para seções específicas.",
                                "Sistemas Embarcados: Gerenciamento de energia e retenção de dados.",
                                "Engenharia de Software: Otimização de código para limites de Flash/SRAM."
                              ],
                              "realWorldApplication": "Em robótica industrial MSP430-based, Flash armazena algoritmos de controle, SRAM gerencia loops de feedback em tempo real, e EEPROM salva calibrações de sensores após setup, garantindo operação autônoma sem perda de configurações em quedas de energia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Calcular requisitos de memória para uma aplicação",
                            "description": "Estimar alocação de memória para um programa mecatrônico simples, considerando overhead de stack e heap em microcontroladores de 8/16/32 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes de memória em microcontroladores",
                                  "subSteps": [
                                    "Estude a arquitetura de memória típica: Flash (programa), RAM (dados, stack, heap).",
                                    "Identifique diferenças entre MCUs de 8, 16 e 32 bits (ex: AVR 8-bit vs ARM Cortex-M).",
                                    "Aprenda sobre alocação estática (globais) vs dinâmica (malloc).",
                                    "Revise overheads: stack frame (8-16 bytes por função), heap fragmentation.",
                                    "Consulte datasheets de MCUs como ATmega328 (8-bit) ou STM32 (32-bit)."
                                  ],
                                  "verification": "Liste corretamente os 4 principais componentes de RAM e overheads em um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Datasheets de MCUs (ATmega, STM32), diagramas de memória online.",
                                  "tips": "Use ferramentas como MCU Memory Calculator para visualização inicial.",
                                  "learningObjective": "Dominar terminologia e estrutura de memória em MCUs de diferentes bits.",
                                  "commonMistakes": "Confundir Flash com RAM ou ignorar que stack cresce para baixo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar e estimar uso de memória estática do código",
                                  "subSteps": [
                                    "Compile o código com flags de mapfile (ex: -Wl,-Map=output.map em GCC).",
                                    "Identifique tamanhos: .text (código), .data (inicializadas), .bss (não inicializadas).",
                                    "Some variáveis globais e estáticas: int (2/4 bytes), arrays, structs.",
                                    "Estime para 8/16/32 bits: ajuste tamanhos de ponteiros (2/4 bytes).",
                                    "Gere relatório de uso estático via linker script ou IDE (Arduino IDE, Keil)."
                                  ],
                                  "verification": "Produza um relatório com tamanhos exatos de .data + .bss < 50% da RAM total.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Compilador GCC/ARM, IDE (PlatformIO), código fonte exemplo.",
                                  "tips": "Use #pragma para alinhamento e evite globals desnecessárias.",
                                  "learningObjective": "Calcular precisamente alocação estática considerando arquitetura do MCU.",
                                  "commonMistakes": "Esquecer .bss ou assumir tamanhos de dados iguais em todos os MCUs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar overhead dinâmico de stack e heap",
                                  "subSteps": [
                                    "Calcule profundidade máxima de stack: conte chamadas recursivas/aninhadas.",
                                    "Estime uso por frame: parâmetros + locais + return address (4-12 bytes).",
                                    "Para heap: some malloc/free, adicione 8-16 bytes de metadata por bloco.",
                                    "Simule worst-case: interrupções + funções profundas (use ferramentas como stack canary).",
                                    "Ajuste para 8-bit (stack pequeno, ~256B) vs 32-bit (até 64KB)."
                                  ],
                                  "verification": "Cálculo mostra stack max < 80% da RAM reservada e heap sem overflow.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramentas de análise (FreeRTOS stack monitor, Valgrind para simulação).",
                                  "tips": "Reserve 20% extra para stack; teste com osciloscópio em hardware real.",
                                  "learningObjective": "Prever uso dinâmico evitando stack overflow comum em embedded.",
                                  "commonMistakes": "Subestimar interrupções ou ignorar alignment padding em structs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular total de memória e otimizar",
                                  "subSteps": [
                                    "Some: código + estática + stack max + heap max + overheads (5-10%).",
                                    "Compare com specs do MCU (ex: ATmega: 2KB RAM; STM32: 128KB).",
                                    "Otimize: use const para Flash, bitfields, reduzir recursão.",
                                    "Valide com build final e linker warnings.",
                                    "Documente em relatório: uso % por seção."
                                  ],
                                  "verification": "Relatório final mostra uso total < 90% da memória disponível sem warnings.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Linker mapfile, calculadora ou planilha Excel.",
                                  "tips": "Priorize RAM crítica; migre para MCU maior se >95%.",
                                  "learningObjective": "Integrar todos cálculos para decisão de viabilidade de projeto.",
                                  "commonMistakes": "Não considerar fragmentation do heap ou linker padding."
                                }
                              ],
                              "practicalExample": "Para um controlador PID em ATmega328 (2KB RAM): variáveis globais (100B), código (1KB Flash), stack max 200B (5 funções aninhadas), heap 50B (1 malloc). Total RAM: 350B (17.5%), viável.",
                              "finalVerifications": [
                                "Cálculo de RAM total < limite do MCU com margem de 20%.",
                                "Stack depth estimado cobre worst-case incluindo ISRs.",
                                "Heap allocation considera metadata e fragmentation.",
                                "Relatório de linker confirma estimativas estáticas.",
                                "Otimização reduz uso em pelo menos 10%.",
                                "Teste simulado sem overflow em ferramenta de análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos estáticos (±5% do mapfile real).",
                                "Correta consideração de overheads por arquitetura (8/16/32 bits).",
                                "Análise dinâmica cobre cenários worst-case.",
                                "Relatório claro com % de uso e recomendações.",
                                "Evidência de otimização aplicada.",
                                "Validação cruzada com datasheet do MCU."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos aritméticos e estimativas percentuais.",
                                "Programação: Análise de código assembly/link-time.",
                                "Eletrônica: Leitura de datasheets e hardware constraints.",
                                "Gestão de Projetos: Avaliação de viabilidade e trade-offs."
                              ],
                              "realWorldApplication": "Em desenvolvimento de firmware para drones ou robôs industriais, garante estabilidade evitando crashes por memory overflow, otimizando custo (MCU menor) e performance em IoT/automação."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Explicar mecanismos de proteção e wear-leveling",
                            "description": "Analisar proteção de memória por hardware e técnicas de wear-leveling em Flash EEPROM para durabilidade em sistemas embarcados industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos da Memória Flash EEPROM e Limitações de Durabilidade",
                                  "subSteps": [
                                    "Estude a estrutura física das células Flash (floating-gate ou charge-trap)",
                                    "Analise o processo de programação (tunneling) e erasure (Fowler-Nordheim)",
                                    "Identifique as limitações de ciclos de escrita/erasure (tipicamente 10.000-100.000 por bloco)",
                                    "Compare NOR Flash (execução in loco) vs NAND Flash (alta densidade)",
                                    "Calcule endurance em cenários reais de uso industrial"
                                  ],
                                  "verification": "Crie um diagrama da célula Flash e liste 3 limitações principais com exemplos numéricos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Datasheet de MCU como STM32 ou PIC32",
                                    "Vídeos tutoriais sobre operação Flash (YouTube/Khan Academy)",
                                    "Simulador de memória como Tinkercad"
                                  ],
                                  "tips": [
                                    "Use analogias como 'células desgastam como pneus de carro'; foque em blocos/erases em vez de bytes."
                                  ],
                                  "learningObjective": "Compreender as bases físicas que motivam proteção e wear-leveling.",
                                  "commonMistakes": [
                                    "Confundir Flash com EEPROM byte-addressable",
                                    "Ignorar que erasures são por bloco, não byte",
                                    "Subestimar impacto de temperatura em endurance"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mecanismos de Proteção de Memória por Hardware",
                                  "subSteps": [
                                    "Explore Error Correction Codes (ECC) para detecção/correção de erros de bit único/múltiplo",
                                    "Estude lock bits e proteção de leitura/escrita (read-out protection levels)",
                                    "Analise proteção contra overvoltage/undervoltage e brown-out detection",
                                    "Examine watchdog timers integrados para reset em falhas de memória",
                                    "Revise redundância como mirroring ou parity bits em regiões críticas"
                                  ],
                                  "verification": "Descreva como ECC corrige um erro de 1-bit em um byte e liste 2 proteções de hardware em um datasheet específico.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Datasheet de ATmega ou ESP32",
                                    "Ferramenta de análise como IAR Embedded Workbench demo",
                                    "Artigos IEEE sobre ECC em memórias embarcadas"
                                  ],
                                  "tips": [
                                    "Sempre verifique o status register após operações de memória para flags de erro."
                                  ],
                                  "learningObjective": "Identificar e explicar proteções hardware que previnem corrupção de dados.",
                                  "commonMistakes": [
                                    "Achar que ECC é só software",
                                    "Confundir lock bits com criptografia",
                                    "Esquecer proteções contra falhas de alimentação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Técnicas de Wear-Leveling para Prolongar Vida Útil",
                                  "subSteps": [
                                    "Diferencie wear-leveling estático (pré-mapeado) vs dinâmico (baseado em uso)",
                                    "Estude algoritmos como round-robin, counter-based e hot/cold data separation",
                                    "Analise gerenciamento de bad blocks (factory e runtime marking)",
                                    "Implemente um exemplo simples de wear-leveling em pseudocódigo",
                                    "Avalie trade-offs: overhead de performance vs ganho em endurance"
                                  ],
                                  "verification": "Escreva pseudocódigo para um algoritmo round-robin e calcule redução de wear em 50% de uso desigual.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código exemplo de FTL (Flash Translation Layer) open-source",
                                    "Simulador de Flash como FlashSim",
                                    "Documentação de NVM em MCUs ARM Cortex-M"
                                  ],
                                  "tips": [
                                    "Monitore contadores de erase por bloco via debug tools para validar leveling."
                                  ],
                                  "learningObjective": "Dominar técnicas que distribuem desgaste uniformemente na memória Flash.",
                                  "commonMistakes": [
                                    "Implementar leveling sem considerar bad blocks",
                                    "Usar contadores lineares sem overflow protection",
                                    "Ignorar overhead de garbage collection"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração e Análise em Sistemas Embarcados Industriais",
                                  "subSteps": [
                                    "Avalie impacto de proteção/wear-leveling em RTOS como FreeRTOS",
                                    "Simule falhas em ambientes industriais (vibração, temperatura extrema)",
                                    "Compare implementações em CLPs vs microcontroladores (ex: Siemens S7 vs Arduino Industrial)",
                                    "Desenvolva um plano de teste para durabilidade (aceleração de writes)",
                                    "Discuta certificações como IEC 61508 para SIL em memórias críticas"
                                  ],
                                  "verification": "Crie um relatório de 1 página analisando wear-leveling em um MCU industrial real.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplos de firmware industrial (GitHub repos)",
                                    "Osciloscópio ou multímetro para testes reais",
                                    "Normas IEC 61508 resumo"
                                  ],
                                  "tips": [
                                    "Teste em loop de escrita com delays para simular anos de operação em horas."
                                  ],
                                  "learningObjective": "Aplicar conceitos a contextos industriais para durabilidade garantida.",
                                  "commonMistakes": [
                                    "Não considerar power cycling em testes",
                                    "Subestimar efeitos de radiação/EMC",
                                    "Ignorar logging de erros para debug"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de monitoramento industrial com ESP32, implemente um data logger que registra sensores a cada minuto. Use wear-leveling dinâmico para distribuir writes em 4 blocos Flash de 64KB, aplicando ECC e lock bits na região de calibração. Simule 1 ano de operação (500k writes) acelerado, verificando endurance via contadores e corrigindo erros simulados com flips de bit.",
                              "finalVerifications": [
                                "Explique verbalmente como ECC detecta/corrige erros em um bloco Flash corrompido.",
                                "Desenhe um fluxograma de um algoritmo de wear-leveling dinâmico.",
                                "Calcule a vida útil estendida de uma memória com 10k ciclos/bloco sob uso desigual.",
                                "Identifique 3 proteções hardware em um datasheet de MCU fornecido.",
                                "Simule uma falha de bad block e demonstre recuperação.",
                                "Compare overhead de wear-leveling vs sem ele em um cenário industrial."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Conceitos corretos sem erros factuais (30%)",
                                "Profundidade: Detalhes sobre algoritmos e hardware (25%)",
                                "Aplicação prática: Exemplos relevantes a embarcados industriais (20%)",
                                "Clareza: Diagramas e explicações acionáveis (15%)",
                                "Análise crítica: Trade-offs e limitações discutidos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Correlação com flip-flops e lógica de proteção contra glitches.",
                                "Programação Embarcada: Integração com drivers HAL para NVM e RTOS tasks.",
                                "Confiabilidade de Sistemas: Alinhamento com fault-tolerance e SIL levels.",
                                "Física de Semicondutores: Ligação com tunelamento quântico e degradação oxide.",
                                "Gestão de Projetos Industriais: Planejamento de testes de durabilidade acelerada."
                              ],
                              "realWorldApplication": "Em PLCs industriais como Allen-Bradley ou Siemens, wear-leveling e proteções ECC garantem armazenamento confiável de receitas de produção e logs de falhas por 10+ anos em fábricas automotivas, prevenindo downtime custoso por falha de memória em ambientes de alta vibração e temperatura (ex: fornos de solda)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Periféricos On-Chip",
                        "description": "Periféricos integrados como timers, ADCs, DACs, PWM e GPIOs, otimizados para controle em tempo real em sistemas mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Listar e descrever periféricos essenciais",
                            "description": "Identificar timers, conversores A/D, PWM e UART em datasheets de microcontroladores como Arduino ou ESP32 para aplicações de sensores e atuadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter e Navegar no Datasheet do Microcontrolador",
                                  "subSteps": [
                                    "Baixe o datasheet oficial do Arduino Uno (baseado em ATmega328P) ou ESP32 do site do fabricante.",
                                    "Identifique as seções principais: visão geral, pinout, periféricos on-chip e descrições detalhadas.",
                                    "Use a função de busca (Ctrl+F) para localizar termos como 'Timer', 'ADC', 'PWM' e 'UART'.",
                                    "Anote a página ou seção de cada periférico encontrado.",
                                    "Crie um índice pessoal dos periféricos essenciais listados."
                                  ],
                                  "verification": "Confirme que você localizou as seções de pelo menos 4 periféricos no datasheet e anotou as páginas corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Datasheet PDF do ATmega328P ou ESP32, leitor de PDF (Adobe Reader ou browser), caderno para anotações.",
                                  "tips": "Sempre priorize o datasheet oficial em vez de tutoriais online para precisão técnica.",
                                  "learningObjective": "Dominar a navegação em documentos técnicos de hardware para localizar informações específicas.",
                                  "commonMistakes": "Confundir datasheets de diferentes microcontroladores; ignorar versão do chip (ex: ATmega328P vs ATmega328)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Descrever Timers",
                                  "subSteps": [
                                    "Localize a seção de 'Timers/Counters' no datasheet.",
                                    "Descreva funções: contagem de tempo, geração de delays, PWM básico.",
                                    "Identifique características: número de timers (ex: 3 em ATmega328P), resolução (8/16-bit), modos (normal, CTC, PWM).",
                                    "Note pinos associados e registros de configuração (ex: TCCR0A).",
                                    "Explique aplicação em sensores: debounce de botões ou scheduling de leituras."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras sobre timers, incluindo specs chave do datasheet.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Datasheet aberto na seção de timers, highlighter digital ou físico.",
                                  "tips": "Compare timers de Arduino vs ESP32 para notar diferenças em quantidade e capacidades.",
                                  "learningObjective": "Compreender o papel dos timers em controle temporal para sistemas embarcados.",
                                  "commonMistakes": "Confundir timers com PWM (PWM usa timers internamente); ignorar overflow em contagens 8-bit."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Descrever Conversores A/D (ADC)",
                                  "subSteps": [
                                    "Encontre a seção 'ADC' ou 'Analog-to-Digital Converter'.",
                                    "Descreva operação: conversão de sinal analógico (sensor) para digital.",
                                    "Liste specs: resolução (10-bit no Arduino), canais (6 no ATmega328P), velocidade de amostragem.",
                                    "Identifique registros (ADMUX, ADCSRA) e pinos analógicos (A0-A5).",
                                    "Relacione com atuadores: leitura de sensores como potenciômetros ou termistores."
                                  ],
                                  "verification": "Desenhe um diagrama simples do fluxo ADC e anote valores de referência do datasheet.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Datasheet, papel para diagrama, calculadora para fórmulas de conversão.",
                                  "tips": "Lembre-se da fórmula de conversão: Valor = (Voltagem / Vref) * (2^resolução - 1).",
                                  "learningObjective": "Capacitar identificação de interfaces analógicas para integração de sensores.",
                                  "commonMistakes": "Esquecer referência de tensão (5V Arduino, 3.3V ESP32); confundir com DAC (não presente nesses chips)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Descrever PWM e UART",
                                  "subSteps": [
                                    "Para PWM: Localize 'Timer PWM Mode'; descreva modulação de largura de pulso para controle analógico simulado.",
                                    "Liste pinos PWM (ex: 3,5,6,9,10,11 no Arduino), frequência e duty cycle.",
                                    "Para UART: Encontre 'USART' ou 'Serial Interface'; descreva comunicação serial assíncrona.",
                                    "Note baud rates suportados, pinos TX/RX, buffers FIFO no ESP32.",
                                    "Conecte a aplicações: PWM para motores/servos, UART para debug ou comunicação com PC."
                                  ],
                                  "verification": "Crie uma tabela comparativa de PWM vs UART com pelo menos 5 características cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Datasheet, planilha ou tabela em documento.",
                                  "tips": "PWM não é analógico verdadeiro; teste frequências para evitar ruído audível em atuadores.",
                                  "learningObjective": "Diferenciar saídas digitais controladas e comunicação serial para atuadores e rede.",
                                  "commonMistakes": "Confundir PWM com sinal analógico; ignorar pull-up em UART para estabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Periféricos para Aplicações de Sensores e Atuadores",
                                  "subSteps": [
                                    "Revise todos os periféricos e crie um mapa de uso: ADC lê sensor, Timer agenda, PWM controla atuador, UART envia dados.",
                                    "Exemplo: Sensor de luz (ADC) -> Timer para polling -> PWM para LED -> UART para log.",
                                    "Compare Arduino vs ESP32: mais UARTs e timers no ESP32 para IoT.",
                                    "Liste limitações on-chip e quando usar shields externos.",
                                    "Documente em um relatório final com lista e descrições."
                                  ],
                                  "verification": "Produza um diagrama de sistema usando esses periféricos para um sensor de temperatura com display.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de diagrama (Draw.io ou papel), relatório consolidado.",
                                  "tips": "Pense em eficiência: use interrupções de timer para evitar polling constante.",
                                  "learningObjective": "Aplicar conhecimentos de periféricos em cenários reais de mecatrônica.",
                                  "commonMistakes": "Sobrecarregar pinos multifuncionais sem verificar conflitos no datasheet."
                                }
                              ],
                              "practicalExample": "Em um projeto de irrigação automática: Use ADC para ler umidade do solo (sensor analógico), Timer para verificar a cada 10s, PWM para controlar bomba d'água (velocidade variável), e UART para enviar alertas via Serial Monitor para um app móvel.",
                              "finalVerifications": [
                                "Lista correta dos 4 periféricos com páginas do datasheet.",
                                "Descrições precisas incluindo funções, specs e pinos.",
                                "Exemplo de aplicação integrada para sensores/atuadores.",
                                "Tabela comparativa Arduino vs ESP32.",
                                "Diagrama de fluxo mostrando interações entre periféricos.",
                                "Identificação de pelo menos 3 limitações por periférico."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica das descrições (baseado em datasheet): 30%",
                                "Completude da lista e specs chave: 25%",
                                "Clareza e organização das anotações/tabelas: 20%",
                                "Relevância para aplicações em sensores/atuadores: 15%",
                                "Identificação de erros comuns e soluções: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Entender sinais analógicos/digitais e pinouts.",
                                "Programação: Configuração via código (ex: analogRead(), Serial.begin()).",
                                "Física: Princípios de temporização, conversão analógica e controle proporcional.",
                                "IoT/Redes: UART como base para comunicação sem fio (WiFi no ESP32)."
                              ],
                              "realWorldApplication": "Em robótica industrial, esses periféricos permitem que microcontroladores como ESP32 leiam sensores ambientais (ADC), controlem motores (PWM), gerenciem tarefas periódicas (Timers) e comuniquem com PLCs ou nuvem (UART), otimizando sistemas autônomos como drones ou linhas de montagem."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Configurar timers e interrupções",
                            "description": "Demonstrar configuração de timers para geração de PWM e handling de interrupções em cenários de controle mecatrônico, como motores DC.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender fundamentos de timers e interrupções",
                                  "subSteps": [
                                    "Estudar o funcionamento de timers em microcontroladores (contador, prescaler, modos de operação).",
                                    "Analisar tipos de interrupções (externas, de timer overflow, de comparação).",
                                    "Revisar geração de PWM via timers (modo de comparação, captura).",
                                    "Explorar exemplos de código para timers em microcontroladores como STM32 ou AVR.",
                                    "Identificar diferenças entre polling e interrupções."
                                  ],
                                  "verification": "Resumir em um diagrama os componentes de um timer e fluxo de interrupção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Datasheet do microcontrolador (ex: STM32F4)",
                                    "IDE como STM32CubeIDE ou Arduino IDE",
                                    "Documentação de periféricos"
                                  ],
                                  "tips": "Use diagramas de timing para visualizar ciclos de clock e overflow.",
                                  "learningObjective": "Entender os princípios teóricos de timers e interrupções para configuração prática.",
                                  "commonMistakes": [
                                    "Confundir prescaler com clock source",
                                    "Ignorar prioridade de interrupções",
                                    "Não considerar latência de ISR"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar timer para geração de PWM",
                                  "subSteps": [
                                    "Selecionar timer e pino PWM no microcontrolador.",
                                    "Configurar registradores: período (ARR), duty cycle (CCR), prescaler.",
                                    "Habilitar modo PWM e iniciar timer.",
                                    "Testar saída PWM com osciloscópio ou multímetro.",
                                    "Ajustar frequência e duty cycle via código."
                                  ],
                                  "verification": "Medir sinal PWM com frequência e duty cycle corretos no osciloscópio.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Placa de desenvolvimento (STM32 Nucleo ou Arduino)",
                                    "Osciloscópio ou multímetro",
                                    "Motor DC e driver (opcional)"
                                  ],
                                  "tips": "Comece com frequências baixas (1kHz) para facilitar medição.",
                                  "learningObjective": "Configurar hardware e software para gerar sinal PWM preciso.",
                                  "commonMistakes": [
                                    "Configurar ARR incorreto levando a frequência errada",
                                    "Esquecer de habilitar clock do timer",
                                    "Duty cycle >100% causando overflow"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar handling de interrupções",
                                  "subSteps": [
                                    "Configurar vetor de interrupções e prioridade (NVIC).",
                                    "Escrever função ISR (Interrupt Service Routine) para timer ou externa.",
                                    "Habilitar interrupção global e flag de interrupção.",
                                    "Implementar debounce ou debounce lógico em ISR.",
                                    "Testar trigger de interrupção com LED ou serial debug."
                                  ],
                                  "verification": "ISR executa e toggle de LED ou print serial ocorre no trigger esperado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Mesmos da etapa anterior",
                                    "Cabo jumper para sinal externo (opcional)"
                                  ],
                                  "tips": "Mantenha ISR curta (<10 linhas) para evitar perda de interrupções.",
                                  "learningObjective": "Gerenciar interrupções de forma eficiente e sem bloqueios.",
                                  "commonMistakes": [
                                    "Não limpar flag de interrupção",
                                    "ISR infinita por recursão",
                                    "Prioridade errada causando starvation"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar PWM e interrupções em controle de motor DC",
                                  "subSteps": [
                                    "Conectar motor DC via driver (ex: L298N) ao pino PWM.",
                                    "Usar interrupção de encoder ou Hall para feedback de rotação.",
                                    "Implementar loop de controle simples (ajustar PWM baseado em interrupções).",
                                    "Testar variação de velocidade e resposta a mudanças.",
                                    "Otimizar código com debounce e filtros."
                                  ],
                                  "verification": "Motor varia velocidade proporcionalmente ao duty cycle; feedback de interrupção preciso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Motor DC com encoder",
                                    "Driver de motor",
                                    "Fonte de alimentação",
                                    "Multímetro para corrente"
                                  ],
                                  "tips": "Monitore corrente do motor para evitar sobrecarga durante testes.",
                                  "learningObjective": "Aplicar timers e interrupções em um sistema mecatrônico real.",
                                  "commonMistakes": [
                                    "Ruído no encoder causando interrupções falsas",
                                    "PWM frequência inadequada para motor (audível)",
                                    "Não sincronizar ISR com PWM update"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um timer no STM32 para gerar PWM de 1kHz em um pino conectado a um driver L298N que controla um motor DC. Use uma interrupção de timer overflow para ler um encoder óptico no motor e ajustar o duty cycle para manter velocidade constante sob carga variável.",
                              "finalVerifications": [
                                "Sinal PWM gerado com frequência e duty cycle configuráveis (verificado por osciloscópio).",
                                "ISR de interrupção executa sem perda de eventos (contador de interrupções via serial).",
                                "Motor DC responde linearmente ao duty cycle (medição de RPM via encoder).",
                                "Sistema estável sob variação de carga (teste com peso adicionado).",
                                "Código compila e roda sem crashes ou watchdog resets.",
                                "Eficiência energética: corrente média < limite do driver."
                              ],
                              "assessmentCriteria": [
                                "Precisão do PWM: erro de frequência <5%.",
                                "Latência de interrupção <1ms.",
                                "Controle de velocidade: variação de RPM <10% sob carga.",
                                "Código limpo: comentários, funções modulares, sem warnings de compilação.",
                                "Segurança: proteções contra stall do motor e overflow.",
                                "Escalabilidade: fácil ajuste de parâmetros via defines."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: manipuladores de registradores e ISRs.",
                                "Eletrônica: análise de sinais PWM e encoders.",
                                "Física: dinâmica rotacional e controle PID básico.",
                                "Matemática: cálculo de prescaler e duty cycle.",
                                "Automação: integração com CLPs em cenários industriais."
                              ],
                              "realWorldApplication": "Controle preciso de velocidade em robôs industriais, drones para estabilização de motores, linhas de montagem para sincronização de esteiras transportadoras e veículos autônomos para tração diferencial."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Avaliar precisão de ADCs e DACs",
                            "description": "Calcular resolução e taxa de amostragem de ADCs em microcontroladores para aquisição de sinais analógicos em robótica aeronáutica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de ADCs e DACs",
                                  "subSteps": [
                                    "Estude a conversão analógico-digital (ADC) e digital-analógico (DAC), identificando funções principais em microcontroladores.",
                                    "Revise parâmetros chave: resolução (bits), faixa de tensão de entrada, taxa de amostragem (SPS).",
                                    "Analise diagrama de funcionamento de um ADC SAR típico usado em microcontroladores como STM32 ou Arduino.",
                                    "Compare ADCs on-chip com módulos externos em termos de precisão e integração.",
                                    "Identifique o papel na aquisição de sinais analógicos em robótica aeronáutica, como sensores de pressão."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes de um ADC e liste 3 diferenças entre ADC e DAC.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Datasheet de microcontrolador (ex: STM32F4), vídeo tutorial sobre ADCs (YouTube/Khan Academy), caderno para anotações.",
                                  "tips": "Use analogias como 'escada' para resolução para visualizar quantização.",
                                  "learningObjective": "Explicar o funcionamento básico de ADCs e DACs e seu papel em sistemas embarcados.",
                                  "commonMistakes": "Confundir resolução com precisão; resolução é bits, precisão inclui ruído e linearidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Resolução de ADCs",
                                  "subSteps": [
                                    "Calcule resolução em volts por LSB: Resolução = Vref / (2^n), onde n é número de bits.",
                                    "Exemplo: Para ADC de 12 bits e Vref=3.3V, calcule LSB e erro máximo de quantização.",
                                    "Considere impacto de Vref instável na precisão efetiva.",
                                    "Aplique fórmula para cenários reais: sensor de 0-5V com ADC 10 bits.",
                                    "Registre cálculos em tabela comparativa para diferentes resoluções (8, 10, 12 bits)."
                                  ],
                                  "verification": "Resolva 3 problemas de cálculo de resolução e verifique com calculadora online.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora científica, planilha Excel/Google Sheets para fórmulas, exemplos de datasheets.",
                                  "tips": "Sempre verifique unidades: Vref em volts, resultado em mV/LSB para precisão.",
                                  "learningObjective": "Dominar cálculo de resolução e entender seu impacto na precisão de medição.",
                                  "commonMistakes": "Esquecer de subtrair 1 no denominador (2^n -1 para full scale)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar Taxa de Amostragem Adequada",
                                  "subSteps": [
                                    "Estude Teorema de Nyquist-Shannon: fs >= 2 * f_max.",
                                    "Calcule taxa mínima para sinais em robótica aeronáutica (ex: vibração 1kHz -> fs=2.5kHz).",
                                    "Considere limitações de microcontroladores: clock ADC, overhead de processamento.",
                                    "Avalie aliasing e use filtros anti-aliasing virtuais.",
                                    "Simule em software: gere sinal senoidal e amostre abaixo/acima de Nyquist."
                                  ],
                                  "verification": "Crie gráfico mostrando aliasing para fs insuficiente usando Python/MATLAB.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software Python com NumPy/Matplotlib ou MATLAB Online, osciloscópio virtual (Falstad).",
                                  "tips": "Margem de segurança: use fs = 2.5-5 * f_max para ruído real.",
                                  "learningObjective": "Calcular e justificar taxa de amostragem para evitar distorções em sinais analógicos.",
                                  "commonMistakes": "Ignorar overhead do microcontrolador, levando a fs efetiva menor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Microcontroladores para Robótica Aeronáutica",
                                  "subSteps": [
                                    "Selecione ADC de um microcontrolador (ex: ESP32 ADC2, 12 bits, 100ksps).",
                                    "Configure via código: inicialize ADC, defina resolução e taxa em Arduino IDE.",
                                    "Adquira sinal de sensor simulado (potenciômetro como acelerômetro de drone).",
                                    "Calcule precisão real: compare leituras com multímetro.",
                                    "Otimize para aeronáutica: ajuste para ruído EMI em drones."
                                  ],
                                  "verification": "Execute código e gere relatório com 10 medições, calculando erro médio.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Placa microcontrolador (Arduino/ESP32), potenciômetro, breadboard, multímetro, IDE Arduino.",
                                  "tips": "Use média de múltiplas amostras para melhorar SNR.",
                                  "learningObjective": "Integrar cálculos de precisão em projeto prático com microcontrolador.",
                                  "commonMistakes": "Não calibrar ADC; offsets internos afetam precisão."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Otimizar Precisão Geral",
                                  "subSteps": [
                                    "Combine resolução e taxa: calcule ENOB (Effective Number of Bits).",
                                    "Teste INL/DNL de datasheet vs. medições reais.",
                                    "Otimize: oversampling para aumentar resolução efetiva.",
                                    "Avalie DACs semelhantes para saída em atuadores aeronáuticos.",
                                    "Documente trade-offs: precisão vs. velocidade/custo."
                                  ],
                                  "verification": "Produza tabela de avaliação com métricas calculadas para um caso de drone.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Datasheets múltiplos, software de análise (Excel/Python).",
                                  "tips": "ENOB = (SNR - 1.76)/6.02 para estimar precisão real.",
                                  "learningObjective": "Avaliar precisão holística e propor otimizações.",
                                  "commonMistakes": "Focar só em bits nominais, ignorando ruído e não-linearidades."
                                }
                              ],
                              "practicalExample": "Em um drone para monitoramento aeronáutico, use ADC 12 bits de ESP32 para ler sensor de acelerômetro (0-5g, sinal 0-3.3V). Calcule resolução: 3.3V/4096 ≈ 0.8mV/LSB (equivalente a 0.004g). Taxa: vibrações até 500Hz -> fs=2.5ksps. Teste código para aquisição e plote sinal para verificar precisão.",
                              "finalVerifications": [
                                "Cálculos de resolução coincidem com fórmulas e exemplos reais (±1%).",
                                "Gráficos de amostragem mostram ausência de aliasing.",
                                "Código roda sem erros e leituras estão dentro de 5% do esperado.",
                                "Relatório inclui trade-offs e otimizações propostas.",
                                "Testes práticos com hardware validam simulações.",
                                "ENOB calculado reflete datasheet."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de resolução e taxa (90% acerto).",
                                "Compreensão demonstrada em explicações e diagramas.",
                                "Aplicação prática funcional em microcontrolador.",
                                "Identificação correta de erros comuns e soluções.",
                                "Relatório completo com exemplos aeronáuticos.",
                                "Criatividade em otimizações (ex: oversampling)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Analógica: Filtros e amplificadores para sinais de entrada.",
                                "Programação Embarcada: Configuração de registradores ADC em C/Arduino.",
                                "Física: Teorema de Nyquist e dinâmica de sinais em aeronáutica.",
                                "Matemática: Cálculos exponenciais e análise estatística de ruído.",
                                "Engenharia de Controle: Feedback com DACs em atuadores de drones."
                              ],
                              "realWorldApplication": "Em robótica aeronáutica, como drones para inspeção de turbinas, ADCs precisos leem sensores de vibração/temperatura para detecção de falhas em tempo real, evitando acidentes e otimizando manutenção preditiva."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.4",
                            "name": "Integrar GPIOs com modos especiais",
                            "description": "Explicar modos pull-up/pull-down e alternos em GPIOs para interfaces com sensores e atuadores em projetos embarcados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de modos pull-up/pull-down e alternos em GPIOs",
                                  "subSteps": [
                                    "Estude o funcionamento de resistores pull-up e pull-down para evitar estados flutuantes em entradas digitais.",
                                    "Analise como o modo pull-up conecta o pino a Vcc via resistor interno, e pull-down a GND.",
                                    "Explore modos alternos (AF) que remapeiam GPIOs para periféricos como UART, SPI, I2C ou PWM.",
                                    "Revise a documentação do microcontrolador (ex: STM32 ou AVR) sobre registradores GPIO (MODER, PUPDR, AFR).",
                                    "Identifique diferenças entre modos de entrada, saída, pull e alterno."
                                  ],
                                  "verification": "Resuma em um diagrama ou tabela os modos e suas configurações de registradores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Datasheet do microcontrolador, editor de texto para anotações.",
                                  "tips": "Use simuladores como Tinkercad ou Proteus para visualizar circuitos virtuais.",
                                  "learningObjective": "Explicar o propósito e configuração básica de cada modo GPIO especial.",
                                  "commonMistakes": "Confundir pull-up com pull-down; ignorar que pull-up interno tipicamente é 20-50kΩ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar GPIOs em modos pull-up/pull-down",
                                  "subSteps": [
                                    "Selecione um pino GPIO e configure-o como entrada com pull-up via registrador PUPDR (ex: 01 para pull-up).",
                                    "Escreva código para inicializar o GPIO (ex: em C para STM32: GPIOx->MODER &= ~(3<<pin*2); GPIOx->PUPDR |= (1<<pin*2)).",
                                    "Conecte um botão ao pino e GND, teste leitura lógica alta quando solto.",
                                    "Altere para pull-down (10 no PUPDR) e verifique leitura baixa quando solto.",
                                    "Meça tensão no pino com multímetro para validar."
                                  ],
                                  "verification": "O pino lê HIGH com pull-up (botão solto) e LOW com pull-down; sem flutuação.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Placa de microcontrolador (ex: Arduino/STM32 Nucleo), botão push, multímetro, fios jumper.",
                                  "tips": "Ative pull interno para economizar componentes externos.",
                                  "learningObjective": "Implementar e testar configurações pull-up/pull-down em código.",
                                  "commonMistakes": "Esquecer de configurar MODER como entrada (00); usar saída acidentalmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar GPIOs em modos alternos para periféricos",
                                  "subSteps": [
                                    "Identifique pinos AF suportados (ex: PA5 para SPI1_MOSI em STM32).",
                                    "Configure MODER para AF (10) e AFR para o modo correto (ex: AFR[0] para AF0-7).",
                                    "Habilite o periférico clock (RCC) e configure-o (ex: SPI_Init).",
                                    "Conecte um dispositivo como display I2C (SDA/SCL em AF) ou sensor SPI.",
                                    "Teste comunicação enviando/recebendo dados."
                                  ],
                                  "verification": "Comunicação bem-sucedida: dados lidos do sensor ou display atualizado.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "Placa de desenvolvimento, sensor I2C (ex: BMP280), osciloscópio ou logic analyzer opcional.",
                                  "tips": "Verifique pinout no datasheet; use bibliotecas HAL para simplificar.",
                                  "learningObjective": "Remapear GPIOs para funções periféricas via modos alternos.",
                                  "commonMistakes": "Configurar AFR errado (low/high register); esquecer clock do periférico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar GPIOs com sensores e atuadores em projeto prático",
                                  "subSteps": [
                                    "Monte circuito: botão com pull-up para input, LED com PWM (AF para timer).",
                                    "Escreva código integrando: ler botão → ativar PWM no LED.",
                                    "Adicione sensor analógico via ADC (AF) com pull-down se necessário.",
                                    "Teste estabilidade e debounce do botão.",
                                    "Otimize código para uso em loop principal."
                                  ],
                                  "verification": "Botão pressed toggles LED PWM; sensor lê valores estáveis sem ruído.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Circuito completo: botão, LED, resistor, sensor (ex: potênciometro), protoboard.",
                                  "tips": "Use interrupts para botões para eficiência.",
                                  "learningObjective": "Aplicar modos especiais em interface sensor-atualizador.",
                                  "commonMistakes": "Ruído em inputs sem pull; conflito de pinos AF."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de motor: use pull-up em switch de segurança (entrada), PWM em pino AF para velocidade do motor (saída), e I2C AF para encoder de posição.",
                              "finalVerifications": [
                                "GPIOs configurados corretamente sem conflitos de modo.",
                                "Entradas estáveis (sem flutuação medida >0.3V).",
                                "Periféricos AF funcionam (ex: dados SPI/I2C válidos).",
                                "Projeto integrado responde corretamente a inputs.",
                                "Código comentado explica registradores usados.",
                                "Testes com multímetro confirmam tensões esperadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de registradores MODER/PUPDR/AFR.",
                                "Estabilidade de sinais em pull-up/down (sem bounce excessivo).",
                                "Funcionamento correto de periféricos em modo AF.",
                                "Integração lógica entre sensor e atuador.",
                                "Eficiência do código (sem busy-wait desnecessário).",
                                "Documentação clara de testes e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Análise de circuitos com resistores internos.",
                                "Programação: Manipulação de registradores em C/Assembly.",
                                "Física: Comportamento de sinais digitais e ruído.",
                                "Engenharia de Software: Modularidade em firmware embarcado."
                              ],
                              "realWorldApplication": "Desenvolvimento de robôs autônomos, onde GPIOs com pull-up leem sensores de proximidade, PWM controla motores via AF, e I2C comunica com IMU para navegação estável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.4",
                        "name": "Interfaces de Comunicação",
                        "description": "Protocolos integrados como UART, SPI, I2C, CAN e USB para interconexão em sistemas mecatrônicos distribuídos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.4.1",
                            "name": "Comparar protocolos seriais síncronos e assíncronos",
                            "description": "Diferenciar SPI/I2C (síncronos, multi-dispositivo) de UART (assíncrono, ponto-a-ponto) em termos de velocidade e complexidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Comunicação Serial Síncrona e Assíncrona",
                                  "subSteps": [
                                    "Defina comunicação serial e seus tipos principais (síncrona vs. assíncrona).",
                                    "Explique o papel do clock em protocolos síncronos para sincronização de dados.",
                                    "Descreva como protocolos assíncronos usam bits de start/stop para sincronização.",
                                    "Identifique vantagens iniciais: síncronos para alta velocidade, assíncronos para simplicidade.",
                                    "Pesquise diagramas de timing para visualização."
                                  ],
                                  "verification": "Crie um diagrama simples comparando timing síncrono e assíncrono e explique verbalmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Datasheets de microcontroladores (ex: Arduino Uno)",
                                    "Vídeos tutoriais sobre serial communication",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Use analogias como 'dança sincronizada' para síncronos e 'carta com endereço' para assíncronos.",
                                    "Foque em clock como 'maestro'."
                                  ],
                                  "learningObjective": "Diferenciar mecanismos de sincronização em protocolos seriais.",
                                  "commonMistakes": [
                                    "Confundir clock externo com interno.",
                                    "Ignorar overhead de bits em assíncronos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Protocolos Síncronos: SPI e I2C",
                                  "subSteps": [
                                    "Estude SPI: 4 fios (MOSI, MISO, SCK, CS), full-duplex, master-slave, alta velocidade.",
                                    "Estude I2C: 2 fios (SDA, SCL), half-duplex, multi-master/slave com endereços, mais complexo.",
                                    "Compare velocidades típicas: SPI até 50MHz, I2C até 400kHz.",
                                    "Liste complexidades: SPI simples hardware, I2C precisa ACK e arbitragem.",
                                    "Simule configurações multi-dispositivo em ambos."
                                  ],
                                  "verification": "Desenhe esquemas de conexão para SPI e I2C com 2 slaves e liste prós/contras.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador Tinkercad ou Proteus",
                                    "Datasheets de sensores I2C/SPI (ex: MPU6050)",
                                    "Microcontrolador como ESP32"
                                  ],
                                  "tips": [
                                    "Lembre: SPI é 'rápido e direto', I2C é 'econômico em fios mas gerencia colisões'.",
                                    "Teste em simulação antes de hardware."
                                  ],
                                  "learningObjective": "Caracterizar SPI e I2C quanto a topologia, velocidade e complexidade.",
                                  "commonMistakes": [
                                    "Confundir full/half-duplex.",
                                    "Esquecer CS em SPI para multi-dispositivos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Protocolo Assíncrono: UART",
                                  "subSteps": [
                                    "Descreva UART: 2 fios (TX, RX), ponto-a-ponto, assíncrono com baud rate.",
                                    "Explique frame: start bit, dados (8 bits), parity, stop bits.",
                                    "Compare velocidade: até 115200 baud típico, menor que SPI mas simples.",
                                    "Discuta complexidade: mínima hardware, sem clock, suscetível a ruído.",
                                    "Identifique limitações: não multi-dispositivo sem multiplexação."
                                  ],
                                  "verification": "Configure UART em um microcontrolador e envie/receba dados simples via terminal serial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Arduino IDE",
                                    "Cabo USB-serial",
                                    "Terminal serial como PuTTY"
                                  ],
                                  "tips": [
                                    "Verifique baud rate match para evitar garbage.",
                                    "Use loopback test para verificação rápida."
                                  ],
                                  "learningObjective": "Entender estrutura e limitações do UART em cenários ponto-a-ponto.",
                                  "commonMistakes": [
                                    "Mismatch de baud rate.",
                                    "Confundir TX/RX."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Protocolos em Termos de Velocidade, Complexidade e Aplicações",
                                  "subSteps": [
                                    "Tabela comparativa: SPI/I2C (síncronos, multi-dev, alta vel.) vs UART (assíncrono, ponto-ponto, simples).",
                                    "Meça velocidades: teste throughput em simulação.",
                                    "Avalie complexidade: linhas de código/fios necessários.",
                                    "Discuta trade-offs: velocidade vs. simplicidade vs. escalabilidade.",
                                    "Crie matriz de seleção baseada em cenários reais."
                                  ],
                                  "verification": "Preencha tabela comparativa e justifique escolha para 3 cenários hipotéticos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela",
                                    "Exemplos de código GitHub para benchmarks"
                                  ],
                                  "tips": [
                                    "Quantifique: calcule bits/segundo.",
                                    "Pense em custo: UART mais barato para debug."
                                  ],
                                  "learningObjective": "Sintetizar diferenças chave para seleção informada de protocolo.",
                                  "commonMistakes": [
                                    "Superestimar velocidade UART.",
                                    "Ignorar overhead em I2C."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de robô mecatrônico, use SPI para conectar um acelerômetro de alta velocidade (rápida leitura de dados), I2C para múltiplos sensores de temperatura (economia de pinos), e UART para debug serial com PC (simples monitoramento).",
                              "finalVerifications": [
                                "Explique verbalmente 5 diferenças principais entre síncronos e assíncronos.",
                                "Desenhe timing diagrams corretos para SPI, I2C e UART.",
                                "Selecione protocolo correto para 3 cenários dados (ex: alta velocidade multi-dev).",
                                "Implemente comunicação básica em hardware/simulador sem erros.",
                                "Compare velocidades reais com valores teóricos.",
                                "Identifique limitações em aplicações reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de sincronização (clock vs. start/stop).",
                                "Correta caracterização de topologias (multi-dev vs. ponto-ponto).",
                                "Análise quantitativa de velocidades e complexidades.",
                                "Uso correto de terminologia técnica (full-duplex, ACK, baud rate).",
                                "Capacidade de trade-offs em contextos práticos.",
                                "Qualidade de diagramas e tabelas comparativas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Sinais elétricos, ruído e integridade de sinal.",
                                "Matemática: Cálculo de throughput (bits/segundo, overhead %).",
                                "Informática: Protocolos de rede e camadas OSI.",
                                "Eletrônica: Design de hardware e pinouts de microcontroladores."
                              ],
                              "realWorldApplication": "Na indústria 4.0, SPI/I2C são usados em sensores IoT para coleta rápida de dados em redes de dispositivos, enquanto UART é padrão para configuração/debug de PLCs e microcontroladores em linhas de produção mecatrônicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.4.2",
                            "name": "Configurar I2C para redes de sensores",
                            "description": "Descrever master-slave em I2C para conectar múltiplos sensores em aplicações embarcadas, incluindo addressing e clock stretching.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Protocolo I2C",
                                  "subSteps": [
                                    "Estude o modelo master-slave: identifique o master como controlador e slaves como dispositivos controlados.",
                                    "Aprenda sobre addressing: cada slave tem um endereço único de 7 bits (ou 10 bits), START + endereço + R/W bit.",
                                    "Entenda clock stretching: slaves podem atrasar o clock SCL segurando-o baixo para ganhar tempo de processamento.",
                                    "Revise sinais: SDA (dados bidirecional), SCL (clock), pull-up resistors necessários nos barramentos.",
                                    "Simule uma comunicação básica com diagramas de timing."
                                  ],
                                  "verification": "Resuma em um diagrama os conceitos master-slave, addressing e clock stretching, explicando cada um.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Datasheets de sensores I2C (ex: BMP280)",
                                    "Documentação I2C oficial",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Use osciloscópio virtual ou Logic Analyzer simulator para visualizar sinais I2C.",
                                  "learningObjective": "Dominar os princípios teóricos do I2C para redes master-slave.",
                                  "commonMistakes": [
                                    "Confundir SDA com SCL",
                                    "Ignorar necessidade de pull-ups",
                                    "Esquecer bit R/W no endereço"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Hardware da Rede I2C",
                                  "subSteps": [
                                    "Selecione um microcontrolador master (ex: Arduino Uno ou ESP32) com suporte I2C.",
                                    "Conecte SDA e SCL: master SDA ao pin A4 (Uno), slaves SDA em paralelo; mesmo para SCL.",
                                    "Adicione resistores pull-up: 4.7kΩ em SDA e SCL para Vcc (3.3V ou 5V).",
                                    "Conecte múltiplos sensores (ex: 2-3 como BMP280 e MPU6050) com alimentação compartilhada.",
                                    "Verifique endereços I2C dos sensores nos datasheets e evite conflitos."
                                  ],
                                  "verification": "Meça continuidade e tensão nos barramentos com multímetro; confirme pull-ups com 3.3V/5V.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Arduino Uno/ESP32",
                                    "Sensores I2C (BMP280, MPU6050)",
                                    "Resistores 4.7kΩ",
                                    "Protoboard, fios jumper",
                                    "Multímetro"
                                  ],
                                  "tips": "Mantenha barramentos curtos (<50cm) para evitar capacitância; use breadboard para protótipo.",
                                  "learningObjective": "Montar fisicamente uma rede I2C funcional com múltiplos slaves.",
                                  "commonMistakes": [
                                    "Conexões invertidas SDA/SCL",
                                    "Sem pull-ups causando falhas de comunicação",
                                    "Endereços duplicados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Software no Master para Comunicação I2C",
                                  "subSteps": [
                                    "Instale biblioteca Wire.h no Arduino IDE.",
                                    "Inicialize I2C no setup(): Wire.begin() para master.",
                                    "Escreva função para scan de endereços: loop de 1-127, transmit(address) para detectar slaves.",
                                    "Implemente leitura/escrita: Wire.requestFrom(addr, bytes) e Wire.read(); Wire.beginTransmission(addr), write(data).",
                                    "Adicione suporte a clock stretching configurando timeout se necessário."
                                  ],
                                  "verification": "Execute scanner I2C e confirme detecção de todos os sensores com seus endereços corretos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Arduino IDE",
                                    "Biblioteca Wire.h",
                                    "Computador com USB"
                                  ],
                                  "tips": "Use Serial Monitor para debug; comece com um slave só antes de múltiplos.",
                                  "learningObjective": "Programar o master para inicializar, endereçar e comunicar com slaves I2C.",
                                  "commonMistakes": [
                                    "Não chamar Wire.endTransmission()",
                                    "Ignorar erros de NACK",
                                    "Frequência clock errada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Validar a Rede I2C",
                                  "subSteps": [
                                    "Teste comunicação básica: leia dados de cada sensor e exiba no Serial.",
                                    "Simule clock stretching: use sensor que o suporte e monitore com logic analyzer.",
                                    "Depure falhas: verifique wiring, endereços, pull-ups; ajuste clock speed com Wire.setClock().",
                                    "Teste com carga: adicione mais slaves e verifique estabilidade.",
                                    "Documente configuração final com esquemático e código."
                                  ],
                                  "verification": "Rede lê dados de todos sensores simultaneamente sem erros por 10 minutos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Logic Analyzer (Saleae ou software)",
                                    "Osciloscópio (opcional)",
                                    "Código de teste"
                                  ],
                                  "tips": "Reduza clock para 100kHz se problemas; isole slaves um a um para depuração.",
                                  "learningObjective": "Garantir operação robusta da rede I2C em cenários reais.",
                                  "commonMistakes": [
                                    "Overloading barramento com muitos slaves",
                                    "Não detectar clock stretching",
                                    "Erros de timing em loops"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um Arduino Uno como master conectado a um BMP280 (endereço 0x76) para pressão/temperatura e MPU6050 (0x68) para aceleração. Escaneie endereços, leia dados a cada 1s e exiba no Serial Monitor, demonstrando master controlando slaves com clock stretching no BMP280.",
                              "finalVerifications": [
                                "Scanner I2C detecta todos slaves com endereços corretos.",
                                "Leitura bem-sucedida de dados de múltiplos sensores sem erros.",
                                "Clock stretching é respeitado (verificado por delay no slave).",
                                "Rede estável sob variação de clock speed (100kHz-400kHz).",
                                "Nenhum conflito de endereço ou falha de pull-up.",
                                "Diagrama esquemático completo documentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração master-slave e addressing (100% detecção).",
                                "Código limpo com handling de erros (NACK, timeout).",
                                "Hardware corretamente wired com pull-ups e sem shorts.",
                                "Demonstração de clock stretching em ação.",
                                "Eficiência: tempo de resposta <500ms para rede completa.",
                                "Documentação clara de passos e troubleshooting."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Análise de sinais e pull-ups.",
                                "Programação Embarcada: Bibliotecas e protocolos de comunicação.",
                                "IoT: Redes de sensores para monitoramento ambiental.",
                                "Física: Timing e capacitância em barramentos.",
                                "Engenharia de Software: Modularidade no código I2C."
                              ],
                              "realWorldApplication": "Em sistemas mecatrônicos como robôs autônomos ou estações meteorológicas IoT, onde múltiplos sensores (temperatura, pressão, IMU) são conectados via I2C a um microcontrolador para coleta de dados eficiente com poucos pinos, otimizando design embarcado em drones ou wearables."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.4.3",
                            "name": "Analisar CAN para controle industrial",
                            "description": "Explicar robustez do CAN bus em ambientes mecatrônicos aeronáuticos, com priorização de mensagens e detecção de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos do Protocolo CAN Bus",
                                  "subSteps": [
                                    "Estudar a arquitetura física e lógica do CAN (diferencial, multi-master).",
                                    "Identificar os campos de um frame CAN: SOF, ID, DLC, dados, CRC, ACK, EOF.",
                                    "Analisar modos de operação: básico e estendido.",
                                    "Compreender bit stuffing e sua importância para sincronização.",
                                    "Revisar velocidades típicas (até 1 Mbps) e topologias suportadas."
                                  ],
                                  "verification": "Desenhar e rotular corretamente um frame CAN completo em um diagrama.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação ISO 11898, simulador CAN (ex: CANalyzer demo), apostila de mecatrônica.",
                                  "tips": "Use diagramas de timing para visualizar bit stuffing.",
                                  "learningObjective": "Compreender a estrutura básica do CAN para análise posterior.",
                                  "commonMistakes": "Confundir ID de 11 bits com 29 bits sem especificar o modo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Robustez do CAN em Ambientes Mecatrônicos Aeronáuticos",
                                  "subSteps": [
                                    "Explicar tolerância a ruído EMI/RFI devido a sinalização diferencial.",
                                    "Analisar uso de transceptores robustos (ex: ISO 1050) em vibrações e temperaturas extremas.",
                                    "Estudar terminadores (120 ohms) para evitar reflexões em cabos longos.",
                                    "Discutir redundância em redes aeronáuticas (dual CAN).",
                                    "Comparar com outros buses (ex: RS-485) em termos de imunidade a falhas."
                                  ],
                                  "verification": "Listar 3 vantagens do CAN sobre buses single-ended em ambientes aeronáuticos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Artigos sobre ARINC 825 (CAN aeronáutico), osciloscópio virtual (Multisim).",
                                  "tips": "Simule ruído em software para ver impacto no sinal diferencial.",
                                  "learningObjective": "Identificar por que o CAN é ideal para mecatrônica aeronáutica.",
                                  "commonMistakes": "Ignorar o papel do terminador em cabos longos, causando ecos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Priorização de Mensagens via Arbitragem",
                                  "subSteps": [
                                    "Explicar arbitragem não destrutiva baseada no ID (menor ID vence).",
                                    "Simular colisão de mensagens com IDs diferentes.",
                                    "Analisar priorização em tempo real para mensagens críticas (controle vs. telemetria).",
                                    "Estudar impacto em latência determinística.",
                                    "Discutir configuração de IDs para priorizar comandos de voo."
                                  ],
                                  "verification": "Simular e descrever o vencedor em uma colisão com IDs 0x123 e 0x456.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Arduino com MCP2515 shield, software Arduino IDE com biblioteca CAN.",
                                  "tips": "Teste com dois Arduinos para ver arbitragem ao vivo.",
                                  "learningObjective": "Dominar como o CAN garante priorização sem perda de mensagens.",
                                  "commonMistakes": "Achar que priorização é por FIFO; é por ID binário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detecção e Tratamento de Erros no CAN",
                                  "subSteps": [
                                    "Identificar 5 tipos de erros: bit, stuff, CRC, form, ACK.",
                                    "Explicar detecção via CRC polinomial e ACK passivo/ativo.",
                                    "Analisar modos de erro: erro passivo, bus off e recuperação.",
                                    "Estudar counters de erro (TEC/REC) e thresholds.",
                                    "Simular injeção de erro e observar retransmissão."
                                  ],
                                  "verification": "Classificar e remediar um erro CRC em um frame exemplo.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Simulador CANoe ou Tinkercad, datasheet MCP2515.",
                                  "tips": "Monitore bus com logic analyzer para ver erros em tempo real.",
                                  "learningObjective": "Compreender mecanismos que garantem integridade em ambientes ruidosos.",
                                  "commonMistakes": "Confundir erro passivo (silencioso) com bus off (desconectado)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Análise Integrada em Sistemas Aeronáuticos",
                                  "subSteps": [
                                    "Integrar robustez, priorização e erros em um caso aeronáutico (fly-by-wire).",
                                    "Mapear mensagens: alta prioridade para atuadores, baixa para sensores.",
                                    "Avaliar conformidade com normas como DO-178C para software CAN.",
                                    "Discutir limitações (ex: max 8 bytes/dados) e extensões (CAN FD).",
                                    "Propor melhorias para mecatrônica industrial."
                                  ],
                                  "verification": "Elaborar relatório de 1 página analisando CAN em um atuador de flap.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Casos de estudo Boeing/Airbus CAN, ferramenta de análise de rede.",
                                  "tips": "Use exemplos reais de ARINC 825 para contextualizar.",
                                  "learningObjective": "Aplicar conceitos em análise crítica de sistemas reais.",
                                  "commonMistakes": "Subestimar latência cumulativa em redes longas."
                                }
                              ],
                              "practicalExample": "Configure dois Arduinos com shields MCP2515 em um barramento CAN. Envie mensagens de controle de motor (ID baixo, alta prioridade) e telemetria (ID alto). Injete ruído via jumper e observe detecção de erros, retransmissão e priorização em osciloscópio, simulando falha em ambiente aeronáutico.",
                              "finalVerifications": [
                                "Desenhar frame CAN com todos campos e explicar bit stuffing.",
                                "Simular arbitragem com 3 mensagens colidindo.",
                                "Listar e exemplificar 5 erros CAN com ações corretivas.",
                                "Explicar robustez diferencial vs. single-ended com diagrama.",
                                "Analisar latência em rede com 10 nós priorizados.",
                                "Mapear 5 mensagens típicas em sistema fly-by-wire."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de frames e arbitragem (30%).",
                                "Compreensão de erros e recuperação (25%).",
                                "Explicação contextualizada para aeronáutica (20%).",
                                "Uso correto de simulações/exemplos práticos (15%).",
                                "Clareza em relatórios e diagramas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Sinalização diferencial e transceptores.",
                                "Redes de Computadores: Protocolos multi-master e QoS.",
                                "Engenharia Aeronáutica: Normas ARINC e certificação DO-178.",
                                "Controle Automático: Latência determinística em loops de controle.",
                                "Física: EMI/RFI e propagação em cabos."
                              ],
                              "realWorldApplication": "Em aeronaves como o Embraer E-Jets, o CAN bus gerencia atuadores de flight controls e sensores ambientais, priorizando comandos de piloto sobre dados de manutenção em meio a vibrações e interferências eletromagnéticas, garantindo segurança e redundância."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.4.4",
                            "name": "Implementar USB como HID ou CDC",
                            "description": "Configurar interfaces USB em microcontroladores modernos para comunicação com PC em desenvolvimento de projetos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de USB, HID e CDC",
                                  "subSteps": [
                                    "Estude a hierarquia USB: host, device, descriptors.",
                                    "Aprenda sobre HID: relatórios de input/output/feature, uso em teclados/mouses.",
                                    "Aprenda sobre CDC: ACM subclass para serial virtual, comandos de controle.",
                                    "Revise diferenças entre full-speed e high-speed USB em MCUs.",
                                    "Analise exemplos de descriptors HID/CDC em documentação de fabricantes."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes chave de HID e CDC, identificando pelo menos 5 diferenças principais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação USB-IF (especificações HID/CDC)",
                                    "Datasheets de MCUs como STM32 ou ESP32-S3",
                                    "Ferramentas de diagramação como Draw.io"
                                  ],
                                  "tips": "Comece com vídeos tutoriais oficiais do fabricante para visualização rápida.",
                                  "learningObjective": "Compreender os protocolos USB HID e CDC para configuração correta em MCUs.",
                                  "commonMistakes": [
                                    "Confundir HID com CDC (HID não é serial)",
                                    "Ignorar little-endian em descriptors",
                                    "Subestimar overhead de polling em HID"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Hardware e Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Selecione MCU com USB nativo (ex: STM32F4xx ou RP2040).",
                                    "Conecte USB DM/DP, VCC, GND; adicione cristal se necessário.",
                                    "Instale IDE (STM32CubeIDE ou PlatformIO) e bibliotecas USB.",
                                    "Configure clock USB (48MHz típico) no CubeMX ou código.",
                                    "Teste detecção básica do MCU via USB sem firmware customizado."
                                  ],
                                  "verification": "MCU é detectado como dispositivo USB genérico no Gerenciador de Dispositivos do PC.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Placa de desenvolvimento STM32 Nucleo ou similar",
                                    "Cabo USB Micro-B/ Type-C",
                                    "STM32CubeIDE ou Arduino IDE",
                                    "Osciloscópio/multímetro opcional"
                                  ],
                                  "tips": "Use pull-ups corretos em D+/D- para full-speed.",
                                  "learningObjective": "Preparar hardware e ferramentas para implementação USB funcional.",
                                  "commonMistakes": [
                                    "Clock USB instável causando falhas de enumeração",
                                    "Conexões invertidas DM/DP",
                                    "Alimentação insuficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Firmware para HID ou CDC",
                                  "subSteps": [
                                    "Gere código base com CubeMX: ative USB_DEVICE como HID ou CDC.",
                                    "Edite descriptors: defina VID/PID, string descriptors, report descriptors para HID.",
                                    "Implemente callbacks: USBD_HID_SendReport() para HID; CDC_Transmit_FS() para CDC.",
                                    "Adicione lógica de aplicação: botões para HID keys; loop serial para CDC.",
                                    "Compile e flash o firmware no MCU."
                                  ],
                                  "verification": "Dispositivo enumera como 'USB Keyboard' (HID) ou 'USB Serial' (CDC) no PC.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "STM32CubeMX",
                                    "Compilador GCC/ARM",
                                    "Exemplos de firmware TinyUSB ou STM32 USB lib"
                                  ],
                                  "tips": "Use TinyUSB para portabilidade entre MCUs.",
                                  "learningObjective": "Desenvolver código funcional para comunicação USB HID/CDC.",
                                  "commonMistakes": [
                                    "Descriptors inválidos causando rejeição pelo host",
                                    "Buffer overflow em transmit",
                                    "Não lidar com NAKs/stalls"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Integrar em Projeto",
                                  "subSteps": [
                                    "Teste HID: use ferramenta como HIDAPI tester para enviar/receber reports.",
                                    "Teste CDC: abra porta COM virtual e envie comandos via terminal (PuTTY).",
                                    "Depure com printf via CDC ou USB traces (Wireshark com USBPcap).",
                                    "Integre com sensores/atuadores mecatrônicos (ex: ler encoder via HID).",
                                    "Otimize latência e consumo de energia."
                                  ],
                                  "verification": "Comunicação bidirecional estável por 30min sem erros; dados corretos trocados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "PuTTY/Tera Term",
                                    "Wireshark + USBPcap",
                                    "Sensores para demo (botão, LED)"
                                  ],
                                  "tips": "Monitore VBUS para detecção de conexão.",
                                  "learningObjective": "Validar e aplicar USB HID/CDC em contexto mecatrônico real.",
                                  "commonMistakes": [
                                    "Ignorar reset USB após attach/detach",
                                    "Race conditions em multi-tasking",
                                    "Não resetar buffers"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um STM32F401 como HID keyboard: pressione botão no MCU para enviar 'A' ao PC. Para CDC, leia potenciômetro e envie valor serial via USB para plotter no PC, simulando telemetria em um braço robótico.",
                              "finalVerifications": [
                                "Dispositivo enumera corretamente como HID ou CDC no SO (Windows/Linux/Mac).",
                                "Dados são transmitidos/recebidos sem perda em loop de 100 iterações.",
                                "Depuração via USB traces mostra pacotes válidos sem stalls/erros.",
                                "Integração com periféricos MCU (GPIO, ADC) funciona em paralelo.",
                                "Sistema resiste a desconexões/reconexões múltiplas.",
                                "Latência <50ms para HID reports."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos descriptors USB (validados por host).",
                                "Robustez: taxa de erro <0.1% em transmissão contínua.",
                                "Eficiência: uso de CPU <20% em idle com USB ativo.",
                                "Documentação: código comentado com fluxogramas.",
                                "Escalabilidade: fácil adaptação para outros MCUs.",
                                "Segurança: sem vazamento de dados sensíveis via USB."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Design de PCB para USB com proteção ESD.",
                                "Programação Embarcada: RTOS tasks para USB handling.",
                                "Comunicação: Protocolos serial comparados a USB CDC.",
                                "Mecatrônica: Controle de servos via HID gamepad.",
                                "Redes: USB como bridge para Ethernet/IP."
                              ],
                              "realWorldApplication": "Em robótica industrial, use CDC para debug remoto de CLPs sem fios extras; HID para interfaces homem-máquina em painéis de controle de máquinas CNC, reduzindo cabos e aumentando portabilidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Funcionamento de Controladores Lógicos Programáveis (CLPs)",
                    "description": "Princípios de operação, linguagens de programação como ladder logic e módulos de E/S em CLPs industriais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Princípios de Operação dos CLPs",
                        "description": "Fundamentos do funcionamento interno dos Controladores Lógicos Programáveis, incluindo o ciclo de scan (leitura de entradas, execução do programa e atualização de saídas), componentes principais como CPU, memória e barramento de comunicação.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Identificar os componentes principais de um CLP",
                            "description": "Reconhecer e descrever a função de CPU, memória RAM/ROM/EEPROM, fonte de alimentação e chassis em um CLP industrial, relacionando-os ao fluxo de operação geral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a função da CPU no CLP",
                                  "subSteps": [
                                    "Pesquisar a definição e localização da CPU em diagramas de arquitetura de CLP.",
                                    "Identificar funções principais: processar lógica do programa, escanear entradas/saídas e executar comandos.",
                                    "Analisar o ciclo de varredura (scan cycle) gerenciado pela CPU.",
                                    "Comparar CPU de CLP com processadores comuns, destacando robustez industrial.",
                                    "Anotar especificações típicas como clock speed e interfaces I/O."
                                  ],
                                  "verification": "Descrever em um parágrafo as funções da CPU e desenhar um diagrama simples de seu papel no CLP.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de blocos de um CLP (ex: Siemens ou Allen-Bradley)",
                                    "Manual técnico de um modelo de CLP"
                                  ],
                                  "tips": "Enfatize o scanning cíclico: inputs → programa → outputs.",
                                  "learningObjective": "Reconhecer a CPU como o 'cérebro' central que executa o programa lógico em tempo real.",
                                  "commonMistakes": [
                                    "Confundir CPU com memória de programa",
                                    "Ignorar o impacto de falhas na CPU no sistema inteiro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os tipos de memória em um CLP (RAM, ROM, EEPROM)",
                                  "subSteps": [
                                    "Diferenciar RAM (memória de trabalho volátil para variáveis temporárias).",
                                    "Explicar ROM (memória de firmware não volátil para boot e sistema operacional).",
                                    "Descrever EEPROM/Flash (memória para armazenamento de programas do usuário, retém dados sem energia).",
                                    "Mapear funções no fluxo: RAM para execução, EEPROM para persistência.",
                                    "Verificar capacidades típicas em um modelo real (ex: 100KB RAM, 4MB Flash)."
                                  ],
                                  "verification": "Listar funções de cada tipo de memória e indicar qual é volátil/não volátil.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Especificações técnicas de memórias em CLPs",
                                    "Ferramenta de simulação como TIA Portal ou LogixPro"
                                  ],
                                  "tips": "Lembre-se: RAM perde dados ao desligar; use EEPROM para programas críticos.",
                                  "learningObjective": "Distinguir memórias por volatilidade e função no ciclo de operação do CLP.",
                                  "commonMistakes": [
                                    "Misturar RAM com armazenamento permanente",
                                    "Subestimar necessidade de backup em EEPROM"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar fonte de alimentação e chassis no CLP",
                                  "subSteps": [
                                    "Descrever fonte de alimentação: converte AC/DC, fornece 5V/24V estável para componentes.",
                                    "Explicar chassis: estrutura física (trilho DIN), proteção IP, dissipação térmica e expansão de módulos.",
                                    "Analisar requisitos: tensão nominal, proteção contra surtos, redundância.",
                                    "Verificar integração: fonte alimenta CPU/memória; chassis suporta montagem.",
                                    "Inspecionar foto ou diagrama de um CLP montado."
                                  ],
                                  "verification": "Explicar como falha na fonte afeta o CLP e listar specs mínimas de um chassis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Foto ou vídeo de CLP desmontado",
                                    "Datasheet de fonte e rack de CLP"
                                  ],
                                  "tips": "CLPs industriais precisam de fontes robustas para ambientes hostis (vibração, poeira).",
                                  "learningObjective": "Entender suporte físico e energético essencial para operação contínua.",
                                  "commonMistakes": [
                                    "Confundir chassis com gabinete de PC comum",
                                    "Ignorar normas de segurança como IEC 61131"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar componentes ao fluxo de operação geral do CLP",
                                  "subSteps": [
                                    "Mapear fluxo: Entradas → CPU lê (input scan) → Processa programa (RAM/ROM) → Saídas (output scan).",
                                    "Integrar memórias: EEPROM carrega programa na inicialização.",
                                    "Incluir fonte/chassis: Energia estável e montagem segura para ciclo contínuo.",
                                    "Simular fluxo em diagrama ou software.",
                                    "Discutir interrupções e diagnósticos via CPU."
                                  ],
                                  "verification": "Desenhar fluxograma completo relacionando todos componentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de simulação CLP (ex: PLCSIM)",
                                    "Papel e caneta para fluxograma"
                                  ],
                                  "tips": "O ciclo de scan típico é <10ms para aplicações industriais.",
                                  "learningObjective": "Visualizar como componentes interagem em um ciclo operacional fechado.",
                                  "commonMistakes": [
                                    "Omitir input/output scan",
                                    "Pensar em fluxo linear em vez de cíclico"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e sintetizar conhecimento dos componentes",
                                  "subSteps": [
                                    "Listar todos componentes e funções em tabela.",
                                    "Testar com quiz: 'Qual componente armazena programa?'",
                                    "Comparar com CLP real via vídeo ou foto.",
                                    "Identificar módulos opcionais (ex: comunicação).",
                                    "Preparar apresentação curta."
                                  ],
                                  "verification": "Criar tabela ou mapa mental com 100% de acerto em autoavaliação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Quiz impresso ou online sobre CLPs",
                                    "Vídeo de desmontagem de CLP"
                                  ],
                                  "tips": "Use mnemônicos: CPU=Cérebro, Memória=Memória, Fonte=Alimentação, Chassis=Casco.",
                                  "learningObjective": "Consolidar identificação e relações funcionais.",
                                  "commonMistakes": [
                                    "Esquecer EEPROM como não volátil",
                                    "Generalizar demais funções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CLP Siemens S7-1200: CPU 1214C processa ladder logic (scan 1ms); RAM 100KB para variáveis; EEPROM 4MB para programa; fonte PM1207 24VDC alimenta tudo; chassis em trilho DIN com 8 slots. Desenhe: Entradas digitais → CPU scan → Atuadores via saídas.",
                              "finalVerifications": [
                                "Listar corretamente CPU, RAM/ROM/EEPROM, fonte e chassis.",
                                "Descrever função de cada componente sem erros.",
                                "Explicar ciclo de scan relacionando todos os componentes.",
                                "Identificar em diagrama/foto real os componentes.",
                                "Discutir impacto de falha em cada um no sistema."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e descrição (90%+ correto).",
                                "Clareza na relação com fluxo operacional.",
                                "Uso de termos técnicos corretos (ex: scan cycle, volatilidade).",
                                "Criatividade no fluxograma ou tabela.",
                                "Profundidade em exemplos industriais."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Circuitos de alimentação e proteção (fonte).",
                                "Informática: Arquitetura von Neumann em microprocessadores.",
                                "Mecânica Industrial: Montagem em trilho DIN e proteção ambiental.",
                                "Programação: Ciclos de execução em linguagens ladder/ST.",
                                "Física: Conversão de energia e estabilidade térmica."
                              ],
                              "realWorldApplication": "Em fábricas de automação, como linhas de montagem automotiva, o CLP usa CPU para lógica em tempo real, memórias para receitas de produção, fonte robusta para 24/7 operação e chassis para integração em painéis de controle, evitando paradas custosas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Descrever o ciclo de scan de um CLP",
                            "description": "Explicar detalhadamente as três fases do ciclo de scan: leitura dos estados das entradas, execução sequencial do programa lógico e escrita nos estados das saídas, incluindo o conceito de tempo de ciclo e watchdog timer.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito geral do ciclo de scan e tempo de ciclo",
                                  "subSteps": [
                                    "Defina o ciclo de scan como o processo cíclico repetitivo que o CLP executa continuamente.",
                                    "Explique que o ciclo de scan consiste em três fases principais: leitura de entradas, execução do programa e atualização de saídas.",
                                    "Descreva o tempo de ciclo como o intervalo de tempo necessário para completar uma iteração completa do ciclo.",
                                    "Discuta fatores que influenciam o tempo de ciclo, como tamanho do programa e velocidade do processador.",
                                    "Identifique a importância do tempo de ciclo para a responsividade do sistema."
                                  ],
                                  "verification": "Desenhe um diagrama simples do ciclo de scan e rotule o tempo de ciclo; explique verbalmente sua duração típica (1-100ms).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama em branco",
                                    "Apresentação ou vídeo introdutório sobre CLPs (ex: YouTube ou software como TIA Portal)"
                                  ],
                                  "tips": "Use analogias como um ciclo de lavadora de roupa para visualizar a repetição contínua.",
                                  "learningObjective": "Compreender o ciclo de scan como um loop contínuo e seu impacto no desempenho do CLP.",
                                  "commonMistakes": [
                                    "Confundir ciclo de scan com execução única do programa",
                                    "Ignorar que o ciclo é assíncrono com eventos reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Fase 1: Leitura dos estados das entradas",
                                  "subSteps": [
                                    "Descreva que na Fase 1, o CLP lê instantaneamente todos os estados físicos das entradas (sensores, botões).",
                                    "Explique que os valores lidos são armazenados em uma tabela de imagem de entradas (input image table).",
                                    "Discuta como isso garante consistência: todas as entradas são capturadas no mesmo instante.",
                                    "Identifique exemplos de entradas: sensores de proximidade, fim de curso, encoders.",
                                    "Simule a leitura com um exemplo: sensor ON gera bit 1 na tabela."
                                  ],
                                  "verification": "Liste 3 entradas comuns e simule sua leitura em uma tabela de imagem desenhada à mão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para tabela de imagem",
                                    "Diagrama de um CLP genérico"
                                  ],
                                  "tips": "Lembre-se: leitura é 'foto instantânea' – não muda durante o ciclo atual.",
                                  "learningObjective": "Dominar como o CLP captura entradas de forma atômica e consistente.",
                                  "commonMistakes": [
                                    "Pensar que entradas mudam durante a execução do programa",
                                    "Confundir tabela de entradas com saídas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Fase 2: Execução sequencial do programa lógico",
                                  "subSteps": [
                                    "Explique que na Fase 2, o processador executa o programa ladder ou instruções sequencialmente, do início ao fim.",
                                    "Descreva o uso da tabela de imagem de entradas para lógica e resultados escritos na tabela de imagem de saídas.",
                                    "Discuta que variáveis auxiliares (M) e temporizadores são processados aqui.",
                                    "Ilustre com exemplo: Se entrada I0.0=1, acione saída Q0.0 via contato normally open.",
                                    "Enfatize que a execução é determinística e rápida, tipicamente em ms."
                                  ],
                                  "verification": "Escreva um programa ladder simples de 3 linhas e trace sua execução em um ciclo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação CLP gratuito (ex: LogixPro ou OpenPLC)",
                                    "Exemplos de programas ladder impressos"
                                  ],
                                  "tips": "Trace o programa linha por linha como um 'scan' de esquerda para direita, cima para baixo.",
                                  "learningObjective": "Entender a execução lógica isolada das entradas físicas atuais.",
                                  "commonMistakes": [
                                    "Acessar entradas físicas diretamente durante execução",
                                    "Executar programa de forma não sequencial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender a Fase 3: Escrita nos estados das saídas e Watchdog Timer",
                                  "subSteps": [
                                    "Descreva que na Fase 3, a tabela de imagem de saídas é transferida para as saídas físicas simultaneamente.",
                                    "Explique o conceito de Watchdog Timer: contador que reseta se o ciclo exceder tempo limite, previnindo travamentos.",
                                    "Discuta configuração típica do watchdog (ex: 100-500ms).",
                                    "Simule: Se Q0.0=1 na tabela, ative relé de saída.",
                                    "Relacione: Saídas só mudam no fim do ciclo, garantindo estabilidade."
                                  ],
                                  "verification": "Descreva o que acontece se o ciclo demorar > watchdog e demonstre com diagrama.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de CLP (ex: manual Siemens S7)",
                                    "Cronômetro para simular tempos"
                                  ],
                                  "tips": "Pense nas saídas como 'atualização em bloco' para evitar flickering.",
                                  "learningObjective": "Graspar a atualização de saídas e proteção contra falhas de tempo.",
                                  "commonMistakes": [
                                    "Atualizar saídas durante execução",
                                    "Ignorar watchdog como irrelevante"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem, um CLP controla um esteira: Fase 1 lê sensor de peça (ON); Fase 2 executa lógica para ligar motor se peça presente; Fase 3 ativa motor fisicamente. Se ciclo >200ms (watchdog), sistema para por segurança. Simule no TIA Portal com 1 entrada, 1 lógica AND, 1 saída.",
                              "finalVerifications": [
                                "Desenhar e rotular diagrama completo do ciclo de scan com 3 fases.",
                                "Explicar verbalmente o fluxo de dados entre tabelas de imagem.",
                                "Calcular tempo de ciclo aproximado para programa de 100 linhas.",
                                "Identificar impacto de atraso em Fase 2 no sistema real.",
                                "Configurar watchdog em software de simulação e testar timeout.",
                                "Traçar execução de programa ladder em um ciclo completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das 3 fases e suas sequências.",
                                "Correta distinção entre tabelas de imagem de I/O e execução lógica.",
                                "Compreensão conceitual de tempo de ciclo e watchdog.",
                                "Uso de exemplos práticos e diagramas claros.",
                                "Identificação de erros comuns e prevenções.",
                                "Capacidade de simular ciclo em ferramenta ou papel."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Similar a loops while() em linguagens como C ou Python.",
                                "Eletrônica: Integração com PLC hardware e I/O modules.",
                                "Física: Conceitos de tempo real e latência em sistemas dinâmicos.",
                                "Matemática: Cálculo de tempos e modelagem de ciclos periódicos.",
                                "Segurança Industrial: Watchdog como mecanismo de fault tolerance."
                              ],
                              "realWorldApplication": "Em fábricas automatizadas, o ciclo de scan garante controle preciso de máquinas como robôs soldadores ou elevadores, onde atrasos <50ms evitam colisões; falha no watchdog para produção em montadoras de carros como Ford ou Volkswagen."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Analisar o fluxo de dados em um CLP",
                            "description": "Mapear o fluxo de dados desde as entradas físicas até as saídas, considerando o barramento de dados e o impacto da velocidade de processamento em aplicações industriais de alta confiabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e mapear as entradas físicas do CLP",
                                  "subSteps": [
                                    "Estudar os tipos de entradas: digitais (on/off) e analógicas (4-20mA, 0-10V).",
                                    "Explicar a conexão de sensores e atuadores aos módulos de E/S.",
                                    "Descrever o condicionamento de sinal (filtros, isoladores ópticos).",
                                    "Mapear a digitalização e armazenamento em registradores de entrada (I0.0, etc.).",
                                    "Identificar endereços de memória associados às entradas."
                                  ],
                                  "verification": "Desenhar um diagrama esquemático das entradas físicas até os registradores de memória.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagrama de pinagem de um módulo de CLP (ex: Siemens S7-1200)",
                                    "Documentação técnica do fabricante",
                                    "Simulador de CLP como PLCSIM"
                                  ],
                                  "tips": [
                                    "Comece pelos sinais mais comuns como sensores indutivos.",
                                    "Use cores diferentes no diagrama para digital vs. analógico."
                                  ],
                                  "learningObjective": "Compreender a transformação de sinais físicos em dados digitais acessíveis pelo programa.",
                                  "commonMistakes": [
                                    "Ignorar o papel do condicionamento de sinal.",
                                    "Confundir endereços de entrada com saída.",
                                    "Não considerar ruído elétrico nas entradas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o barramento de dados e o ciclo de scan do CLP",
                                  "subSteps": [
                                    "Descrever o barramento de dados (backplane) que conecta CPU, E/S e memória.",
                                    "Explicar o ciclo de scan: leitura de entradas → execução do programa → escrita de saídas.",
                                    "Mapear o fluxo de dados dos registradores de entrada para a CPU via barramento.",
                                    "Identificar componentes como RAM, ROM e registradores auxiliares.",
                                    "Simular um ciclo completo de scan em software."
                                  ],
                                  "verification": "Listar os passos do ciclo de scan e desenhar o fluxo no barramento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Manual de programação do CLP",
                                    "Software de simulação (TIA Portal ou Codesys)",
                                    "Vídeos tutoriais sobre ciclo de scan"
                                  ],
                                  "tips": [
                                    "Lembre-se: ciclo de scan típico é 1-100ms.",
                                    "Desenhe setas direcionais no diagrama para o fluxo."
                                  ],
                                  "learningObjective": "Dominar o mecanismo de comunicação interna via barramento e ciclo de scan.",
                                  "commonMistakes": [
                                    "Confundir barramento com rede de comunicação externa.",
                                    "Subestimar o tempo de scan no fluxo.",
                                    "Omitir a atualização assíncrona de saídas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar o processamento na CPU e execução da lógica do programa",
                                  "subSteps": [
                                    "Descrever como a CPU lê registradores de entrada e executa o programa ladder/FBD.",
                                    "Mapear o fluxo de dados através de contadores, timers e funções lógicas.",
                                    "Analisar o impacto da velocidade de clock da CPU no tempo de execução.",
                                    "Identificar buffers de dados e prioridades de interrupções.",
                                    "Testar um programa simples para observar mudanças nos dados."
                                  ],
                                  "verification": "Executar um programa de teste e registrar mudanças nos registradores durante o scan.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Laptop com software de programação CLP",
                                    "Exemplo de programa ladder simples",
                                    "Osciloscópio virtual para timing"
                                  ],
                                  "tips": [
                                    "Use breakpoints no simulador para pausar e inspecionar dados.",
                                    "Compare CPUs de diferentes velocidades."
                                  ],
                                  "learningObjective": "Entender como a lógica do programa processa dados de entrada para gerar comandos de saída.",
                                  "commonMistakes": [
                                    "Ignorar o efeito de loops longos no tempo de scan.",
                                    "Confundir execução sequencial com paralela.",
                                    "Não considerar overflows em contadores."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear as saídas e avaliar impacto da velocidade de processamento",
                                  "subSteps": [
                                    "Descrever a transferência de dados processados para registradores de saída.",
                                    "Mapear do barramento aos módulos de saída (relés, transistores, analógicos).",
                                    "Analisar como a velocidade de processamento afeta aplicações de alta confiabilidade (ex: tempo de resposta <10ms).",
                                    "Calcular tempo total de ciclo e identificar gargalos.",
                                    "Propor otimizações para reduzir latência."
                                  ],
                                  "verification": "Criar um diagrama completo de fluxo de entrada a saída com tempos estimados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora ou planilha para timing",
                                    "Casos de estudo industriais",
                                    "Ferramentas de profiling de CLP"
                                  ],
                                  "tips": [
                                    "Foque em aplicações críticas como freios de emergência.",
                                    "Use fórmulas: Tempo total = Scan time + Rede + E/S."
                                  ],
                                  "learningObjective": "Avaliar o fluxo completo e impactos da performance em cenários reais.",
                                  "commonMistakes": [
                                    "Superestimar velocidade sem considerar overhead.",
                                    "Omitir atrasos de hardware nas saídas.",
                                    "Não ligar à confiabilidade (ex: SIL levels)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem automatizada, um sensor de presença (entrada digital IX0.0) detecta peça → CLP lê via scan (10ms) → lógica verifica contador → aciona motor (saída Q0.0) se OK; analisar se velocidade de CPU (1ms execução) garante resposta <50ms para evitar colisões.",
                              "finalVerifications": [
                                "Diagrama completo do fluxo de dados de entrada a saída está correto e rotulado.",
                                "Explicação verbal do ciclo de scan e barramento sem erros.",
                                "Cálculo preciso do tempo de resposta total para um exemplo dado.",
                                "Identificação de pelo menos 3 impactos da velocidade em apps confiáveis.",
                                "Simulação executada mostrando fluxo em tempo real.",
                                "Otimização proposta para reduzir latência."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude do mapeamento de fluxo (90%+ cobertura).",
                                "Correta inclusão de barramento, scan e velocidades (sem omissões chave).",
                                "Qualidade dos diagramas: claros, legíveis e com legendas.",
                                "Análise crítica do impacto em confiabilidade industrial.",
                                "Evidências práticas de simulação ou teste.",
                                "Criatividade em otimizações e conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Condicionamento de sinais e interfaces E/S.",
                                "Programação: Lógica ladder, timers e estruturas de controle.",
                                "Física: Análise de tempos, velocidades e dinâmica de sistemas.",
                                "Gestão de Projetos: Avaliação de riscos e confiabilidade (SIL, ISO 13849).",
                                "Redes Industriais: Comparação com protocolos como Profibus."
                              ],
                              "realWorldApplication": "Na indústria automotiva, análise do fluxo em CLPs garante tempos de resposta em robôs soldadores, evitando falhas catastróficas; em plantas químicas, assegura sincronia para válvulas de segurança, reduzindo downtime e riscos operacionais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Linguagens de Programação para CLPs",
                        "description": "Linguagens padronizadas pela norma IEC 61131-3, com ênfase na Ladder Logic (diagrama de梯子), incluindo símbolos, blocos funcionais e programação estruturada para controle industrial.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Compreender a Ladder Logic como linguagem gráfica",
                            "description": "Interpretar diagramas ladder como equivalentes a circuitos de relés eletromecânicos, identificando rungs, contatos normalmente abertos/fechados e bobinas de saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos de circuitos de relés eletromecânicos",
                                  "subSteps": [
                                    "Estude o funcionamento básico de um relé: bobina, contatos normalmente abertos (NO) e normalmente fechados (NC).",
                                    "Analise como um circuito de relé usa energia elétrica para abrir/fechar contatos e ativar cargas.",
                                    "Desenhe um circuito simples com um interruptor, relé e lâmpada para visualizar o fluxo lógico.",
                                    "Identifique a lógica de controle: entrada ativa bobina, que fecha contatos para saída.",
                                    "Compare com lógica booleana: AND, OR representados por contatos em série/paralelo."
                                  ],
                                  "verification": "Desenhar e explicar um circuito de relé simples que acende uma lâmpada ao pressionar um botão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, diagramas impressos de relés, vídeo tutorial sobre relés (YouTube ou Khan Academy).",
                                  "tips": "Sempre comece visualizando o estado em repouso (sem energia) para entender NO/NC.",
                                  "learningObjective": "Compreender como relés eletromecânicos implementam lógica de controle básica.",
                                  "commonMistakes": "Confundir NO com NC; ignorar o estado inicial do circuito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conhecer os componentes da Ladder Logic",
                                  "subSteps": [
                                    "Aprenda o que é um 'rung': linha horizontal que representa um circuito lógico completo.",
                                    "Identifique contatos de entrada: --| |-- (NO) e --|/|-- (NC), simbolizando condições de entrada.",
                                    "Estude bobinas de saída: --( )-- para ativar saídas como motores ou válvulas.",
                                    "Observe símbolos auxiliares: contatos de memória e timers básicos em ladder.",
                                    "Pratique lendo notação: esquerda para entradas, direita para saídas."
                                  ],
                                  "verification": "Listar e desenhar os 3 componentes principais (rung, contato, bobina) com suas simbologias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de referência de símbolos Ladder Logic, software gratuito como Ladder Logic Simulator online.",
                                  "tips": "Memorize: contatos à esquerda controlam, bobina à direita executa.",
                                  "learningObjective": "Reconhecer e nomear os elementos gráficos fundamentais da Ladder Logic.",
                                  "commonMistakes": "Inverter a direção de leitura (da direita para esquerda); confundir símbolos de NO/NC."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar diagramas Ladder como circuitos equivalentes",
                                  "subSteps": [
                                    "Compare um rung simples Ladder com circuito de relé: contatos = interruptores/relés, bobina = carga.",
                                    "Analise fluxos: série de contatos NO = AND lógico; paralelo = OR lógico.",
                                    "Trace o caminho de energia em um diagrama: da esquerda, através de contatos energizados até bobina.",
                                    "Simule mentalmente estados: qual entrada ativa a saída? Teste com valores 0/1.",
                                    "Converta um circuito relé físico para diagrama Ladder e vice-versa."
                                  ],
                                  "verification": "Converter um diagrama Ladder simples em descrição de circuito relé e simular seu funcionamento.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Simulador Ladder Logic (ex: PLC Fiddle online), exemplos impressos de diagramas.",
                                  "tips": "Pense em 'fluxo de potência': energia flui só se todos os contatos no caminho estiverem fechados.",
                                  "learningObjective": "Mapear elementos Ladder diretamente para equivalentes eletromecânicos.",
                                  "commonMistakes": "Ignorar polaridade ou estado inicial; não considerar latching (auto-manutenção)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em diagramas reais",
                                  "subSteps": [
                                    "Analise um diagrama Ladder de partida de motor: identifique start/stop, contatos auxiliares.",
                                    "Identifique rungs múltiplos e saídas independentes em um programa completo.",
                                    "Simule falhas: o que acontece se um contato NC falhar? Explique logicamente.",
                                    "Crie um diagrama Ladder para um cenário simples (ex: luz de alerta com duas condições).",
                                    "Valide com simulação: execute e observe saídas esperadas."
                                  ],
                                  "verification": "Identificar corretamente todos os rungs, contatos e bobinas em um diagrama fornecido, explicando seu propósito.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Simulador PLC online (PLC Simulator), diagramas de exemplo de indústria.",
                                  "tips": "Use cores para marcar caminhos energizados em diagramas complexos.",
                                  "learningObjective": "Aplicar o conhecimento para interpretar e criar diagramas Ladder funcionais.",
                                  "commonMistakes": "Não considerar interdependências entre rungs; sobrecarregar com timers desnecessários."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de esteira: Rung 1 com botão start (NO) em série com sensor de peça (NO) ativando bobina de motor (M1). Rung 2 com contato auxiliar M1 (NO) paralelo ao start para manter o motor ligado até stop (NC). Equivalente a relés: start fecha contato para bobina M1, que fecha seu auxiliar.",
                              "finalVerifications": [
                                "Desenhar um rung equivalente a um circuito relé simples.",
                                "Identificar NO/NC e bobinas em um diagrama Ladder fornecido.",
                                "Explicar o fluxo lógico de um programa com 3 rungs.",
                                "Simular um diagrama em software e prever saídas para entradas dadas.",
                                "Converter verbalmente um circuito físico para Ladder Logic.",
                                "Detectar e corrigir um erro comum em um diagrama (ex: falta de latching)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (100% correto).",
                                "Correta equivalência entre Ladder e relés eletromecânicos.",
                                "Explicação clara do fluxo lógico e estados.",
                                "Criatividade em exemplos práticos propostos.",
                                "Uso correto de terminologia técnica (rung, NO/NC, bobina).",
                                "Demonstração prática via simulação sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Equivalência com circuitos lógicos discretos.",
                                "Programação: Paralelo com linguagens imperativas e fluxogramas.",
                                "Física: Princípios de eletromagnetismo em relés.",
                                "Matemática: Lógica booleana (AND/OR/NOT).",
                                "Automação Industrial: Integração com sensores e atuadores."
                              ],
                              "realWorldApplication": "Na indústria manufatureira, Ladder Logic é usada em CLPs para controlar linhas de produção, como sequências de soldagem em robôs ou sistemas de elevadores, substituindo painéis relés físicos por programação gráfica mais flexível e segura."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Implementar elementos básicos em Ladder Logic",
                            "description": "Criar programas simples utilizando contatos (NO/NC), bobinas, timers (TON/TOF) e contadores (CTU/CTD), simulando comportamentos como partida de motor ou sequências de controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de simulação Ladder Logic",
                                  "subSteps": [
                                    "Baixar e instalar um simulador Ladder Logic gratuito como LogixPro ou OpenPLC Editor.",
                                    "Criar um novo projeto e configurar I/O básicos (entradas como switches, saídas como luzes ou motores).",
                                    "Explorar a interface: rungs, contatos, bobinas e blocos de função.",
                                    "Testar um rung simples com contato NO para acender uma saída.",
                                    "Salvar o projeto e executar simulação inicial."
                                  ],
                                  "verification": "Projeto abre sem erros e um circuito simples de entrada-saída funciona na simulação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Simulador Ladder Logic (LogixPro ou similar)",
                                    "Computador com Windows/Linux"
                                  ],
                                  "tips": "Use atalhos de teclado para inserir elementos rapidamente; sempre salve antes de simular.",
                                  "learningObjective": "Configurar e navegar no ambiente de programação Ladder Logic.",
                                  "commonMistakes": [
                                    "Não mapear I/Os corretamente",
                                    "Esquecer de compilar o programa antes de simular"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar contatos (NO/NC) e bobinas básicas",
                                  "subSteps": [
                                    "Inserir contato NO (Normally Open) em um rung e associar a uma entrada (ex: I:1/0).",
                                    "Adicionar bobina de saída (OTE) para controlar uma lâmpada (ex: O:2/0).",
                                    "Criar contato NC (Normally Closed) em paralelo para lógica de parada de emergência.",
                                    "Testar lógicas: liga/desliga com NO e intertravamento com NC.",
                                    "Adicionar auto-manutenção usando bobina de latch (OTL) e unlatch (OTU)."
                                  ],
                                  "verification": "Circuito simula corretamente: liga com botão, mantém estado e desliga com emergência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador Ladder Logic aberto",
                                    "Diagrama de relés físicos para referência"
                                  ],
                                  "tips": "Visualize o fluxo de energia da esquerda para direita nos rungs.",
                                  "learningObjective": "Construir circuitos lógicos básicos equivalentes a relés eletromecânicos.",
                                  "commonMistakes": [
                                    "Confundir NO com NC",
                                    "Não energizar bobina corretamente para latch"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar timers TON e TOF",
                                  "subSteps": [
                                    "Inserir bloco TON após um contato de partida e configurar preset (ex: 5 segundos).",
                                    "Usar saída do timer (TT) para energizar uma bobina de motor após delay.",
                                    "Implementar TOF para delay na desenergização (off-delay).",
                                    "Testar sequência: partida imediata, motor liga após TON, desliga após TOF.",
                                    "Ajustar presets e monitorar valores acumulados (ACC) durante simulação."
                                  ],
                                  "verification": "Timer conta corretamente e altera estados de saída nos delays especificados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador em execução",
                                    "Cronômetro para validar tempos reais"
                                  ],
                                  "tips": "Sempre defina unidades de tempo (ms/s) no timer para precisão.",
                                  "learningObjective": "Controlar sequências temporizadas usando timers on-delay e off-delay.",
                                  "commonMistakes": [
                                    "Esquecer de resetar timer",
                                    "Preset em formato errado (use decimal)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar contadores CTU e CTD",
                                  "subSteps": [
                                    "Adicionar CTU após um pulso de entrada (use one-shot RTO para gerar pulso).",
                                    "Configurar preset do contador (ex: 3 pulsos para ativar saída).",
                                    "Implementar CTD em paralelo para decremento e reset.",
                                    "Testar contagem ascendente/descendente em uma sequência simulada.",
                                    "Integrar com timers para ciclo completo (ex: contar ciclos de motor)."
                                  ],
                                  "verification": "Contador atinge preset, reseta e controla saídas corretamente após múltiplos pulsos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Projeto anterior salvo",
                                    "Tabela de estados esperados"
                                  ],
                                  "tips": "Use one-shot para evitar contagens múltiplas em sinal contínuo.",
                                  "learningObjective": "Gerenciar contagens para automação de processos repetitivos.",
                                  "commonMistakes": [
                                    "Não usar pulso para incremento",
                                    "Confundir CTU (up) com CTD (down)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Criar e testar programa integrado de partida de motor",
                                  "subSteps": [
                                    "Combinar todos elementos: NO partida, latch, TON para aceleração, CTU para contagem de partidas, NC emergência.",
                                    "Adicionar TOF para cooldown pós-parada e CTD para limite de ciclos.",
                                    "Simular cenários: partida normal, emergência, múltiplos ciclos.",
                                    "Debugar usando force I/O e monitor de forças.",
                                    "Documentar o programa com comentários em cada rung."
                                  ],
                                  "verification": "Programa completo simula partida de motor com delays, contagens e segurança sem falhas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Projeto completo",
                                    "Checklist de testes"
                                  ],
                                  "tips": "Force entradas para testar sem hardware real; use print screens para portfólio.",
                                  "learningObjective": "Integrar elementos básicos em um programa funcional Ladder Logic.",
                                  "commonMistakes": [
                                    "Rungs não sequenciais corretos",
                                    "Falta de intertravamento de segurança"
                                  ]
                                }
                              ],
                              "practicalExample": "Simular partida de motor: Botão de start (NO) ativa latch e TON (5s) para ligar motor; CTU conta 10 partidas; NC de emergência desliga tudo; TOF (3s) para cooldown antes de nova partida.",
                              "finalVerifications": [
                                "Programa compila sem erros de sintaxe.",
                                "Simulação reproduz sequência de motor com timers e contadores precisos.",
                                "Emergência interrompe imediatamente todos os processos.",
                                "Contadores resetam corretamente após preset.",
                                "Comentários explicam cada rung.",
                                "Exportar relatório de simulação com tendências de timers."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação de contatos, bobinas, timers e contadores (100% funcional).",
                                "Uso correto de lógicas de segurança (intertravamento e emergência).",
                                "Eficiência: mínimo de rungs sem redundâncias.",
                                "Documentação clara com comentários e diagramas.",
                                "Testes abrangentes cobrindo cenários normais e de falha.",
                                "Tempos de execução dentro de 10% do preset."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Equivalência com relés e contatos físicos.",
                                "Programação: Lógica booleana similar a linguagens como C ou Python.",
                                "Matemática: Cálculos de tempo e contagem (aritmética modular).",
                                "Física: Comportamento de motores e delays em sistemas dinâmicos.",
                                "Manufatura: Integração com PLCs em linhas de produção."
                              ],
                              "realWorldApplication": "Em indústrias como automotiva ou alimentícia, controla partida sequencial de motores em esteiras transportadoras, garantindo delays para aceleração, contagem de ciclos para manutenção preditiva e paradas de emergência para segurança."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Explorar outras linguagens IEC 61131-3",
                            "description": "Comparar Ladder Logic com Function Block Diagram (FBD), Structured Text (ST) e Instruction List (IL), identificando aplicações ideais para cada uma em projetos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Ladder Logic e Introduzir Conceitos das Outras Linguagens IEC 61131-3",
                                  "subSteps": [
                                    "Relembrar a estrutura gráfica de Ladder Logic (LD): contatos, bobinas e redes lógicas.",
                                    "Ler a norma IEC 61131-3 para entender o conjunto de linguagens padronizadas (LD, FBD, ST, IL).",
                                    "Identificar diferenças iniciais: LD e FBD são gráficas, ST é textual como Pascal, IL é assembly-like.",
                                    "Assistir a um vídeo introdutório (5-10 min) sobre as 4 linguagens principais.",
                                    "Anotar prós e contras iniciais de cada uma com base em documentação básica."
                                  ],
                                  "verification": "Criar um mapa mental comparativo inicial com pelo menos 3 características por linguagem.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Norma IEC 61131-3 (PDF gratuito ou resumo online)",
                                    "Software de simulação CLP como OpenPLC ou Codesys Trial",
                                    "Vídeos tutoriais no YouTube sobre IEC 61131-3"
                                  ],
                                  "tips": "Use diagramas visuais para facilitar a memorização das diferenças gráficas vs. textuais.",
                                  "learningObjective": "Compreender o escopo das linguagens IEC 61131-3 e posicionar Ladder Logic no contexto.",
                                  "commonMistakes": [
                                    "Confundir linguagens gráficas (LD/FBD) com textuais sem exemplos visuais.",
                                    "Ignorar a padronização IEC, assumindo variações proprietárias."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Function Block Diagram (FBD) em Detalhe",
                                  "subSteps": [
                                    "Aprender blocos funcionais: entradas/saídas, operadores lógicos e conexões.",
                                    "Implementar um exemplo simples: lógica AND/OR com blocos FBD em simulador.",
                                    "Comparar sintaxe visual com LD: FBD usa blocos retangulares vs. rungs de LD.",
                                    "Explorar bibliotecas padrão IEC (ex: timers, contadores em FBD).",
                                    "Converter um programa LD simples para FBD e testar funcionalidade."
                                  ],
                                  "verification": "Executar e depurar um programa FBD que controle um LED baseado em dois sensores.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Codesys ou TIA Portal Trial",
                                    "Exemplos de código FBD da documentação Siemens/ Rockwell"
                                  ],
                                  "tips": "Desenhe fluxos de sinal com setas para visualizar o fluxo de dados em FBD.",
                                  "learningObjective": "Dominar a representação gráfica baseada em blocos e suas vantagens em modularidade.",
                                  "commonMistakes": [
                                    "Esquecer de conectar todas as entradas/saídas, causando erros de compilação.",
                                    "Subestimar reutilização de blocos personalizados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Structured Text (ST) e Instruction List (IL)",
                                  "subSteps": [
                                    "Estudar ST: sintaxe procedural (IF-THEN, loops, funções) similar a linguagens de programação.",
                                    "Implementar lógica condicional em ST: ex. controle de temperatura com PID.",
                                    "Analisar IL: formato assembly (códigos mnemônicos como LD, AND, ST).",
                                    "Converter o mesmo programa LD para ST e IL, comparando legibilidade.",
                                    "Testar execução em simulador, medindo tempo de ciclo."
                                  ],
                                  "verification": "Escrever e simular um programa ST/IL que implemente uma sequência de estados finitos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de texto com syntax highlight para ST",
                                    "Simulador OpenPLC com suporte a ST/IL",
                                    "Referência IEC 61131-3 para mnemônicos IL"
                                  ],
                                  "tips": "Para ST, pense como em C/Pascal; para IL, memorize 10 comandos básicos primeiro.",
                                  "learningObjective": "Entender linguagens textuais para otimização e portabilidade de código.",
                                  "commonMistakes": [
                                    "Erros de sintaxe em ST (ponto e vírgula faltando).",
                                    "Usar IL sem otimizar stack pointer."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Linguagens e Identificar Aplicações Ideais em Mecatrônica",
                                  "subSteps": [
                                    "Criar tabela comparativa: legibilidade, performance, debugging, reusabilidade (LD vs FBD/ST/IL).",
                                    "Mapear aplicações: LD para eletricistas, FBD para sistemas modulares, ST para algoritmos complexos, IL para RTOS.",
                                    "Analisar casos mecatrônicos: LD/FBD para painéis I/O, ST para controle avançado (servos), IL para microcontroladores.",
                                    "Discutir trade-offs: tamanho de código, tempo de scan, manutenção.",
                                    "Selecionar linguagem ideal para 3 cenários mecatrônicos hipotéticos."
                                  ],
                                  "verification": "Produzir relatório de 1 página com tabela e recomendações para projetos específicos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela",
                                    "Casos de estudo de automação industrial"
                                  ],
                                  "tips": "Priorize critérios mecatrônicos: integração com PLC hardware e equipes multidisciplinares.",
                                  "learningObjective": "Aplicar comparação para seleção otimizada de linguagens em contextos reais.",
                                  "commonMistakes": [
                                    "Generalizar sem considerar hardware específico do CLP.",
                                    "Ignorar curva de aprendizado da equipe."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Praticar Integração Mista",
                                  "subSteps": [
                                    "Criar programa híbrido: usar LD para I/O, FBD para funções, ST para lógica complexa.",
                                    "Simular um projeto mecatrônico completo: ex. linha de montagem com sensores e atuadores.",
                                    "Avaliar performance e legibilidade do código misto.",
                                    "Documentar lições aprendidas sobre interoperabilidade IEC.",
                                    "Pesquisar exemplos reais de indústrias usando múltiplas linguagens."
                                  ],
                                  "verification": "Executar simulação bem-sucedida de projeto híbrido com log de eventos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador CLP completo",
                                    "Exemplos de código híbrido online"
                                  ],
                                  "tips": "Comece pequeno e itere; use POU (Program Organization Units) para modularidade.",
                                  "learningObjective": "Integrar linguagens para soluções otimizadas em mecatrônica.",
                                  "commonMistakes": [
                                    "Misturar linguagens sem namespaces, causando conflitos.",
                                    "Sobrecarregar scan time com lógica ineficiente."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver o controle de uma esteira transportadora mecatrônica: Use LD para start/stop de emergência, FBD para blocos de sensores de posição, ST para algoritmo de velocidade variável baseado em carga, e IL para otimizações de baixo nível em regiões críticas de tempo real. Simule no Codesys e compare tempos de execução.",
                              "finalVerifications": [
                                "Lista precisa de 5 diferenças chave entre LD e cada linguagem (FBD, ST, IL).",
                                "Tabela comparativa completa com prós/contras e aplicações mecatrônicas.",
                                "Programa funcional em pelo menos duas linguagens alternativas para um mesmo problema.",
                                "Recomendações justificadas para 3 cenários industriais reais.",
                                "Diagrama de fluxo mostrando quando escolher cada linguagem.",
                                "Relatório de simulação com métricas de performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da comparação técnica (30%).",
                                "Relevância das aplicações para projetos mecatrônicos (25%).",
                                "Qualidade dos exemplos práticos e simulações (20%).",
                                "Clareza na tabela/relatório e uso de evidências IEC (15%).",
                                "Criatividade em integrações híbridas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação de computadores: Similaridades com C (ST) e assembly (IL).",
                                "Engenharia de software: Modularidade e reusabilidade de blocos (FBD).",
                                "Eletrônica digital: Lógica booleana em múltiplas representações.",
                                "Gestão de projetos: Seleção de ferramentas baseada em equipe e hardware.",
                                "Matemática: Algoritmos e expressões lógicas."
                              ],
                              "realWorldApplication": "Em fábricas de automação mecatrônica, como linhas de montagem da indústria automotiva (ex: Siemens S7 com LD para manutenção rápida por eletricistas e ST para IA em controle preditivo), otimizando tempo de desenvolvimento, manutenção e performance em cenários de alta confiabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Módulos de Entrada/Saída (E/S) em CLPs",
                        "description": "Módulos expansíveis para interfaces com sensores e atuadores industriais, incluindo tipos digitais/analógicos, configuração de endereços e diagnósticos de falhas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Classificar módulos de E/S digitais e analógicos",
                            "description": "Diferenciar módulos de entrada/saída digitais (24VDC, 120VAC), analógicos (4-20mA, 0-10V) e especiais (RTD, termopares), especificando faixas de sinal e isolação galvânica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de sinais digitais e analógicos em módulos E/S",
                                  "subSteps": [
                                    "Estude a definição de sinal digital: discreto, com níveis lógicos (0/1, ON/OFF).",
                                    "Estude a definição de sinal analógico: contínuo, variando em amplitude (ex: tensão ou corrente proporcional).",
                                    "Identifique diferenças chave: precisão, ruído, processamento em CLPs.",
                                    "Revise exemplos iniciais: interruptor (digital) vs. sensor de temperatura (analógico).",
                                    "Anote faixas típicas: digitais (24VDC, 120VAC), analógicos (4-20mA, 0-10V)."
                                  ],
                                  "verification": "Resuma em um diagrama comparativo digital vs. analógico com pelo menos 5 diferenças.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Datasheet genérico de CLP",
                                    "Vídeo tutorial sobre sinais E/S (YouTube ou curso online)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use analogias cotidianas: digital como interruptor de luz, analógico como dimmer.",
                                  "learningObjective": "Diferenciar sinais digitais e analógicos, identificando suas características básicas.",
                                  "commonMistakes": [
                                    "Confundir sinal digital com alta tensão como analógico.",
                                    "Ignorar impacto do ruído em sinais analógicos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar módulos de E/S digitais",
                                  "subSteps": [
                                    "Liste tipos comuns: 24VDC (sink/source), 120VAC.",
                                    "Analise faixas de sinal: threshold para ON/OFF (ex: >15V para 24VDC).",
                                    "Identifique especificações: número de canais, LED indicadores.",
                                    "Estude diagramas de conexão: fiação para entrada/saída.",
                                    "Compare módulos DC vs. AC em termos de aplicação."
                                  ],
                                  "verification": "Classifique 3 módulos digitais de um catálogo, especificando faixa e tipo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Catálogo de módulos Siemens S7 ou Allen-Bradley",
                                    "Software de simulação CLP (TIA Portal trial)"
                                  ],
                                  "tips": "Verifique se é entrada ou saída no rótulo do módulo.",
                                  "learningObjective": "Classificar corretamente módulos digitais por tensão e tipo de sinal.",
                                  "commonMistakes": [
                                    "Não distinguir sink de source em 24VDC.",
                                    "Esquecer polaridade em DC."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar módulos de E/S analógicos e especiais",
                                  "subSteps": [
                                    "Descreva analógicos: 4-20mA (corrente, imune a ruído), 0-10V (tensão).",
                                    "Liste especiais: RTD (resistência térmica, Pt100), termopares (milivolts, Type K/J).",
                                    "Analise faixas: resolução (12/16 bits), linearidade.",
                                    "Estude condicionamento de sinal: amplificadores, filtros.",
                                    "Compare precisão: analógico vs. digital em sensores."
                                  ],
                                  "verification": "Monte uma tabela com 4 módulos analógicos/especiais, faixas e aplicações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Datasheets de módulos analógicos (ex: Siemens 6ES7131)",
                                    "Tabela de padrões RTD/termopares"
                                  ],
                                  "tips": "Lembre: 4-20mA permite detecção de falha (0mA = cabo rompido).",
                                  "learningObjective": "Identificar e especificar módulos analógicos e especiais por faixa de sinal.",
                                  "commonMistakes": [
                                    "Confundir 0-10V com 4-20mA sem considerar perdas de linha.",
                                    "Ignorar necessidade de linearização em termopares."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar isolação galvânica e especificações completas",
                                  "subSteps": [
                                    "Defina isolação galvânica: barreira elétrica para proteção contra surtos.",
                                    "Identifique em specs: 1500V RMS típico entre canais e bus.",
                                    "Compare módulos com/sem isolação: riscos em ambientes industriais.",
                                    "Revise certificações: UL, CE para isolação.",
                                    "Pratique leitura de placas: sinal, isolação, faixa em um módulo virtual."
                                  ],
                                  "verification": "Explique isolação em 2 módulos e por que é crítica em um relatório curto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Placas técnicas de módulos E/S",
                                    "Vídeo sobre isolação galvânica em CLPs"
                                  ],
                                  "tips": "Procure símbolo de isolação (traços interrompidos) nos diagramas.",
                                  "learningObjective": "Especificar isolação galvânica e integrá-la na classificação de módulos.",
                                  "commonMistakes": [
                                    "Subestimar isolação em módulos analógicos sensíveis.",
                                    "Confundir isolação funcional com galvânica."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CLP Siemens S7-1200, classifique o módulo 6ES7222-1HF32-0XB0 como digital 24VDC (8 entradas sink/source, faixa 0-30V, isolação 500V), e o 6ES7231-4HF32-0XB0 como analógico 4-20mA (2 canais, resolução 16 bits, isolação galvânica 500V).",
                              "finalVerifications": [
                                "Classifica corretamente 24VDC e 120VAC como digitais.",
                                "Especifica faixas exatas para 4-20mA e 0-10V.",
                                "Diferencia RTD de termopar por tipo de sinal.",
                                "Identifica presença de isolação galvânica em specs.",
                                "Explica aplicação de cada tipo em um sistema mecatrônico.",
                                "Monte tabela comparativa sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na diferenciação digital/analógico (90%+ correto).",
                                "Correta especificação de faixas de sinal (todas listadas).",
                                "Compreensão de isolação galvânica com exemplos.",
                                "Uso correto de terminologia técnica.",
                                "Capacidade de ler e interpretar datasheets.",
                                "Aplicação prática em cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Princípios de circuitos e sinais.",
                                "Programação de CLPs: Configuração de canais E/S no software.",
                                "Física: Sensores e transdutores térmicos.",
                                "Segurança Industrial: Normas de isolação e proteção.",
                                "Automação: Integração em PLC/SCADA."
                              ],
                              "realWorldApplication": "Em uma linha de produção automotiva, classificar módulos permite conectar sensores analógicos (pressão 4-20mA) e atuadores digitais (24VDC solenoides), garantindo isolação galvânica para evitar falhas por ruído EMI em ambientes industriais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Configurar endereçamento de módulos de E/S",
                            "description": "Atribuir endereços lógicos aos módulos via DIP switches ou software, mapeando entradas/saídas físicas para variáveis no programa ladder, considerando expansão modular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar documentação e preparar hardware",
                                  "subSteps": [
                                    "Ler o manual do CLP para entender o sistema de endereçamento (slots, DIP switches ou software).",
                                    "Identificar os módulos de E/S disponíveis e seus slots de instalação na rack.",
                                    "Verificar a configuração base da CPU e planejar endereços lógicos para expansão.",
                                    "Desligar a alimentação do CLP e instalar os módulos nos slots corretos.",
                                    "Inspecionar DIP switches nos módulos para configuração inicial."
                                  ],
                                  "verification": "O aluno descreve corretamente o esquema de endereçamento e mostra módulos instalados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Manual do CLP",
                                    "Módulos de E/S",
                                    "Rack de expansão",
                                    "Ferramentas de montagem"
                                  ],
                                  "tips": "Sempre priorize a segurança: desligue a energia antes de manipular hardware.",
                                  "learningObjective": "Compreender o esquema de endereçamento físico e lógico do CLP.",
                                  "commonMistakes": [
                                    "Ignorar limitações de slots da CPU",
                                    "Não ler manual antes da instalação",
                                    "Confundir ordem de slots"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar endereços físicos via DIP switches",
                                  "subSteps": [
                                    "Localizar os DIP switches no módulo de E/S (geralmente 8-16 switches).",
                                    "Definir o endereço base do módulo conforme tabela do manual (ex: binário para slot 1 = 0001).",
                                    "Ajustar switches para mapear entradas/saídas físicas (ex: 16 entradas em %I0.0 a %I0.15).",
                                    "Verificar configurações com multímetro se aplicável e registrar endereços.",
                                    "Repetir para módulos adicionais considerando expansão sequencial."
                                  ],
                                  "verification": "DIP switches ajustados corretamente e endereço base confirmado visualmente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Módulos de E/S com DIP switches",
                                    "Manual de configuração",
                                    "Lupa ou lanterna para switches pequenos"
                                  ],
                                  "tips": "Use a representação binária: switch 1 (MSB) para bit mais significativo.",
                                  "learningObjective": "Dominar configuração física de endereços em módulos.",
                                  "commonMistakes": [
                                    "Erro na conversão binária",
                                    "Inverter MSB/LSB",
                                    "Não considerar paridade ou terminadores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar endereços lógicos no software",
                                  "subSteps": [
                                    "Abrir o software do CLP (ex: TIA Portal ou RSLogix).",
                                    "Criar ou abrir projeto e acessar configuração de hardware.",
                                    "Adicionar módulos à configuração I/O e atribuir endereços lógicos automáticos ou manuais.",
                                    "Mapear entradas/saídas físicas para variáveis (ex: %IX0.0 para sensor).",
                                    "Compilar e fazer download da configuração para o CLP."
                                  ],
                                  "verification": "Configuração compilada sem erros e download realizado com sucesso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Computador com software CLP",
                                    "Cabo de programação",
                                    "CLP energizado"
                                  ],
                                  "tips": "Salve o projeto antes do download e verifique conflitos de endereço.",
                                  "learningObjective": "Mapear endereços físicos para lógicos em programas ladder.",
                                  "commonMistakes": [
                                    "Conflitos de endereço entre módulos",
                                    "Esquecer de compilar",
                                    "Variáveis com nomes inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e verificar mapeamento no programa ladder",
                                  "subSteps": [
                                    "Criar programa ladder simples testando E/S (ex: entrada acende saída).",
                                    "Simular ou conectar sensores reais e executar o programa.",
                                    "Monitorar variáveis online para confirmar mapeamento (ex: %I0.0 ativa %Q0.0).",
                                    "Testar expansão adicionando módulo extra e reconfigurando.",
                                    "Documentar configuração final e resolver anomalias."
                                  ],
                                  "verification": "Programa ladder executa corretamente com E/S mapeadas e sem falhas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Sensores e atuadores de teste",
                                    "Software em modo online",
                                    "Multímetro"
                                  ],
                                  "tips": "Use modo de simulação primeiro para evitar danos em hardware real.",
                                  "learningObjective": "Validar configuração de endereçamento em operação real.",
                                  "commonMistakes": [
                                    "Não testar todas as E/S",
                                    "Ignorar delays de scan",
                                    "Falhar em detectar conflitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CLP Allen-Bradley MicroLogix 1400 com rack de expansão, instale um módulo 1762-IF2 em slot 1 (DIP para endereço 1), configure no RSLogix 500 como I:1.0 a I:1.15, crie ladder com XIC(I:1.0) OTE(O:2.0) e teste com potenciômetro conectado.",
                              "finalVerifications": [
                                "Todos os módulos têm endereços únicos sem conflitos.",
                                "Mapeamento físico-lógico confirmado via monitoramento online.",
                                "Programa ladder responde corretamente a estímulos em E/S.",
                                "Expansão modular testada com novo módulo adicionado.",
                                "Documentação de endereços completa e precisa.",
                                "Sistema opera estável por 10 ciclos de teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de DIP switches (sem erros binários).",
                                "Eficiência no mapeamento software (tempo < 60 min total).",
                                "Ausência de erros de compilação ou download.",
                                "Sucesso em testes práticos (100% de E/S funcionais).",
                                "Capacidade de explicar processo e resolver falhas.",
                                "Documentação clara e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica digital: Compreensão de lógica binária e switches.",
                                "Programação: Variáveis e mapeamento em linguagens ladder.",
                                "Manutenção industrial: Diagnóstico de falhas em automação.",
                                "Redes e comunicação: Integração com protocolos como Profibus.",
                                "Segurança do trabalho: Procedimentos com alta tensão."
                              ],
                              "realWorldApplication": "Em fábricas de automação, como linhas de montagem de automóveis, onde CLPs expandem E/S para monitorar centenas de sensores e atuadores, permitindo escalabilidade sem recabeamento total."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1",
                              "10.1.4.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Diagnosticar falhas em módulos de E/S",
                            "description": "Interpretar LEDs de status, códigos de erro e ferramentas de software para identificar problemas como curto-circuito, perda de sinal ou falha de comunicação no barramento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inspeção Visual e Verificação de LEDs de Status",
                                  "subSteps": [
                                    "Examine o módulo E/S externamente por danos físicos, como quebras, corrosão ou conexões soltas.",
                                    "Localize e observe os LEDs de status (power, input/output, communication, error).",
                                    "Registre o padrão de iluminação (fixo, piscando, cor: verde, vermelho, amarelo).",
                                    "Compare o padrão observado com a tabela de LEDs no manual do módulo.",
                                    "Anote discrepâncias iniciais, como ausência de luz em LED de alimentação."
                                  ],
                                  "verification": "Lista de observações dos LEDs registrada e comparada corretamente com o manual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Módulo E/S do CLP",
                                    "Manual do fabricante",
                                    "Lanterna",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": [
                                    "Use luvas antiestáticas para evitar danos ESD.",
                                    "Fotografe os LEDs para registro permanente.",
                                    "Verifique em ambiente com boa iluminação."
                                  ],
                                  "learningObjective": "Identificar o status operacional inicial do módulo através de inspeção visual e LEDs.",
                                  "commonMistakes": [
                                    "Ignorar LEDs secundários como 'fault' ou 'comm'.",
                                    "Confundir piscar rápido com piscar lento.",
                                    "Não consultar o manual específico do modelo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Análise de Códigos de Erro no Software do CLP",
                                  "subSteps": [
                                    "Conecte o computador ao CLP via cabo de programação (Ethernet ou serial).",
                                    "Abra o software de configuração do CLP (ex: TIA Portal, RSLogix).",
                                    "Acesse a seção de diagnóstico ou status I/O e leia os códigos de erro atuais.",
                                    "Consulte a base de dados de erros do software ou manual para decodificar (ex: 0x8080 para falha de barramento).",
                                    "Registre códigos associados ao módulo específico (endereço I/O)."
                                  ],
                                  "verification": "Códigos de erro listados e interpretados corretamente com referências do manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Computador com software do CLP instalado",
                                    "Cabo de programação",
                                    "Manual de erros do CLP"
                                  ],
                                  "tips": [
                                    "Atualize o software para evitar falsos positivos.",
                                    "Faça download do log de erros para análise offline.",
                                    "Verifique se o CLP está em modo RUN."
                                  ],
                                  "learningObjective": "Ler e interpretar códigos de erro do software para mapear falhas potenciais.",
                                  "commonMistakes": [
                                    "Não sincronizar o software com o CLP.",
                                    "Interpretar códigos genéricos sem contexto do módulo.",
                                    "Ignorar histórico de erros passados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Utilização de Ferramentas de Diagnóstico de Hardware e Software",
                                  "subSteps": [
                                    "Meça tensões de alimentação no módulo com multímetro (ex: 24V DC).",
                                    "Teste sinais de entrada/saída com simulador ou loop de teste.",
                                    "Use osciloscópio para verificar integridade de sinais no barramento (ex: ausência de pulso).",
                                    "Execute testes integrados do software (force I/O) e monitore respostas.",
                                    "Identifique anomalias como curto-circuito (corrente excessiva) ou perda de sinal (sem variação)."
                                  ],
                                  "verification": "Resultados de testes documentados com medições numéricas e waveforms se aplicável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Multímetro digital",
                                    "Osciloscópio portátil",
                                    "Simulador de sinais I/O",
                                    "Software de teste do CLP"
                                  ],
                                  "tips": [
                                    "Desligue o CLP antes de testes elétricos.",
                                    "Use sondas adequadas para evitar curtos.",
                                    "Compare com módulo funcionante como referência."
                                  ],
                                  "learningObjective": "Aplicar ferramentas de medição para confirmar falhas elétricas e de sinal.",
                                  "commonMistakes": [
                                    "Medir sem desconectar cargas.",
                                    "Confundir ruído com sinal válido.",
                                    "Não calibrar instrumentos antes do uso."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretação Integrada e Identificação da Falha Específica",
                                  "subSteps": [
                                    "Correlacione dados de LEDs, códigos de erro e testes (ex: LED vermelho + erro 0x45 = falha barramento).",
                                    "Classifique a falha: curto-circuito, perda de sinal, falha comunicação ou defeito interno.",
                                    "Proponha causa raiz baseada em padrões (ex: curto por fiação danificada).",
                                    "Documente relatório com evidências e passos de correção sugeridos.",
                                    "Teste correção simulada ou real se seguro."
                                  ],
                                  "verification": "Relatório de falha completo com diagnóstico preciso e evidências cruzadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Relatório modelo",
                                    "Manual de troubleshooting",
                                    "Computador para edição"
                                  ],
                                  "tips": [
                                    "Use matriz de decisão para correlação.",
                                    "Consulte fóruns ou suporte fabricante se código raro.",
                                    "Priorize falhas de segurança."
                                  ],
                                  "learningObjective": "Sintetizar todas as informações para diagnosticar precisamente a falha.",
                                  "commonMistakes": [
                                    "Isolar dados sem correlação.",
                                    "Diagnosticar prematuramente sem testes.",
                                    "Omitir documentação de evidências."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma célula robótica, o módulo de entrada não registra sensores de proximidade. LEDs mostram vermelho piscando em 'input fault' e código 0x1234 no software indica perda de sinal. Multímetro revela 24V ok, mas osciloscópio mostra sinal intermitente no barramento devido a conector solto. Correção: reconectar e testar.",
                              "finalVerifications": [
                                "Lista correta de significados de 5 LEDs comuns de um módulo E/S.",
                                "Interpretação precisa de 3 códigos de erro exemplo.",
                                "Diagrama de fluxo de diagnóstico executado sem erros.",
                                "Identificação simulada de curto-circuito vs. falha de comunicação.",
                                "Relatório de falha completo e acionável.",
                                "Teste prático em módulo real com acerto >90%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de LEDs e códigos (80%+ correto).",
                                "Completude dos testes com ferramentas (todos substeps cobertos).",
                                "Tempo total de diagnóstico <1 hora.",
                                "Qualidade do relatório (claro, com evidências).",
                                "Correlação interdisciplinar demonstrada.",
                                "Segurança em todos os procedimentos."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Medição de sinais e tensões.",
                                "Programação: Leitura de diagnósticos em software industrial.",
                                "Segurança do Trabalho: Lockout/Tagout em manutenção.",
                                "Manutenção Preditiva: Uso de dados para análise de falhas recorrentes.",
                                "Redes Industriais: Entendimento de protocolos de barramento."
                              ],
                              "realWorldApplication": "Na manutenção de linhas de produção automatizadas em indústrias como automotiva ou alimentícia, permitindo identificar falhas em módulos E/S rapidamente, reduzindo paradas não planejadas (downtime) em até 50% e evitando custos de substituição desnecessária."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Aplicações em Sistemas Mecatrônicos",
                    "description": "Integração de microprocessadores, microcontroladores e CLPs em projetos mecatrônicos, incluindo controle e automação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Integração de Microprocessadores em Sistemas Mecatrônicos",
                        "description": "Exploração da aplicação de microprocessadores para processamento de sinais e controle em projetos mecatrônicos, incluindo interfaces com sensores e atuadores.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Selecionar microprocessador adequado",
                            "description": "Analisar requisitos de desempenho, consumo de energia e interfaces para escolher microprocessadores apropriados em projetos mecatrônicos de controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Documentar Requisitos do Projeto",
                                  "subSteps": [
                                    "Liste os componentes do sistema mecatrônico (sensores, atuadores, comunicação).",
                                    "Defina métricas de desempenho: velocidade de processamento (MHz), memória RAM/Flash necessária (KB/MB).",
                                    "Avalie restrições de energia: tensão de alimentação, consumo em mA (ativo/inativo).",
                                    "Identifique interfaces requeridas: GPIO, I2C, SPI, UART, ADC, PWM.",
                                    "Considere fatores adicionais: custo, disponibilidade, suporte de software."
                                  ],
                                  "verification": "Checklist de requisitos completo e assinado, com valores quantitativos para cada métrica.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Planilha de requisitos (Excel/Google Sheets)",
                                    "Especificações do projeto",
                                    "Datasheets de sensores/atuadores"
                                  ],
                                  "tips": "Priorize requisitos críticos usando MoSCoW (Must, Should, Could, Won't).",
                                  "learningObjective": "Mapear necessidades funcionais do projeto para especificações técnicas de hardware.",
                                  "commonMistakes": [
                                    "Subestimar necessidades de memória para buffers de dados",
                                    "Ignorar modos de baixo consumo para aplicações battery-powered",
                                    "Esquecer compatibilidade de pinagem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar e Listar Microprocessadores Candidatos",
                                  "subSteps": [
                                    "Consulte catálogos de fabricantes (STMicro, Microchip, NXP, Espressif).",
                                    "Busque opções com famílias semelhantes (ARM Cortex-M, AVR, PIC).",
                                    "Selecione 4-6 candidatos que atendam parcialmente aos requisitos iniciais.",
                                    "Colete dados preliminares: clock speed, memória, periféricos de cada um.",
                                    "Crie uma tabela comparativa inicial com links para datasheets."
                                  ],
                                  "verification": "Lista de 4-6 microprocessadores com tabela preenchida e fontes citadas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Sites de fabricantes (DigiKey, Mouser)",
                                    "Ferramentas de busca como Octopart",
                                    "Datasheets em PDF"
                                  ],
                                  "tips": "Use filtros avançados em distribuidores para refinar buscas por pin count e pacote.",
                                  "learningObjective": "Desenvolver habilidades de pesquisa eficiente em componentes eletrônicos.",
                                  "commonMistakes": [
                                    "Focar apenas em microcontroladores populares como Arduino, ignorando opções industriais",
                                    "Não verificar EOL (End-of-Life) status",
                                    "Confundir microprocessadores com microcontroladores integrados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar e Comparar Critérios Chave",
                                  "subSteps": [
                                    "Pontue desempenho: MIPS, FPU para cálculos floating-point.",
                                    "Calcule consumo: Icc em diferentes modos, eficiência em mA/MHz.",
                                    "Verifique interfaces: número e velocidade de canais I2C/SPI/etc.",
                                    "Compare custo unitário e ferramentas de desenvolvimento (IDE, debuggers).",
                                    "Aplique pesos aos critérios (ex: desempenho 40%, energia 30%) e calcule scores."
                                  ],
                                  "verification": "Matriz de decisão preenchida com scores normalizados e gráficos comparativos.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Planilha avançada com fórmulas",
                                    "Calculadora de potência online",
                                    "Ferramentas como KiCad para simulação de pinos"
                                  ],
                                  "tips": "Use método AHP (Analytic Hierarchy Process) para pesos subjetivos.",
                                  "learningObjective": "Aplicar análise multicritério para tomada de decisão técnica.",
                                  "commonMistakes": [
                                    "Dar peso igual a todos critérios sem priorização",
                                    "Usar dados de marketing em vez de datasheets",
                                    "Ignorar overhead de software no consumo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar, Justificar e Validar Escolha",
                                  "subSteps": [
                                    "Escolha o top 1-2 baseado na pontuação mais alta.",
                                    "Escreva justificativa detalhada ligando specs aos requisitos.",
                                    "Simule integração básica (ex: blink LED ou leitura sensor).",
                                    "Verifique escalabilidade e riscos (ex: supply chain).",
                                    "Documente alternativas rejeitadas e razões."
                                  ],
                                  "verification": "Relatório final de 1-2 páginas com seleção justificada e protótipo funcional simples.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Placa de desenvolvimento do candidato selecionado",
                                    "IDE (STM32Cube, Arduino IDE)",
                                    "Multímetro para medição de corrente"
                                  ],
                                  "tips": "Teste real de consumo com osciloscópio se possível.",
                                  "learningObjective": "Sintetizar análise em decisão acionável com validação empírica.",
                                  "commonMistakes": [
                                    "Selecionar pelo preço mais baixo sem balancear performance",
                                    "Não testar protótipo antes da decisão final",
                                    "Esquecer certificações (ex: automotive grade)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de irrigação autônomo com 4 sensores de umidade (I2C), bomba PWM e comunicação WiFi, bateria solar 5V/2Ah: Analise requisitos (32KB RAM min, <50mA avg), pesquise ESP32 vs STM32F4, compare (ESP32 vence por WiFi integrado e baixo custo), valide com sketch básico medindo 35mA idle.",
                              "finalVerifications": [
                                "Lista requisitos com valores quantitativos corretos.",
                                "Matriz de comparação mostra trade-offs claros.",
                                "Justificativa liga specs diretamente aos requisitos.",
                                "Protótipo simples roda sem erros de interface.",
                                "Identifica 2-3 riscos potenciais da escolha.",
                                "Sugere upgrades para cenários futuros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de requisitos (80% cobertura).",
                                "Qualidade da pesquisa (fontes confiáveis, 4+ opções).",
                                "Rigor na comparação (métricas quantificadas, pesos lógicos).",
                                "Profundidade da justificativa (evidências de dados).",
                                "Validação prática (medidas reais de consumo/performance).",
                                "Clareza da documentação (visual aids como tabelas/gráficos)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Entender pinouts e periféricos analógicos/digitais.",
                                "Programação: Compatibilidade com RTOS e linguagens (C++, MicroPython).",
                                "Gestão de Projetos: Análise de risco e análise custo-benefício.",
                                "Sustentabilidade: Otimização de energia para IoT green.",
                                "Matemática: Cálculos de pontuação ponderada e eficiência energética."
                              ],
                              "realWorldApplication": "Em fábricas de automação, engenheiros selecionam MCUs como STM32 para PLCs que controlam linhas de montagem, balanceando alto desempenho para PID loops com baixo consumo para operação 24/7, reduzindo custos operacionais em 20%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Desenvolver firmware para controle",
                            "description": "Implementar algoritmos de controle em assembly ou C para microprocessadores, integrando feedback de sensores em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise de Requisitos e Design do Algoritmo de Controle",
                                  "subSteps": [
                                    "Identificar sensores (ex: encoders, potenciômetros) e atuadores (ex: motores, servos) do sistema mecatrônico.",
                                    "Definir tipo de algoritmo de controle (PID, bang-bang ou state-space).",
                                    "Especificar entradas (setpoint, feedback), saídas e variáveis internas.",
                                    "Elaborar fluxograma ou diagrama de blocos do loop de controle.",
                                    "Calcular constantes iniciais do controlador com base em modelo matemático simplificado."
                                  ],
                                  "verification": "Fluxograma e especificação técnica documentados e revisados.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de diagramação (Draw.io ou Visio)",
                                    "Documentação técnica de sensores e microprocessadores",
                                    "Folha de cálculo para simulações iniciais"
                                  ],
                                  "tips": "Priorize modelos lineares iniciais para simplicidade antes de considerar não-linearidades.",
                                  "learningObjective": "Projetar algoritmos de controle adaptados às especificações do sistema mecatrônico.",
                                  "commonMistakes": [
                                    "Ignorar saturação de atuadores",
                                    "Subestimar ruído de sensores",
                                    "Não definir faixas operacionais claras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração do Ambiente de Desenvolvimento e Hardware",
                                  "subSteps": [
                                    "Instalar IDE e toolchain (ex: PlatformIO para C ou AVR Studio para assembly).",
                                    "Conectar microprocessador ao programador e verificar comunicação via serial/USB.",
                                    "Configurar periféricos: ADC para sensores analógicos, PWM/Timer para atuadores.",
                                    "Implementar e testar código básico de leitura de sensor e saída PWM.",
                                    "Verificar configuração de clock, interrupções e alimentação do hardware."
                                  ],
                                  "verification": "Teste básico (blink LED + leitura ADC) executa corretamente no hardware.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Microcontrolador (ex: ATMega328 ou STM32)",
                                    "Programador (USBasp ou ST-Link)",
                                    "Multímetro e osciloscópio básico",
                                    "Computador com IDE instalada"
                                  ],
                                  "tips": "Use breadboard para prototipagem rápida e evite soldas prematuras.",
                                  "learningObjective": "Configurar hardware e software para desenvolvimento embarcado eficiente.",
                                  "commonMistakes": [
                                    "Configurações erradas de clock levando a timing issues",
                                    "Pinos mal mapeados",
                                    "Alimentação instável causando resets"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação do Algoritmo de Controle em C ou Assembly",
                                  "subSteps": [
                                    "Estruturar código principal com setup(), loop() e funções modulares.",
                                    "Implementar rotina de leitura de sensores com média móvel para filtragem.",
                                    "Codificar algoritmo de controle (ex: PID com anti-windup em C).",
                                    "Gerar saídas PWM ou duty cycle para atuadores.",
                                    "Adicionar tratamento de erros e watchdog timer."
                                  ],
                                  "verification": "Código compila, faz upload e executa loop de controle sem crashes.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Editor de código/IDE",
                                    "Documentação do microcontrolador (datasheet)",
                                    "Simulador embarcado opcional (Proteus)"
                                  ],
                                  "tips": "Use estruturas de dados fixas para otimizar memória em assembly.",
                                  "learningObjective": "Traduzir design matemático em código embarcado eficiente.",
                                  "commonMistakes": [
                                    "Overflow em variáveis de erro acumulado",
                                    "Frequência de amostragem inadequada",
                                    "Falta de proteção contra divisão por zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração de Feedback de Sensores e Testes Iniciais",
                                  "subSteps": [
                                    "Conectar sensores físicos e calibrar offsets/gains via software.",
                                    "Executar testes em open-loop para validar entradas/saídas.",
                                    "Fechar loop de controle e monitorar resposta via serial plotter.",
                                    "Ajustar ganhos (Kp, Ki, Kd) iterativamente para estabilidade.",
                                    "Registrar dados de teste para análise de overshoot e settling time."
                                  ],
                                  "verification": "Sistema mantém setpoint com erro estacionário < 2% em condições nominais.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Sensores reais (encoder, termistor)",
                                    "Atuadores (motor DC com driver)",
                                    "Fonte de alimentação regulada",
                                    "Display serial ou osciloscópio"
                                  ],
                                  "tips": "Comece com ganhos baixos para evitar oscilações destrutivas.",
                                  "learningObjective": "Integrar e validar feedback em tempo real no hardware.",
                                  "commonMistakes": [
                                    "Calibração inadequada de sensores",
                                    "Atrasos de amostragem causando instabilidade",
                                    "Ignorar dead-zones em atuadores"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Depuração, Otimização e Validação Final",
                                  "subSteps": [
                                    "Usar debugger/JTAG para inspecionar variáveis em tempo real.",
                                    "Otimizar código: reduzir ciclos CPU e footprint de memória.",
                                    "Testar robustez com ruídos, falhas e variações de carga.",
                                    "Documentar código-fonte, parâmetros e procedimentos de setup.",
                                    "Preparar firmware para integração em sistema mecatrônico maior."
                                  ],
                                  "verification": "Firmware opera estável por 1 hora contínua com perturbações.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Debugger hardware",
                                    "Ferramentas de profiling (timer interrupts)",
                                    "Checklist de testes"
                                  ],
                                  "tips": "Implemente logging condicional para depuração sem impactar performance.",
                                  "learningObjective": "Garantir robustez e manutenibilidade do firmware desenvolvido.",
                                  "commonMistakes": [
                                    "Depuração sem breakpoints estratégicos",
                                    "Otimização prematura sem profiling",
                                    "Falta de testes de borda"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver firmware PID em C para microcontrolador STM32 que controla a posição de um braço robótico mecatrônico, usando encoder óptico como sensor de feedback e servo motor como atuador, mantendo precisão de 1 grau em movimentos dinâmicos.",
                              "finalVerifications": [
                                "Firmware compila e faz upload sem warnings ou erros.",
                                "Loop de controle responde a setpoints com settling time < 500ms.",
                                "Sensores são lidos com taxa de amostragem > 100Hz sem perda de dados.",
                                "Nenhum overflow, reset ou instabilidade observada em 30 minutos de teste.",
                                "Código possui comentários em >80% das funções e variáveis chave.",
                                "Performance atende especificações: uso de CPU <70%, memória <80%."
                              ],
                              "assessmentCriteria": [
                                "Precisão de controle: erro médio <1% do range.",
                                "Estabilidade: ausência de oscilações sustentadas.",
                                "Tempo de resposta: rise time <200ms para step input.",
                                "Eficiência computacional: ciclo de loop <10ms.",
                                "Robustez: performance mantida com ±20% variação em parâmetros.",
                                "Qualidade do código: modularidade, legibilidade e documentação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem diferencial e transformada de Laplace para PID.",
                                "Eletrônica: Condicionamento de sinais e interfaces A/D.",
                                "Programação: Algoritmos em tempo real e gerenciamento de interrupções.",
                                "Física: Cinemática e dinâmica de sistemas mecatrônicos.",
                                "Automação: Integração com CLPs e redes industriais."
                              ],
                              "realWorldApplication": "Controle de posição em robôs industriais de soldagem, onde firmware em microcontroladores integra encoders e motores para precisão milimétrica, reduzindo defeitos em linhas de produção automotiva."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Integrar com atuadores mecânicos",
                            "description": "Conectar microprocessadores a motores e servos, gerenciando PWM e comunicação serial para automação mecatrônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Conectar Hardware de Atuadores Mecânicos",
                                  "subSteps": [
                                    "Identifique o tipo de atuador (motor DC, servo ou stepper) compatível com o microcontrolador (ex: Arduino ou ESP32).",
                                    "Verifique as especificações elétricas: tensão, corrente e pinos necessários (PWM para controle de velocidade/posição).",
                                    "Monte o circuito: conecte o atuador ao pino PWM do microcontrolador, adicione resistores, diodos de proteção e fonte de alimentação externa se necessário.",
                                    "Use protoboard ou PCB para conexões seguras e solde componentes para durabilidade.",
                                    "Teste continuidade com multímetro para evitar curtos-circuitos."
                                  ],
                                  "verification": "Circuito montado sem erros, medido com multímetro mostrando continuidade e sem curto entre VCC/GND.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Microcontrolador (Arduino/ESP32)",
                                    "Motor DC ou Servo SG90",
                                    "Protoboard",
                                    "Jumpers",
                                    "Multímetro",
                                    "Fonte 5V/12V",
                                    "Diodo 1N4007"
                                  ],
                                  "tips": "Sempre desconecte a alimentação antes de manipular fios para evitar danos.",
                                  "learningObjective": "Compreender conexões físicas seguras entre microcontroladores e atuadores mecânicos.",
                                  "commonMistakes": [
                                    "Conectar diretamente à porta USB sem fonte externa (causa superaquecimento)",
                                    "Inverter polaridade do motor",
                                    "Esquecer diodo flyback em motores indutivos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar PWM para Controle de Velocidade e Posição",
                                  "subSteps": [
                                    "Instale o IDE do microcontrolador e selecione a biblioteca Servo.h para servos ou analogWrite para PWM em motores DC.",
                                    "Defina o pino PWM (ex: pin 9 no Arduino) e configure a frequência (geralmente 50Hz para servos).",
                                    "Escreva código básico: mapa valores de 0-180 graus para servos ou 0-255 para duty cycle em motores.",
                                    "Compile e faça upload do sketch de teste simples (ex: varrer posição do servo).",
                                    "Monitore o sinal PWM com osciloscópio ou multímetro para validar saída."
                                  ],
                                  "verification": "Atuador responde corretamente a comandos PWM: servo gira de 0-180° suavemente, motor varia velocidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Computador com IDE Arduino/ESP-IDF",
                                    "Cabo USB",
                                    "Osciloscópio ou multímetro (opcional)"
                                  ],
                                  "tips": "Use delay() para movimentos suaves e evite bloqueios no loop principal.",
                                  "learningObjective": "Dominar modulação PWM para controle preciso de atuadores.",
                                  "commonMistakes": [
                                    "Usar pinos não-PWM (digitalWrite em vez de analogWrite)",
                                    "Frequência errada para servo (causa jitter)",
                                    "Duty cycle acima de 100% (255 no Arduino)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Comunicação Serial para Controle Remoto",
                                  "subSteps": [
                                    "Configure Serial.begin(9600) no setup() e leia comandos via Serial.read() ou Serial.parseInt().",
                                    "Mapeie comandos seriais para ações: ex: 'M100' para motor 100% velocidade, 'S90' para servo em 90°.",
                                    "Adicione parsing de strings com delimitadores (ex: vírgula) para múltiplos parâmetros.",
                                    "Integre lógica de controle: if/else para processar comandos recebidos.",
                                    "Teste com monitor serial enviando comandos manualmente."
                                  ],
                                  "verification": "Comandos seriais controlam atuadores corretamente via Monitor Serial.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Monitor Serial no IDE",
                                    "Terminal externo como PuTTY (opcional)"
                                  ],
                                  "tips": "Flush serial buffer com Serial.flush() após leitura para evitar comandos duplicados.",
                                  "learningObjective": "Integrar comunicação serial como interface de controle para atuadores.",
                                  "commonMistakes": [
                                    "Baud rate mismatch entre emissor/receptor",
                                    "Não limpar buffer serial (comandos fantasma)",
                                    "Ignorar caracteres de nova linha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Integração e Depuração do Sistema Completo",
                                  "subSteps": [
                                    "Execute teste end-to-end: envie comandos seriais e observe resposta mecânica.",
                                    "Monitore variáveis com Serial.print() para debug (ex: duty cycle atual).",
                                    "Ajuste deadbands e rampas de aceleração para movimentos suaves.",
                                    "Simule falhas: desconecte fios, envie comandos inválidos e corrija.",
                                    "Documente o sistema com diagrama Fritzing e código comentado."
                                  ],
                                  "verification": "Sistema responde a sequência de comandos seriais sem falhas, com movimentos precisos e estáveis.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Fritzing ou software similar para diagramas"
                                  ],
                                  "tips": "Use funções modulares (ex: controlMotor(), moveServo()) para código reutilizável.",
                                  "learningObjective": "Validar e otimizar integração de microprocessadores com atuadores em automação.",
                                  "commonMistakes": [
                                    "Sobrecarga térmica por duty cycle contínuo alto",
                                    "Ruído serial interferindo em comandos",
                                    "Falta de limites de segurança (ex: max 180° no servo)"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um braço robótico simples com servo para garra e motor DC para rotação base. Envie comandos seriais como 'R90,G50' via app Bluetooth (HC-05) para posicionar e abrir/fechar a garra, simulando pick-and-place em linha de produção.",
                              "finalVerifications": [
                                "Motor/servo responde instantaneamente a comandos PWM via serial sem delay >500ms.",
                                "Sistema opera por 10 minutos contínuos sem superaquecimento ou perda de sinal.",
                                "Movimentos são precisos (±5° para servos, ±10% velocidade para motores).",
                                "Código lida com comandos inválidos sem crashar (graceful error handling).",
                                "Diagrama elétrico e código estão documentados e reproduzíveis.",
                                "Consumo de corrente medido < limite da fonte (ex: <1A para servo)"
                              ],
                              "assessmentCriteria": [
                                "Precisão e estabilidade do controle PWM (sem jitter ou oscilações).",
                                "Robustez da comunicação serial (taxa de erro <1%).",
                                "Segurança elétrica (sem curtos, proteções adequadas).",
                                "Eficiência do código (otimizado, modular e comentado).",
                                "Criatividade na aplicação prática e depuração proativa.",
                                "Documentação completa (esquemas, código, testes)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de eletromagnetismo e torque em motores.",
                                "Programação: Estruturas condicionais, parsing de strings e controle de loops.",
                                "Eletrônica: Circuitos de potência e sinal (PWM, proteção).",
                                "Matemática: Mapeamento linear (duty cycle vs velocidade).",
                                "Engenharia: Design de sistemas mecatrônicos integrados."
                              ],
                              "realWorldApplication": "Em fábricas de automação industrial, como linhas de montagem robóticas (ex: braços da ABB ou Fanuc), onde microcontroladores gerenciam servos/motores via protocolos seriais para precisão em soldagem, pintura ou logística."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Integração de Microcontroladores em Projetos Mecatrônicos",
                        "description": "Uso de microcontroladores como Arduino ou STM32 para prototipagem rápida e controle embarcado em aplicações mecatrônicas industriais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Configurar ambiente de desenvolvimento",
                            "description": "Instalar IDEs e bibliotecas para microcontroladores, configurando pinagens e periféricos para projetos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Instalar o IDE Adequado",
                                  "subSteps": [
                                    "Pesquise IDEs compatíveis com microcontroladores comuns em mecatrônica (ex: Arduino IDE, PlatformIO, STM32CubeIDE).",
                                    "Baixe a versão mais recente do site oficial do fabricante.",
                                    "Execute o instalador e siga as instruções de instalação padrão para o seu SO (Windows, Linux ou macOS).",
                                    "Verifique se o IDE foi instalado corretamente abrindo-o pela primeira vez.",
                                    "Configure preferências iniciais como tema e linguagem de interface."
                                  ],
                                  "verification": "IDE abre sem erros e exibe a tela inicial de novos sketches.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Computador com internet",
                                    "Espaço em disco (mínimo 500MB)",
                                    "Site oficial do IDE"
                                  ],
                                  "tips": "Use a versão LTS se disponível para estabilidade em projetos educacionais.",
                                  "learningObjective": "Entender a importância de escolher um IDE compatível e instalá-lo corretamente.",
                                  "commonMistakes": [
                                    "Baixar de fontes não oficiais (risco de malware)",
                                    "Ignorar requisitos de SO levando a falhas de instalação",
                                    "Não reiniciar o computador após instalação de drivers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar Drivers e Configurar Gerenciador de Placas",
                                  "subSteps": [
                                    "Identifique o microcontrolador alvo (ex: Arduino Uno, ESP32) e baixe drivers específicos do fabricante.",
                                    "No IDE, abra o Gerenciador de Placas (File > Preferences > Additional Boards Manager URLs) e adicione URLs oficiais.",
                                    "Instale o pacote da placa via Tools > Board > Boards Manager.",
                                    "Selecione a porta COM correta em Tools > Port após conectar o microcontrolador via USB.",
                                    "Teste a detecção da placa piscando o LED onboard com um sketch Blink simples."
                                  ],
                                  "verification": "Placa detectada na lista de portas e sketch Blink compila e faz upload com sucesso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Microcontrolador com cabo USB",
                                    "Drivers do chipset USB (CH340/FTDI)",
                                    "URL oficial do board manager"
                                  ],
                                  "tips": "Sempre desconecte e reconecte o cabo USB após instalar drivers para forçar redeteção.",
                                  "learningObjective": "Configurar comunicação serial entre PC e microcontrolador de forma confiável.",
                                  "commonMistakes": [
                                    "Selecionar porta errada",
                                    "Não instalar drivers corretos causando 'porta não encontrada'",
                                    "Conflitos com antivírus bloqueando uploads"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instalar e Configurar Bibliotecas Essenciais",
                                  "subSteps": [
                                    "Abra o Library Manager (Sketch > Include Library > Manage Libraries).",
                                    "Pesquise e instale bibliotecas chave para mecatrônica: Servo, Wire (I2C), SPI, Adafruit Sensor.",
                                    "Inclua as bibliotecas no sketch de teste com #include.",
                                    "Compile um sketch de exemplo usando múltiplas bibliotecas para verificar dependências.",
                                    "Atualize bibliotecas se houver avisos de versão desatualizada."
                                  ],
                                  "verification": "Sketch com bibliotecas compila sem erros de 'biblioteca não encontrada'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de bibliotecas recomendadas para o projeto",
                                    "IDE com internet para downloads"
                                  ],
                                  "tips": "Instale apenas bibliotecas oficiais ou bem avaliadas para evitar conflitos.",
                                  "learningObjective": "Gerenciar dependências de software para projetos integrados.",
                                  "commonMistakes": [
                                    "Instalar versões incompatíveis",
                                    "Não reiniciar IDE após instalação",
                                    "Conflitos de nomes entre bibliotecas similares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Pinagens e Periféricos para Teste Inicial",
                                  "subSteps": [
                                    "Consulte o datasheet do microcontrolador para mapear pinos (GPIO, PWM, I2C, SPI).",
                                    "Crie um diagrama de pinout no IDE ou papel para o projeto (ex: Pino 9 para servo, A0 para sensor).",
                                    "Configure periféricos no código: pinMode(), attachInterrupt(), etc.",
                                    "Conecte periféricos reais (servo, LED, sensor) e faça upload de um sketch de integração.",
                                    "Monitore serial output para debugar configurações de pinos."
                                  ],
                                  "verification": "Periféricos respondem corretamente ao sketch (ex: servo gira, sensor lê valores).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Microcontrolador",
                                    "Periféricos básicos (servo, LED, sensor analógico)",
                                    "Protoboard e jumpers",
                                    "Datasheet do microcontrolador"
                                  ],
                                  "tips": "Use resistores pull-up/down onde necessário para estabilidade de sinais.",
                                  "learningObjective": "Mapear e configurar hardware-software interface de forma precisa.",
                                  "commonMistakes": [
                                    "Curto-circuitos por pinos errados",
                                    "Ignorar limites de corrente dos pinos",
                                    "Não considerar modos de pino (INPUT vs OUTPUT)"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure o Arduino IDE para um braço robótico mecatrônico: instale board Arduino Uno, biblioteca Servo, configure pino 9 (PWM) para servo de garra, pino A0 para potenciômetro de posição, e teste rotação suave da garra via serial monitor.",
                              "finalVerifications": [
                                "IDE e todas bibliotecas abrem sem erros ou avisos.",
                                "Microcontrolador detectado e sketch Blink faz upload instantâneo.",
                                "Bibliotecas instaladas compilam em sketch integrado.",
                                "Pinout configurado ativa periféricos corretamente (servo move, sensor lê).",
                                "Serial monitor exibe dados reais sem garbage.",
                                "Ambiente pronto para projeto maior sem reconfigurações."
                              ],
                              "assessmentCriteria": [
                                "Instalação completa sem dependências pendentes (100% funcional).",
                                "Tempo de setup dentro do estimado com zero falhas graves.",
                                "Configuração de pinos matches datasheet (precisão 100%).",
                                "Teste de integração bem-sucedido em primeira tentativa.",
                                "Documentação de pinout clara e compartilhável.",
                                "Uso eficiente de recursos (sem bibliotecas desnecessárias)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Lógica de controle e depuração de código.",
                                "Eletrônica: Entendimento de pinouts, sinais analógicos/digitais e protocolos (I2C/SPI).",
                                "Mecânica: Integração com atuadores como servos em sistemas robóticos.",
                                "Informática: Gerenciamento de software, drivers e bibliotecas.",
                                "Matemática: Mapeamento de PWM e conversão analógico-digital."
                              ],
                              "realWorldApplication": "Em fábricas de automação industrial, configurar ambientes para microcontroladores PLC-like permite prototipagem rápida de linhas de montagem robóticas, reduzindo tempo de desenvolvimento de semanas para dias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Implementar loops de controle PID",
                            "description": "Programar controladores PID em microcontroladores para estabilização de sistemas mecatrônicos como braços robóticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios do Controle PID e Calcular Constantes",
                                  "subSteps": [
                                    "Estude a teoria do PID: Proporcional (Kp), Integral (Ki) e Derivativo (Kd).",
                                    "Analise o setpoint, erro (e = setpoint - processo), saída u(t) = Kp*e + Ki*∫e dt + Kd*de/dt.",
                                    "Use métodos como Ziegler-Nichols para estimar gains iniciais baseados na planta (ex: braço robótico).",
                                    "Simule o sistema em software como MATLAB/Simulink para validar gains.",
                                    "Documente valores iniciais de Kp, Ki, Kd e limites anti-windup."
                                  ],
                                  "verification": "Gains calculados e simulados com overshoot <20% e tempo de estabilização <5s.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Documentação PID (livros/PDFs)",
                                    "MATLAB/Simulink ou Python (control library)",
                                    "Especificações do sistema mecatrônico"
                                  ],
                                  "tips": [
                                    "Comece com Ki=Kd=0 e ajuste Kp primeiro.",
                                    "Use unidades consistentes (ex: rad/s para ângulos)."
                                  ],
                                  "learningObjective": "Dominar equações PID e métodos de tuning para sistemas mecatrônicos.",
                                  "commonMistakes": [
                                    "Ignorar saturação do atuador.",
                                    "Escolha errada de unidades causando instabilidade.",
                                    "Não simular antes de hardware."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Hardware e Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Selecione microcontrolador (ex: Arduino/ESP32/STM32) compatível com sensores/atuadores.",
                                    "Conecte sensores (encoder/IMU para posição/velocidade) e atuadores (servo/motor DC).",
                                    "Instale IDE (Arduino IDE/PlatformIO) e bibliotecas (PID_v1, Wire para I2C).",
                                    "Calibre sensores e teste comunicação serial para leitura de dados.",
                                    "Configure loop de amostragem (ex: 100Hz) com timer interrupt."
                                  ],
                                  "verification": "Leituras de sensores precisas (±1%) e atuadores respondem via comandos simples.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Microcontrolador",
                                    "Sensores (encoder/IMU)",
                                    "Atuadores (servo/motor)",
                                    "Protoboard, fios jumper",
                                    "Multímetro/Osciloscópio"
                                  ],
                                  "tips": [
                                    "Use pull-ups em I2C se ruído.",
                                    "Monitore via Serial Plotter para debug."
                                  ],
                                  "learningObjective": "Preparar plataforma hardware-software para loop PID em tempo real.",
                                  "commonMistakes": [
                                    "Frequência de amostragem baixa causando aliasing.",
                                    "Conexões soltas levando a leituras erráticas.",
                                    "Bibliotecas incompatíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Algoritmo PID no Código",
                                  "subSteps": [
                                    "Inclua biblioteca PID e defina variáveis: setpoint, input, output, Kp/Ki/Kd.",
                                    "Escreva função de leitura de sensor no loop principal.",
                                    "Calcule erro, atualize PID.compute() e aplique output ao atuador.",
                                    "Adicione anti-windup (clamp integral) e filtro derivativo.",
                                    "Implemente serial output para monitorar erro, output e setpoint."
                                  ],
                                  "verification": "Código compila sem erros e PID.compute() retorna valores esperados em simulação serial.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "IDE de programação",
                                    "Exemplo código PID_v1 library"
                                  ],
                                  "tips": [
                                    "Use double/float para precisão.",
                                    "Teste com setpoint fixo primeiro."
                                  ],
                                  "learningObjective": "Codificar loop PID discreto otimizado para microcontroladores.",
                                  "commonMistakes": [
                                    "Divisão por zero em derivativo.",
                                    "Overflow em integral sem clamp.",
                                    "Não zerar integral em setpoint change."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Tunar e Integrar em Sistema Mecatrônico",
                                  "subSteps": [
                                    "Carregue código no hardware e teste step response (setpoint jump).",
                                    "Ajuste gains iterativamente: reduza overshoot com Kd, elimine steady-state com Ki.",
                                    "Integre em braço robótico: controle posição angular de junta.",
                                    "Registre dados (erro vs tempo) e compare com simulação.",
                                    "Otimize para bateria (sleep modes) e adicione safety stops."
                                  ],
                                  "verification": "Braço estabiliza em setpoint com erro <2% em <3s, sem oscilações sustentadas.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Braço robótico ou mockup",
                                    "PC para logging dados",
                                    "Ferramentas de tuning (Ziegler-Nichols tabela)"
                                  ],
                                  "tips": [
                                    "Mude um gain por vez.",
                                    "Grave vídeos para análise qualitativa."
                                  ],
                                  "learningObjective": "Aplicar e refinar PID em hardware real para estabilização mecatrônica.",
                                  "commonMistakes": [
                                    "Tuning agressivo causando vibração.",
                                    "Ignorar atrasos de sensor.",
                                    "Não testar limites extremos."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar Desempenho e Documentar",
                                  "subSteps": [
                                    "Execute testes repetidos com distúrbios (carga extra no braço).",
                                    "Calcule métricas: rise time, settling time, overshoot.",
                                    "Compare com benchmarks industriais (ex: <1% erro em robótica).",
                                    "Escreva relatório com código, gains finais e gráficos.",
                                    "Planeje melhorias (PID cascado, fuzzy logic)."
                                  ],
                                  "verification": "Relatório completo com métricas atendendo critérios (ex: settling <2s).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Excel/Python para plots",
                                    "Template de relatório"
                                  ],
                                  "tips": [
                                    "Automatize logging com SD card.",
                                    "Versione código no Git."
                                  ],
                                  "learningObjective": "Avaliar e documentar implementação PID para projetos profissionais.",
                                  "commonMistakes": [
                                    "Métricas subjetivas sem dados.",
                                    "Omitir condições de teste."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente PID para estabilizar a junta de um braço robótico DIY (servo + encoder): setpoint=90°, responda a distúrbios como empurrões manuais, alcançando estabilização em 1.5s com erro <1°.",
                              "finalVerifications": [
                                "Sistema estabiliza em setpoint com erro steady-state <1%.",
                                "Tempo de settling <3s para step de 30°.",
                                "Overshoot <10% sem oscilações sustentadas.",
                                "Resiste a distúrbios (ex: +20% carga) recuperando em <2s.",
                                "Loop roda a 100Hz sem perda de ticks.",
                                "Anti-windup previne saturação prolongada."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro steady-state <2%.",
                                "Robustez: Recuperação de distúrbios <2s.",
                                "Eficiência: Uso CPU <50%, sem overflows.",
                                "Código: Modular, comentado, com safety checks.",
                                "Documentação: Gains, tuning log, métricas plotadas.",
                                "Integração: Funciona em sistema mecatrônico completo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais e métodos numéricos (Euler para integração).",
                                "Física: Dinâmica de sistemas (massa, inércia, atrito).",
                                "Eletrônica: Interfaces analógico-digitais, filtros.",
                                "Programação: Estruturas de loop em tempo real, interrupts.",
                                "Engenharia de Controle: Teoria clássica vs. avançada (MPC)."
                              ],
                              "realWorldApplication": "Controle de drones para estabilização de altitude/atitude, robôs industriais para precisão em soldagem/pick-and-place, e veículos autônomos para direção assistida."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Interface com comunicação I2C/SPI",
                            "description": "Estabelecer comunicação entre microcontroladores e módulos sensoriais para automação distribuída em mecatrônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Protocolos I2C e SPI",
                                  "subSteps": [
                                    "Estude as diferenças entre I2C (bidirecional, multi-master, 2 fios: SDA, SCL) e SPI (full-duplex, master-slave, 4 fios: MOSI, MISO, SCK, SS).",
                                    "Aprenda sobre endereços I2C (7-bit/10-bit), clock stretching e pull-ups necessários.",
                                    "Revise timing diagrams para ambos os protocolos usando datasheets.",
                                    "Identifique aplicações típicas: I2C para sensores, SPI para displays/SD cards.",
                                    "Compare velocidades: I2C até 400kHz padrão, SPI até 50MHz."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças chave e liste 3 prós/contras de cada protocolo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Datasheets de I2C/SPI (NXP/Arduino), osciloscópio virtual (ex: Falstad simulator), vídeo tutoriais SparkFun/Arduino.cc"
                                  ],
                                  "tips": "Use simuladores online para visualizar sinais antes de hardware real.",
                                  "learningObjective": "Diferenciar I2C e SPI, entendendo suas topologias e limitações elétricas.",
                                  "commonMistakes": [
                                    "Confundir pinagens (SDA/SCL vs MOSI/MISO), ignorar pull-ups em I2C, assumir SPI é mais simples sem considerar clock sync."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Conexões de Hardware",
                                  "subSteps": [
                                    "Selecione microcontrolador (ex: Arduino Uno) e periférico (ex: MPU6050 para I2C, ou ADC MCP3008 para SPI).",
                                    "Conecte pinos corretos: Para I2C - A4(SDA)/A5(SCL) no Uno; para SPI - 11(MOSI)/12(MISO)/13(SCK)/10(SS).",
                                    "Adicione resistores pull-up 4.7kΩ em SDA/SCL para I2C.",
                                    "Alimente módulos com 3.3V/5V compatível e verifique com multímetro continuidade/voltagem.",
                                    "Monte em protoboard com breadboard para prototipagem segura."
                                  ],
                                  "verification": "Meça tensões nos pinos com multímetro e confirme ausência de curtos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Arduino Uno, MPU6050 ou similar, protoboard, fios jumper, multímetro, resistores 4.7kΩ"
                                  ],
                                  "tips": "Sempre desligue alimentação antes de reconectar fios para evitar danos.",
                                  "learningObjective": "Realizar conexões elétricas seguras e corretas para ambos protocolos.",
                                  "commonMistakes": [
                                    "Polaridade errada em VCC/GND, esquecer pull-ups causando falhas I2C, usar pinos errados em boards específicas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Software Básico no Microcontrolador",
                                  "subSteps": [
                                    "Instale bibliotecas: Wire.h para I2C, SPI.h para SPI no Arduino IDE.",
                                    "Escreva scanner I2C para detectar dispositivos ou init SPI com pinMode.",
                                    "Programe master para enviar comando simples (ex: ler registro 0x75 no MPU6050).",
                                    "Compile e upload código, monitore Serial para ACK/ dados recebidos.",
                                    "Adapte para SPI: SPI.beginTransaction com modo/clock speed."
                                  ],
                                  "verification": "Serial Monitor mostra endereço/dispositivo detectado e dados lidos corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Arduino IDE, cabo USB, computador"
                                  ],
                                  "tips": "Use Serial.print para debug em cada função para isolar falhas.",
                                  "learningObjective": "Configurar e inicializar comunicação via bibliotecas padrão.",
                                  "commonMistakes": [
                                    "Biblioteca não instalada, baud rate Serial incompatível, não chamar begin() antes de transferências."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Ler Dados de Módulos Sensoriais",
                                  "subSteps": [
                                    "Configure sensor específico: ex: init MPU6050 via I2C write para power management.",
                                    "Leia múltiplos registros (ex: accel X/Y/Z) em loop com delay para estabilidade.",
                                    "Para SPI, leia ADC continuamente e converta para volts.",
                                    "Implemente parsing de dados (union ou shift bits para multi-byte).",
                                    "Adicione filtro simples (média móvel) para dados ruidosos."
                                  ],
                                  "verification": "Dados sensoriais variam realisticamente com movimento/inclinação no Serial Plotter.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código anterior, MPU6050 ou ADC SPI"
                                  ],
                                  "tips": "Comece com reads single-byte antes de burst para validar.",
                                  "learningObjective": "Extrair e processar dados úteis de sensores via I2C/SPI.",
                                  "commonMistakes": [
                                    "Endianness errada em multi-byte reads, não respeitar timing entre comandos, overflow em variáveis int."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Depurar e Aplicar em Automação Distribuída",
                                  "subSteps": [
                                    "Teste com múltiplos dispositivos: 2 sensores I2C com endereços diferentes.",
                                    "Simule rede distribuída: master controlando 2 slaves SPI.",
                                    "Depure com osciloscópio lógico ou Serial para NACK/timeouts.",
                                    "Integre em loop de controle: leia sensor, atue (ex: LED baseado em threshold).",
                                    "Documente código com comentários e esquemático Fritzing."
                                  ],
                                  "verification": "Sistema responde a estímulos sensoriais em tempo real sem crashes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Osciloscópio lógico (Saleae ou sigrok), múltiplos sensores, LEDs/resistores"
                                  ],
                                  "tips": "Use #define para endereços/pinos para fácil mudança de protocolo.",
                                  "learningObjective": "Criar sistemas distribuídos robustos com depuração eficaz.",
                                  "commonMistakes": [
                                    "Colisões de endereço I2C, clock mismatch SPI, loops bloqueantes causando timeouts."
                                  ]
                                }
                              ],
                              "practicalExample": "Conecte um Arduino Uno como master a um MPU6050 (I2C) e um cartao SD (SPI). Leia aceleração do MPU, logue dados no SD a cada 100ms, simulando monitoramento distribuído em um braço robótico.",
                              "finalVerifications": [
                                "Scanner I2C detecta todos dispositivos conectados.",
                                "Dados SPI/I2C lidos consistentemente sem erros de CRC/NACK.",
                                "Sistema opera por 10min sem falhas ou aquecimento excessivo.",
                                "Mudança de protocolo (I2C para SPI) requer <30min adaptação.",
                                "Gráficos de dados mostram resposta real-time a inputs físicos.",
                                "Código comentado permite reprodução por outro aluno."
                              ],
                              "assessmentCriteria": [
                                "Precisão das conexões hardware (sem curtos/erros lógicos).",
                                "Código funcional, eficiente e modular (reutilizável).",
                                "Compreensão demonstrada em explicação oral das diferenças I2C/SPI.",
                                "Depuração autônoma de 2+ falhas comuns.",
                                "Integração em cenário mecatrônico simples (controle baseado em sensor).",
                                "Documentação completa com diagramas e lições aprendidas."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Sinais e timing de protocolos seriais.",
                                "Programação Embarcada: Bibliotecas e interrupções.",
                                "Automação Industrial: CLPs com comunicação fieldbus similar.",
                                "Física: Sensores inerciais e calibração.",
                                "Projetos Integrados: IoT e redes sensoriais distribuídas."
                              ],
                              "realWorldApplication": "Em linhas de produção mecatrônicas, microcontroladores masters coordenam sensores distribuídos via I2C/SPI para monitoramento de vibração em motores, permitindo manutenção preditiva e automação sem fios em setups compactos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.4",
                            "name": "Testar protótipos mecatrônicos",
                            "description": "Realizar testes de integração e depuração de microcontroladores em hardware mecatrônico real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de teste e o protótipo",
                                  "subSteps": [
                                    "Inspecionar fisicamente o hardware mecatrônico para danos ou conexões soltas.",
                                    "Conectar o microcontrolador ao hardware (motores, sensores, atuadores) conforme diagrama esquemático.",
                                    "Configurar o software de depuração (IDE como Arduino IDE ou PlatformIO) e carregar o firmware inicial.",
                                    "Verificar alimentação elétrica e sinais de tensão com multímetro.",
                                    "Calibrar sensores e atuadores manualmente para baseline."
                                  ],
                                  "verification": "Checklist completo assinalado e multímetro confirma tensões corretas em todos os pontos chave.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Multímetro, osciloscópio básico, cabos jumper, diagrama esquemático, computador com IDE instalada.",
                                  "tips": "Sempre desligue a alimentação antes de reconectar componentes para evitar curtos.",
                                  "learningObjective": "Entender a importância da preparação segura para testes de integração.",
                                  "commonMistakes": "Ignorar inspeção visual levando a falhas prematuras; conectar pinos incorretos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar testes unitários e de integração básica",
                                  "subSteps": [
                                    "Testar cada módulo individualmente (ex: sensor lendo valores, motor girando).",
                                    "Executar script de teste sequencial para verificar comunicação I2C/SPI entre microcontrolador e periféricos.",
                                    "Monitorar saídas seriais para logs de status e erros iniciais.",
                                    "Registrar métricas como tempo de resposta e precisão de leitura.",
                                    "Repetir testes 3-5 vezes para consistência."
                                  ],
                                  "verification": "Todos os módulos respondem corretamente nos logs seriais sem timeouts ou erros de CRC.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Monitor serial (USB), software de logging, protótipo montado.",
                                  "tips": "Use delays mínimos nos códigos para capturar picos de sinal no osciloscópio.",
                                  "learningObjective": "Identificar integrações bem-sucedidas e falhas iniciais em sistemas mecatrônicos.",
                                  "commonMistakes": "Pular testes unitários, assumindo integração direta; ignorar ruído em sinais analógicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar depuração de falhas e iterações",
                                  "subSteps": [
                                    "Analisar logs e osciloscópio para identificar falhas (ex: jitter em PWM, drift em sensores).",
                                    "Inserir breakpoints no código e usar debugger para inspecionar variáveis em tempo real.",
                                    "Ajustar firmware (ex: filtros de software para ruído, timeouts em loops).",
                                    "Testar hardware com substituição de componentes suspeitos.",
                                    "Documentar causa-raiz e correção em relatório."
                                  ],
                                  "verification": "Falhas resolvidas: logs limpos e testes unitários passam 100%.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": "Osciloscópio, debugger JTAG/SWD (se disponível), componentes de reposição, bloco de notas.",
                                  "tips": "Comece depuração do mais simples (software) para o complexo (hardware).",
                                  "learningObjective": "Desenvolver habilidades sistemáticas de troubleshooting em mecatrônica.",
                                  "commonMistakes": "Mudar múltiplas variáveis de uma vez, perdendo rastreabilidade; subestimar interferência EMI."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar testes avançados e performance final",
                                  "subSteps": [
                                    "Executar cenários de estresse (ex: sobrecarga, variações térmicas).",
                                    "Medir performance global (eficiência energética, precisão de controle).",
                                    "Simular condições reais de operação por 30+ minutos.",
                                    "Coletar dados com datalogger para análise posterior.",
                                    "Gerar relatório final com gráficos de performance."
                                  ],
                                  "verification": "Protótipo opera estável por tempo definido sem falhas ou degradação.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Fonte de alimentação variável, datalogger, termômetro infravermelho.",
                                  "tips": "Automatize testes com scripts para repetibilidade.",
                                  "learningObjective": "Garantir robustez do protótipo para deployment real.",
                                  "commonMistakes": "Testar apenas em condições ideais; ignorar consumo de energia em bateria."
                                }
                              ],
                              "practicalExample": "Em um braço robótico com Arduino controlando servos e sensores ultrassônicos: preparar conexões, testar leitura de distância e movimento sequencial, depurar delay no servo via serial monitor, validar ciclo completo de pick-and-place sem colisões.",
                              "finalVerifications": [
                                "Todos os testes passam sem erros em 5 execuções consecutivas.",
                                "Logs seriais mostram estabilidade de sinais e ausência de warnings.",
                                "Medições físicas (ex: ângulo de motor) coincidem com esperados (±5%).",
                                "Consumo de energia dentro de limites especificados.",
                                "Protótipo resiste a vibrações simuladas por 10 minutos.",
                                "Relatório documenta todas as iterações e métricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e resolução de falhas (90%+ taxa de sucesso).",
                                "Eficiência temporal: completar em <4 horas.",
                                "Qualidade da documentação e logs (clareza e completude).",
                                "Segurança observada em todas as etapas (zero incidentes).",
                                "Uso otimizado de recursos (mínimo desperdício de componentes).",
                                "Criatividade em soluções de depuração."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Debugging de código embarcado (lógica e algoritmos).",
                                "Eletrônica: Análise de sinais com osciloscópio e multímetro.",
                                "Mecânica: Compreensão de atuadores e transmissão de movimento.",
                                "Matemática: Modelagem de controle PID e análise estatística de dados.",
                                "Gestão de Projetos: Documentação de testes e relatórios."
                              ],
                              "realWorldApplication": "Na indústria automotiva, testar protótipos de sistemas de freios ABS com microcontroladores para depurar latência em sensores de rotação, garantindo segurança veicular; ou em robótica industrial para validar braços pick-and-place em linhas de montagem."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Aplicação de CLPs em Automação Mecatrônica",
                        "description": "Emprego de CLPs para automação industrial robusta, incluindo ladder logic e integração com sistemas mecatrônicos complexos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Programar em ladder logic",
                            "description": "Desenvolver programas ladder para CLPs controlando sequências de atuadores em linhas de produção mecatrônicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Ladder Logic",
                                  "subSteps": [
                                    "Estudar os símbolos básicos: contatos normalmente aberto (NO), normalmente fechado (NC), bobinas e timers.",
                                    "Aprender o conceito de scan cycle (varredura cíclica) do CLP.",
                                    "Identificar elementos auxiliares como relés internos, contadores e funções especiais.",
                                    "Praticar leitura de diagramas ladder simples.",
                                    "Explicar a lógica booleana aplicada (AND, OR, NOT)."
                                  ],
                                  "verification": "Montar manualmente um diagrama ladder simples e explicar seu funcionamento verbalmente ou em diagrama.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação como LogixPro ou Factory I/O",
                                    "Tutoriais em PDF sobre ladder logic",
                                    "Vídeos introdutórios no YouTube"
                                  ],
                                  "tips": "Use papel e lápis para desenhar diagramas antes de digitar no software.",
                                  "learningObjective": "Dominar a sintaxe e elementos básicos da ladder logic para leitura e interpretação.",
                                  "commonMistakes": [
                                    "Confundir contatos NO e NC",
                                    "Ignorar a direção de leitura da esquerda para direita",
                                    "Esquecer o conceito de scan time"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Problema e Projetar a Sequência",
                                  "subSteps": [
                                    "Definir entradas (sensores, botões) e saídas (atuadores, motores) da linha de produção.",
                                    "Criar um fluxograma ou tabela de sequência temporal dos atuadores.",
                                    "Mapear condições de ativação e desativação para cada atuador.",
                                    "Identificar estados de emergência e reset.",
                                    "Desenhar o diagrama ladder preliminar no papel."
                                  ],
                                  "verification": "Apresentar fluxograma e diagrama preliminar que cubram todos os cenários da sequência.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Papel milimetrado ou software de diagramação como Draw.io",
                                    "Especificação do problema da linha mecatrônica"
                                  ],
                                  "tips": "Priorize sequências lineares antes de adicionar loops ou condições paralelas.",
                                  "learningObjective": "Capacitar o design lógico de sequências de controle para automação industrial.",
                                  "commonMistakes": [
                                    "Omitir condições de segurança",
                                    "Não considerar tempos de transição",
                                    "Fluxogramas ambíguos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Programa no Software de CLP",
                                  "subSteps": [
                                    "Configurar o ambiente de simulação com I/O correspondentes.",
                                    "Converter o diagrama preliminar em código ladder no editor.",
                                    "Inserir timers, contadores e funções auxiliares necessários.",
                                    "Adicionar lógica de intertravamento (interlocks) para segurança.",
                                    "Compilar o programa e corrigir erros de sintaxe iniciais."
                                  ],
                                  "verification": "Programa compila sem erros e roda em modo simulação básica.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software CLP como RSLogix ou TIA Portal Simulator",
                                    "PLC virtual ou hardware de treinamento"
                                  ],
                                  "tips": "Teste cada rung (linha) isoladamente antes de integrar.",
                                  "learningObjective": "Desenvolver habilidade em codificação prática de ladder logic.",
                                  "commonMistakes": [
                                    "Erros de endereço de I/O",
                                    "Bobinas duplicadas",
                                    "Timers mal configurados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Otimizar o Programa",
                                  "subSteps": [
                                    "Executar simulação completa da sequência com entradas manuais.",
                                    "Monitorar variáveis em tempo real e registrar falhas.",
                                    "Depurar usando breakpoints e force de valores.",
                                    "Otimizar código removendo redundâncias e melhorando eficiência.",
                                    "Documentar o programa com comentários em cada rung."
                                  ],
                                  "verification": "Sequência completa executa corretamente em 3 rodadas consecutivas sem intervenção.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software de simulação com modo debug",
                                    "Checklist de testes"
                                  ],
                                  "tips": "Registre logs de cada teste para rastrear problemas recorrentes.",
                                  "learningObjective": "Garantir robustez e confiabilidade do programa ladder.",
                                  "commonMistakes": [
                                    "Testes insuficientes em cenários de falha",
                                    "Ignorar latência de sensores",
                                    "Código não comentado"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de produção mecatrônica, programar para: 1) Sensor detecta peça na esteira (liga motor); 2) Peça chega ao final (braço robótico desce e pega); 3) Braço move para próxima estação; 4) Solta peça e reseta para próxima.",
                              "finalVerifications": [
                                "Programa executa a sequência completa sem travamentos.",
                                "Resposta correta a entradas de emergência (parada).",
                                "Tempos de ativação dos atuadores respeitam especificações.",
                                "Reset manual e automático funcionam perfeitamente.",
                                "Não há conflitos lógicos entre atuadores simultâneos.",
                                "Simulação em ciclo contínuo por 10 minutos sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão lógica do diagrama (sem erros de sequência).",
                                "Eficiência do código (mínimo de rungs e auxiliares).",
                                "Inclusão de segurança e intertravamentos.",
                                "Qualidade da documentação e comentários.",
                                "Desempenho em testes (sucesso >95%).",
                                "Criatividade em otimizações opcionais."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Interpretação de diagramas de relés eletromecânicos.",
                                "Mecânica: Conhecimento de atuadores e sensores industriais.",
                                "Informática: Lógica de programação estruturada.",
                                "Matemática: Aplicação de lógica booleana e temporizadores.",
                                "Segurança do Trabalho: Normas NR-12 para automação."
                              ],
                              "realWorldApplication": "Em fábricas de automação industrial, como linhas de montagem automotiva ou embalagem, onde ladder logic controla sequências precisas de robôs e esteiras, reduzindo downtime e erros humanos em até 80%."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Configurar redes industriais",
                            "description": "Implementar protocolos como Modbus ou Profibus para conectar CLPs a microcontroladores em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Protocolos Industriais como Modbus e Profibus",
                                  "subSteps": [
                                    "Estude a documentação oficial de Modbus RTU/TCP e Profibus DP, focando em camadas OSI, modos master/slave e estruturas de frames.",
                                    "Identifique requisitos de hardware: interfaces RS485 para Modbus, RS485/ProfiBus para Profibus.",
                                    "Compare protocolos: velocidade, topologia (daisy-chain para Profibus), e compatibilidade com CLPs (ex: Siemens S7 para Profibus).",
                                    "Revise exemplos de aplicação em mecatrônica: leitura de sensores via CLP para microcontrolador.",
                                    "Anote parâmetros chave: baud rate (9600-115200), paridade, endereço slave (1-247 para Modbus)."
                                  ],
                                  "verification": "Criar um resumo de 1 página com tabela comparativa dos protocolos e parâmetros, revisado por um tutor.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação Modbus (modbus.org), manual Profibus (profibus.com)",
                                    "CLP e microcontrolador manuais",
                                    "Notebook com internet"
                                  ],
                                  "tips": "Use diagramas de rede para visualizar topologias; priorize Modbus RTU para simplicidade inicial.",
                                  "learningObjective": "Dominar fundamentos teóricos para seleção adequada de protocolo em cenários mecatrônicos.",
                                  "commonMistakes": [
                                    "Confundir Modbus TCP com RTU",
                                    "Ignorar limitações de distância (1200m max RS485)",
                                    "Subestimar necessidade de terminadores de linha"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Preparar Hardware para Conexão",
                                  "subSteps": [
                                    "Escolha CLP compatível (ex: Siemens LOGO! ou Allen-Bradley MicroLogix para Modbus) e microcontrolador (Arduino com RS485 shield ou ESP32).",
                                    "Adquira cabos: RS485 twisted pair para Modbus/Profibus, com resistores de terminação 120Ω.",
                                    "Monte protoboard ou painel com alimentações isoladas (24V DC para CLP, 5V para microcontrolador).",
                                    "Teste integridade física: multímetro para continuidade e isolação.",
                                    "Instale shields/drivers: MAX485 para Arduino."
                                  ],
                                  "verification": "Foto ou diagrama do setup hardware com etiquetas, confirmando conexões A/B/GND corretas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "CLP (ex: Siemens S7-1200)",
                                    "Microcontrolador (ESP32/Arduino)",
                                    "Módulo RS485",
                                    "Cabos twisted pair",
                                    "Multímetro",
                                    "Fonte 24V/5V"
                                  ],
                                  "tips": "Sempre use alimentação isolada para evitar loops de terra; teste cabos antes da conexão.",
                                  "learningObjective": "Preparar infraestrutura física robusta para redes industriais confiáveis.",
                                  "commonMistakes": [
                                    "Inversão de fios A/B",
                                    "Esquecimento de terminadores",
                                    "Misturar níveis lógicos sem conversor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Software no CLP",
                                  "subSteps": [
                                    "Instale software do fabricante (TIA Portal para Siemens, RSLogix para AB).",
                                    "Crie novo projeto: configure porta serial/Ethernet como Modbus slave/master, defina baud rate 19200, paridade none, endereço 1.",
                                    "Mapeie registrandos: coils 00001-00100 para saídas, holding registers 40001-40100 para variáveis analógicas.",
                                    "Compile e baixe para CLP; monitore status de comunicação no software.",
                                    "Teste loopback: configure CLP como master/slave consigo mesmo."
                                  ],
                                  "verification": "Log do software mostrando configuração baixada sem erros e status 'Ready'.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software TIA Portal/RSLogix (licença trial)",
                                    "Cabo de programação USB/Ethernet para CLP"
                                  ],
                                  "tips": "Salve backups de configuração; use simulador do software para testes iniciais.",
                                  "learningObjective": "Habilitar CLP como nó de rede com parâmetros otimizados para mecatrônica.",
                                  "commonMistakes": [
                                    "Baud rate mismatch",
                                    "Endereços inválidos (>247 Modbus)",
                                    "Falha em mapear registrandos corretos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Software no Microcontrolador",
                                  "subSteps": [
                                    "Instale IDE (Arduino IDE ou PlatformIO); adicione bibliotecas ModbusMaster/ModbusRTU.",
                                    "Escreva sketch: configure como master, inicialize Serial2 para RS485, defina ID slave do CLP.",
                                    "Implemente funções: readHoldingRegisters(1, 40001, 10) para ler dados; writeCoil(1, 00001, true).",
                                    "Adicione timeout e retry logic para robustez.",
                                    "Carregue e monitore Serial Monitor para debug."
                                  ],
                                  "verification": "Código compilado e rodando, com output no Serial Monitor confirmando init bem-sucedida.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Arduino IDE",
                                    "Biblioteca ModbusMaster (GitHub)",
                                    "Cabo USB para microcontrolador"
                                  ],
                                  "tips": "Use pinos dedicados para DE/RE no RS485; debug com delays iniciais.",
                                  "learningObjective": "Programar microcontrolador para comunicação bidirecional com CLP.",
                                  "commonMistakes": [
                                    "Não controlar pin DE/RE",
                                    "Ignorar checksum CRC",
                                    "Loop infinito sem timeout"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Estabelecer Conexão, Testar e Depurar Rede",
                                  "subSteps": [
                                    "Conecte fisicamente: A-A, B-B, GND; ligue alimentações.",
                                    "Execute comunicação: envie comando do microcontrolador para ler/escrever no CLP.",
                                    "Monitore tráfego: use osciloscópio ou sniffer Modbus para pacotes.",
                                    "Depure erros: verifique erros de CRC, timeout, NAK; ajuste baud/paridade.",
                                    "Otimize: teste com carga (múltiplos slaves) e distâncias reais."
                                  ],
                                  "verification": "Relatório de teste com 100 trocas de dados sem erros, capturas de tela de logs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Osciloscópio ou Modbus Poll software",
                                    "Sniffer USB-RS485"
                                  ],
                                  "tips": "Comece com distâncias curtas; isole ruídos com ferritas nos cabos.",
                                  "learningObjective": "Validar rede funcional e resiliente em ambiente mecatrônico.",
                                  "commonMistakes": [
                                    "Ruído EMI não mitigado",
                                    "Sobrecarga de polling",
                                    "Ignorar timeouts em falhas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um protótipo de braço robótico mecatrônico, configure rede Modbus RTU entre CLP Siemens LOGO! (slave, controlando motores) e ESP32 (master, lendo encoders e enviando comandos via app móvel), garantindo sincronia em tempo real.",
                              "finalVerifications": [
                                "Comunicação bidirecional sem erros de CRC ou timeout após 30min de teste contínuo.",
                                "Leitura/escrita correta de 50 registrandos/coils entre dispositivos.",
                                "Rede mantém integridade com cabo de 50m e ruído simulado.",
                                "CLP e microcontrolador respondem em <100ms a polling.",
                                "Backup de configurações exportado e documentado.",
                                "Teste de falha: desconexão/recconexão automática detectada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de parâmetros (baud, endereço, paridade): 100% match com specs.",
                                "Código e setup livre de erros comuns (RS485 wiring, CRC).",
                                "Eficiência: taxa de sucesso >95% em testes automatizados.",
                                "Documentação completa: diagramas, logs, resumos.",
                                "Robustez: opera sob variações de tensão/alimentação.",
                                "Integração mecatrônica: aplica a sensores/atuadores reais."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Industrial: Sinais diferenciais RS485 e isolamento galvânico.",
                                "Programação Embarcada: Bibliotecas de comunicação serial e protocolos.",
                                "Automação e Controle: Integração PID via rede em loops fechados.",
                                "Redes e IoT: Escalabilidade para Ethernet/IP ou OPC UA.",
                                "Segurança Industrial: Criptografia básica e firewalls em redes de campo."
                              ],
                              "realWorldApplication": "Em fábricas de automação mecatrônica, como linhas de montagem automotiva, onde CLPs Siemens controlam estairas via Profibus, integrados a microcontroladores edge para visão computacional e IIoT, reduzindo downtime em 30% via monitoramento remoto."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Integrar com visão computacional",
                            "description": "Conectar CLPs a câmeras para processamento de imagens em inspeção mecatrônica, usando triggers e I/O.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do Hardware de Visão Computacional",
                                  "subSteps": [
                                    "Selecionar e conectar a câmera industrial ao CLP via interface Ethernet/IP ou serial RS-232/485.",
                                    "Configurar alimentação elétrica e fixação mecânica da câmera na posição de inspeção.",
                                    "Testar conectividade básica entre câmera e CLP usando ping ou comandos de diagnóstico.",
                                    "Instalar lentes adequadas e ajustar iluminação para otimizar captura de imagens.",
                                    "Verificar cabos e conexões para evitar interferências eletromagnéticas."
                                  ],
                                  "verification": "Executar teste de conectividade: câmera responde a comandos do CLP sem perda de pacotes.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Câmera industrial (ex: Cognex ou Basler), CLP com módulo Ethernet, cabos Ethernet/CAT6, fonte de alimentação, suportes mecânicos.",
                                  "tips": "Use câmeras com protocolo padrão como GigE Vision para compatibilidade com CLPs Siemens ou Allen-Bradley.",
                                  "learningObjective": "Entender e implementar conexões físicas seguras entre dispositivos de visão e CLPs.",
                                  "commonMistakes": "Ignorar grounding elétrico levando a ruído nas imagens; usar cabos inadequados para distâncias longas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração do Software de Processamento de Imagens",
                                  "subSteps": [
                                    "Instalar biblioteca de visão computacional como OpenCV ou software proprietário (ex: Halcon).",
                                    "Desenvolver script básico para captura de imagens em tempo real da câmera.",
                                    "Implementar algoritmos simples de processamento: detecção de bordas, thresholds ou matching de templates.",
                                    "Definir regiões de interesse (ROI) para inspeção específica em mecatrônica.",
                                    "Salvar resultados de processamento em formato legível para o CLP (ex: JSON ou variáveis Modbus)."
                                  ],
                                  "verification": "Executar script e confirmar que imagens são processadas e resultados exportados corretamente.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "PC com Python/OpenCV instalado, licenças de software de visão se necessário, acesso à documentação da câmera.",
                                  "tips": "Comece com resoluções baixas para testes rápidos e otimize depois para performance em tempo real.",
                                  "learningObjective": "Dominar ferramentas de visão computacional para extrair dados acionáveis de imagens.",
                                  "commonMistakes": "Não calibrar iluminação causando falsos positivos/negativos; ignorar latência no processamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Programação do CLP para Triggers e I/O",
                                  "subSteps": [
                                    "Configurar variáveis de entrada no CLP para receber resultados da visão (ex: bit 'defeito_detectado').",
                                    "Programar ladder logic ou ST para triggers: ativar saída I/O baseada em sinal da câmera.",
                                    "Implementar comunicação via Modbus TCP ou OPC UA entre software de visão e CLP.",
                                    "Adicionar timers e counters para sincronização de inspeções cíclicas.",
                                    "Testar isoladamente os I/Os do CLP com simulações de sinais da visão."
                                  ],
                                  "verification": "Simular sinal da visão e observar ativação correta de saídas no CLP.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "Software de programação do CLP (ex: TIA Portal para Siemens), simulador de I/O.",
                                  "tips": "Use blocos funcionais prontos para comunicação Ethernet para agilizar o desenvolvimento.",
                                  "learningObjective": "Integrar lógica de controle do CLP com dados externos de visão computacional.",
                                  "commonMistakes": "Configurar polling muito frequente causando sobrecarga na rede; não tratar falhas de comunicação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração, Testes e Depuração do Sistema Completo",
                                  "subSteps": [
                                    "Executar loop completo: captura > processamento > trigger > ação no CLP.",
                                    "Realizar testes com cenários reais de inspeção (OK/defeituoso).",
                                    "Monitorar performance com ferramentas de log e osciloscópio para latência.",
                                    "Otimizar parâmetros de visão e lógica para taxa de inspeção > 1 imagem/segundo.",
                                    "Documentar configurações e criar rotina de manutenção."
                                  ],
                                  "verification": "Sistema integrado processa 100 imagens consecutivas com taxa de acerto >95%.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Objetos de teste para inspeção (ex: peças mecatrônicas), multímetro, software de monitoramento de rede.",
                                  "tips": "Grave vídeos de falhas para análise offline e ajuste thresholds dinamicamente.",
                                  "learningObjective": "Validar e otimizar sistemas integrados de visão e automação mecatrônica.",
                                  "commonMistakes": "Testar apenas em condições ideais ignorando variações reais; não backup configurações."
                                }
                              ],
                              "practicalExample": "Em uma célula de inspeção de soldas em chassis automotivo, a câmera captura imagem da solda; OpenCV detecta porosidade; se defeito, envia trigger via Modbus para CLP ativar atuador rejeitador e registrar falha.",
                              "finalVerifications": [
                                "Câmera captura imagens em tempo real sem perda de frames.",
                                "Processamento de imagem gera resultados precisos em <200ms.",
                                "CLP recebe triggers corretamente e executa ações I/O associadas.",
                                "Sistema mantém estabilidade por 30 minutos contínuos.",
                                "Logs registram todas detecções e ações sem erros de comunicação.",
                                "Taxa de falsos positivos/negativos <5% em testes variados."
                              ],
                              "assessmentCriteria": [
                                "Precisão de detecção de defeitos >95%.",
                                "Latência total do ciclo de inspeção <500ms.",
                                "Estabilidade da comunicação rede >99% uptime.",
                                "Facilidade de configuração e manutenção do sistema.",
                                "Integração sem conflitos com outros módulos do CLP.",
                                "Documentação completa de parâmetros e troubleshooting."
                              ],
                              "crossCurricularConnections": [
                                "Informática: Programação em Python/OpenCV para IA e processamento digital.",
                                "Eletrônica: Protocolos de comunicação industrial (Ethernet/IP, Modbus).",
                                "Mecânica: Design de fixação e alinhamento óptico de câmeras.",
                                "Matemática: Algoritmos de filtros e estatística para análise de imagens.",
                                "Gestão Industrial: Otimização de processos de qualidade e automação."
                              ],
                              "realWorldApplication": "Inspeção automatizada de qualidade em linhas de produção fabris, como detecção de defeitos em PCBs na indústria eletrônica, contagem de componentes em embalagens farmacêuticas ou verificação de alinhamento em montagem robótica automotiva."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.4",
                        "name": "Desenvolvimento Integrado e Aplicações Avançadas",
                        "description": "Abordagem multifuncional para projetos mecatrônicos com robótica aeronáutica, visão por computador e times interdisciplinares.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.4.1",
                            "name": "Planejar projetos com times multifuncionais",
                            "description": "Aplicar técnicas de desenvolvimento integrado de produtos, coordenando engenheiros mecânicos, elétricos e de software em mecatrônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise de Requisitos e Definição de Objetivos do Projeto",
                                  "subSteps": [
                                    "Identificar as necessidades do sistema mecatrônico, considerando componentes mecânicos, elétricos e de software.",
                                    "Realizar reuniões iniciais com stakeholders para coletar requisitos funcionais e não funcionais.",
                                    "Definir objetivos SMART (Específicos, Mensuráveis, Alcançáveis, Relevantes, Temporais).",
                                    "Documentar o escopo do projeto em um documento de requisitos.",
                                    "Validar os requisitos com a equipe multidisciplinar."
                                  ],
                                  "verification": "Documento de requisitos aprovado por todos os membros da equipe e stakeholders.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Ferramentas de colaboração como Microsoft Teams ou Google Workspace, templates de requisitos (ex: IEEE SRS).",
                                  "tips": "Use diagramas de contexto para visualizar integrações entre disciplinas.",
                                  "learningObjective": "Compreender e documentar requisitos integrados para projetos mecatrônicos.",
                                  "commonMistakes": "Ignorar requisitos de uma disciplina em favor de outra, levando a retrabalho."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formação da Equipe Multifuncional e Atribuição de Papéis",
                                  "subSteps": [
                                    "Listar perfis necessários: engenheiros mecânicos, elétricos, de software e gerentes de projeto.",
                                    "Selecionar membros com base em competências complementares e experiência em mecatrônica.",
                                    "Definir papéis e responsabilidades usando matriz RACI (Responsible, Accountable, Consulted, Informed).",
                                    "Realizar kick-off meeting para alinhamento de expectativas.",
                                    "Estabelecer normas de conduta e resolução de conflitos."
                                  ],
                                  "verification": "Matriz RACI assinada por todos os membros da equipe.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Planilhas para matriz RACI (Excel ou Google Sheets), perfis de competências.",
                                  "tips": "Priorize diversidade de backgrounds para inovação em integrações mecatrônicas.",
                                  "learningObjective": "Montar equipes eficazes para coordenação interdisciplinar.",
                                  "commonMistakes": "Sobrecarregar um membro com múltiplas disciplinas sem suporte."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolvimento do Cronograma e Alocação de Recursos",
                                  "subSteps": [
                                    "Criar Gantt chart com milestones para fases de design mecânico, elétrico e software.",
                                    "Estimar tempos e dependências entre disciplinas (ex: software após protótipo mecânico).",
                                    "Alocar recursos humanos, materiais e orçamentários por fase.",
                                    "Incluir buffers para integrações e testes.",
                                    "Revisar e ajustar o cronograma com input da equipe."
                                  ],
                                  "verification": "Cronograma aprovado com assinaturas digitais da equipe.",
                                  "estimatedTime": "5-8 horas",
                                  "materials": "Software de gerenciamento como MS Project, Trello ou Asana.",
                                  "tips": "Use método crítico do caminho (CPM) para identificar gargalos interdisciplinares.",
                                  "learningObjective": "Planejar cronogramas realistas para desenvolvimento integrado.",
                                  "commonMistakes": "Subestimar tempo de integração entre hardware e software."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecimento de Protocolos de Comunicação e Colaboração",
                                  "subSteps": [
                                    "Definir ferramentas de comunicação síncrona (Zoom) e assíncrona (Slack).",
                                    "Criar canais dedicados por disciplina e um geral para integrações.",
                                    "Estabelecer frequência de reuniões (diárias stand-up, semanais reviews).",
                                    "Implementar repositórios compartilhados (Git para software, CAD para mecânica).",
                                    "Treinar equipe em protocolos ágeis adaptados a mecatrônica (Scrum híbrido)."
                                  ],
                                  "verification": "Guia de comunicação testado em uma reunião simulada.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "Ferramentas como Slack, GitHub, Zoom; templates de atas de reunião.",
                                  "tips": "Registre todas as decisões em um log compartilhado para rastreabilidade.",
                                  "learningObjective": "Garantir fluxo de informação fluido entre equipes multifuncionais.",
                                  "commonMistakes": "Falta de padronização, causando mal-entendidos em interfaces."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Planejamento de Monitoramento, Riscos e Contingências",
                                  "subSteps": [
                                    "Identificar riscos potenciais (ex: atrasos em protótipos elétricos afetando software).",
                                    "Criar matriz de riscos com probabilidade, impacto e mitigação.",
                                    "Definir KPIs para cada disciplina e integrações.",
                                    "Planejar revisões regulares e ajustes.",
                                    "Preparar plano de contingência para cenários críticos."
                                  ],
                                  "verification": "Matriz de riscos e KPIs validados pela equipe.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Templates de matriz de riscos (Excel), dashboards de KPIs (Power BI).",
                                  "tips": "Priorize riscos de integração mecatrônica, como incompatibilidades de hardware/software.",
                                  "learningObjective": "Antecipar e mitigar riscos em projetos colaborativos.",
                                  "commonMistakes": "Ignorar riscos culturais ou de comunicação entre disciplinas."
                                }
                              ],
                              "practicalExample": "Planejar o desenvolvimento de um braço robótico industrial: engenheiro mecânico projeta estrutura, elétrico cuida de atuadores e sensores, software implementa controle via microcontrolador; coordenação garante sincronia em milestones de prototipagem integrada.",
                              "finalVerifications": [
                                "Plano de projeto completo aprovado por toda a equipe multifuncional.",
                                "Cronograma com dependências claras entre disciplinas.",
                                "Matriz RACI e de riscos assinadas.",
                                "Protocolos de comunicação testados e documentados.",
                                "Simulação inicial de kick-off meeting bem-sucedida.",
                                "Alinhamento de objetivos com requisitos mecatrônicos."
                              ],
                              "assessmentCriteria": [
                                "Clareza e completude do documento de planejamento (20%).",
                                "Adequação da formação da equipe e papéis (20%).",
                                "Realismo do cronograma e alocação de recursos (20%).",
                                "Robustez dos protocolos de comunicação (15%).",
                                "Identificação abrangente de riscos e mitigação (15%).",
                                "Integração efetiva de perspectivas mecatrônicas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos (PMBOK ou Agile).",
                                "Comunicação Organizacional e Trabalho em Equipe.",
                                "Engenharia de Sistemas e Integração.",
                                "Liderança e Resolução de Conflitos."
                              ],
                              "realWorldApplication": "Em indústrias automotiva e robótica, como na montagem de linhas de produção inteligentes na Bosch ou Siemens, onde times multifuncionais planejam sistemas mecatrônicos para automação industrial, reduzindo tempo de desenvolvimento em 30%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.4.2",
                            "name": "Introduzir sistemas de visão por computador",
                            "description": "Integrar câmeras e algoritmos de processamento de imagem com microcontroladores para aplicações mecatrônicas industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Seleção e Configuração do Hardware",
                                  "subSteps": [
                                    "Pesquisar e selecionar uma câmera compatível com o microcontrolador (ex: OV7670 para ESP32 ou Raspberry Pi Pico).",
                                    "Conectar a câmera ao microcontrolador via interface apropriada (I2C, SPI ou USB).",
                                    "Alimentar corretamente o hardware e verificar conexões com multímetro.",
                                    "Testar alimentação e sinal básico com osciloscópio ou LED indicador.",
                                    "Instalar drivers ou bibliotecas de hardware no microcontrolador."
                                  ],
                                  "verification": "Câmera detectada pelo microcontrolador sem erros de conexão; imagem raw capturada via serial monitor.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Câmera módulo (OV7670), microcontrolador (ESP32), fios jumper, multímetro, protoboard.",
                                  "tips": "Use diagramas de pinout oficiais para evitar curtos-circuitos.",
                                  "learningObjective": "Entender interfaces de hardware para visão computacional em sistemas embarcados.",
                                  "commonMistakes": "Conexões invertidas de VCC/GND; ignorar requisitos de corrente da câmera."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração do Ambiente de Software e Captura de Imagem",
                                  "subSteps": [
                                    "Instalar IDE (Arduino IDE ou PlatformIO) e bibliotecas como ESP32-CAM ou esp_camera.",
                                    "Escrever código básico para inicializar a câmera e capturar frames.",
                                    "Transmitir imagens via WiFi/Serial para visualização em PC (usando Processing ou app web).",
                                    "Ajustar parâmetros de câmera (resolução, FPS, exposição).",
                                    "Salvar frames em cartão SD ou buffer de memória."
                                  ],
                                  "verification": "Imagens capturadas exibidas em tempo real no monitor serial ou app; sem artefatos visíveis.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Computador com IDE instalada, cartão SD opcional, acesso WiFi.",
                                  "tips": "Comece com baixa resolução para depuração rápida.",
                                  "learningObjective": "Configurar software para aquisição de imagens em microcontroladores.",
                                  "commonMistakes": "Bibliotecas incompatíveis com versão do board; buffer overflow por imagens grandes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação de Algoritmos de Processamento de Imagem",
                                  "subSteps": [
                                    "Implementar filtros básicos (thresholding, edge detection) usando OpenCV-lite ou bibliotecas embarcadas (ex: ESP-DL).",
                                    "Desenvolver detecção de objetos simples (ex: contornos via Canny + findContours).",
                                    "Otimizar algoritmos para tempo real (reduzir resolução, usar grayscale).",
                                    "Adicionar segmentação de cor HSV para identificação de peças.",
                                    "Testar precisão em diferentes condições de iluminação."
                                  ],
                                  "verification": "Algoritmo detecta e destaca objetos corretamente em pelo menos 80% das imagens testadas.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Bibliotecas OpenCV para embedded (esp32-camera com EloquentArduino), amostras de imagens.",
                                  "tips": "Use funções vetorizadas para performance; teste com imagens reais variadas.",
                                  "learningObjective": "Aplicar processamento de imagem básico em recursos limitados de microcontroladores.",
                                  "commonMistakes": "Processamento em RGB em vez de HSV; loops ineficientes causando lag."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração com Sistemas Mecatrônicos e Controle",
                                  "subSteps": [
                                    "Interfacear resultados de visão com GPIOs para controlar atuadores (servos, relés).",
                                    "Implementar lógica de decisão (ex: se objeto detectado, ativar motor).",
                                    "Adicionar comunicação via MQTT ou UART com CLP/supervisor.",
                                    "Simular aplicação industrial (ex: sorting de peças por cor/tamanho).",
                                    "Implementar feedback loop com sensores adicionais."
                                  ],
                                  "verification": "Sistema responde corretamente a inputs visuais, ativando atuadores em <500ms.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Atuadores (servo, motor DC), CLP opcional, plataforma de teste (esteira simulada).",
                                  "tips": "Use estados finitos para gerenciar fluxos de controle.",
                                  "learningObjective": "Integrar visão computacional em loops de controle mecatrônicos.",
                                  "commonMistakes": "Latência alta por processamento bloqueante; falha em sincronizar visão com atuadores."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes, Otimização e Validação Industrial",
                                  "subSteps": [
                                    "Executar testes de robustez (iluminação variável, vibração, poeira).",
                                    "Otimizar código para consumo de energia e velocidade.",
                                    "Coletar métricas (precisão, recall, FPS).",
                                    "Documentar setup e gerar relatório de performance.",
                                    "Simular falhas e implementar redundâncias."
                                  ],
                                  "verification": "Sistema opera com >90% acurácia em cenários industriais simulados por 30min contínuos.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "Caixa de testes ambiental, cronômetro, ferramentas de profiling.",
                                  "tips": "Registre logs para análise pós-teste.",
                                  "learningObjective": "Validar sistemas de visão para ambientes industriais reais.",
                                  "commonMistakes": "Testes só em condições ideais; ignorar consumo de energia."
                                }
                              ],
                              "practicalExample": "Desenvolver um sistema de inspeção de qualidade em linha de montagem: câmera detecta defeitos em parafusos (tamanho/cor errada), sinaliza rejeição via atuador pneumático conectado ao microcontrolador ESP32.",
                              "finalVerifications": [
                                "Câmera captura imagens em tempo real sem perda de frames.",
                                "Algoritmos processam e detectam objetos com acurácia >85%.",
                                "Integração ativa atuadores corretamente baseado em visão.",
                                "Sistema resiste a variações de iluminação (±50% lux).",
                                "Consumo de energia <2W em operação contínua.",
                                "Logs e métricas documentados."
                              ],
                              "assessmentCriteria": [
                                "Precisão de detecção: >90% em testes padronizados.",
                                "Tempo de resposta end-to-end: <1s por ciclo.",
                                "Robustez: Funciona em 95% dos cenários variáveis.",
                                "Eficiência de código: FPS >5 em hardware embarcado.",
                                "Documentação: Diagrama completo e código comentado.",
                                "Integração: Sem conflitos com outros subsistemas mecatrônicos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Embarcada: Uso de C++ e bibliotecas RTOS.",
                                "Eletrônica Digital: Interfaces I2C/SPI e sinalização.",
                                "Inteligência Artificial: Conceitos básicos de visão computacional.",
                                "Automação Industrial: Integração com CLPs e Industry 4.0."
                              ],
                              "realWorldApplication": "Inspeção automatizada em fábricas de automotiva, detectando defeitos em peças soldadas ou montadas, reduzindo erros humanos em 70% e aumentando throughput em linhas de produção."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.4.3",
                            "name": "Aplicar robótica na indústria aeronáutica",
                            "description": "Desenvolver projetos mecatrônicos robóticos para montagem aeronáutica, usando CLPs e microprocessadores para precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise de Requisitos para Montagem Aeronáutica",
                                  "subSteps": [
                                    "Identificar componentes aeronáuticos críticos como fuselagem, asas e sistemas de montagem.",
                                    "Definir tolerâncias de precisão (ex.: ±0.1mm para parafusos).",
                                    "Mapear processos de montagem manual e pontos de automação robótica.",
                                    "Especificar interfaces com CLPs e microprocessadores para controle em tempo real.",
                                    "Documentar riscos de segurança e normas aeronáuticas (ex.: FAA, EASA)."
                                  ],
                                  "verification": "Relatório de requisitos aprovado com diagrama de fluxo de montagem.",
                                  "estimatedTime": "8 horas",
                                  "materials": "Normas aeronáuticas (PDFs), software de modelagem (SolidWorks), planilhas de requisitos.",
                                  "tips": "Priorize precisão sobre velocidade inicial para evitar retrabalho.",
                                  "learningObjective": "Compreender requisitos específicos da indústria aeronáutica para robótica.",
                                  "commonMistakes": "Ignorar normas de segurança aeronáutica levando a designs não conformes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Design do Sistema Robótico Mecatrônico",
                                  "subSteps": [
                                    "Modelar o robô (ex.: braço articulado de 6 eixos) em CAD para montagem de painéis.",
                                    "Selecionar atuadores, sensores (visão, força) e end-effectors para tarefas precisas.",
                                    "Integrar CLP para controle sequencial e microprocessador para feedback em tempo real.",
                                    "Simular cinemática e dinâmica usando software como ROS ou MATLAB.",
                                    "Gerar desenhos técnicos e lista de materiais (BOM)."
                                  ],
                                  "verification": "Modelo 3D simulado sem colisões e com precisão validada.",
                                  "estimatedTime": "12 horas",
                                  "materials": "Software CAD (SolidWorks/AutoCAD), simulador ROS, hardware protótipo básico.",
                                  "tips": "Use análise de falhas (FMEA) para prever problemas em ambientes aeronáuticos.",
                                  "learningObjective": "Projetar sistemas robóticos otimizados para precisão aeronáutica.",
                                  "commonMistakes": "Subestimar vibrações em montagens leves, causando perda de precisão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Programação de CLPs e Microprocessadores",
                                  "subSteps": [
                                    "Configurar CLP (ex.: Siemens S7) com ladder logic para sequências de montagem.",
                                    "Programar microprocessador (ex.: Arduino/ESP32) para controle PID de posição.",
                                    "Implementar comunicação (Ethernet/IP, Modbus) entre CLP e microprocessador.",
                                    "Adicionar lógica de segurança (parada de emergência, detecção de falhas).",
                                    "Testar código em simulador antes de hardware real."
                                  ],
                                  "verification": "Código compilado e simulado com cenários de montagem sem erros.",
                                  "estimatedTime": "16 horas",
                                  "materials": "Software de programação CLP (TIA Portal), IDE Arduino, osciloscópio.",
                                  "tips": "Modularize o código para facilitar depuração em ciclos rápidos.",
                                  "learningObjective": "Dominar programação integrada para controle preciso em robótica.",
                                  "commonMistakes": "Falhas na comunicação serial causando delays em tempo real."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montagem, Integração e Testes Iniciais",
                                  "subSteps": [
                                    "Montar hardware robótico conforme desenhos CAD.",
                                    "Integrar sensores, CLP e microprocessador no sistema.",
                                    "Executar testes unitários (movimento, precisão, sensores).",
                                    "Calibrar sistema para tolerâncias aeronáuticas.",
                                    "Registrar dados de testes e ajustes necessários."
                                  ],
                                  "verification": "Protótipo executa montagem simulada com precisão <0.1mm.",
                                  "estimatedTime": "20 horas",
                                  "materials": "Componentes robóticos (motores, sensores), ferramentas de montagem, bancada de testes.",
                                  "tips": "Teste em ambiente controlado simulando vibrações aeronáuticas.",
                                  "learningObjective": "Integrar e testar sistemas mecatrônicos completos.",
                                  "commonMistakes": "Pular calibração inicial, resultando em erros cumulativos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação Final e Otimização",
                                  "subSteps": [
                                    "Realizar testes end-to-end com peças aeronáuticas simuladas.",
                                    "Otimizar ciclos de tempo e consumo energético.",
                                    "Validar conformidade com normas de segurança e precisão.",
                                    "Documentar projeto completo e plano de escalabilidade.",
                                    "Preparar relatório de desempenho com métricas."
                                  ],
                                  "verification": "Sistema atende todos os critérios de precisão e segurança em testes repetidos.",
                                  "estimatedTime": "12 horas",
                                  "materials": "Peças de teste aeronáuticas, software de análise de dados (LabVIEW).",
                                  "tips": "Use dados de telemetria para iterações rápidas.",
                                  "learningObjective": "Validar e otimizar projetos para aplicação industrial.",
                                  "commonMistakes": "Não considerar escalabilidade para produção em massa."
                                }
                              ],
                              "practicalExample": "Desenvolver um braço robótico para parafusar painéis na fuselagem de uma aeronave pequena, usando CLP para sequência de furação-montagem e microprocessador para ajuste fino de torque, alcançando precisão de 0.05mm em 10 ciclos.",
                              "finalVerifications": [
                                "Sistema atinge precisão de ±0.1mm em montagem simulada.",
                                "CLP e microprocessador comunicam sem perda de pacotes.",
                                "Tempo de ciclo <30s por operação crítica.",
                                "Todas as paradas de segurança ativam em <100ms.",
                                "Conformidade com normas aeronáuticas verificada.",
                                "Documentação completa e BOM atualizados."
                              ],
                              "assessmentCriteria": [
                                "Precisão e repetibilidade do robô (nota 1-10).",
                                "Eficiência do código CLP/microprocessador (tempo de execução).",
                                "Integração de sensores e atuadores sem falhas.",
                                "Adesão a normas de segurança aeronáutica.",
                                "Qualidade da documentação e relatórios.",
                                "Capacidade de escalabilidade demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Aeroespacial: Design de componentes leves.",
                                "Programação: Algoritmos de controle PID.",
                                "Materiais: Seleção de ligas para alta precisão.",
                                "Gestão de Projetos: Metodologia Ágil em protótipos."
                              ],
                              "realWorldApplication": "Em fábricas da Embraer ou Boeing, robôs mecatrônicos automatizam montagem de fuselagens, reduzindo erros humanos em 90% e acelerando produção de aeronaves comerciais."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Elaboração de Projetos Microcontrolados",
                    "description": "Técnicas para desenvolvimento, programação e execução de projetos de sistemas mecatrônicos baseados em microcontroladores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Planejamento e Especificação de Projetos Microcontrolados",
                        "description": "Definição das etapas iniciais para elaboração de projetos mecatrônicos baseados em microcontroladores, incluindo análise de requisitos e formação de equipes multifuncionais conforme técnicas de Desenvolvimento Integrado de Produtos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Análise de Requisitos do Sistema",
                            "description": "Identificar e documentar os requisitos funcionais e não funcionais de um sistema mecatrônico, considerando interfaces com sensores, atuadores e microcontroladores, utilizando métodos de engenharia como os descritos em CROSS (2004).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificação dos Stakeholders e Entendimento do Problema",
                                  "subSteps": [
                                    "Reúna informações sobre o contexto do sistema mecatrônico, incluindo objetivos gerais e restrições iniciais.",
                                    "Identifique todos os stakeholders relevantes (usuários finais, engenheiros, gerentes de projeto).",
                                    "Realize entrevistas ou questionários iniciais para mapear necessidades básicas.",
                                    "Defina o escopo do problema, focando em interfaces com sensores, atuadores e microcontroladores.",
                                    "Crie um diagrama de contexto inicial baseado no método de CROSS (2004)."
                                  ],
                                  "verification": "Verifique se há uma lista completa de stakeholders e um diagrama de contexto aprovado por pelo menos um stakeholder.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ferramentas de diagramação (Draw.io ou Visio)",
                                    "Questionários padronizados",
                                    "Referência: CROSS (2004) - Engenharia de Requisitos"
                                  ],
                                  "tips": "Priorize stakeholders com maior impacto no sistema; grave entrevistas para revisão posterior.",
                                  "learningObjective": "Compreender o problema do sistema e mapear atores envolvidos.",
                                  "commonMistakes": [
                                    "Ignorar stakeholders secundários",
                                    "Definir escopo muito amplo sem foco em mecatrônica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coleta de Requisitos Funcionais e Não Funcionais",
                                  "subSteps": [
                                    "Utilize técnicas como brainstorming e workshops com stakeholders para elicitar requisitos.",
                                    "Liste requisitos funcionais: o que o sistema deve fazer (ex.: ler sensor de temperatura, acionar motor via microcontrolador).",
                                    "Liste requisitos não funcionais: desempenho, segurança, usabilidade (ex.: resposta em <1s, tolerância a vibrações).",
                                    "Considere interfaces específicas: protocolos de comunicação (I2C, SPI) entre sensores/atuadores e microcontroladores.",
                                    "Registre todos os requisitos em uma planilha ou ferramenta colaborativa."
                                  ],
                                  "verification": "Confira se todos os requisitos estão rastreados em uma tabela com fontes e prioridades.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Planilhas (Google Sheets ou Excel)",
                                    "Ferramentas de elicitação (Miro ou Jamboard)",
                                    "Livro CROSS (2004)"
                                  ],
                                  "tips": "Use o método MoSCoW (Must, Should, Could, Won't) para priorizar requisitos.",
                                  "learningObjective": "Elicitar requisitos abrangentes considerando aspectos mecatrônicos.",
                                  "commonMistakes": [
                                    "Confundir funcionais com não funcionais",
                                    "Omitir requisitos de interface hardware-software"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Análise e Classificação de Requisitos",
                                  "subSteps": [
                                    "Analise requisitos para inconsistências, ambiguidades ou conflitos usando checklists de CROSS (2004).",
                                    "Classifique em funcionais (comportamentos) e não funcionais (qualidades).",
                                    "Crie modelos como casos de uso ou diagramas de fluxo de dados para requisitos funcionais.",
                                    "Avalie viabilidade técnica para interfaces mecatrônicas (ex.: compatibilidade de microcontroladores com sensores).",
                                    "Atribua atributos SMART (Specific, Measurable, Achievable, Relevant, Time-bound) a cada requisito."
                                  ],
                                  "verification": "Realize uma revisão por pares onde todos os requisitos passam na checklist de análise.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "UML tools (Lucidchart)",
                                    "Checklists de requisitos de CROSS (2004)",
                                    "Templates de casos de uso"
                                  ],
                                  "tips": "Modele fluxos com swimlane diagrams para visualizar interfaces.",
                                  "learningObjective": "Refinar requisitos para clareza e completude.",
                                  "commonMistakes": [
                                    "Requisitos vagos como 'rápido'",
                                    "Ignorar trade-offs entre desempenho e custo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentação e Validação Inicial",
                                  "subSteps": [
                                    "Compile todos os requisitos em um documento SRS (Software/Hardware Requirements Specification).",
                                    "Inclua seções para introdução, escopo, requisitos detalhados e glossário.",
                                    "Valide o documento com stakeholders via walkthroughs ou protótipos simulados.",
                                    "Incorpore feedback e itere até aprovação.",
                                    "Versione o documento e defina baseline."
                                  ],
                                  "verification": "Obtenha assinaturas ou aprovações formais de stakeholders chave no documento.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Templates SRS (IEEE Std 830)",
                                    "Ferramentas de versionamento (Git ou Google Docs)",
                                    "CROSS (2004)"
                                  ],
                                  "tips": "Use numeração hierárquica para requisitos (ex.: REQ-1.1) para rastreabilidade.",
                                  "learningObjective": "Produzir uma especificação formal e validada.",
                                  "commonMistakes": [
                                    "Documentação incompleta sem glossário",
                                    "Pular validação com usuários reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de irrigação automatizada: requisitos funcionais incluem 'ler umidade do solo via sensor analógico no Arduino e acionar bomba d'água se <30%'; não funcionais: 'resistir a umidade IP65 e responder em <5s'. Documente em SRS com diagramas de interfaces.",
                              "finalVerifications": [
                                "Todos os requisitos estão priorizados e rastreáveis a stakeholders.",
                                "SRS cobre interfaces sensores/atuadores/microcontroladores explicitamente.",
                                "Nenhuma ambiguidade detectada em revisão por pares.",
                                "Requisitos são SMART e alinhados com CROSS (2004).",
                                "Documento versionado e aprovado.",
                                "Modelos (casos de uso, diagramas) suportam os requisitos."
                              ],
                              "assessmentCriteria": [
                                "Completude: Cobertura de funcionais e não funcionais (90%+).",
                                "Clareza: Linguagem precisa, sem ambiguidades.",
                                "Rastreabilidade: Cada requisito ligado a fonte e prioridade.",
                                "Viabilidade: Alinhamento com tecnologias mecatrônicas realistas.",
                                "Validação: Evidência de feedback de stakeholders.",
                                "Conformidade: Segue métodos de CROSS (2004)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Especificação de interfaces sensores/atuadores.",
                                "Programação: Requisitos para firmware de microcontroladores.",
                                "Gestão de Projetos: Técnicas de elicitação e priorização.",
                                "Matemática: Modelagem de desempenho (tempos de resposta, precisão).",
                                "Segurança do Trabalho: Requisitos não funcionais de segurança."
                              ],
                              "realWorldApplication": "Em fábricas automotivas, análise de requisitos garante que sistemas de controle robótico integrem sensores de visão com atuadores precisos via PLCs, evitando falhas caras e otimizando produção."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Formação de Equipes Multifuncionais",
                            "description": "Estruturar times com engenheiros mecânicos, elétricos e de software para projetos integrados, aplicando princípios de Desenvolvimento Integrado de Produtos para otimizar o fluxo de trabalho em sistemas microcontrolados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar Necessidades do Projeto e Definir Objetivos",
                                  "subSteps": [
                                    "Analise o escopo do projeto microcontrolado, identificando componentes mecânicos, elétricos e de software necessários.",
                                    "Mapeie os requisitos integrados, como interfaces entre hardware e firmware.",
                                    "Defina objetivos claros de equipe, incluindo prazos e entregas esperadas.",
                                    "Liste riscos potenciais relacionados à integração multifuncional.",
                                    "Documente um plano inicial de necessidades em um relatório preliminar."
                                  ],
                                  "verification": "Verifique se o relatório de necessidades cobre mecânica, elétrica, software e integração, com objetivos SMART.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de planejamento como Trello ou Microsoft Project",
                                    "Documentação do projeto microcontrolado",
                                    "Templates de análise de requisitos"
                                  ],
                                  "tips": "Envolva stakeholders iniciais para validar as necessidades e evitar escopo creep.",
                                  "learningObjective": "Compreender como alinhar necessidades do projeto com composição de equipe multifuncional.",
                                  "commonMistakes": [
                                    "Ignorar dependências entre disciplinas",
                                    "Definir objetivos vagos",
                                    "Subestimar riscos de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Perfis e Competências Requeridas",
                                  "subSteps": [
                                    "Liste competências essenciais: engenharia mecânica (CAD, prototipagem), elétrica (circuitos, sensores) e software (programação embarcada, C/Arduino).",
                                    "Crie matriz de competências usando princípios de IPD para colaboração integrada.",
                                    "Priorize perfis com experiência em projetos microcontrolados.",
                                    "Avalie necessidades de competências complementares, como comunicação e resolução de conflitos.",
                                    "Valide a lista com referências de projetos semelhantes."
                                  ],
                                  "verification": "Confirme que a matriz de competências cobre todas as disciplinas e está balanceada para IPD.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Matriz de competências em Excel/Google Sheets",
                                    "Perfis profissionais de engenheiros (LinkedIn ou CVs)",
                                    "Livros ou guias sobre IPD como 'Integrated Product Development'"
                                  ],
                                  "tips": "Use ferramentas como Skills Matrix para visualizar gaps de competências.",
                                  "learningObjective": "Mapear competências multidisciplinares para otimizar equipes em projetos integrados.",
                                  "commonMistakes": [
                                    "Focar apenas em habilidades técnicas, ignorando soft skills",
                                    "Sobrecarregar uma disciplina",
                                    "Não considerar experiência prévia em microcontroladores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Recrutar e Selecionar Membros da Equipe",
                                  "subSteps": [
                                    "Publique chamadas internas/externas destacando o foco em IPD e microcontroladores.",
                                    "Realize entrevistas técnicas e comportamentais para avaliar fit multidisciplinar.",
                                    "Forme shortlist baseada em matriz de competências e diversidade.",
                                    "Obtenha aprovações e confirme disponibilidades.",
                                    "Comunique seleções e expectativas iniciais."
                                  ],
                                  "verification": "Verifique se a equipe selecionada tem representação equilibrada das três disciplinas e assinaturas de compromisso.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Plataformas de recrutamento (LinkedIn, vagas internas)",
                                    "Questionários de entrevista padronizados",
                                    "Ferramentas de videochamada como Zoom"
                                  ],
                                  "tips": "Inclua dinâmicas de grupo nas entrevistas para testar colaboração.",
                                  "learningObjective": "Selecionar profissionais alinhados com princípios de desenvolvimento integrado.",
                                  "commonMistakes": [
                                    "Recrutar apenas especialistas isolados sem sinergia",
                                    "Ignorar disponibilidade e conflitos de agenda",
                                    "Não avaliar cultura de equipe"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estruturar Equipe e Otimizar Fluxo de Trabalho com IPD",
                                  "subSteps": [
                                    "Defina papéis e responsabilidades usando RACI matrix.",
                                    "Estabeleça canais de comunicação (daily stand-ups, Slack/Teams).",
                                    "Implemente fluxo IPD: planejamento paralelo, reviews integrados e iterações ágeis.",
                                    "Crie cronograma otimizado para microcontroladores, com milestones de integração.",
                                    "Realize kick-off meeting para alinhamento."
                                  ],
                                  "verification": "Confirme RACI preenchida, cronograma aprovado e atas do kick-off distribuídas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "RACI template",
                                    "Ferramentas ágeis como Jira ou Asana",
                                    "Documentos IPD (NASA ou Boeing guidelines)"
                                  ],
                                  "tips": "Promova co-localização virtual ou física para integração rápida.",
                                  "learningObjective": "Aplicar IPD para estruturar fluxos colaborativos em sistemas mecatrônicos.",
                                  "commonMistakes": [
                                    "Definir hierarquias rígidas",
                                    "Subestimar tempo de comunicação",
                                    "Não integrar feedback loops"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Treinar e Alinhar Equipe para Execução",
                                  "subSteps": [
                                    "Conduza sessão de treinamento em IPD e ferramentas microcontroladas (ex: Arduino IDE).",
                                    "Simule cenários de integração para prática.",
                                    "Estabeleça métricas de performance coletiva.",
                                    "Defina plano de resolução de conflitos.",
                                    "Monitore alinhamento inicial com survey rápido."
                                  ],
                                  "verification": "Avalie com survey pós-treinamento (nota >80%) e plano de métricas documentado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tutoriais Arduino/STM32",
                                    "Simuladores como Tinkercad",
                                    "Survey tools como Google Forms"
                                  ],
                                  "tips": "Use gamificação para engajar em treinamentos multidisciplinares.",
                                  "learningObjective": "Garantir readiness da equipe para projetos integrados via treinamento direcionado.",
                                  "commonMistakes": [
                                    "Pular treinamento por pressa",
                                    "Não medir alinhamento inicial",
                                    "Ignorar dinâmicas de equipe"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um projeto de braço robótico com microcontrolador STM32: Step 1 identifica necessidade de mecânico para juntas, elétrico para atuadores e software para controle PID; recrute um de cada; estruture com dailies IPD para integrar firmware com hardware em 4 semanas.",
                              "finalVerifications": [
                                "Equipe possui pelo menos um especialista em mecânica, elétrica e software.",
                                "RACI e cronograma IPD aprovados por todos os membros.",
                                "Kick-off meeting realizado com atas e metas claras.",
                                "Matriz de competências 100% preenchida sem gaps críticos.",
                                "Survey inicial indica alinhamento >85%.",
                                "Plano de comunicação e resolução de conflitos definido."
                              ],
                              "assessmentCriteria": [
                                "Diversidade e equilíbrio de competências multidisciplinares (peso 25%).",
                                "Alinhamento com princípios IPD e otimização de fluxo (peso 25%).",
                                "Clareza em papéis e responsabilidades via RACI (peso 20%).",
                                "Viabilidade do cronograma para integração microcontrolada (peso 15%).",
                                "Nível de engajamento e alinhamento pós-kick-off (peso 15%)."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Uso de metodologias ágeis e IPD.",
                                "Comunicações: Canais e resolução de conflitos.",
                                "Liderança e Trabalho em Equipe: Seleção e motivação.",
                                "Ética Profissional: Diversidade e inclusão em equipes.",
                                "Inovação: Integração criativa de disciplinas."
                              ],
                              "realWorldApplication": "Em indústrias como automotiva (ex: Bosch) ou robótica (ex: Fanuc), onde equipes multifuncionais desenvolvem sistemas mecatrônicos como veículos autônomos, reduzindo tempo de mercado em 30% via IPD."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Definição de Cronograma e Recursos",
                            "description": "Elaborar cronogramas Gantt e listas de recursos necessários para projetos microcontrolados, incluindo seleção inicial de microcontroladores como Arduino ou PIC, alinhado a SHETTY e KOLK (1997).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar Requisitos e Escopo do Projeto",
                                  "subSteps": [
                                    "Identificar objetivos principais e deliverables do projeto microcontrolado.",
                                    "Listar tarefas principais, subtarefas e dependências lógicas.",
                                    "Estimar durações iniciais para cada tarefa com base em experiência ou referências como SHETTY e KOLK (1997).",
                                    "Definir milestones chave e restrições (tempo, custo, equipe).",
                                    "Documentar escopo em um relatório inicial."
                                  ],
                                  "verification": "Relatório de escopo aprovado com lista de tarefas e dependências validadas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Papel/caneta ou software de notas (ex: Google Docs)",
                                    "Descrição inicial do projeto",
                                    "Referência SHETTY e KOLK (1997)"
                                  ],
                                  "tips": "Consulte stakeholders para refinar estimativas e evitar escopo creep.",
                                  "learningObjective": "Desenvolver habilidade em decompor projetos complexos em componentes gerenciáveis.",
                                  "commonMistakes": [
                                    "Subestimar dependências entre tarefas",
                                    "Ignorar restrições externas como prazos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar Microcontrolador Inicial",
                                  "subSteps": [
                                    "Listar requisitos de hardware: pinos I/O, memória RAM/Flash, velocidade de clock, interfaces (ex: UART, I2C).",
                                    "Comparar opções como Arduino Uno, PIC16F, ESP32 usando tabela de critérios.",
                                    "Avaliar fatores: custo, disponibilidade, suporte IDE e comunidade.",
                                    "Justificar escolha alinhada a SHETTY e KOLK (1997) para projetos mecatrônicos.",
                                    "Documentar decisão com prós/contras."
                                  ],
                                  "verification": "Tabela comparativa e relatório de seleção com escolha final justificada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Datasheets de microcontroladores (Arduino, PIC)",
                                    "Planilha Excel/Google Sheets",
                                    "Referência SHETTY e KOLK (1997)"
                                  ],
                                  "tips": "Priorize escalabilidade para futuras expansões do projeto.",
                                  "learningObjective": "Aprender a mapear requisitos funcionais a hardware específico.",
                                  "commonMistakes": [
                                    "Escolher baseado apenas em custo sem considerar performance",
                                    "Ignorar compatibilidade com sensores periféricos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Elaborar Cronograma Gantt",
                                  "subSteps": [
                                    "Organizar tarefas do Step 1 em sequência com dependências (predecessor/sucessor).",
                                    "Atribuir durações realistas e calcular datas de início/fim.",
                                    "Criar gráfico Gantt usando software, marcando milestones e folga.",
                                    "Identificar caminho crítico e pontos de risco.",
                                    "Exportar e revisar o cronograma para realismo."
                                  ],
                                  "verification": "Gráfico Gantt completo com caminho crítico destacado e exportado em PDF.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software Gantt gratuito (GanttProject, LibreOffice)",
                                    "Lista de tarefas do Step 1"
                                  ],
                                  "tips": "Use cores para tipos de tarefas (ex: azul para programação, vermelho para testes).",
                                  "learningObjective": "Dominar visualização temporal de projetos para gerenciamento eficaz.",
                                  "commonMistakes": [
                                    "Não considerar folgas ou buffers para imprevistos",
                                    "Sobrecarregar fases iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Lista de Recursos Necessários",
                                  "subSteps": [
                                    "Categorizar recursos: hardware (microcontrolador, sensores), software (IDE), humanos (equipe).",
                                    "Estimar quantidades, custos unitários e totais para cada item.",
                                    "Verificar disponibilidade com fornecedores e lead times.",
                                    "Alocar recursos ao cronograma Gantt.",
                                    "Criar orçamento consolidado e plano de aquisição."
                                  ],
                                  "verification": "Lista de recursos detalhada com orçamento total e alocação no Gantt.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Catálogos de fornecedores (ex: DigiKey, Mercado Livre)",
                                    "Planilhas de custo",
                                    "Cronograma Gantt"
                                  ],
                                  "tips": "Inclua 10-20% de contingência no orçamento para variações de preço.",
                                  "learningObjective": "Integrar alocação de recursos ao planejamento temporal do projeto.",
                                  "commonMistakes": [
                                    "Esquecer recursos não-técnicos como ferramentas de solda",
                                    "Não prever lead times longos"
                                  ]
                                }
                              ],
                              "practicalExample": "Projeto de controle de temperatura para estufa usando Arduino Uno: Escopo inclui sensores DHT11 e relés; Gantt de 6 semanas (Semana 1: Aquisição; Semana 2-3: Montagem; etc.); Recursos: Arduino Uno (R$50), DHT11 (R$15x2), protoboard, total R$200.",
                              "finalVerifications": [
                                "Cronograma Gantt cobre 100% das tarefas com dependências lógicas.",
                                "Microcontrolador selecionado justificado por requisitos específicos.",
                                "Lista de recursos inclui custos totais abaixo do orçamento limite.",
                                "Caminho crítico identificado com buffers adequados.",
                                "Documentos integrados e prontos para apresentação.",
                                "Alinhamento com princípios de SHETTY e KOLK (1997) documentado."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão do Gantt (legibilidade, escalas corretas).",
                                "Realismo das estimativas de tempo e recursos (baseadas em dados).",
                                "Justificativa técnica da seleção de microcontrolador.",
                                "Completude da lista de recursos com categorização e custos.",
                                "Identificação de riscos e contingências.",
                                "Integração entre cronograma e recursos."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos (PMBOK: planejamento temporal e de custos).",
                                "Engenharia de Software (decomposição de tarefas e estimativas).",
                                "Matemática Aplicada (cálculo de caminho crítico e orçamentos).",
                                "Administração (controle de estoque e fornecedores)."
                              ],
                              "realWorldApplication": "Na indústria automotiva, engenheiros usam Gantt e listas de recursos para planejar sistemas de controle embarcado em veículos, evitando atrasos milionários em linhas de produção, como em fábricas da Toyota ou Bosch."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Design de Hardware para Microcontroladores",
                        "description": "Projeto do hardware físico do sistema mecatrônico, focando em integração de microcontroladores com componentes eletromecânicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Seleção de Microcontroladores",
                            "description": "Escolher microcontroladores adequados (ex.: AVR, ARM) com base em critérios de processamento, I/O e consumo de energia para aplicações mecatrônicas industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Requisitos da Aplicação Mecatrônica",
                                  "subSteps": [
                                    "Analise o escopo do projeto mecatrônico industrial, identificando funções principais como controle de motores, sensores e atuadores.",
                                    "Liste requisitos de processamento: velocidade de clock necessária (ex.: MHz), capacidade de memória (RAM/Flash) e periféricos requeridos.",
                                    "Especifique necessidades de I/O: número de pinos digitais/analógicos, interfaces como UART, SPI, I2C.",
                                    "Avalie restrições de consumo de energia: limite de corrente, modos de baixo consumo para aplicações battery-powered ou industriais.",
                                    "Considere ambiente operacional: temperatura, vibração, certificações industriais (ex.: IEC 61508)."
                                  ],
                                  "verification": "Criar uma tabela de requisitos com colunas para função, métrica quantitativa e prioridade (alta/média/baixa).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Especificação do projeto mecatrônico",
                                    "Documentação de normas industriais"
                                  ],
                                  "tips": "Priorize requisitos críticos usando MoSCoW (Must, Should, Could, Won't).",
                                  "learningObjective": "Mapear requisitos funcionais e não-funcionais para guiar a seleção de hardware.",
                                  "commonMistakes": [
                                    "Ignorar restrições ambientais",
                                    "Subestimar necessidades de I/O futuras",
                                    "Não quantificar métricas de performance"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar Famílias de Microcontroladores Adequadas",
                                  "subSteps": [
                                    "Identifique famílias relevantes: AVR (ex.: ATmega), ARM Cortex-M (ex.: STM32), PIC para aplicações industriais.",
                                    "Consulte datasheets e sites de fabricantes (Microchip, STMicroelectronics, NXP) para overview de portfólios.",
                                    "Filtre opções iniciais baseadas em arquitetura (8-bit, 32-bit) e aplicação mecatrônica (controle real-time).",
                                    "Compile uma lista curta de 5-10 candidatos com links para documentação.",
                                    "Verifique suporte a ferramentas de desenvolvimento e ecossistema (IDE, bibliotecas HAL)."
                                  ],
                                  "verification": "Lista de candidatos com resumo de arquitetura, clock max e memória em uma tabela comparativa inicial.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Datasheets online (Digikey, Mouser)",
                                    "Ferramentas de busca como Octopart",
                                    "Navegador web"
                                  ],
                                  "tips": "Use comparadores de MCU online como o da DigiKey para agilizar a pesquisa.",
                                  "learningObjective": "Explorar portfólios de MCU e mapear famílias a cenários industriais.",
                                  "commonMistakes": [
                                    "Focar apenas em um fabricante",
                                    "Ignorar suporte de software",
                                    "Não considerar escalabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Especificações Técnicas Chave",
                                  "subSteps": [
                                    "Crie matriz de comparação: colunas para clock speed, RAM/Flash, pinos I/O, ADC/DAC, timers/PWM.",
                                    "Avalie consumo de energia: corrente em active/sleep modes, eficiência em uA/MHz.",
                                    "Pontue cada candidato (1-10) por critério usando pesos baseados em requisitos do Step 1.",
                                    "Simule cargas de trabalho básicas para estimar performance (ex.: ciclos por interrupção).",
                                    "Identifique trade-offs, como alto processamento vs. alto consumo."
                                  ],
                                  "verification": "Matriz de comparação preenchida com scores e ranking inicial dos candidatos.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Planilhas de cálculo",
                                    "Calculadoras de consumo de MCU dos fabricantes",
                                    "Datasheets detalhados"
                                  ],
                                  "tips": "Use fórmulas em planilhas para scores ponderados: Score = Soma(Peso * Nota).",
                                  "learningObjective": "Aplicar análise quantitativa para comparar MCUs em métricas críticas.",
                                  "commonMistakes": [
                                    "Comparar apenas specs de pico",
                                    "Ignorar overhead de periféricos",
                                    "Não pesar critérios adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Fatores Adicionais e Selecionar",
                                  "subSteps": [
                                    "Considere custo unitário, disponibilidade e lead time via distribuidores.",
                                    "Avalie suporte comunitário, exemplos de código e certificações de segurança industrial.",
                                    "Verifique compatibilidade com ferramentas de debug (JTAG, SWD) e prototipagem (shields).",
                                    "Selecione o top 1-2 MCUs e justifique com relatório resumido.",
                                    "Documente decisão em template: requisitos atendidos, trade-offs aceitos."
                                  ],
                                  "verification": "Relatório de seleção final com justificativa, scores finais e alternativas rejeitadas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Sites de distribuidores (DigiKey, Farnell)",
                                    "Fóruns como EEVblog, StackExchange"
                                  ],
                                  "tips": "Verifique obsolescência recente para evitar riscos de supply chain.",
                                  "learningObjective": "Integrar fatores holísticos para decisão otimizada em projetos reais.",
                                  "commonMistakes": [
                                    "Priorizar custo sobre performance",
                                    "Ignorar suporte de longo prazo",
                                    "Não documentar raciocínio"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar Seleção com Protótipo Conceitual",
                                  "subSteps": [
                                    "Monte diagrama esquemático básico no KiCad ou Proteus simulando conexões I/O.",
                                    "Simule consumo e performance em ferramentas como STM32CubeMX ou AVR Simulator.",
                                    "Teste viabilidade com breadboard ou devkit do MCU selecionado.",
                                    "Ajuste seleção se simulações revelarem gaps.",
                                    "Atualize documentação com resultados de validação."
                                  ],
                                  "verification": "Relatório de simulação/protótipo com métricas medidas vs. esperadas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software de simulação (Proteus, LTSpice)",
                                    "Devkit do MCU",
                                    "Multímetro"
                                  ],
                                  "tips": "Comece com simulação antes de hardware para economizar tempo.",
                                  "learningObjective": "Validar escolhas teóricas com testes práticos iniciais.",
                                  "commonMistakes": [
                                    "Pular validação",
                                    "Testar apenas idle mode",
                                    "Ignorar ruído EMI em simulações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de braço robótico industrial: Requisitos incluem 50kHz PWM para 8 motores, 16 entradas analógicas de sensores, <100mA em operação. Comparar STM32F4 (ARM, alto performance) vs. ATmega2560 (AVR, baixo custo). Selecionar STM32 por I/O e timers abundantes, validado em simulação com torque control.",
                              "finalVerifications": [
                                "Tabela de requisitos 100% mapeada e atendida pelo MCU selecionado.",
                                "Matriz de comparação completa com pelo menos 5 candidatos avaliados.",
                                "Relatório de seleção com justificativas quantitativas e qualitativas.",
                                "Simulação ou protótipo confirmando specs de processamento, I/O e energia.",
                                "Documentação incluindo trade-offs e plano de escalabilidade.",
                                "Verificação de conformidade com normas industriais (ex.: EMC, safety)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na definição de requisitos (30%)",
                                "Abrangência e rigor na comparação técnica (25%)",
                                "Integração de fatores não-técnicos como custo e suporte (20%)",
                                "Qualidade da justificativa e documentação (15%)",
                                "Evidências de validação prática (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Design de interfaces e power supply.",
                                "Programação Embarcada: Avaliação de HAL e RTOS compatibility.",
                                "Engenharia Mecânica: Integração com atuadores e sensores.",
                                "Gestão de Projetos: Análise de custo-benefício e risco.",
                                "Sustentabilidade: Otimização de consumo para eficiência energética."
                              ],
                              "realWorldApplication": "Na indústria automotiva, selecionar ARM Cortex-M para ECU de controle de motores, balanceando processamento para algoritmos de PID com baixo consumo para veículos elétricos, reduzindo custos de produção em 15% via escolha otimizada."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Projeto de Circuitos de Interface",
                            "description": "Desenhar esquemáticos para conexão de sensores, atuadores e fontes de alimentação com microcontroladores, utilizando ferramentas como Eagle ou KiCad, conforme LYSHEVSKI (1999).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejamento e Seleção de Componentes",
                                  "subSteps": [
                                    "Identifique os requisitos do projeto: sensores (ex: termistor), atuadores (ex: motor DC), microcontrolador (ex: Arduino ou STM32) e fonte de alimentação.",
                                    "Liste componentes necessários, incluindo resistores, capacitores, diodos e conectores, consultando datasheets.",
                                    "Desenhe um diagrama de blocos preliminar no papel ou software de diagramação.",
                                    "Verifique compatibilidade elétrica (tensões, correntes) conforme Lyshevski (1999).",
                                    "Calcule valores de componentes (ex: resistores pull-up para sensores)."
                                  ],
                                  "verification": "Diagrama de blocos completo com lista de componentes e cálculos validados.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Datasheets de componentes",
                                    "Papel e lápis ou software como Draw.io",
                                    "Livro Lyshevski (1999)"
                                  ],
                                  "tips": "Priorize componentes de baixa potência para protótipos iniciais.",
                                  "learningObjective": "Compreender os requisitos funcionais e elétricos de um circuito de interface.",
                                  "commonMistakes": [
                                    "Ignorar limites de corrente do microcontrolador",
                                    "Esquecer proteção contra polaridade reversa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração do Software e Criação do Projeto",
                                  "subSteps": [
                                    "Instale e configure Eagle ou KiCad (baixe bibliotecas padrão de microcontroladores e sensores).",
                                    "Crie um novo projeto e biblioteca personalizada para componentes específicos.",
                                    "Importe símbolos e footprints dos componentes selecionados.",
                                    "Defina configurações do projeto: unidades (mm/mils), camadas e normas (IPC).",
                                    "Salve o projeto em uma estrutura de pastas organizada (schematics, boards)."
                                  ],
                                  "verification": "Projeto novo criado com bibliotecas carregadas e configurações salvas.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Eagle ou KiCad instalado",
                                    "Bibliotecas oficiais (ex: Arduino KiCad library)"
                                  ],
                                  "tips": "Use KiCad para projetos open-source gratuitos; Eagle para integração com Fusion 360.",
                                  "learningObjective": "Dominar a interface e setup inicial de ferramentas de design de PCB.",
                                  "commonMistakes": [
                                    "Usar footprints incorretos",
                                    "Não atualizar bibliotecas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenho do Esquemático",
                                  "subSteps": [
                                    "Posicione o microcontrolador no centro e conecte pinos de I/O aos sensores e atuadores.",
                                    "Adicione fonte de alimentação com reguladores, capacitores de desacoplamento e filtros.",
                                    "Inclua proteções (diodos flyback para atuadores indutivos, resistores limitadores).",
                                    "Rotule nets (ex: VCC_5V, GND, SENSOR_IN) e adicione valores de componentes.",
                                    "Organize o layout logicamente: power no topo, sinais no meio, saídas na base."
                                  ],
                                  "verification": "Esquemático completo sem erros de conexão (use DRC - Design Rule Check).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Eagle/KiCad",
                                    "Referências de pinouts de microcontroladores"
                                  ],
                                  "tips": "Use hierarquia de símbolos para circuitos complexos.",
                                  "learningObjective": "Criar conexões elétricas precisas e seguras entre componentes.",
                                  "commonMistakes": [
                                    "Conexões cruzadas sem jumpers",
                                    "Falta de desacoplamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação, Simulação e Documentação",
                                  "subSteps": [
                                    "Execute DRC e ERC (Electrical Rule Check) para detectar erros.",
                                    "Simule o circuito (use ngspice no KiCad ou LTSpice integrado).",
                                    "Adicione anotações, BOM (Bill of Materials) e netlist.",
                                    "Atualize o layout para PCB se necessário (forward annotation).",
                                    "Exporte PDF do esquemático e valide com normas de Lyshevski."
                                  ],
                                  "verification": "Relatório DRC/ERC limpo e BOM gerada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de simulação integradas",
                                    "Software PDF viewer"
                                  ],
                                  "tips": "Simule cenários de falha como curto-circuito.",
                                  "learningObjective": "Garantir integridade e documentação profissional do design.",
                                  "commonMistakes": [
                                    "Ignorar warnings do DRC",
                                    "BOM incompleta"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenhar o esquemático de um sistema de controle de temperatura: conectar um sensor NTC ao pino A0 de um Arduino Uno, um relê para aquecedor no pino D3, com fonte 12V regulada para 5V, incluindo diodo de proteção e capacitor de 100uF.",
                              "finalVerifications": [
                                "Esquemático compila sem erros DRC/ERC.",
                                "Todas conexões de sensores/atuadores mapeadas corretamente aos pinos do microcontrolador.",
                                "Proteções elétricas (contra picos, polaridade) presentes.",
                                "BOM completa e viável para compra.",
                                "Simulação confirma funcionamento básico.",
                                "Documentação inclui netlist e PDF anotado."
                              ],
                              "assessmentCriteria": [
                                "Precisão das conexões elétricas (100% sem erros).",
                                "Adequação de componentes à aplicação (compatibilidade tensão/corrente).",
                                "Qualidade da organização e legibilidade do esquemático.",
                                "Presença de proteções e boas práticas conforme Lyshevski.",
                                "Completude da documentação (BOM, nets, anotações).",
                                "Eficiência no uso de recursos (minimalismo sem comprometer funcionalidade)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Analógica: Dimensionamento de filtros e reguladores.",
                                "Programação de Microcontroladores: Mapeamento de pinos para firmware.",
                                "Mecânica: Integração com atuadores em sistemas robóticos.",
                                "Matemática: Cálculos de resistores e capacitores (leis de Kirchhoff).",
                                "Gestão de Projetos: Planejamento de BOM e prazos."
                              ],
                              "realWorldApplication": "Desenvolvimento de interfaces em robôs industriais para conectar sensores de proximidade a CLPs, ou em wearables para monitoramento biomédico com microcontroladores Bluetooth."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Simulação de Hardware",
                            "description": "Simular circuitos protótipos com software como Proteus para validar o design de hardware antes da fabricação em projetos microcontrolados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalação e Configuração Inicial do Proteus",
                                  "subSteps": [
                                    "Baixe e instale a versão mais recente do Proteus ISIS do site oficial da Labcenter Electronics.",
                                    "Execute o instalador e configure as bibliotecas padrão para microcontroladores (ex: PIC, AVR, Arduino).",
                                    "Abra o Proteus, crie um novo projeto e familiarize-se com a interface: biblioteca de componentes, área de design e simulador.",
                                    "Configure as unidades de medida e opções de simulação básica nas preferências.",
                                    "Teste a instalação simulando um circuito simples como um resistor e LED sem código."
                                  ],
                                  "verification": "Projeto de teste abre corretamente e simulação básica roda sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Computador com Windows",
                                    "Download do Proteus (versão trial ou licensed)",
                                    "Bibliotecas de microcontroladores"
                                  ],
                                  "tips": "Use a versão trial para testes iniciais; ative atualizações automáticas para bibliotecas.",
                                  "learningObjective": "Configurar ambiente de simulação pronto para uso em projetos microcontrolados.",
                                  "commonMistakes": [
                                    "Ignorar instalação de bibliotecas de microcontroladores",
                                    "Não configurar unidades corretamente levando a erros de escala"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelagem do Circuito Protótipo",
                                  "subSteps": [
                                    "Selecione e arraste componentes da biblioteca: microcontrolador (ex: Arduino Uno), resistores, capacitores, LEDs e fontes de alimentação.",
                                    "Conecte os componentes usando o modo de fiação automática, verificando pinagens corretas do datasheet do microcontrolador.",
                                    "Adicione medidores virtuais (osciloscópio, multímetro) para monitoramento de sinais.",
                                    "Defina valores nominais para componentes e configure propriedades (ex: frequência do clock do microcontrolador).",
                                    "Salve o esquema e realize uma verificação de erros elétricos (ERC)."
                                  ],
                                  "verification": "Circuito modelado sem erros de conexão reportados pelo ERC e visível no layout.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Proteus aberto",
                                    "Datasheet do microcontrolador alvo",
                                    "Esquema preliminar do projeto"
                                  ],
                                  "tips": "Use bus wires para conexões múltiplas; nomeie nets para facilitar debugging.",
                                  "learningObjective": "Criar um esquema elétrico funcional e realista para prototipagem virtual.",
                                  "commonMistakes": [
                                    "Pinagem incorreta do microcontrolador",
                                    "Esquecer alimentação (VCC/GND)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integração do Código e Configuração do Microcontrolador",
                                  "subSteps": [
                                    "Compile o código do microcontrolador em um IDE (ex: Arduino IDE ou MPLAB) e gere o arquivo HEX.",
                                    "No Proteus, duplo-clique no microcontrolador e carregue o arquivo HEX gerado.",
                                    "Configure parâmetros do microcontrolador: clock speed, fuses e memória.",
                                    "Edite propriedades para simular periféricos (ex: PWM, ADC, timers).",
                                    "Teste play/pause para verificar se o microcontrolador inicializa sem crashes."
                                  ],
                                  "verification": "Arquivo HEX carrega e microcontrolador executa sem erros de firmware no simulador.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código fonte compilado em HEX",
                                    "IDE de programação compatível"
                                  ],
                                  "tips": "Verifique compatibilidade de bibliotecas HEX com versão do Proteus; use debug mode para step-by-step.",
                                  "learningObjective": "Integrar firmware ao hardware simulado para testes funcionais.",
                                  "commonMistakes": [
                                    "HEX incompatível com modelo de microcontrolador",
                                    "Clock speed errada causando timing issues"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Execução de Simulações, Debugging e Validação",
                                  "subSteps": [
                                    "Inicie a simulação em tempo real e monitore sinais com osciloscópio/multímetro.",
                                    "Identifique anomalias (ex: oscilações, quedas de tensão) e ajuste componentes.",
                                    "Execute cenários de teste: normal, edge cases (ex: falha de alimentação, overload).",
                                    "Gere relatórios de simulação (gráficos, logs de eventos).",
                                    "Compare resultados com especificações do design e itere se necessário."
                                  ],
                                  "verification": "Simulação passa todos os testes sem falhas críticas; relatório gerado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Circuito completo simulado",
                                    "Planilha de testes planejados"
                                  ],
                                  "tips": "Acelere simulação para testes longos; use probes para logging automático.",
                                  "learningObjective": "Validar design através de simulações realistas e debugar problemas.",
                                  "commonMistakes": [
                                    "Não testar edge cases",
                                    "Ignorar ruído/parasitas em simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Geração de Relatório e Preparação para Fabricação",
                                  "subSteps": [
                                    "Exporte esquemas, layouts e waveforms para PDF/PNG.",
                                    "Documente achados: problemas resolvidos, métricas de performance.",
                                    "Crie lista de materiais (BOM) a partir do Proteus.",
                                    "Simule variações de tolerância de componentes para robustez.",
                                    "Arquive projeto e prepare handover para prototipagem física."
                                  ],
                                  "verification": "Relatório completo gerado e BOM exportado sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de export do Proteus",
                                    "Template de relatório"
                                  ],
                                  "tips": "Use Gerber viewer se disponível para preview de PCB; inclua screenshots anotados.",
                                  "learningObjective": "Documentar simulação para transição suave ao hardware real.",
                                  "commonMistakes": [
                                    "Relatório incompleto sem métricas quantitativas",
                                    "Esquecer BOM levando a compras erradas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um sistema de controle de motor DC com Arduino Uno: inclua driver L298N, sensor de rotação, LED indicador e código PWM. Teste aceleração, freada e detecção de falha, validando tensão/corrente antes de fabricar.",
                              "finalVerifications": [
                                "Simulação roda sem crashes por 10 minutos em tempo real.",
                                "Todos os sinais atendem especificações (ex: tensão < 5V, frequência correta).",
                                "Relatório inclui waveforms, BOM e lista de testes passados.",
                                "Edge cases testados: overload, falha de sensor.",
                                "Projeto exportado e pronto para PCB layout.",
                                "Comparação com datasheet: 95% de conformidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão do esquema: sem erros ERC (100%).",
                                "Qualidade da simulação: todos testes passam (pass/fail).",
                                "Eficiência de debugging: problemas resolvidos em <3 iterações.",
                                "Relatório completo: inclui métricas quantitativas e qualitativas.",
                                "Tempo total: dentro de 6-7 horas estimadas.",
                                "Robustez: simulação tolera ±10% variação de componentes."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Analógica e Digital: modelagem de circuitos mistos.",
                                "Programação Embarcada: integração de firmware HEX.",
                                "Gestão de Projetos: documentação e validação de protótipos.",
                                "Matemática Aplicada: análise de sinais e Fourier via osciloscópio.",
                                "Física: simulação de leis de Kirchhoff e dinâmicas de circuitos."
                              ],
                              "realWorldApplication": "Em indústrias como automotiva e robótica, simulações em Proteus reduzem custos de prototipagem em 70%, permitindo validar designs de controladores (ex: ECU de veículos) antes da produção em massa, evitando recalls caros."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Programação e Desenvolvimento de Software",
                        "description": "Técnicas de programação embarcada para microcontroladores em sistemas mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Estruturação de Código Embarcado",
                            "description": "Implementar estruturas modulares em linguagens como C/Arduino IDE, com loops principais, interrupções e tratamento de erros para controle mecatrônico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração da Estrutura Básica do Código",
                                  "subSteps": [
                                    "Instalar e configurar o Arduino IDE.",
                                    "Criar um novo sketch e entender as funções setup() e loop().",
                                    "Definir pinos de entrada/saída e inicializar variáveis globais.",
                                    "Implementar um loop principal simples com delay para controle básico.",
                                    "Compilar e fazer upload para o microcontrolador."
                                  ],
                                  "verification": "Código compila sem erros e executa um LED piscando no loop principal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Arduino IDE",
                                    "Placa Arduino Uno",
                                    "Cabo USB",
                                    "LED e resistor"
                                  ],
                                  "tips": [
                                    "Use comentários para documentar cada seção.",
                                    "Sempre inicialize variáveis no setup()."
                                  ],
                                  "learningObjective": "Compreender e implementar a estrutura fundamental de um programa embarcado.",
                                  "commonMistakes": [
                                    "Esquecer de declarar pinMode()",
                                    "Usar delay() excessivo no loop()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modularização com Funções e Bibliotecas",
                                  "subSteps": [
                                    "Identificar blocos reutilizáveis no código principal.",
                                    "Criar funções personalizadas para leitura de sensores e controle de atuadores.",
                                    "Incluir bibliotecas como Wire.h para I2C ou Servo.h para servos.",
                                    "Passar parâmetros para funções e retornar valores quando necessário.",
                                    "Refatorar o loop() para chamar essas funções modularmente."
                                  ],
                                  "verification": "Código modular compila e funções são chamadas corretamente sem duplicação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Arduino IDE",
                                    "Sensores como DHT11",
                                    "Servomotor"
                                  ],
                                  "tips": [
                                    "Mantenha funções curtas e com um propósito único.",
                                    "Use prototipagem para testar funções isoladamente."
                                  ],
                                  "learningObjective": "Desenvolver código modular para facilitar manutenção e escalabilidade.",
                                  "commonMistakes": [
                                    "Funções globais sem escopo definido",
                                    "Passagem incorreta de ponteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação de Interrupções",
                                  "subSteps": [
                                    "Configurar pinos interruptíveis (ex: pin 2 no Arduino Uno).",
                                    "Definir ISR (Interrupt Service Routine) para eventos como borda de subida.",
                                    "Usar variáveis voláteis para flags compartilhadas entre ISR e loop().",
                                    "Desabilitar interrupções brevemente se necessário para seções críticas.",
                                    "Integrar ISR com o loop principal para ações assíncronas."
                                  ],
                                  "verification": "Interrupção dispara corretamente ao acionar sensor, alterando flag volátil.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Arduino Uno",
                                    "Botão push ou sensor Hall",
                                    "Multímetro para debug"
                                  ],
                                  "tips": [
                                    "Mantenha ISR o mais curta possível.",
                                    "Evite delay() ou Serial.print() dentro de ISR."
                                  ],
                                  "learningObjective": "Gerenciar eventos assíncronos de forma eficiente em sistemas embarcados.",
                                  "commonMistakes": [
                                    "Não declarar variáveis como volatile",
                                    "ISR longa bloqueando o sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratamento de Erros e Estados de Falha",
                                  "subSteps": [
                                    "Implementar máquina de estados finita (FSM) no loop principal.",
                                    "Adicionar verificações de sensores (ex: timeout em leituras).",
                                    "Criar funções de recuperação de erros e logs via Serial.",
                                    "Usar watchdog timer para reset automático em falhas.",
                                    "Testar cenários de falha simulados."
                                  ],
                                  "verification": "Sistema detecta e recupera de erro simulado, como sensor desconectado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Arduino IDE",
                                    "Sensores redundantes",
                                    "Display LCD para status"
                                  ],
                                  "tips": [
                                    "Defina estados claros: NORMAL, ERROR, RECOVERY.",
                                    "Log erros com timestamps."
                                  ],
                                  "learningObjective": "Tornar o código robusto contra falhas comuns em aplicações mecatrônicas.",
                                  "commonMistakes": [
                                    "Ignorar retornos de funções",
                                    "Loop infinito sem escape"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integração, Testes e Otimização",
                                  "subSteps": [
                                    "Integrar todos os módulos em um projeto completo.",
                                    "Executar testes unitários para cada função e integração.",
                                    "Otimizar uso de memória com sizeof() e free().",
                                    "Perfilhar tempo de execução com micros().",
                                    "Documentar o código com diagrama de fluxo."
                                  ],
                                  "verification": "Projeto completo roda sem crashes por 30 minutos em cenários variados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Osciloscópio ou logic analyzer opcional",
                                    "Bateria para testes reais"
                                  ],
                                  "tips": [
                                    "Use #ifdef para configurações de debug.",
                                    "Versão controle com Git."
                                  ],
                                  "learningObjective": "Validar e refinar a estrutura para produção mecatrônica.",
                                  "commonMistakes": [
                                    "Sobrecarga de memória por vazamentos",
                                    "Testes insuficientes em bordas"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver um sistema de controle de braço robótico: setup() inicializa servos e encoders; funções modulares leem encoders e controlam PWM; ISR detecta fim de curso; FSM gerencia estados (idle, moving, error) com recuperação automática se encoder falhar.",
                              "finalVerifications": [
                                "Código compila e roda sem warnings em Arduino IDE.",
                                "Loop principal executa <20ms por ciclo com interrupções.",
                                "Sistema recupera de falha de sensor em <5s.",
                                "Memória livre >50% após upload.",
                                "Logs de erro são gerados corretamente via Serial.",
                                "Módulos são independentes e reutilizáveis."
                              ],
                              "assessmentCriteria": [
                                "Modularidade: >80% do código em funções <50 linhas.",
                                "Robustez: Sobrevive a 10 falhas simuladas sem crash.",
                                "Eficiência: Tempo de resposta <100ms para interrupções.",
                                "Documentação: Comentários em >90% das funções.",
                                "Testabilidade: Cada função tem verificação isolada.",
                                "Escalabilidade: Fácil adicionar novo sensor/atuador."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Configuração de hardware para interrupções.",
                                "Mecânica: Controle de atuadores em sistemas mecatrônicos.",
                                "Matemática: Cálculos de PWM e filtros em loops.",
                                "Gestão de Projetos: Versionamento e testes iterativos."
                              ],
                              "realWorldApplication": "Em automação industrial, como linhas de montagem onde microcontroladores gerenciam esteiras com detecção de falhas via sensores, interrupções para paradas de emergência e FSM para operação contínua 24/7."
                            },
                            "estimatedTime": "6 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Integração com Periféricos",
                            "description": "Programar comunicação via protocolos como I2C, SPI e UART para integração de sensores e atuadores em microcontroladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos Protocolos I2C, SPI e UART",
                                  "subSteps": [
                                    "Estude as diferenças entre I2C (bidirecional, multi-master), SPI (síncrono, full-duplex) e UART (assíncrono, serial simples).",
                                    "Analise diagramas de pinagem e sinais (SCL/SDA para I2C, MOSI/MISO/SCK/SS para SPI, TX/RX para UART).",
                                    "Revise configurações de baud rate, endereços de escravo e modos de operação.",
                                    "Compare velocidades e distâncias típicas de cada protocolo.",
                                    "Pratique identificação de periféricos comuns compatíveis com cada um."
                                  ],
                                  "verification": "Resuma em um diagrama comparativo os protocolos e liste 3 periféricos para cada.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação Arduino (datasheets), diagramas online de protocolos.",
                                  "tips": "Use ferramentas como o Osciloscópio lógico virtual para visualizar sinais.",
                                  "learningObjective": "Diferenciar e explicar princípios de operação dos protocolos de comunicação serial.",
                                  "commonMistakes": "Confundir pinagens entre protocolos ou ignorar pull-up resistors no I2C."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Programar Comunicação UART",
                                  "subSteps": [
                                    "Conecte um módulo UART (ex: HC-05 Bluetooth ou sensor serial) aos pinos TX/RX do microcontrolador.",
                                    "Configure baud rate no código (ex: Serial.begin(9600)) e envie/receba dados simples.",
                                    "Implemente leitura de dados de um sensor UART e exibição no monitor serial.",
                                    "Adicione tratamento de erros para buffers overflow.",
                                    "Teste com diferentes baud rates para verificar estabilidade."
                                  ],
                                  "verification": "Envie 'Hello World' via UART e receba confirmação no monitor serial sem erros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Arduino Uno, módulo HC-05 ou sensor serial (ex: GPS), fios jumper.",
                                  "tips": "Sempre desconecte TX/RX durante upload do código para evitar conflitos.",
                                  "learningObjective": "Implementar comunicação assíncrona UART de forma confiável.",
                                  "commonMistakes": "Usar baud rates incompatíveis ou inverter TX/RX."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Protocolo I2C para Sensores",
                                  "subSteps": [
                                    "Instale biblioteca Wire.h e conecte sensor I2C (ex: BMP180) aos pinos SDA/SCL com pull-ups.",
                                    "Escaneie endereços I2C usando scanner code para identificar o dispositivo.",
                                    "Escreva código para inicializar (Wire.begin()) e ler dados do sensor.",
                                    "Implemente escrita de comandos no registrador do sensor.",
                                    "Integre múltiplos sensores no mesmo bus I2C."
                                  ],
                                  "verification": "Leia temperatura/pressão de um sensor I2C e exiba valores corretos no Serial.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Arduino, sensor BMP180 ou MPU6050, resistores 4.7kΩ para pull-up.",
                                  "tips": "Verifique endereço I2C com scanner antes de codificar.",
                                  "learningObjective": "Dominar bus I2C multi-dispositivo com leitura/escrita.",
                                  "commonMistakes": "Esquecer pull-ups ou usar endereço incorreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Programar SPI para Atuadores",
                                  "subSteps": [
                                    "Conecte display SPI (ex: Nokia 5110) ou SD card aos pinos MOSI/MISO/SCK/CS.",
                                    "Configure SPI no Arduino (SPI.begin(), pinMode CS).",
                                    "Escreva funções para transferência de dados e controle de chip select.",
                                    "Teste envio de comandos para inicializar e operar o atuador.",
                                    "Otimize para alta velocidade com modo SPI rápido."
                                  ],
                                  "verification": "Exiba texto ou imagem simples no display SPI sem glitches.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Arduino, display Nokia 5110 ou módulo SD, fios.",
                                  "tips": "Mantenha CS low apenas durante transação para evitar conflitos.",
                                  "learningObjective": "Controlar dispositivos SPI síncronos com precisão.",
                                  "commonMistakes": "Não gerenciar CS corretamente ou wiring incorreto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Múltiplos Periféricos em um Projeto",
                                  "subSteps": [
                                    "Planeje um sistema com sensor I2C, UART e atuador SPI.",
                                    "Implemente loop principal com priorização de comunicação.",
                                    "Adicione interrupções ou timers para comunicação não-bloqueante.",
                                    "Debugue conflitos de pinos e alimentação.",
                                    "Otimize código para eficiência e robustez."
                                  ],
                                  "verification": "Sistema integrado lê sensor I2C, envia via UART e controla SPI simultaneamente.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Todos os materiais anteriores + protoboard.",
                                  "tips": "Use Serial para debug em tempo real.",
                                  "learningObjective": "Combinar protocolos em aplicações mecatrônicas reais.",
                                  "commonMistakes": "Bloqueio em loops de leitura infinita."
                                }
                              ],
                              "practicalExample": "Construa um monitor ambiental: sensor de temperatura/humidade DHT11 via UART envia dados para app via HC-05; sensor BMP280 via I2C lê pressão; display SPI mostra alertas se valores excederem thresholds.",
                              "finalVerifications": [
                                "Todos os periféricos respondem corretamente sem perda de dados.",
                                "Código compila e roda sem erros em diferentes execuções.",
                                "Medições dos sensores coincidem com valores reais (±5%).",
                                "Sistema mantém estabilidade por 30 minutos contínuos.",
                                "Debug logs mostram tráfego de dados nos protocolos.",
                                "Mudanças em um periférico não afetam os outros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de pinos e protocolos (30%).",
                                "Robustez do código com tratamento de erros (25%).",
                                "Eficiência temporal e uso de recursos (20%).",
                                "Documentação de código e comentários claros (15%).",
                                "Integração seamless de múltiplos periféricos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Análise de sinais e circuitos de interface.",
                                "Programação: Estruturas de bibliotecas e programação embarcada.",
                                "Física: Princípios de sensores e transdutores.",
                                "Automação Industrial: Integração em CLPs e IoT."
                              ],
                              "realWorldApplication": "Em robótica industrial, integra sensores I2C/SPI para monitoramento e atuadores UART para controle remoto em linhas de produção automatizadas, como braços robóticos que ajustam posição baseada em feedback sensorial."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Debugging de Software",
                            "description": "Utilizar debuggers e serial monitors para identificar e corrigir falhas em códigos de microcontroladores durante o desenvolvimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do Ambiente de Debugging",
                                  "subSteps": [
                                    "Instalar e configurar a IDE com suporte a debuggers (ex: PlatformIO ou Arduino IDE com extensões)",
                                    "Conectar o microcontrolador ao computador via USB e verificar reconhecimento do hardware",
                                    "Configurar o serial monitor com baud rate correto (ex: 9600)",
                                    "Habilitar modo de debug no firmware (ex: ativar JTAG ou SWD se aplicável)",
                                    "Realizar teste básico de comunicação enviando uma mensagem 'Hello World' via serial"
                                  ],
                                  "verification": "Serial monitor exibe mensagens de teste sem erros de conexão",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Computador com IDE instalada",
                                    "Microcontrolador (ex: Arduino Uno ou ESP32)",
                                    "Cabo USB",
                                    "Drivers USB atualizados"
                                  ],
                                  "tips": "Sempre verifique conflitos de portas COM no Gerenciador de Dispositivos",
                                  "learningObjective": "Configurar ferramentas essenciais para iniciar o processo de debugging",
                                  "commonMistakes": [
                                    "Selecionar porta serial incorreta",
                                    "Baud rate incompatível",
                                    "Firmware sem suporte a debug"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reprodução e Documentação do Erro",
                                  "subSteps": [
                                    "Executar o código no microcontrolador e observar o comportamento falho",
                                    "Registrar sintomas: o que acontece vs. o esperado (ex: LED não acende)",
                                    "Identificar condições de reprodução (ex: após reset, em alta temperatura)",
                                    "Capturar screenshots ou logs iniciais do serial monitor",
                                    "Criar um relatório simples: descrição, ambiente, passos para reproduzir"
                                  ],
                                  "verification": "Relatório de erro documentado com passos reprodutíveis",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE aberta",
                                    "Microcontrolador conectado",
                                    "Bloco de notas ou ferramenta de issue tracking"
                                  ],
                                  "tips": "Use prints() no código para logs iniciais se serial não estiver configurado",
                                  "learningObjective": "Reproduzir erros de forma consistente para análise posterior",
                                  "commonMistakes": [
                                    "Assumir causa sem reproduzir",
                                    "Ignorar variáveis ambientais",
                                    "Relatório vago"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Análise com Serial Monitor e Logs",
                                  "subSteps": [
                                    "Inserir printfs() ou Serial.print() em pontos críticos do código",
                                    "Executar e monitorar logs em tempo real para rastrear fluxo",
                                    "Identificar discrepâncias nos valores de variáveis",
                                    "Analisar padrões de falha (ex: loop infinito detectado por ausência de logs)",
                                    "Remover ou comentar prints excessivos para evitar overhead"
                                  ],
                                  "verification": "Logs revelam ponto exato de falha ou valor incorreto",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Serial Monitor na IDE",
                                    "Código fonte editável"
                                  ],
                                  "tips": "Use timestamps nos prints para sequenciar eventos",
                                  "learningObjective": "Usar logs para diagnosticar problemas lógicos e de runtime",
                                  "commonMistakes": [
                                    "Prints em loops rápidos sobrecarregando o buffer",
                                    "Ignorar overflows de variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Uso Avançado de Debugger para Inspeção",
                                  "subSteps": [
                                    "Configurar breakpoints em linhas suspeitas",
                                    "Executar em modo debug e pausar na falha",
                                    "Inspecionar variáveis, pilha de chamadas e registradores",
                                    "Passo a passo (step over/into) para rastrear execução",
                                    "Modificar variáveis em tempo real para testes rápidos"
                                  ],
                                  "verification": "Debugger permite pausar, inspecionar e avançar sem crashes",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Debugger integrado (ex: GDB com OpenOCD)",
                                    "Probe de debug (ex: ST-Link)"
                                  ],
                                  "tips": "Step into funções para debugar recursões",
                                  "learningObjective": "Dominar ferramentas de debugger para análise profunda",
                                  "commonMistakes": [
                                    "Breakpoints em código otimizado que é pulado",
                                    "Não checar registradores em falhas de hardware"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Correção, Testes e Validação Final",
                                  "subSteps": [
                                    "Aplicar correções baseadas na análise (ex: corrigir lógica if)",
                                    "Recompilar, flashar e testar com serial/debugger",
                                    "Executar testes unitários e de regressão",
                                    "Verificar performance e consumo de memória",
                                    "Documentar a correção e lições aprendidas"
                                  ],
                                  "verification": "Sistema funciona conforme esperado em todos os cenários testados",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código corrigido",
                                    "Suite de testes simples"
                                  ],
                                  "tips": "Sempre teste edge cases após correção",
                                  "learningObjective": "Validar correções de forma robusta e documentar processo",
                                  "commonMistakes": [
                                    "Não testar regressões",
                                    "Otimizar prematuramente",
                                    "Esquecer documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de sensor de temperatura com ESP32, o display não atualiza valores. Serial monitor mostra que a leitura do sensor falha (NaN). Debugger revela ponteiro nulo na função de leitura. Correção: Inicializar ponteiro corretamente e adicionar checagem de erro. Após testes, display atualiza em tempo real.",
                              "finalVerifications": [
                                "Código compila e executa sem crashes ou warnings",
                                "Todas funcionalidades esperadas operam corretamente",
                                "Logs e debugger confirmam fluxo lógico intacto",
                                "Testes de estresse (ex: múltiplos resets) passam",
                                "Consumo de memória e performance dentro dos limites",
                                "Documentação de debugging atualizada no repositório"
                              ],
                              "assessmentCriteria": [
                                "Eficiência: Tempo total de debugging < 2 horas",
                                "Precisão: Identificação correta da causa raiz na primeira análise profunda",
                                "Cobertura: Todos os edge cases testados e documentados",
                                "Documentação: Relatório claro com antes/depois",
                                "Otimização: Código corrigido sem introduzir novas vulnerabilidades",
                                "Autonomia: Uso correto de ferramentas sem consulta excessiva"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de controle e manipulação de variáveis",
                                "Eletrônica: Protocolos de comunicação serial e interfaces hardware",
                                "Matemática: Lógica booleana e algoritmos de detecção de falhas",
                                "Gestão de Projetos: Metodologias ágeis para iterações de correção"
                              ],
                              "realWorldApplication": "Na manutenção de sistemas embarcados industriais, como CLPs em linhas de produção, onde falhas de software causam paradas; debugging rápido minimiza downtime e custos operacionais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.4",
                        "name": "Testes, Integração e Execução",
                        "description": "Validação final e implantação de projetos microcontrolados em ambientes mecatrônicos reais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.4.1",
                            "name": "Testes Unitários e Integrados",
                            "description": "Realizar testes unitários em módulos de hardware e software, seguidos de testes integrados para verificar o sistema completo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejamento de Testes Unitários",
                                  "subSteps": [
                                    "Identificar todos os módulos individuais do sistema (ex: sensor, atuador, função de software)",
                                    "Definir casos de teste para entradas normais, borda e excepcionais",
                                    "Especificar critérios de sucesso e falha para cada módulo",
                                    "Documentar o plano de testes em uma tabela ou ferramenta como Excel",
                                    "Priorizar módulos críticos baseados no impacto no sistema"
                                  ],
                                  "verification": "Plano de testes documentado com pelo menos 5 casos por módulo principal e aprovado por revisão",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Computador, planilha (Excel/Google Sheets), documentação do projeto microcontrolado",
                                  "tips": "Use o formato 'Dado-Quando-Então' para casos de teste para clareza",
                                  "learningObjective": "Desenvolver habilidade em mapear requisitos para casos de teste acionáveis",
                                  "commonMistakes": "Ignorar casos de borda, como valores extremos de sensores, levando a falhas inesperadas"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolvimento e Execução de Testes Unitários",
                                  "subSteps": [
                                    "Implementar mocks ou simuladores para dependências externas",
                                    "Codificar testes unitários usando frameworks como Unity para C ou ArduinoUnit",
                                    "Executar testes isoladamente em cada módulo (hardware com osciloscópio, software em IDE)",
                                    "Registrar resultados com logs de pass/fail e métricas de cobertura",
                                    "Corrigir falhas imediatas e retestar"
                                  ],
                                  "verification": "100% dos testes unitários passam com cobertura mínima de 80% do código",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Microcontrolador (ex: Arduino/ESP32), IDE (Arduino IDE), multímetro/osciloscópio, framework de testes",
                                  "tips": "Teste hardware com sinais simulados antes de conectar componentes reais",
                                  "learningObjective": "Executar testes isolados para validar funcionalidade modular",
                                  "commonMistakes": "Não isolar dependências, causando falsos positivos/negativos"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Execução de Testes Integrados",
                                  "subSteps": [
                                    "Montar o sistema completo conectando módulos testados unitariamente",
                                    "Definir sequência de testes integrados baseados no fluxo do sistema",
                                    "Executar testes end-to-end monitorando interfaces (I2C/SPI/Serial)",
                                    "Medir desempenho integrado (latência, consumo de energia)",
                                    "Identificar falhas de integração como problemas de comunicação"
                                  ],
                                  "verification": "Sistema integrado opera sem crashes e atende especificações principais",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Sistema montado, fonte de alimentação estável, analisador lógico, software de monitoramento serial",
                                  "tips": "Use debug serial para logs em tempo real durante integração",
                                  "learningObjective": "Verificar interações entre módulos no contexto do sistema completo",
                                  "commonMistakes": "Pular testes unitários antes da integração, ampliando problemas"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise de Resultados e Iteração",
                                  "subSteps": [
                                    "Compilar relatório com métricas (taxa de falha, cobertura)",
                                    "Analisar falhas raiz usando ferramentas de debug",
                                    "Refatorar código/hardware e reexecutar testes afetados",
                                    "Atualizar plano de testes com lições aprendidas",
                                    "Arquivar resultados para rastreabilidade futura"
                                  ],
                                  "verification": "Relatório final com todas falhas resolvidas e lições documentadas",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Ferramentas de análise (JIRA/Trello para tracking), backup do código",
                                  "tips": "Priorize falhas por severidade (crítica, alta, baixa)",
                                  "learningObjective": "Melhorar processos de teste através de análise iterativa",
                                  "commonMistakes": "Não documentar falhas, repetindo erros em iterações futuras"
                                }
                              ],
                              "practicalExample": "Em um projeto de controle de motor com Arduino: teste unitário do sensor de velocidade (girar motor manualmente e verificar leituras), teste do driver de motor (comandos PWM isolados), depois teste integrado (loop de feedback PID sem sobrecarga).",
                              "finalVerifications": [
                                "Todos testes unitários passam com cobertura >85%",
                                "Testes integrados executam sem falhas críticas por 10 ciclos",
                                "Medições de hardware (tensão/corrente) dentro de tolerâncias",
                                "Logs de integração mostram comunicação estável entre módulos",
                                "Relatório de testes assinado e arquivado",
                                "Sistema pronto para deployment em ambiente de staging"
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude dos casos de teste (cobertura de cenários)",
                                "Eficiência na execução (tempo vs. qualidade)",
                                "Qualidade da documentação e relatórios",
                                "Habilidade em debugar falhas de integração",
                                "Aplicação de boas práticas (mocks, automação)",
                                "Melhoria iterativa baseada em resultados"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Frameworks de TDD/BDD como Unity",
                                "Eletrônica: Uso de osciloscópio e analisador lógico",
                                "Matemática: Lógica booleana e análise estatística de falhas",
                                "Gestão de Projetos: Rastreabilidade e relatórios ágeis"
                              ],
                              "realWorldApplication": "Na indústria automotiva, testes unitários validam sensores de ECU individualmente, enquanto integrados simulam condições de estrada para garantir segurança em veículos autônomos; em fábricas, asseguram robôs industriais operem sem downtime."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.4.2",
                            "name": "Otimização e Calibração",
                            "description": "Ajustar parâmetros do sistema para performance ótima, incluindo calibração de sensores e tuning de loops de controle PID em microcontroladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise Inicial do Sistema e Coleta de Dados Baseline",
                                  "subSteps": [
                                    "Identifique todos os componentes do sistema: sensores, atuadores e microcontrolador.",
                                    "Meça o desempenho atual sem otimizações usando ferramentas de monitoramento (osciloscópio, multímetro, software de log).",
                                    "Registre métricas baseline: tempo de resposta, overshoot, erro steady-state e consumo de energia.",
                                    "Analise o diagrama de blocos do sistema de controle e identifique loops PID necessários.",
                                    "Documente condições ambientais e variações que afetam o desempenho."
                                  ],
                                  "verification": "Relatório baseline gerado com gráficos de desempenho e métricas quantificadas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Multímetro",
                                    "Osciloscópio",
                                    "Software de log do microcontrolador (ex: Serial Plotter no Arduino IDE)",
                                    "Planilha para registro de dados"
                                  ],
                                  "tips": "Sempre compare com especificações do fabricante para definir benchmarks realistas.",
                                  "learningObjective": "Compreender o estado atual do sistema para estabelecer metas de otimização.",
                                  "commonMistakes": [
                                    "Ignorar variações ambientais",
                                    "Não registrar dados suficientes para análise estatística"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calibração de Sensores",
                                  "subSteps": [
                                    "Conecte o sensor ao microcontrolador e leia valores raw em condições conhecidas (ex: temperatura ambiente controlada).",
                                    "Aplique curva de calibração: compare leituras raw com valores reais usando equação linear (y = mx + b).",
                                    "Implemente código de calibração no firmware, incluindo offset e ganho ajustáveis.",
                                    "Teste em múltiplos pontos (mínimo 5) e valide com instrumento de referência.",
                                    "Salve coeficientes de calibração em EEPROM para persistência."
                                  ],
                                  "verification": "Erro de leitura do sensor < 2% em testes de validação com referência.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Sensores (ex: DHT22, MPU6050)",
                                    "Microcontrolador (ex: Arduino/ESP32)",
                                    "Instrumentos de referência (termômetro calibrado, etc.)",
                                    "EEPROM library"
                                  ],
                                  "tips": "Use interpolação linear para não-linearidades leves; teste em faixa operacional completa.",
                                  "learningObjective": "Dominar técnicas de calibração para precisão de sensores em sistemas embarcados.",
                                  "commonMistakes": [
                                    "Calibração em apenas um ponto",
                                    "Não considerar ruído ou histerese"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Tuning de Loops de Controle PID",
                                  "subSteps": [
                                    "Implemente biblioteca PID no código (ex: PID library do Arduino).",
                                    "Inicie com método Ziegler-Nichols: aplique step response para encontrar Ku e Tu.",
                                    "Calcule ganhos iniciais (Kp, Ki, Kd) e implemente no loop de controle.",
                                    "Teste em simulação (ex: MATLAB/Simulink) antes de hardware real.",
                                    "Ajuste iterativamente: reduza overshoot com Kd, elimine steady-state error com Ki."
                                  ],
                                  "verification": "Resposta do sistema com overshoot < 10%, settling time < 2s e erro steady-state < 1%.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Biblioteca PID",
                                    "Software de simulação (Tinkercad ou MATLAB)",
                                    "Display para monitoramento em tempo real"
                                  ],
                                  "tips": "Monitore integral windup e adicione anti-windup se necessário.",
                                  "learningObjective": "Aplicar métodos sistemáticos de tuning PID para estabilidade e performance.",
                                  "commonMistakes": [
                                    "Ajustes manuais sem método",
                                    "Ignorar limites de atuador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testes Iterativos, Otimização e Validação Final",
                                  "subSteps": [
                                    "Execute testes em cenários reais: carga variável, distúrbios e condições extremas.",
                                    "Meça KPIs (tempo de resposta, eficiência energética) e compare com baseline.",
                                    "Otimize código: reduza delays, use interrupções para sampling preciso.",
                                    "Analise dados com FFT para identificar oscilações residuais.",
                                    "Documente parâmetros finais e crie rotina de auto-calibração se aplicável."
                                  ],
                                  "verification": "Sistema atende todos os KPIs otimizados em testes repetidos (n=10).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Equipamentos de teste (cargas variáveis)",
                                    "Software de análise (Excel/Python para FFT)",
                                    "Backup do firmware original"
                                  ],
                                  "tips": "Automatize testes com scripts para reproducibilidade.",
                                  "learningObjective": "Integrar calibração e tuning em um ciclo de otimização iterativa.",
                                  "commonMistakes": [
                                    "Testes insuficientes em edge cases",
                                    "Não otimizar código após tuning"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um braço robótico com microcontrolador ESP32, calibre o sensor de posição (potenciômetro) para precisão de 0.5°, tune PID para controle de servo-motor reduzindo overshoot de 25% para 5%, resultando em movimentos suaves e precisos em linha de montagem simulada.",
                              "finalVerifications": [
                                "Erro de sensor calibrado < 1% em toda faixa operacional.",
                                "Loop PID com overshoot < 10%, settling time < 2s e zero steady-state error.",
                                "Eficiência energética melhorada em pelo menos 15% vs baseline.",
                                "Sistema estável sob distúrbios (ex: variação de 20% na carga).",
                                "Código otimizado roda em < 80% da CPU disponível.",
                                "Parâmetros persistentes após reset."
                              ],
                              "assessmentCriteria": [
                                "Precisão das medições e calibração (30%)",
                                "Qualidade do tuning PID e estabilidade (30%)",
                                "Eficiência e otimização geral (20%)",
                                "Documentação e análise de dados (10%)",
                                "Robustez em testes reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais e análise de sistemas lineares.",
                                "Física: Dinâmica de sistemas de controle e termodinâmica para sensores.",
                                "Programação: Algoritmos de controle embarcado e otimização de código.",
                                "Eletrônica: Interfaces analógicas e filtragem de sinal."
                              ],
                              "realWorldApplication": "Otimização de sistemas de controle em linhas de produção automotiva (ex: robôs de solda), drones para estabilização de voo, HVAC em edifícios inteligentes e próteses robóticas para precisão de movimento."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.4.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.4.3",
                            "name": "Documentação e Implantação",
                            "description": "Elaborar relatórios finais, manuais de usuário e implantar o projeto em ambiente industrial, considerando aplicações aeronáuticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Elaborar o Relatório Final do Projeto",
                                  "subSteps": [
                                    "Coletar todos os dados de testes, integração e execução do projeto microcontrolado.",
                                    "Estruturar o relatório com seções: introdução, objetivos, metodologia, resultados, análise, conclusões e referências.",
                                    "Redigir conteúdo técnico detalhado, incluindo diagramas esquemáticos, códigos-fonte e métricas de desempenho.",
                                    "Incorporar considerações específicas para aplicações aeronáuticas, como normas de segurança (ex: DO-178C).",
                                    "Formatar o documento com tabelas, gráficos e anexos para clareza visual."
                                  ],
                                  "verification": "Relatório completo com todas as seções preenchidas, revisado por um par e sem erros factuais.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Template de relatório técnico",
                                    "Dados de testes e logs do projeto",
                                    "Software de edição (MS Word ou LaTeX)",
                                    "Normas aeronáuticas (PDFs da ANAC/FAA)"
                                  ],
                                  "tips": "Priorize linguagem objetiva e use imagens de alta resolução para esquemas elétricos.",
                                  "learningObjective": "Produzir um relatório técnico profissional que documente integralmente o ciclo de vida do projeto.",
                                  "commonMistakes": [
                                    "Omissão de dados críticos de testes",
                                    "Falta de referências bibliográficas",
                                    "Excesso de jargões sem explicações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar o Manual de Usuário",
                                  "subSteps": [
                                    "Identificar público-alvo (operadores industriais, técnicos de manutenção em aeronáutica).",
                                    "Estruturar o manual: introdução, especificações do sistema, instalação, operação, troubleshooting e manutenção.",
                                    "Desenvolver instruções passo a passo com ilustrações, incluindo comandos para microcontrolador/CLP.",
                                    "Incluir advertências de segurança específicas para ambientes aeronáuticos (ex: redundância em atuadores).",
                                    "Testar o manual simulando uso por um não-especialista."
                                  ],
                                  "verification": "Manual aprovado em teste de usabilidade por um colega simulando operador.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Template de manual de usuário",
                                    "Esquemas do projeto",
                                    "Ferramentas de diagramação (Visio ou Draw.io)",
                                    "Imagens do protótipo físico"
                                  ],
                                  "tips": "Use bullet points e fluxogramas para facilitar a leitura rápida em campo.",
                                  "learningObjective": "Desenvolver um manual acessível que permita operação independente do sistema.",
                                  "commonMistakes": [
                                    "Instruções vagas ou ambíguas",
                                    "Ausência de diagramas visuais",
                                    "Ignorar cenários de falha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Planejar a Implantação em Ambiente Industrial",
                                  "subSteps": [
                                    "Avaliar requisitos do ambiente industrial/aeronáutico: hardware compatível, rede de comunicação e protocolos (ex: CAN bus).",
                                    "Criar checklist de implantação: pré-requisitos, sequência de montagem e calibração.",
                                    "Simular implantação em ambiente de teste para identificar riscos.",
                                    "Documentar plano de contingência, incluindo rollback e monitoramento pós-implantação.",
                                    "Coordenar com stakeholders para aprovações regulatórias aeronáuticas."
                                  ],
                                  "verification": "Plano de implantação revisado e aprovado por supervisor, com simulação bem-sucedida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Checklist template",
                                    "Especificações do ambiente industrial",
                                    "Software de simulação (Proteus ou MATLAB)",
                                    "Documentos regulatórios aeronáuticos"
                                  ],
                                  "tips": "Considere fatores ambientais como vibração e temperatura em aeronaves.",
                                  "learningObjective": "Elaborar um plano robusto que minimize downtime durante implantação.",
                                  "commonMistakes": [
                                    "Subestimar dependências de hardware",
                                    "Falta de plano B para falhas",
                                    "Ignorar conformidade certificadora"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar a Implantação e Verificações Finais",
                                  "subSteps": [
                                    "Instalar o sistema microcontrolado no ambiente alvo, conectando sensores e atuadores.",
                                    "Executar testes de integração final, validando funcionalidades em cenários aeronáuticos reais/simulados.",
                                    "Monitorar desempenho inicial e registrar métricas (ex: tempo de resposta, taxa de erro).",
                                    "Treinar usuários com o manual e coletar feedback inicial.",
                                    "Finalizar handover com assinatura de aceite e arquivamento de documentos."
                                  ],
                                  "verification": "Sistema operacional sem falhas por 1 hora de teste contínuo e aceite formal assinado.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Hardware do ambiente industrial",
                                    "Ferramentas de teste (multímetro, osciloscópio)",
                                    "Sistema microcontrolado pronto",
                                    "Checklist de implantação"
                                  ],
                                  "tips": "Registre vídeos curtos dos testes para auditorias futuras.",
                                  "learningObjective": "Implantar o projeto de forma segura e eficiente em contexto industrial.",
                                  "commonMistakes": [
                                    "Testes insuficientes pós-implantação",
                                    "Falta de treinamento aos usuários",
                                    "Não documentar desvios do plano"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de controle de atuadores para flaps de aeronave usando microcontrolador Arduino com CLP, elabore relatório com análise de testes de fadiga, manual para montagem em linha de produção da Embraer, planeje implantação em bancada de teste vibracional e execute instalação com verificação de redundância de segurança.",
                              "finalVerifications": [
                                "Relatório final completo e aprovado por revisor técnico.",
                                "Manual de usuário testado e compreendido por 80% dos avaliadores simulados.",
                                "Implantação executa todas as funções sem erros em ambiente simulado.",
                                "Todos os documentos incorporam normas aeronáuticas relevantes.",
                                "Handover realizado com treinamento e aceite formal.",
                                "Métricas de desempenho atendem especificações do projeto."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão técnica da documentação (nota 1-10).",
                                "Completude das seções obrigatórias no relatório e manual.",
                                "Adequação às normas e contextos aeronáuticos/industriais.",
                                "Eficiência da implantação (tempo vs. estimado, zero incidentes).",
                                "Qualidade das verificações e testes finais documentados.",
                                "Nível de usabilidade e acessibilidade do manual.",
                                "Integração de feedback e correções iterativas."
                              ],
                              "crossCurricularConnections": [
                                "Comunicação Técnica: Redação profissional e visualização de dados.",
                                "Gestão de Projetos: Planejamento, risco e handover.",
                                "Segurança e Normas: Conformidade aeronáutica (ANAC, FAA).",
                                "Ética Profissional: Transparência e responsabilidade em implantações.",
                                "Inglês Técnico: Tradução de manuais para padrões internacionais."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na produção de aviões da Embraer ou Boeing, a documentação e implantação garantem conformidade regulatória, reduzem tempo de setup em linhas de montagem e minimizam riscos de falhas em sistemas críticos de voo, como controles de superfície."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.4.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Elaboração e Execução de Projetos Mecatrônicos",
                "description": "Processos de elaboração e execução de projetos de sistemas mecatrônicos e microcontrolados.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Desenvolvimento Integrado de Produtos Mecatrônicos",
                    "description": "Técnicas de projeto e formação de times multifuncionais para elaboração de sistemas mecatrônicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Técnicas de Projeto Integrado de Produtos Mecatrônicos",
                        "description": "Métodos e abordagens para o desenvolvimento colaborativo de sistemas mecatrônicos, enfatizando integração de disciplinas como mecânica, eletrônica e software.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Identificar técnicas de design integrado",
                            "description": "Reconhecer e descrever técnicas como design concurrente e V-model aplicadas ao desenvolvimento de produtos mecatrônicos, com exemplos de ciclos de projeto iterativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de design integrado",
                                  "subSteps": [
                                    "Ler definições de design integrado em mecatrônica.",
                                    "Identificar diferenças entre design sequencial e integrado.",
                                    "Listar benefícios como redução de tempo e custos.",
                                    "Anotar exemplos iniciais de produtos mecatrônicos.",
                                    "Resumir em um mapa mental os conceitos chave."
                                  ],
                                  "verification": "Criar um resumo de 200 palavras explicando design integrado e seus benefícios.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livros de mecatrônica (ex: 'Mecatrônica' de Bolton), artigos online sobre design integrado, papel e caneta para mapa mental.",
                                  "tips": "Use diagramas para visualizar fluxos sequenciais vs. integrados.",
                                  "learningObjective": "Definir e diferenciar design integrado de abordagens tradicionais.",
                                  "commonMistakes": "Confundir design integrado com automação simples; focar apenas em software."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a técnica de Design Concurrente",
                                  "subSteps": [
                                    "Estudar o que é design concurrente: equipes multidisciplinares trabalhando em paralelo.",
                                    "Desenhar o fluxo de design concurrente com setas paralelas.",
                                    "Identificar ferramentas como CAD colaborativo e simulações.",
                                    "Pesquisar casos em mecatrônica, como desenvolvimento de drones.",
                                    "Comparar com design sequencial em uma tabela."
                                  ],
                                  "verification": "Desenhar e explicar um diagrama de design concurrente para um produto mecatrônico.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Vídeos no YouTube sobre 'Concurrent Engineering', software de desenho como Draw.io, artigos da IEEE.",
                                  "tips": "Enfatize a comunicação entre equipes para evitar retrabalhos.",
                                  "learningObjective": "Descrever o processo de design concurrente e suas vantagens em projetos mecatrônicos.",
                                  "commonMistakes": "Ignorar o papel da iteração; achar que é só paralelismo sem coordenação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Modelo V no desenvolvimento mecatrônico",
                                  "subSteps": [
                                    "Entender a estrutura V: decomposição à esquerda, integração à direita.",
                                    "Mapear fases: requisitos, design, implementação, verificação e validação.",
                                    "Aplicar ao contexto mecatrônico: hardware, software e controle.",
                                    "Desenhar um Modelo V para um sistema mecatrônico simples.",
                                    "Identificar pontos de iteração no modelo."
                                  ],
                                  "verification": "Construir um diagrama V completo para um atuador mecatrônico.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Diagramas do Modelo V em PDFs (NASA standards), ferramentas como Lucidchart, exemplos de livros de engenharia de sistemas.",
                                  "tips": "Lembre que o V suporta iterações verticais para refinamentos.",
                                  "learningObjective": "Reconhecer e diagramar o Modelo V aplicado a produtos mecatrônicos.",
                                  "commonMistakes": "Ver o V como linear; esquecer validação contra requisitos iniciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar ciclos iterativos e exemplos práticos",
                                  "subSteps": [
                                    "Combinar design concurrente e V-model em ciclos iterativos.",
                                    "Pesquisar exemplos reais: robôs industriais ou veículos autônomos.",
                                    "Criar uma tabela comparativa das técnicas com prós e contras.",
                                    "Simular um ciclo iterativo em um projeto fictício.",
                                    "Documentar lições aprendidas de iterações."
                                  ],
                                  "verification": "Produzir um relatório curto com exemplos e ciclos iterativos descritos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Casos de estudo online (ex: Bosch mecatrônica), planilhas Excel para tabelas.",
                                  "tips": "Use protótipos rápidos para testar iterações.",
                                  "learningObjective": "Aplicar técnicas em ciclos iterativos com exemplos mecatrônicos.",
                                  "commonMistakes": "Subestimar o número de iterações necessárias; não integrar disciplinas."
                                }
                              ],
                              "practicalExample": "No desenvolvimento de um braço robótico mecatrônico, use design concurrente para equipes de mecânica, eletrônica e software trabalharem em paralelo no V-model: requisitos no topo, protótipos iterativos na base, validando precisão de movimento após cada ciclo.",
                              "finalVerifications": [
                                "Descrever corretamente design concurrente e V-model.",
                                "Diagramar ambas as técnicas com exemplos mecatrônicos.",
                                "Identificar pelo menos 3 ciclos iterativos em um projeto.",
                                "Comparar vantagens em uma tabela.",
                                "Explicar aplicação em um produto real.",
                                "Listar benefícios e desafios."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição das técnicas (80% correta).",
                                "Qualidade dos diagramas e exemplos (clareza visual).",
                                "Profundidade na análise de iterações (mínimo 3 exemplos).",
                                "Integração de conceitos mecatrônicos específicos.",
                                "Capacidade de verbalizar explicações.",
                                "Originalidade em aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Ciclos ágeis semelhantes ao Scrum.",
                                "Gestão de Projetos: Ferramentas como MS Project para coordenação.",
                                "Física e Controle: Modelagem dinâmica em simulações.",
                                "Economia Empresarial: Redução de custos em ciclos iterativos."
                              ],
                              "realWorldApplication": "Na indústria automotiva, como na Tesla, design concurrente e V-model aceleram o desenvolvimento de sistemas mecatrônicos autônomos, reduzindo tempo de mercado de anos para meses via iterações rápidas em protótipos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Aplicar princípios de engenharia de design",
                            "description": "Utilizar métodos de engenharia de design descritos em Cross (2004), como análise funcional e síntese de soluções para sistemas mecatrônicos integrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Clarificar o Problema e Realizar Análise Funcional",
                                  "subSteps": [
                                    "Identificar stakeholders e coletar requisitos iniciais usando entrevistas ou questionários.",
                                    "Definir objetivos principais e restrições (funcionais e não funcionais) do sistema mecatrônico.",
                                    "Criar diagrama de funções principais (Functional Decomposition Diagram) baseado em Cross (2004).",
                                    "Decompor funções em subfunções e mapear fluxos de energia, material e informação.",
                                    "Validar análise funcional com modelo de black-box e white-box."
                                  ],
                                  "verification": "Diagrama funcional completo revisado e aprovado por pares ou mentor, sem ambiguidades.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Papel e caneta ou software como SysML/VISIO",
                                    "Livro 'Engineering Design Methods' de Cross (2004)",
                                    "Templates de análise funcional"
                                  ],
                                  "tips": [
                                    "Use as perguntas 5W1H (What, Why, Who, Where, When, How) para clarificar.",
                                    "Priorize funções críticas para sistemas mecatrônicos integrados."
                                  ],
                                  "learningObjective": "Dominar a análise funcional para decompor problemas complexos em sistemas mecatrônicos.",
                                  "commonMistakes": [
                                    "Ignorar requisitos não funcionais como custo e segurança.",
                                    "Fazer decomposição superficial sem fluxos de sinal/informação.",
                                    "Confundir funções com soluções prematuras."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Sintetizar Conceitos de Solução",
                                  "subSteps": [
                                    "Gerar ideias iniciais de soluções usando brainstorming e morfologia (matriz morfológica).",
                                    "Mapear subfunções às soluções conceituais (ex: atuadores mecânicos, sensores eletrônicos, controladores de software).",
                                    "Combinar conceitos para formar soluções integradas mecatrônicas, considerando interfaces.",
                                    "Esboçar conceitos preliminares com desenhos ou modelos 3D simples.",
                                    "Refinar síntese iterativamente com base em princípios de Cross (2004)."
                                  ],
                                  "verification": "Pelo menos 3-5 conceitos de solução documentados com esboços e justificativas.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Software de CAD como SolidWorks ou FreeCAD",
                                    "Post-its para brainstorming",
                                    "Referências de componentes mecatrônicos (catálogos)"
                                  ],
                                  "tips": [
                                    "Evite convergir cedo; gere diversidade de soluções radicais.",
                                    "Considere trade-offs entre mecânica, eletrônica e controle desde o início."
                                  ],
                                  "learningObjective": "Desenvolver habilidades de síntese criativa para soluções mecatrônicas viáveis.",
                                  "commonMistakes": [
                                    "Fixar em uma solução familiar sem explorar alternativas.",
                                    "Negligenciar integração interdisciplinar (ex: compatibilidade software-hardware).",
                                    "Gerar ideias não factíveis tecnicamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar e Selecionar Soluções",
                                  "subSteps": [
                                    "Definir critérios de avaliação ponderados (ex: custo, desempenho, robustez, escalabilidade).",
                                    "Aplicar métodos de avaliação como Pugh Matrix ou análise multicritério.",
                                    "Simular ou prototipar conceitos selecionados para testar viabilidade mecatrônica.",
                                    "Realizar análise de risco e trade-off para sistemas integrados.",
                                    "Selecionar e justificar a solução final."
                                  ],
                                  "verification": "Matriz de avaliação preenchida com pontuações e solução selecionada documentada.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Planilhas Excel para matriz Pugh",
                                    "Software de simulação como MATLAB/Simulink",
                                    "Prototipo simples (breadboard para eletrônica)"
                                  ],
                                  "tips": [
                                    "Atribua pesos realistas baseados em requisitos do projeto.",
                                    "Inclua simulações para prever interações mecatrônicas."
                                  ],
                                  "learningObjective": "Aprender a avaliar soluções de forma sistemática e objetiva.",
                                  "commonMistakes": [
                                    "Critérios subjetivos sem pesos.",
                                    "Ignorar riscos de integração (ex: ruído eletromagnético).",
                                    "Selecionar baseado apenas em custo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhar e Planejar Implementação Integrada",
                                  "subSteps": [
                                    "Desenvolver especificações detalhadas para componentes (mecânicos, eletrônicos, software).",
                                    "Criar plano de integração e testes (ex: integração bottom-up).",
                                    "Definir cronograma, recursos e milestones para prototipagem.",
                                    "Documentar o design final com relatórios e desenhos técnicos.",
                                    "Planejar iterações baseadas em feedback de testes preliminares."
                                  ],
                                  "verification": "Pacote de design completo (especificações, plano de integração) revisado.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de gerenciamento de projetos como MS Project",
                                    "Ferramentas CAD/CAE",
                                    "Templates de relatório de design"
                                  ],
                                  "tips": [
                                    "Use versionamento para evoluções do design.",
                                    "Antecipe testes de integração cedo."
                                  ],
                                  "learningObjective": "Finalizar designs mecatrônicos prontos para prototipagem.",
                                  "commonMistakes": [
                                    "Pular documentação detalhada.",
                                    "Subestimar tempo de integração.",
                                    "Não considerar fabricação e montagem."
                                  ]
                                }
                              ],
                              "practicalExample": "Ao projetar um braço robótico mecatrônico para pick-and-place em linha de produção: 1) Analisar funções como detecção, grip e movimento; 2) Sintetizar conceitos com servos, visão computacional e PLC; 3) Avaliar por precisão e velocidade; 4) Detalhar integração com Arduino e braços pneumáticos.",
                              "finalVerifications": [
                                "Diagrama funcional completo e validado.",
                                "Mínimo de 3 conceitos de solução gerados e avaliados.",
                                "Solução selecionada com justificativa multicritério.",
                                "Plano de integração detalhado para componentes mecatrônicos.",
                                "Documentação alinhada aos princípios de Cross (2004).",
                                "Análise de riscos identificados e mitigados."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da análise funcional (30%).",
                                "Criatividade e diversidade na síntese de soluções (25%).",
                                "Rigor na avaliação e seleção (20%).",
                                "Qualidade da integração mecatrônica proposta (15%).",
                                "Clareza da documentação e alinhamento com Cross (2004) (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de funções e otimização multicritério.",
                                "Física: Análise de dinâmica e cinemática em sistemas mecatrônicos.",
                                "Informática: Simulação e programação de controladores.",
                                "Gestão de Projetos: Planejamento e análise de riscos.",
                                "Materiais: Seleção de componentes baseados em propriedades."
                              ],
                              "realWorldApplication": "Na indústria automotiva, aplica-se para desenvolver sistemas de freios ABS integrados, onde análise funcional identifica sensores de roda, síntese combina hidráulica e eletrônica, e avaliação garante segurança em veículos autônomos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Planejar execução de projetos mecatrônicos",
                            "description": "Elaborar planos de projeto incluindo etapas de prototipagem, teste e validação para sistemas mecatrônicos e microcontrolados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Objetivos e Escopo do Projeto",
                                  "subSteps": [
                                    "Identificar o problema ou necessidade que o projeto mecatrônico resolve.",
                                    "Estabelecer objetivos SMART (Específicos, Mensuráveis, Alcançáveis, Relevantes, Temporais).",
                                    "Delimitar o escopo, incluindo funcionalidades principais de sistemas mecatrônicos e microcontrolados.",
                                    "Listar restrições como orçamento, tempo e recursos disponíveis.",
                                    "Documentar em um documento de projeto inicial."
                                  ],
                                  "verification": "Objetivos SMART documentados e escopo aprovado por stakeholders simulados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Computador com editor de texto (Google Docs ou MS Word)",
                                    "Templates de plano de projeto mecatrônico"
                                  ],
                                  "tips": "Priorize objetivos alinhados ao contexto mecatrônico, focando em integração de mecânica, eletrônica e software.",
                                  "learningObjective": "Dominar a definição precisa de escopo para evitar desvios em projetos integrados.",
                                  "commonMistakes": [
                                    "Escopo excessivamente amplo sem priorização",
                                    "Ignorar integração mecatrônica desde o início",
                                    "Objetivos vagos não mensuráveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Requisitos e Selecionar Componentes",
                                  "subSteps": [
                                    "Levantar requisitos funcionais (ex.: sensores, atuadores) e não funcionais (desempenho, segurança).",
                                    "Pesquisar e listar componentes mecatrônicos compatíveis (microcontroladores como Arduino/ESP32, motores, sensores).",
                                    "Criar diagrama de blocos do sistema mostrando integração.",
                                    "Avaliar fornecedores e custos preliminares.",
                                    "Validar compatibilidade com prototipagem rápida."
                                  ],
                                  "verification": "Lista de componentes com especificações e diagrama de blocos completo.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Acesso à internet para catálogos (DigiKey, Arduino.cc)",
                                    "Software de diagramação (Draw.io ou Lucidchart)"
                                  ],
                                  "tips": "Use matriz de requisitos para priorizar componentes essenciais para sistemas microcontrolados.",
                                  "learningObjective": "Aprender a mapear requisitos para seleção otimizada de hardware mecatrônico.",
                                  "commonMistakes": [
                                    "Selecionar componentes incompatíveis",
                                    "Subestimar consumo de energia",
                                    "Ignorar escalabilidade para testes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Elaborar Cronograma e Etapas de Execução",
                                  "subSteps": [
                                    "Dividir o projeto em fases: design, prototipagem, teste, validação e iteração.",
                                    "Estimar duração de cada etapa com buffers para imprevistos.",
                                    "Criar Gantt chart ou lista de tarefas com milestones.",
                                    "Definir dependências entre tarefas (ex.: protótipo antes de testes).",
                                    "Integrar checkpoints para revisão de protótipos mecatrônicos."
                                  ],
                                  "verification": "Cronograma visualizado com todas as etapas principais e milestones alcançáveis.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Software de gerenciamento (MS Project, Trello ou GanttProject gratuito)"
                                  ],
                                  "tips": "Aloque 20-30% do tempo total para testes e validação em projetos mecatrônicos.",
                                  "learningObjective": "Desenvolver habilidades em sequenciamento lógico de fases de projeto integrado.",
                                  "commonMistakes": [
                                    "Cronograma irrealista sem buffers",
                                    "Omitir fase de validação",
                                    "Dependências mal definidas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Planejar Recursos, Riscos e Contingências",
                                  "subSteps": [
                                    "Listar recursos humanos, ferramentas e orçamento detalhado.",
                                    "Identificar riscos potenciais (falhas em protótipos, atrasos em componentes).",
                                    "Criar matriz de riscos com probabilidade, impacto e mitigação.",
                                    "Definir plano de contingência para cada risco alto.",
                                    "Estabelecer métricas de monitoramento do plano."
                                  ],
                                  "verification": "Matriz de riscos completa e orçamento aprovado.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Planilhas Excel para matriz de riscos e orçamento",
                                    "Templates PMBOK adaptados para mecatrônica"
                                  ],
                                  "tips": "Priorize riscos relacionados à integração de software/hardware em microcontroladores.",
                                  "learningObjective": "Capacitar na gestão proativa de riscos em ambientes mecatrônicos complexos.",
                                  "commonMistakes": [
                                    "Subestimar riscos de suprimentos",
                                    "Orçamento sem contingências",
                                    "Falta de responsáveis claros"
                                  ]
                                }
                              ],
                              "practicalExample": "Planejar um sistema de braço robótico mecatrônico controlado por Arduino: definir escopo (movimento em 3 eixos), selecionar servos e sensores, cronograma com prototipagem em 2 semanas, testes de precisão e validação com cargas reais, incluindo riscos como falha de calibração.",
                              "finalVerifications": [
                                "Plano cobre todas as etapas: prototipagem, teste e validação.",
                                "Cronograma realista com milestones mensuráveis.",
                                "Componentes selecionados são compatíveis e orçamentados.",
                                "Riscos identificados com planos de mitigação.",
                                "Escopo alinhado a objetivos SMART.",
                                "Documentação completa e revisável."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na definição de escopo e objetivos (30%).",
                                "Completude e realismo do cronograma (25%).",
                                "Adequação da seleção de componentes mecatrônicos (20%).",
                                "Profundidade na análise de riscos e contingências (15%).",
                                "Integração de verificações em todas as fases (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Aplicação de PMBOK em planejamento.",
                                "Eletrônica: Seleção de microcontroladores e sensores.",
                                "Programação: Planejamento de firmware para testes.",
                                "Mecânica: Design inicial de protótipos.",
                                "Matemática: Cálculos de cronograma e orçamento."
                              ],
                              "realWorldApplication": "Na indústria automotiva, para planejar desenvolvimento de linhas de montagem robóticas; em agricultura de precisão, sistemas de irrigação automatizados com microcontroladores; ou em manufatura inteligente (Indústria 4.0), integrando prototipagem rápida e validação para redução de tempo de mercado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Formação de Times Multifuncionais",
                        "description": "Estratégias para composição e gerenciamento de equipes interdisciplinares envolvidas na elaboração de sistemas mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Definir papéis em times multifuncionais",
                            "description": "Especificar funções de engenheiros mecânicos, eletrônicos, de software e especialistas em controle para projetos mecatrônicos colaborativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os papéis principais em um time mecatrônico multifuncional",
                                  "subSteps": [
                                    "Liste os quatro papéis essenciais: engenheiro mecânico, engenheiro eletrônico, engenheiro de software e especialista em controle.",
                                    "Descreva brevemente as contribuições únicas de cada um para um projeto mecatrônico.",
                                    "Analise o escopo do projeto para confirmar a necessidade de cada papel.",
                                    "Pesquise exemplos de times semelhantes em projetos reais de mecatrônica.",
                                    "Crie um diagrama inicial de organograma mostrando os papéis."
                                  ],
                                  "verification": "Verifique se há uma lista completa com descrições breves e um diagrama preliminar criado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel ou ferramenta digital como Draw.io ou Lucidchart",
                                    "Referências sobre papéis em mecatrônica (livros ou sites como IEEE)"
                                  ],
                                  "tips": "Comece pelo engenheiro mecânico como base estrutural para contextualizar os outros.",
                                  "learningObjective": "Compreender as funções fundamentais de cada especialista em contextos mecatrônicos colaborativos.",
                                  "commonMistakes": [
                                    "Ignorar o especialista em controle, subestimando integração",
                                    "Confundir papéis de software com eletrônico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar responsabilidades detalhadas para cada papel",
                                  "subSteps": [
                                    "Para engenheiro mecânico: defina tarefas como design de estruturas, seleção de materiais e simulações cinemáticas.",
                                    "Para engenheiro eletrônico: liste hardware, sensores, atuadores e PCBs.",
                                    "Para engenheiro de software: detalhe algoritmos, interfaces e código embarcado.",
                                    "Para especialista em controle: especifique modelagem dinâmica, controladores PID e tuning.",
                                    "Atribua responsabilidades compartilhadas, como testes integrados."
                                  ],
                                  "verification": "Confirme que cada papel tem pelo menos 4-6 responsabilidades específicas listadas em um documento compartilhado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel para tabela de responsabilidades",
                                    "Templates de RACI matrix"
                                  ],
                                  "tips": "Use matriz RACI (Responsible, Accountable, Consulted, Informed) para clareza.",
                                  "learningObjective": "Mapear tarefas específicas alinhadas ao ciclo de vida do projeto mecatrônico.",
                                  "commonMistakes": [
                                    "Sobrecarregar um papel sem balanceamento",
                                    "Não incluir responsabilidades de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir interações, comunicação e fluxo de trabalho entre papéis",
                                  "subSteps": [
                                    "Mapeie dependências: ex., mecânica informa eletrônica sobre dimensões.",
                                    "Estabeleça reuniões regulares e ferramentas de comunicação (ex.: Slack, Jira).",
                                    "Crie fluxogramas de handover entre papéis.",
                                    "Defina protocolos para resolução de conflitos interdisciplinares.",
                                    "Simule um cenário de integração para testar fluxos."
                                  ],
                                  "verification": "Examine o fluxograma e simulação para cobertura de interações chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de diagramação (Microsoft Visio ou Miro)",
                                    "Exemplos de fluxos de projetos ágeis em mecatrônica"
                                  ],
                                  "tips": "Priorize integrações bidirecionais para evitar silos.",
                                  "learningObjective": "Estabelecer dinâmicas colaborativas eficazes em times multifuncionais.",
                                  "commonMistakes": [
                                    "Assumir comunicação implícita sem ferramentas definidas",
                                    "Ignorar conflitos potenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar, revisar e comunicar os papéis definidos",
                                  "subSteps": [
                                    "Compile tudo em um documento oficial de definição de papéis.",
                                    "Revise com stakeholders simulados ou pares para feedback.",
                                    "Crie resumo visual (infográfico ou pôster).",
                                    "Distribua via e-mail ou repositório (GitHub).",
                                    "Planeje uma sessão de kickoff para alinhamento."
                                  ],
                                  "verification": "Documento final aprovado por revisão e comunicado a todos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Google Docs ou Word para documento",
                                    "Ferramentas de design como Canva para infográfico"
                                  ],
                                  "tips": "Mantenha linguagem acessível para não-especialistas.",
                                  "learningObjective": "Garantir que definições sejam acionáveis e compreensíveis por todo o time.",
                                  "commonMistakes": [
                                    "Documentos muito técnicos sem resumo",
                                    "Não revisar antes de comunicar"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de braço robótico mecatrônico: engenheiro mecânico projeta juntas e links; eletrônico seleciona motores e sensores; software desenvolve controle de trajetória; controle otimiza estabilidade. Interações incluem simulações compartilhadas no MATLAB/Simulink.",
                              "finalVerifications": [
                                "Todos os quatro papéis têm responsabilidades claras e balanceadas.",
                                "Matriz de interações cobre dependências e comunicações.",
                                "Documento inclui exemplos práticos e matriz RACI.",
                                "Fluxograma demonstra fluxo de trabalho sem gargalos.",
                                "Revisão simulada confirma compreensão por membros do time.",
                                "Preparado para sessão de kickoff com resumo visual."
                              ],
                              "assessmentCriteria": [
                                "Clareza e especificidade das descrições de papéis (nota 1-5).",
                                "Cobertura completa de responsabilidades e integrações (sem lacunas).",
                                "Uso efetivo de ferramentas visuais e matrizes.",
                                "Balanceamento de carga entre papéis.",
                                "Potencial para aplicação real em projetos colaborativos.",
                                "Qualidade da documentação e comunicação."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Uso de metodologias ágeis como Scrum.",
                                "Comunicação: Desenvolvimento de habilidades de apresentação e feedback.",
                                "Liderança: Facilitação de times multidisciplinares.",
                                "Ética Profissional: Definição de accountability em colaborações."
                              ],
                              "realWorldApplication": "Na indústria automotiva, como na montagem de linhas robóticas da Tesla ou BMW, onde times multifuncionais definem papéis para integrar mecânica, eletrônica, software e controle, acelerando o desenvolvimento de veículos autônomos e reduzindo tempo de mercado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Gerenciar comunicação em equipes integradas",
                            "description": "Implementar ferramentas e práticas de comunicação, como reuniões ágeis e ferramentas de gerenciamento de projetos, para times multifuncionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar necessidades de comunicação da equipe multifuncional",
                                  "subSteps": [
                                    "Identificar membros da equipe e suas funções (ex.: mecânica, elétrica, software).",
                                    "Mapear fluxos de informação atuais e gargalos de comunicação.",
                                    "Realizar enquetes ou entrevistas para entender preferências e desafios.",
                                    "Definir objetivos de comunicação claros, como frequência de atualizações e tipos de mensagens.",
                                    "Documentar um relatório inicial de necessidades."
                                  ],
                                  "verification": "Relatório de necessidades aprovado pela equipe ou líder do projeto.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Ferramentas de enquete (Google Forms, Microsoft Forms), planilha para mapeamento (Excel/Google Sheets), acesso aos membros da equipe.",
                                  "tips": "Envolva toda a equipe desde o início para aumentar o buy-in.",
                                  "learningObjective": "Compreender as dinâmicas específicas de comunicação em times multifuncionais.",
                                  "commonMistakes": "Ignorar diferenças culturais ou funcionais entre membros da equipe."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e configurar ferramentas de comunicação e gerenciamento",
                                  "subSteps": [
                                    "Pesquisar ferramentas adequadas (ex.: Slack/Teams para chat, Trello/Jira para tarefas, Zoom para reuniões).",
                                    "Comparar funcionalidades, custos e integração com sistemas mecatrônicos (ex.: CAD/PLM).",
                                    "Configurar canais específicos por função ou projeto (ex.: #mecatronica-robô).",
                                    "Definir regras de uso (ex.: etiquetas para urgência, arquivamento de mensagens).",
                                    "Testar ferramentas em um piloto com subgrupo da equipe."
                                  ],
                                  "verification": "Ferramentas configuradas e testadas com feedback positivo do piloto.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "Acesso a contas trial de ferramentas (Slack, Jira, Microsoft Teams), computador com internet.",
                                  "tips": "Priorize ferramentas com integrações nativas para reduzir fricção.",
                                  "learningObjective": "Escolher ferramentas que suportem colaboração assíncrona e síncrona em projetos mecatrônicos.",
                                  "commonMistakes": "Escolher ferramentas complexas sem treinamento prévio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer práticas e protocolos de comunicação, incluindo reuniões ágeis",
                                  "subSteps": [
                                    "Definir cadência de reuniões (daily stand-up de 15min, sprint reviews semanais).",
                                    "Criar templates para atualizações (o quê feito, bloqueios, próximos passos).",
                                    "Implementar práticas ágeis como Kanban ou Scrum adaptado para mecatrônica.",
                                    "Estabelecer normas de resposta (ex.: 24h para mensagens não urgentes).",
                                    "Documentar o protocolo em um guia compartilhado."
                                  ],
                                  "verification": "Guia de protocolos aprovado e distribuído à equipe.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Quadro Kanban digital (Trello/Miro), templates em Google Docs.",
                                  "tips": "Mantenha reuniões curtas e focadas em ações, usando timer.",
                                  "learningObjective": "Aplicar metodologias ágeis para comunicação eficiente em times integrados.",
                                  "commonMistakes": "Sobrecarregar com reuniões excessivas, levando a fadiga."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Treinar a equipe e monitorar a implementação",
                                  "subSteps": [
                                    "Realizar sessão de onboarding/training sobre ferramentas e protocolos.",
                                    "Designar 'campeões' por função para suporte inicial.",
                                    "Coletar feedback semanal via enquete rápida.",
                                    "Ajustar protocolos com base no feedback (ex.: adicionar emojis para status).",
                                    "Registrar métricas iniciais (taxa de adesão, tempo de resolução de issues)."
                                  ],
                                  "verification": "80% da equipe relata compreensão e uso correto em enquete pós-treinamento.",
                                  "estimatedTime": "3-5 horas + 1 semana de monitoramento",
                                  "materials": "Plataforma de videochamada (Zoom/Teams), enquetes online.",
                                  "tips": "Use gamificação, como badges por adesão, para engajar.",
                                  "learningObjective": "Garantir adesão e proficiência da equipe nas práticas de comunicação.",
                                  "commonMistakes": "Não monitorar adesão, permitindo que maus hábitos persistam."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e otimizar continuamente a comunicação",
                                  "subSteps": [
                                    "Analisar métricas (ex.: tempo médio de resposta, issues resolvidos).",
                                    "Realizar retrospectivas mensais para identificar melhorias.",
                                    "Introduzir novas ferramentas ou ajustes conforme evolução do projeto.",
                                    "Celebrar sucessos para reforçar comportamentos positivos.",
                                    "Atualizar o guia de comunicação com lições aprendidas."
                                  ],
                                  "verification": "Relatório de otimização com pelo menos 2 ajustes implementados.",
                                  "estimatedTime": "2-4 horas mensais",
                                  "materials": "Dashboards de ferramentas (Jira reports), planilhas de métricas.",
                                  "tips": "Foque em dados quantitativos e qualitativos para decisões baseadas em evidências.",
                                  "learningObjective": "Desenvolver habilidades de melhoria contínua em comunicação de equipes.",
                                  "commonMistakes": "Parar de monitorar após implementação inicial."
                                }
                              ],
                              "practicalExample": "Em um projeto de desenvolvimento de um braço robótico mecatrônico, o líder usa Slack para canais diários (#design-mecanico, #software), Jira para rastrear tarefas integradas e stand-ups ágeis de 15min para alinhar engenheiros mecânicos, elétricos e programadores, resolvendo um bloqueio de integração em 2 dias ao invés de 1 semana.",
                              "finalVerifications": [
                                "Equipe utiliza ferramentas consistentemente (≥90% adesão medida por logs).",
                                "Tempo médio de resolução de issues de comunicação reduzido em 50%.",
                                "Feedback da equipe indica alta satisfação (nota ≥4/5 em enquetes).",
                                "Ausência de gargalos reportados em retrospectivas.",
                                "Protocolos documentados e atualizados acessíveis a todos.",
                                "Métricas de produtividade do projeto melhoradas (ex.: milestones no prazo)."
                              ],
                              "assessmentCriteria": [
                                "Eficiência na seleção e configuração de ferramentas (adequação ao contexto multifuncional).",
                                "Qualidade dos protocolos e práticas ágeis implementadas (clareza e acionabilidade).",
                                "Nível de engajamento e treinamento da equipe (taxa de participação).",
                                "Resultados mensuráveis em métricas de comunicação (tempo de resposta, resolução de conflitos).",
                                "Capacidade de otimização contínua baseada em feedback.",
                                "Integração efetiva com fluxos mecatrônicos (ex.: compartilhamento de CAD/simulações)."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Integração com metodologias ágeis/Scrum.",
                                "Liderança e Trabalho em Equipe: Habilidades de facilitação e resolução de conflitos.",
                                "Tecnologias da Informação: Uso avançado de ferramentas colaborativas.",
                                "Psicologia Organizacional: Compreensão de dinâmicas de grupo multifuncionais."
                              ],
                              "realWorldApplication": "Na indústria automotiva, como na montagem de linhas de produção mecatrônicas da Toyota, gerentes usam essas práticas para coordenar times de engenharia, reduzindo erros de integração e acelerando o time-to-market de novos veículos híbridos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Avaliar desempenho de times mecatrônicos",
                            "description": "Desenvolver métricas para avaliar a eficácia de times na integração de subsistemas mecatrônicos durante o ciclo de projeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir objetivos de avaliação e métricas chave para times mecatrônicos",
                                  "subSteps": [
                                    "Analise o ciclo de projeto mecatrônico (concepção, design, integração, teste) e identifique fases críticas de integração de subsistemas.",
                                    "Liste atributos de desempenho do time: colaboração, eficiência na resolução de problemas, integração técnica e cumprimento de prazos.",
                                    "Desenvolva métricas SMART (Específicas, Mensuráveis, Alcançáveis, Relevantes, Temporais) como taxa de integração bem-sucedida, tempo de resolução de conflitos e índice de satisfação do time.",
                                    "Priorize 5-8 métricas principais baseadas em objetivos do projeto, como % de subsistemas integrados sem retrabalho.",
                                    "Valide métricas com stakeholders do time para alinhamento."
                                  ],
                                  "verification": "Lista de métricas documentada em tabela com critérios SMART e aprovação de pelo menos um stakeholder.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Documentação do ciclo de projeto mecatrônico",
                                    "Guia de métricas de desempenho de times (ex: OKR framework)"
                                  ],
                                  "tips": "Use frameworks como OKR ou Balanced Scorecard para inspirar métricas equilibradas entre aspectos técnicos e comportamentais.",
                                  "learningObjective": "Compreender e criar métricas alinhadas ao contexto de integração mecatrônica.",
                                  "commonMistakes": [
                                    "Métricas vagas sem critérios mensuráveis",
                                    "Ignorar aspectos comportamentais focando só em técnicos",
                                    "Excesso de métricas levando a sobrecarga"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar ferramentas e métodos de coleta de dados",
                                  "subSteps": [
                                    "Escolha métodos de coleta: questionários, observação direta, logs de reuniões, métricas de software de gerenciamento (ex: Jira).",
                                    "Crie formulários padronizados para autoavaliação do time e avaliação 360 graus.",
                                    "Defina frequência de coleta: semanal durante integração, diária em fases críticas.",
                                    "Integre ferramentas digitais como Trello ou Microsoft Teams para rastreamento automático de tarefas.",
                                    "Teste piloto as ferramentas em uma reunião simulada para refinar."
                                  ],
                                  "verification": "Ferramentas prototipadas e testadas com dados simulados de uma fase de projeto.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ferramentas de survey como Google Forms",
                                    "Software de gerenciamento de projetos (Jira, Trello)",
                                    "Templates de avaliação 360 graus"
                                  ],
                                  "tips": "Automatize o máximo possível para reduzir viés subjetivo e economizar tempo.",
                                  "learningObjective": "Dominar design de instrumentos de medição confiáveis e escaláveis.",
                                  "commonMistakes": [
                                    "Métodos invasivos que atrapalhem o fluxo do time",
                                    "Falta de anonimato em avaliações levando a respostas enviesadas",
                                    "Não calibrar escalas de pontuação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar coleta e análise de dados de desempenho",
                                  "subSteps": [
                                    "Colete dados durante uma fase real ou simulada de integração de subsistemas.",
                                    "Organize dados em dashboard (ex: Excel pivot tables ou Power BI).",
                                    "Aplique análises estatísticas básicas: médias, desvios padrão, correlações entre métricas.",
                                    "Identifique padrões: gargalos em integração mecânica-elétrica, por exemplo.",
                                    "Compare resultados com benchmarks de projetos mecatrônicos semelhantes."
                                  ],
                                  "verification": "Dashboard com dados analisados e insights preliminares documentados.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Planilhas avançadas ou Power BI/Tableau",
                                    "Dados simulados/real de times",
                                    "Calculadora estatística ou Python básico para análise"
                                  ],
                                  "tips": "Visualize dados com gráficos para facilitar interpretação rápida.",
                                  "learningObjective": "Aplicar análise de dados para extrair insights acionáveis sobre desempenho de times.",
                                  "commonMistakes": [
                                    "Análise superficial sem estatísticas",
                                    "Ignorar outliers que indicam problemas sistêmicos",
                                    "Confundir correlação com causalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados, relatar e propor melhorias",
                                  "subSteps": [
                                    "Sintetize achados em relatório executivo com forças, fraquezas e recomendações.",
                                    "Classifique desempenho: alto/médio/baixo por métrica e overall.",
                                    "Proponha ações corretivas: treinamentos em integração, realocação de papéis.",
                                    "Apresente feedback ao time em sessão de debriefing.",
                                    "Defina plano de follow-up com novas métricas de monitoramento."
                                  ],
                                  "verification": "Relatório final entregue e sessão de feedback realizada com atas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Template de relatório de desempenho",
                                    "Ferramentas de apresentação (PowerPoint)",
                                    " atas de reuniões"
                                  ],
                                  "tips": "Foquem em feedback construtivo usando método SBI (Situação-Comportamento-Impacto).",
                                  "learningObjective": "Transformar dados em ações estratégicas para melhoria contínua de times.",
                                  "commonMistakes": [
                                    "Relatórios longos sem resumo executivo",
                                    "Recomendações genéricas sem base nos dados",
                                    "Não envolver o time no processo de melhoria"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de braço robótico mecatrônico, desenvolva métricas como 'taxa de sucesso na integração atuador-sensor (90% alvo)' e 'tempo médio de resolução de falhas de interface (2 horas máx.). Colete dados via logs do time no Jira durante testes de integração, analise desvios e recomende workshop de comunicação para reduzir conflitos em 20%.",
                              "finalVerifications": [
                                "Métricas cobrem integração técnica e dinâmica de time com pelo menos 80% de cobertura SMART.",
                                "Dashboard funcional com dados reais/simulados e análises estatísticas básicas.",
                                "Relatório inclui recomendações acionáveis com prazos e responsáveis.",
                                "Feedback do time indica compreensão e aceitação das avaliações.",
                                "Melhoria mensurável simulada em pelo menos uma métrica chave.",
                                "Conexão clara com ciclo de projeto mecatrônico documentada."
                              ],
                              "assessmentCriteria": [
                                "Precisão e relevância das métricas (alinhadas ao contexto mecatrônico).",
                                "Confiabilidade dos métodos de coleta (baixa subjetividade, alta consistência).",
                                "Profundidade da análise (uso de estatísticas e visualizações).",
                                "Qualidade do relatório e recomendações (claras, acionáveis, baseadas em evidências).",
                                "Engajamento interdisciplinar evidenciado nas conexões.",
                                "Tempo respeitado e eficiência no processo."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Uso de frameworks como PMBOK para avaliação de times.",
                                "Estatística e Análise de Dados: Aplicação de métricas quantitativas e qualitativas.",
                                "Psicologia Organizacional: Dinâmicas de grupo e avaliação 360 graus.",
                                "Engenharia de Software: Métricas de integração semelhantes a DevOps.",
                                "Liderança e Comunicação: Feedback e melhoria contínua."
                              ],
                              "realWorldApplication": "Na indústria automotiva, como na montagem de linhas de produção robóticas da Tesla ou Bosch, onde times multifuncionais integram mecânica, eletrônica e software; métricas de desempenho garantem entregas no prazo, reduzem retrabalhos em 30% e otimizam custos de projeto."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Componentes e Aplicações em Mecatrônica",
                        "description": "Introdução a elementos chave como microprocessadores, visão computacional e robótica, com foco em aplicações industriais aeronáuticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Compreender microprocessadores e microcontroladores",
                            "description": "Diferenciar microprocessadores, microcontroladores e CLPs, descrevendo suas aplicações em sistemas mecatrônicos conforme Lyshevski (1999).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceituar Microprocessadores",
                                  "subSteps": [
                                    "Ler a definição de microprocessador em Lyshevski (1999), capítulo relevante sobre componentes digitais.",
                                    "Identificar componentes principais: ALU, registradores, unidade de controle e barramentos.",
                                    "Desenhar um diagrama simplificado de um microprocessador genérico (ex: Intel 8085).",
                                    "Pesquisar evolução histórica de microprocessadores (von Neumann architecture).",
                                    "Comparar microprocessadores com CPUs modernas em termos de clock speed e integração."
                                  ],
                                  "verification": "Desenhar e rotular corretamente um diagrama de microprocessador com pelo menos 5 componentes chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro Lyshevski (1999)",
                                    "Papel e caneta para diagramas",
                                    "Vídeos tutoriais sobre arquitetura von Neumann (YouTube/Khan Academy)"
                                  ],
                                  "tips": "Use analogias como 'cérebro de um computador' para fixar o conceito.",
                                  "learningObjective": "Compreender a estrutura e função básica de um microprocessador.",
                                  "commonMistakes": [
                                    "Confundir microprocessador com memória RAM",
                                    "Ignorar a necessidade de memória externa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conceituar Microcontroladores",
                                  "subSteps": [
                                    "Ler seção sobre microcontroladores em Lyshevski (1999), focando em SoC (System on Chip).",
                                    "Listar diferenças chave: integração de CPU, memória, I/O e periféricos em um chip único.",
                                    "Estudar exemplos como Arduino (ATmega) ou PIC, diagramando seus pinos e módulos.",
                                    "Simular um microcontrolador básico usando Tinkercad ou Proteus.",
                                    "Analisar datasheet de um microcontrolador comum (ex: ATmega328)."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito 4 vantagens de microcontroladores sobre microprocessadores.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro Lyshevski (1999)",
                                    "Datasheet ATmega328 (online)",
                                    "Simulador Tinkercad (gratuito)"
                                  ],
                                  "tips": "Pense em microcontroladores como 'computadores completos em miniatura' para projetos embarcados.",
                                  "learningObjective": "Dominar a arquitetura integrada dos microcontroladores.",
                                  "commonMistakes": [
                                    "Achar que todos os microcontroladores precisam de OS",
                                    "Subestimar periféricos integrados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conceituar CLPs (Controladores Lógicos Programáveis)",
                                  "subSteps": [
                                    "Definir CLP conforme Lyshevski (1999): hardware robusto para automação industrial com linguagens ladder.",
                                    "Identificar componentes: CPU, I/O modules, power supply e programação via PLC software.",
                                    "Comparar CLPs com microcontroladores em termos de robustez e programação (IEC 61131-3).",
                                    "Assistir vídeo de ladder logic e simular um ciclo simples em software gratuito como OpenPLC.",
                                    "Listar aplicações industriais típicas de CLPs."
                                  ],
                                  "verification": "Criar um diagrama de um CLP básico e simular um programa ladder simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro Lyshevski (1999)",
                                    "Software OpenPLC ou LogixPro",
                                    "Vídeos sobre ladder logic"
                                  ],
                                  "tips": "Lembre-se: CLPs são para ambientes industriais hostis, priorizando confiabilidade.",
                                  "learningObjective": "Entender o papel dos CLPs em controle industrial.",
                                  "commonMistakes": [
                                    "Confundir ladder logic com programação procedural",
                                    "Ignorar certificações de segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e Aplicar em Sistemas Mecatrônicos",
                                  "subSteps": [
                                    "Criar tabela comparativa: microprocessador vs microcontrolador vs CLP (colunas: custo, integração, aplicações, robustez).",
                                    "Descrever aplicações mecatrônicas por Lyshevski: microcontroladores em robótica, CLPs em linhas de produção.",
                                    "Analisar case study: uso de microcontrolador em drone vs CLP em conveyor belt.",
                                    "Discutir trade-offs em projetos mecatrônicos (ex: custo vs performance).",
                                    "Redigir parágrafo resumindo diferenças chave."
                                  ],
                                  "verification": "Apresentar tabela comparativa e explicar 3 aplicações específicas em mecatrônica.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Livro Lyshevski (1999)",
                                    "Planilha Excel/Google Sheets",
                                    "Artigos/cases online sobre mecatrônica"
                                  ],
                                  "tips": "Use exemplos reais para ancorar conceitos abstratos.",
                                  "learningObjective": "Diferenciar os três e mapear aplicações em mecatrônica.",
                                  "commonMistakes": [
                                    "Generalizar aplicações sem contexto mecatrônico",
                                    "Omitir referência a Lyshevski"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema mecatrônico de braço robótico: use microcontrolador (Arduino) para controle preciso de servos em protótipo; microprocessador para processamento de visão computacional em PC; CLP para automação industrial em fábrica.",
                              "finalVerifications": [
                                "Explicar diferenças arquiteturais entre os três componentes.",
                                "Listar 3 aplicações mecatrônicas para cada um.",
                                "Desenhar diagramas corretos de cada dispositivo.",
                                "Simular um programa simples para microcontrolador e CLP.",
                                "Referenciar corretamente Lyshevski (1999) em explicações.",
                                "Discutir trade-offs em um projeto hipotético."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (20%)",
                                "Uso correto de terminologia técnica (20%)",
                                "Qualidade de diagramas e tabelas (20%)",
                                "Profundidade de aplicações mecatrônicas (20%)",
                                "Referência adequada a Lyshevski (10%)",
                                "Capacidade de simulação prática (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Arquitetura de hardware.",
                                "Programação: Linguagens embarcadas e ladder logic.",
                                "Engenharia Mecânica: Integração em atuadores e sensores.",
                                "Automação Industrial: Normas IEC 61131.",
                                "Física: Sinais digitais e temporização."
                              ],
                              "realWorldApplication": "Na indústria automotiva, microcontroladores gerenciam ECUs em veículos; CLPs controlam linhas de montagem; microprocessadores processam dados em sistemas de IA para inspeção de qualidade."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Introduzir sistemas de visão por computador",
                            "description": "Explicar princípios básicos de visão computacional e sua integração em projetos mecatrônicos para automação industrial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Básicos de Visão Computacional",
                                  "subSteps": [
                                    "Estude os conceitos fundamentais: aquisição de imagem, pré-processamento (filtro de ruído, binarização), detecção de características (bordas, cantos) e segmentação.",
                                    "Analise o fluxo de processamento de imagem: captura → processamento → análise → decisão.",
                                    "Explore algoritmos básicos como Canny Edge Detection e thresholding.",
                                    "Discuta diferenças entre visão computacional e sensores tradicionais (ex.: proximidade vs. inspeção visual).",
                                    "Revise aplicações iniciais em automação, como detecção de presença."
                                  ],
                                  "verification": "Resuma os princípios em um diagrama de fluxo e explique verbalmente para um colega.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Slides ou vídeo introdutório sobre visão computacional (ex.: OpenCV tutorial básico)",
                                    "Notebook para anotações",
                                    "Software gratuito como ImageJ para visualizar imagens"
                                  ],
                                  "tips": "Use imagens reais de fábrica para ilustrar conceitos e evite sobrecarregar com matemática avançada inicialmente.",
                                  "learningObjective": "Identificar e descrever os passos fundamentais do processamento de visão computacional.",
                                  "commonMistakes": [
                                    "Confundir visão computacional com visão humana (falta de contexto 3D)",
                                    "Ignorar ruído em imagens reais",
                                    "Pular pré-processamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Componentes de um Sistema de Visão por Computador",
                                  "subSteps": [
                                    "Liste hardware essencial: câmeras (USB, industrial), iluminação (LEDs controlados), lentes e suportes.",
                                    "Descreva software: bibliotecas como OpenCV ou Halcon, interfaces com PLCs.",
                                    "Monte um diagrama de blocos de um sistema completo: sensor → processador → atuador.",
                                    "Teste uma câmera simples conectada a um PC para captura de imagem.",
                                    "Avalie fatores ambientais: vibração, poeira em contextos industriais."
                                  ],
                                  "verification": "Crie um esquema anotado dos componentes e demonstre captura de imagem ao vivo.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Câmera USB básica",
                                    "Computador com Python e OpenCV instalados",
                                    "Iluminação LED simples",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Escolha câmeras com alta taxa de frames para aplicações em tempo real; teste em condições de pouca luz.",
                                  "learningObjective": "Montar e descrever os componentes hardware e software de um sistema de visão.",
                                  "commonMistakes": [
                                    "Subestimar iluminação (causa sombras falsas)",
                                    "Escolher câmeras sem calibração",
                                    "Ignorar latência de processamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Sistemas de Visão em Projetos Mecatrônicos",
                                  "subSteps": [
                                    "Estude protocolos de comunicação: Ethernet/IP, Modbus para conectar visão a PLCs ou microcontroladores.",
                                    "Implemente um script simples em Python/OpenCV para detecção de objeto e envio de sinal.",
                                    "Integre com atuadores mecatrônicos: ex., sinal para esteira ou braço robótico.",
                                    "Calibre o sistema para precisão (distância focal, distorção).",
                                    "Teste loop fechado: visão detecta → PLC atua → feedback visual."
                                  ],
                                  "verification": "Execute um teste integrado onde a visão controla um LED ou motor simples baseado em detecção.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Arduino ou PLC simulado (ex.: Node-RED)",
                                    "Câmera e PC",
                                    "Componentes mecatrônicos básicos (motor, sensor)",
                                    "Cabo Ethernet/USB"
                                  ],
                                  "tips": "Use threads em Python para processamento em tempo real; sincronize clocks entre visão e controle.",
                                  "learningObjective": "Desenvolver uma integração básica de visão computacional com hardware mecatrônico.",
                                  "commonMistakes": [
                                    "Falta de sincronização temporal",
                                    "Overfitting em um ambiente (falha em produção)",
                                    "Protocolos incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Automação Industrial e Avaliar Desempenho",
                                  "subSteps": [
                                    "Simule cenários industriais: inspeção de defeitos em peças, orientação de robôs.",
                                    "Meça métricas: precisão, recall, tempo de ciclo.",
                                    "Otimize código para robustez (multi-threading, ROI cropping).",
                                    "Documente limitações e melhorias (IA para reconhecimento avançado).",
                                    "Planeje escalabilidade para produção real."
                                  ],
                                  "verification": "Apresente um relatório com vídeo de demonstração e métricas de performance.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Peças de teste (ex.: parafusos variados)",
                                    "Software de gravação de vídeo",
                                    "Ferramentas de medição (stopwatch, planilha Excel)"
                                  ],
                                  "tips": "Registre dados em CSV para análise; considere variações de produção como peças giradas.",
                                  "learningObjective": "Avaliar e otimizar um sistema de visão em contexto de automação industrial.",
                                  "commonMistakes": [
                                    "Testar só em condições ideais",
                                    "Ignorar custo de hardware industrial",
                                    "Falta de validação estatística"
                                  ]
                                }
                              ],
                              "practicalExample": "Integre uma câmera USB com OpenCV em um braço robótico mecatrônico para detectar e classificar peças em uma esteira simulada, enviando comandos via serial para pick-and-place baseado na cor e forma detectadas.",
                              "finalVerifications": [
                                "Explicar o pipeline completo de visão computacional em um projeto mecatrônico.",
                                "Demonstrar detecção em tempo real com hardware real.",
                                "Identificar e corrigir um erro comum em setup de câmera.",
                                "Calcular precisão de detecção em um teste com 20 amostras.",
                                "Desenhar diagrama de integração visão-PLC-atuador.",
                                "Discutir trade-offs de hardware (custo vs. performance)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 90% de acerto em quiz sobre princípios.",
                                "Habilidade prática: Sucesso em demo integrada sem falhas críticas.",
                                "Profundidade de análise: Identificação de 3+ limitações reais.",
                                "Criatividade: Sugestão de aplicação personalizada.",
                                "Documentação: Relatório claro com diagramas e código comentado.",
                                "Tempo de execução: Cumprir prazos com qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de Python/OpenCV para processamento.",
                                "Eletrônica: Interfaces com sensores e PLCs.",
                                "Matemática: Álgebra linear para transformações de imagem.",
                                "Física: Óptica e iluminação em câmeras.",
                                "Gestão de Projetos: Planejamento de integração em mecatrônica."
                              ],
                              "realWorldApplication": "Em fábricas automotivas, sistemas de visão inspecionam soldas em chassis em tempo real, rejeitando peças defeituosas e integrando com robôs para correção automática, reduzindo desperdícios em 30%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Explorar robótica mecatrônica aeronáutica",
                            "description": "Analisar aplicações de robótica mecatrônica na indústria aeronáutica, incluindo exemplos de Shetty e Kolk (1997).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Robótica Mecatrônica",
                                  "subSteps": [
                                    "Definir robótica mecatrônica como integração de mecânica, eletrônica, controle e computação.",
                                    "Identificar componentes chave: atuadores, sensores, microcontroladores e software de controle.",
                                    "Explicar princípios de feedback e controle PID aplicados em sistemas robóticos.",
                                    "Revisar evolução histórica da mecatrônica na robótica.",
                                    "Mapear como esses fundamentos se aplicam a ambientes aeronáuticos."
                                  ],
                                  "verification": "Criar um diagrama conceitual dos componentes mecatrônicos e sua integração.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livros de mecatrônica (ex: Shetty e Kolk, 1997), vídeos introdutórios no YouTube, software de diagramação como Draw.io.",
                                  "tips": "Use analogias com sistemas biológicos, como membros robóticos simulando movimentos de aves.",
                                  "learningObjective": "Dominar os pilares da robótica mecatrônica para contextualizar aplicações aeronáuticas.",
                                  "commonMistakes": "Confundir mecatrônica com robótica pura, ignorando integração multidisciplinar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Aplicações Gerais na Indústria Aeronáutica",
                                  "subSteps": [
                                    "Listar usos: montagem de fuselagens, inspeção de turbinas, soldagem automatizada e testes de fadiga.",
                                    "Estudar robôs colaborativos (cobots) em linhas de produção da Boeing ou Airbus.",
                                    "Examinar desafios: precisão em ambientes de alta vibração e conformidade com normas FAA.",
                                    "Comparar robótica tradicional vs. mecatrônica avançada em eficiência e segurança.",
                                    "Documentar métricas de performance, como ciclo de produção reduzido em 30%."
                                  ],
                                  "verification": "Elaborar uma tabela comparativa de aplicações com prós e contras.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Artigos da IEEE Aerospace, relatórios da Airbus/Boeing, acesso a bases como Google Scholar.",
                                  "tips": "Foque em vídeos de fábricas reais para visualizar aplicações dinâmicas.",
                                  "learningObjective": "Identificar contextos específicos onde robótica mecatrônica otimiza processos aeronáuticos.",
                                  "commonMistakes": "Subestimar restrições regulatórias aeronáuticas, como certificação de materiais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Exemplos Específicos de Shetty e Kolk (1997)",
                                  "subSteps": [
                                    "Ler capítulos relevantes do livro 'Mechatronics System Design' de Shetty e Kolk sobre robótica.",
                                    "Analisar casos de estudo: braços robóticos para montagem de componentes leves em aeronaves.",
                                    "Extrair lições: modelagem dinâmica, simulação e prototipagem integrada.",
                                    "Replicar um exemplo simplificado usando software de simulação.",
                                    "Discutir limitações e avanços pós-1997, como IA em controles."
                                  ],
                                  "verification": "Resumir em relatório de 2 páginas os insights chave do livro aplicados à aeronáutica.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Cópia digital/PDF de Shetty e Kolk (1997), MATLAB/Simulink para simulações.",
                                  "tips": "Anote citações diretas para precisão acadêmica.",
                                  "learningObjective": "Aplicar referências clássicas para análise crítica de robótica mecatrônica aeronáutica.",
                                  "commonMistakes": "Interpretar exemplos fora de contexto histórico, ignorando evoluções tecnológicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Casos Práticos e Simulações",
                                  "subSteps": [
                                    "Simular um robô mecatrônico inspecionando asas de aeronave via ROS ou Gazebo.",
                                    "Analisar dados de sensores: visão computacional para detecção de defeitos.",
                                    "Avaliar integração com sistemas aeronáuticos existentes, como PLCs industriais.",
                                    "Testar cenários de falha e recuperação autônoma.",
                                    "Propor melhorias baseadas em análise."
                                  ],
                                  "verification": "Gravar e demonstrar uma simulação funcional com relatório de resultados.",
                                  "estimatedTime": "7 horas",
                                  "materials": "Software gratuito: ROS, Gazebo, Python para scripts; hardware opcional como Arduino.",
                                  "tips": "Comece com simulações 2D antes de 3D para eficiência.",
                                  "learningObjective": "Desenvolver habilidades práticas em prototipagem virtual de robótica aeronáutica.",
                                  "commonMistakes": "Negligenciar calibração de sensores, levando a dados imprecisos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Análise e Propor Inovações",
                                  "subSteps": [
                                    "Compilar achados em um framework de análise SWOT para robótica mecatrônica aeronáutica.",
                                    "Propor aplicação inovadora, como drones mecatrônicos para manutenção in-flight.",
                                    "Discutir impactos éticos e sustentáveis: redução de emissões via automação.",
                                    "Preparar apresentação com visualizações.",
                                    "Autoavaliar compreensão com quiz interno."
                                  ],
                                  "verification": "Produzir apresentação em slides (10-15) com referências.",
                                  "estimatedTime": "4 horas",
                                  "materials": "PowerPoint/Google Slides, ferramentas de design como Canva.",
                                  "tips": "Use gráficos para ilustrar métricas quantitativas.",
                                  "learningObjective": "Integrar conhecimentos para análise crítica e inovação.",
                                  "commonMistakes": "Focar apenas em teoria sem ligar a impactos reais."
                                }
                              ],
                              "practicalExample": "Desenvolver um braço robótico mecatrônico simulado para soldagem precisa de painéis de fuselagem em uma linha de produção da Embraer, integrando sensores de visão e controle adaptativo para compensar vibrações, reduzindo tempo de montagem em 25%.",
                              "finalVerifications": [
                                "Diagrama completo de componentes mecatrônicos aeronáuticos criado.",
                                "Relatório detalhado sobre Shetty e Kolk com pelo menos 5 citações.",
                                "Simulação funcional executada e documentada.",
                                "Análise SWOT elaborada com evidências.",
                                "Apresentação final com conexões interdisciplinares.",
                                "Autoavaliação mostrando domínio de 90% dos conceitos."
                              ],
                              "assessmentCriteria": [
                                "Profundidade na análise de Shetty e Kolk (30%)",
                                "Precisão técnica em aplicações aeronáuticas (25%)",
                                "Criatividade em exemplos práticos e simulações (20%)",
                                "Qualidade de verificações e documentação (15%)",
                                "Integração de conexões interdisciplinares (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica e controle de sistemas vibracionais.",
                                "Programação: Algoritmos de controle em Python/ROS.",
                                "Engenharia de Materiais: Seleção de ligas leves para robótica.",
                                "Gestão de Projetos: Ciclos ágeis em desenvolvimento mecatrônico.",
                                "Ética e Sustentabilidade: Impactos ambientais da automação."
                              ],
                              "realWorldApplication": "Na manufatura de aviões comerciais, robôs mecatrônicos como os da KUKA na Airbus automatizam inspeções e montagens, aumentando precisão, reduzindo custos operacionais em até 40% e minimizando erros humanos em ambientes críticos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.4",
                            "name": "Integrar componentes em projetos reais",
                            "description": "Desenvolver um exemplo simples de integração de microcontroladores com visão e robótica em um protótipo mecatrônico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejamento e Design do Protótipo",
                                  "subSteps": [
                                    "Defina os requisitos funcionais do protótipo, como detecção de um objeto colorido via câmera e movimento de um atuador robótico.",
                                    "Crie um diagrama esquemático do sistema, incluindo conexões entre microcontrolador, módulo de visão e componentes robóticos.",
                                    "Selecione componentes compatíveis e liste os materiais necessários.",
                                    "Desenhe um fluxograma do algoritmo de integração.",
                                    "Estime riscos e soluções alternativas."
                                  ],
                                  "verification": "Diagrama esquemático e fluxograma completos e revisados por pares.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel ou software de diagramação (Draw.io), lista de componentes"
                                  ],
                                  "tips": "Use ferramentas gratuitas como Fritzing para esquemáticos elétricos.",
                                  "learningObjective": "Compreender a importância do planejamento para evitar erros de integração.",
                                  "commonMistakes": "Ignorar compatibilidade de tensões entre componentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montagem e Configuração do Hardware",
                                  "subSteps": [
                                    "Monte o microcontrolador (ex: Raspberry Pi ou Arduino) na base mecatrônica.",
                                    "Conecte o módulo de visão (ex: Pi Camera ou ESP32-CAM) ao microcontrolador.",
                                    "Instale atuadores robóticos (ex: servos ou motores DC) com drivers adequados.",
                                    "Realize soldas ou conexões jumper seguras e teste continuidade com multímetro.",
                                    "Fixe todos os componentes em uma estrutura protótipo estável."
                                  ],
                                  "verification": "Alimentação ligada sem curtos-circuitos e LEDs de status acesos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Microcontrolador, módulo de câmera, servos/motores, protoboard, fios jumper, multímetro, estrutura base (chassi ou caixa)"
                                  ],
                                  "tips": "Use protoboard para protótipos rápidos e evite soldas permanentes inicialmente.",
                                  "learningObjective": "Dominar conexões físicas seguras entre componentes mecatrônicos.",
                                  "commonMistakes": "Conexões invertidas de polaridade causando danos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolvimento de Software Individual",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias (ex: OpenCV para visão, Servo library para atuadores).",
                                    "Escreva e teste código para captura de imagem e processamento de visão básico (detecção de cor).",
                                    "Desenvolva e teste código independente para controle de atuadores robóticos.",
                                    "Compile e faça upload para o microcontrolador, verificando erros de sintaxe.",
                                    "Execute testes unitários em cada módulo separadamente."
                                  ],
                                  "verification": "Códigos individuais funcionam isoladamente (visão detecta cor, servo se move).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Computador com IDE (Arduino IDE ou Thonny), bibliotecas OpenCV/PiCamera"
                                  ],
                                  "tips": "Use Serial Monitor para debug de valores de sensores.",
                                  "learningObjective": "Criar módulos de software modulares e testáveis.",
                                  "commonMistakes": "Bibliotecas incompatíveis com a versão do microcontrolador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração de Software e Hardware",
                                  "subSteps": [
                                    "Combine códigos de visão e robótica em um programa principal com comunicação (ex: I2C ou UART).",
                                    "Implemente loop principal com lógica condicional: detectar objeto → acionar movimento.",
                                    "Ajuste parâmetros de visão (thresholds de cor) e controle PID para atuadores.",
                                    "Faça upload do código integrado e teste inicial com baixa velocidade.",
                                    "Registre logs de execução para análise."
                                  ],
                                  "verification": "Sistema responde corretamente a estímulos (detecta e move).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "IDE de programação, cabo USB para upload"
                                  ],
                                  "tips": "Modularize o código em funções para facilitar depuração.",
                                  "learningObjective": "Integrar fluxos de dados entre visão, controle e atuadores.",
                                  "commonMistakes": "Loops infinitos sem delays causando travamentos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes, Depuração e Otimização",
                                  "subSteps": [
                                    "Execute testes em cenários variados (iluminação diferente, objetos múltiplos).",
                                    "Identifique e corrija bugs usando debug tools (printfs, osciloscópio).",
                                    "Otimize performance (reduza latência de visão, suavize movimentos).",
                                    "Documente o protótipo com fotos, código fonte e relatório.",
                                    "Realize teste final end-to-end."
                                  ],
                                  "verification": "Protótipo opera consistentemente por 10 minutos sem falhas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Objetos de teste, ferramentas de medição (osciloscópio opcional)"
                                  ],
                                  "tips": "Grave vídeos dos testes para análise posterior.",
                                  "learningObjective": "Aplicar metodologias de teste para validar integrações complexas.",
                                  "commonMistakes": "Testes apenas em condições ideais, ignorando variações reais."
                                }
                              ],
                              "practicalExample": "Construa um braço robótico simples com Raspberry Pi, Pi Camera para detectar uma bola vermelha e um servo motor para girar e 'pegar' a bola, simulando uma tarefa de pick-and-place em linha de produção.",
                              "finalVerifications": [
                                "O sistema detecta corretamente objetos-alvo em diferentes condições de luz.",
                                "Atuadores respondem com precisão à detecção de visão (erro < 5 cm).",
                                "Todo o protótipo opera sem superaquecimento ou falhas por 15 minutos.",
                                "Código roda sem erros e logs mostram processamento fluido.",
                                "Estrutura mecatrônica suporta vibrações e movimentos repetidos.",
                                "Integração permite escalabilidade para mais sensores."
                              ],
                              "assessmentCriteria": [
                                "Funcionalidade completa: detecção + ação integrada (30%)",
                                "Robustez e confiabilidade em testes variados (25%)",
                                "Eficiência do código e hardware (20%)",
                                "Documentação clara e reprodutível (15%)",
                                "Criatividade na resolução de problemas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos de visão computacional e controle.",
                                "Eletrônica: Interfaces de comunicação (I2C, UART).",
                                "Mecânica: Design de estruturas e cinemática de atuadores.",
                                "Matemática: Processamento de imagens e filtros.",
                                "Física: Sensores ópticos e dinâmica de movimento."
                              ],
                              "realWorldApplication": "Em indústrias como automotiva e manufatura, para robôs de inspeção visual e montagem automatizada, reduzindo erros humanos e aumentando eficiência em linhas de produção."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Introdução a Sistemas de Visão por Computador",
                    "description": "Conceitos básicos de visão computacional aplicados em projetos mecatrônicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Fundamentos da Visão Computacional",
                        "description": "Apresentação dos conceitos básicos de visão computacional, incluindo definição, importância e componentes principais de um sistema de visão por computador aplicado em projetos mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Definir Visão Computacional",
                            "description": "Explicar o que é visão computacional, diferenciando-a de visão humana, e destacar sua relevância em sistemas mecatrônicos para automação e inspeção industrial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Visão Computacional",
                                  "subSteps": [
                                    "Pesquisar definições padrão de visão computacional em fontes confiáveis como Wikipedia ou artigos acadêmicos.",
                                    "Identificar que visão computacional é um ramo da inteligência artificial que permite a máquinas interpretar e entender imagens e vídeos.",
                                    "Anotar os componentes principais: aquisição de imagem, processamento e análise.",
                                    "Assistir a um vídeo introdutório de 5 minutos sobre o tema.",
                                    "Resumir o conceito em suas próprias palavras."
                                  ],
                                  "verification": "Escrever um parágrafo de definição clara e compartilhar com um colega para feedback.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Vídeo introdutório no YouTube (ex: 'What is Computer Vision?')",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use analogias simples como 'olhos da máquina' para fixar o conceito.",
                                  "learningObjective": "Definir visão computacional com precisão, incluindo seus objetivos principais.",
                                  "commonMistakes": [
                                    "Confundir visão computacional apenas com câmeras, ignorando o processamento.",
                                    "Pensar que é sinônimo de fotografia digital."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Visão Computacional da Visão Humana",
                                  "subSteps": [
                                    "Listar características da visão humana: percepção contextual, adaptação a luz, reconhecimento intuitivo.",
                                    "Comparar com visão computacional: depende de algoritmos, sensível a ruído, requer treinamento de dados.",
                                    "Criar uma tabela comparativa com pelo menos 5 diferenças (ex: flexibilidade vs. rigidez).",
                                    "Analisar limitações da visão computacional, como ilusões ópticas que enganam máquinas mas não humanos.",
                                    "Discutir vantagens da visão computacional, como velocidade e precisão em tarefas repetitivas."
                                  ],
                                  "verification": "Apresentar a tabela comparativa e explicar verbalmente 3 diferenças chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Imagens de ilusões ópticas (internet)",
                                    "Artigos sobre limitações da CV"
                                  ],
                                  "tips": "Foque em aspectos biológicos vs. algorítmicos para uma diferenciação clara.",
                                  "learningObjective": "Distinguir com clareza as capacidades e limitações entre visão humana e computacional.",
                                  "commonMistakes": [
                                    "Superestimar a visão computacional como idêntica à humana.",
                                    "Ignorar que humanos usam contexto semântico implícito."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar os Processos Fundamentais da Visão Computacional",
                                  "subSteps": [
                                    "Estudar os passos principais: pré-processamento (filtragem), detecção de features, segmentação e reconhecimento.",
                                    "Visualizar fluxogramas de um pipeline de visão computacional.",
                                    "Experimentar com uma ferramenta online simples de processamento de imagem (ex: filtro em Photopea).",
                                    "Anotar como cada processo simula etapas da visão humana de forma algorítmica.",
                                    "Relacionar com hardware: câmeras, sensores CCD/CMOS."
                                  ],
                                  "verification": "Desenhar e rotular um fluxograma simples do processo de visão computacional.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta online como Photopea ou ImageJ",
                                    "Imagens de teste",
                                    "Vídeo sobre pipeline de CV"
                                  ],
                                  "tips": "Comece com imagens simples como formas geométricas para entender detecção.",
                                  "learningObjective": "Descrever os processos chave envolvidos na visão computacional.",
                                  "commonMistakes": [
                                    "Pular pré-processamento, achando que é só 'ver'.",
                                    "Confundir segmentação com classificação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar a Relevância em Sistemas Mecatrônicos",
                                  "subSteps": [
                                    "Pesquisar aplicações em automação: robótica, inspeção de qualidade.",
                                    "Exemplificar em mecatrônica: detecção de defeitos em linhas de montagem.",
                                    "Analisar integração com atuadores e controladores em sistemas mecatrônicos.",
                                    "Discutir benefícios: redução de erros humanos, aumento de eficiência.",
                                    "Prever tendências futuras como visão em tempo real com IA."
                                  ],
                                  "verification": "Escrever um texto curto (100 palavras) sobre relevância em mecatrônica com 2 exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigos sobre CV em indústria 4.0",
                                    "Vídeos de inspeção industrial",
                                    "Caderno"
                                  ],
                                  "tips": "Ligue sempre a contextos práticos como fábricas para relevância.",
                                  "learningObjective": "Explicar a importância da visão computacional em automação e inspeção mecatrônica.",
                                  "commonMistakes": [
                                    "Focar só em aplicações gerais, ignorando mecatrônica.",
                                    "Subestimar integração com sensores físicos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de produção de parafusos, uma câmera captura imagens; o software de visão computacional processa para detectar parafusos tortos (diferente da visão humana que pode cansar), sinalizando para um braço robótico remover o defeituoso, garantindo qualidade automatizada.",
                              "finalVerifications": [
                                "Fornecer definição precisa de visão computacional.",
                                "Listar pelo menos 3 diferenças claras com visão humana.",
                                "Desenhar fluxograma de processos fundamentais.",
                                "Explicar 2 aplicações específicas em mecatrônica.",
                                "Discutir limitações e vantagens corretamente.",
                                "Resumir relevância para automação industrial."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da definição (0-5 pontos).",
                                "Clareza na diferenciação com visão humana (0-5).",
                                "Detalhamento dos processos fundamentais (0-5).",
                                "Relevância contextualizada em mecatrônica (0-5).",
                                "Uso de exemplos práticos e verificações (0-5).",
                                "Ausência de erros conceituais (0-5)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e estatística para processamento de imagens.",
                                "Física: Óptica, sensores e propriedades da luz.",
                                "Informática: Algoritmos de IA e programação em Python/OpenCV.",
                                "Engenharia Mecânica: Integração com robótica e sistemas de controle.",
                                "Biologia: Analogias com sistema visual humano."
                              ],
                              "realWorldApplication": "Na indústria automotiva, sistemas de visão computacional inspecionam soldas em chassis de carros em tempo real, detectando microfissuras invisíveis a olho nu, reduzindo recalls e otimizando produção em fábricas como as da Toyota ou Volkswagen."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Identificar Componentes de um Sistema de Visão",
                            "description": "Listar e descrever os componentes essenciais como câmeras, iluminação, processadores e software, relacionando-os à integração em projetos mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Listar os componentes essenciais de um sistema de visão",
                                  "subSteps": [
                                    "Pesquise a definição de um sistema de visão computacional em fontes confiáveis.",
                                    "Identifique os componentes de hardware principal: câmeras e iluminação.",
                                    "Identifique os componentes de processamento: processadores e software.",
                                    "Anote todos os componentes em uma lista organizada.",
                                    "Classifique-os em categorias (aquisição de imagem, processamento e integração)."
                                  ],
                                  "verification": "Verifique se a lista contém pelo menos câmeras, iluminação, processadores e software, com classificações corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet ou livro de mecatrônica",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": [
                                    "Priorize componentes essenciais; evite listar periféricos desnecessários.",
                                    "Use diagramas simples para visualizar a lista."
                                  ],
                                  "learningObjective": "Reconhecer e listar os quatro componentes fundamentais de um sistema de visão.",
                                  "commonMistakes": [
                                    "Incluir componentes não essenciais como monitores",
                                    "Esquecer o software como componente crítico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever as funções de cada componente",
                                  "subSteps": [
                                    "Descreva a função da câmera: captura de imagens ou vídeo.",
                                    "Explique a iluminação: fornece luz controlada para imagens de qualidade.",
                                    "Detalhe o processador: executa algoritmos de processamento de imagem.",
                                    "Descreva o software: gerencia aquisição, processamento e análise de dados.",
                                    "Relacione brevemente cada um ao fluxo de dados no sistema."
                                  ],
                                  "verification": "Cada componente tem uma descrição de 2-3 frases claras e precisas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas da lista anterior",
                                    "Referências técnicas online sobre visão computacional"
                                  ],
                                  "tips": [
                                    "Use termos técnicos como 'resolução' para câmeras e 'FPS' para processadores.",
                                    "Inclua exemplos simples de uso."
                                  ],
                                  "learningObjective": "Compreender o papel específico de cada componente no sistema.",
                                  "commonMistakes": [
                                    "Confundir funções de hardware com software",
                                    "Descrições vagas sem menção a integração de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar as interações entre componentes",
                                  "subSteps": [
                                    "Desenhe um diagrama de fluxo mostrando como a câmera envia dados para o processador.",
                                    "Explique como a iluminação afeta a qualidade da entrada da câmera.",
                                    "Descreva o papel do software na comunicação entre processador e outros sistemas.",
                                    "Identifique pontos de falha comuns nas interações.",
                                    "Teste o diagrama verbalizando o fluxo completo."
                                  ],
                                  "verification": "Diagrama completo com setas indicando fluxo de dados e descrições de interações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io ou papel",
                                    "Notas dos passos anteriores"
                                  ],
                                  "tips": [
                                    "Pense no sistema como uma linha de produção: entrada → processamento → saída.",
                                    "Marque dependências com linhas tracejadas."
                                  ],
                                  "learningObjective": "Entender como os componentes se integram para formar um sistema funcional.",
                                  "commonMistakes": [
                                    "Ignorar dependências, como iluminação na câmera",
                                    "Diagrama sem fluxo lógico de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar componentes à integração em projetos mecatrônicos",
                                  "subSteps": [
                                    "Identifique como integrar o sistema de visão com atuadores mecatrônicos (ex: robôs).",
                                    "Descreva cenários de uso em projetos, como inspeção automatizada.",
                                    "Liste interfaces necessárias (ex: APIs para software, conexões elétricas).",
                                    "Crie um exemplo de projeto simples incorporando todos os componentes.",
                                    "Avalie benefícios para mecatrônica, como automação."
                                  ],
                                  "verification": "Exemplo de projeto com todos os componentes integrados e pelo menos duas interfaces descritas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de projetos mecatrônicos online",
                                    "Ferramenta de diagramação"
                                  ],
                                  "tips": [
                                    "Considere protocolos como USB para câmeras e Ethernet para processadores.",
                                    "Enfatize escalabilidade em projetos reais."
                                  ],
                                  "learningObjective": "Aplicar o conhecimento de componentes em contextos mecatrônicos integrados.",
                                  "commonMistakes": [
                                    "Focar só em visão isolada, sem integração mecatrônica",
                                    "Esquecer interfaces de comunicação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Revisar e sintetizar o conhecimento",
                                  "subSteps": [
                                    "Revise todas as listas, descrições e diagramas criados.",
                                    "Crie um resumo em uma página única.",
                                    "Responda a perguntas de autoavaliação sobre cada componente.",
                                    "Compare com um sistema de visão real de referência.",
                                    "Ajuste qualquer imprecisão encontrada."
                                  ],
                                  "verification": "Resumo completo e autoavaliação com 100% de acertos em perguntas chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Todos os materiais e notas anteriores",
                                    "Referência de sistema de visão real (vídeo ou artigo)"
                                  ],
                                  "tips": [
                                    "Use flashcards para memorização rápida.",
                                    "Grave um vídeo curto explicando para reforçar."
                                  ],
                                  "learningObjective": "Consolidar o aprendizado para retenção e aplicação futura.",
                                  "commonMistakes": [
                                    "Pular revisões, levando a memorização superficial",
                                    "Ignorar referências reais para validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto mecatrônico de inspeção de peças em linha de produção, a câmera industrial captura imagens de uma peça sob iluminação LED controlada; o processador embarcado (como Raspberry Pi) executa software OpenCV para detectar defeitos; resultados são enviados via interface serial para um braço robótico descartar peças ruins, integrando visão ao sistema completo.",
                              "finalVerifications": [
                                "Lista todos os componentes essenciais corretamente (câmera, iluminação, processador, software).",
                                "Descreve funções com precisão técnica em pelo menos 80% dos itens.",
                                "Apresenta diagrama de fluxo com interações claras.",
                                "Relaciona adequadamente a projetos mecatrônicos com exemplo viável.",
                                "Resumo sintetiza o aprendizado sem erros factuais."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos os componentes e interações cobertos (30%).",
                                "Precisão técnica: Termos e funções corretos (25%).",
                                "Profundidade: Subpassos detalhados e exemplos concretos (20%).",
                                "Criatividade na integração mecatrônica (15%).",
                                "Clareza e organização dos diagramas/resumos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Seleção e conexão de câmeras e iluminação.",
                                "Programação: Desenvolvimento de algoritmos em software de visão (ex: Python/OpenCV).",
                                "Mecânica: Montagem física e calibração em sistemas robóticos.",
                                "Física: Princípios ópticos na iluminação e captura de imagem.",
                                "Matemática: Processamento de imagens com álgebra linear."
                              ],
                              "realWorldApplication": "Sistemas de visão são usados em indústrias automotivas para inspeção de soldas, em agricultura para colheita autônoma via drones, e em robótica colaborativa para detecção de obstáculos, otimizando processos mecatrônicos e reduzindo erros humanos em até 90%."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Explicar o Pipeline de Processamento",
                            "description": "Descrever o fluxo básico de processamento em visão computacional: aquisição, pré-processamento, análise e saída de decisão, com exemplos mecatrônicos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Etapa de Aquisição de Imagem",
                                  "subSteps": [
                                    "Identificar fontes de imagem: câmeras CCD, CMOS ou webcams comuns em mecatrônica.",
                                    "Explicar parâmetros chave: resolução, taxa de frames (FPS) e iluminação controlada.",
                                    "Discutir exemplos mecatrônicos: captura de peças em esteiras rolantes.",
                                    "Analisar impacto da qualidade da aquisição no pipeline inteiro.",
                                    "Listar sensores típicos em sistemas industriais como câmeras infravermelhas."
                                  ],
                                  "verification": "Descrever verbalmente ou diagramar 3 sensores e seus papéis na aquisição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Computador com webcam, imagens de exemplo, diagrama de sensores impresso.",
                                  "tips": "Teste a webcam em diferentes luzes para ver efeitos reais.",
                                  "learningObjective": "Compreender como imagens são capturadas e fatores que afetam sua qualidade inicial.",
                                  "commonMistakes": "Confundir aquisição com análise; aquisição é apenas a captura bruta."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o Pré-processamento da Imagem",
                                  "subSteps": [
                                    "Aplicar filtros para redução de ruído: Gaussian blur ou mediana.",
                                    "Realizar normalização de intensidade e correção de iluminação.",
                                    "Executar segmentação básica: threshold ou edge detection com Canny.",
                                    "Ajustar tamanho da imagem via redimensionamento ou cropping.",
                                    "Exemplo mecatrônico: limpar ruído de vibrações em imagens de esteiras."
                                  ],
                                  "verification": "Processar uma imagem de exemplo e mostrar antes/depois visualmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software OpenCV (Python), imagens de teste com ruído.",
                                  "tips": "Use histogramas para visualizar melhorias no contraste.",
                                  "learningObjective": "Aprender técnicas para preparar imagens cruas para análise eficaz.",
                                  "commonMistakes": "Aplicar filtros excessivos, perdendo detalhes importantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Etapa de Análise e Extração de Features",
                                  "subSteps": [
                                    "Identificar features: contornos, blobs ou keypoints com SIFT/Harris.",
                                    "Aplicar segmentação avançada: watershed ou clustering K-means.",
                                    "Realizar detecção de objetos simples via template matching.",
                                    "Exemplo mecatrônico: detectar posição de parafusos em montagem.",
                                    "Interpretar resultados: medir dimensões ou formas geométricas."
                                  ],
                                  "verification": "Extrair e rotular features de uma imagem de peça mecânica.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ambiente Python com OpenCV e NumPy, conjunto de imagens industriais.",
                                  "tips": "Comece com imagens simples para validar algoritmos antes de complexas.",
                                  "learningObjective": "Capacitar na extração de informações relevantes das imagens pré-processadas.",
                                  "commonMistakes": "Ignorar variações de escala ou rotação nas features."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender a Saída de Decisão e Integração",
                                  "subSteps": [
                                    "Definir regras de decisão: thresholds baseados em features extraídas.",
                                    "Classificar resultados: bom/ruim ou coordenadas para ação robótica.",
                                    "Integrar com atuadores mecatrônicos: sinal para PLC ou motor.",
                                    "Exemplo: rejeitar peça defeituosa ativando braço robótico.",
                                    "Avaliar pipeline completo com métricas como acurácia."
                                  ],
                                  "verification": "Simular decisão final em um fluxograma ou código simples.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Diagrama de pipeline, simulador básico como Arduino com câmera.",
                                  "tips": "Pense em feedback loops para pipelines adaptativos.",
                                  "learningObjective": "Integrar análise em ações concretas no sistema mecatrônico.",
                                  "commonMistakes": "Decisões isoladas sem considerar contexto do sistema inteiro."
                                }
                              ],
                              "practicalExample": "Em uma linha de produção mecatrônica de parafusos: (1) Câmera adquire imagem da peça na esteira; (2) Pré-processa removendo ruído de vibração; (3) Analisa presença e alinhamento do parafuso; (4) Decide aprovar (esteira avança) ou rejeitar (braço pneumático remove).",
                              "finalVerifications": [
                                "Diagramar o pipeline completo com 4 etapas e setas de fluxo.",
                                "Explicar cada etapa usando o exemplo de inspeção de parafusos.",
                                "Identificar 3 problemas potenciais em cada etapa e soluções.",
                                "Simular o pipeline com software simples (ex: OpenCV).",
                                "Descrever integração com hardware mecatrônico.",
                                "Listar métricas de performance como FPS e acurácia."
                              ],
                              "assessmentCriteria": [
                                "Precisão e sequência correta das 4 etapas do pipeline.",
                                "Uso de exemplos mecatrônicos relevantes e concretos.",
                                "Detalhe nos sub-processos e verificações por etapa.",
                                "Clareza na descrição de integrações hardware/software.",
                                "Identificação de erros comuns e dicas preventivas.",
                                "Completude do fluxograma ou simulação prática."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/OpenCV para automação.",
                                "Eletrônica: Integração com sensores e PLCs industriais.",
                                "Mecânica: Aplicação em robótica e esteiras transportadoras.",
                                "Matemática: Algoritmos de filtragem e estatística em features.",
                                "Física: Óptica e iluminação em aquisição de imagens."
                              ],
                              "realWorldApplication": "Inspeção de qualidade em indústrias automotivas, onde sistemas de visão detectam defeitos em peças soldadas em tempo real, integrando com robôs para correção automática, reduzindo desperdícios em linhas de montagem."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Processamento Básico de Imagens",
                        "description": "Estudo das etapas iniciais de processamento de imagens digitais, como filtragem, segmentação e extração de características, adaptadas para aplicações mecatrônicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Realizar Aquisição de Imagens",
                            "description": "Compreender métodos de captura de imagens por câmeras CCD/CMOS e fatores como resolução e frame rate em contextos mecatrônicos industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Princípios de Sensores CCD e CMOS",
                                  "subSteps": [
                                    "Estudar a estrutura física e o processo de captura de luz em sensores CCD (transferência de carga).",
                                    "Analisar o funcionamento pixel-independente dos sensores CMOS e sua leitura paralela.",
                                    "Comparar vantagens (ex.: sensibilidade em baixa luz para CCD) e desvantagens (ex.: custo para CMOS).",
                                    "Identificar impactos em aplicações mecatrônicas industriais, como ruído e velocidade.",
                                    "Pesquisar especificações técnicas de câmeras comerciais CCD/CMOS."
                                  ],
                                  "verification": "Criar um diagrama comparativo resumindo diferenças, vantagens e aplicações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação técnica de fabricantes (ex.: datasheets Sony/Basler)",
                                    "Vídeos educativos sobre sensores de imagem",
                                    "Notebook para diagramas"
                                  ],
                                  "tips": "Use analogias como 'CCD é como uma esteira transportadora' para fixar conceitos.",
                                  "learningObjective": "Diferenciar mecanismos de CCD e CMOS e avaliar adequação para contextos industriais.",
                                  "commonMistakes": [
                                    "Confundir transferência sequencial do CCD com leitura paralela do CMOS",
                                    "Ignorar efeitos de ruído térmico em ambientes industriais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Hardware para Aquisição de Imagens",
                                  "subSteps": [
                                    "Selecionar câmera CCD ou CMOS compatível com interface industrial (USB3, GigE).",
                                    "Conectar a câmera ao computador ou PLC mecatrônico e instalar drivers.",
                                    "Testar conexão básica e reconhecimento do dispositivo.",
                                    "Configurar alimentação e montagem física em suporte estável.",
                                    "Verificar compatibilidade com software de aquisição (ex.: OpenCV ou HALCON)."
                                  ],
                                  "verification": "Registrar log de conexão bem-sucedida e imagem de teste estática.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Câmera CCD/CMOS industrial",
                                    "Cabos USB/GigE",
                                    "Computador com software de visão",
                                    "Suporte de montagem"
                                  ],
                                  "tips": "Sempre teste em ambiente controlado antes de integrar ao sistema mecatrônico.",
                                  "learningObjective": "Preparar hardware corretamente para captura confiável de imagens.",
                                  "commonMistakes": [
                                    "Usar cabos inadequados causando perda de sinal",
                                    "Esquecer de calibrar alimentação estável"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar Parâmetros de Resolução e Frame Rate",
                                  "subSteps": [
                                    "Definir resolução desejada (ex.: 640x480 para velocidade vs. 1920x1080 para detalhe).",
                                    "Configurar frame rate considerando processamento (ex.: 30 fps para movimento).",
                                    "Ajustar exposição, ganho e balanceamento de branco para otimizar qualidade.",
                                    "Testar trade-offs: alta resolução reduz frame rate devido a largura de banda.",
                                    "Salvar perfil de configuração para reutilização em projetos mecatrônicos."
                                  ],
                                  "verification": "Capturar sequência de frames e medir resolução/frame rate com ferramenta de análise.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de configuração de câmera (ex.: Camera Control Tool)",
                                    "Monitor para visualização em tempo real"
                                  ],
                                  "tips": "Monitore temperatura da câmera, pois afeta frame rate em operações longas.",
                                  "learningObjective": "Otimizar parâmetros para equilibrar qualidade e desempenho em cenários industriais.",
                                  "commonMistakes": [
                                    "Definir resolução alta sem verificar largura de banda da interface",
                                    "Ignorar saturação em alta exposição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Aquisição e Verificar Qualidade da Imagem",
                                  "subSteps": [
                                    "Iniciar stream de aquisição em modo contínuo ou trigger.",
                                    "Capturar imagens de objeto de teste em ambiente mecatrônico simulado.",
                                    "Analisar métricas: nitidez, ruído, uniformidade de iluminação.",
                                    "Ajustar parâmetros iterativamente com base em feedback visual.",
                                    "Exportar imagens e relatar métricas para integração futura."
                                  ],
                                  "verification": "Gerar relatório com 10 imagens capturadas, métricas medidas e ajustes realizados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Objeto de teste (ex.: peça industrial com defeitos simulados)",
                                    "Software de análise de imagem (ex.: ImageJ)"
                                  ],
                                  "tips": "Use triggers externos para sincronizar com movimentos mecatrônicos.",
                                  "learningObjective": "Realizar aquisição efetiva e validar qualidade para aplicações práticas.",
                                  "commonMistakes": [
                                    "Capturar sem controle de iluminação causando sombras",
                                    "Não sincronizar frame rate com velocidade do processo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma célula robótica de inspeção, configure uma câmera CMOS com resolução 1280x1024 e 15 fps para capturar imagens de soldas em peças automotivas, detectando defeitos como porosidade em tempo real.",
                              "finalVerifications": [
                                "Imagem capturada atinge resolução e frame rate especificados sem perda de frames.",
                                "Diferenças entre CCD e CMOS explicadas corretamente em relatório.",
                                "Hardware configurado e estável por 10 minutos de aquisição contínua.",
                                "Qualidade da imagem permite identificação clara de detalhes finos (ex.: 1mm).",
                                "Perfil de parâmetros salvo e reproduzível.",
                                "Análise de trade-offs documentada (resolução vs. velocidade)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de CCD vs. CMOS (80% de acerto em quiz).",
                                "Configuração de hardware sem erros de conexão (100% sucesso).",
                                "Otimização de parâmetros resulta em qualidade industrial aceitável.",
                                "Relatório completo com verificações e métricas quantitativas.",
                                "Capacidade de troubleshooting de problemas comuns como ruído.",
                                "Integração conceitual com sistemas mecatrônicos."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Interfaces de comunicação (USB, GigE Vision).",
                                "Programação: Controle de câmeras via Python/OpenCV.",
                                "Física/Óptica: Princípios de formação de imagem e iluminação.",
                                "Matemática: Cálculos de resolução (pixels/mm) e taxa de dados.",
                                "Automação Industrial: Integração com PLCs e robôs."
                              ],
                              "realWorldApplication": "Inspeção automatizada de qualidade em linhas de produção fabris, como detecção de defeitos em PCBs ou embalagens farmacêuticas, reduzindo desperdícios e aumentando eficiência em indústrias mecatrônicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Aplicar Pré-processamento de Imagens",
                            "description": "Descrever técnicas de filtragem (média, gaussiana), binarização e redução de ruído para preparar imagens em sistemas mecatrônicos embarcados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente e Carregar Imagem",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias como OpenCV e NumPy via pip.",
                                    "Importar as bibliotecas no script Python.",
                                    "Carregar a imagem de teste usando cv2.imread().",
                                    "Exibir a imagem original com cv2.imshow() e analisar visualmente ruído e qualidade.",
                                    "Converter a imagem para escala de cinza se colorida, usando cv2.cvtColor()."
                                  ],
                                  "verification": "Imagem carregada corretamente e exibida sem erros; histograma ou estatísticas básicas confirmam propriedades.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "OpenCV (cv2)",
                                    "NumPy",
                                    "Imagem de teste com ruído (ex: peça mecatrônica capturada por câmera)"
                                  ],
                                  "tips": "Use imagens reais de sistemas embarcados para simular condições reais; verifique formato da imagem (JPEG/PNG).",
                                  "learningObjective": "Preparar o ambiente de desenvolvimento e entender a imagem raw em contextos mecatrônicos.",
                                  "commonMistakes": [
                                    "Esquecer de instalar OpenCV",
                                    "Carregar imagem em canal errado (BGR vs RGB)",
                                    "Não converter para grayscale quando necessário"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Filtros de Suavização (Média e Gaussiana)",
                                  "subSteps": [
                                    "Implementar filtro de média com cv2.blur() ou cv2.boxFilter(), testando tamanhos de kernel (3x3, 5x5).",
                                    "Aplicar filtro gaussiano com cv2.GaussianBlur(), variando sigma para controle de suavização.",
                                    "Comparar resultados lado a lado usando cv2.imshow() para múltiplas janelas.",
                                    "Salvar imagens intermediárias com cv2.imwrite() para análise posterior.",
                                    "Ajustar kernels baseado no nível de ruído observado na imagem original."
                                  ],
                                  "verification": "Ruído reduzido visivelmente nas imagens filtradas; bordas preservadas sem borrão excessivo.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Script Python com OpenCV",
                                    "Imagens do Step 1"
                                  ],
                                  "tips": "Comece com kernels pequenos para evitar perda de detalhes finos em sistemas de visão embarcados.",
                                  "learningObjective": "Dominar técnicas de filtragem para redução inicial de ruído em imagens mecatrônicas.",
                                  "commonMistakes": [
                                    "Kernel muito grande causando perda de bordas",
                                    "Confundir ordem de canais em imagens coloridas",
                                    "Não normalizar sigma no gaussiano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Binarização da Imagem",
                                  "subSteps": [
                                    "Aplicar limiarização simples com cv2.threshold() usando método THRESH_BINARY ou OTSU.",
                                    "Testar diferentes valores de threshold manualmente e automático (OTSU).",
                                    "Exibir imagem binarizada e máscara resultante.",
                                    "Refinar com limiarização adaptativa cv2.adaptiveThreshold() para iluminação irregular.",
                                    "Avaliar segmentação de objetos relevantes (ex: peças mecânicas)."
                                  ],
                                  "verification": "Imagem binarizada destaca regiões de interesse claramente; fundo e objeto separados adequadamente.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Imagens filtradas do Step 2",
                                    "OpenCV"
                                  ],
                                  "tips": "Use OTSU para automação em cenários embarcados com variação de luz.",
                                  "learningObjective": "Aprender binarização para simplificar imagens preparando para análise em sistemas embarcados.",
                                  "commonMistakes": [
                                    "Threshold fixo inadequado para diferentes luzes",
                                    "Esquecer pré-filtro causando binarização ruidosa",
                                    "Inverter máscara (foreground/background)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Redução de Ruído Final e Refinamento",
                                  "subSteps": [
                                    "Usar filtro mediano cv2.medianBlur() para ruído de sal-e-pimenta pós-binarização.",
                                    "Aplicar operações morfológicas: erosão e dilatação com cv2.morphologyEx() (kernel 3x3).",
                                    "Remover pequenos artefatos com abertura/fechamento morfológico.",
                                    "Comparar pipeline completo vs original.",
                                    "Otimizar parâmetros para performance em hardware embarcado (ex: kernels pequenos)."
                                  ],
                                  "verification": "Imagem final limpa, sem ruído residual; features preservadas e prontas para processamento posterior.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Imagens binarizadas do Step 3",
                                    "OpenCV"
                                  ],
                                  "tips": "Teste em loop para otimização rápida; considere FPS em embedded.",
                                  "learningObjective": "Implementar refinamentos finais para imagens robustas em aplicações mecatrônicas.",
                                  "commonMistakes": [
                                    "Morph kernel muito agressivo removendo features",
                                    "Ignorar custo computacional para embedded",
                                    "Não iterar erosão/dilatação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um braço robótico mecatrônico, pré-processe uma imagem capturada por câmera de uma peça com ruído devido a vibração industrial: aplique gaussiano para suavizar, binarize para isolar defeitos e reduza ruído mediano para detecção precisa de bordas.",
                              "finalVerifications": [
                                "Ruído visivelmente reduzido em comparação com original (PSNR > 25dB).",
                                "Binarização segmenta corretamente >90% das regiões de interesse.",
                                "Tempo de processamento < 100ms por imagem para embedded.",
                                "Sem artefatos morfológicos ou perda de bordas críticas.",
                                "Pipeline funciona em sequência sem crashes.",
                                "Imagens salvas comparáveis visualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de filtros (sem distorção >10%).",
                                "Escolha adequada de parâmetros baseada em análise visual.",
                                "Eficiência computacional otimizada para mecatrônica embarcada.",
                                "Comparação quantitativa (ex: métricas de ruído).",
                                "Código limpo, comentado e reproduzível.",
                                "Integração correta do pipeline completo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos em Python/OpenCV para visão.",
                                "Matemática: Convolução e operações morfológicas.",
                                "Eletrônica: Integração com sensores CMOS em embedded.",
                                "Mecânica: Preparação para detecção em robótica industrial."
                              ],
                              "realWorldApplication": "Em sistemas mecatrônicos embarcados como inspeção automatizada em linhas de produção, onde pré-processamento garante detecção confiável de defeitos em peças sob condições reais de iluminação e vibração variáveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Executar Segmentação Básica",
                            "description": "Explicar métodos de segmentação por limiar e contornos para identificar objetos em imagens, com foco em aplicações robóticas mecatrônicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Segmentação por Limiar",
                                  "subSteps": [
                                    "Estude o que é segmentação de imagens e seu papel na visão computacional.",
                                    "Aprenda sobre limiarização (thresholding): binarização de imagens baseando-se em intensidade de pixels.",
                                    "Explore tipos de limiar: global, adaptativo e Otsu.",
                                    "Analise exemplos de imagens antes e depois da limiarização.",
                                    "Discuta limitações em condições de iluminação variável."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os tipos de limiar e demonstre com uma imagem manualmente binarizada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com Python e OpenCV",
                                    "Imagens de teste (ex: bola em fundo variado)",
                                    "Documentação OpenCV thresholding"
                                  ],
                                  "tips": "Comece com imagens simples de alto contraste para visualizar melhor os efeitos.",
                                  "learningObjective": "Entender os princípios fundamentais da segmentação por limiar e suas aplicações em robótica.",
                                  "commonMistakes": "Confundir limiar global com adaptativo; ignorar pré-processamento como equalização de histograma."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Segmentação por Limiar em Código",
                                  "subSteps": [
                                    "Carregue uma imagem usando cv2.imread() e converta para escala de cinza.",
                                    "Aplique cv2.threshold() com limiar global e visualize o resultado.",
                                    "Implemente limiar adaptativo com cv2.adaptiveThreshold().",
                                    "Use método Otsu com cv2.THRESH_OTSU para limiar automático.",
                                    "Salve e compare múltiplas versões binarizadas."
                                  ],
                                  "verification": "Execute o código e produza imagens binarizadas corretas para pelo menos 3 imagens de teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ambiente Python com OpenCV instalado",
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Imagens de objetos robóticos (ex: peças mecatrônicas)"
                                  ],
                                  "tips": "Ajuste valores de limiar iterativamente usando trackbars com cv2.createTrackbar().",
                                  "learningObjective": "Desenvolver habilidade em codificar e otimizar segmentação por limiar.",
                                  "commonMistakes": "Esquecer de converter para grayscale; valores de limiar inadequados levando a ruído excessivo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Detecção de Contornos na Imagem Segmentada",
                                  "subSteps": [
                                    "Aplique operações morfológicas (erosão/dilatação) para limpar a imagem binarizada com cv2.morphologyEx().",
                                    "Encontre contornos usando cv2.findContours() com modo RETR_EXTERNAL.",
                                    "Desenhe contornos na imagem original com cv2.drawContours().",
                                    "Calcule propriedades como área e perímetro com cv2.contourArea() e cv2.arcLength().",
                                    "Filtre contornos por tamanho para eliminar ruído."
                                  ],
                                  "verification": "Gere imagem com contornos destacados e liste propriedades de pelo menos um objeto detectado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Mesmos do step anterior",
                                    "Funções OpenCV de contornos documentadas"
                                  ],
                                  "tips": "Use hierarquia de contornos para detectar objetos internos/externos em aplicações robóticas complexas.",
                                  "learningObjective": "Dominar detecção e análise de contornos para identificação de objetos.",
                                  "commonMistakes": "Não aplicar morfologia prévia, resultando em contornos fragmentados; modo de contorno incorreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Segmentação em Aplicação Robótica Mecatrônica",
                                  "subSteps": [
                                    "Simule integração com robô: capture vídeo de câmera com cv2.VideoCapture().",
                                    "Processe frames em loop para segmentação em tempo real.",
                                    "Calcule centroide do objeto com cv2.moments() para orientação robótica.",
                                    "Defina comandos simulados (ex: mover para centroide).",
                                    "Teste com vídeo gravado de um robô manipulando objetos."
                                  ],
                                  "verification": "Execute demo em vídeo real-time mostrando detecção estável de objeto com centroide marcado.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Webcam ou vídeo de teste robótico",
                                    "Código integrado em script Python"
                                  ],
                                  "tips": "Otimize para FPS alto reduzindo resolução da imagem.",
                                  "learningObjective": "Aplicar segmentação básica em cenários reais de mecatrônica robótica.",
                                  "commonMistakes": "Processamento lento sem otimização; falha em lidar com movimento borrado."
                                }
                              ],
                              "practicalExample": "Em um braço robótico mecatrônico, use segmentação por limiar para binarizar uma imagem de uma peça vermelha em linha de montagem, detecte seus contornos e calcule o centroide para guiar o gripper até a posição exata de pegada.",
                              "finalVerifications": [
                                "Segmentação por limiar produz máscara binarizada precisa sem ruído excessivo.",
                                "Contornos detectados correspondem fielmente aos objetos alvo.",
                                "Propriedades como área e centroide são calculadas corretamente.",
                                "Processamento em tempo real mantém FPS acima de 15 em webcam.",
                                "Filtro de contornos elimina falsos positivos em fundos complexos.",
                                "Integração simulada gera comandos robóticos válidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da binarização: >90% de pixels do objeto corretamente segmentados.",
                                "Robustez a variações de luz: sucesso em 3 condições de iluminação diferentes.",
                                "Eficiência computacional: tempo por frame <100ms.",
                                "Qualidade de contornos: perímetro suave sem fragmentação.",
                                "Aplicação prática: detecção consistente em vídeo dinâmico.",
                                "Documentação de código: comentários claros e estrutura modular."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações em matrizes e estatística (método Otsu).",
                                "Programação: Estruturas de loop e funções em Python.",
                                "Eletrônica: Integração com sensores de câmera em sistemas embarcados.",
                                "Física: Modelagem de luz e sombras em imagens."
                              ],
                              "realWorldApplication": "Robôs industriais em fábricas mecatrônicas usam essa segmentação para inspeção de qualidade, pick-and-place de peças e navegação autônoma em armazéns, reduzindo erros humanos e aumentando eficiência produtiva."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Aplicações em Projetos Mecatrônicos",
                        "description": "Exploração de casos práticos de sistemas de visão computacional integrados a microcontroladores e robótica na indústria, como aeronáutica.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Analisar Aplicações Industriais",
                            "description": "Discutir usos de visão computacional em inspeção de qualidade, orientação robótica e navegação autônoma em projetos mecatrônicos aeronáuticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Aplicações de Visão Computacional",
                                  "subSteps": [
                                    "Pesquisar definições e princípios básicos de visão computacional em contextos industriais.",
                                    "Identificar os componentes principais: câmeras, processamento de imagem e algoritmos de detecção.",
                                    "Estudar casos gerais de uso em mecatrônica, focando em automação.",
                                    "Mapear aplicações específicas: inspeção, orientação e navegação.",
                                    "Anotar vantagens como precisão e velocidade em ambientes industriais."
                                  ],
                                  "verification": "Criar um mapa mental ou tabela resumindo conceitos e componentes principais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Acesso à internet para artigos e vídeos sobre visão computacional",
                                    "Ferramenta de mind mapping (ex: MindMeister ou papel e caneta)",
                                    "Livros ou PDFs introdutórios em visão computacional"
                                  ],
                                  "tips": "Comece com fontes confiáveis como IEEE ou sites de universidades para evitar informações desatualizadas.",
                                  "learningObjective": "Dominar os fundamentos teóricos das aplicações de visão computacional em mecatrônica.",
                                  "commonMistakes": [
                                    "Confundir visão computacional com processamento de imagem simples",
                                    "Ignorar limitações como iluminação variável",
                                    "Não relacionar conceitos ao contexto aeronáutico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Aplicação em Inspeção de Qualidade",
                                  "subSteps": [
                                    "Descrever como visão computacional detecta defeitos em peças aeronáuticas (ex: rachaduras em fuselagem).",
                                    "Estudar algoritmos como detecção de bordas (Canny) e segmentação.",
                                    "Simular um fluxo: aquisição de imagem > pré-processamento > análise > decisão.",
                                    "Comparar com métodos manuais: tempo, precisão e redução de erros humanos.",
                                    "Pesquisar exemplos reais em indústrias aeronáuticas."
                                  ],
                                  "verification": "Produzir um diagrama de fluxo da inspeção e listar 3 benefícios quantificáveis.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software gratuito como OpenCV ou ImageJ",
                                    "Imagens de amostra de peças aeronáuticas (bancos online)",
                                    "Vídeos tutoriais do YouTube sobre OpenCV para inspeção"
                                  ],
                                  "tips": "Use imagens reais de falhas para tornar a análise mais concreta e visual.",
                                  "learningObjective": "Capacitar análise crítica da inspeção de qualidade via visão computacional.",
                                  "commonMistakes": [
                                    "Subestimar impacto de ruído na imagem",
                                    "Não considerar integração com linhas de produção",
                                    "Focar apenas em teoria sem exemplos práticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Aplicação em Orientação Robótica",
                                  "subSteps": [
                                    "Explicar como visão computacional guia robôs em montagem de componentes aeronáuticos.",
                                    "Explorar técnicas como tracking de objetos e pose estimation.",
                                    "Modelar cenários: robô pick-and-place guiado por câmera.",
                                    "Discutir feedback em tempo real e correção de trajetória.",
                                    "Avaliar desafios como vibrações em ambientes industriais."
                                  ],
                                  "verification": "Desenhar um esquema de um robô orientado por visão e descrever seu ciclo de operação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simuladores como Gazebo com ROS",
                                    "Tutoriais de visão para robótica (ex: ROS.org)",
                                    "Vídeos de robôs industriais em ação"
                                  ],
                                  "tips": "Integre com conhecimento de robótica mecatrônica para conexões práticas.",
                                  "learningObjective": "Entender integração de visão computacional para precisão robótica.",
                                  "commonMistakes": [
                                    "Ignorar latência de processamento",
                                    "Confundir orientação com navegação",
                                    "Não abordar segurança em falhas de detecção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Aplicação em Navegação Autônoma",
                                  "subSteps": [
                                    "Descrever uso em veículos autônomos ou drones para inspeção aeronáutica.",
                                    "Estudar SLAM (Simultaneous Localization and Mapping) e detecção de obstáculos.",
                                    "Simular navegação em hangar: path planning via visão.",
                                    "Comparar com sensores alternativos (LIDAR vs. visão).",
                                    "Discutir aplicações em manutenção preditiva de aeronaves."
                                  ],
                                  "verification": "Criar um relatório curto comparando visão com outros sensores em navegação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas como Cartographer para SLAM",
                                    "Vídeos de drones autônomos",
                                    "Artigos sobre navegação em aviação"
                                  ],
                                  "tips": "Foque em cenários aeronáuticos reais como hangares para relevância.",
                                  "learningObjective": "Analisar navegação autônoma impulsionada por visão em contextos mecatrônicos.",
                                  "commonMistakes": [
                                    "Superestimar robustez em baixa visibilidade",
                                    "Não considerar regulamentações aeronáuticas",
                                    "Misturar navegação com orientação estática"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Discutir Aplicações no Contexto Aeronáutico",
                                  "subSteps": [
                                    "Integrar análises: inspeção, orientação e navegação em um projeto mecatrônico.",
                                    "Avaliar impactos: eficiência, custo e inovação em aeronáutica.",
                                    "Debater limitações e futuras tendências (IA integrada).",
                                    "Preparar discussão: prós, contras e recomendações.",
                                    "Relacionar a projetos reais como Boeing ou Embraer."
                                  ],
                                  "verification": "Elaborar uma apresentação ou ensaio de 1 página sintetizando as aplicações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramenta de apresentação (PowerPoint ou Google Slides)",
                                    "Casos de estudo de empresas aeronáuticas"
                                  ],
                                  "tips": "Use métricas como ROI para tornar a discussão mais profissional.",
                                  "learningObjective": "Sintetizar análises para discussão crítica em projetos mecatrônicos aeronáuticos.",
                                  "commonMistakes": [
                                    "Falta de integração entre aplicações",
                                    "Ignorar aspectos éticos/sustentabilidade",
                                    "Discussão superficial sem dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de montagem de asas de aeronave, use visão computacional para inspecionar soldas (detecção de defeitos), guiar um braço robótico para posicionar rebites (orientação) e navegar um drone para mapear a estrutura (navegação autônoma), simulando com OpenCV e ROS.",
                              "finalVerifications": [
                                "Explicar com precisão os três usos principais em contexto aeronáutico.",
                                "Demonstrar um diagrama de fluxo para cada aplicação.",
                                "Listar pelo menos duas limitações e soluções para cada uma.",
                                "Comparar visão computacional com métodos tradicionais.",
                                "Relacionar aplicações a um projeto mecatrônico integrado.",
                                "Apresentar exemplos reais de indústrias aeronáuticas."
                              ],
                              "assessmentCriteria": [
                                "Profundidade da análise teórica e prática (30%)",
                                "Precisão e relevância dos exemplos aeronáuticos (25%)",
                                "Qualidade dos diagramas e verificações (20%)",
                                "Integração interdisciplinar e síntese (15%)",
                                "Clareza na discussão de limitações e tendências (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Robótica: Integração com controle de braços robóticos.",
                                "Inteligência Artificial: Algoritmos de machine learning para detecção.",
                                "Engenharia Aeronáutica: Normas de qualidade e segurança em aviação.",
                                "Processamento de Sinais: Filtros e pré-processamento de imagens.",
                                "Gestão de Projetos: Avaliação de ROI em implementações industriais."
                              ],
                              "realWorldApplication": "Na Embraer, visão computacional é usada para inspeção automatizada de fuselagens, reduzindo tempo de produção em 40%; robôs guiados por visão montam componentes em linhas da Boeing; drones autônomos inspecionam aeronaves em hangares da Airbus, melhorando manutenção preditiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Integrar Visão com Microcontroladores",
                            "description": "Descrever a interface entre câmeras de visão e microcontroladores/CLPs para processamento em tempo real em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação do Hardware",
                                  "subSteps": [
                                    "Selecionar câmera compatível (ex: ESP32-CAM ou OV7670) e microcontrolador (ex: Arduino ou ESP32).",
                                    "Conectar a câmera ao microcontrolador via interfaces como I2C, SPI ou USB.",
                                    "Alimentar corretamente os componentes e adicionar resistores/pull-ups necessários.",
                                    "Testar conexões com multímetro para evitar curtos-circuitos.",
                                    "Montar em protoboard ou PCB para estabilidade."
                                  ],
                                  "verification": "Verificar continuidade elétrica e alimentação estável com LED de status aceso.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Câmera (ESP32-CAM), Microcontrolador (Arduino/ESP32), Jumpers, Protoboard, Multímetro"
                                  ],
                                  "tips": "Use diagramas de pinout oficiais para evitar erros de conexão.",
                                  "learningObjective": "Entender interfaces físicas entre visão e microcontroladores.",
                                  "commonMistakes": [
                                    "Conexões invertidas de VCC/GND",
                                    "Esquecimento de pull-ups em I2C"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração Inicial do Software da Câmera",
                                  "subSteps": [
                                    "Instalar bibliotecas como ESP32Cam ou OpenCV para captura de imagem.",
                                    "Configurar resolução, framerate e formato de saída (JPEG/YUV).",
                                    "Implementar código básico para streaming de imagens via WiFi ou serial.",
                                    "Testar captura isolada e salvar frames em cartão SD.",
                                    "Ajustar parâmetros de exposição e ganho para ambiente de teste."
                                  ],
                                  "verification": "Captura e exibição de imagem em monitor serial ou app web.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Arduino IDE, Bibliotecas ESP32Cam/OpenCV, Computador com serial monitor"
                                  ],
                                  "tips": "Comece com resoluções baixas para depuração rápida.",
                                  "learningObjective": "Configurar captura de imagens em tempo real.",
                                  "commonMistakes": [
                                    "Bibliotecas incompatíveis com board",
                                    "Framerate alto sem otimização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolvimento do Código no Microcontrolador",
                                  "subSteps": [
                                    "Implementar recepção de frames via serial/SPI no microcontrolador.",
                                    "Aplicar processamento básico (ex: detecção de bordas com filtros Sobel).",
                                    "Definir thresholds para decisões em tempo real (ex: objeto detectado).",
                                    "Integrar saídas com atuadores (ex: LED ou motor).",
                                    "Otimizar loop principal para <100ms por frame."
                                  ],
                                  "verification": "Processamento local de frame com saída visível (Serial.print ou LED piscando).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Arduino IDE, Bibliotecas de processamento de imagem (TinyML ou Edge Impulse)"
                                  ],
                                  "tips": "Use interrupções para comunicação assíncrona.",
                                  "learningObjective": "Processar dados visuais em microcontroladores limitados.",
                                  "commonMistakes": [
                                    "Buffer overflow em recepção",
                                    "Processamento bloqueante"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração e Testes em Tempo Real",
                                  "subSteps": [
                                    "Sincronizar captura e processamento com protocolo de handshake.",
                                    "Implementar feedback loop (ex: ajustar posição baseada em visão).",
                                    "Testar latência total com cronômetro e osciloscópio.",
                                    "Debugar com logs e visualizadores de frames.",
                                    "Simular falhas (luz baixa, movimento rápido) e corrigir."
                                  ],
                                  "verification": "Sistema responde a estímulos visuais em <500ms consistentemente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Osciloscópio ou Logic Analyzer, Objetos de teste (bolas coloridas)"
                                  ],
                                  "tips": "Monitore uso de RAM/CPU para evitar travamentos.",
                                  "learningObjective": "Garantir operação em tempo real em sistemas mecatrônicos.",
                                  "commonMistakes": [
                                    "Latência acumulada por delays",
                                    "Ignorar jitter de comunicação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimização e Validação Final",
                                  "subSteps": [
                                    "Reduzir tamanho de imagem e comprimir dados.",
                                    "Implementar multithreading ou DMA se suportado.",
                                    "Calibrar sistema para precisão >90%.",
                                    "Documentar código e diagrama de fluxo.",
                                    "Preparar para integração em projeto maior."
                                  ],
                                  "verification": "Benchmark de performance com 100 frames consecutivos sem falhas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de profiling (FreeRTOS tasks)"
                                  ],
                                  "tips": "Priorize processamento em hardware (ex: DSP no ESP32).",
                                  "learningObjective": "Otimizar para aplicações industriais.",
                                  "commonMistakes": [
                                    "Sobrecarga de memória",
                                    "Falta de calibração ambiental"
                                  ]
                                }
                              ],
                              "practicalExample": "Integre uma ESP32-CAM com Arduino para detectar garrafas defeituosas em uma linha de montagem simulada: a câmera captura imagem, processa bordas para alinhamento e aciona um servo para rejeitar itens ruins em tempo real.",
                              "finalVerifications": [
                                "Sistema captura e processa frames a >10 FPS.",
                                "Comunicação estável sem perda de dados por 10 minutos.",
                                "Precisão de detecção >85% em testes variados.",
                                "Latência total <200ms de captura a ação.",
                                "Código roda sem crashes em reinícios múltiplos.",
                                "Integração com atuadores funciona corretamente."
                              ],
                              "assessmentCriteria": [
                                "Correção das conexões hardware (sem erros elétricos).",
                                "Eficiência do código (otimizado para tempo real).",
                                "Qualidade do processamento de imagem (thresholds adequados).",
                                "Documentação clara de passos e depuração.",
                                "Capacidade de troubleshooting autônomo.",
                                "Integração fluida em contexto mecatrônico."
                              ],
                              "crossCurricularConnections": [
                                "Programação Embarcada (loops e interrupções).",
                                "Eletrônica Digital (interfaces seriais).",
                                "Processamento de Sinais (filtros em imagens).",
                                "Inteligência Artificial (detecção básica de objetos).",
                                "Controle Automático (feedback visual)."
                              ],
                              "realWorldApplication": "Em indústrias automotivas para inspeção visual de peças em linhas de produção, garantindo qualidade e eficiência sem intervenção humana constante."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Avaliar Desafios e Limitações",
                            "description": "Identificar desafios como iluminação variável, processamento em tempo real e integração multifuncional, propondo soluções iniciais baseadas em bibliografia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Desafios Comuns em Sistemas de Visão por Computador",
                                  "subSteps": [
                                    "Revise conceitos básicos de visão computacional e liste desafios ambientais como iluminação variável.",
                                    "Identifique desafios computacionais, incluindo processamento em tempo real e limitações de hardware.",
                                    "Registre desafios de integração, como sincronização com sensores mecatrônicos e atuadores.",
                                    "Categorize desafios em ambientais, computacionais e de integração para clareza.",
                                    "Documente exemplos iniciais de cada categoria baseados em casos reais."
                                  ],
                                  "verification": "Lista completa com pelo menos 8 desafios categorizados, revisada por pares.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigos introdutórios sobre visão computacional (ex: OpenCV docs)",
                                    "Vídeos tutoriais no YouTube sobre desafios em CV",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use mind maps para visualizar categorias de desafios e facilitar categorização.",
                                  "learningObjective": "Ao final, o aluno será capaz de listar e categorizar desafios comuns em sistemas de visão.",
                                  "commonMistakes": [
                                    "Ignorar desafios de integração multifuncional",
                                    "Focar apenas em problemas teóricos sem exemplos práticos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Impactos dos Desafios no Contexto Mecatrônico",
                                  "subSteps": [
                                    "Selecione um projeto mecatrônico específico (ex: robô com visão para inspeção).",
                                    "Avalie como iluminação variável afeta precisão de detecção de objetos.",
                                    "Analise atrasos em processamento em tempo real e seu impacto na segurança do sistema.",
                                    "Examine conflitos de integração multifuncional com outros subsistemas (ex: motores, PLCs).",
                                    "Quantifique impactos potenciais usando métricas como taxa de erro ou latência."
                                  ],
                                  "verification": "Relatório de análise com impactos quantificados para pelo menos 3 desafios principais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Diagrama do projeto mecatrônico",
                                    "Ferramentas de simulação como MATLAB/Simulink",
                                    "Planilhas para cálculo de métricas"
                                  ],
                                  "tips": "Priorize desafios com maior impacto no desempenho geral do sistema.",
                                  "learningObjective": "Ao final, o aluno será capaz de relacionar desafios de visão ao contexto de projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Subestimar impactos em tempo real",
                                    "Não considerar interdependências com outros componentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Pesquisar Bibliografia para Soluções Iniciais",
                                  "subSteps": [
                                    "Busque em bases como IEEE Xplore, Google Scholar por papers sobre 'desafios em visão computacional mecatrônica'.",
                                    "Selecione 5-7 referências relevantes para cada categoria de desafio.",
                                    "Extraia soluções iniciais, como filtros adaptativos para iluminação ou algoritmos otimizados para tempo real.",
                                    "Anote autores, anos e resumos chave das soluções propostas.",
                                    "Organize em tabela comparativa de soluções por desafio."
                                  ],
                                  "verification": "Tabela com pelo menos 5 referências bibliográficas e resumos de soluções.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Acesso a Google Scholar/IEEE",
                                    "Ferramenta Zotero ou Mendeley para gerenciamento de referências",
                                    "Palavras-chave: 'computer vision challenges mechatronics'"
                                  ],
                                  "tips": "Use filtros por data recente (últimos 5 anos) para soluções atualizadas.",
                                  "learningObjective": "Ao final, o aluno será capaz de pesquisar e sintetizar bibliografia relevante.",
                                  "commonMistakes": [
                                    "Citar fontes não acadêmicas",
                                    "Não extrair soluções práticas aplicáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propor e Avaliar Soluções Iniciais",
                                  "subSteps": [
                                    "Proponha 2-3 soluções iniciais por desafio, baseadas na bibliografia.",
                                    "Avalie viabilidade considerando custo, complexidade e compatibilidade mecatrônica.",
                                    "Crie um plano de mitigação com priorização (alta/média/baixa).",
                                    "Simule ou esboce uma solução para um desafio chave (ex: pseudocódigo para filtro de luz).",
                                    "Documente trade-offs e próximos passos para implementação."
                                  ],
                                  "verification": "Relatório final com propostas de soluções, avaliação e plano de ação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Pseudocódigo editor (ex: VS Code)",
                                    "Bibliografia do step 3",
                                    "Matriz de decisão para viabilidade"
                                  ],
                                  "tips": "Use critérios SMART (Specific, Measurable, etc.) para avaliar soluções.",
                                  "learningObjective": "Ao final, o aluno será capaz de propor soluções factíveis baseadas em evidências.",
                                  "commonMistakes": [
                                    "Propor soluções genéricas sem base bibliográfica",
                                    "Ignorar trade-offs de custo vs. performance"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um braço robótico mecatrônico para pick-and-place em linha de produção, identifique desafios como iluminação variável de lâmpadas LED piscantes (solução: pré-processamento com equalização de histograma), processamento em tempo real para ciclos de 500ms (solução: uso de GPU com CUDA), e integração com PLC para controle de garras (solução: protocolo ROS-Industrial).",
                              "finalVerifications": [
                                "Lista exaustiva de desafios identificados e categorizados.",
                                "Análise de impactos quantificada no contexto do projeto.",
                                "Bibliografia com pelo menos 5 referências relevantes citadas corretamente.",
                                "Propostas de soluções iniciais com avaliação de viabilidade.",
                                "Plano de mitigação priorizado e documentado.",
                                "Simulação ou esboço de pelo menos uma solução chave."
                              ],
                              "assessmentCriteria": [
                                "Completude na identificação de desafios (mínimo 8, 30%)",
                                "Profundidade da análise de impactos (25%)",
                                "Qualidade e relevância da pesquisa bibliográfica (20%)",
                                "Criatividade e factibilidade das soluções propostas (15%)",
                                "Clareza e organização do relatório final (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de algoritmos de processamento de imagem em Python/OpenCV.",
                                "Eletrônica: Integração de câmeras com microcontroladores e sensores.",
                                "Matemática: Modelos estatísticos para correção de iluminação e otimização de tempo real.",
                                "Gestão de Projetos: Análise de riscos e planejamento de mitigação."
                              ],
                              "realWorldApplication": "Na indústria manufatureira, como em linhas de montagem automotiva da Toyota, onde sistemas de visão avaliam soldas sob iluminação variável, processam em tempo real para evitar paradas e integram com robôs colaborativos, reduzindo defeitos em 20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Introdução à Robótica Mecatrônica",
                    "description": "Fundamentos de robótica com aplicações na indústria aeronáutica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Fundamentos de Robótica Mecatrônica",
                        "description": "Apresentação dos princípios básicos da robótica mecatrônica, integrando mecânica, eletrônica e controle para sistemas autônomos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Definir robótica mecatrônica",
                            "description": "Explicar o conceito de robótica mecatrônica como a integração sinérgica de mecanismos mecânicos, eletrônicos e de controle computacional para criar sistemas inteligentes e autônomos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes fundamentais da robótica mecatrônica",
                                  "subSteps": [
                                    "Pesquise a definição de mecanismos mecânicos em robótica, como estruturas, atuadores e sensores físicos.",
                                    "Estude componentes eletrônicos, incluindo circuitos, sensores e atuadores elétricos como motores e LEDs.",
                                    "Analise o controle computacional, focando em microcontroladores, algoritmos e software de programação.",
                                    "Compare os três componentes usando um diagrama de Venn para visualizar diferenças e sobreposições iniciais.",
                                    "Registre exemplos reais de cada componente em robôs cotidianos, como rodas em um robô móvel."
                                  ],
                                  "verification": "Crie um diagrama de Venn completo com pelo menos um exemplo por componente e explique verbalmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet para pesquisas (Wikipedia, Khan Academy)",
                                    "Papel e caneta para diagrama",
                                    "Vídeos introdutórios sobre mecatrônica (YouTube: canais como 'The Engineering Mindset')"
                                  ],
                                  "tips": [
                                    "Use analogias simples, como comparar um robô a um corpo humano (ossos=mecânica, nervos=eletrônica, cérebro=computacional).",
                                    "Priorize fontes confiáveis acadêmicas.",
                                    "Desenhe o diagrama à mão para melhor retenção."
                                  ],
                                  "learningObjective": "Compreender os três pilares individuais da robótica mecatrônica: mecânica, eletrônica e computacional.",
                                  "commonMistakes": [
                                    "Confundir eletrônica com computacional (eletrônica é hardware físico, computacional é software/lógica).",
                                    "Ignorar sensores como ponte entre componentes.",
                                    "Listar componentes sem exemplos concretos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a integração sinérgica entre os componentes",
                                  "subSteps": [
                                    "Defina 'sinergia' como o efeito maior que a soma das partes, onde componentes interagem para criar funcionalidades emergentes.",
                                    "Descreva como mecânica fornece estrutura, eletrônica detecta/atuam e computacional processa decisões em loop fechado.",
                                    "Estude exemplos de feedback: sensores enviam dados ao controlador, que ajusta atuadores mecânicos.",
                                    "Crie um fluxograma simples mostrando o fluxo de dados: sensor → processador → atuador.",
                                    "Discuta por que a separação falha: um mecanismo sem controle é rígido, eletrônica sem mecânica é inerte."
                                  ],
                                  "verification": "Produza um fluxograma anotado demonstrando um ciclo de feedback em um robô simples.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramentas online como Draw.io ou Lucidchart para fluxogramas",
                                    "Artigos sobre sistemas de controle (ex: 'Mecatrônica Básica' PDF gratuito)",
                                    "Vídeo: 'Como funcionam robôs' (TED-Ed)"
                                  ],
                                  "tips": [
                                    "Pense em um termostato como mini-exemplo de sinergia.",
                                    "Use setas coloridas no fluxograma para cada componente.",
                                    "Teste o fluxograma explicando para um colega."
                                  ],
                                  "learningObjective": "Explicar como a sinergia integra mecânica, eletrônica e computacional para além da soma isolada.",
                                  "commonMistakes": [
                                    "Ver sinergia apenas como 'montagem' física, ignorando interações dinâmicas.",
                                    "Omitir loops de feedback.",
                                    "Sobrecarregar o fluxograma com detalhes desnecessários."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir características de sistemas inteligentes e autônomos",
                                  "subSteps": [
                                    "Liste traços de inteligência robótica: percepção (sensores), raciocínio (algoritmos) e ação (atuadores).",
                                    "Explique autonomia como capacidade de operar sem intervenção humana constante, via IA e aprendizado.",
                                    "Diferencie autônomo de automatizado: autônomo adapta-se a ambientes imprevisíveis.",
                                    "Analise exemplos: robô aspirador Roomba (navega sozinho) vs. linha de montagem fixa.",
                                    "Escreva uma definição concisa incorporando sinergia e autonomia."
                                  ],
                                  "verification": "Escreva uma definição de 100-150 palavras de robótica mecatrônica, incluindo os três pilares, sinergia e autonomia.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Modelo de texto: definição oficial da IEEE sobre mecatrônica",
                                    "Exemplos de robôs (imagens de drones, braços robóticos)",
                                    "Ferramenta de escrita como Google Docs"
                                  ],
                                  "tips": [
                                    "Estruture a definição: introdução + pilares + sinergia + características + conclusão.",
                                    "Use termos precisos mas evite jargão excessivo.",
                                    "Leia em voz alta para checar fluidez."
                                  ],
                                  "learningObjective": "Identificar e descrever inteligência e autonomia como resultados da integração mecatrônica.",
                                  "commonMistakes": [
                                    "Confundir autonomia com velocidade ou complexidade.",
                                    "Definir inteligência apenas como 'IA avançada', ignorando basics.",
                                    "Fazer definição muito genérica sem menção aos pilares."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e validar a definição completa de robótica mecatrônica",
                                  "subSteps": [
                                    "Combine elementos dos steps anteriores em uma definição unificada.",
                                    "Compare sua definição com fontes padrão (ex: livros de mecatrônica).",
                                    "Crie um pôster ou slide resumindo: pilares, sinergia, inteligência, autonomia.",
                                    "Apresente a definição para autoavaliação ou peer-review.",
                                    "Ajuste com base em feedback para precisão."
                                  ],
                                  "verification": "Produza um pôster ou slide final com a definição e passe em uma autoavaliação checklist.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Canva ou PowerPoint para pôster/slide",
                                    "Checklist de verificação impressa",
                                    "Referências: 'Introdução à Mecatrônica' de Bolton"
                                  ],
                                  "tips": [
                                    "Mantenha visual: ícones para cada pilar.",
                                    "Peça feedback específico: 'A sinergia está clara?'",
                                    "Limite texto a bullet points."
                                  ],
                                  "learningObjective": "Formular uma definição precisa e holística de robótica mecatrônica.",
                                  "commonMistakes": [
                                    "Copiar definições sem sintetizar.",
                                    "Ignorar validação com fontes.",
                                    "Fazer pôster sobrecarregado visualmente."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um drone quadricóptero: estrutura mecânica (hélices e frame) integra eletrônica (baterias, IMU sensores) e controle computacional (firmware PID para estabilidade). A sinergia permite voo autônomo: sensores detectam inclinação, processador ajusta motores em tempo real, criando inteligência para navegação GPS sem piloto.",
                              "finalVerifications": [
                                "Articula corretamente os três pilares (mecânica, eletrônica, computacional).",
                                "Explica sinergia com exemplo de interação dinâmica.",
                                "Define inteligência e autonomia com distinções claras.",
                                "Produz definição escrita coerente e precisa.",
                                "Cria representações visuais (diagrama/fluxograma) corretas.",
                                "Valida definição contra fontes padrão sem erros conceituais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (90% dos termos corretos, 40%)",
                                "Completude (todos pilares, sinergia e autonomia cobertos, 25%)",
                                "Clareza e estrutura da definição (linguagem acessível, 15%)",
                                "Uso de exemplos e visuais relevantes (20%)",
                                "Validação e auto-correção demonstradas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica e cinemática para mecanismos mecânicos.",
                                "Matemática: Algoritmos de controle e equações diferenciais.",
                                "Informática: Programação de microcontroladores (ex: Arduino/Python).",
                                "Engenharia de Software: Modelagem de sistemas embarcados.",
                                "Ética: Implicações de autonomia em robótica (segurança, privacidade)."
                              ],
                              "realWorldApplication": "Na indústria automotiva, robótica mecatrônica é usada em linhas de montagem da Tesla, onde robôs autônomos soldam e montam carros com precisão, integrando visão computacional para adaptação em tempo real, reduzindo erros humanos e aumentando eficiência produtiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Identificar componentes básicos de um robô mecatrônico",
                            "description": "Listar e descrever os principais componentes, como atuadores, sensores, microcontroladores e estruturas mecânicas, destacando sua interconexão em um sistema robótico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e descrever atuadores em robôs mecatrônicos",
                                  "subSteps": [
                                    "Pesquise definições de atuadores comuns como motores DC, servomotores e atuadores pneumáticos.",
                                    "Assista a um vídeo demonstrando o funcionamento de atuadores em robôs.",
                                    "Desenhe um diagrama simples de um atuador e anote sua função principal (converter energia em movimento).",
                                    "Liste 3 exemplos de atuadores usados em robótica e suas aplicações específicas.",
                                    "Compare atuadores elétricos vs. hidráulicos em termos de precisão e força."
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 3 atuadores, suas funções e exemplos, e revise com um colega ou tutor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com acesso à internet",
                                    "Vídeos tutoriais no YouTube (ex: 'Tipos de atuadores em robótica')",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Foquem em como atuadores recebem sinais elétricos para gerar movimento mecânico.",
                                  "learningObjective": "Compreender o papel dos atuadores como elementos de saída em sistemas robóticos.",
                                  "commonMistakes": [
                                    "Confundir atuadores com sensores (atuadores agem, sensores percebem)",
                                    "Ignorar limitações como velocidade vs. torque"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e descrever sensores em robôs mecatrônicos",
                                  "subSteps": [
                                    "Estude sensores comuns como ultrassônicos, infravermelhos, encoders e sensores de temperatura.",
                                    "Visualize demonstrações práticas de sensores detectando obstáculos ou medindo distâncias.",
                                    "Esboce um circuito simples conectando um sensor a um microcontrolador.",
                                    "Registre 3 sensores e explique como eles convertem estímulos físicos em sinais elétricos.",
                                    "Simule cenários onde sensores falham e como mitigar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre sensores analógicos e digitais com exemplos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Acesso online a simulações de sensores (ex: Tinkercad)",
                                    "Folhas de anotações",
                                    "Vídeos educativos sobre sensores robóticos"
                                  ],
                                  "tips": "Lembre-se: sensores são 'olhos e ouvidos' do robô, fornecendo dados para decisões.",
                                  "learningObjective": "Dominar os sensores como componentes de entrada que captam o ambiente.",
                                  "commonMistakes": [
                                    "Subestimar calibração necessária",
                                    "Confundir saída de sensor com processamento de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar microcontroladores e estruturas mecânicas",
                                  "subSteps": [
                                    "Aprenda sobre microcontroladores como Arduino ou Raspberry Pi: funções de processamento e I/O.",
                                    "Descreva estruturas mecânicas: chassis, braços, rodas e materiais (plástico, alumínio).",
                                    "Monte um diagrama de pinos de um microcontrolador conectados a atuadores/sensores.",
                                    "Liste vantagens de estruturas modulares em robôs.",
                                    "Pesquise exemplos de falhas estruturais em robôs e soluções."
                                  ],
                                  "verification": "Desenhe um fluxograma mostrando microcontrolador integrando sensores e atuadores.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Datasheet de Arduino Uno (PDF online)",
                                    "Imagens de chassis robóticos",
                                    "Software de diagramação gratuito como Draw.io"
                                  ],
                                  "tips": "Microcontroladores são o 'cérebro'; estruturas fornecem suporte físico.",
                                  "learningObjective": "Entender microcontroladores como núcleo de controle e estruturas como base física.",
                                  "commonMistakes": [
                                    "Pensar que microcontroladores executam lógica complexa sem programação",
                                    "Ignorar rigidez vs. peso nas estruturas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar interconexões entre componentes em um sistema robótico",
                                  "subSteps": [
                                    "Mapeie fluxos: sensor → microcontrolador → atuador.",
                                    "Crie um diagrama completo de um robô simples destacando interdependências.",
                                    "Simule um loop de feedback (ex: sensor detecta → processa → atua).",
                                    "Discuta como falha em um componente afeta o sistema inteiro.",
                                    "Revise exemplos reais de sistemas mecatrônicos integrados."
                                  ],
                                  "verification": "Apresente um diagrama final com legendas explicando interconexões e teste com perguntas de autoavaliação.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Ferramentas de diagramação online",
                                    "Vídeos de montagem de robôs (ex: Arduino robot car)",
                                    "Papel para esboços"
                                  ],
                                  "tips": "Pense no robô como um ecossistema: todos os componentes interagem em tempo real.",
                                  "learningObjective": "Visualizar o robô como sistema integrado, não componentes isolados.",
                                  "commonMistakes": [
                                    "Visualizar componentes separadamente sem fluxo de dados",
                                    "Esquecer alimentação elétrica compartilhada"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando um kit Arduino Robot Car básico, desmonte o robô, identifique atuadores (motores DC), sensores (ultrassônicos), microcontrolador (Arduino) e estrutura (chassis de acrílico), depois remonte anotando conexões como sensor HC-SR04 no pino digital 9.",
                              "finalVerifications": [
                                "Liste corretamente os 4 componentes principais com descrições breves.",
                                "Desenhe um diagrama preciso de interconexões.",
                                "Explique um loop de feedback simples.",
                                "Identifique pelo menos 2 erros comuns em montagens.",
                                "Compare funções de atuador vs. sensor em um exemplo prático.",
                                "Descreva impacto de uma falha estrutural no sistema."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas descrições de funções (90% correto).",
                                "Completude do diagrama de interconexões.",
                                "Profundidade nos substeps (todos completos com evidências).",
                                "Capacidade de explicar verbalmente interdependências.",
                                "Identificação de erros comuns e prevenções.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de mecânica e eletromagnetismo em atuadores.",
                                "Eletrônica: Circuitos e sinais em sensores/microcontroladores.",
                                "Programação: Lógica de controle e loops de feedback.",
                                "Engenharia de Materiais: Seleção de estruturas resistentes.",
                                "Matemática: Cálculos de torque, distância e precisão sensorial."
                              ],
                              "realWorldApplication": "Em fábricas automotivas, robôs mecatrônicos usam sensores para detectar peças defeituosas, microcontroladores para processar dados e atuadores para soldar ou montar, com estruturas robustas suportando operação 24/7, otimizando produção e reduzindo erros humanos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Explicar o desenvolvimento integrado de produtos robóticos",
                            "description": "Descrever técnicas de projeto com times multifuncionais para o desenvolvimento de produtos robóticos mecatrônicos, conforme métodos de engenharia de design.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Desenvolvimento Integrado",
                                  "subSteps": [
                                    "Estudar a definição de desenvolvimento integrado (concurrent engineering) e sua importância em produtos complexos.",
                                    "Analisar as diferenças entre abordagens sequenciais (waterfall) e integradas.",
                                    "Identificar os princípios chave: integração precoce, iterações paralelas e feedback contínuo.",
                                    "Revisar exemplos históricos de sucesso em indústrias como aeroespacial.",
                                    "Mapear os benefícios: redução de tempo, custo e riscos."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando os fundamentos e diferenças principais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo 'Concurrent Engineering' da NASA",
                                    "Vídeo 'Introdução ao Desenvolvimento Integrado' no YouTube (20 min)",
                                    "Slides sobre engenharia de design"
                                  ],
                                  "tips": "Use diagramas para visualizar fluxos sequenciais vs. integrados.",
                                  "learningObjective": "Dominar os conceitos básicos de desenvolvimento integrado aplicado a produtos mecatrônicos.",
                                  "commonMistakes": [
                                    "Confundir com métodos ágeis de software puro",
                                    "Ignorar o foco em hardware integrado",
                                    "Subestimar a necessidade de colaboração multifuncional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Composição de Times Multifuncionais",
                                  "subSteps": [
                                    "Listar papéis essenciais: engenheiros mecânicos, eletrônicos, de software, designers industriais e gerentes de projeto.",
                                    "Descrever responsabilidades de cada função no contexto robótico.",
                                    "Estudar técnicas de formação de equipes: diversidade de skills e comunicação.",
                                    "Explorar ferramentas de colaboração: Jira, Slack ou Microsoft Teams adaptadas para hardware.",
                                    "Simular um organograma de equipe para um projeto robótico."
                                  ],
                                  "verification": "Criar um organograma com 8-10 membros e suas interações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'The Lean Startup' (cap. sobre equipes)",
                                    "Template de organograma no Lucidchart",
                                    "Case study de equipe da Boston Dynamics"
                                  ],
                                  "tips": "Enfatize papéis híbridos para robótica, como mecatrônicos integradores.",
                                  "learningObjective": "Identificar e estruturar times multifuncionais eficazes para projetos robóticos.",
                                  "commonMistakes": [
                                    "Focar apenas em engenheiros técnicos, ignorando designers e stakeholders",
                                    "Não considerar conflitos culturais em times diversos",
                                    "Subestimar treinamento inicial da equipe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever Técnicas de Projeto em Engenharia de Design",
                                  "subSteps": [
                                    "Estudar modelos como V-Model adaptado para mecatrônica e Stage-Gate.",
                                    "Detalhar fases: conceitual, detalhamento, prototipagem, teste integrado e validação.",
                                    "Explorar ferramentas: CAD (SolidWorks), simulação (MATLAB/Simulink) e versionamento de hardware.",
                                    "Analisar iterações com DFMEA (Design Failure Mode Effects Analysis).",
                                    "Revisar métricas de progresso: KPIs como tempo de ciclo e taxa de defeitos."
                                  ],
                                  "verification": "Montar um fluxograma das fases principais com ferramentas associadas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Guia 'V-Model em Mecatrônica' (PDF IEEE)",
                                    "Software gratuito TinkerCAD para protótipos virtuais",
                                    "Vídeo tutorial Simulink para robótica"
                                  ],
                                  "tips": "Integre simulações virtuais desde cedo para validar designs.",
                                  "learningObjective": "Explicar técnicas de engenharia de design para desenvolvimento robótico integrado.",
                                  "commonMistakes": [
                                    "Aplicar modelos de software diretamente sem adaptação para hardware",
                                    "Pular análises de risco como DFMEA",
                                    "Não sincronizar fases paralelas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Processo a Produtos Robóticos Mecatrônicos",
                                  "subSteps": [
                                    "Selecionar um caso: desenvolvimento de um robô móvel autônomo.",
                                    "Mapear o fluxo integrado: do conceito à produção em escala.",
                                    "Descrever desafios específicos: integração sensor-actuador-software.",
                                    "Analisar lições aprendidas de cases reais (ex: Roomba ou drones industriais).",
                                    "Elaborar um plano de projeto simplificado com milestones."
                                  ],
                                  "verification": "Produzir um relatório de 1 página descrevendo o processo aplicado ao case.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Case study iRobot Roomba (site oficial)",
                                    "Ferramenta gratuita Draw.io para fluxogramas",
                                    "Artigo 'Mecatrônica em Robótica' da revista Robotics"
                                  ],
                                  "tips": "Sempre priorize testes em hardware real após simulações.",
                                  "learningObjective": "Sintetizar o desenvolvimento integrado especificamente para robótica mecatrônica.",
                                  "commonMistakes": [
                                    "Generalizar demais sem foco em mecatrônica",
                                    "Ignorar escalabilidade para produção",
                                    "Subestimar integração de firmware"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de braço robótico industrial, o time multifuncional inicia com sketches conceituais conjuntos (mecânica + eletrônica), prototipa em 3D impresso com Arduino integrado, itera via simulações Simulink e valida com testes reais de precisão de 0.1mm, reduzindo tempo de mercado de 18 para 9 meses.",
                              "finalVerifications": [
                                "Pode diagramar o fluxo completo de desenvolvimento integrado?",
                                "Descreve corretamente papéis multifuncionais em robótica?",
                                "Explica adaptações do V-Model para mecatrônica?",
                                "Identifica 3 desafios específicos e soluções?",
                                "Apresenta um exemplo prático com métricas de sucesso?",
                                "Compara com abordagens tradicionais?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (fundamentos corretos: 30%)",
                                "Detalhamento de times e técnicas (25%)",
                                "Aplicação contextual a robótica mecatrônica (20%)",
                                "Uso de exemplos e diagramas claros (15%)",
                                "Identificação de riscos e benefícios (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos (PMBOK para times ágeis)",
                                "Engenharia de Software (integração CI/CD com hardware)",
                                "Design Thinking (ideação colaborativa)",
                                "Gestão da Qualidade (Six Sigma em protótipos)"
                              ],
                              "realWorldApplication": "Na indústria automotiva, como na linha de montagem da Tesla com robôs colaborativos, onde times integrados reduzem falhas em 40% e aceleram inovação em veículos autônomos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Componentes Eletrônicos em Robótica Mecatrônica",
                        "description": "Estudo de microprocessadores, microcontroladores e CLPs como elementos centrais no controle de sistemas robóticos mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Diferenciar microprocessadores e microcontroladores",
                            "description": "Comparar características, aplicações e limitações de microprocessadores e microcontroladores em projetos robóticos, incluindo exemplos de programação básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender definições e componentes básicos",
                                  "subSteps": [
                                    "Pesquise a definição de microprocessador: CPU geral sem periféricos integrados.",
                                    "Pesquise a definição de microcontrolador: Sistema integrado com CPU, memória e periféricos.",
                                    "Identifique componentes principais de cada: RAM, ROM, I/O para microcontroladores; foco em ALU e registradores para microprocessadores.",
                                    "Compare arquiteturas básicas usando diagramas simples.",
                                    "Anote similaridades iniciais, como ambos processarem instruções."
                                  ],
                                  "verification": "Criar um glossário com definições e diagramas desenhados à mão ou digitais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Internet para pesquisa (sites como Wikipedia, Arduino docs)",
                                    "Papel e caneta ou software de diagrama (Draw.io)",
                                    "Notebook"
                                  ],
                                  "tips": "Use fontes confiáveis como documentações oficiais de Intel/ARM para microprocessadores e Microchip/Atmel para microcontroladores.",
                                  "learningObjective": "Diferenciar conceitualmente microprocessadores e microcontroladores por suas composições.",
                                  "commonMistakes": [
                                    "Confundir microcontrolador com processador completo",
                                    "Ignorar periféricos integrados nos microcontroladores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar características técnicas",
                                  "subSteps": [
                                    "Liste velocidades de clock típicas: microprocessadores >100MHz, microcontroladores 8-80MHz.",
                                    "Compare memória: microprocessadores usam RAM/ROM externa; microcontroladores integradas.",
                                    "Analise periféricos: microcontroladores têm ADC, PWM, UART integrados; microprocessadores precisam externos.",
                                    "Discuta consumo de energia e custo: microcontroladores mais eficientes e baratos.",
                                    "Crie uma tabela comparativa com pelo menos 5 características."
                                  ],
                                  "verification": "Tabela comparativa completa preenchida e revisada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Datasheets de exemplos: Arduino Uno (ATmega328), Raspberry Pi (ARM)"
                                  ],
                                  "tips": "Baixe datasheets oficiais para dados precisos; foque em specs reais de modelos comuns.",
                                  "learningObjective": "Identificar diferenças técnicas chave que impactam escolhas de projeto.",
                                  "commonMistakes": [
                                    "Generalizar sem exemplos reais",
                                    "Ignorar trade-offs como custo vs performance"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar aplicações e limitações em robótica",
                                  "subSteps": [
                                    "Exemplifique aplicações: microcontroladores em sensores/motores (Arduino em robô móvel); microprocessadores em visão computacional (RPi em drone).",
                                    "Discuta limitações: microcontroladores não escalam para multitarefa complexa; microprocessadores consomem mais energia.",
                                    "Analise cenários robóticos: tempo real (microcontrolador) vs processamento pesado (microprocessador).",
                                    "Pesquise cases reais de robótica mecatrônica.",
                                    "Mapeie prós/contras para projetos robóticos específicos."
                                  ],
                                  "verification": "Relatório curto com 3 exemplos de aplicações e limitações cada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Vídeos YouTube sobre Arduino vs Raspberry Pi em robótica",
                                    "Sites de projetos: Instructables, Hackster.io"
                                  ],
                                  "tips": "Pense em projetos pessoais: qual usaria para um braço robótico simples?",
                                  "learningObjective": "Aplicar diferenças a contextos robóticos práticos.",
                                  "commonMistakes": [
                                    "Subestimar limitações de energia em baterias robóticas",
                                    "Não considerar integração com outros componentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplos de programação básica e síntese",
                                  "subSteps": [
                                    "Escreva código Blink LED em microcontrolador (Arduino IDE: pinMode, digitalWrite).",
                                    "Escreva equivalente em microprocessador (Python no RPi: GPIO library).",
                                    "Compare sintaxe, bibliotecas e performance esperada.",
                                    "Simule ou execute em simuladores (Tinkercad para Arduino, RPi emulator).",
                                    "Sintetize diferenças em um resumo final com tabela atualizada."
                                  ],
                                  "verification": "Códigos funcionais testados em simulador e resumo escrito.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Arduino IDE ou online editor",
                                    "Raspberry Pi simulator (como Wokwi ou QEMU)",
                                    "Computador com internet"
                                  ],
                                  "tips": "Comece com códigos copy-paste e modifique para entender; teste delays para ver diferenças de tempo real.",
                                  "learningObjective": "Demonstrar diferenças práticas via programação em robótica.",
                                  "commonMistakes": [
                                    "Não testar códigos",
                                    "Ignorar overhead de SO em microprocessadores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um robô seguidor de linha: use microcontrolador (Arduino) para controle rápido de motores via PWM; para um robô com IA de reconhecimento de objetos, use microprocessador (Raspberry Pi) com OpenCV, conectando sensores via GPIO.",
                              "finalVerifications": [
                                "Explicar verbalmente 5 diferenças principais sem consultar notas.",
                                "Montar tabela comparativa precisa de memória.",
                                "Escolher corretamente hardware para 3 cenários robóticos dados.",
                                "Executar códigos básicos em simuladores sem erros.",
                                "Identificar limitações em um projeto hipotético robótico.",
                                "Discutir trade-offs de custo/energia/performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das definições e comparações (30%)",
                                "Qualidade da tabela e diagramas visuais (20%)",
                                "Relevância de exemplos robóticos e programação (25%)",
                                "Análise de limitações e aplicações práticas (15%)",
                                "Clareza do resumo final e verificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Lógica e sintaxe em C/Python.",
                                "Eletrônica: Periféricos e interfaces GPIO.",
                                "Física: Consumo de energia e sinais elétricos.",
                                "Matemática: Lógica booleana e operações binárias.",
                                "Informática: Sistemas operacionais vs bare-metal."
                              ],
                              "realWorldApplication": "Na indústria automotiva, microcontroladores gerenciam freios ABS em tempo real (ex: ECU em carros); microprocessadores processam dados de sensores em veículos autônomos (ex: Tesla com visão computacional)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Descrever o uso de CLPs em robótica",
                            "description": "Explicar o papel dos Controladores Lógicos Programáveis (CLPs) em automação robótica, com ênfase em programação ladder e integração com sensores e atuadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos CLPs e seu Papel na Robótica",
                                  "subSteps": [
                                    "Definir o que é um Controlador Lógico Programável (CLP) e suas componentes principais (CPU, entradas/saídas, memória).",
                                    "Explicar as vantagens dos CLPs em automação robótica comparados a microcontroladores.",
                                    "Identificar aplicações típicas de CLPs em robôs industriais, como controle de sequências e loops.",
                                    "Descrever o ciclo de operação de um CLP (scan cycle: leitura de entradas, execução do programa, atualização de saídas).",
                                    "Analisar diagramas básicos de CLP em contextos robóticos."
                                  ],
                                  "verification": "Resumir em um diagrama ou parágrafo o ciclo de scan e o papel do CLP na robótica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Apresentação sobre CLPs, diagrama de ciclo de scan, vídeo introdutório (ex: YouTube sobre PLC basics).",
                                  "tips": "Use analogias como 'cérebro do robô' para fixar conceitos.",
                                  "learningObjective": "Entender a arquitetura e função básica dos CLPs em sistemas robóticos.",
                                  "commonMistakes": "Confundir CLPs com microcontroladores Arduino; ignorar o ciclo de scan."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Programação Ladder (Ladder Logic)",
                                  "subSteps": [
                                    "Estudar os símbolos básicos do ladder: contatos normalmente aberto/fechado, bobinas, timers e contadores.",
                                    "Criar um programa ladder simples para ligar/desligar uma saída baseado em entrada.",
                                    "Implementar lógica de sequência: AND, OR, NOT usando ladder.",
                                    "Adicionar funções avançadas como timers (TON, TOF) e contadores (CTU, CTD).",
                                    "Simular o programa em software gratuito como OpenPLC ou LogixPro."
                                  ],
                                  "verification": "Executar simulação de um programa ladder que aciona uma sequência de 3 saídas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de simulação Ladder (OpenPLC Editor), tutoriais ladder logic PDF.",
                                  "tips": "Pense em ladder como diagramas elétricos; desenhe no papel antes de codificar.",
                                  "learningObjective": "Programar lógicas básicas e sequenciais em ladder para controle robótico.",
                                  "commonMistakes": "Esquecer de resetar timers/contadores; lógica invertida em contatos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Sensores ao CLP em Sistemas Robóticos",
                                  "subSteps": [
                                    "Classificar sensores comuns em robótica (proximidade, ópticos, encoders) e suas interfaces (digital/analógico).",
                                    "Mapear entradas do CLP para sensores: configuração de addressing (ex: I0.0 para sensor 1).",
                                    "Programar ladder para ler sinais de sensores e disparar ações condicionais.",
                                    "Tratar ruídos e debounce em entradas digitais.",
                                    "Testar integração em simulação com inputs virtuais."
                                  ],
                                  "verification": "Criar ladder que reage a 2 sensores diferentes (ex: parar robô se sensor detectar obstáculo).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Esquemas de sensores, CLP simulator com I/O virtuais.",
                                  "tips": "Sempre verifique polaridade e tensão dos sensores antes de conectar.",
                                  "learningObjective": "Configurar e programar CLPs para processar dados de sensores robóticos.",
                                  "commonMistakes": "Não mapear corretamente endereços I/O; ignorar sinais analógicos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Atuadores e Testar o Sistema Completo",
                                  "subSteps": [
                                    "Identificar atuadores robóticos (motores, solenoides, servos) e suas conexões a saídas do CLP.",
                                    "Programar ladder para controlar atuadores baseado em sensores e lógica.",
                                    "Implementar modos de segurança: emergency stop e intertravamentos.",
                                    "Simular sistema completo: sensor -> CLP ladder -> atuador.",
                                    "Documentar o programa com comentários em ladder."
                                  ],
                                  "verification": "Simular e registrar um ciclo completo de operação robótica controlado por CLP.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "CLP simulator avançado, lista de atuadores comuns.",
                                  "tips": "Use relés de saída para atuadores de alta potência.",
                                  "learningObjective": "Controlar atuadores via CLP integrado a sensores em cenários robóticos.",
                                  "commonMistakes": "Sobrecarregar saídas do CLP; faltar safety interlocks."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Sintetizar o Uso de CLPs em Robótica",
                                  "subSteps": [
                                    "Analisar casos reais de falhas em CLPs robóticos e soluções.",
                                    "Comparar ladder com outras linguagens (ex: FBD, ST).",
                                    "Escrever um relatório descrevendo o fluxo completo: sensores -> CLP -> atuadores.",
                                    "Discutir escalabilidade para robôs colaborativos (cobots).",
                                    "Planejar próximo passo: programação em hardware real."
                                  ],
                                  "verification": "Produzir relatório de 1 página com diagrama e explicação do sistema.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Templates de relatório, estudos de caso industriais.",
                                  "tips": "Inclua prints de simulações no relatório para evidência.",
                                  "learningObjective": "Sintetizar conhecimentos para descrever integralmente o uso de CLPs em robótica.",
                                  "commonMistakes": "Focar só em teoria sem exemplos práticos; omitir segurança."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem automotiva, um CLP controla um braço robótico: sensores de proximidade detectam peça (entrada I0.1), ladder ativa timer de 5s e aciona motor (saída Q0.0) para posicionar peça, com emergency stop (I0.0) parando tudo.",
                              "finalVerifications": [
                                "Descreve corretamente o ciclo de scan do CLP.",
                                "Explica programação ladder com pelo menos 3 símbolos básicos.",
                                "Demonstra integração de 2 sensores e 1 atuador em ladder simulado.",
                                "Identifica 2 vantagens dos CLPs em robótica industrial.",
                                "Apresenta diagrama de um sistema robótico completo com CLP.",
                                "Discute uma medida de segurança em CLP robótico."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de CLPs e ladder (30%).",
                                "Detalhe e correção na integração sensores/atuadores (25%).",
                                "Clareza e estrutura da explicação (20%).",
                                "Uso de exemplos práticos e simulações (15%).",
                                "Cobertura de segurança e aplicações reais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Interfaces de sensores e atuadores.",
                                "Programação: Lógica booleana e linguagens industriais.",
                                "Mecânica: Cinemática de robôs controlados por CLP.",
                                "Informática: Simulação e HMI (Interfaces Homem-Máquina)."
                              ],
                              "realWorldApplication": "CLPs são essenciais em indústrias como automotiva (linhas de solda robótica da Volkswagen), alimentícia (empacotamento automatizado) e farmacêutica, garantindo controle preciso, redundância e conformidade com normas de segurança como ISO 13849."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Aplicar componentes em esquemas simples",
                            "description": "Montar diagramas conceituais de circuitos robóticos utilizando microcontroladores e CLPs para controle de movimento e feedback.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Selecionar Componentes Essenciais",
                                  "subSteps": [
                                    "Liste os componentes básicos para circuitos robóticos: microcontrolador (ex: Arduino), CLP, motores DC/servos, sensores (ex: encoders, proximidade), fontes de alimentação e resistores.",
                                    "Analise funções: microcontrolador para lógica sequencial, CLP para controle lógico industrial, sensores para feedback.",
                                    "Crie uma tabela de especificações: tensão, corrente, pinos de I/O necessários.",
                                    "Verifique compatibilidade entre componentes (ex: níveis lógicos 5V/3.3V).",
                                    "Desenhe símbolos esquemáticos padronizados para cada componente."
                                  ],
                                  "verification": "Tabela de componentes completa com símbolos desenhados e compatibilidades anotadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de papel ou software de diagramação (ex: Draw.io, Fritzing), catálogo de componentes eletrônicos.",
                                  "tips": "Use bibliotecas de símbolos prontos em software para agilizar.",
                                  "learningObjective": "Compreender papéis e especificações de componentes em circuitos robóticos.",
                                  "commonMistakes": "Ignorar compatibilidade de tensão, levando a danos em simulações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar Esquema Básico de Controle de Movimento",
                                  "subSteps": [
                                    "Conecte microcontrolador aos motores: defina pinos PWM para controle de velocidade.",
                                    "Inclua CLP para relés ou saídas lógicas que acionem motores em sequências.",
                                    "Adicione fonte de alimentação com capacitores de desacoplamento.",
                                    "Desenhe linhas de sinal e terra claramente, usando convenções IEC.",
                                    "Rotule todas as conexões com referências (ex: M1 para Motor 1)."
                                  ],
                                  "verification": "Esquema básico desenhado com todas conexões rotuladas e sem curtos-circuitos visíveis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de esquemas (ex: KiCad, Eagle), régua e lápis para rascunhos.",
                                  "tips": "Mantenha o diagrama limpo: evite cruzamentos desnecessários de fios.",
                                  "learningObjective": "Projetar conexões para acionamento preciso de atuadores.",
                                  "commonMistakes": "Esquecer terra comum, causando flutuações de sinal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Mecanismos de Feedback",
                                  "subSteps": [
                                    "Conecte sensores de feedback (ex: encoder no eixo do motor) aos pinos analógicos do microcontrolador.",
                                    "Configure entradas do CLP para sinais de limite ou proximidade.",
                                    "Adicione lógica de loop fechado: sensor -> microcontrolador/CLP -> ajuste motor.",
                                    "Inclua pull-up/down resistors para entradas digitais estáveis.",
                                    "Desenhe blocos funcionais para loops de feedback (PID conceitual)."
                                  ],
                                  "verification": "Loops de feedback mapeados no diagrama com resistores e conexões corretas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Datasheets de sensores, multímetro virtual no software.",
                                  "tips": "Teste conexões logicamente: simule sinal do sensor.",
                                  "learningObjective": "Implementar feedback para controle estável de movimento.",
                                  "commonMistakes": "Conectar sensores analógicos em pinos digitais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Finalizar o Diagrama Conceitual",
                                  "subSteps": [
                                    "Revise o diagrama completo: verifique continuidade, polaridades e sobrecargas.",
                                    "Simule o circuito em software (ex: Tinkercad, Proteus).",
                                    "Adicione legendas, escalas e notas de segurança (ex: fusíveis).",
                                    "Documente fluxo de sinal: de comando a feedback.",
                                    "Compare com normas (ex: IEC 61131 para CLPs)."
                                  ],
                                  "verification": "Simulação sem erros e diagrama documentado com notas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Simulador de circuitos online, normas IEC impressas.",
                                  "tips": "Use zoom e camadas no software para detalhes finos.",
                                  "learningObjective": "Garantir viabilidade e segurança do esquema.",
                                  "commonMistakes": "Sobrecarregar pinos de I/O sem drivers."
                                }
                              ],
                              "practicalExample": "Desenhe um diagrama para um braço robótico simples: Arduino controla servo para movimento, CLP gerencia fim-de-curso via sensor de proximidade, encoder fornece feedback de posição para correção PID básica.",
                              "finalVerifications": [
                                "Todos componentes listados com especificações corretas.",
                                "Conexões de sinal e potência sem erros lógicos.",
                                "Loops de feedback integrados e rotulados.",
                                "Simulação roda sem falhas.",
                                "Diagrama segue convenções padrão e está legível.",
                                "Notas de segurança incluídas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção e conexão de componentes (30%).",
                                "Clareza e organização do diagrama (25%).",
                                "Correta implementação de controle e feedback (25%).",
                                "Validação via simulação e verificações (15%).",
                                "Documentação completa e profissional (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de eletricidade e electromagnetismo em motores.",
                                "Programação: Lógica de controle similar a linguagens ladder para CLPs.",
                                "Matemática: Cálculos de resistores e loops PID.",
                                "Informática: Uso de software CAD para esquemas."
                              ],
                              "realWorldApplication": "Em linhas de montagem automatizadas, onde CLPs controlam robôs colaborativos (cobots) com feedback sensorial para precisão em soldagem ou pick-and-place, reduzindo erros humanos em indústrias como automotiva."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Aplicações na Indústria Aeronáutica",
                        "description": "Exploração de robótica mecatrônica aplicada à manufatura e montagem aeronáutica, incluindo visão por computador.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Identificar aplicações robóticas aeronáuticas",
                            "description": "Listar e exemplificar usos de robôs mecatrônicos na indústria aeronáutica, como soldagem, inspeção e montagem de componentes de aeronaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e listar aplicações gerais de robôs mecatrônicos na indústria aeronáutica",
                                  "subSteps": [
                                    "Acessar fontes confiáveis como sites oficiais da Boeing, Airbus e Embraer.",
                                    "Identificar aplicações principais: soldagem, inspeção, montagem e pintura.",
                                    "Registrar pelo menos 5 aplicações com descrições breves.",
                                    "Classificar por estágio de produção (fabricação, montagem, manutenção).",
                                    "Anotar exemplos iniciais de empresas que utilizam essas tecnologias."
                                  ],
                                  "verification": "Lista documentada com pelo menos 5 aplicações classificadas e fontes citadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com internet",
                                    "Bloco de notas ou documento digital",
                                    "Sites de fabricantes aeronáuticos"
                                  ],
                                  "tips": "Priorize fontes recentes (últimos 5 anos) para relevância tecnológica.",
                                  "learningObjective": "Compreender o panorama geral das aplicações robóticas na aeronáutica.",
                                  "commonMistakes": [
                                    "Confundir aplicações automotivas com aeronáuticas",
                                    "Listar aplicações sem fontes verificáveis",
                                    "Ignorar o aspecto mecatrônico (sensores e atuadores)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar aplicações de soldagem e montagem robótica",
                                  "subSteps": [
                                    "Estudar robôs para soldagem de fuselagens e estruturas leves.",
                                    "Descrever componentes mecatrônicos envolvidos (braços robóticos, sensores de visão).",
                                    "Exemplificar montagem de componentes como rebites em asas.",
                                    "Comparar precisão robótica vs. manual.",
                                    "Documentar vantagens como redução de fadiga humana."
                                  ],
                                  "verification": "Relatório com diagramas ou descrições detalhadas de 2 aplicações, incluindo componentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Vídeos tutoriais no YouTube (canais oficiais)",
                                    "Softwares de desenho simples como Draw.io",
                                    "Artigos técnicos sobre robótica industrial"
                                  ],
                                  "tips": "Busque vídeos de demonstração para visualizar o processo em ação.",
                                  "learningObjective": "Dominar exemplos concretos de soldagem e montagem com ênfase mecatrônica.",
                                  "commonMistakes": [
                                    "Subestimar requisitos de precisão aeronáutica",
                                    "Omitir integração de sensores",
                                    "Generalizar sem exemplos específicos de aeronaves"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar inspeção e manutenção robótica em aeronaves",
                                  "subSteps": [
                                    "Investigar robôs para inspeção não destrutiva (ultrassom, drones internos).",
                                    "Listar usos em detecção de rachaduras em fuselagens e turbinas.",
                                    "Analisar robôs móveis para manutenção em hangares.",
                                    "Exemplificar com casos reais como inspeção de Boeing 787.",
                                    "Destacar integração de IA para análise de dados."
                                  ],
                                  "verification": "Lista de 3 exemplos de inspeção com fluxogramas de processo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Artigos da NASA ou FAA sobre robótica",
                                    "Ferramentas de mind mapping online",
                                    "Vídeos de inspeção robótica"
                                  ],
                                  "tips": "Foque em robôs mecatrônicos com múltiplos sensores para inspeções complexas.",
                                  "learningObjective": "Identificar aplicações avançadas de inspeção e seu impacto na segurança.",
                                  "commonMistakes": [
                                    "Confundir drones civis com robôs industriais mecatrônicos",
                                    "Ignorar normas de certificação aeronáutica",
                                    "Não relacionar com manutenção preditiva"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar conhecimentos e criar exemplos práticos completos",
                                  "subSteps": [
                                    "Compilar todas as aplicações em uma tabela unificada.",
                                    "Criar 3 exemplos detalhados com contextos reais (ex: Airbus A350).",
                                    "Avaliar benefícios econômicos e de segurança.",
                                    "Pesquisar tendências futuras como robôs colaborativos.",
                                    "Preparar apresentação ou resumo final."
                                  ],
                                  "verification": "Tabela ou apresentação com 8+ aplicações exemplificadas e análise de tendências.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Imagens de robôs aeronáuticos",
                                    "Fontes de tendências (relatórios da Deloitte ou McKinsey)"
                                  ],
                                  "tips": "Use tabelas para facilitar comparação entre aplicações.",
                                  "learningObjective": "Integrar conhecimentos para identificação abrangente de aplicações.",
                                  "commonMistakes": [
                                    "Listas superficiais sem exemplos",
                                    "Omitir benefícios quantitativos",
                                    "Não considerar limitações robóticas"
                                  ]
                                }
                              ],
                              "practicalExample": "Na linha de produção do Boeing 787 Dreamliner, robôs mecatrônicos KUKA realizam a soldagem de painéis de compósitos com precisão de 0,1 mm, integrando sensores de visão para alinhamento automático, reduzindo tempo de produção em 30%.",
                              "finalVerifications": [
                                "Capacidade de listar pelo menos 8 aplicações robóticas aeronáuticas com exemplos.",
                                "Descrição precisa de componentes mecatrônicos em cada aplicação.",
                                "Identificação correta de vantagens e limitações.",
                                "Fontes citadas em todos os exemplos.",
                                "Análise de pelo menos 2 tendências futuras.",
                                "Tabela ou diagrama sintetizando as aplicações."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da lista de aplicações (mínimo 8).",
                                "Qualidade e relevância dos exemplos práticos.",
                                "Profundidade na descrição de aspectos mecatrônicos.",
                                "Correta classificação por estágio de produção.",
                                "Uso adequado de fontes confiáveis e citações.",
                                "Clareza na síntese e análise de benefícios."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Mecânica: Design de estruturas aeronáuticas.",
                                "Programação e Automação: Controle de robôs via PLC e ROS.",
                                "Gestão Industrial: Otimização de processos produtivos.",
                                "Segurança do Trabalho: Normas ISO para robótica colaborativa.",
                                "Inteligência Artificial: Processamento de imagens em inspeções."
                              ],
                              "realWorldApplication": "Essa habilidade permite atuar em fábricas aeronáuticas como Embraer ou Airbus, projetando linhas de produção robóticas, reduzindo custos e erros humanos, com demanda crescente em manutenção preditiva para frotas comerciais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Introduzir sistemas de visão por computador",
                            "description": "Descrever princípios básicos de visão computacional em robótica, como processamento de imagens para detecção de defeitos em peças aeronáuticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Princípios Básicos de Visão Computacional",
                                  "subSteps": [
                                    "Estudar o que é visão computacional e sua aplicação em robótica.",
                                    "Aprender conceitos chave como pixels, canais de cor (RGB) e resolução de imagem.",
                                    "Explorar o pipeline típico: aquisição, processamento e análise.",
                                    "Identificar diferenças entre visão computacional e visão humana.",
                                    "Revisar exemplos históricos de visão computacional em indústrias."
                                  ],
                                  "verification": "Resumir em um diagrama os componentes principais do pipeline de visão computacional.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Apresentação em slides sobre visão computacional, vídeo introdutório (YouTube: 'Computer Vision Basics'), caderno para anotações.",
                                  "tips": "Use analogias cotidianas, como comparar pixels a blocos de Lego, para fixar conceitos.",
                                  "learningObjective": "Compreender os fundamentos teóricos da visão computacional e seu papel em robótica.",
                                  "commonMistakes": "Confundir visão computacional com aprendizado de máquina; visão computacional é mais ampla."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente e Realizar Aquisição de Imagens",
                                  "subSteps": [
                                    "Instalar bibliotecas essenciais como OpenCV e Python.",
                                    "Capturar imagens de peças aeronáuticas usando câmera ou webcam.",
                                    "Carregar e exibir imagens em um script Python básico.",
                                    "Aplicar transformações simples como redimensionamento e conversão para escala de cinza.",
                                    "Salvar imagens processadas para análise posterior."
                                  ],
                                  "verification": "Executar um script que captura e exibe uma imagem de uma peça com defeito simulado.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Computador com Python 3+, OpenCV (pip install opencv-python), câmera USB, imagens de amostra de peças aeronáuticas.",
                                  "tips": "Teste a câmera em diferentes iluminções para entender impactos na qualidade da imagem.",
                                  "learningObjective": "Configurar ferramentas e realizar aquisição inicial de imagens para processamento.",
                                  "commonMistakes": "Ignorar calibração da câmera, levando a distorções nas imagens."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Pré-processamento e Detecção Básica de Defeitos",
                                  "subSteps": [
                                    "Aplicar filtros como Gaussian Blur para redução de ruído.",
                                    "Usar detecção de bordas com Canny Edge Detector.",
                                    "Implementar segmentação por limiarização (thresholding) para isolar defeitos.",
                                    "Detectar contornos e medir áreas de possíveis defeitos como rachaduras.",
                                    "Marcar defeitos visualmente na imagem com retângulos ou círculos."
                                  ],
                                  "verification": "Processar uma imagem de peça aeronáutica e gerar output com defeitos destacados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Jupyter Notebook, OpenCV, imagens de peças com defeitos artificiais (rachaduras desenhadas).",
                                  "tips": "Ajuste parâmetros do Canny iterativamente para otimizar detecção em diferentes texturas.",
                                  "learningObjective": "Dominar técnicas de pré-processamento e detecção para identificar defeitos em imagens.",
                                  "commonMistakes": "Aplicar filtros excessivos, borrando defeitos reais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Visão Computacional com Robótica",
                                  "subSteps": [
                                    "Conectar o script de visão a um braço robótico simulado (usando ROS ou simulator).",
                                    "Configurar triggers: robô para quando defeito é detectado.",
                                    "Transmitir coordenadas de defeito para o robô via API ou sockets.",
                                    "Testar loop completo: aquisição -> detecção -> ação robótica.",
                                    "Registrar logs de detecções para análise."
                                  ],
                                  "verification": "Demonstrar um ciclo onde o robô 'rejeita' uma peça defeituosa baseada na detecção.",
                                  "estimatedTime": "3 horas",
                                  "materials": "ROS (Robot Operating System) ou Gazebo simulator, script Python integrado.",
                                  "tips": "Use threading para processamento em tempo real sem travar o robô.",
                                  "learningObjective": "Integrar sistemas de visão em fluxos robóticos para automação industrial.",
                                  "commonMistakes": "Sincronização inadequada entre visão e movimento robótico."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Otimizar o Sistema",
                                  "subSteps": [
                                    "Calcular métricas como precisão e recall em conjunto de imagens de teste.",
                                    "Ajustar hiperparâmetros baseados em falsos positivos/negativos.",
                                    "Testar em condições reais: diferentes ângulos e iluminções.",
                                    "Documentar pipeline completo em relatório.",
                                    "Planejar melhorias como ML para detecção avançada."
                                  ],
                                  "verification": "Gerar relatório com métricas acima de 85% de acurácia em 10 imagens de teste.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Conjunto de dados de teste (20 imagens), planilha para métricas.",
                                  "tips": "Use cross-validation simples dividindo dados em treino/teste.",
                                  "learningObjective": "Avaliar performance e iterar para robustez em cenários industriais.",
                                  "commonMistakes": "Testar apenas em imagens ideais, ignorando variações reais."
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de asas de aeronaves, o sistema captura imagens de uma peça, detecta uma rachadura de 2mm via bordas e contornos, e sinaliza o braço robótico para remover a peça defeituosa, prevenindo falhas estruturais.",
                              "finalVerifications": [
                                "Explicar o pipeline de visão computacional em robótica.",
                                "Executar detecção de defeito em imagem real com >80% acurácia.",
                                "Integrar visão com simulação robótica funcional.",
                                "Identificar e corrigir 3 erros comuns em processamento de imagens.",
                                "Documentar métricas de performance do sistema.",
                                "Discutir limitações e melhorias potenciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de defeitos (mín. 85%).",
                                "Correta configuração e uso de OpenCV.",
                                "Integração seamless com componente robótico.",
                                "Relatório claro com diagramas e métricas.",
                                "Compreensão demonstrada em explicação oral.",
                                "Tratamento de variações em iluminação e ângulo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de Python e bibliotecas como OpenCV.",
                                "Inteligência Artificial: Introdução a técnicas de ML para visão avançada.",
                                "Engenharia Aeronáutica: Inspeção de qualidade em manufatura.",
                                "Matemática: Processamento de matrizes e estatística em imagens.",
                                "Física: Óptica e propriedades de luz em aquisição de imagens."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Boeing ou Embraer, sistemas de visão por computador em robôs inspecionam fuselagens e turbinas para defeitos microscópicos, reduzindo tempo de inspeção em 70% e aumentando segurança de voo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Analisar elaboração de projetos mecatrônicos aeronáuticos",
                            "description": "Discutir etapas de elaboração e execução de projetos robóticos para a indústria aeronáutica, referenciando bibliografia como Shetty & Kolk.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Projetos Mecatrônicos Aeronáuticos",
                                  "subSteps": [
                                    "Ler capítulos iniciais do livro 'Mechatronics System Design' de Shetty & Kolk sobre integração de sistemas mecatrônicos.",
                                    "Identificar componentes essenciais: atuadores, sensores e controladores usados em aplicações aeronáuticas.",
                                    "Pesquisar exemplos de robótica em montagem de aeronaves, como braços robóticos para fuselagem.",
                                    "Mapear requisitos específicos da indústria aeronáutica, como leveza e precisão.",
                                    "Anotar definições chave de mecatrônica aplicada à robótica aeronáutica."
                                  ],
                                  "verification": "Produzir um mapa conceitual com pelo menos 10 componentes e suas funções.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro Shetty & Kolk",
                                    "Artigos da IEEE sobre robótica aeronáutica",
                                    "Vídeos de montagem robótica da Boeing"
                                  ],
                                  "tips": "Priorize diagramas visuais para melhor retenção dos conceitos integrados.",
                                  "learningObjective": "Dominar os princípios básicos de integração mecatrônica em contextos aeronáuticos.",
                                  "commonMistakes": [
                                    "Ignorar restrições aeronáuticas como vibração e peso",
                                    "Confundir mecatrônica com automação industrial genérica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Etapas de Elaboração de Projetos",
                                  "subSteps": [
                                    "Listar as fases padrão: concepção, design conceitual, modelagem e simulação.",
                                    "Estudar ferramentas CAD/CAM para modelagem 3D de sistemas robóticos.",
                                    "Analisar integração de software de controle (ex: MATLAB/Simulink) conforme Shetty & Kolk.",
                                    "Revisar especificações técnicas para conformidade aeronáutica (FAA/ANAC).",
                                    "Documentar fluxogramas das etapas de elaboração."
                                  ],
                                  "verification": "Criar um fluxograma detalhado das 5-7 etapas principais de elaboração.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software CAD gratuito como FreeCAD",
                                    "Capítulos 4-6 de Shetty & Kolk",
                                    "Normas aeronáuticas online"
                                  ],
                                  "tips": "Use exemplos reais para ilustrar cada etapa, facilitando a compreensão sequencial.",
                                  "learningObjective": "Identificar e descrever as etapas sequenciais de elaboração de projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Pular simulações virtuais",
                                    "Não considerar iterações cíclicas no design"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Execução e Integração de Projetos Robóticos",
                                  "subSteps": [
                                    "Descrever montagem física: integração de hardware mecatrônico.",
                                    "Analisar programação de controladores para tarefas aeronáuticas repetitivas.",
                                    "Estudar testes iniciais: calibração, tuning e validação.",
                                    "Avaliar gerenciamento de riscos durante execução, como falhas em atuadores.",
                                    "Simular cenários de integração usando ferramentas básicas."
                                  ],
                                  "verification": "Elaborar um relatório de 1 página sobre um ciclo de execução simulado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Simuladores como Gazebo/ROS",
                                    "Shetty & Kolk capítulos de implementação",
                                    "Vídeos de testes robóticos da Airbus"
                                  ],
                                  "tips": "Registre métricas de performance em cada sub-etapa para análise quantitativa.",
                                  "learningObjective": "Compreender processos de execução e integração em projetos reais.",
                                  "commonMistakes": [
                                    "Subestimar testes de integração",
                                    "Ignorar feedback loops em controladores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Referenciar Bibliografia e Realizar Análise Crítica",
                                  "subSteps": [
                                    "Citar trechos relevantes de Shetty & Kolk sobre projetos robóticos.",
                                    "Comparar com casos reais da indústria aeronáutica (ex: drones de inspeção).",
                                    "Criticar limitações: custo, escalabilidade e inovação.",
                                    "Buscar artigos complementares em bases como Scopus ou Google Scholar.",
                                    "Sintetizar lições aprendidas em uma tabela comparativa."
                                  ],
                                  "verification": "Produzir uma análise crítica de 500 palavras com 3 referências.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Shetty & Kolk (edição completa)",
                                    "Bases de dados acadêmicas",
                                    "Relatórios da Embraer sobre robótica"
                                  ],
                                  "tips": "Use citações APA para credibilidade acadêmica.",
                                  "learningObjective": "Aplicar referências bibliográficas para embasar análises críticas.",
                                  "commonMistakes": [
                                    "Citar superficialmente sem análise",
                                    "Ignorar fontes recentes pós-Shetty & Kolk"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Avaliar Projetos Completos",
                                  "subSteps": [
                                    "Revisar um projeto completo: do conceito à operação.",
                                    "Avaliar métricas de sucesso: eficiência, segurança e custo.",
                                    "Propor melhorias baseadas na análise.",
                                    "Discutir escalabilidade para produção em massa aeronáutica.",
                                    "Preparar apresentação resumida das conclusões."
                                  ],
                                  "verification": "Apresentar um resumo executivo de 10 slides sobre um projeto analisado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de apresentação como PowerPoint",
                                    "Casos de estudo da NASA",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Foque em impactos mensuráveis para fortalecer argumentos.",
                                  "learningObjective": "Sintetizar análises em avaliações holísticas de projetos.",
                                  "commonMistakes": [
                                    "Focar só em teoria sem avaliação prática",
                                    "Não propor inovações viáveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Analisar o projeto de um sistema robótico mecatrônico para inspeção não-destrutiva de asas de aeronaves da Embraer: mapear etapas de design em CAD, simulação em Simulink, montagem com sensores ultrassônicos, testes de calibração e integração em linha de produção, referenciando Shetty & Kolk para controle PID.",
                              "finalVerifications": [
                                "Pode listar e explicar 5 etapas principais de elaboração de projetos mecatrônicos aeronáuticos.",
                                "Identifica componentes mecatrônicos chave em um exemplo real.",
                                "Critica limitações de um projeto robótico com base em bibliografia.",
                                "Cria fluxogramas precisos de execução.",
                                "Propõe melhorias viáveis para aplicações aeronáuticas.",
                                "Referencia corretamente Shetty & Kolk em análises."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de etapas (80% cobertura das fases chave).",
                                "Profundidade da análise crítica com referências bibliográficas.",
                                "Qualidade dos fluxogramas e diagramas visuais.",
                                "Relevância de exemplos à indústria aeronáutica.",
                                "Capacidade de propor soluções inovadoras e factíveis.",
                                "Clareza e organização na síntese final."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Aeroespacial: Design de estruturas leves.",
                                "Programação e Controle: PLCs e algoritmos de IA.",
                                "Gestão de Projetos: Metodologias Ágeis/PMBOK.",
                                "Materiais Avançados: Compósitos para robótica.",
                                "Segurança e Normas: Certificações FAA/EASA."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Boeing e Airbus, projetos mecatrônicos robóticos automatizam soldagem, pintura e inspeção de componentes, reduzindo tempo de produção em 30-50%, minimizando erros humanos e atendendo padrões de segurança rigorosos."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.3.1",
                              "10.1.5.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.4",
                            "name": "Referenciar bibliografia especializada",
                            "description": "Consultar e resumir conceitos chave de obras como 'Mechatronics System Design' de Shetty & Kolk e 'Electromechanical Systems' de Lyshevski aplicados à robótica aeronáutica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Localizar Fontes Bibliográficas Especializadas",
                                  "subSteps": [
                                    "Pesquise catálogos de bibliotecas acadêmicas ou plataformas como Google Scholar, IEEE Xplore e ResearchGate usando termos como 'Mechatronics System Design Shetty Kolk' e 'Electromechanical Systems Lyshevski robótica aeronáutica'.",
                                    "Verifique edições mais recentes dos livros citados e identifique capítulos relevantes sobre sistemas mecatrônicos em aplicações aeronáuticas.",
                                    "Compile uma lista inicial de 3-5 fontes primárias, incluindo ISBN, autores e ano de publicação.",
                                    "Acesse versões digitais via bibliotecas universitárias ou serviços como SpringerLink.",
                                    "Anote metadados completos para citações futuras (APA, IEEE ou ABNT)."
                                  ],
                                  "verification": "Lista de fontes com metadados completos e links de acesso salvos em um documento compartilhável.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Acesso à internet, conta em biblioteca acadêmica, software de notas como Evernote ou Notion.",
                                  "tips": "Priorize fontes peer-reviewed e evite resumos genéricos de sites como Wikipedia.",
                                  "learningObjective": "Dominar a busca eficiente por literatura técnica especializada em mecatrônica aeronáutica.",
                                  "commonMistakes": "Ignorar edições atualizadas ou selecionar fontes irrelevantes sem verificação de aplicação em robótica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Consultar e Extrair Conceitos Chave das Obras",
                                  "subSteps": [
                                    "Leia índices e prefácios dos livros para mapear seções sobre modelagem de sistemas mecatrônicos e atuadores eletromecânicos.",
                                    "Extraia conceitos chave como integração de sensores em 'Mechatronics System Design' (capítulos sobre design de sistemas) e controle dinâmico em 'Electromechanical Systems'.",
                                    "Destaque passagens relevantes para robótica aeronáutica, como UAVs e sistemas de controle de voo.",
                                    "Crie um mapa mental conectando conceitos a aplicações aeronáuticas específicas.",
                                    "Registre citações diretas com páginas exatas."
                                  ],
                                  "verification": "Mapa mental ou tabela com pelo menos 10 conceitos chave extraídos, incluindo citações.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Cópias digitais ou físicas dos livros, software de leitura anotada como Adobe Acrobat ou Zotero.",
                                  "tips": "Use busca por palavras-chave nos PDFs para agilizar a extração.",
                                  "learningObjective": "Extrair e organizar informações técnicas de forma sistemática de textos especializados.",
                                  "commonMistakes": "Cópia literal sem compreensão ou pular contexto histórico dos conceitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resumir Conceitos Chave Aplicados à Robótica Aeronáutica",
                                  "subSteps": [
                                    "Escreva resumos concisos (100-200 palavras por conceito) adaptando-os a cenários de robótica aeronáutica, como drones autônomos.",
                                    "Compare abordagens de Shetty & Kolk (design integrado) com Lyshevski (modelos eletromecânicos) em contextos de UAVs.",
                                    "Inclua diagramas ou equações simplificadas dos livros para ilustrar aplicações.",
                                    "Valide resumos com referências cruzadas entre os dois livros.",
                                    "Formate resumos em parágrafos coesos com linguagem técnica precisa."
                                  ],
                                  "verification": "Documento com 5-7 resumos estruturados, incluindo diagramas e comparações.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Processador de texto como LaTeX ou Microsoft Word, ferramentas de diagramação como Draw.io.",
                                  "tips": "Mantenha resumos objetivos, focando em 20% do conteúdo chave que gera 80% do valor.",
                                  "learningObjective": "Sintetizar literatura complexa em resumos acionáveis para projetos de robótica.",
                                  "commonMistakes": "Resumos muito genéricos sem ligação explícita à robótica aeronáutica ou distorção de conceitos originais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Referências em um Projeto ou Relatório",
                                  "subSteps": [
                                    "Incorpore resumos e citações em uma seção de bibliografia de um projeto mecatrônico aeronáutico.",
                                    "Use normas de citação (ex: IEEE) para listar fontes no formato correto.",
                                    "Crie uma tabela de referências com colunas: Conceito, Fonte, Página, Aplicação Aeronáutica.",
                                    "Revise o texto final para consistência e ausência de plágio.",
                                    "Compartilhe o documento para feedback inicial."
                                  ],
                                  "verification": "Relatório ou seção de projeto com referências integradas e tabela de síntese.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "Ferramentas de gerenciamento de referências como Mendeley ou EndNote, template de relatório.",
                                  "tips": "Automatize citações com plugins para evitar erros manuais.",
                                  "learningObjective": "Aplicar referências bibliográficas de forma ética e integrada em contextos profissionais.",
                                  "commonMistakes": "Citações incompletas ou falha em parafrasear adequadamente."
                                }
                              ],
                              "practicalExample": "Em um projeto de drone autônomo, resuma o capítulo 5 de 'Mechatronics System Design' sobre modelagem de atuadores, aplicando-o ao controle de hélices: 'Shetty & Kolk descrevem equações de transferência para servomotores (p. 245), adaptáveis a estabilização de UAVs em ventos turbulentos.'",
                              "finalVerifications": [
                                "Todas as fontes têm citações completas e precisas (autor, ano, página).",
                                "Resumos capturam conceitos chave sem distorções, validados por releitura das fontes.",
                                "Aplicações à robótica aeronáutica são explícitas e relevantes.",
                                "Normas de citação são consistentes (ex: IEEE).",
                                "Ausência de plágio detectada por ferramentas como Turnitin.",
                                "Tabela de síntese conecta pelo menos 5 conceitos a cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão e fidelidade aos conceitos originais dos livros (nota 1-10).",
                                "Profundidade da aplicação à robótica aeronáutica (relevância e exemplos).",
                                "Qualidade dos resumos: clareza, concisão e linguagem técnica.",
                                "Correção das citações e formatação bibliográfica.",
                                "Criatividade nas conexões interdisciplinares e verificações internas.",
                                "Completude da estrutura: steps seguidos com todos os sub-elementos."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Aeronáutica: Integração de controles mecatrônicos em aerodinâmica.",
                                "Programação e Controle: Uso de modelos de Lyshevski em simulações MATLAB/Simulink.",
                                "Gestão de Projetos: Referenciação ética em relatórios técnicos.",
                                "Física Aplicada: Equações dinâmicas de sistemas eletromecânicos."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Embraer ou Boeing, engenheiros referenciam essas obras para validar designs de UAVs militares, garantindo conformidade com normas FAA e otimizando sistemas de controle autônomo em missões de vigilância."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Microprocessadores e Microcontroladores",
                    "description": "Princípios e uso de microprocessadores, microcontroladores e CLPs em sistemas mecatrônicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Microprocessadores",
                        "description": "Princípios fundamentais de microprocessadores, incluindo arquitetura von Neumann e Harvard, ciclo de instrução, barramentos de dados, endereço e controle, e sua aplicação em sistemas mecatrônicos para processamento central de sinais e controle.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Identificar componentes e arquitetura de um microprocessador",
                            "description": "Reconhecer e descrever os principais componentes de um microprocessador típico (CPU, ALU, registradores, unidade de controle), diferenciando arquiteturas CISC e RISC, com exemplos como Intel 8086 ou ARM.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os Principais Componentes de um Microprocessador",
                                  "subSteps": [
                                    "Estude a definição de microprocessador como o 'cérebro' de um computador.",
                                    "Liste os componentes principais: CPU (Unidade Central de Processamento), ALU (Unidade Lógica Aritmética), Registradores e Unidade de Controle.",
                                    "Descreva a função de cada: ALU executa operações aritméticas e lógicas; Registradores armazenam dados temporários; Unidade de Controle gerencia o fluxo de instruções.",
                                    "Visualize um diagrama simples mostrando conexões entre componentes via barramentos.",
                                    "Crie um mapa mental ligando cada componente à sua função."
                                  ],
                                  "verification": "Liste e descreva corretamente os quatro componentes principais com suas funções em um quiz autoavaliado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama básico de microprocessador (impresso ou digital)",
                                    "Vídeo introdutório sobre componentes de CPU (YouTube: 'CPU Components Explained')"
                                  ],
                                  "tips": "Use mnemônicos: 'ALU faz contas, Registradores guardam, Controle dirige o tráfego'.",
                                  "learningObjective": "Nomear e descrever as funções dos componentes fundamentais de um microprocessador.",
                                  "commonMistakes": [
                                    "Confundir ALU com a CPU inteira",
                                    "Omitir a Unidade de Controle",
                                    "Achar que registradores são memória principal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Arquitetura Geral e Fluxo de Dados",
                                  "subSteps": [
                                    "Analise o ciclo de instrução: Busca (Fetch), Decodificação (Decode), Execução (Execute), Armazenamento (Store).",
                                    "Desenhe o fluxo de dados: Memória -> Registradores -> ALU -> Registradores -> Memória, orquestrado pela Unidade de Controle.",
                                    "Identifique barramentos: Endereço, Dados e Controle.",
                                    "Simule o ciclo com um exemplo simples de adição: LOAD A, ADD B, STORE resultado.",
                                    "Compare com um fluxograma pronto para validar seu desenho."
                                  ],
                                  "verification": "Desenhe e explique um fluxograma do ciclo de instrução que processe uma soma simples.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e caneta para fluxogramas",
                                    "Simulador online de CPU como Logisim ou Tinkercad",
                                    "Artigo sobre ciclo de instrução fetch-decode-execute"
                                  ],
                                  "tips": "Pense na CPU como uma fábrica: Controle é o gerente, ALU a linha de produção, Registradores as prateleiras.",
                                  "learningObjective": "Explicar como os componentes interagem no ciclo de processamento de instruções.",
                                  "commonMistakes": [
                                    "Ignorar o papel dos barramentos",
                                    "Confundir fetch com execute",
                                    "Esquecer o loop de interrupções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Arquiteturas CISC e RISC",
                                  "subSteps": [
                                    "Defina CISC: Complex Instruction Set Computing – instruções complexas, múltiplos ciclos (ex: Intel 8086).",
                                    "Defina RISC: Reduced Instruction Set Computing – instruções simples, um ciclo por instrução (ex: ARM).",
                                    "Compare: CISC tem mais registradores e instruções variadas; RISC foca em pipeline e simplicidade.",
                                    "Liste prós/contras: CISC denso em código mas lento; RISC rápido mas código maior.",
                                    "Crie uma tabela comparativa com 5 diferenças chave."
                                  ],
                                  "verification": "Preencha uma tabela comparativa CISC vs RISC com pelo menos 5 itens corretos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Tabela em branco para comparação",
                                    "Infográfico CISC vs RISC (buscar 'CISC RISC comparison PDF')",
                                    "Vídeo: 'RISC vs CISC Explained'"
                                  ],
                                  "tips": "Lembre: CISC = 'Complexo como Intel antigo', RISC = 'Rápido e Simples como ARM mobile'.",
                                  "learningObjective": "Distinguir características, vantagens e exemplos de arquiteturas CISC e RISC.",
                                  "commonMistakes": [
                                    "Achar que RISC é sempre superior",
                                    "Confundir com arquiteturas von Neumann/Harvard",
                                    "Exemplos errados (ex: chamar ARM de CISC)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Exemplos Práticos: Intel 8086 e ARM",
                                  "subSteps": [
                                    "Estude diagrama do Intel 8086: Note registradores segmentados (AX, BX), ALU de 16 bits, CISC.",
                                    "Explore arquitetura ARM: Registradores de propósito geral (R0-R15), pipeline, RISC.",
                                    "Identifique componentes em diagramas reais de cada um.",
                                    "Compare um ciclo de instrução em cada: MOV em 8086 vs LDR em ARM.",
                                    "Resuma similaridades e diferenças em um relatório curto."
                                  ],
                                  "verification": "Identifique e rotule componentes em diagramas de 8086 e ARM fornecidos.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Diagramas do Intel 8086 e ARM Cortex (imagens online)",
                                    "Emulador 8086 como DOSBox",
                                    "Documentação ARM básica (ARMv8 overview PDF)"
                                  ],
                                  "tips": "Baixe diagramas em alta resolução para zoom; foque em blocos funcionais, não transistores.",
                                  "learningObjective": "Aplicar conhecimento de componentes e arquiteturas a exemplos reais.",
                                  "commonMistakes": [
                                    "Ignorar evoluções (ARM tem variantes)",
                                    "Confundir 8086 com x86 moderno",
                                    "Não notar pipelining em RISC"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando um diagrama do Intel 8086, identifique e rotule a ALU, registradores (como AX), Unidade de Controle e barramentos; então, trace o caminho de uma instrução ADD AX, BX, explicando o papel de cada componente. Repita para um diagrama ARM Cortex-M, destacando diferenças RISC.",
                              "finalVerifications": [
                                "Lista corretamente os 4 componentes principais com funções.",
                                "Explica o ciclo fetch-decode-execute-store.",
                                "Diferencia CISC (8086) de RISC (ARM) com 3 exemplos.",
                                "Rastreia fluxo de dados em um diagrama simples.",
                                "Identifica componentes em diagramas reais.",
                                "Cria tabela comparativa precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas descrições de componentes e funções (90% correto).",
                                "Completude do ciclo de instrução e interações.",
                                "Correta distinção e exemplos de CISC/RISC.",
                                "Qualidade de diagramas e tabelas (clareza, legibilidade).",
                                "Uso de terminologia técnica apropriada.",
                                "Profundidade na análise de exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Portas lógicas e circuitos combinacionais na ALU.",
                                "Programação: Linguagem Assembly para instruções de microprocessadores.",
                                "Matemática: Álgebra booleana e aritmética binária.",
                                "Física: Sinais digitais e temporização de clock.",
                                "Engenharia de Software: Otimização de código para arquiteturas específicas."
                              ],
                              "realWorldApplication": "Em projetos mecatrônicos, como um robô industrial, usar microprocessadores ARM (RISC) para controle eficiente de motores via PLCs, identificando componentes para depuração de falhas em tempo real ou otimizando firmware em sistemas embarcados automotivos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Analisar o ciclo de instrução e barramentos",
                            "description": "Explicar o fetch-decode-execute em detalhes, incluindo o papel dos barramentos e interrupções, e simular o fluxo de execução de um programa simples em assembly.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Ciclo de Instrução Fetch-Decode-Execute",
                                  "subSteps": [
                                    "Estude a fase Fetch: o microprocessador envia o endereço da próxima instrução para o barramento de endereço e lê a instrução do barramento de dados para o Registrador de Instrução (IR).",
                                    "Analise a fase Decode: o decodificador de instruções interpreta o opcode e operandos no IR, gerando sinais de controle para a ALU e registradores.",
                                    "Examine a fase Execute: a instrução é executada, como operações aritméticas na ALU ou transferências de dados, atualizando o PC para a próxima instrução.",
                                    "Revise o ciclo completo, incluindo o incremento do Program Counter (PC) após o Fetch.",
                                    "Desenhe um diagrama de fluxo do ciclo básico."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama do ciclo Fetch-Decode-Execute com setas indicando o fluxo de dados e controle.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagrama de ciclo de instrução de um microprocessador (ex: 8085 ou MIPS), papel e caneta ou software de desenho como Draw.io.",
                                  "tips": "Use animações online de simuladores de CPU para visualizar o ciclo em tempo real.",
                                  "learningObjective": "Explicar as três fases do ciclo de instrução e seu fluxo sequencial.",
                                  "commonMistakes": "Confundir Fetch com Execute ou ignorar o papel do PC no ciclo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Papel dos Barramentos no Ciclo de Instrução",
                                  "subSteps": [
                                    "Identifique o barramento de endereço: transporta endereços de memória do PC para a memória, unidirecional em muitos designs.",
                                    "Descreva o barramento de dados: bidirecional, carrega instruções e dados entre CPU, memória e periféricos.",
                                    "Explique o barramento de controle: sinais como RD (Read), WR (Write), ALE (Address Latch Enable) que sincronizam operações.",
                                    "Relacione barramentos ao ciclo: Fetch usa endereço e dados; Execute pode usar dados e controle para I/O.",
                                    "Compare barramentos paralelos vs. seriais em microprocessadores modernos."
                                  ],
                                  "verification": "Listar funções de cada barramento e mapear seu uso em cada fase do ciclo em uma tabela.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Pinout de um microprocessador (ex: diagrama 8085), tabela de sinais de controle.",
                                  "tips": "Pense nos barramentos como 'estradas' de dados: endereço é o mapa, dados é a carga, controle é o semáforo.",
                                  "learningObjective": "Descrever como barramentos de endereço, dados e controle suportam o ciclo de instrução.",
                                  "commonMistakes": "Confundir barramento de dados bidirecional com unidirecional ou ignorar sinais de controle."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Interrupções e Seu Impacto no Ciclo de Instrução",
                                  "subSteps": [
                                    "Classifique interrupções: hardware (ex: timer), software (ex: INT instrução) e exceções.",
                                    "Descreva o processo: sinal de interrupção para INTR pin, CPU completa ciclo atual, salva PC e status em pilha.",
                                    "Explique ISR (Interrupt Service Routine): CPU pula para vetor de interrupção, executa rotina, retorna com IRET.",
                                    "Analise impacto no ciclo: pausar fetch normal, salvar contexto, restaurar após ISR.",
                                    "Diferencie interrupções mascaráveis e não-mascaráveis."
                                  ],
                                  "verification": "Escrever uma sequência de passos para handling de uma interrupção hardware durante o ciclo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Diagrama de vetor de interrupções (ex: 8085), pseudocódigo de ISR.",
                                  "tips": "Simule com um exemplo: 'tecla pressionada interrompe loop principal'.",
                                  "learningObjective": "Explicar como interrupções interrompem e restauram o ciclo de instrução.",
                                  "commonMistakes": "Achar que interrupções param a CPU imediatamente sem salvar contexto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular o Fluxo de Execução de um Programa Simples em Assembly",
                                  "subSteps": [
                                    "Escreva um programa assembly simples: soma de dois números (ex: LOAD A, 5; ADD B, 3; STORE resultado).",
                                    "Simule Fetch: PC=0, bus endereço=0, IR recebe instrução LOAD.",
                                    "Simule Decode e Execute para cada instrução, rastreando PC, registradores e barramentos.",
                                    "Inclua uma interrupção simulada: após soma, INT 1, salte para ISR, retorne.",
                                    "Registre o estado da CPU (registradores, barramentos) após cada ciclo em uma tabela."
                                  ],
                                  "verification": "Produzir uma tabela de simulação com 10+ ciclos, mostrando mudanças em PC, IR, barramentos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador online (ex: 8085 simulator ou Logisim), editor de texto para assembly.",
                                  "tips": "Use papel milimetrado para rastrear estados; comece com programa de 3 instruções.",
                                  "learningObjective": "Simular manualmente o ciclo completo para um programa assembly com interrupção.",
                                  "commonMistakes": "Esquecer de incrementar PC ou não lidar com alinhamento de bytes."
                                }
                              ],
                              "practicalExample": "Simule o programa assembly para um controlador de motor em mecatrônica: LOAD velocidade_atual; ADD incremento; STORE PWM; se sensor de fim de curso interrompe (INT), pare motor e retorne.",
                              "finalVerifications": [
                                "Diagramar corretamente o ciclo Fetch-Decode-Execute com barramentos.",
                                "Explicar o fluxo de uma interrupção em uma ISR simples.",
                                "Simular 5 ciclos de um programa assembly rastreando PC e registradores.",
                                "Identificar sinais de controle usados em cada fase.",
                                "Diferenciar barramentos em um pinout real de microprocessador.",
                                "Prever o estado da CPU após uma interrupção não-mascarável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das fases do ciclo e barramentos (30%).",
                                "Detalhe na simulação de assembly com tabela de estados (25%).",
                                "Compreensão de interrupções e contexto salva/restaura (20%).",
                                "Uso correto de terminologia técnica (15%).",
                                "Clareza em diagramas e explicações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Sinais elétricos nos barramentos e temporização.",
                                "Programação: Assembly como base para linguagens de baixo nível em embedded.",
                                "Matemática: Representação binária de endereços e operações aritméticas.",
                                "Física: Temporização de clock e latência em sistemas reais."
                              ],
                              "realWorldApplication": "Em projetos mecatrônicos, como robôs autônomos, o ciclo de instrução e barramentos gerenciam leitura de sensores via interrupções, execução de controle PID e saída para atuadores em microcontroladores como Arduino ou STM32."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Integrar microprocessadores em sistemas mecatrônicos",
                            "description": "Projetar uma interface básica entre microprocessador e periféricos mecatrônicos, como sensores e atuadores, considerando temporização e protocolos de comunicação serial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Entender Componentes",
                                  "subSteps": [
                                    "Identificar o microprocessador adequado (ex: Arduino Uno ou STM32) baseado em requisitos de pinos I/O, velocidade e periféricos.",
                                    "Escolher sensores (ex: sensor ultrassônico HC-SR04) e atuadores (ex: servo motor SG90) compatíveis com protocolos seriais e temporização.",
                                    "Estudar datasheets para pinouts, níveis de tensão, protocolos (I2C, SPI, UART) e requisitos de alimentação.",
                                    "Definir necessidades de temporização (ex: delays para leitura de sensor) e comunicação serial (baud rate 9600).",
                                    "Listar todos os componentes e ferramentas necessárias."
                                  ],
                                  "verification": "Lista de componentes com justificativas e resumo dos datasheets revisados.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Datasheets dos componentes",
                                    "Planilha ou documento de planejamento",
                                    "Computador com acesso à internet"
                                  ],
                                  "tips": [
                                    "Priorize componentes com bibliotecas prontas para prototipagem rápida.",
                                    "Verifique compatibilidade de tensão (3.3V vs 5V) para evitar danos."
                                  ],
                                  "learningObjective": "Compreender especificações técnicas para seleção otimizada de componentes mecatrônicos.",
                                  "commonMistakes": [
                                    "Ignorar diferenças de tensão entre microprocessador e periféricos.",
                                    "Subestimar consumo de corrente dos atuadores."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar e Montar Interface Hardware",
                                  "subSteps": [
                                    "Desenhar esquemático no software (ex: Fritzing ou KiCad) conectando microprocessador a sensores/atuadores via pinos GPIO, ADC e PWM.",
                                    "Incluir resistores pull-up/down, capacitores de desacoplamento e conversores de nível se necessário.",
                                    "Montar protoboard ou PCB com solda fria, garantindo conexões seguras.",
                                    "Adicionar circuito de alimentação estável com regulador de tensão.",
                                    "Verificar continuidade e ausência de curtos com multímetro."
                                  ],
                                  "verification": "Circuito montado testado com multímetro (continuidade OK, sem curtos) e foto/esquema documentado.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Protoboard",
                                    "Jumpers, resistores, capacitores",
                                    "Multímetro",
                                    "Software de esquemático (Fritzing)",
                                    "Microprocessador e periféricos"
                                  ],
                                  "tips": [
                                    "Use breadboard para protótipos iniciais para facilitar alterações.",
                                    "Sempre isole alimentação de sinal para reduzir ruído."
                                  ],
                                  "learningObjective": "Dominar design de interfaces hardware seguras e eficientes para sistemas mecatrônicos.",
                                  "commonMistakes": [
                                    "Conexões invertidas em pinos TX/RX para serial.",
                                    "Esquecer capacitores de filtro causando instabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Firmware com Temporização e Comunicação Serial",
                                  "subSteps": [
                                    "Configurar ambiente IDE (ex: Arduino IDE ou STM32CubeIDE) e instalar bibliotecas para periféricos.",
                                    "Escrever código para inicializar pinos, configurar UART serial (baud 9600) e timers para temporização precisa.",
                                    "Implementar loop principal: ler sensor, processar dados com delays/timers, enviar via serial, controlar atuador.",
                                    "Adicionar tratamento de erros (ex: timeout em leituras serial).",
                                    "Compilar, carregar e monitorar serial no terminal."
                                  ],
                                  "verification": "Código compila sem erros, monitor serial mostra dados corretos em tempo real.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "IDE de programação",
                                    "Cabo USB para programação",
                                    "Computador"
                                  ],
                                  "tips": [
                                    "Use millis() em vez de delay() para temporização não-bloqueante.",
                                    "Teste funções isoladamente antes de integrar."
                                  ],
                                  "learningObjective": "Programar microprocessadores para interfaces mecatrônicas com controle preciso de tempo e comunicação.",
                                  "commonMistakes": [
                                    "Usar delay() bloqueando comunicação serial.",
                                    "Configurar baud rate incorreto causando lixo nos dados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Integrar Sistema",
                                  "subSteps": [
                                    "Executar testes unitários: sensor isolado, atuador isolado, comunicação serial.",
                                    "Testes integrados: simular cenários reais (ex: sensor detecta objeto, atuador responde).",
                                    "Depurar com osciloscópio ou logic analyzer para sinais e temporização.",
                                    "Otimizar código para eficiência (reduzir latência) e adicionar comentários.",
                                    "Documentar setup completo e gerar relatório de testes."
                                  ],
                                  "verification": "Sistema responde corretamente a inputs em 95% dos testes, com logs de depuração.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Osciloscópio ou multímetro avançado",
                                    "Terminal serial",
                                    "Ferramentas de depuração"
                                  ],
                                  "tips": [
                                    "Registre todos os testes em tabela com pass/fail.",
                                    "Simule falhas (ex: desconectar sensor) para robustez."
                                  ],
                                  "learningObjective": "Validar e otimizar integração de microprocessadores em sistemas mecatrônicos.",
                                  "commonMistakes": [
                                    "Ignorar ruído em sinais analógicos afetando leituras.",
                                    "Sobrecarga de atuadores sem limite de corrente."
                                  ]
                                }
                              ],
                              "practicalExample": "Integre um Arduino Uno com sensor ultrassônico HC-SR04 (trigger/echo via digital pins com temporização de 50ms) e servo SG90 (controle PWM). Envie distância medida via UART serial para um PC, ativando servo se distância < 20cm.",
                              "finalVerifications": [
                                "Leituras do sensor são precisas (±5% erro) em diferentes distâncias.",
                                "Servo responde corretamente com delay <100ms após detecção.",
                                "Dados serial chegam ao PC sem perda em baud 9600 por 5 minutos.",
                                "Sistema opera estável por 30 minutos sem reset.",
                                "Temporização de polling não excede 100ms por ciclo.",
                                "Nenhum superaquecimento ou falha de hardware."
                              ],
                              "assessmentCriteria": [
                                "Precisão e robustez da interface hardware (sem falhas elétricas).",
                                "Eficiência do código (uso otimizado de timers e memória <80%).",
                                "Conformidade com temporização e protocolos especificados.",
                                "Qualidade da documentação e depuração.",
                                "Integração seamless com periféricos mecatrônicos.",
                                "Escalabilidade para sistemas maiores."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Design de circuitos e análise de sinais.",
                                "Programação: Desenvolvimento embedded em C/C++.",
                                "Física: Princípios de temporização, ondas e controle PID básico.",
                                "Mecânica: Integração com atuadores cinemáticos.",
                                "Informática: Protocolos de comunicação e serialização de dados."
                              ],
                              "realWorldApplication": "Em robôs industriais para automação de linhas de produção, onde microprocessadores integram sensores de proximidade para controle preciso de atuadores, evitando colisões e otimizando fluxos em fábricas como montagem de automóveis."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Microcontroladores",
                        "description": "Conceitos de microcontroladores como sistemas embarcados completos, com CPU integrada, memória, timers, ADCs e interfaces de E/S, destacando famílias como AVR, PIC e ARM Cortex-M para projetos mecatrônicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Configurar periféricos de um microcontrolador",
                            "description": "Configurar timers, PWM, conversores A/D e portas GPIO em um microcontrolador como Arduino ou STM32, utilizando ferramentas como IDEs específicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Portas GPIO",
                                  "subSteps": [
                                    "Identificar os pinos GPIO disponíveis no microcontrolador (ex: Arduino Uno pins 2-13).",
                                    "Selecionar modo de operação (INPUT, OUTPUT, INPUT_PULLUP) usando pinMode().",
                                    "Escrever código para ler/gravar valores com digitalRead() e digitalWrite().",
                                    "Implementar debounce para entradas para evitar ruído.",
                                    "Testar com LED e botão físico."
                                  ],
                                  "verification": "LED acende/apaga conforme comando e botão responde sem falhas múltiplas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Arduino Uno ou STM32",
                                    "LED",
                                    "Resistor 220Ω",
                                    "Botão push",
                                    "Jumpers",
                                    "IDE Arduino ou STM32CubeIDE"
                                  ],
                                  "tips": "Sempre use resistores de pull-up/down para entradas estáveis.",
                                  "learningObjective": "Dominar controle básico de I/O digitais para interfaces simples.",
                                  "commonMistakes": [
                                    "Esquecer pinMode() causando comportamento imprevisível.",
                                    "Não debounçar botões levando a múltiplas leituras.",
                                    "Inverter lógica HIGH/LOW."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Timers",
                                  "subSteps": [
                                    "Estudar registros de timer (ex: Timer1 no Arduino com prescaler).",
                                    "Configurar modo (CTC ou Overflow) e frequência desejada via TCCR1A/B.",
                                    "Implementar interrupção com TIMER1_COMPA_vect para ações periódicas.",
                                    "Calcular valores de contagem para delay preciso (ex: 1ms tick).",
                                    "Integrar com millis() ou micros() para testes iniciais."
                                  ],
                                  "verification": "Timer gera interrupções precisas, medido com osciloscópio ou LED piscando a 1Hz exato.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Arduino/STM32",
                                    "Osciloscópio ou multímetro",
                                    "IDE com suporte a interrupções"
                                  ],
                                  "tips": "Use calculadora de timer online para prescaler e TOP values.",
                                  "learningObjective": "Criar temporizadores precisos para controle de tempo não bloqueante.",
                                  "commonMistakes": [
                                    "Prescaler errado causando frequência imprecisa.",
                                    "Não limpar flags de overflow.",
                                    "Conflito com delay() bloqueando loop."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar PWM",
                                  "subSteps": [
                                    "Selecionar pinos PWM suportados (ex: pins 3,5,6,9,10,11 no Arduino).",
                                    "Configurar duty cycle com analogWrite() (0-255 para 8-bit).",
                                    "Ajustar frequência via timers FastPWM se necessário (modificar ICR1).",
                                    "Testar com servo ou LED dimmable para variar intensidade.",
                                    "Implementar controle suave com map() para entradas analógicas."
                                  ],
                                  "verification": "Saída PWM varia duty cycle corretamente, medido com multímetro (de 0-5V).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Arduino/STM32",
                                    "Servo motor ou LED com resistor",
                                    "Multímetro",
                                    "Potenciômetro para input"
                                  ],
                                  "tips": "Para frequências altas, ajuste timer registers manualmente.",
                                  "learningObjective": "Gerar sinais PWM para controle de potência e servos.",
                                  "commonMistakes": [
                                    "Usar pin não-PWM.",
                                    "Duty cycle invertido.",
                                    "Frequência padrão inadequada para motores."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Conversores A/D (ADC)",
                                  "subSteps": [
                                    "Configurar referência ADC (5V ou interna) e resolução (10-bit Arduino).",
                                    "Ler valores com analogRead() em pinos analógicos (A0-A5).",
                                    "Converter leitura para tensão real (valor * 5.0 / 1023).",
                                    "Implementar média móvel para filtrar ruído.",
                                    "Testar com potenciômetro ou sensor (ex: LDR)."
                                  ],
                                  "verification": "Leitura ADC corresponde à tensão aplicada, com erro <5%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Arduino/STM32",
                                    "Potenciômetro 10kΩ",
                                    "Sensor analógico como LDR",
                                    "Multímetro para calibração"
                                  ],
                                  "tips": "Amostre múltiplas vezes e faça média para precisão.",
                                  "learningObjective": "Interfacear sensores analógicos e processar sinais reais.",
                                  "commonMistakes": [
                                    "Não calibrar referência de tensão.",
                                    "Ruído sem filtragem.",
                                    "Ler pino digital como analógico."
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um sistema de controle de motor DC: Use GPIO para botão start/stop, timer para monitoramento de tempo, PWM para velocidade variável baseada em potenciômetro ADC, exibindo status via Serial.",
                              "finalVerifications": [
                                "Todos periféricos configurados sem conflitos (GPIO, Timer, PWM, ADC funcionam simultaneamente).",
                                "Código compila e roda sem warnings/erros em IDE.",
                                "Testes com hardware mostram precisão (frequência timer ±1%, PWM duty 0-100%, ADC erro <50mV).",
                                "Sistema integrado responde a inputs em <10ms.",
                                "Documentação inclui pinout e cálculos.",
                                "Backup do código com comentários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de periféricos (frequências, resoluções corretas).",
                                "Eficiência do código (sem delays bloqueantes, uso de interrupções).",
                                "Robustez contra erros comuns (debounce, filtragem).",
                                "Integração fluida entre periféricos.",
                                "Clareza da documentação e comentários.",
                                "Criatividade no exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de controle e funções em C/C++.",
                                "Eletrônica: Entendimento de sinais digitais/analógicos e componentes.",
                                "Física: Ondas PWM, conversão A/D, temporização.",
                                "Matemática: Cálculos de prescaler, duty cycle e médias.",
                                "Projeto: Integração em sistemas mecatrônicos."
                              ],
                              "realWorldApplication": "Em robótica industrial, configurar PWM para controlar velocidade de motores em linhas de montagem, timers para sequências de automação, ADC para feedback de sensores de posição e GPIO para interfaces homem-máquina em PLCs ou drones."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Programar microcontroladores em linguagem C",
                            "description": "Desenvolver firmware em C para controle de loops fechados, tratamento de interrupções e comunicação I2C/SPI, com exemplos de controle de motores em sistemas mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Desenvolvimento para Microcontroladores",
                                  "subSteps": [
                                    "Instalar uma IDE como STM32CubeIDE ou PlatformIO.",
                                    "Baixar e configurar o toolchain GCC para ARM (para STM32) ou AVR-GCC.",
                                    "Conectar a placa de microcontrolador (ex: STM32 Nucleo ou Arduino com C nativo) via USB e testar comunicação serial.",
                                    "Criar um projeto blink LED básico em C para validar setup.",
                                    "Configurar debugger (ST-Link ou JTAG)."
                                  ],
                                  "verification": "LED pisca conforme código e debugger mostra variáveis em tempo real.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Computador com Windows/Linux/Mac",
                                    "STM32CubeIDE",
                                    "Placa STM32 Nucleo-F401RE",
                                    "Cabo USB ST-Link"
                                  ],
                                  "tips": "Use wizards de configuração da IDE para gerar código boilerplate e evite configurações manuais iniciais.",
                                  "learningObjective": "Dominar setup de toolchain e hardware para programação em C em MCUs.",
                                  "commonMistakes": [
                                    "Instalação incorreta de drivers USB",
                                    "Seleção errada de MCU family no IDE",
                                    "Ignorar permissões de porta serial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Controle Básico de Periféricos e Loops Abertos",
                                  "subSteps": [
                                    "Configurar GPIOs para saída PWM em pinos de timer (ex: TIM2 para motor).",
                                    "Escrever loop principal com delay e controle de duty cycle para variar velocidade.",
                                    "Adicionar ADC para leitura de potenciômetro como setpoint.",
                                    "Implementar funções modulares para init de periféricos.",
                                    "Testar com osciloscópio ou multímetro para medir sinal PWM."
                                  ],
                                  "verification": "PWM varia linearmente com input do potenciômetro e motor gira proporcionalmente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Placa MCU",
                                    "Motor DC pequeno",
                                    "Driver L298N ou MOSFET",
                                    "Potenciômetro 10kΩ",
                                    "Osciloscópio/multímetro"
                                  ],
                                  "tips": "Use HAL library do STM32 para abstrair registradores e focar em lógica.",
                                  "learningObjective": "Controlar periféricos básicos em C para saídas analógicas simuladas.",
                                  "commonMistakes": [
                                    "Configuração errada de clock do timer",
                                    "Overflow em variáveis de duty cycle",
                                    "Não zerar registradores antes de init"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Tratar Interrupções para Eventos Assíncronos",
                                  "subSteps": [
                                    "Configurar interrupção de timer para sampling periódico (ex: 1kHz).",
                                    "Implementar ISR (Interrupt Service Routine) para capturar sinal de encoder no motor.",
                                    "Usar flags voláteis para comunicação entre ISR e main loop.",
                                    "Adicionar prioridade de interrupções e NVIC config.",
                                    "Testar com gerador de pulsos para simular encoder."
                                  ],
                                  "verification": "Contagem de pulsos do encoder é precisa (±1% erro) em diferentes velocidades.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Encoder incremental para motor",
                                    "Gerador de função ou Arduino simulador",
                                    "Documentação RM do MCU"
                                  ],
                                  "tips": "Mantenha ISRs curtas (<10 linhas) e use atomic access para variáveis compartilhadas.",
                                  "learningObjective": "Gerenciar interrupções de forma eficiente e segura em firmware C.",
                                  "commonMistakes": [
                                    "Não habilitar interrupção global (NVIC_EnableIRQ)",
                                    "Race conditions sem voláteis",
                                    "ISRs longas bloqueando sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Comunicação I2C/SPI para Sensores e Atuadores",
                                  "subSteps": [
                                    "Configurar periférico I2C como master para ler sensor (ex: MPU6050 gyro).",
                                    "Escrever funções para SPI slave/master com motor driver (ex: TMC2209).",
                                    "Implementar polling e interrupções para comunicação.",
                                    "Tratar ACK/NACK e timeouts em transações.",
                                    "Integrar dados de sensor no loop de controle."
                                  ],
                                  "verification": "Dados de sensor são lidos corretamente e exibidos via UART sem perda de pacotes.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Sensor MPU6050 (I2C)",
                                    "Driver motor SPI",
                                    "Logic analyzer opcional"
                                  ],
                                  "tips": "Use buffers DMA para comunicação eficiente e reduza CPU load.",
                                  "learningObjective": "Dominar protocolos seriais para integração de periféricos em sistemas mecatrônicos.",
                                  "commonMistakes": [
                                    "Pinos errados para SCL/SDA ou MOSI/MISO",
                                    "Clock stretching ignorado no I2C",
                                    "Endianness em SPI"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Desenvolver Controle de Loop Fechado com PID para Motores",
                                  "subSteps": [
                                    "Implementar algoritmo PID simples (Proporcional, Integral, Derivativo) em ponto fixo.",
                                    "Calcular erro = setpoint - feedback (encoder velocidade).",
                                    "Ajustar gains (Kp, Ki, Kd) via serial e anti-windup.",
                                    "Integrar com interrupções e comunicação para monitoramento.",
                                    "Otimizar e testar estabilidade em diferentes cargas."
                                  ],
                                  "verification": "Sistema mantém velocidade setpoint com erro <5% sob perturbações de carga.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Motor com encoder",
                                    "Carga variável (peso)",
                                    "Terminal serial para tuning"
                                  ],
                                  "tips": "Comece com Kp baixo e aumente iterativamente; simule em MATLAB primeiro.",
                                  "learningObjective": "Aplicar teoria de controle em firmware embarcado para loops fechados.",
                                  "commonMistakes": [
                                    "Overflow em soma integral",
                                    "Derivativo em ruído sem filtro",
                                    "Gains altos causando oscilação"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver firmware para um braço mecatrônico onde um motor DC com encoder mantém posição angular precisa via PID, lendo gyro via I2C para correção e enviando status via SPI para um master controller, usando interrupções para timer de 1ms.",
                              "finalVerifications": [
                                "Firmware compila sem warnings e faz upload sem erros.",
                                "Sistema responde a comandos seriais com latência <10ms.",
                                "Loop fechado estabiliza em <500ms com overshoot <10%.",
                                "Sem crashes após 1 hora de operação contínua.",
                                "Dados de encoder e PID exibidos corretamente via UART.",
                                "Comunicação I2C/SPI sem perda de frames (>99% taxa de sucesso)."
                              ],
                              "assessmentCriteria": [
                                "Eficiência do código: <20% CPU usage em 100MHz MCU.",
                                "Robustez: Tratamento de falhas em sensores e timeouts.",
                                "Modularidade: Funções reutilizáveis e comentários claros.",
                                "Precisão do controle: Erro médio <2% em steady-state.",
                                "Otimização: Uso eficiente de memória (<10KB RAM/Flash extra).",
                                "Documentação: Diagrama de fluxo e gains PID justificados."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Configuração de periféricos e registradores.",
                                "Controle Automático: Algoritmos PID e estabilidade de sistemas.",
                                "Física Aplicada: Cinemática de motores e dinâmica de cargas.",
                                "Programação: Estruturas C avançadas (ponteiros, voláteis).",
                                "Sistemas Embarcados: RTOS basics e scheduling."
                              ],
                              "realWorldApplication": "Controle de motores em robôs colaborativos (cobots) para montagem precisa em linhas de produção automotiva, estabilização de drones em voo autônomo ou sistemas de CNC para usinagem de alta precisão."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Depurar e otimizar código embarcado",
                            "description": "Utilizar debuggers e osciloscópios para identificar falhas em tempo real, otimizando consumo de energia e performance em aplicações mecatrônicas industriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de depuração",
                                  "subSteps": [
                                    "Conectar o microcontrolador ao debugger (ex: JTAG/SWD) e ao osciloscópio nos pinos relevantes.",
                                    "Instalar e configurar o software de depuração (ex: IDE com GDB ou Keil uVision).",
                                    "Verificar comunicação serial e alimentação estável do sistema.",
                                    "Calibrar o osciloscópio para capturar sinais em tempo real (frequência, trigger).",
                                    "Criar um projeto de teste com código embarcado básico para validação inicial."
                                  ],
                                  "verification": "Debugger conecta sem erros e osciloscópio captura sinais PWM ou GPIO corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Debugger hardware (ST-Link ou similar)",
                                    "Osciloscópio digital",
                                    "Microcontrolador (ex: STM32)",
                                    "Cabo JTAG/SWD",
                                    "IDE com suporte a debug"
                                  ],
                                  "tips": "Sempre isole o sistema de ruídos externos durante a configuração inicial.",
                                  "learningObjective": "Configurar ferramentas de depuração para acesso remoto ao código embarcado.",
                                  "commonMistakes": [
                                    "Conexões invertidas em pinos",
                                    "Driver de debugger desatualizado",
                                    "Frequência de clock mismatch"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reproduzir e analisar o problema inicial",
                                  "subSteps": [
                                    "Executar o código no modo run e observar falhas (ex: motor não responde, consumo alto).",
                                    "Usar logs seriais para capturar mensagens de erro ou estados variáveis.",
                                    "Monitorar consumo de energia com multímetro e osciloscópio em Vcc.",
                                    "Identificar padrões de falha reproduzíveis (ex: sobreaquecimento após 10s).",
                                    "Documentar sintomas: tempo de ocorrência, condições ambientais."
                                  ],
                                  "verification": "Problema reproduzido consistentemente com logs e capturas de sinal salvas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Multímetro",
                                    "Software terminal serial",
                                    "Planilha para logs"
                                  ],
                                  "tips": "Grave vídeos curtos das falhas para análise posterior.",
                                  "learningObjective": "Identificar e documentar falhas de forma sistemática em sistemas embarcados.",
                                  "commonMistakes": [
                                    "Ignorar falhas intermitentes",
                                    "Não registrar condições iniciais",
                                    "Confundir sintomas com causas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Depurar o código usando breakpoints e osciloscópio",
                                  "subSteps": [
                                    "Definir breakpoints em funções suspeitas (ex: ISR de timer).",
                                    "Inspecionar variáveis em tempo real com watch windows.",
                                    "Capturar sinais analógicos no osciloscópio sincronizados com breakpoints.",
                                    "Passar step-by-step analisando stack e registradores.",
                                    "Corrigir bugs identificados (ex: overflow em contador, race condition)."
                                  ],
                                  "verification": "Breakpoints param execução corretamente e sinais correlacionam com código.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Debugger software",
                                    "Osciloscópio com trigger externo"
                                  ],
                                  "tips": "Use conditional breakpoints para falhas intermitentes.",
                                  "learningObjective": "Usar ferramentas para mapear falhas lógicas e elétricas em tempo real.",
                                  "commonMistakes": [
                                    "Breakpoints em loops infinitos",
                                    "Não pausar ISRs adequadamente",
                                    "Ignorar jitter em sinais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar consumo de energia e performance",
                                  "subSteps": [
                                    "Analisar perfil de consumo com debugger (halt mode vs run mode).",
                                    "Implementar modos de baixo consumo (sleep, idle) e wake-up conditions.",
                                    "Otimizar loops críticos (unroll, inline functions).",
                                    "Reduzir clock dinamicamente baseado em carga e medir performance.",
                                    "Recompilar com flags de otimização (-O2/-Os) e testar regressões."
                                  ],
                                  "verification": "Consumo reduzido em >20% sem perda de performance, medido por osciloscópio.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Profiler de energia (opcional)",
                                    "Compilador com otimizações"
                                  ],
                                  "tips": "Meça antes/depois para quantificar ganhos.",
                                  "learningObjective": "Aplicar técnicas de otimização específicas para embedded systems.",
                                  "commonMistakes": [
                                    "Otimizar prematuramente",
                                    "Não testar em hardware real",
                                    "Ignorar overhead de wake-up"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar otimizações e testar robustez",
                                  "subSteps": [
                                    "Executar testes de stress (temperatura, voltagem variável).",
                                    "Comparar métricas pré/pós-otimização (tempo de ciclo, consumo).",
                                    "Simular falhas (desconectar sensores) e verificar recovery.",
                                    "Gerar relatório com antes/depois e código final.",
                                    "Flashar firmware otimizado em produção simulada."
                                  ],
                                  "verification": "Sistema opera sem falhas por 1 hora de teste contínuo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Fonte de alimentação variável",
                                    "Câmara térmica (opcional)"
                                  ],
                                  "tips": "Automatize testes com scripts se possível.",
                                  "learningObjective": "Garantir robustez e eficiência em aplicações industriais.",
                                  "commonMistakes": [
                                    "Testes só em condições ideais",
                                    "Não versionar código",
                                    "Pular validação cross-plataforma"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema mecatrônico para controle de motor em linha de produção, o motor vibra intermitentemente devido a overflow em timer ISR. Usando debugger, identifica-se o bug; osciloscópio mostra sinal PWM distorcido. Otimiza-se com 32-bit counter e sleep mode, reduzindo consumo de 150mA para 80mA sem perda de precisão.",
                              "finalVerifications": [
                                "Código depurado executa sem crashes por 2 horas.",
                                "Consumo de energia otimizado em pelo menos 15-30%.",
                                "Performance (tempo de resposta) mantida ou melhorada.",
                                "Sinais elétricos limpos no osciloscópio.",
                                "Relatório documentado com métricas antes/depois.",
                                "Testes de regressão passam 100%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da causa raiz (80%+).",
                                "Eficiência das otimizações (redução mensurável).",
                                "Qualidade da documentação e relatórios.",
                                "Uso correto de ferramentas (sem erros de configuração).",
                                "Robustez em cenários edge-case.",
                                "Tempo total dentro do estimado (5-4.5 horas)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Análise de sinais com osciloscópio.",
                                "Programação: Algoritmos de otimização e debugging.",
                                "Física: Princípios de consumo energético e termodinâmica.",
                                "Gestão de Projetos: Documentação e validação iterativa.",
                                "Automação Industrial: Aplicações em PLCs e SCADA."
                              ],
                              "realWorldApplication": "Em fábricas de automação, depurar e otimizar código embarcado em controladores de robôs garante operação 24/7 com eficiência energética, reduzindo custos operacionais em 25% e downtime em indústrias como automotiva e manufatura."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "CLPs (Controladores Lógicos Programáveis)",
                        "description": "Princípios de CLPs para automação industrial mecatrônica, incluindo programação em ladder logic, PLCs como Siemens S7 ou Allen-Bradley, integração com redes fieldbus e supervisão SCADA.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Compreender linguagens de programação de CLPs",
                            "description": "Interpretar e criar programas em ladder diagram (LD), function block diagram (FBD) e structured text (ST), conforme norma IEC 61131-3.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar a norma IEC 61131-3 e conceitos básicos das linguagens LD, FBD e ST",
                                  "subSteps": [
                                    "Ler a introdução da norma IEC 61131-3, focando nas 5 linguagens padronizadas.",
                                    "Identificar características principais: LD (lógica de relés), FBD (blocos funcionais gráficos), ST (texto estruturado como Pascal).",
                                    "Comparar vantagens e desvantagens de cada linguagem em contextos industriais.",
                                    "Assistir vídeos tutoriais introdutórios sobre cada linguagem.",
                                    "Anotar definições chave: contatos, bobinas, blocos, operadores lógicos."
                                  ],
                                  "verification": "Resumir em um mapa mental as diferenças entre LD, FBD e ST, com exemplos de símbolos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Norma IEC 61131-3 (PDF), vídeos no YouTube (PLC Academy), software Codesys ou TIA Portal para visualização.",
                                  "tips": "Use diagramas visuais para memorizar símbolos; comece com LD por ser mais intuitivo.",
                                  "learningObjective": "Compreender o padrão IEC 61131-3 e diferenciar as linguagens de programação de CLPs.",
                                  "commonMistakes": "Confundir ST com linguagens de alto nível como C++; ignorar que LD é gráfica apesar de baseada em relés."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Ladder Diagram (LD): Interpretação e criação básica",
                                  "subSteps": [
                                    "Aprender elementos básicos: contatos normalmente aberto/fechado (NO/NC), bobinas (coil), timers e counters.",
                                    "Interpretar um programa LD simples para start/stop de motor.",
                                    "Criar um LD para controle de luz com sensor: lógica AND/OR.",
                                    "Simular o programa em software e debugar erros lógicos.",
                                    "Converter lógica booleana em diagramas ladder."
                                  ],
                                  "verification": "Executar simulação de um LD criado e demonstrar funcionamento correto com inputs variáveis.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Software gratuito Codesys ou LogixPro Simulator, exemplos de LD de manuais Siemens.",
                                  "tips": "Pense em LD como circuitos de relés físicos; desenhe no papel antes de codificar.",
                                  "learningObjective": "Interpretar e programar lógicas básicas em LD conforme IEC 61131-3.",
                                  "commonMistakes": "Esquecer paralelismo em ramos; usar contatos errados (NO vs NC)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Function Block Diagram (FBD): Construção e interpretação",
                                  "subSteps": [
                                    "Estudar blocos funcionais: AND, OR, NOT, timers (TON/TOF), comparadores.",
                                    "Interpretar um FBD para controle PID simples.",
                                    "Criar FBD equivalente ao LD de start/stop do step anterior.",
                                    "Conectar múltiplos blocos em rede e simular fluxos de dados.",
                                    "Analisar reutilização de blocos em programas maiores."
                                  ],
                                  "verification": "Converter um LD simples para FBD e simular outputs idênticos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Codesys ou TIA Portal com exemplos FBD, folhetos de blocos IEC.",
                                  "tips": "Siga o fluxo de esquerda para direita; use EN/ENO para controle de execução.",
                                  "learningObjective": "Criar e interpretar diagramas baseados em blocos funcionais.",
                                  "commonMistakes": "Ignorar pinos de enable (EN); conectar saídas múltiplas incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aprender Structured Text (ST): Sintaxe e programação textual",
                                  "subSteps": [
                                    "Revisar sintaxe ST: variáveis, IF-THEN-ELSE, CASE, FOR loops, funções IEC.",
                                    "Interpretar um programa ST para contador cíclico.",
                                    "Escrever ST equivalente aos LD/FBD anteriores.",
                                    "Implementar estruturas condicionais e aritméticas.",
                                    "Debugar erros de compilação em ST."
                                  ],
                                  "verification": "Compilar e simular um programa ST que replica lógica de LD/FBD, com variáveis monitoradas.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Editor Codesys ST, referências IEC 61131-3 Parte 3 (ST syntax).",
                                  "tips": "ST é case-sensitive; declare todas variáveis antes de usar.",
                                  "learningObjective": "Escrever e debugar programas em texto estruturado padronizado.",
                                  "commonMistakes": "Erros de ponto e vírgula; esquecer END_IF ou declarações de tipo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar linguagens: Prática mista e projetos aplicados",
                                  "subSteps": [
                                    "Criar projeto híbrido: LD para I/O, FBD para controle, ST para cálculos.",
                                    "Interpretar programas mistos de exemplos industriais.",
                                    "Otimizar um programa multi-linguagem para eficiência.",
                                    "Testar cenários de falha e debugar cross-language.",
                                    "Documentar o programa com comentários."
                                  ],
                                  "verification": "Executar simulação completa de projeto híbrido e gerar relatório de testes.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software CLP completo (Codesys trial), exemplos de projetos reais (PLCS.net).",
                                  "tips": "Use POU (Program Organization Units) para modularidade entre linguagens.",
                                  "learningObjective": "Combinar LD, FBD e ST em aplicações mecatrônicas reais.",
                                  "commonMistakes": "Incompatibilidades de tipos entre linguagens; sobrecarga de ciclos de scan."
                                }
                              ],
                              "practicalExample": "Desenvolver um controle de esteira transportadora: LD para start/stop e sensores de presença, FBD para timer de delay, ST para cálculo de velocidade baseado em encoder, simulando operação em Codesys.",
                              "finalVerifications": [
                                "Interpretar corretamente um programa LD/FBD/ST desconhecido e explicar lógica passo a passo.",
                                "Criar programas funcionais em cada linguagem para o mesmo problema (ex: controle de bomba).",
                                "Simular e debugar erros intencionais em programas mistos.",
                                "Converter programas entre LD, FBD e ST sem perda de funcionalidade.",
                                "Documentar um projeto com normas IEC 61131-3.",
                                "Identificar violações da norma em códigos fornecidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação: 100% de acerto em simulações lógicas.",
                                "Completude do código: Todos elementos IEC implementados corretamente.",
                                "Eficiência: Ciclos de scan otimizados, sem loops infinitos.",
                                "Modularidade: Uso apropriado de blocos e funções reutilizáveis.",
                                "Documentação: Comentários claros e diagrama de fluxo.",
                                "Debugging: Identificação e correção de 90% dos erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Equivalência com circuitos lógicos e relés.",
                                "Programação Geral: Conceitos de linguagens imperativas e funcionais.",
                                "Automação Industrial: Integração com SCADA e HMI.",
                                "Matemática: Lógica booleana e álgebra.",
                                "Projeto Mecatrônico: Aplicação em atuadores e sensores."
                              ],
                              "realWorldApplication": "Em fábricas de automotiva, programar CLPs para linhas de montagem onde LD gerencia I/O de segurança, FBD controla loops PID de temperatura, e ST processa dados de visão computacional para inspeção de qualidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Implementar controle sequencial com CLPs",
                            "description": "Desenvolver sequências de controle para máquinas mecatrônicas, como linhas de montagem, incorporando temporizadores, contadores e diagnósticos de falhas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar Requisitos e Modelar Sequência de Controle",
                                  "subSteps": [
                                    "Identificar entradas (sensores, botões) e saídas (atuadores, motores) do sistema mecatrônico.",
                                    "Definir estados sequenciais principais (ex: inicialização, operação, parada).",
                                    "Incorporar temporizadores para delays e contadores para ciclos.",
                                    "Mapear transições entre estados com condições de ativação.",
                                    "Planejar diagnósticos de falhas, como timeouts ou sensores inoperantes."
                                  ],
                                  "verification": "Diagrama de sequência (ex: Grafcet ou SFC) completo e revisado por pares.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de diagramação (Draw.io ou Visio)",
                                    "Especificação técnica do projeto",
                                    "Papel e marcadores"
                                  ],
                                  "tips": [
                                    "Use notação SFC para visualização clara de estados e transições.",
                                    "Priorize segurança em transições de emergência."
                                  ],
                                  "learningObjective": "Modelar logicamente uma sequência de controle sequencial com elementos temporais e de contagem.",
                                  "commonMistakes": [
                                    "Omitir condições de reset ou falha.",
                                    "Definir estados sobrepostos ou ambíguos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Programação do CLP",
                                  "subSteps": [
                                    "Instalar e configurar software de programação do CLP (ex: TIA Portal para Siemens ou RSLogix para Allen-Bradley).",
                                    "Conectar o CLP ao computador via Ethernet ou USB.",
                                    "Criar novo projeto e configurar I/O mapping conforme diagrama.",
                                    "Testar comunicação e carregar configuração básica.",
                                    "Configurar bibliotecas para temporizadores (TON/TOF) e contadores (CTU/CTD)."
                                  ],
                                  "verification": "Comunicação bem-sucedida e I/O mapeados corretamente no software.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "CLP físico ou simulador",
                                    "Cabo de programação",
                                    "Software proprietário do CLP",
                                    "Manual do CLP"
                                  ],
                                  "tips": [
                                    "Verifique versão de firmware compatível antes de conectar.",
                                    "Faça backup da configuração inicial."
                                  ],
                                  "learningObjective": "Preparar ambiente de desenvolvimento integrado para programação de CLP.",
                                  "commonMistakes": [
                                    "Mapeamento incorreto de endereços I/O.",
                                    "Ignorar permissões de segurança no software."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Programa Sequencial em Ladder Logic",
                                  "subSteps": [
                                    "Implementar estados iniciais com contatos e bobinas auxiliares.",
                                    "Adicionar rungs para temporizadores e contadores nos estados apropriados.",
                                    "Inserir lógica de transições baseada em condições de entrada.",
                                    "Integrar diagnósticos: flags de erro e paradas de emergência.",
                                    "Adicionar HMI básico para monitoramento de estados."
                                  ],
                                  "verification": "Compilação sem erros e simulação offline executa sequência básica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de programação CLP",
                                    "Diagrama de sequência do Step 1"
                                  ],
                                  "tips": [
                                    "Use redes (networks) separadas por estado para modularidade.",
                                    "Teste cada rung isoladamente."
                                  ],
                                  "learningObjective": "Codificar controle sequencial usando blocos padrão de CLP.",
                                  "commonMistakes": [
                                    "Loops infinitos em transições.",
                                    "Excesso de timers sem reset adequado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, Depurar e Otimizar",
                                  "subSteps": [
                                    "Executar simulação online com variáveis de força (force I/O).",
                                    "Injetar falhas simuladas (ex: sensor off) e verificar diagnósticos.",
                                    "Medir tempos de ciclo e otimizar delays.",
                                    "Analisar watch tables para variáveis críticas.",
                                    "Documentar código com comentários em cada rung."
                                  ],
                                  "verification": "Simulação completa 10 ciclos sem falhas, com diagnósticos acionados corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulador integrado ao software CLP"
                                  ],
                                  "tips": [
                                    "Use modo single-step para depuração fina.",
                                    "Registre logs de simulação."
                                  ],
                                  "learningObjective": "Validar e refinar programa sequencial em ambiente virtual.",
                                  "commonMistakes": [
                                    "Não testar cenários de borda como reset rápido.",
                                    "Otimizar prematuramente sem validação."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar em Hardware e Realizar Testes Finais",
                                  "subSteps": [
                                    "Carregar programa no CLP físico e ativar modo RUN.",
                                    "Conectar sistema mecatrônico real (ex: esteiras, sensores).",
                                    "Executar testes cíclicos com monitoramento HMI.",
                                    "Verificar diagnósticos em falhas reais e recuperação.",
                                    "Gerar relatório de performance e manutenção."
                                  ],
                                  "verification": "Sistema opera 20 ciclos reais com 100% sucesso e recuperação de falhas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "CLP físico",
                                    "Hardware mecatrônico (sensores, atuadores)",
                                    "Multímetro para diagnósticos"
                                  ],
                                  "tips": [
                                    "Comece com velocidades reduzidas.",
                                    "Tenha plano de desligamento de emergência."
                                  ],
                                  "learningObjective": "Integrar e validar controle sequencial em aplicação real.",
                                  "commonMistakes": [
                                    "Carregar sem download seguro.",
                                    "Ignorar vibrações afetando sensores."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linha de montagem de embalagens: sensor detecta caixa vazia (entrada) -> ativa esteira por temporizador de 5s -> braço robótico carrega produto (contador de 100 itens) -> sensor confirma montagem -> descarga; se sensor falhar, para e aciona alarme diagnóstico.",
                              "finalVerifications": [
                                "Sequência completa executa sem travamentos em simulação e hardware.",
                                "Temporizadores e contadores respondem precisamente às condições.",
                                "Diagnósticos detectam e isolam falhas em <2s.",
                                "Sistema reseta corretamente após emergência.",
                                "HMI exibe estados e erros em tempo real.",
                                "Relatório documenta 95%+ de uptime em testes."
                              ],
                              "assessmentCriteria": [
                                "Precisão da sequência: 100% de transições corretas em 50 ciclos.",
                                "Resposta a falhas: detecção e recuperação em <5s.",
                                "Eficiência: tempo de ciclo otimizado vs. especificação (±10%).",
                                "Qualidade do código: modular, comentado e compilável sem warnings.",
                                "Documentação: diagramas e relatório completos.",
                                "Segurança: todas paradas de emergência funcionais."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Configuração de I/O e sensores.",
                                "Programação: Lógica booleana e estruturas de controle.",
                                "Mecânica Industrial: Integração com atuadores pneumáticos/hidráulicos.",
                                "Manutenção Predial: Estratégias de diagnóstico e troubleshooting.",
                                "Gestão de Projetos: Planejamento e documentação de automação."
                              ],
                              "realWorldApplication": "Controle de linhas de produção em indústrias automotivas, alimentícias e farmacêuticas, garantindo eficiência, redução de downtime e conformidade com normas de segurança como NR-12 no Brasil."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Integrar CLPs em redes industriais",
                            "description": "Configurar comunicação Profibus, Modbus ou Ethernet/IP para conectar CLPs a sensores, atuadores e sistemas HMI em ambientes mecatrônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Planejar o Protocolo de Comunicação",
                                  "subSteps": [
                                    "Analisar os requisitos do sistema mecatrônico, incluindo distância, velocidade de transmissão e número de dispositivos.",
                                    "Comparar protocolos Profibus, Modbus e Ethernet/IP com base em compatibilidade, custo e desempenho.",
                                    "Definir a topologia da rede (barramento, estrela ou anel) e diagramar as conexões.",
                                    "Listar todos os dispositivos (CLP, sensores, atuadores, HMI) e mapear endereços preliminares.",
                                    "Elaborar um plano escrito com justificativas."
                                  ],
                                  "verification": "Aprovação do diagrama de rede e plano de comunicação por supervisor ou simulação inicial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação técnica dos protocolos (manuais Profibus/Modbus/Ethernet/IP)",
                                    "Especificações dos dispositivos CLP e periféricos",
                                    "Software de diagramação (ex: Visio ou Draw.io)"
                                  ],
                                  "tips": "Priorize Ethernet/IP para redes modernas com alta velocidade; use Modbus para simplicidade em redes pequenas.",
                                  "learningObjective": "Compreender critérios para seleção de protocolos industriais adequados ao contexto mecatrônico.",
                                  "commonMistakes": [
                                    "Ignorar limitações de distância (ex: Profibus DP até 100m)",
                                    "Não considerar ruído eletromagnético em ambientes industriais",
                                    "Escolher topologia incompatível com os dispositivos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a Infraestrutura Física da Rede",
                                  "subSteps": [
                                    "Selecionar e preparar cabos adequados (ex: par trançado blindado para Profibus, cabo Ethernet Cat5e para Ethernet/IP).",
                                    "Conectar fisicamente o CLP aos sensores, atuadores e HMI, respeitando a topologia planejada.",
                                    "Instalar resistores terminadores nas extremidades da rede (ex: 120 ohms para Modbus RS485).",
                                    "Verificar conexões com multímetro para continuidade, polaridade e ausência de curtos.",
                                    "Rotular todos os cabos e conexões para facilitar manutenção futura."
                                  ],
                                  "verification": "Teste de continuidade elétrica sem falhas e inspeção visual confirmando fixação segura.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Cabos industriais específicos (RS485, Profibus, Ethernet)",
                                    "Conectores DB9/M12/RJ45",
                                    "Multímetro e crimpadora",
                                    "Resistores terminadores"
                                  ],
                                  "tips": "Use blindagem aterrada em um só ponto para evitar loops de terra.",
                                  "learningObjective": "Dominar montagem física de redes industriais robustas contra interferências.",
                                  "commonMistakes": [
                                    "Inversão de polaridade em RS485",
                                    "Esquecimento de terminadores causando reflexões de sinal",
                                    "Cabos não blindados em ambientes ruidosos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Parâmetros de Software no CLP",
                                  "subSteps": [
                                    "Instalar e abrir o software de programação do CLP (ex: TIA Portal para Siemens, RSLogix para Allen-Bradley).",
                                    "Configurar o módulo de comunicação: endereço IP (Ethernet/IP), ID escravo (Modbus) ou endereço estação (Profibus).",
                                    "Definir parâmetros: baud rate (ex: 19200 bps para Modbus), paridade, timeouts e mapeamento de registradores.",
                                    "Criar blocos de função para leitura/escrita de dados (ex: MB_MASTER para Modbus).",
                                    "Compilar e fazer download da configuração para o CLP."
                                  ],
                                  "verification": "CLP inicializa sem erros de comunicação no software e LEDs de rede piscam corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de programação do CLP (TIA Portal, Codesys, etc.)",
                                    "PC com interface de programação (USB/Ethernet)",
                                    "Licenças de software se aplicável"
                                  ],
                                  "tips": "Comece com configurações padrão e ajuste gradualmente para evitar lockouts.",
                                  "learningObjective": "Configurar software para comunicação padronizada em redes industriais.",
                                  "commonMistakes": [
                                    "Endereços duplicados causando colisões",
                                    "Baud rate incompatível entre mestre/escravo",
                                    "Mapeamento incorreto de registradores I/O"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Programar Dispositivos Periféricos",
                                  "subSteps": [
                                    "Configurar sensores e atuadores como escravos (ex: endereços Modbus nos dispositivos).",
                                    "Programar o HMI para polling/leitura dos registradores do CLP.",
                                    "Implementar lógica no CLP para troca de dados (ex: ler sensor e acionar atuador via rede).",
                                    "Sincronizar clocks e priorizar mensagens críticas.",
                                    "Salvar configurações em todos os dispositivos."
                                  ],
                                  "verification": "Troca inicial de dados simulados via ferramentas de diagnóstico (ex: ping Modbus).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software HMI (ex: WinCC, FactoryTalk)",
                                    "Manuais dos sensores/atuadores",
                                    "Ferramentas de diagnóstico de rede (ex: Wireshark para Ethernet)"
                                  ],
                                  "tips": "Use modos de configuração segura para evitar ativações acidentais.",
                                  "learningObjective": "Integrar múltiplos dispositivos em uma rede coesa com CLP central.",
                                  "commonMistakes": [
                                    "Configurações de escravo não salvas",
                                    "Lógica sem tratamento de erros de comunicação",
                                    "HMI com polling muito frequente sobrecarregando a rede"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Depurar e Validar a Integração",
                                  "subSteps": [
                                    "Executar testes unitários: comunicação CLP-sensor, CLP-atuador, CLP-HMI.",
                                    "Simular falhas (desconectar cabo) e verificar recuperação automática.",
                                    "Monitorar tráfego de rede com ferramentas de diagnóstico e analisar erros.",
                                    "Otimizar performance (reduzir latência, priorizar pacotes).",
                                    "Documentar resultados e configurações finais."
                                  ],
                                  "verification": "Sistema operacional em ciclo completo sem perda de dados por 30 minutos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de diagnóstico (Profibus tester, Modbus Poll)",
                                    "Osciloscópio para sinais seriais",
                                    "Checklist de testes"
                                  ],
                                  "tips": "Registre timestamps de erros para análise de padrões.",
                                  "learningObjective": "Validar robustez da rede integrada em cenários reais.",
                                  "commonMistakes": [
                                    "Não testar sob carga máxima",
                                    "Ignorar timeouts em recuperação",
                                    "Falta de documentação para troubleshooting"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma célula mecatrônica de inspeção de peças automotivas, configure uma rede Modbus RTU com CLP Siemens S7-1200 como mestre conectado a 3 sensores indutivos (endereços 1-3), 2 atuadores pneumáticos (endereços 4-5) e HMI Siemens Comfort Panel. O CLP lê posições dos sensores a cada 500ms, aciona atuadores se defeito detectado e exibe status no HMI, permitindo operação autônoma da célula.",
                              "finalVerifications": [
                                "CLP estabelece comunicação bidirecional com todos os dispositivos sem timeouts.",
                                "Dados de sensores são lidos e refletidos no HMI em tempo real (<1s).",
                                "Atuadores respondem corretamente a comandos do CLP via rede.",
                                "Rede resiste a desconexão/reconexão de um dispositivo sem falha total.",
                                "Não há erros de CRC ou colisão acumulados após 1 hora de operação.",
                                "LEDs de status indicam link ativo em todos os nós."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção e configuração do protocolo (compatibilidade 100%).",
                                "Ausência de falhas físicas na rede (continuidade e blindagem verificadas).",
                                "Configurações de software corretas (endereços únicos, parâmetros sincronizados).",
                                "Performance da rede: latência <200ms, taxa de erro <0.1%.",
                                "Robustez: recuperação de falhas em <5s.",
                                "Documentação completa e diagramas legíveis."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Industrial: Conhecimento de sinais diferenciais e blindagem.",
                                "Programação de CLPs: Uso de blocos de comunicação e tratamento de exceções.",
                                "Mecânica: Integração com atuadores pneumáticos/hidráulicos.",
                                "Segurança do Trabalho: Normas NR-12 para redes em máquinas.",
                                "Gestão de Projetos: Planejamento e documentação de integrações."
                              ],
                              "realWorldApplication": "Em fábricas de automação industrial, como linhas de montagem da indústria automotiva (ex: Volkswagen ou Mercedes), onde CLPs integrados via Ethernet/IP controlam robôs, esteiras e HMIs, permitindo produção 24/7 com monitoramento remoto, redução de downtime e escalabilidade para Indústria 4.0."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Processos de Execução de Projetos Mecatrônicos",
                    "description": "Etapas de implementação, teste e validação de projetos de sistemas mecatrônicos e microcontrolados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Implementação de Sistemas Mecatrônicos",
                        "description": "Etapas práticas de montagem, programação e integração inicial de componentes em projetos mecatrônicos e microcontrolados, utilizando times multifuncionais e técnicas de desenvolvimento integrado de produtos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Montagem de Hardware Mecatrônico",
                            "description": "Realizar a montagem física de atuadores, sensores e microcontroladores em protótipos, garantindo compatibilidade mecânica e elétrica conforme especificações do projeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejamento e Verificação de Componentes",
                                  "subSteps": [
                                    "Reunir todos os componentes listados nas especificações do projeto: atuadores (ex: servos, motores DC), sensores (ex: ultrassônicos, encoders) e microcontrolador (ex: Arduino ou ESP32).",
                                    "Verificar a compatibilidade mecânica consultando dimensões, furos de montagem e peso suportado usando folhas de dados (datasheets).",
                                    "Inspecionar visualmente por danos e testar continuidade elétrica com multímetro.",
                                    "Criar um diagrama esquemático de montagem usando software como Fritzing ou papel.",
                                    "Listar ferramentas e materiais necessários e preparar estação de trabalho limpa e organizada."
                                  ],
                                  "verification": "Checklist completo assinalado com fotos de componentes inspecionados e diagrama aprovado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Datasheets dos componentes",
                                    "Multímetro",
                                    "Ferramentas de medição (paquímetro, régua)",
                                    "Papel ou software de diagramação"
                                  ],
                                  "tips": "Sempre use EPI (óculos, luvas antiestáticas) para evitar danos eletrostáticos.",
                                  "learningObjective": "Identificar e validar compatibilidade de componentes antes da montagem.",
                                  "commonMistakes": [
                                    "Ignorar datasheets levando a incompatibilidades",
                                    "Não testar continuidade causando falhas elétricas posteriores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montagem da Base Estrutural",
                                  "subSteps": [
                                    "Selecionar e preparar a base ou chassi conforme projeto (ex: placa de acrílico ou estrutura impressa em 3D).",
                                    "Fixar o microcontrolador na base usando parafusos ou suportes adequados, garantindo acesso a portas.",
                                    "Alinhar e perfurar furos necessários com broca adequada ao material.",
                                    "Fixar suportes para atuadores e sensores, verificando alinhamento com nível bolha.",
                                    "Aplicar adesivos ou parafusos para reforço estrutural."
                                  ],
                                  "verification": "Base estável, sem folgas, testada com pressão manual sem deformações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Base/chassi",
                                    "Parafusos, porcas e arruelas",
                                    "Broca e furadeira",
                                    "Nível bolha",
                                    "Alicate de corte"
                                  ],
                                  "tips": "Use torque controlado em parafusos para evitar trincar materiais frágeis.",
                                  "learningObjective": "Construir uma estrutura mecânica robusta e alinhada.",
                                  "commonMistakes": [
                                    "Alinhamento incorreto causando vibrações",
                                    "Furos mal posicionados desperdiçando material"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instalação de Sensores e Atuadores",
                                  "subSteps": [
                                    "Posicionar sensores em locais otimizados (ex: sensor ultrassônico na frente do protótipo).",
                                    "Fixar atuadores com grampos ou suportes, verificando ângulos de movimento livre.",
                                    "Testar movimento manual dos atuadores para garantir ausência de obstruções mecânicas.",
                                    "Ajustar posicionamento com shims ou espaçadores se necessário.",
                                    "Documentar posições finais com fotos e medidas."
                                  ],
                                  "verification": "Todos sensores e atuadores se movem livremente sem interferências mecânicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Sensores e atuadores",
                                    "Suportes e grampos",
                                    "Shims/espaçadores",
                                    "Chaves de fenda e allen"
                                  ],
                                  "tips": "Marque eixos de rotação para alinhamento preciso.",
                                  "learningObjective": "Integrar componentes dinâmicos mantendo liberdade de movimento.",
                                  "commonMistakes": [
                                    "Fixação muito rígida limitando movimento",
                                    "Posicionamento subótimo afetando performance"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conexões Elétricas e Fiação",
                                  "subSteps": [
                                    "Seguir diagrama esquemático para conectar fios: VCC, GND e sinais aos pinos corretos.",
                                    "Usar conectores dupont ou solda com manga retrátil para isolação.",
                                    "Organizar cabos com abraçadeiras zip-tie para evitar curtos e interferências.",
                                    "Verificar polaridade e tensões com multímetro antes de energizar.",
                                    "Rotular todos os fios para facilitar troubleshooting."
                                  ],
                                  "verification": "Continuidade elétrica confirmada em todos os circuitos sem curtos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Fios jumper, conectores",
                                    "Multímetro",
                                    "Manga retrátil e soldador",
                                    "Abraçadeiras zip-tie"
                                  ],
                                  "tips": "Mantenha fios curtos para reduzir ruído eletromagnético.",
                                  "learningObjective": "Realizar conexões elétricas seguras e organizadas.",
                                  "commonMistakes": [
                                    "Inversão de polaridade danificando componentes",
                                    "Cabos soltos causando falhas intermitentes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes Iniciais e Ajustes Finais",
                                  "subSteps": [
                                    "Energizar o sistema em baixa tensão e verificar funcionamento básico via código de teste.",
                                    "Medir correntes e tensões para detectar sobrecargas.",
                                    "Ajustar fixações soltas e realinhar componentes conforme necessário.",
                                    "Executar testes de integração: sensores detectando e atuadores respondendo.",
                                    "Documentar relatório final com métricas de performance."
                                  ],
                                  "verification": "Sistema operacional sem erros, todas especificações atendidas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Fonte de alimentação",
                                    "Osciloscópio ou multímetro avançado",
                                    "Código de teste no microcontrolador"
                                  ],
                                  "tips": "Teste incrementalmente para isolar falhas rapidamente.",
                                  "learningObjective": "Validar montagem completa através de testes funcionais.",
                                  "commonMistakes": [
                                    "Pular testes levando a falhas em campo",
                                    "Ignorar vibrações em testes dinâmicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Montagem de um braço robótico simples: fixe um servo motor como junta base em chassi de acrílico, instale sensor ultrassônico na extremidade, conecte ao Arduino com fios organizados, teste movimentos coordenados via código serial.",
                              "finalVerifications": [
                                "Todos componentes firmemente fixados sem folgas ou vibrações excessivas.",
                                "Conexões elétricas sem curtos, com continuidade e polaridade corretas.",
                                "Movimentos livres de atuadores e leituras precisas de sensores.",
                                "Compatibilidade mecânica total: dimensões e alinhamentos conforme specs.",
                                "Sistema energizado opera sem superaquecimento ou falhas.",
                                "Documentação completa com diagramas e fotos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na verificação de compatibilidade (100% dos componentes validados).",
                                "Robustez mecânica: resiste a testes de estresse manual.",
                                "Qualidade das conexões elétricas: zero curtos ou falhas elétricas.",
                                "Organização e rotulagem de fiação (fácil manutenção).",
                                "Performance em testes: sensores e atuadores funcionam integrados.",
                                "Tempo de montagem dentro do estimado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Conceitos de circuitos e medições elétricas.",
                                "Programação: Desenvolvimento de códigos de teste para validação.",
                                "Física: Análise de forças, torques e alinhamentos mecânicos.",
                                "Matemática: Cálculos de dimensões e tolerâncias.",
                                "Segurança do Trabalho: Uso de EPI e normas de montagem industrial."
                              ],
                              "realWorldApplication": "Na indústria automotiva, montagem de sistemas mecatrônicos em linhas de produção robóticas, garantindo precisão em braços robóticos para soldagem ou montagem de peças, reduzindo downtime e erros humanos."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Programação de Microcontroladores",
                            "description": "Desenvolver e carregar firmware em microcontroladores para controle de sistemas mecatrônicos, incluindo loops de controle e interfaces com periféricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Selecionar e instalar o IDE apropriado (ex: Arduino IDE ou PlatformIO).",
                                    "Instalar drivers e bibliotecas necessárias para o microcontrolador escolhido (ex: Arduino Uno, ESP32).",
                                    "Conectar o microcontrolador ao computador via USB e verificar portas COM.",
                                    "Compilar e carregar um sketch de teste vazio para validar a comunicação.",
                                    "Configurar o gerenciador de placas e bibliotecas externas."
                                  ],
                                  "verification": "Sketch de teste compila e carrega sem erros, com LED de power aceso no microcontrolador.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Computador com Windows/Linux/Mac",
                                    "Microcontrolador (ex: Arduino Uno)",
                                    "Cabo USB",
                                    "Arduino IDE"
                                  ],
                                  "tips": [
                                    "Use o modo verbose no IDE para depuração de erros de porta.",
                                    "Verifique conflitos de drivers com gerenciadores de dispositivos."
                                  ],
                                  "learningObjective": "Configurar ambiente funcional para programação de microcontroladores.",
                                  "commonMistakes": [
                                    "Selecionar porta COM errada.",
                                    "Não instalar drivers CH340/FTDI.",
                                    "Esquecer de selecionar a placa correta."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolvimento de Firmware Básico",
                                  "subSteps": [
                                    "Escrever código para piscar um LED usando loop() e delay().",
                                    "Implementar funções personalizadas para controle do LED (ex: blink com frequência variável).",
                                    "Adicionar variáveis globais e constantes para pinos e tempos.",
                                    "Usar Serial.begin() para debug via monitor serial.",
                                    "Testar variações de velocidade de piscar com millis() em vez de delay()."
                                  ],
                                  "verification": "LED pisca conforme código, monitor serial exibe mensagens de debug.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Protoboard",
                                    "LED",
                                    "Resistor 220Ω",
                                    "Jumpers",
                                    "Microcontrolador"
                                  ],
                                  "tips": [
                                    "Prefira millis() para não-blocking code.",
                                    "Sempre inicialize pinMode() no setup().",
                                    "Use #define para pinos."
                                  ],
                                  "learningObjective": "Dominar estrutura básica de firmware: setup(), loop(), funções e debug.",
                                  "commonMistakes": [
                                    "Usar delay() em loops críticos.",
                                    "Esquecer pinMode().",
                                    "Não flush Serial antes de leituras."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integração com Periféricos",
                                  "subSteps": [
                                    "Conectar e configurar sensor analógico (ex: potenciômetro no A0).",
                                    "Ler valores do sensor com analogRead() e mapear para 0-255.",
                                    "Conectar atuador (ex: servo ou LED PWM) e controlar com analogWrite().",
                                    "Implementar comunicação I2C ou SPI se aplicável para periféricos avançados.",
                                    "Adicionar tratamento de erros para leituras inválidas."
                                  ],
                                  "verification": "Valor do sensor varia o brilho do LED ou posição do servo em tempo real.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Potenciômetro 10kΩ",
                                    "Servo motor SG90 ou LED PWM",
                                    "Protoboard e jumpers"
                                  ],
                                  "tips": [
                                    "Calibre sensores com leituras múltiplas e média.",
                                    "Use bibliotecas Servo.h para simplificação.",
                                    "Monitore picos com Serial.print."
                                  ],
                                  "learningObjective": "Interfacear microcontrolador com sensores e atuadores.",
                                  "commonMistakes": [
                                    "Pinos errados para PWM (nem todos são PWM).",
                                    "Não mapear valores analógicos corretamente.",
                                    "Conexões invertidas em I2C."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementação de Loops de Controle",
                                  "subSteps": [
                                    "Implementar loop de controle proporcional simples (P-control) para estabilizar saída baseada em setpoint.",
                                    "Adicionar controle integral (PI) para eliminar erro steady-state.",
                                    "Testar com sensor e atuador reais (ex: controlar velocidade de motor via PWM baseado em encoder).",
                                    "Otimizar constantes Kp, Ki via tuning manual ou Ziegler-Nichols.",
                                    "Adicionar deadband e filtros para ruído."
                                  ],
                                  "verification": "Sistema atinge setpoint em <5s com overshoot <10%, erro steady-state <2%.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Motor DC com driver L298N",
                                    "Encoder ou sensor de velocidade",
                                    "Bateria ou fonte 5V"
                                  ],
                                  "tips": [
                                    "Comece com Kp baixo para evitar oscilações.",
                                    "Log erros no Serial para tuning.",
                                    "Use interrupções para encoders precisos."
                                  ],
                                  "learningObjective": "Desenvolver algoritmos de controle fechado em firmware.",
                                  "commonMistakes": [
                                    "Ganho alto causando oscilações.",
                                    "Sem filtro de ruído em leituras.",
                                    "Integração sem limite causing windup."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes, Depuração e Deploy",
                                  "subSteps": [
                                    "Executar testes unitários para cada função (ex: assert em simulações).",
                                    "Depurar com breakpoints no IDE ou Serial debug.",
                                    "Otimizar código para memória e CPU (ex: evitar floats se possível).",
                                    "Gerar firmware final e carregar em produção.",
                                    "Documentar código com comentários e README."
                                  ],
                                  "verification": "Firmware roda estável por 30min sem crashes, passa todos testes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Multímetro para verificações elétricas"
                                  ],
                                  "tips": [
                                    "Use oscilloscope se disponível para sinais.",
                                    "Versione código com Git.",
                                    "Teste em diferentes condições (temp, volt)."
                                  ],
                                  "learningObjective": "Garantir robustez e deploy de firmware mecatrônico.",
                                  "commonMistakes": [
                                    "Ignorar warnings de compilação.",
                                    "Sem testes de edge cases.",
                                    "Código sem documentação."
                                  ]
                                }
                              ],
                              "practicalExample": "Programar um Arduino Uno para ler um sensor de temperatura (DHT11) e controlar um cooler via PWM, mantendo temperatura entre 20-25°C usando controle PI em um braço robótico simples.",
                              "finalVerifications": [
                                "Firmware compila e carrega sem erros em hardware alvo.",
                                "Sistema responde a inputs periféricos em <100ms.",
                                "Loop de controle mantém precisão de 5% no setpoint.",
                                "Monitor serial loga dados sem overflows.",
                                "Código consome <80% da memória flash.",
                                "Testes de longa duração (1h) sem falhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude do código (80% cobertura funcional).",
                                "Eficiência do loop de controle (tempo de settling <10s, overshoot <15%).",
                                "Qualidade de integração periféricos (sem artefatos ou ruído).",
                                "Documentação e comentários no código (>20% linhas).",
                                "Robustez a falhas (graceful degradation).",
                                "Tempo total de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Circuito de periféricos e sinalização.",
                                "Mecânica: Modelagem dinâmica para tuning de controle.",
                                "Programação: Estruturas de dados e algoritmos em C++.",
                                "Matemática: Cálculo diferencial para PID.",
                                "Física: Leis de controle e termodinâmica em aplicações."
                              ],
                              "realWorldApplication": "Desenvolvimento de sistemas embarcados em automação industrial, como PLCs para linhas de montagem, drones autônomos ou wearables IoT com feedback sensorial."
                            },
                            "estimatedTime": "6 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Integração Inicial de Componentes",
                            "description": "Conectar subsistemas como microprocessadores, CLPs e módulos de visão por computador em um ambiente multifuncional, verificando comunicação básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e Verificação Individual dos Componentes",
                                  "subSteps": [
                                    "Inspecione fisicamente microprocessadores, CLPs e módulos de visão por computador quanto a danos ou defeitos.",
                                    "Instale e configure o firmware/software básico em cada componente individualmente.",
                                    "Realize testes unitários em cada subsistema para garantir funcionamento autônomo.",
                                    "Documente configurações iniciais e resultados dos testes unitários.",
                                    "Calibre sensores e atuadores associados aos módulos."
                                  ],
                                  "verification": "Cada componente responde corretamente a comandos básicos isolados, sem erros reportados nos logs.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Microprocessadores (ex: Arduino/Raspberry Pi)",
                                    "CLPs (ex: Siemens S7 ou Allen-Bradley)",
                                    "Módulos de visão (ex: OpenCV camera)",
                                    "Ferramentas de diagnóstico (multímetro, osciloscópio)",
                                    "Software de programação (IDE para cada componente)"
                                  ],
                                  "tips": "Sempre desligue a alimentação antes de inspeções físicas e use luvas antiestáticas para evitar danos ESD.",
                                  "learningObjective": "Garantir que todos os subsistemas funcionem de forma independente antes da integração.",
                                  "commonMistakes": [
                                    "Ignorar calibração de sensores levando a leituras imprecisas",
                                    "Firmware desatualizado causando incompatibilidades",
                                    "Não documentar configurações iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conexão Física dos Subsistemas",
                                  "subSteps": [
                                    "Identifique pinos de comunicação (ex: UART, I2C, Ethernet, CAN) em cada componente conforme datasheet.",
                                    "Monte o barramento de comunicação físico utilizando cabos blindados e conectores apropriados.",
                                    "Conecte fontes de alimentação compartilhadas ou independentes com proteções contra surtos.",
                                    "Instale módulos de interface se necessário (ex: conversores RS232-RS485).",
                                    "Verifique continuidade elétrica e ausência de curtos-circuitos com multímetro."
                                  ],
                                  "verification": "Continuidade confirmada em todos os pinos de comunicação e zero resistência em curtos indesejados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Cabos de comunicação (Ethernet CAT6, RS485)",
                                    "Conectores e terminadores",
                                    "Fontes de alimentação reguladas",
                                    "Multímetro e testador de cabos"
                                  ],
                                  "tips": "Use diagramas esquemáticos para mapear conexões e evite loops de terra para reduzir ruído.",
                                  "learningObjective": "Estabelecer conexões físicas seguras e compatíveis entre subsistemas.",
                                  "commonMistakes": [
                                    "Conexões invertidas em pinos TX/RX",
                                    "Falta de terminadores em barramentos CAN/RS485",
                                    "Alimentação inadequada causando brownouts"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configuração de Protocolos de Comunicação",
                                  "subSteps": [
                                    "Selecione e configure o protocolo comum (ex: Modbus TCP, OPC UA) em todos os dispositivos.",
                                    "Defina endereços IP ou IDs de nó únicos para evitar conflitos.",
                                    "Implemente scripts ou blocos de função para envio/recebimento de mensagens de teste.",
                                    "Ajuste baud rates, paridade e timeouts para sincronização.",
                                    "Habilite logs de comunicação para monitoramento em tempo real."
                                  ],
                                  "verification": "Mensagens de handshake trocadas com ACKs confirmados entre todos os pares de subsistemas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de configuração (ex: TIA Portal para CLPs)",
                                    "Ferramentas de monitoramento de rede (Wireshark)",
                                    "Documentação de protocolos (datasheets)"
                                  ],
                                  "tips": "Comece com comunicação ponto-a-ponto antes de rede completa para isolar problemas.",
                                  "learningObjective": "Configurar comunicação digital padronizada entre subsistemas heterogêneos.",
                                  "commonMistakes": [
                                    "Endereços duplicados causando colisões",
                                    "Timeouts mal configurados levando a falhas falsas",
                                    "Protocolos incompatíveis entre fabricantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Teste e Verificação da Comunicação Básica",
                                  "subSteps": [
                                    "Execute comandos simples de ping ou heartbeat entre subsistemas.",
                                    "Teste troca de dados básicos (ex: envio de status de sensor do módulo de visão para CLP).",
                                    "Monitore latência, taxa de perda de pacotes e erros de CRC.",
                                    "Registre logs e waveforms para análise de falhas.",
                                    "Ajuste configurações iterativamente até estabilidade."
                                  ],
                                  "verification": "100% de sucesso em 100 comandos consecutivos sem perda de dados ou timeouts.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software de teste (ex: PLC simulators, serial monitors)",
                                    "Osciloscópio para sinais analógicos",
                                    "Logs e relatórios automatizados"
                                  ],
                                  "tips": "Use loops de teste automatizados para eficiência e repita testes sob carga simulada.",
                                  "learningObjective": "Validar comunicação básica funcional em ambiente multifuncional.",
                                  "commonMistakes": [
                                    "Ignorar ruído eletromagnético",
                                    "Testes insuficientes sem carga",
                                    "Não considerar interferências de outros dispositivos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de inspeção de qualidade em linha de montagem, integre um CLP Siemens com um Raspberry Pi (microprocessador) rodando visão computacional via Modbus TCP: o módulo de visão detecta defeitos e envia sinal binário ao CLP, que aciona um rejeitador pneumático.",
                              "finalVerifications": [
                                "Todos subsistemas se comunicam bidirecionalmente sem erros por 30 minutos contínuos.",
                                "Troca de dados reais (ex: imagem processada -> comando de atuador) ocorre com latência < 500ms.",
                                "Sistema permanece estável ao desconectar/reconectar um subsistema.",
                                "Logs mostram zero erros de protocolo ou timeouts.",
                                "Energia e sinais permanecem dentro de especificações nominais.",
                                "Documentação completa de configuração disponível e verificada."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas conexões físicas (sem curtos ou malhações).",
                                "Configurações de comunicação corretas e sincronizadas.",
                                "Taxa de sucesso nos testes > 95%.",
                                "Latência de comunicação abaixo de 1 segundo.",
                                "Documentação clara e completa do processo.",
                                "Identificação e correção de pelo menos um erro comum durante testes."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Análise de sinais e protocolos seriais.",
                                "Programação: Desenvolvimento de scripts de comunicação em linguagens como Ladder ou Python.",
                                "Redes Industriais: Conceitos de IIoT e barramentos de campo.",
                                "Manutenção Industrial: Diagnóstico de falhas em sistemas integrados.",
                                "Segurança do Trabalho: Normas NR-10 e NR-12 para integrações elétricas."
                              ],
                              "realWorldApplication": "Na indústria automotiva, integrações iniciais como essa são usadas em estações robóticas para coordenar visão artificial, controladores lógicos e microcontroladores em linhas de soldagem ou montagem, garantindo sincronia e reduzindo downtime em produção."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Testes em Projetos Mecatrônicos",
                        "description": "Procedimentos sistemáticos para testar funcionalidade, desempenho e robustez de sistemas mecatrônicos, identificando e corrigindo falhas durante a execução.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Testes Unitários de Componentes",
                            "description": "Executar testes isolados em sensores, atuadores e microcontroladores para validar operação individual conforme requisitos do projeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejamento dos Testes Unitários",
                                  "subSteps": [
                                    "Identificar os componentes a serem testados: sensores, atuadores e microcontroladores listados nos requisitos do projeto.",
                                    "Revisar os requisitos funcionais e não funcionais de cada componente (ex: faixa de medição do sensor, torque do atuador).",
                                    "Definir casos de teste positivos, negativos e de borda para cada componente.",
                                    "Elaborar uma planilha ou documento com os critérios de aceitação para cada caso de teste.",
                                    "Priorizar testes com base no risco de falha do componente."
                                  ],
                                  "verification": "Planilha de testes preenchida e revisada por pares, com pelo menos 5 casos por componente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Requisitos do projeto",
                                    "Planilha Excel ou Google Sheets",
                                    "Documentação técnica dos componentes"
                                  ],
                                  "tips": "Comece pelos componentes mais críticos para o projeto, como sensores de segurança.",
                                  "learningObjective": "Compreender e mapear requisitos em casos de teste acionáveis.",
                                  "commonMistakes": [
                                    "Ignorar casos de borda",
                                    "Não considerar variações ambientais (temperatura, umidade)",
                                    "Definir testes muito genéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração do Ambiente de Teste Isolado",
                                  "subSteps": [
                                    "Montar um setup isolado em breadboard ou protoboard para cada tipo de componente.",
                                    "Conectar o componente ao microcontrolador de teste (ex: Arduino ou Raspberry Pi) sem interferência de outros módulos.",
                                    "Instalar e configurar o software de teste (IDE, bibliotecas específicas para sensores/atuadores).",
                                    "Realizar testes de conectividade básica (energia, comunicação serial).",
                                    "Calibrar equipamentos de medição auxiliares (multímetro, osciloscópio)."
                                  ],
                                  "verification": "Setup operacional com leituras estáveis de energia e comunicação sem erros.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Breadboard",
                                    "Microcontrolador de teste",
                                    "Cabos jumper",
                                    "Multímetro",
                                    "Computador com IDE instalada"
                                  ],
                                  "tips": "Use resistores de pull-up/down quando necessário para evitar ruídos em sinais digitais.",
                                  "learningObjective": "Configurar ambientes de teste isolados para simular condições reais sem dependências.",
                                  "commonMistakes": [
                                    "Conexões cruzadas entre componentes",
                                    "Alimentação inadequada causando superaquecimento",
                                    "Bibliotecas incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Execução dos Testes Unitários",
                                  "subSteps": [
                                    "Executar testes em sensores: verificar leituras em diferentes condições (ex: sensor de temperatura em banho térmico).",
                                    "Executar testes em atuadores: validar respostas a comandos (ex: motor girando em velocidades específicas).",
                                    "Executar testes em microcontroladores: checar boot, loops principais e interfaces de comunicação.",
                                    "Registrar resultados em tempo real (logs, capturas de tela, vídeos curtos).",
                                    "Repetir testes 3 vezes para confirmar consistência."
                                  ],
                                  "verification": "Relatório parcial com resultados de todos os casos de teste executados e aprovados.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Componentes a testar",
                                    "Fontes de sinal de teste (ex: potenciômetro para simular entrada)",
                                    "Osciloscópio ou logic analyzer opcional"
                                  ],
                                  "tips": "Automatize testes repetitivos com scripts simples no microcontrolador.",
                                  "learningObjective": "Executar testes isolados com precisão e registrar evidências.",
                                  "commonMistakes": [
                                    "Testes não repetidos",
                                    "Ignorar latência ou ruído nos sinais",
                                    "Danos por sobrecarga de atuadores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise de Resultados e Documentação",
                                  "subSteps": [
                                    "Comparar resultados obtidos com critérios de aceitação definidos no planejamento.",
                                    "Identificar falhas, causas raiz e ações corretivas (ex: recalibração ou substituição).",
                                    "Gerar relatório final com métricas (taxa de aprovação, tempo de execução).",
                                    "Arquivar evidências (códigos fonte, logs, fotos do setup).",
                                    "Recomendar próximos passos para integração."
                                  ],
                                  "verification": "Relatório completo aprovado, com taxa de aprovação mínima de 95%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha de resultados",
                                    "Ferramentas de edição de relatórios (Word, Markdown)"
                                  ],
                                  "tips": "Use gráficos para visualizar desempenho (ex: gráfico de leituras do sensor vs. esperado).",
                                  "learningObjective": "Analisar dados de teste e documentar para auditoria.",
                                  "commonMistakes": [
                                    "Relatórios vagos sem evidências",
                                    "Não rastrear causas de falhas",
                                    "Omitir recomendações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de carrinho robótico autônomo, testar unitariamente o sensor ultrassônico HC-SR04: configurar no Arduino, enviar 10 pulsos trigger, medir distâncias de 2cm, 50cm e 200cm, verificando leituras com ±2% de precisão contra régua métrica.",
                              "finalVerifications": [
                                "Todos os componentes (sensores, atuadores, microcontroladores) foram testados isoladamente.",
                                "Taxa de aprovação dos testes ≥ 95%, com repetições confirmadas.",
                                "Relatório documenta setup, resultados, falhas e ações corretivas.",
                                "Evidências fotográficas/vídeos de setups e leituras estão arquivadas.",
                                "Critérios de aceitação dos requisitos do projeto foram atendidos.",
                                "Setup de teste pode ser replicado por outra pessoa."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na definição de casos de teste (cobertura ≥ 80% dos requisitos).",
                                "Execução sem danos aos componentes e setups isolados corretamente.",
                                "Análise quantitativa de resultados com métricas claras.",
                                "Documentação profissional e reproduzível.",
                                "Identificação proativa de erros comuns e correções aplicadas.",
                                "Eficiência temporal dentro das estimativas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de scripts de teste em linguagens como C++ ou Python.",
                                "Eletrônica: Conhecimento de circuitos, sinais analógicos/digitais e calibração.",
                                "Gestão de Qualidade: Aplicação de metodologias como PDCA em testes.",
                                "Matemática: Análise estatística de dados de medição (média, desvio padrão)."
                              ],
                              "realWorldApplication": "Na indústria automotiva, testes unitários de sensores de colisão em veículos garantem detecção precisa antes da integração ao sistema de freios ABS, evitando recalls caros e aumentando a segurança."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Testes Integrados de Subsistemas",
                            "description": "Realizar testes de integração entre hardware, software e controle, simulando cenários reais como aplicações robóticas na indústria aeronáutica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejamento dos Testes Integrados",
                                  "subSteps": [
                                    "Identificar subsistemas envolvidos (hardware, software e controle) e mapear interfaces entre eles.",
                                    "Definir cenários de teste baseados em requisitos do projeto, incluindo casos nominais e de falha.",
                                    "Criar matriz de testes com entradas, saídas esperadas e critérios de sucesso.",
                                    "Estabelecer métricas de desempenho (ex.: tempo de resposta, precisão).",
                                    "Revisar plano com equipe para validação."
                                  ],
                                  "verification": "Plano de testes documentado e aprovado pela equipe, com matriz completa.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Documentos de requisitos do projeto",
                                    "Ferramentas de diagramação (ex.: Draw.io)",
                                    "Planilhas (Excel ou Google Sheets)"
                                  ],
                                  "tips": "Priorize cenários críticos de segurança primeiro, como falhas em sistemas robóticos.",
                                  "learningObjective": "Desenvolver habilidade em planejar testes sistemáticos para integração.",
                                  "commonMistakes": [
                                    "Ignorar interfaces não documentadas",
                                    "Definir testes muito genéricos sem métricas claras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração do Ambiente de Teste",
                                  "subSteps": [
                                    "Montar bancada de testes com hardware real ou simuladores (ex.: ROS para robótica).",
                                    "Instalar e configurar software de controle e drivers necessários.",
                                    "Integrar ferramentas de monitoramento (osciloscópio, multímetro, logs de software).",
                                    "Realizar testes unitários rápidos em cada subsistema para baseline.",
                                    "Simular ambiente real, como vibrações ou temperaturas para aeronáutica."
                                  ],
                                  "verification": "Ambiente operacional com todos subsistemas comunicando sem erros iniciais.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Hardware dos subsistemas",
                                    "Software de simulação (ex.: Gazebo, MATLAB/Simulink)",
                                    "Equipamentos de medição",
                                    "Cabo de rede/USB"
                                  ],
                                  "tips": "Use containers Docker para isolar software e facilitar replicação.",
                                  "learningObjective": "Configurar setups realistas para testes de integração.",
                                  "commonMistakes": [
                                    "Configurar sem calibrar sensores",
                                    "Esquecer compatibilidade de versões de software"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Execução dos Testes de Integração",
                                  "subSteps": [
                                    "Executar testes sequencialmente, registrando dados em tempo real.",
                                    "Simular cenários robóticos reais, como pick-and-place em montagem aeronáutica.",
                                    "Monitorar interações entre hardware, software e controle (ex.: latência de comandos).",
                                    "Repetir testes múltiplas vezes para estatísticas de confiabilidade.",
                                    "Pausar e registrar anomalias imediatamente."
                                  ],
                                  "verification": "Todos cenários testados com logs completos e sem falhas catastróficas.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Bancada montada",
                                    "Scripts de automação de testes",
                                    "Câmeras para gravação visual"
                                  ],
                                  "tips": "Automatize testes repetitivos com scripts Python para eficiência.",
                                  "learningObjective": "Executar testes simulando condições reais de operação.",
                                  "commonMistakes": [
                                    "Executar testes isolados sem integração real",
                                    "Ignorar ruído ambiental"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise, Depuração e Relatório",
                                  "subSteps": [
                                    "Analisar logs e dados para identificar falhas de integração.",
                                    "Depurar problemas (ex.: mismatch de protocolos comunicação).",
                                    "Realizar testes de revalidação pós-correções.",
                                    "Compilar relatório com resultados, gráficos e recomendações.",
                                    "Arquivar artefatos para rastreabilidade."
                                  ],
                                  "verification": "Relatório final com todas falhas resolvidas e métricas atendidas.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Ferramentas de análise (ex.: Wireshark, MATLAB)",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use root cause analysis (5 Whys) para depuração eficaz.",
                                  "learningObjective": "Analisar resultados e documentar para iterações futuras.",
                                  "commonMistakes": [
                                    "Atribuir falhas erradamente a um subsistema",
                                    "Relatórios incompletos sem evidências"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de braço robótico para montagem de painéis aeronáuticos, integre motor (hardware), algoritmo de visão computacional (software) e PLC (controle): teste se o braço detecta peça, move com precisão <1mm e para em falha de sensor, simulando vibrações de fábrica.",
                              "finalVerifications": [
                                "Todos subsistemas integram sem erros de comunicação >95% das execuções.",
                                "Cenários reais simulados passam em métricas definidas (ex.: tempo <2s).",
                                "Falhas identificadas e corrigidas com evidências documentadas.",
                                "Relatório inclui gráficos de performance e lições aprendidas.",
                                "Sistema pronto para testes de sistema completo.",
                                "Equipe concorda com resultados via revisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude do plano de testes (30%).",
                                "Efetividade na configuração e execução (25%).",
                                "Profundidade da análise e depuração (20%).",
                                "Qualidade da documentação e relatórios (15%).",
                                "Adesão a prazos e segurança (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Scripts de automação em Python/ROS.",
                                "Eletrônica: Configuração de sensores e atuadores.",
                                "Gestão de Projetos: Planejamento e rastreabilidade.",
                                "Física/Mecânica: Simulação de dinâmicas reais.",
                                "Segurança do Trabalho: Protocolos em testes robóticos."
                              ],
                              "realWorldApplication": "Na indústria aeronáutica, como na Embraer, testes integrados garantem que robôs de soldagem ou montagem operem sem falhas, reduzindo defeitos em aeronaves e atendendo certificações FAA/EASA."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Debug e Correção de Falhas",
                            "description": "Aplicar técnicas de depuração para identificar e resolver erros em sistemas mecatrônicos, utilizando ferramentas de monitoramento e análise de logs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Reproduzir e Documentar o Erro",
                                  "subSteps": [
                                    "Executar o sistema mecatrônico sob condições operacionais normais e estressantes.",
                                    "Observar e registrar sintomas exatos do erro (ex.: falha em movimento, ruído anormal).",
                                    "Documentar configurações de hardware, software e ambiente (versões, temperaturas, etc.).",
                                    "Tentar reproduzir o erro múltiplas vezes para confirmar consistência.",
                                    "Classificar o erro (hardware, software, integração ou ambiental)."
                                  ],
                                  "verification": "Erro reproduzido consistentemente com relatório detalhado incluindo screenshots, vídeos e logs iniciais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Sistema mecatrônico em teste",
                                    "Bloco de notas ou ferramenta como Jira/Trello",
                                    "Câmera ou smartphone para registros visuais"
                                  ],
                                  "tips": "Sempre anote a sequência exata de ações que levam ao erro para facilitar a reprodução.",
                                  "learningObjective": "Dominar a reprodução confiável de erros para basear análises subsequentes.",
                                  "commonMistakes": [
                                    "Ignorar condições ambientais variáveis",
                                    "Não registrar versões exatas de componentes",
                                    "Assumir erro sem múltiplas reproduções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ferramentas de Monitoramento e Coletar Dados",
                                  "subSteps": [
                                    "Instalar e configurar ferramentas como osciloscópio, multímetro, analisador lógico e software de logs (ex.: PLC logger).",
                                    "Definir pontos de monitoramento (sensores, atuadores, comunicação serial).",
                                    "Executar o sistema com monitoramento ativo durante reprodução do erro.",
                                    "Coletar logs, waveforms e métricas em tempo real.",
                                    "Salvar dados em formatos analisáveis (CSV, imagens de osciloscópio)."
                                  ],
                                  "verification": "Dados de monitoramento coletados e salvos, cobrindo o ciclo completo do erro.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Osciloscópio/multímetro",
                                    "Software de logging (ex.: LabVIEW, Arduino IDE Serial Monitor)",
                                    "Cabo de conexão e adaptadores"
                                  ],
                                  "tips": "Monitore múltiplos sinais simultaneamente para capturar correlações.",
                                  "learningObjective": "Aprender a usar ferramentas de monitoramento para capturar evidências empíricas de falhas.",
                                  "commonMistakes": [
                                    "Configurar ferramentas sem calibração",
                                    "Coletar dados insuficientes durante o erro",
                                    "Ignorar ruídos ou interferências"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Dados e Identificar Causa Raiz",
                                  "subSteps": [
                                    "Revisar logs e dados coletados em sequência temporal.",
                                    "Comparar valores normais vs. anormais (ex.: tensão fora de spec, delays em comunicação).",
                                    "Usar técnicas como diagrama de causa-efeito (Ishikawa) ou 5 Whys.",
                                    "Testar hipóteses isolando componentes (ex.: desconectar sensor).",
                                    "Documentar evidências que apontam para a causa raiz."
                                  ],
                                  "verification": "Relatório de análise com hipótese principal da causa raiz suportada por dados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de análise (ex.: MATLAB, Excel para logs)",
                                    "Diagramas impressos ou digitais",
                                    "Sistema para testes isolados"
                                  ],
                                  "tips": "Procure padrões recorrentes nos dados antes de concluir.",
                                  "learningObjective": "Desenvolver habilidades analíticas para isolar causas raízes em sistemas complexos.",
                                  "commonMistakes": [
                                    "Culpar o componente óbvio sem evidências",
                                    "Não considerar interações entre subsistemas",
                                    "Pular análise temporal dos logs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Correção, Testar e Validar",
                                  "subSteps": [
                                    "Aplicar correção baseada na causa raiz (ex.: corrigir código, trocar componente).",
                                    "Reproduzir condições de teste e monitorar para confirmar resolução.",
                                    "Executar testes de regressão em funcionalidades relacionadas.",
                                    "Otimizar se necessário e atualizar documentação do sistema.",
                                    "Registrar lições aprendidas para prevenção futura."
                                  ],
                                  "verification": "Sistema funcional sem erro reproduzido, com testes de regressão aprovados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de correção (soldador, editor de código)",
                                    "Sistema de teste completo",
                                    "Checklist de validação"
                                  ],
                                  "tips": "Sempre faça backup antes de alterações e teste incrementalmente.",
                                  "learningObjective": "Garantir correções robustas e preventivas em projetos mecatrônicos.",
                                  "commonMistakes": [
                                    "Corrigir sintoma em vez de causa",
                                    "Pular testes de regressão",
                                    "Não documentar a solução"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um braço robótico mecatrônico, o efetuador final não gira conforme comando. Reproduza o erro girando o braço; monitore logs do PLC e sinais do motor com osciloscópio, identifique delay no sensor de posição devido a conexão solta; corrija a conexão, teste movimentos completos e valide com ciclo de operação repetido.",
                              "finalVerifications": [
                                "Erro original não é mais reproduzível após 10 ciclos de teste.",
                                "Logs e monitoramento mostram valores dentro das especificações nominais.",
                                "Sistema mantém performance estável sob condições estressantes.",
                                "Documentação atualizada com correção e lições aprendidas.",
                                "Testes de regressão confirmam ausência de novos erros.",
                                "Eficiência do sistema restaurada ou melhorada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da causa raiz (baseada em evidências).",
                                "Eficiência temporal no processo completo de debug.",
                                "Qualidade da documentação e relatórios gerados.",
                                "Robustez da correção (ausência de regressões).",
                                "Uso adequado de ferramentas de monitoramento.",
                                "Criatividade na análise de hipóteses."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Análise e depuração de código embarcado.",
                                "Eletrônica: Medições e interpretação de sinais analógicos/digitais.",
                                "Gestão de Projetos: Documentação de issues e lições aprendidas.",
                                "Matemática: Análise estatística de dados de logs.",
                                "Física: Entendimento de dinâmicas de sistemas mecatrônicos."
                              ],
                              "realWorldApplication": "Na indústria manufatureira, debug de falhas em linhas de montagem robóticas reduz downtime, aumentando produtividade e evitando custos de paradas não planejadas em fábricas automotivas ou aeroespaciais."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Validação de Projetos Mecatrônicos",
                        "description": "Processos finais de verificação e validação para garantir que o sistema atenda aos requisitos de desempenho, segurança e aplicação industrial.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Verificação de Requisitos Funcionais",
                            "description": "Comparar o sistema implementado com os requisitos iniciais, utilizando métricas de desempenho para sistemas mecatrônicos e microcontrolados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Documentar Requisitos Iniciais",
                                  "subSteps": [
                                    "Ler integralmente o documento de especificação de requisitos do projeto mecatrônico.",
                                    "Extrair e listar todos os requisitos funcionais relevantes (ex: precisão de movimento, tempo de resposta).",
                                    "Categorizar requisitos por tipo: funcionais, de performance e de interface.",
                                    "Associar métricas quantificáveis a cada requisito (ex: erro < 0.5mm, ciclo < 2s).",
                                    "Criar uma tabela de rastreabilidade com colunas: ID, Descrição, Métrica, Critério de Aceitação."
                                  ],
                                  "verification": "Tabela de rastreabilidade completa, revisada e assinada por um par.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documento de requisitos",
                                    "Planilha Excel/Google Sheets",
                                    "Caneta e papel para anotações"
                                  ],
                                  "tips": "Priorize requisitos críticos marcados como 'high priority' e use numeração sequencial para IDs.",
                                  "learningObjective": "Compreender e organizar os requisitos iniciais de forma estruturada para facilitar a validação.",
                                  "commonMistakes": [
                                    "Ignorar requisitos implícitos ou não funcionais",
                                    "Não quantificar critérios de aceitação",
                                    "Listar requisitos de forma vaga sem métricas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Selecionar Métricas de Desempenho Específicas",
                                  "subSteps": [
                                    "Identificar métricas padrão para sistemas mecatrônicos: precisão, tempo de resposta, consumo de energia, confiabilidade.",
                                    "Adaptar métricas ao microcontrolador (ex: taxa de amostragem ADC, latência de interrupções).",
                                    "Definir métodos de medição para cada métrica (ex: osciloscópio para tempo, multímetro para energia).",
                                    "Estabelecer baselines e thresholds baseados nos requisitos (ex: precisão > 95%).",
                                    "Documentar protocolo de medição em um checklist padronizado."
                                  ],
                                  "verification": "Checklist de métricas aprovado, com métodos e thresholds definidos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Lista de métricas padrão para mecatrônica",
                                    "Documentação do microcontrolador (datasheet)",
                                    "Software de simulação como MATLAB/Simulink"
                                  ],
                                  "tips": "Consulte normas como ISO 9001 para métricas de qualidade em sistemas embarcados.",
                                  "learningObjective": "Selecionar métricas relevantes e quantificáveis para validar desempenho mecatrônico.",
                                  "commonMistakes": [
                                    "Escolher métricas irrelevantes ao contexto",
                                    "Definir thresholds irrealistas",
                                    "Esquecer métricas de robustez como vibração ou temperatura"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Testes e Coletar Dados do Sistema Implementado",
                                  "subSteps": [
                                    "Configurar ambiente de teste controlado (ex: bancada com alimentação estável).",
                                    "Executar testes repetidos (mínimo 10 ciclos) para cada métrica definida.",
                                    "Registrar dados brutos usando ferramentas de medição (ex: logger no microcontrolador).",
                                    "Calcular estatísticas básicas: média, desvio padrão, mínimo/máximo.",
                                    "Armazenar dados em formato tabular para análise posterior."
                                  ],
                                  "verification": "Banco de dados de testes coletados, com pelo menos 10 repetições por métrica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Sistema mecatrônico implementado",
                                    "Osciloscópio/multímetro",
                                    "Software de aquisição de dados (ex: Arduino IDE com Serial Plotter)",
                                    "Computador para logging"
                                  ],
                                  "tips": "Teste em condições nominais e extremas (ex: temperatura variada) para robustez.",
                                  "learningObjective": "Coletar dados empíricos precisos do sistema para comparação objetiva.",
                                  "commonMistakes": [
                                    "Poucas repetições levando a variância alta",
                                    "Ambiente de teste não controlado",
                                    "Erros de calibração em sensores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados, Comparar e Documentar Discrepâncias",
                                  "subSteps": [
                                    "Comparar valores medidos vs. requisitos usando gráficos e tabelas.",
                                    "Identificar e classificar discrepâncias (crítica, menor, atendida).",
                                    "Calcular conformidade percentual por requisito.",
                                    "Gerar relatório com evidências, análise estatística e recomendações de correção.",
                                    "Atualizar tabela de rastreabilidade com status final."
                                  ],
                                  "verification": "Relatório de validação completo, com gráficos e status de conformidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha com dados coletados",
                                    "Software de análise (Excel, Python com Pandas/Matplotlib)",
                                    "Template de relatório de validação"
                                  ],
                                  "tips": "Use testes de hipótese (ex: t-test) para validar significância estatística.",
                                  "learningObjective": "Realizar análise comparativa rigorosa e propor ações corretivas baseadas em evidências.",
                                  "commonMistakes": [
                                    "Análise subjetiva sem dados",
                                    "Omitir análise estatística",
                                    "Não priorizar discrepâncias críticas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um braço robótico controlado por Arduino, requisitos incluem precisão de 0.5mm e tempo de resposta <1s. Meça posição com encoder, compare erro médio (0.3mm atendido) e tempo (0.8s atendido), documente em relatório com gráficos de trajetória.",
                              "finalVerifications": [
                                "Todos os requisitos funcionais foram mapeados e testados.",
                                "Métricas medidas mostram conformidade >90% ou justificativa para falhas.",
                                "Relatório inclui dados brutos, análise e recomendações.",
                                "Tabela de rastreabilidade atualizada com status final.",
                                "Testes repetidos confirmam reprodutibilidade dos resultados.",
                                "Discrepâncias críticas têm plano de ação definido."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas medições e cálculos (>95% de acurácia).",
                                "Cobertura completa de todos os requisitos iniciais.",
                                "Uso adequado de estatísticas para análise de dados.",
                                "Relatório claro, objetivo e bem documentado.",
                                "Identificação precisa de discrepâncias e propostas viáveis.",
                                "Eficiência no tempo: conclusão dentro do estimado total (6 horas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e testes de hipótese para análise de dados.",
                                "Programação: Desenvolvimento de scripts de teste automatizados em C++/Python.",
                                "Eletrônica: Calibração de sensores e uso de ferramentas de medição.",
                                "Gestão de Projetos: Rastreabilidade e documentação conforme PMBOK.",
                                "Física: Compreensão de dinâmica e controle em sistemas mecatrônicos."
                              ],
                              "realWorldApplication": "Na indústria automotiva, engenheiros verificam se atuadores em linhas de montagem atendem requisitos de precisão e velocidade antes da produção em massa, evitando recalls caros e garantindo qualidade."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Simulações e Testes de Validação",
                            "description": "Executar simulações computacionais e testes em ambiente controlado para validar aplicações como robótica e visão por computador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejamento e Configuração do Ambiente de Simulação",
                                  "subSteps": [
                                    "Definir os parâmetros do sistema mecatrônico a ser simulado (ex: dimensões, massas, atuadores).",
                                    "Selecionar software de simulação adequado (Gazebo, MATLAB/Simulink ou CoppeliaSim).",
                                    "Importar ou criar modelo 3D do sistema e configurar física realista (gravidade, fricção).",
                                    "Calibrar sensores virtuais (câmeras para visão computacional, encoders para robótica).",
                                    "Testar configuração inicial com simulação simples para verificar estabilidade."
                                  ],
                                  "verification": "Modelo carrega sem erros e simulação básica executa por 30 segundos sem crashes.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Computador com GPU dedicada",
                                    "Software de simulação instalado",
                                    "Arquivos modelo 3D (STL/URDF)",
                                    "Documentação do software"
                                  ],
                                  "tips": "Use templates prontos para acelerar a configuração e priorize unidades SI consistentes.",
                                  "learningObjective": "Configurar um ambiente de simulação realista e funcional para sistemas mecatrônicos.",
                                  "commonMistakes": [
                                    "Escala incorreta do modelo 3D",
                                    "Falta de calibração de sensores",
                                    "Ignorar limitações computacionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Execução da Simulação Computacional",
                                  "subSteps": [
                                    "Definir cenários de teste (nominal, extremos, falhas).",
                                    "Executar scripts de controle (ex: ROS nodes para robótica).",
                                    "Registrar dados de saída (posições, velocidades, imagens de visão computacional).",
                                    "Monitorar em tempo real métricas como CPU/GPU usage e latência.",
                                    "Repetir simulações variando parâmetros para análise estatística."
                                  ],
                                  "verification": "Pelo menos 10 iterações completas com logs salvos e gráficos gerados.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Scripts de controle em Python/ROS",
                                    "Ferramentas de logging (ROS bags, CSV export)",
                                    "Monitor de performance (htop, NVIDIA-SMI)"
                                  ],
                                  "tips": "Automatize execuções com batch scripts para eficiência e salve seeds aleatórias para reprodutibilidade.",
                                  "learningObjective": "Executar simulações controladas coletando dados relevantes para validação.",
                                  "commonMistakes": [
                                    "Não registrar todos os dados de entrada/saída",
                                    "Sobrecarregar o hardware sem otimização",
                                    "Ignorar condições de falha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realização de Testes em Ambiente Controlado Físico",
                                  "subSteps": [
                                    "Preparar bancada física replicando o modelo simulado (robô ou setup de visão).",
                                    "Executar os mesmos cenários dos testes simulados no hardware real.",
                                    "Coletar dados físicos com sensores reais (IMU, câmeras).",
                                    "Controlar variáveis ambientais (iluminação, temperatura).",
                                    "Comparar dados em tempo real com simulação via dashboard."
                                  ],
                                  "verification": "Testes físicos completos com dados coletados e sincronizados com simulação.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Bancada mecatrônica (robô, sensores)",
                                    "Câmeras e processadores embarcados",
                                    "Software de aquisição de dados (LabVIEW, Arduino IDE)"
                                  ],
                                  "tips": "Use safety interlocks e comece com velocidades baixas para evitar danos.",
                                  "learningObjective": "Integrar testes físicos controlados para validar simulações.",
                                  "commonMistakes": [
                                    "Desalinhamento entre simulação e hardware",
                                    "Falta de controle ambiental",
                                    "Expor hardware a cenários não testados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise de Resultados e Validação Final",
                                  "subSteps": [
                                    "Processar dados de simulação e testes físicos (gráficos, estatísticas).",
                                    "Calcular métricas de erro (RMSE, precisão de detecção em visão).",
                                    "Identificar discrepâncias e causas (modelagem, calibração).",
                                    "Iterar ajustes no modelo/simulação se erro > 5%.",
                                    "Gerar relatório com conclusões de validação."
                                  ],
                                  "verification": "Relatório gerado com métricas abaixo de thresholds definidos e validação aprovada.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Ferramentas de análise (MATLAB, Python Pandas/Matplotlib)",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use métricas quantitativas prioritárias e visualize dados para insights rápidos.",
                                  "learningObjective": "Analisar discrepâncias e validar o sistema mecatrônico como pronto para deployment.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente métricas",
                                    "Não quantificar erros",
                                    "Pular iterações necessárias"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentação e Iteração para Melhoria",
                                  "subSteps": [
                                    "Documentar setup, resultados e lições aprendidas.",
                                    "Compartilhar repositório com códigos e dados.",
                                    "Planejar iterações baseadas em falhas identificadas.",
                                    "Validar com stakeholder ou peer review.",
                                    "Arquivar para reutilização futura."
                                  ],
                                  "verification": "Documentação completa e aprovada por revisão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "GitHub ou similar",
                                    "Templates de documentação técnica"
                                  ],
                                  "tips": "Mantenha versionamento rigoroso para rastreabilidade.",
                                  "learningObjective": "Garantir reprodutibilidade e melhoria contínua através de documentação.",
                                  "commonMistakes": [
                                    "Documentação incompleta",
                                    "Não versionar mudanças",
                                    "Ignorar feedback"
                                  ]
                                }
                              ],
                              "practicalExample": "Simular um braço robótico manipulando objetos em Gazebo com visão computacional via OpenCV para detecção, executar testes físicos na bancada medindo precisão de grip e validar erro < 2cm em 50 trials.",
                              "finalVerifications": [
                                "Simulações executam sem crashes em múltiplos cenários.",
                                "Dados físicos e simulados divergem < 5% em métricas chave.",
                                "Sistema valida requisitos funcionais (ex: precisão robótica >95%).",
                                "Relatório documenta todas discrepâncias resolvidas.",
                                "Testes reprodutíveis em setup idêntico.",
                                "Integração com visão computacional processa frames em <100ms."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da configuração de simulação (30%).",
                                "Qualidade dos dados coletados e analisados (25%).",
                                "Eficiência temporal e uso de recursos (20%).",
                                "Correção de erros e iterações (15%).",
                                "Clareza da documentação e relatórios (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de scripts ROS/Python para controle.",
                                "Matemática: Modelagem cinemática/dinâmica e análise estatística.",
                                "Física: Simulação de forças, colisões e dinâmica.",
                                "Eletrônica: Integração de sensores e atuadores reais.",
                                "Informática: Processamento de imagens em visão computacional."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, validar algoritmos de controle de drones autônomos via simulações em X-Plane e testes em túnel de vento, reduzindo custos de protótipos físicos em 70%."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.3"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Documentação e Relatório Final",
                            "description": "Elaborar relatórios de validação, incluindo resultados de testes e recomendações para produção, alinhados a metodologias de engenharia de design.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Estrutura e Revisar Requisitos do Relatório",
                                  "subSteps": [
                                    "Revisar os requisitos do projeto mecatrônico e critérios de validação definidos na fase inicial.",
                                    "Definir a estrutura padrão do relatório: capa, sumário, introdução, metodologia, resultados, análise, recomendações e anexos.",
                                    "Alinhar a estrutura às metodologias de engenharia de design, como o modelo V ou normas ISO 15288.",
                                    "Criar um outline detalhado com seções e subseções específicas.",
                                    "Identificar dados necessários de testes prévios e fontes de informação."
                                  ],
                                  "verification": "Outline completo aprovado por checklist interna, com todas as seções mapeadas aos requisitos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Templates de relatório padrão",
                                    "Documentos de requisitos do projeto",
                                    "Normas de engenharia (ISO, ABNT)"
                                  ],
                                  "tips": "Use ferramentas como Microsoft Word ou LaTeX para outlines profissionais; priorize clareza visual.",
                                  "learningObjective": "Entender e aplicar estruturas padronizadas de relatórios técnicos em engenharia.",
                                  "commonMistakes": [
                                    "Ignorar normas específicas do setor",
                                    "Criar outline genérico sem alinhamento ao projeto",
                                    "Subestimar tempo para revisão de requisitos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Organizar Resultados de Testes",
                                  "subSteps": [
                                    "Compilar todos os dados brutos de testes: tabelas, gráficos, logs de sensores e métricas de desempenho.",
                                    "Categorizar resultados por tipo de teste (funcional, desempenho, confiabilidade).",
                                    "Processar dados quantitativos: calcular médias, desvios padrão e gerar visualizações (gráficos, histogramas).",
                                    "Documentar evidências qualitativas: observações, fotos e vídeos de falhas ou sucessos.",
                                    "Garantir rastreabilidade: vincular cada resultado ao requisito validado."
                                  ],
                                  "verification": "Banco de dados ou planilha organizada com 100% dos testes cobertos e visualizações geradas.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Planilhas Excel/Google Sheets",
                                    "Softwares de análise (MATLAB, Python com Pandas/Matplotlib)",
                                    "Logs de testes e dados sensoriais"
                                  ],
                                  "tips": "Automatize gráficos com scripts para eficiência; use cores padronizadas para pass/fail.",
                                  "learningObjective": "Dominar a organização e visualização de dados experimentais para relatórios técnicos.",
                                  "commonMistakes": [
                                    "Dados incompletos ou não categorizados",
                                    "Visualizações ilegíveis ou sem legendas",
                                    "Falta de rastreabilidade aos requisitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Análise e Formular Recomendações",
                                  "subSteps": [
                                    "Analisar resultados contra critérios de aceitação: identificar conformidades e não-conformidades.",
                                    "Realizar análise de causa raiz para falhas usando ferramentas como 5 Whys ou Ishikawa.",
                                    "Priorizar recomendações: categorizar por impacto (crítico, médio, baixo) e custo de implementação.",
                                    "Redigir recomendações claras, com ações específicas, responsáveis e prazos para produção.",
                                    "Integrar lições aprendidas alinhadas a ciclos PDCA ou DMAIC."
                                  ],
                                  "verification": "Seção de análise completa com pelo menos 80% dos resultados analisados e recomendações priorizadas.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": [
                                    "Ferramentas de análise (Minitab, Fishbone diagrams)",
                                    "Matriz de priorização (Eisenhower)",
                                    "Templates de recomendação"
                                  ],
                                  "tips": "Seja específico nas recomendações: 'Ajustar ganho PID de 1.5 para 1.2' em vez de genéricas.",
                                  "learningObjective": "Desenvolver habilidades analíticas para extrair insights acionáveis de dados de validação.",
                                  "commonMistakes": [
                                    "Análises superficiais sem causa raiz",
                                    "Recomendações vagas ou não priorizadas",
                                    "Omitir lições aprendidas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Redigir, Revisar e Finalizar o Relatório",
                                  "subSteps": [
                                    "Escrever seções narrativas: introdução contextual, metodologia resumida e conclusões.",
                                    "Integrar resultados, análises e recomendações no documento principal.",
                                    "Realizar revisão técnica: checar precisão, consistência e conformidade com normas.",
                                    "Aplicar formatação profissional: numeração, referências, glossário e assinatura.",
                                    "Gerar versão final em PDF e arquivar com controle de versão."
                                  ],
                                  "verification": "Relatório revisado por pares, sem erros detectados em checklist de qualidade.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software de edição (Word, LaTeX)",
                                    "Checklist de revisão",
                                    "Ferramentas de controle de versão (Git, SharePoint)"
                                  ],
                                  "tips": "Peça revisão de colega para viés; use sumário executivo para resumo impactante.",
                                  "learningObjective": "Produzir relatórios profissionais completos e prontos para produção.",
                                  "commonMistakes": [
                                    "Erros gramaticais ou de formatação",
                                    "Falta de resumo executivo",
                                    "Não versionar o documento"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um braço robótico mecatrônico validado: Colete dados de precisão de posicionamento (erro médio 0.5mm), analise falhas em atuadores (causa: vibração excessiva), recomende reforço estrutural e teste adicional; relatório final de 20 páginas com gráficos e plano de produção.",
                              "finalVerifications": [
                                "Todos os resultados de testes estão documentados e visualizados.",
                                "Recomendações são acionáveis, priorizadas e alinhadas a produção.",
                                "Relatório segue estrutura padrão e normas de engenharia.",
                                "Rastreabilidade completa aos requisitos do projeto.",
                                "Versão final aprovada por revisor técnico.",
                                "Anexos incluem dados brutos e evidências."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na redação técnica (nota 1-10).",
                                "Qualidade das visualizações e análise de dados.",
                                "Relevância e viabilidade das recomendações.",
                                "Conformidade com metodologias de design (ex: cobertura de ciclos de vida).",
                                "Completude e organização geral do documento.",
                                "Profissionalismo na formatação e referências."
                              ],
                              "crossCurricularConnections": [
                                "Comunicação Técnica: Redação clara e visualizações eficazes.",
                                "Gestão de Projetos: Integração de lições aprendidas e planejamento de ações.",
                                "Estatística e Análise de Dados: Processamento quantitativo de resultados.",
                                "Engenharia de Software: Rastreabilidade similar a requisitos em devops.",
                                "Sustentabilidade: Recomendações considerando ciclo de vida ambiental."
                              ],
                              "realWorldApplication": "Em indústrias como automotiva (ex: validação de linhas robóticas na Bosch) ou aeroespacial (relatórios de certificação FAA), onde relatórios finais garantem aprovação para produção em massa, reduzindo riscos e custos de retrabalho."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 267
          }
        ],
        "totalSkills": 267,
        "percentage": 0
      }
    ]
  }
}