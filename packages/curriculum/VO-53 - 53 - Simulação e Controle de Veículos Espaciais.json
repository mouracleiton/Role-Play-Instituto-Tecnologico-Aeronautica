{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T12:27:28.586Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - VO-53",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 176,
      "startDate": "2025-02-01",
      "duration": "5 years",
      "dailyStudyHours": 6,
      "version": "VO-53",
      "institution": "Instituto Tecnológico de Aeronáutica (ITA)",
      "basedOn": "Catálogo dos Cursos de Graduação 2025 - VO-53"
    },
    "areas": [
      {
        "id": "10",
        "name": "Aeroespacial",
        "description": "Disciplinas relacionadas à simulação, dinâmica e controle de veículos espaciais.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Simulação e Controle de Veículos Espaciais",
            "description": "Determinação de atitude a partir de medidas de sensores: sensores terrestres infravermelho; sensores solares; sensor de estrelas; sensores inerciais. Dinâmica e controle de atitude: sistemas propulsivos; torque de pressão solar; atuadores de troca de momentos (rodas de reação; roda de reação com gimbal); torque magnético. Simulação de veículos espaciais: controle para a estabilização de atitude e para a realização de manobras de atitude. Bibliografia: SIDI, M. Spacecraft dynamics and control: a practical engineering approach. Cambridge: University Press, 2006. WIESEL, W. E. Spaceflight dynamics. 3. ed. Beavercreek, OH: Aphelion Press, 2010. WERTZ, J. R. (ed.). Spacecraft attitude determination and control. Dordrecht: Kluwer Academic, 1978.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Determinação de Atitude a partir de Sensores",
                "description": "Estudo da determinação de atitude utilizando sensores terrestres infravermelho, sensores solares, sensor de estrelas e sensores inerciais.",
                "totalSkills": 37,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Sensores Terrestres Infravermelho",
                    "description": "Princípios e métodos para determinação de atitude de veículos espaciais utilizando sensores que detectam a Terra no infravermelho.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Princípios Físicos da Detecção Infravermelha da Terra",
                        "description": "Fundamentos da radiação infravermelha emitida pela Terra e sua detecção para determinação de atitude em veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Explicar a emissão térmica da Terra no infravermelho",
                            "description": "Descrever como a Terra atua como uma fonte de radiação infravermelha devido à sua temperatura superficial, formando um 'disco quente' contra o fundo frio do espaço, e calcular a intensidade usando a lei de Planck.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Radiação Térmica e a Lei de Planck",
                                  "subSteps": [
                                    "Estudar a formulação da lei de Planck para a densidade espectral de radiação de um corpo negro: B(λ, T) = (2hc²/λ⁵) / (e^(hc/λkT) - 1).",
                                    "Explicar o conceito de corpo negro ideal como um absorvedor/emissor perfeito de radiação.",
                                    "Analisar como a temperatura T determina o espectro de emissão, com maior intensidade em comprimentos de onda mais longos para T baixa.",
                                    "Relacionar com a lei de Wien: λ_max * T = 2898 μm·K, para prever o pico de emissão.",
                                    "Discutir a transição do regime clássico (Rayleigh-Jeans) para quântico em infravermelho."
                                  ],
                                  "verification": "Derivar qualitativamente o espectro de Planck para T=288K e identificar o regime IR.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Fórmula da lei de Planck impressa",
                                    "Calculadora científica",
                                    "Gráficos de espectro de corpo negro online (ex: Wolfram Alpha)"
                                  ],
                                  "tips": "Use plotters online para visualizar curvas de Planck em diferentes T e foque no tail IR.",
                                  "learningObjective": "Dominar a lei de Planck como base para emissão térmica de objetos aquecidos.",
                                  "commonMistakes": [
                                    "Confundir lei de Planck (espectral) com Stefan-Boltzmann (total), ignorar o fator quântico e^(hc/λkT)-1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Caracterizar a Emissão Térmica Superficial da Terra",
                                  "subSteps": [
                                    "Identificar a temperatura superficial média da Terra: aproximadamente 288K (15°C).",
                                    "Calcular o comprimento de onda de pico usando lei de Wien: λ_max ≈ 10 μm (infravermelho térmico).",
                                    "Explicar que a Terra emite principalmente no IR devido à baixa T comparada ao Sol (pico ~0.5 μm).",
                                    "Discutir albedo e absorção solar levando ao equilíbrio térmico.",
                                    "Comparar com fundo cósmico de micro-ondas (T~2.7K), muito frio e fraco em IR."
                                  ],
                                  "verification": "Calcular λ_max para 288K e confirmar que cai na banda IR (8-14 μm).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de constantes físicas (h, c, k, Wien constant)",
                                    "Planilha Excel para cálculos"
                                  ],
                                  "tips": "Lembre-se: Terra é corpo negro aproximado (ε≈0.9-1.0 no IR devido a H2O e CO2).",
                                  "learningObjective": "Relacionar temperatura da Terra ao seu espectro de emissão IR dominante.",
                                  "commonMistakes": [
                                    "Usar T atmosférica efetiva errada (~255K) em vez de superficial (288K), ignorar variação latitudinal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Visualizar a Terra como 'Disco Quente' contra Fundo Frio do Espaço",
                                  "subSteps": [
                                    "Descrever perspectiva orbital: Terra aparece como disco angular (~0.5° de um satélite LEO).",
                                    "Explicar contraste: emissão IR da Terra >> fundo espacial (estrelas/nebulae frias, CMB).",
                                    "Discutir geometria: intensidade cai com cosθ (lei de Lambert para superfícies difusas).",
                                    "Simular visualmente com modelo 2D: disco emissor vs fundo negro.",
                                    "Analisar ruído: fundo cósmico negligible em IR térmico."
                                  ],
                                  "verification": "Esboçar diagrama da Terra como disco IR visto de satélite, anotando contrastes térmicos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel e lápis para diagrama",
                                    "Software de simulação como STK ou SkySafari para visualização orbital"
                                  ],
                                  "tips": "Pense em fotos IR de satélites como GOES: Terra brilha intensamente no canal IR.",
                                  "learningObjective": "Compreender a aparência observacional da Terra em sensores IR espaciais.",
                                  "commonMistakes": [
                                    "Subestimar tamanho angular da Terra, confundir com disco solar (muito menor de LEO)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a Intensidade da Radiação Infravermelha da Terra",
                                  "subSteps": [
                                    "Aplicar lei de Planck para calcular B(λ=10μm, T=288K).",
                                    "Usar valores: h=6.626e-34 Js, c=3e8 m/s, k=1.381e-23 J/K.",
                                    "Calcular radiance em W/m²/sr/μm e converter para unidades de sensor (ex: mW/cm²/sr).",
                                    "Comparar com fundo: B(10μm, 3K) ≈ 0.",
                                    "Estimar sinal/ruído para detecção: S/N >>1 devido ao contraste."
                                  ],
                                  "verification": "Realizar cálculo numérico e obter B≈1.3e7 W/m²/sr/μm a 10μm, 288K.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB script para Planck",
                                    "Tabelas de radiance IR pré-calculadas"
                                  ],
                                  "tips": "Aproxime e^(hc/λkT) >>1 para λ<<λ_max, simplificando fórmula.",
                                  "learningObjective": "Executar cálculos quantitativos de emissão IR terrestre.",
                                  "commonMistakes": [
                                    "Erros em unidades (μm vs m), overflow numérico no expoente sem log"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python, plote o espectro de Planck para Terra (288K) e fundo (3K) em 8-14μm. Calcule o sinal médio de um pixel de sensor apontando para o limbo terrestre: contraste >1000:1 permite detecção robusta de atitude.",
                              "finalVerifications": [
                                "Explica corretamente a origem quântica da emissão IR via Planck.",
                                "Calcula λ_max=10μm para T=288K com erro <5%.",
                                "Descreve o 'disco quente' com contraste vs fundo frio.",
                                "Computa B(10μm,288K) com valor aproximado correto (~10^7 W/m²/sr/μm).",
                                "Identifica aplicações em sensores de atitude IR.",
                                "Discute limitações como nuvens variáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção corpo negro vs real (90% match).",
                                "Cálculos corretos: erro <10% em λ_max e B(λ,T).",
                                "Visualização: diagrama claro do disco IR.",
                                "Integração: liga emissão a detecção espacial.",
                                "Profundidade: menciona Wien/Lambert espontaneamente.",
                                "Clareza: explica sem jargão excessivo."
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: derivação da lei de Planck por Planck (1900).",
                                "Astronomia: detecção térmica de exoplanetas via IR (JWST).",
                                "Engenharia Aeroespacial: design de sensores IR para ADCS (Attitude Determination).",
                                "Ciência do Clima: balanço radiativo Terra-energia (modelos GCM).",
                                "Óptica: propriedades emissivas de atmosferas (janela IR 8-12μm)."
                              ],
                              "realWorldApplication": "Em satélites como CubeSats ou ISS, sensores IR terrestres (Earth Horizon Sensors) detectam o limbo IR da Terra como disco quente para estimar roll/pitch com precisão <0.1°, essencial para controle de atitude sem GPS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Identificar bandas espectrais relevantes para sensores IR",
                            "description": "Diferenciar as bandas infravermelhas médias (3-5 μm) e térmicas (8-12 μm) usadas em sensores terrestres, explicando a influência da atmosfera terrestre e nuvens na detecção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos das Bandas Espectrais Infravermelhas",
                                  "subSteps": [
                                    "Estude o espectro eletromagnético, focando na região infravermelha (0.7-1000 μm).",
                                    "Identifique as subdivisões principais: próximo-IR (NIR, 0.7-1.4 μm), médio-IR (MWIR, 3-5 μm) e longo-IR (LWIR, 8-14 μm).",
                                    "Aprenda sobre emissão térmica de corpos negros usando a lei de Planck e Wien.",
                                    "Revise exemplos de fontes terrestres como solo, vegetação e oceanos em IR.",
                                    "Anote as faixas relevantes para sensores: MWIR (3-5 μm) para reflexão/emissão e LWIR (8-12 μm) para emissão térmica."
                                  ],
                                  "verification": "Resuma em um diagrama as faixas IR principais e suas características térmicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráfico do espectro eletromagnético",
                                    "Lei de Planck explicada (Khan Academy ou similar)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use curvas de corpo negro para visualizar picos de emissão em diferentes temperaturas terrestres (~300K).",
                                  "learningObjective": "Dominar as divisões básicas do espectro IR e sua relevância para detecção terrestre.",
                                  "commonMistakes": "Confundir IR com visível; ignorar que MWIR é menos afetada por vapor d'água que LWIR."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Bandas MWIR (3-5 μm) e LWIR (8-12 μm) em Sensores Terrestres",
                                  "subSteps": [
                                    "Analise MWIR: alta refletância de superfícies terrestres, usada para detecção de alvos quentes/resfriados.",
                                    "Analise LWIR: pico de emissão térmica da Terra (8-12 μm, janela atmosférica), ideal para imagens térmicas.",
                                    "Compare resoluções: MWIR para contraste diurno/noite, LWIR para temperatura absoluta.",
                                    "Estude detectores: HgCdTe para MWIR, microbolômetros para LWIR.",
                                    "Crie uma tabela comparativa de aplicações em sensores de atitude espaciais."
                                  ],
                                  "verification": "Preencha uma tabela comparando MWIR vs LWIR com exemplos de uso em satélites.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabela comparativa de bandas IR",
                                    "Imagens de satélites como MODIS",
                                    "Software gratuito como SpectraViewer"
                                  ],
                                  "tips": "Lembre-se: 8-12 μm é a 'janela' LWIR onde a atmosfera é mais transparente.",
                                  "learningObjective": "Distinguir precisamente as características e usos de MWIR e LWIR em contextos aeroespaciais.",
                                  "commonMistakes": "Trocar faixas: MWIR não é puramente térmica como LWIR."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Influência da Atmosfera Terrestre na Detecção IR",
                                  "subSteps": [
                                    "Estude absorção por gases: CO2 (4.3 μm em MWIR), vapor d'água (forte em LWIR >12 μm).",
                                    "Identifique janelas atmosféricas: 3-5 μm e 8-12 μm com baixa atenuação.",
                                    "Modele transmissão atmosférica usando ferramentas como MODTRAN (simulador gratuito).",
                                    "Discuta ângulo zenital: maior caminho atmosférico aumenta absorção.",
                                    "Calcule atenuação qualitativa para cenários de baixa/alta umidade."
                                  ],
                                  "verification": "Gere um gráfico simples de transmissão atmosférica nas faixas 3-5 μm e 8-12 μm.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Gráficos de transmissão atmosférica (HITRAN database)",
                                    "Ferramenta MODTRAN online",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Foque em picos de absorção: evite 6-7 μm por ozônio e vapor.",
                                  "learningObjective": "Explicar como a atmosfera filtra bandas IR e afeta sensores espaciais.",
                                  "commonMistakes": "Subestimar variação com altitude ou umidade; assumir atmosfera uniforme."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o Impacto de Nuvens e Condições Adversas",
                                  "subSteps": [
                                    "Aprenda opacidade de nuvens: bloqueiam IR em ambas faixas, mas LWIR mais afetada por espessura.",
                                    "Diferencie nuvens cirrus (semi-transparentes em MWIR) vs cumulonimbus (opacas).",
                                    "Estude detecção de nuvens via canais IR: contraste térmico.",
                                    "Simule cenários: detecção terrestre clara vs obstruída por nuvens.",
                                    "Desenvolva critérios para seleção de banda baseada em cobertura nubosa."
                                  ],
                                  "verification": "Descreva em parágrafos como nuvens impactam cada banda e proponha mitigações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Imagens GOES/Meteosat IR",
                                    "Relatórios NASA sobre sensores IR",
                                    "Vídeos de simulação atmosférica"
                                  ],
                                  "tips": "Nuvens frias aparecem escuras em LWIR; use multi-banda para mascaramento.",
                                  "learningObjective": "Integrar efeitos de nuvens na escolha de bandas para sensores de atitude.",
                                  "commonMistakes": "Ignorar que nuvens emitem IR próprio, mascarando superfície."
                                }
                              ],
                              "practicalExample": "Em um satélite de observação terrestre como o Landsat, use sensores MWIR (banda 7, 2.1-2.3 μm estendida) para mapear vegetação seca durante o dia, alternando para LWIR (banda 10/11, 10.6-12.5 μm) à noite para medir temperaturas de superfície, ajustando por transmissão atmosférica via modelos e mascarando pixels nubosos via threshold de brilho.",
                              "finalVerifications": [
                                "Nomeie corretamente as faixas MWIR (3-5 μm) e LWIR (8-12 μm) e suas aplicações primárias.",
                                "Explique pelo menos dois gases atmosféricos que afetam cada banda.",
                                "Identifique quando nuvens cirrus permitem detecção em MWIR mas não em LWIR.",
                                "Crie um diagrama de transmissão atmosférica destacando janelas IR.",
                                "Avalie um cenário hipotético: 'Por que usar LWIR para determinação de atitude noturna?'",
                                "Diferencie emissão vs reflexão em cada banda com exemplos terrestres."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de faixas espectrais (100% correto).",
                                "Profundidade na explicação de efeitos atmosféricos (cita gases e janelas).",
                                "Capacidade de diferenciar impactos de nuvens por tipo e banda.",
                                "Uso correto de terminologia (ex: 'janela atmosférica', 'emissão térmica').",
                                "Integração prática em contextos de sensores espaciais.",
                                "Criatividade em exemplos e verificações personalizadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de radiação térmica (Planck, Stefan-Boltzmann).",
                                "Meteorologia: Modelos de transmissão atmosférica e detecção de nuvens.",
                                "Engenharia Óptica: Design de filtros e detectores IR.",
                                "Ciência da Terra: Monitoramento ambiental via sensoriamento remoto.",
                                "Matemática: Modelagem espectral e cálculos de atenuação."
                              ],
                              "realWorldApplication": "Em missões espaciais como o James Webb Space Telescope (JWST) ou satélites GOES para previsão do tempo, identificar bandas IR corretas permite determinação precisa de atitude via bordas terrestres térmicas, monitoramento de furacões por contraste nuboso e detecção de incêndios florestais, otimizando filtros para minimizar interferência atmosférica e garantir imagens claras mesmo sob cobertura parcial de nuvens."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Analisar o perfil de brilho da Terra",
                            "description": "Interpretar o perfil angular de intensidade IR da Terra visto de órbita, incluindo o efeito de limb darkening e o cálculo do ângulo de horizonte.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Básicos do Limb Darkening na Terra",
                                  "subSteps": [
                                    "Estude a emissão de radiação infravermelha (IR) pela atmosfera e superfície terrestre.",
                                    "Explique o fenômeno de limb darkening: intensidade diminui em direção à borda devido ao caminho óptico mais longo na atmosfera.",
                                    "Compare com o Sol: similaridades e diferenças em escalas planetárias.",
                                    "Identifique fatores como temperatura superficial, nuvens e absorção atmosférica.",
                                    "Revise leis de Planck e Stefan-Boltzmann aplicadas à Terra."
                                  ],
                                  "verification": "Desenhe um diagrama simples do perfil de brilho mostrando o pico central e decaimento nas bordas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de física atmosférica",
                                    "Vídeos sobre limb darkening (YouTube/Khan Academy)",
                                    "Gráficos de perfis IR da Terra (NASA resources)"
                                  ],
                                  "tips": "Visualize a Terra como uma esfera iluminada uniformemente, mas observe o escurecimento nas bordas em fotos de satélite.",
                                  "learningObjective": "Explicar qualitativamente o limb darkening e sua origem física na detecção IR orbital.",
                                  "commonMistakes": [
                                    "Confundir limb darkening com sombra noturna",
                                    "Ignorar o papel da atmosfera espessa da Terra vs. estrelas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Perfil Angular de Intensidade IR",
                                  "subSteps": [
                                    "Defina coordenadas angulares: zenith angle θ do nadir ao horizonte.",
                                    "Aprenda a função de intensidade I(θ) ≈ I(0) * cos^n(θ), onde n ≈ 2-4 para IR terrestre.",
                                    "Colete dados reais de satélites como o DSCOVR/EPIC para validar o modelo.",
                                    "Plote o perfil usando Python/MATLAB: intensidade vs. ângulo.",
                                    "Ajuste parâmetros para simular diferentes condições (dia/noite, latitude)."
                                  ],
                                  "verification": "Gere e plote um gráfico de I(θ) que corresponda a dados observados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com Matplotlib/NumPy",
                                    "Dados IR da NASA Earthdata",
                                    "Tutorial de plotting científico"
                                  ],
                                  "tips": "Comece com n=2 para simplicidade; aumente para melhor ajuste em IR.",
                                  "learningObjective": "Construir e plotar um modelo matemático do perfil de brilho IR angular.",
                                  "commonMistakes": [
                                    "Usar cos(θ) linear em vez de potência",
                                    "Esquecer normalização em I(0)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Ângulo de Horizonte",
                                  "subSteps": [
                                    "Defina o ângulo de horizonte como θ_h onde I(θ_h) cai para um limiar (ex: 10% de I(0)).",
                                    "Derive fórmula: θ_h = arccos((limiar/I(0))^(1/n)).",
                                    "Implemente cálculo numérico para perfis reais com ruído.",
                                    "Considere efeitos geométricos: raio da Terra e altitude orbital.",
                                    "Valide com simulações: compare θ_h calculado vs. esperado (~90° ajustado)."
                                  ],
                                  "verification": "Calcule θ_h para um perfil dado e compare erro <5% com valor teórico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora científica ou script Python",
                                    "Dados de sensores IR simulados",
                                    "Fórmulas de geometria orbital"
                                  ],
                                  "tips": "Use iterações numéricas para perfis não-ideais; teste com diferentes limiares.",
                                  "learningObjective": "Executar cálculos precisos do ângulo de horizonte a partir de dados de intensidade.",
                                  "commonMistakes": [
                                    "Confundir θ_h com 90° fixo",
                                    "Ignorar altitude orbital no modelo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Perfis de Brilho em Contextos Reais",
                                  "subSteps": [
                                    "Analise um perfil IR real: identifique nadir, bordas e anomalias (nuvens, oceanos).",
                                    "Integre com dados de atitude: use perfil para estimar roll/pitch do satélite.",
                                    "Simule erros: adicione ruído e reinterprete.",
                                    "Compare perfis diurnos vs. noturnos (IR térmico dominante à noite).",
                                    "Documente interpretação em relatório curto."
                                  ],
                                  "verification": "Escreva uma análise de 200 palavras explicando um perfil fornecido.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados reais de satélites (ex: GOES/IR)",
                                    "Software de análise (Python/Jupyter)",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Procure assimetrias no perfil para detectar off-nadir views.",
                                  "learningObjective": "Interpretar perfis IR para aplicações em determinação de atitude espacial.",
                                  "commonMistakes": [
                                    "Sobrestimar brilho uniforme",
                                    "Não considerar contaminação por Lua/Sol"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados IR do satélite DSCOVR, plote o perfil angular durante uma órbita geoestacionária. Identifique o nadir (pico ~1000 W/m²/sr), decaimento para θ=80° (~200 W/m²/sr), calcule θ_h=85° e interprete uma assimetria como roll de 2° do satélite.",
                              "finalVerifications": [
                                "Explicar limb darkening em termos de óptica atmosférica.",
                                "Plotar corretamente I(θ) para dados simulados.",
                                "Calcular θ_h com erro <3%.",
                                "Identificar anomalias em perfis reais.",
                                "Relacionar perfil a determinação de atitude.",
                                "Discutir limitações em condições nubladas."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo matemático (equação e parâmetros corretos).",
                                "Qualidade dos plots e visualizações (rótulos, escalas adequadas).",
                                "Exatidão nos cálculos de θ_h (validação com dados).",
                                "Profundidade da interpretação (considera contexto orbital).",
                                "Clareza na documentação e explicações.",
                                "Criatividade em lidar com dados reais/ruídos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Radiação térmica e óptica atmosférica.",
                                "Matemática: Funções trigonométricas e ajuste de curvas.",
                                "Programação: Análise de dados com Python/NumPy.",
                                "Astronomia: Observações planetárias e detecção de exoplanetas.",
                                "Engenharia Aeroespacial: Sensores em satélites."
                              ],
                              "realWorldApplication": "Em satélites como o ISS ou CubeSats, essa análise permite determinação autônoma de atitude usando sensores IR baratos, essencial para controle de orientação sem GPS, missões de imageamento Earth-observation e navegação em deep space."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Arquitetura e Funcionamento dos Sensores Terrestres IR",
                        "description": "Componentes, operação e configuração típica de sensores de horizonte infravermelho para determinação de atitude.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Descrever o design de sensores de varredura IR",
                            "description": "Explicar o funcionamento de sensores de varredura rotativa ou cônica, incluindo detectores de estado sólido (PbSe ou InSb) e óptica de campo de visão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios básicos da detecção infravermelha em sensores de varredura",
                                  "subSteps": [
                                    "Estudar a radiação infravermelha (IR) e suas faixas espectrais relevantes para sensores terrestres (meio-IR e longo-IR).",
                                    "Explicar como sensores IR detectam radiação térmica de estrelas ou alvos terrestres convertendo fótons em sinal elétrico.",
                                    "Identificar componentes principais: detector, óptica, mecanismo de varredura e eletrônica de processamento.",
                                    "Analisar o papel da varredura para cobrir um campo de visão amplo com um detector estreito.",
                                    "Revisar diferenças entre sensores passivos e ativos no contexto aeroespacial."
                                  ],
                                  "verification": "Desenhar um diagrama esquemático básico de um sensor IR de varredura e rotulá-lo corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de óptica infravermelha (ex: 'Infrared Detectors' de Dereniak), artigos da NASA sobre sensores estelares, software de desenho como Draw.io"
                                  ],
                                  "tips": "Comece com analogias simples, como uma câmera térmica comum, para visualizar o conceito.",
                                  "learningObjective": "Entender os fundamentos físicos da detecção IR e a necessidade de varredura em aplicações espaciais.",
                                  "commonMistakes": "Confundir IR com visível; ignorar que sensores IR detectam calor, não luz visível."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar mecanismos de varredura rotativa e cônica",
                                  "subSteps": [
                                    "Descrever varredura rotativa: rotação mecânica de um espelho ou prisma para escanear linearmente.",
                                    "Explicar varredura cônica: rotação do sensor inteiro ou uso de óptica cônica para campo de visão em cone.",
                                    "Comparar velocidades, precisão e artefatos (ex: distorção em varredura cônica).",
                                    "Calcular taxa de varredura básica: ângulo/segundo baseado em rotação (ex: 6 rpm para 60 graus/seg).",
                                    "Simular geometricamente o padrão de varredura em um software simples."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito as diferenças entre varredura rotativa e cônica, com um cálculo de exemplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Vídeos tutoriais sobre sensores de estrela IR (YouTube/NASA), simulador GeoGebra para padrões cônicos, calculadora científica"
                                  ],
                                  "tips": "Use animações 3D para visualizar o movimento; foque em como a varredura expande o FOV efetivo.",
                                  "learningObjective": "Dominar os tipos de varredura e seu impacto na cobertura angular.",
                                  "commonMistakes": "Confundir rotação do detector com rotação do espelho; subestimar vibrações em ambientes espaciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar detectores de estado sólido PbSe e InSb",
                                  "subSteps": [
                                    "Estudar PbSe (sulfeto de chumbo): características (faixa 1-5 µm, resfriamento termelétrico, fotoconductivo).",
                                    "Descrever InSb (antimoniato de índio): faixa 1-5.5 µm, resfriamento criogênico, maior sensibilidade mas mais frágil.",
                                    "Comparar responsividade, tempo de resposta, ruído e requisitos de refrigeração.",
                                    "Explicar conversão de fótons IR em elétrons via efeito fotoelétrico em semicondutores.",
                                    "Revisar exemplos de uso em sensores espaciais (ex: InSb em telescópios IR)."
                                  ],
                                  "verification": "Criar uma tabela comparativa PbSe vs InSb com pelo menos 5 parâmetros chave.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Datasheets de detectores (Hamamatsu ou Vigilant Systems), tabela periódica para composição química, planilha Excel"
                                  ],
                                  "tips": "Memorize faixas espectrais com mnemônicos: PbSe para 'pouco além' de 5 µm.",
                                  "learningObjective": "Diferenciar detectores e suas aplicações em sensores de varredura IR.",
                                  "commonMistakes": "Ignorar requisitos de refrigeração; confundir tipos de detecção (fotovoltaico vs fotoconductivo)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar óptica de campo de visão (FOV) em sensores IR",
                                  "subSteps": [
                                    "Definir FOV: ângulo cônico ou retangular (tipicamente 0.5-2 graus para precisão estelar).",
                                    "Estudar lentes e espelhos IR (germanio, ZnSe) e coatings antirreflexo para IR.",
                                    "Calcular resolução espacial: FOV / número de pixels ou linhas de varredura.",
                                    "Analisar trade-offs: FOV amplo vs precisão; impacto de aberrações ópticas.",
                                    "Desenhar ray-tracing simples para varredura cônica."
                                  ],
                                  "verification": "Calcular FOV efetivo para um exemplo dado e desenhar diagrama óptico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software óptico gratuito como OSLO LT, diagramas de óptica IR de artigos SPIE, régua e papel milimetrado"
                                  ],
                                  "tips": "Pense em FOV como 'olho' do sensor: estreito para precisão, amplo para busca.",
                                  "learningObjective": "Entender como óptica define e limita o campo de visão.",
                                  "commonMistakes": "Usar materiais ópticos visíveis em IR; ignorar atenuação atmosférica em simulações terrestres."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar componentes em descrição completa do design",
                                  "subSteps": [
                                    "Montar diagrama completo: óptica + varredura + detector + eletrônica.",
                                    "Escrever descrição passo a passo do sinal: radiação → óptica → varredura → detector → processamento.",
                                    "Simular fluxo de dados em um diagrama de blocos.",
                                    "Discutir calibração e compensação de fundo terrestre.",
                                    "Praticar descrição oral ou escrita de um sensor hipotético."
                                  ],
                                  "verification": "Produzir uma descrição escrita de 500 palavras com diagrama integrado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de diagramação (Lucidchart), exemplos de papers sobre sensores IR espaciais"
                                  ],
                                  "tips": "Estruture a descrição como uma história: entrada → processamento → saída.",
                                  "learningObjective": "Sintetizar todos os elementos em uma narrativa coesa do design.",
                                  "commonMistakes": "Omitir integração eletrônica; descrever isoladamente sem fluxo sistêmico."
                                }
                              ],
                              "practicalExample": "No satélite Hipparcos da ESA, um sensor IR de varredura rotativa usa detector PbSe resfriado, com espelho rotativo a 4 rpm e FOV cônico de 1 grau, escaneando o céu para determinar atitude via padrões estelares IR, compensando ruído terrestre.",
                              "finalVerifications": [
                                "Desenhar diagrama completo do sensor com todos componentes rotulados.",
                                "Explicar diferenças entre varredura rotativa e cônica com prós/contras.",
                                "Comparar PbSe e InSb em tabela com aplicações.",
                                "Calcular taxa de varredura para rotação de 10 rpm e FOV 2 graus.",
                                "Descrever fluxo de sinal do fóton IR ao dado de atitude.",
                                "Identificar 3 desafios em uso espacial (vibração, temperatura, ruído)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: uso correto de termos e princípios físicos (30%).",
                                "Completude: cobertura de todos componentes (varredura, detectores, óptica) (25%).",
                                "Clareza na descrição: linguagem acessível e lógica (20%).",
                                "Exemplos e cálculos: inclusão de aplicações reais e quantitativos (15%).",
                                "Diagramação: diagramas precisos e rotulados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: óptica geométrica e semicondutores.",
                                "Matemática: geometria cônica e cálculo de ângulos.",
                                "Engenharia: design mecatrônico e controle de motores.",
                                "Informática: simulação de sinais em Python/MATLAB."
                              ],
                              "realWorldApplication": "Esses sensores são usados em satélites para determinação autônoma de atitude, rastreando estrelas IR contra fundo terrestre, essencial para missões como James Webb Space Telescope ou navegação de sondas interplanetárias, garantindo orientação precisa sem GPS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Configurar arrays de sensores para cobertura completa",
                            "description": "Planejar a disposição de múltiplos sensores IR em uma constelação para determinar roll, pitch e yaw, considerando redundância e campo de visão total.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar Requisitos da Missão e Especificações dos Sensores",
                                  "subSteps": [
                                    "Identificar os requisitos de determinação de atitude: roll, pitch e yaw com precisão mínima.",
                                    "Listar especificações dos sensores IR: ângulo de campo de visão (FOV), resolução angular e taxa de amostragem.",
                                    "Definir necessidades de redundância: mínimo de 2 sensores por eixo para tolerância a falhas.",
                                    "Mapear o envelope operacional do veículo espacial, incluindo obstruções potenciais.",
                                    "Documentar restrições físicas: tamanho da plataforma, consumo de energia e peso."
                                  ],
                                  "verification": "Checklist completo de requisitos assinado e revisado, com todas as especificações dos sensores documentadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Fichas técnicas de sensores IR, documento de requisitos da missão, software de edição de texto (ex: Google Docs).",
                                  "tips": "Priorize FOV amplo (ex: 60-90°) para minimizar número de sensores.",
                                  "learningObjective": "Compreender como requisitos da missão ditam a configuração de sensores.",
                                  "commonMistakes": "Ignorar obstruções como painéis solares, levando a pontos cegos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Campo de Visão e Geometria do Veículo",
                                  "subSteps": [
                                    "Representar o veículo como um modelo 3D esférico ou poliédrico para simulação.",
                                    "Calcular o cone de visão de cada sensor usando trigonometria (FOV/2 como semi-ângulo).",
                                    "Projetar vetores de visão unitários para posições candidatas nos eixos x, y, z.",
                                    "Visualizar sobreposições de FOV em um diagrama de cobertura hemisférica.",
                                    "Identificar gaps iniciais na cobertura total (360° em roll/pitch/yaw)."
                                  ],
                                  "verification": "Diagrama 2D/3D gerado mostrando FOVs individuais e gaps iniciais.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software de modelagem 3D (ex: Blender gratuito ou MATLAB), calculadora trigonométrica.",
                                  "tips": "Use coordenadas esféricas (azimute, elevação) para precisão angular.",
                                  "learningObjective": "Dominar modelagem geométrica de sensores para visualização de cobertura.",
                                  "commonMistakes": "Confundir FOV com ângulo de detecção, subestimando overlaps necessários."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar Configuração da Constelação de Sensores",
                                  "subSteps": [
                                    "Selecionar posições ótimas: tipicamente 6-12 sensores em octaedro ou dodecaedro para cobertura isotrópica.",
                                    "Garantir redundância: pelo menos 3 sensores visíveis simultaneamente para solução de atitude.",
                                    "Otimizar ângulos entre sensores para minimizar erro de estimação (ângulo >30° entre vetores).",
                                    "Ajustar para cobertura total: nenhum ponto no céu com menos de 2 sensores.",
                                    "Calcular métricas: grau médio de redundância e tempo de exposição mínima."
                                  ],
                                  "verification": "Esquema da constelação desenhado com posições, vetores e métricas calculadas.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Software de simulação (ex: Python com Matplotlib/NumPy, ou STK gratuito).",
                                  "tips": "Comece com configuração simétrica e itere para assimetrias da plataforma.",
                                  "learningObjective": "Aplicar princípios de geometria espacial para arrays redundantes.",
                                  "commonMistakes": "Posicionar todos sensores no mesmo hemisfério, criando pontos cegos opostos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Validar Cobertura e Redundância",
                                  "subSteps": [
                                    "Implementar simulação Monte Carlo: amostrar direções aleatórias e contar sensores visíveis.",
                                    "Verificar cobertura: 100% das direções com ≥2 sensores, erro de atitude <1° RMS.",
                                    "Testar cenários de falha: remover 1-2 sensores e reavaliar cobertura.",
                                    "Analisar sensibilidade a ruído e calibração inicial dos sensores.",
                                    "Gerar relatório com gráficos de cobertura e histogramas de redundância."
                                  ],
                                  "verification": "Relatório de simulação com métricas passando thresholds (ex: cobertura >99.9%).",
                                  "estimatedTime": "5 horas",
                                  "materials": "Python/Jupyter Notebook com bibliotecas NumPy, SciPy e Matplotlib.",
                                  "tips": "Use 10.000+ iterações Monte Carlo para estatística robusta.",
                                  "learningObjective": "Validar designs através de simulação numérica realista.",
                                  "commonMistakes": "Não simular falhas, superestimando confiabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Otimizar Plano Final",
                                  "subSteps": [
                                    "Compilar blueprint: posições exatas, montagem e calibração.",
                                    "Otimizar trade-offs: custo vs. redundância, ajustando número de sensores.",
                                    "Planejar integração: interfaces elétricas e software de fusão de dados.",
                                    "Revisar com pares para feedback.",
                                    "Preparar para prototipagem física."
                                  ],
                                  "verification": "Plano final documentado e aprovado por revisão.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de diagramação (ex: Draw.io), documento final em PDF.",
                                  "tips": "Inclua margens de erro de 10% em cálculos para robustez.",
                                  "learningObjective": "Sintetizar design em plano acionável e otimizado.",
                                  "commonMistakes": "Esquecer calibração cruzada entre sensores."
                                }
                              ],
                              "practicalExample": "Em um CubeSat educacional, configure 8 sensores IR em posições octaédricas nos cantos do chassi 1U: 4 no 'equador' para pitch/roll e 4 nos polos para yaw. Simule no Python para confirmar que, independentemente da orientação, pelo menos 3 sensores veem estrelas terrestres simuladas, permitindo solução de atitude com redundância.",
                              "finalVerifications": [
                                "Cobertura hemisférica total: nenhum gap >1% em simulações.",
                                "Redundância mínima de 2 sensores por direção em 99% dos casos.",
                                "Erro RMS de atitude <2° em validação simulada.",
                                "Tolerância a falha única: cobertura mantida >95%.",
                                "Documentação completa com diagramas e código fonte.",
                                "Métricas de performance documentadas e thresholds atendidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão geométrica: ângulos e posições calculados corretamente (30%).",
                                "Cobertura e redundância: simulações comprovam 100% cobertura (25%).",
                                "Validação robusta: testes de falha e Monte Carlo incluídos (20%).",
                                "Documentação clara: diagramas legíveis e relatório estruturado (15%).",
                                "Otimização: trade-offs justificados (ex: custo vs. performance) (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria esférica e vetores unitários.",
                                "Física: Óptica infravermelha e determinação de atitude.",
                                "Programação: Simulações em Python/NumPy para Monte Carlo.",
                                "Engenharia: Design de sistemas redundantes e integração.",
                                "Estatística: Análise de distribuições de cobertura."
                              ],
                              "realWorldApplication": "Em missões como o satélite CYGNSS da NASA, arrays de sensores IR terrestres fornecem determinação de atitude autônoma, essencial para manobras precisas em constelações de nanosatélites, tolerando falhas e garantindo cobertura contínua em órbitas LEO."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Avaliar limitações operacionais dos sensores",
                            "description": "Discutir erros induzidos por alumínio, nuvens, eclipse e temperatura do sensor, e estratégias de mitigação como filtros e calibração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e analisar erros induzidos por alumínio e nuvens",
                                  "subSteps": [
                                    "Pesquisar propriedades óticas do alumínio e sua reflexão no infravermelho.",
                                    "Estudar impacto de nuvens na atenuação de sinal IR terrestre.",
                                    "Coletar exemplos de dados simulados ou reais mostrando falsos horizontes.",
                                    "Documentar mecanismos físicos de cada erro em um diagrama.",
                                    "Quantificar erros típicos em termos de ângulo de atitude (ex: 0.5-2 graus)."
                                  ],
                                  "verification": "Diagrama completo com descrições e quantificações submetido e revisado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigos científicos sobre sensores IR",
                                    "Software de desenho (ex: Draw.io)",
                                    "Dados de simulação de sensores IR"
                                  ],
                                  "tips": [
                                    "Use espectros IR para visualizar reflexões; foque em comprimentos de onda 8-14 μm."
                                  ],
                                  "learningObjective": "Compreender mecanismos físicos de erros superficiais e atmosféricos em sensores IR.",
                                  "commonMistakes": [
                                    "Confundir reflexão especular com difusa",
                                    "Ignorar variação de espessura de nuvens"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar erros por eclipse e temperatura do sensor",
                                  "subSteps": [
                                    "Explicar perda de sinal durante eclipse solar (ausência de gradiente térmico).",
                                    "Investigar deriva térmica do sensor devido a variações de temperatura ambiente.",
                                    "Modelar matematicamente o impacto (ex: erro = k * ΔT, onde k é coeficiente).",
                                    "Revisar curvas de resposta térmica de sensores IR comerciais.",
                                    "Simular cenários de eclipse com ferramentas de software."
                                  ],
                                  "verification": "Modelo matemático e simulação gerados, com gráficos de erro vs. condições.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Folhas de dados de sensores IR (ex: Heimdall ou ML1007)",
                                    "MATLAB ou Python para modelagem",
                                    "Referências astronômicas sobre eclipses"
                                  ],
                                  "tips": [
                                    "Considere ciclos orbitais para prever eclipses; teste em câmara térmica virtual."
                                  ],
                                  "learningObjective": "Modelar quantitativamente erros transitórios e térmicos em determinação de atitude.",
                                  "commonMistakes": [
                                    "Subestimar histerese térmica",
                                    "Não diferenciar eclipse total de parcial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar estratégias de mitigação com filtros ópticos",
                                  "subSteps": [
                                    "Estudar tipos de filtros IR (band-pass, notch para rejeitar alumínio).",
                                    "Analisar como filtros reduzem ruído de nuvens e reflexões.",
                                    "Simular aplicação de filtro em dados ruidosos.",
                                    "Avaliar trade-offs: ganho em precisão vs. perda de sinal.",
                                    "Documentar configurações ótimas para sensores terrestres."
                                  ],
                                  "verification": "Simulação antes/depois com filtro mostrando redução de erro >50%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software óptico (ex: Zemax trial ou Python OpticPy)",
                                    "Espectros de filtros IR",
                                    "Datasets de sensores ruidosos"
                                  ],
                                  "tips": [
                                    "Escolha filtros centrados em 10-12 μm para horizonte terrestre; valide com SNR."
                                  ],
                                  "learningObjective": "Aplicar filtros ópticos para mitigar erros ambientais específicos.",
                                  "commonMistakes": [
                                    "Escolher filtro inadequado para banda IR",
                                    "Ignorar alinhamento do filtro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar calibração e avaliar limitações operacionais integradas",
                                  "subSteps": [
                                    "Desenvolver procedimento de calibração térmica e estelar.",
                                    "Integrar mitigações em um fluxo de processamento de dados.",
                                    "Simular cenários completos (alumínio + nuvens + eclipse).",
                                    "Calcular envelope operacional do sensor (faixas de erro aceitáveis).",
                                    "Redigir relatório de avaliação com recomendações."
                                  ],
                                  "verification": "Relatório com simulações integradas e envelope operacional definido.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ferramenta de simulação orbital (ex: STK ou Orekit)",
                                    "Planilhas para calibração",
                                    "Templates de relatório"
                                  ],
                                  "tips": [
                                    "Use calibração look-up table para temperatura; valide com dados reais de missões."
                                  ],
                                  "learningObjective": "Avaliar holisticamente limitações e otimizar operação do sensor IR.",
                                  "commonMistakes": [
                                    "Não considerar interações entre erros",
                                    "Calibração estática em ambiente dinâmico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma estação terrestre rastreando um satélite LEO, nuvens grossas causam erro de 1.5° na atitude; aplicar filtro band-pass e recalibração térmica reduz para 0.2°, permitindo correção precisa de órbita.",
                              "finalVerifications": [
                                "Lista completa dos quatro erros com mecanismos físicos descritos.",
                                "Modelos quantitativos para cada erro desenvolvidos.",
                                "Simulações de mitigações mostram redução efetiva de erros.",
                                "Envelope operacional do sensor definido com limites claros.",
                                "Relatório integra todas as limitações e estratégias."
                              ],
                              "assessmentCriteria": [
                                "Precisão e profundidade na descrição dos erros (90% cobertura).",
                                "Qualidade quantitativa das modelagens e simulações.",
                                "Eficácia das mitigações propostas (redução >40% em cenários testados).",
                                "Clareza e completude do envelope operacional.",
                                "Integração interdisciplinar e recomendações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Emissão e absorção IR, termodinâmica de sensores.",
                                "Matemática: Modelagem de erros, estatística de ruído.",
                                "Engenharia: Design óptico e controle térmico.",
                                "Computação: Processamento de sinais e simulação orbital."
                              ],
                              "realWorldApplication": "Em operações de controle de attitude de satélites como os da constelação Starlink ou missões da ESA, estações terrestres usam sensores IR para fornecer dados de referência, avaliando limitações climáticas e aplicando calibrações em tempo real para manter precisão de pointing abaixo de 0.1°."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Métodos de Processamento e Determinação de Atitude",
                        "description": "Algoritmos e técnicas para extrair informações de atitude a partir de medidas de sensores terrestres IR.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Implementar detecção de horizonte IR",
                            "description": "Aplicar algoritmos de threshold e detecção de borda para identificar o horizonte IR a partir de sinais de varredura, calculando ângulos de elevação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Aquisição e Pré-processamento do Sinal de Varredura IR",
                                  "subSteps": [
                                    "Carregue o sinal de varredura IR de um arquivo ou gere sinteticamente usando funções como numpy.linspace para simular ângulos de varredura.",
                                    "Aplique filtro passa-baixa (ex: Butterworth) para reduzir ruído usando scipy.signal.",
                                    "Normalize o sinal para o intervalo [0,1] subtraindo a média e dividindo pelo desvio padrão.",
                                    "Plote o sinal original e filtrado usando matplotlib para visualização inicial.",
                                    "Salve o sinal pré-processado em uma variável para uso posterior."
                                  ],
                                  "verification": "O sinal plotado mostra redução clara de ruído e normalização entre 0 e 1, sem distorções visíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "SciPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use windowing (ex: Hamming) antes do filtro para evitar artefatos de borda.",
                                  "learningObjective": "Compreender e aplicar técnicas básicas de pré-processamento de sinais para melhorar a qualidade dos dados IR.",
                                  "commonMistakes": [
                                    "Ignorar ruído alto sem filtragem",
                                    "Normalização inadequada levando a valores fora de [0,1]",
                                    "Não plotar para inspeção visual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicação do Algoritmo de Threshold para Segmentação",
                                  "subSteps": [
                                    "Calcule o threshold automático usando método Otsu com skimage.filters.threshold_otsu.",
                                    "Crie uma máscara binária aplicando o threshold ao sinal normalizado.",
                                    "Suavize a máscara com dilatação/erosão morfológica usando skimage.morphology.",
                                    "Identifique regiões de terra (1) e céu (0) na máscara.",
                                    "Plote o sinal com o threshold e máscara sobrepostos."
                                  ],
                                  "verification": "A máscara binária separa claramente regiões de céu e terra, com threshold valor impresso e plotado corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "scikit-image"
                                  ],
                                  "tips": "Teste thresholds manuais primeiro para validar o automático em sinais ruidosos.",
                                  "learningObjective": "Dominar segmentação de imagem 1D via threshold adaptativo para sinais IR.",
                                  "commonMistakes": [
                                    "Threshold fixo insensível a variações de intensidade",
                                    "Não suavizar a máscara levando a fragmentação",
                                    "Inversão errada de céu/terra"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detecção de Borda no Sinal Segmentado",
                                  "subSteps": [
                                    "Calcule a derivada do sinal segmentado usando numpy.gradient ou Sobel 1D.",
                                    "Aplique filtro de não-máximos para refinar picos de borda.",
                                    "Encontre o pico máximo da derivada absoluta como posição da borda do horizonte.",
                                    "Aplique supressão de não-máximos para eliminar bordas espúrias.",
                                    "Plote a derivada e marque a borda detectada."
                                  ],
                                  "verification": "A posição da borda detectada corresponde visualmente à transição céu-terra no plot.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "SciPy"
                                  ],
                                  "tips": "Use sigma baixo no Gaussian blur antes da derivada para bordas nítidas.",
                                  "learningObjective": "Implementar detecção de borda precisa em sinais 1D para localização do horizonte.",
                                  "commonMistakes": [
                                    "Derivada sem suavização causando múltiplos picos falsos",
                                    "Não suprimir bordas secundárias",
                                    "Escala errada na derivada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Cálculo do Ângulo de Elevação e Validação",
                                  "subSteps": [
                                    "Converta a posição da borda (índice) em ângulo de elevação usando fórmula: elevation = (index / len(sinal)) * fov - 90, onde fov é o campo de visão.",
                                    "Compare com ângulo conhecido (ground truth) calculando erro RMSE.",
                                    "Implemente loop para múltiplas varreduras e média dos ângulos.",
                                    "Gere relatório com ângulo médio, desvio e plots.",
                                    "Teste com ruído adicionado para robustez."
                                  ],
                                  "verification": "Ângulo calculado impresso e erro < 2 graus em testes simulados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Calibre fov baseado no sensor real (ex: 120 graus para IR scanner).",
                                  "learningObjective": "Calcular e validar ângulos de atitude a partir de detecções de horizonte IR.",
                                  "commonMistakes": [
                                    "Fórmula de ângulo sem considerar offset de varredura",
                                    "Não média múltiplas detecções",
                                    "Ignorar calibração de fov"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de CubeSat em órbita baixa terrestre (LEO), gere um sinal de varredura IR de 1024 pontos cobrindo -90° a +30° de elevação, adicione ruído gaussiano (SNR=20dB), aplique threshold Otsu, detecte borda via derivada, e calcule elevação do horizonte em 0° com erro <1°.",
                              "finalVerifications": [
                                "Sinal pré-processado normalizado e ruído reduzido visivelmente nos plots.",
                                "Threshold Otsu aplicado corretamente com máscara binária suave.",
                                "Borda do horizonte detectada na posição esperada (±5 pontos).",
                                "Ângulo de elevação calculado com erro RMSE <2° em 10 varreduras.",
                                "Código roda em <5s por varredura e é robusto a variações de ruído.",
                                "Relatório gerado com plots e métricas impressas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da detecção de borda >95% em sinais com SNR>15dB.",
                                "Tempo total de processamento <3s para 1024 pontos.",
                                "Robustez: Funciona com ruído gaussiano e offsets de sinal.",
                                "Código modular com funções separadas para cada step.",
                                "Plots claros com anotações de threshold, borda e ângulo.",
                                "Erro de ângulo médio <1.5° comparado a ground truth."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Derivadas e otimização (Otsu como maximização de variância).",
                                "Programação: Bibliotecas NumPy/SciPy para processamento numérico eficiente.",
                                "Física: Radiometria IR e contraste céu-terra em espectro térmico.",
                                "Estatística: Análise de ruído e validação via RMSE.",
                                "Engenharia de Software: Modularidade e testes unitários em simulações."
                              ],
                              "realWorldApplication": "Em satélites e sondas espaciais como CubeSats ou missões interplanetárias, a detecção de horizonte IR fornece determinação autônoma de atitude para controle de apontamento de instrumentos, navegação sem GPS e recuperação de orientação após falhas de giroscópios."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Calcular vetores de atitude usando medidas múltiplas",
                            "description": "Usar métodos como QUEST ou TRIAD para combinar medidas de múltiplos sensores IR e determinar a matriz de direção de atitude em relação ao referencial orbital.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Vetores de Atitude e Sensores IR",
                                  "subSteps": [
                                    "Estude a definição de matriz de direção de atitude (DCM) e vetores de referência orbital (ex: vetor nadir da Terra).",
                                    "Revise o funcionamento de sensores IR terrestres: como eles medem o vetor de linha de visão (LOS) para a Terra.",
                                    "Aprenda os princípios dos métodos QUEST (para múltiplas medidas ponderadas) e TRIAD (para duas medidas ortogonais).",
                                    "Identifique as entradas necessárias: vetores medidos (b_i) e vetores de referência (r_i) em seus frames.",
                                    "Pratique normalização de vetores para garantir magnitudes unitárias."
                                  ],
                                  "verification": "Resuma em um diagrama os frames de referência (body e orbital) e liste diferenças entre QUEST e TRIAD.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de dinâmica de spacecraft (ex: Sidi), slides de aula, calculadora simbólica (SymPy ou MATLAB).",
                                  "tips": "Use visualizações 3D para entender rotações entre frames.",
                                  "learningObjective": "Compreender as bases matemáticas e físicas para combinar medidas de atitude.",
                                  "commonMistakes": "Confundir frames de referência (body vs. inertial); ignorar normalização de vetores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Pré-processar Medidas de Múltiplos Sensores IR",
                                  "subSteps": [
                                    "Simule ou colete dados de 3-6 sensores IR: gere vetores LOS medidos no frame do corpo (b_i).",
                                    "Calcule os vetores de referência correspondentes no frame orbital (r_i), usando modelo da Terra esférica.",
                                    "Aplique calibração: remova biases e ruídos usando filtros (ex: média móvel ou Kalman simples).",
                                    "Atribua pesos (w_i) às medidas baseados em precisão do sensor (maior para sensores centrais).",
                                    "Normalise todos os vetores e verifique ortogonalidade aproximada."
                                  ],
                                  "verification": "Gere um plot dos vetores b_i e r_i; confirme que ||b_i|| ≈ 1 e ângulos entre r_i são consistentes.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python (NumPy, Matplotlib), dataset simulado de sensores IR ou software STK (Systems Tool Kit).",
                                  "tips": "Comece com dados sintéticos sem ruído para depuração.",
                                  "learningObjective": "Preparar dados reais para input nos algoritmos de estimação.",
                                  "commonMistakes": "Não normalizar vetores levando a DCM não-ortogonal; ignorar pesos em QUEST."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Algoritmo TRIAD para Duas Medidas",
                                  "subSteps": [
                                    "Selecione duas medidas não-colineares: b1, b2 e r1, r2.",
                                    "Construa matrizes: Z = [b1 b2] * [r1 r2]^T.",
                                    "Calcule SVD de Z = U Σ V^T; defina DCM = U V^T.",
                                    "Verifique det(DCM) = 1; se -1, ajuste o último singular vector.",
                                    "Teste com rotação conhecida e compute erro de atitude."
                                  ],
                                  "verification": "Compare DCM estimada com DCM verdadeira; erro < 1 grau.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (SciPy para SVD) ou MATLAB.",
                                  "tips": "Use np.linalg.svd() para simplicidade.",
                                  "learningObjective": "Aplicar TRIAD para estimação rápida com duas medidas.",
                                  "commonMistakes": "Selecionar vetores colineares causando singularidade; esquecer correção de determinante."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o Algoritmo QUEST para Múltiplas Medidas",
                                  "subSteps": [
                                    "Construa a matriz de covariância B = sum(w_i * (b_i * r_i^T - skew(r_i) * K * skew(r_i))).",
                                    "Encontre autovalor máximo λ_max e autovetor correspondente via polinômio característico de 4x4.",
                                    "Calcule quaternions a partir do autovetor: q = [λ_max^{1/2}, elementos do autovetor].",
                                    "Converta quaternion para DCM e normalize.",
                                    "Avalie perda de QUEST (2(4-λ_max)) para qualidade."
                                  ],
                                  "verification": "Erro de atitude < 0.5 grau e perda QUEST < 0.1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python (NumPy para álgebra linear, SciPy para eigen), código QUEST open-source.",
                                  "tips": "Analise numericamente o polinômio para evitar instabilidades.",
                                  "learningObjective": "Usar QUEST para estimação ótima ponderada com múltiplas medidas.",
                                  "commonMistakes": "Erro na construção de B (skew simétrico); normalização incorreta do quaternion."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Comparar Resultados dos Métodos",
                                  "subSteps": [
                                    "Aplique ambos TRIAD e QUEST aos mesmos dados com ruído adicionado.",
                                    "Compute métricas: erro RMS de atitude, tempo de computação.",
                                    "Analise sensibilidade a número de sensores e ruído.",
                                    "Integre em loop de simulação para sequência temporal.",
                                    "Documente trade-offs: TRIAD (rápido, menos preciso) vs. QUEST (ótimo, computacional)."
                                  ],
                                  "verification": "Relatório com plots de erro vs. ruído; QUEST superior em >3 sensores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Jupyter Notebook para visualizações, simulador orbital (ex: Orekit).",
                                  "tips": "Adicione ruído gaussiano realista (0.1-1 grau).",
                                  "learningObjective": "Avaliar e selecionar método baseado no cenário.",
                                  "commonMistakes": "Não testar com ruído levando a superestimação de precisão."
                                }
                              ],
                              "practicalExample": "Em um CubeSat com 4 sensores IR nos cantos, medidas LOS são b1=[0.7,0.3,0.6], b2=[-0.2,0.8,-0.55], etc. Referências orbitais r_i baseados em nadir. Aplique QUEST para DCM que alinha body para apontar payload à Terra, corrigindo drift de 2 graus.",
                              "finalVerifications": [
                                "DCM resultante tem det=1 e colunas ortonormais (erro <1e-6).",
                                "Erro de atitude RMS <0.5 graus em simulação com ruído.",
                                "Perda QUEST <0.05 para >3 sensores.",
                                "Código roda em <10ms por iteração.",
                                "Resultados consistentes entre TRIAD e QUEST em casos ideais.",
                                "Visualização 3D mostra alinhamento correto com Terra."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro de atitude <1 grau em testes variados (40%).",
                                "Completude: Todos substeps implementados corretamente (20%).",
                                "Eficiência: Tempo computacional otimizado (15%).",
                                "Análise: Interpretação de erros e trade-offs (15%).",
                                "Documentação: Código comentado e relatório claro (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (SVD, quaternions, autovalores).",
                                "Programação: NumPy/SciPy para simulações numéricas.",
                                "Física: Cinemática orbital e modelo da Terra não-esférico.",
                                "Estatística: Análise de covariância e filtros de Kalman para fusão.",
                                "Engenharia: Integração de sensores em sistemas embarcados."
                              ],
                              "realWorldApplication": "Satélites como o CubeSat da NASA usam QUEST com sensores IR para determinação autônoma de atitude durante aquisição de imagens da Terra, essencial para missões de observação sem GPS em órbita LEO."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Simular erros e precisão de atitude",
                            "description": "Modelar simulações de determinação de atitude com sensores IR, avaliando precisão típica (0.1-0.5 graus) e fusão com outros sensores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o modelo básico de simulação para sensores IR terrestres",
                                  "subSteps": [
                                    "Definir a geometria do sensor IR apontando para a Terra, considerando o horizonte infravermelho.",
                                    "Implementar o modelo matemático de detecção de atitude baseado em ângulos de visão do horizonte.",
                                    "Configurar parâmetros iniciais: órbita do veículo espacial, posição do sensor e resolução angular.",
                                    "Criar uma função para calcular a atitude nominal sem erros.",
                                    "Testar o modelo com cenários ideais para validar a saída básica."
                                  ],
                                  "verification": "Executar simulação ideal e confirmar que a atitude calculada corresponde à verdade de terreno (ground truth) com erro < 0.01 graus.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de simulação (MATLAB/Simulink ou Python com NumPy/SciPy), documentação de sensores IR (ex: IRU specs).",
                                  "tips": "Use coordenadas esféricas para modelar o horizonte terrestre para maior precisão.",
                                  "learningObjective": "Compreender e implementar o modelo cinemático de determinação de atitude via sensores IR.",
                                  "commonMistakes": "Ignorar a curvatura terrestre ou assumir sensor puntiforme em vez de com campo de visão finito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar e introduzir erros típicos nos sensores IR",
                                  "subSteps": [
                                    "Identificar fontes de erro: ruído gaussiano, bias de montagem, distorção ótica e variações térmicas.",
                                    "Implementar distribuições estatísticas para erros (ex: ruído N(0, σ) com σ=0.05 graus).",
                                    "Adicionar erros sistemáticos como desalinhamento (0.1 graus) e ruído de quantização.",
                                    "Simular múltiplas runs (Monte Carlo, 1000 iterações) para capturar variabilidade.",
                                    "Calcular estatísticas iniciais: média, desvio padrão e RMSE da atitude estimada."
                                  ],
                                  "verification": "Gerar histogramas de erros e confirmar que a precisão simulada está na faixa 0.1-0.5 graus (95% confidence).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Bibliotecas estatísticas (SciPy.stats ou MATLAB Statistics Toolbox), scripts de Monte Carlo.",
                                  "tips": "Use seed randômico fixo para reprodutibilidade durante debugging.",
                                  "learningObjective": "Modelar realisticamente fontes de erro em sensores IR e quantificar sua impactância na precisão.",
                                  "commonMistakes": "Subestimar correlações entre erros (ex: bias térmico correlacionado com órbita) ou usar distribuições uniformes em vez de gaussianas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar precisão da atitude e executar simulações completas",
                                  "subSteps": [
                                    "Executar simulações em diferentes condições orbitais (LEO, GEO) e attitudes.",
                                    "Computar métricas de precisão: erro RMS, bias e intervalo de confiança para 0.1-0.5 graus.",
                                    "Visualizar resultados com plots de erro vs. tempo e sky maps de detecção.",
                                    "Comparar com literatura (ex: precisão de sensores como STAR trackers vs. IR earth sensors).",
                                    "Otimizar thresholds de detecção para minimizar falsos positivos."
                                  ],
                                  "verification": "Relatório de simulação mostra precisão média <0.3 graus e variância consistente com specs reais.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Ferramentas de plotagem (Matplotlib ou MATLAB plotting), dados orbitais (ex: Two-Line Elements).",
                                  "tips": "Simule eclipse orbital para testar degradação de performance em ausência de sinal IR.",
                                  "learningObjective": "Avaliar quantitativamente a precisão de determinação de atitude sob erros realistas.",
                                  "commonMistakes": "Não considerar multi-path reflections da atmosfera ou nuvens na simulação IR."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar fusão de sensores e validar melhoria de precisão",
                                  "subSteps": [
                                    "Integrar dados de outros sensores (giroscópios, magnetômetros, STAR trackers) no modelo.",
                                    "Aplicar filtro de Kalman estendido (EKF) para fusão de atitude IR com rates gyros.",
                                    "Simular cenários de falha (ex: perda de sinal IR) e recuperação via fusão.",
                                    "Comparar precisão pré e pós-fusão (target: redução de erro para <0.1 graus).",
                                    "Documentar matrizes de covariância e gains do filtro."
                                  ],
                                  "verification": "Simulação fused mostra melhoria estatisticamente significativa (teste t, p<0.05) na precisão.",
                                  "estimatedTime": "3.5 horas",
                                  "materials": "Bibliotecas de filtros (Python FilterPy ou MATLAB EKF toolbox), modelos de sensores adicionais.",
                                  "tips": "Inicialize o filtro com atitude IR para convergência rápida.",
                                  "learningObjective": "Demonstrar como fusão sensorial mitiga erros IR e melhora precisão global.",
                                  "commonMistakes": "Ignorar divergência do filtro devido a não-linearidades ou model mismatch."
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO (400km) usando sensor IR terrestre para estimar roll/pitch. Introduza ruído de 0.2 graus, fusione com gyros MEMS e valide precisão <0.3 graus durante manobras, comparando com dados telemetry reais de missões como CubeSat FireSat.",
                              "finalVerifications": [
                                "Simulações rodam sem crashes e geram 1000+ iterações Monte Carlo.",
                                "Precisão da atitude IR isolada está entre 0.1-0.5 graus (RMS).",
                                "Fusão sensorial reduz erro em pelo menos 50%.",
                                "Plots e estatísticas documentam variabilidade e bias.",
                                "Código é modular e comentado para reutilização.",
                                "Resultados alinham com specs de sensores reais (ex: Honeywell IRU)."
                              ],
                              "assessmentCriteria": [
                                "Modelo de erro IR é fisicamente realista e parametrizado corretamente (30%).",
                                "Simulações Monte Carlo são estatisticamente robustas (25%).",
                                "Implementação de fusão EKF converge e melhora precisão (20%).",
                                "Análise quantitativa inclui métricas chave (RMS, bias, CI) (15%).",
                                "Visualizações e documentação são claras e profissionais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística (Monte Carlo, distribuições de erro), Álgebra Linear (matrizes de covariância).",
                                "Física: Ótica Infravermelha, Dinâmica Orbital, Cinemática de Rigid Bodies.",
                                "Programação: Simulação Numérica, Filtros Recursivos (Kalman).",
                                "Engenharia: Sistemas Embarcados, Validação de Modelos."
                              ],
                              "realWorldApplication": "Em missões espaciais como o Telescópio Hubble ou estações ISS, sensores IR terrestres com fusão Kalman mantêm atitude precisa para apontamento de antenas/painéis solares, tolerando erros de 0.1-0.5 graus em ambientes hostis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Sensores Solares",
                    "description": "Técnicas de determinação de atitude baseadas em sensores que medem a direção e intensidade da radiação solar.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Princípios Físicos dos Sensores Solares",
                        "description": "Fundamentos físicos que permitem aos sensores solares detectarem a direção e a intensidade da radiação solar para determinação de atitude em veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Identificar os princípios de detecção de radiação solar",
                            "description": "Explicar como os sensores solares utilizam a lei dos cossenos para relacionar a intensidade da radiação recebida com o ângulo de incidência do vetor solar em relação ao plano do sensor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Radiação Solar e Sensores Solares",
                                  "subSteps": [
                                    "Estude o que é radiação solar: energia eletromagnética emitida pelo Sol, principalmente na faixa visível e infravermelha.",
                                    "Aprenda sobre sensores solares: dispositivos fotossensíveis (como células fotovoltaicas ou fotodiodos) que detectam intensidade de luz solar.",
                                    "Identifique a função principal: medir a direção e intensidade do vetor solar para determinação de atitude em veículos espaciais.",
                                    "Revise unidades de medida: W/m² para irradiância solar.",
                                    "Explore diagramas básicos de sensores solares em satélites."
                                  ],
                                  "verification": "Desenhe um diagrama simples de um sensor solar e rotule os componentes principais, explicando sua função.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de física aeroespacial",
                                    "Vídeos educativos sobre sensores solares (YouTube/Khan Academy)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com analogias terrestres, como painéis solares em telhados, para visualizar melhor.",
                                  "learningObjective": "Entender os conceitos básicos de radiação solar e o papel dos sensores em aplicações espaciais.",
                                  "commonMistakes": [
                                    "Confundir radiação solar com luz visível apenas",
                                    "Ignorar que sensores medem intensidade proporcional à projeção da radiação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Vetor Solar e Plano do Sensor",
                                  "subSteps": [
                                    "Defina o vetor solar: direção unitária apontando do Sol para o veículo espacial.",
                                    "Descreva o plano do sensor: superfície perpendicular ao eixo de detecção do sensor.",
                                    "Aprenda a representar vetorialmente: vetor normal ao plano do sensor (n) e vetor solar (s).",
                                    "Estude a relação geométrica: ângulo entre o vetor solar e o normal ao plano.",
                                    "Pratique com vetores 3D usando software como GeoGebra ou desenhos."
                                  ],
                                  "verification": "Escreva definições precisas e desenhe vetores s e n com ângulo θ entre eles.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de geometria vetorial (GeoGebra gratuito)",
                                    "Folhas de exercícios vetoriais"
                                  ],
                                  "tips": "Use coordenadas cartesianas para fixar ideias: s = (sx, sy, sz), n = (nx, ny, nz).",
                                  "learningObjective": "Dominar a representação vetorial do Sol e do sensor para análise geométrica.",
                                  "commonMistakes": [
                                    "Confundir vetor solar com posição absoluta do Sol",
                                    "Esquecer que o plano é definido pelo normal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o Conceito de Ângulo de Incidência",
                                  "subSteps": [
                                    "Defina ângulo de incidência θ: ângulo entre o vetor solar s e o normal n ao plano do sensor.",
                                    "Relacione com produto escalar: cos(θ) = s · n / (|s| |n|), onde |s| = |n| = 1 para unitários.",
                                    "Discuta limites: θ = 0° (máxima intensidade, perpendicular), θ = 90° (zero intensidade).",
                                    "Calcule exemplos numéricos: se s · n = 0.866, θ = 30°.",
                                    "Visualize com animações ou modelos 3D."
                                  ],
                                  "verification": "Calcule cos(θ) para dois vetores dados e encontre θ usando calculadora.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tutoriais de produto escalar (Khan Academy)",
                                    "Ferramenta online de vetores"
                                  ],
                                  "tips": "Lembre-se: vetores unitários simplificam para cos(θ) = s · n.",
                                  "learningObjective": "Calcular e interpretar o ângulo de incidência usando geometria vetorial.",
                                  "commonMistakes": [
                                    "Usar ângulo com o plano em vez do normal",
                                    "Esquecer normalizar vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Lei dos Cossenos para Intensidade da Radiação",
                                  "subSteps": [
                                    "Revise lei dos cossenos: em triângulo, c² = a² + b² - 2ab cos(C).",
                                    "Aplique ao contexto: intensidade I = I₀ cos(θ), onde θ é incidência (lei de Lambert aproximada).",
                                    "Derive geometricamente: projeção da irradiância I₀ no plano é I₀ |s · n|.",
                                    "Simule cenários: θ variando de 0° a 90°, plote I vs θ.",
                                    "Integre em equação de sensor: sinal proporcional a I."
                                  ],
                                  "verification": "Derive a fórmula I = I₀ cos(θ) e calcule I para θ=45°, I₀=1366 W/m².",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel/MATLAB para simulação",
                                    "Artigos sobre sensores solares (NASA)",
                                    "Gráficos de irradiância"
                                  ],
                                  "tips": "Pense na sombra: quanto mais oblíquo, menor a intensidade efetiva.",
                                  "learningObjective": "Explicar matematicamente como a lei dos cossenos relaciona ângulo e intensidade.",
                                  "commonMistakes": [
                                    "Aplicar cosseno diretamente sem projeção",
                                    "Ignorar que cos(θ) pode ser negativo (ocultação)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Verificar o Princípio Completo",
                                  "subSteps": [
                                    "Combine todos: sensor output ~ I₀ cos(θ), θ de s e n.",
                                    "Discuta calibração: sensores lineares para cos(θ) > 0.",
                                    "Analise erros: sombreamento, temperatura, não-linearidades.",
                                    "Crie fluxograma: vetor solar → θ → I → atitude.",
                                    "Teste com dados reais de satélites."
                                  ],
                                  "verification": "Explique verbalmente o processo completo e resolva um problema end-to-end.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Dados de missão CubeSat",
                                    "Simulador de atitude online"
                                  ],
                                  "tips": "Use equação completa: cos(θ) = s · n para determinar quadrante da atitude.",
                                  "learningObjective": "Sintetizar o princípio de detecção em um modelo acionável.",
                                  "commonMistakes": [
                                    "Esquecer dependência angular na calibração",
                                    "Confundir intensidade com direção absoluta"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um satélite CubeSat, com vetor solar s = (1, 0, 0) e normal do sensor n = (cos(30°), sin(30°), 0), calcule θ = 30°, cos(θ) ≈ 0.866, então I = 1366 * 0.866 ≈ 1183 W/m², sinal do sensor proporcional indica inclinação de 30° no plano XY.",
                              "finalVerifications": [
                                "Explicar verbalmente como cos(θ) relaciona intensidade e ângulo.",
                                "Calcular corretamente θ e I para vetores dados.",
                                "Desenhar diagrama vetorial preciso com rótulos.",
                                "Identificar quando I=0 (θ=90°).",
                                "Discutir limitações reais de sensores solares.",
                                "Simular variação de atitude e prever output do sensor."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de vetor solar, normal e θ (90% correto).",
                                "Correta aplicação de produto escalar e lei dos cossenos.",
                                "Exemplos práticos relevantes ao contexto aeroespacial.",
                                "Identificação de erros comuns e limitações.",
                                "Clareza em diagramas e cálculos numéricos.",
                                "Integração conceitual completa sem lacunas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria vetorial e trigonometria.",
                                "Física: Óptica geométrica e lei de Lambert.",
                                "Engenharia: Sensores em sistemas embarcados e controle de atitude.",
                                "Computação: Simulações numéricas em Python/MATLAB.",
                                "Ciências da Terra: Modelos de irradiância solar."
                              ],
                              "realWorldApplication": "Em satélites como o Hubble ou CubeSats, sensores solares usam esse princípio para estimar atitude, essencial para apontamento de antenas, painéis solares e câmeras, permitindo navegação autônoma sem GPS no espaço."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Calcular intensidade solar em função do ângulo",
                            "description": "Realizar cálculos da intensidade medida I = I0 * cos(θ), onde θ é o ângulo entre o vetor solar e a normal do sensor, considerando sombreamento e eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos geométricos fundamentais",
                                  "subSteps": [
                                    "Identifique o vetor solar como a direção do Sol em relação ao sensor.",
                                    "Defina a normal do sensor como o vetor perpendicular à superfície do sensor.",
                                    "Calcule o ângulo θ como o ângulo entre o vetor solar e a normal do sensor usando produto escalar.",
                                    "Desenhe diagramas 2D e 3D para visualizar a geometria.",
                                    "Discuta unidades: intensidade em W/m², ângulos em radianos ou graus."
                                  ],
                                  "verification": "Desenhe um diagrama correto mostrando θ = 0° (intensidade máxima) e θ = 90° (zero).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, calculadora, software de desenho vetorial como GeoGebra.",
                                  "tips": "Sempre normalize os vetores antes de calcular o produto escalar para evitar erros de magnitude.",
                                  "learningObjective": "Entender a relação geométrica entre vetor solar e normal do sensor para definir θ corretamente.",
                                  "commonMistakes": "Confundir θ com o ângulo zenital ou esquecer de converter graus para radianos em funções trigonométricas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a fórmula básica de intensidade solar I = I₀ cos(θ)",
                                  "subSteps": [
                                    "Obtenha I₀, a constante solar (1366 W/m² no topo da atmosfera).",
                                    "Calcule cos(θ) usando calculadora ou software.",
                                    "Multiplique I = I₀ * cos(θ) para diferentes valores de θ (0°, 30°, 60°, 90°).",
                                    "Crie uma tabela de valores para validar o comportamento (máximo em θ=0, zero em θ=90).",
                                    "Implemente em código simples (Python ou MATLAB) para automação."
                                  ],
                                  "verification": "Gere uma tabela com pelo menos 5 valores de θ onde I(0°)=I₀ e I(90°)=0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou Python com numpy/math.",
                                  "tips": "Use funções built-in como np.cos() em radianos; converta graus com np.deg2rad().",
                                  "learningObjective": "Dominar o cálculo da intensidade projetada usando a lei dos cossenos.",
                                  "commonMistakes": "Usar sin(θ) em vez de cos(θ) ou calcular θ incorretamente como ângulo entre superfícies."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar efeitos de sombreamento",
                                  "subSteps": [
                                    "Defina sombreamento como fator S (0 a 1), onde S=0 é sombra total.",
                                    "Identifique causas: obstruções como painéis solares ou partes do veículo.",
                                    "Modele S geometricamente: verifique se o raio solar intersecta obstruções.",
                                    "Ajuste a fórmula: I_sombreada = I * S.",
                                    "Teste cenários: S=1 (sem sombra), S=0.5 (parcial)."
                                  ],
                                  "verification": "Calcule I para θ=30°, S=0.5 e confirme redução pela metade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Diagramas de sombreamento, software CAD ou Python com ray-tracing simples.",
                                  "tips": "Comece com sombreamento binário (sim/não) antes de modelar parcial.",
                                  "learningObjective": "Modelar realisticamente reduções de intensidade devido a obstruções no veículo espacial.",
                                  "commonMistakes": "Ignorar sombreamento dinâmico que varia com rotação do satélite."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incluir eficiência do sensor e cálculo final",
                                  "subSteps": [
                                    "Defina eficiência η (ex: 0.9 para 90% de resposta).",
                                    "Ajuste fórmula completa: I_medida = I_sombreada * η.",
                                    "Colete parâmetros reais: I₀, θ medida, S estimado, η do datasheet.",
                                    "Realize cálculo end-to-end para um caso simulado.",
                                    "Analise sensibilidade: varie θ ±10% e observe impacto."
                                  ],
                                  "verification": "Produza relatório com I_medida para parâmetros dados, com erro <1%.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Datasheet de sensor solar (ex: ADCS), Python/MATLAB script completo.",
                                  "tips": "Sempre valide com limites físicos: I_medida ≤ I₀ * η.",
                                  "learningObjective": "Integrar todos os fatores para um modelo completo de intensidade medida.",
                                  "commonMistakes": "Aplicar eficiência antes do sombreamento ou usar valores irreais para η."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e simular em contexto de determinação de atitude",
                                  "subSteps": [
                                    "Simule rotação do satélite variando θ ao longo do tempo.",
                                    "Compare I_medida com dados esperados de órbita.",
                                    "Implemente função para estimar θ a partir de I_medida: θ = acos(I / (I₀ * S * η)).",
                                    "Teste com ruído: adicione ±5% erro e avalie robustez.",
                                    "Documente código e resultados em relatório."
                                  ],
                                  "verification": "Simulação reproduz curva de intensidade para órbita conhecida.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com matplotlib para plots, dados orbitais (ex: Two-Line Elements).",
                                  "tips": "Use loops para simular tempo; plote I vs. θ para visualização.",
                                  "learningObjective": "Aplicar o modelo em simulações reais de sensores solares em veículos espaciais.",
                                  "commonMistakes": "Esquecer inversa do cos (não monótona) requer múltiplas soluções ou contexto."
                                }
                              ],
                              "practicalExample": "Em um satélite CubeSat, com I₀=1366 W/m², θ=45° (vetor solar [1,0,0], normal [0.707,0.707,0]), S=0.8 (sombra parcial de painel solar), η=0.92. Calcule: cos(45°)=0.707, I=1366*0.707=966 W/m², I_sombreada=966*0.8=773 W/m², I_medida=773*0.92=711 W/m². Use para estimar atitude.",
                              "finalVerifications": [
                                "Cálculo correto de θ via produto escalar de vetores unitários.",
                                "Intensidade zero quando θ=90° e máxima em θ=0°.",
                                "Redução apropriada com S<1 e η<1.",
                                "Inversão: recuperar θ de I_medida com erro <5°.",
                                "Simulação temporal mostra variação suave sem discrepâncias.",
                                "Código roda sem erros e produz plots legíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (±1% de erro).",
                                "Correta modelagem de sombreamento e eficiência.",
                                "Entendimento conceitual demonstrado em diagramas.",
                                "Implementação funcional em código com comentários.",
                                "Análise de sensibilidade e limites físicos.",
                                "Relatório claro com exemplos e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Trigonometria, vetores e produto escalar.",
                                "Física: Radiação eletromagnética e lei dos cossenos.",
                                "Programação: Simulações numéricas em Python/MATLAB.",
                                "Engenharia: Modelagem de sistemas aeroespaciais e ADCS.",
                                "Estatística: Análise de erro e sensibilidade em medições."
                              ],
                              "realWorldApplication": "Em satélites e sondas espaciais, sensores solares calculam assim a atitude (orientação) usando múltiplos sensores para triangulação, essencial para controle de apontamento, painéis solares e comunicações, como na ISS ou missões Mars Rover."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Analisar efeitos ambientais na medição solar",
                            "description": "Discutir impactos de temperatura, envelhecimento de materiais e variação da constante solar na precisão das medições de sensores solares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios básicos das medições de sensores solares",
                                  "subSteps": [
                                    "Estude o funcionamento de sensores solares como células fotovoltaicas ou fotodiodos em veículos espaciais.",
                                    "Revise a relação entre irradiância solar e sinal elétrico gerado pelo sensor.",
                                    "Identifique fontes ideais de medição e fatores que podem introduzir erros.",
                                    "Analise o diagrama de um sensor solar típico, incluindo componentes ópticos e eletrônicos.",
                                    "Calcule a irradiância solar nominal usando a constante solar padrão (1366 W/m²)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como um sensor solar converte luz em sinal elétrico sem erros ambientais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de sensores espaciais",
                                    "Diagrama de sensor solar (PDF ou imagem)",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Comece com equações básicas como I = G * A * η, onde G é irradiância, A área e η eficiência.",
                                  "learningObjective": "Dominar os fundamentos teóricos das medições solares para identificar desvios ambientais.",
                                  "commonMistakes": "Confundir constante solar com irradiância na superfície terrestre; ignorar perdas ópticas iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o impacto da temperatura nas medições solares",
                                  "subSteps": [
                                    "Pesquise coeficientes de temperatura para materiais semicondutores em sensores solares.",
                                    "Derive a equação de correção térmica: V_out = V_nom * (1 + α * ΔT), onde α é o coeficiente térmico.",
                                    "Simule variações de temperatura de -100°C a +100°C e calcule erros percentuais.",
                                    "Compare dados experimentais de sensores reais sob diferentes temperaturas.",
                                    "Discuta mecanismos físicos como expansão térmica e mudança de bandgap."
                                  ],
                                  "verification": "Calcule e grafique o erro de medição para ΔT = 50°C em um sensor típico.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de planilha (Excel ou Python com Matplotlib)",
                                    "Dados de temperatura de sensores (dataset online)",
                                    "Artigos sobre fotodiodos espaciais"
                                  ],
                                  "tips": "Use curvas de calibração fornecidas por fabricantes como NASA para validação.",
                                  "learningObjective": "Quantificar e modelar o efeito térmico na precisão das medições solares.",
                                  "commonMistakes": "Negligenciar histerese térmica; assumir linearidade em faixas extremas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar o envelhecimento de materiais nos sensores solares",
                                  "subSteps": [
                                    "Identifique mecanismos de degradação: radiação cósmica, UV e oxidação.",
                                    "Estude curvas de degradação ao longo do tempo (ex: perda de 2% de eficiência por ano).",
                                    "Modele a redução de eficiência η(t) = η_0 * e^(-kt) para envelhecimento exponencial.",
                                    "Analise casos de sensores em missões como Hubble ou ISS.",
                                    "Proponha métodos de monitoramento in-orbit para detectar envelhecimento precoce."
                                  ],
                                  "verification": "Preveja a vida útil de um sensor com base em dados de degradação e compare com missões reais.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Relatórios de missões espaciais (NASA archives)",
                                    "Gráficos de degradação de materiais",
                                    "Ferramenta de modelagem simples (Python)"
                                  ],
                                  "tips": "Foque em materiais como silício ou GaAs, comuns em sensores espaciais.",
                                  "learningObjective": "Entender e quantificar como o envelhecimento afeta a precisão a longo prazo.",
                                  "commonMistakes": "Subestimar efeitos cumulativos de radiação; ignorar revestimentos protetores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar variações da constante solar nas medições",
                                  "subSteps": [
                                    "Defina a constante solar total (TSI) e suas variações cíclicas (11 anos) e curtas (diárias).",
                                    "Colete dados históricos de satélites SORCE ou ACRIM.",
                                    "Calcule o impacto de ±1 W/m² na leitura do sensor.",
                                    "Discuta correlações com atividade solar e manchas solares.",
                                    "Integre modelos de previsão de TSI em simulações de atitude."
                                  ],
                                  "verification": "Ajuste uma medição simulada para variação de TSI de 0.1% e avalie o erro resultante.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Dados TSI de NASA (PMOD/WRC composite)",
                                    "Gráficos de atividade solar",
                                    "Calculadora ou script Python"
                                  ],
                                  "tips": "Use médias móveis para suavizar variações curtas em análises de longo prazo.",
                                  "learningObjective": "Modelar flutuações externas da constante solar e seu efeito na precisão.",
                                  "commonMistakes": "Confundir variações locais (atmosfera) com TSI espacial; ignorar assimetrias hemisféricas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar efeitos ambientais e propor correções para precisão",
                                  "subSteps": [
                                    "Combine modelos de temperatura, envelhecimento e TSI em uma equação de erro composta.",
                                    "Simule cenários reais de missão e calcule precisão cumulativa.",
                                    "Desenvolva algoritmos de calibração dinâmica (ex: lookup tables ou ML).",
                                    "Avalie trade-offs entre complexidade e precisão.",
                                    "Redija um relatório resumindo impactos e recomendações."
                                  ],
                                  "verification": "Demonstre redução de erro >50% com correções aplicadas em simulação.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB ou Python)",
                                    "Templates de relatório",
                                    "Dados integrados dos steps anteriores"
                                  ],
                                  "tips": "Priorize efeitos dominantes por missão (ex: temperatura em LEO).",
                                  "learningObjective": "Sintetizar análises para otimizar precisão de sensores solares em ambiente espacial.",
                                  "commonMistakes": "Sobrestimar independência dos efeitos; negligenciar validação cruzada."
                                }
                              ],
                              "practicalExample": "Em uma simulação de satélite CubeSat, aplique um modelo onde temperatura sobe 30°C devido a eclipse, envelhecimento reduz eficiência em 5% após 2 anos, e TSI varia 0.1% por pico solar; calcule erro de atitude de 2° sem correção, reduzido para 0.5° com modelo integrado.",
                              "finalVerifications": [
                                "Explicar corretamente os três efeitos principais com equações associadas.",
                                "Calcular erros percentuais para cenários dados com precisão <5%.",
                                "Identificar pelo menos duas estratégias de mitigação por efeito.",
                                "Simular e graficar impacto cumulativo em uma ferramenta digital.",
                                "Discutir limitações do modelo em contexto de missão real.",
                                "Comparar com dados de sensores reais de missões espaciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão científica na descrição dos mecanismos físicos (80%+ correção).",
                                "Uso adequado de equações e cálculos quantitativos.",
                                "Profundidade dos substeps com exemplos numéricos.",
                                "Clareza na integração de efeitos e propostas de correção.",
                                "Criatividade em conexões com aplicações reais.",
                                "Qualidade da simulação prática e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Termodinâmica e semicondutores (efeito temperatura).",
                                "Química: Degradação de materiais sob radiação (envelhecimento).",
                                "Astronomia: Ciclos solares e medições heliocêntricas (TSI).",
                                "Engenharia de Controle: Algoritmos de calibração e filtros Kalman.",
                                "Ciência de Dados: Modelagem preditiva e análise de séries temporais."
                              ],
                              "realWorldApplication": "Em satélites como o James Webb Space Telescope, análise precisa desses efeitos garante determinação de atitude com erro <0.01°, essencial para apontamento de instrumentos e comunicações, evitando perda de dados científicos valiosos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Tipos de Sensores Solares",
                        "description": "Classificação e características dos principais sensores solares utilizados em sistemas de determinação de atitude, como sensores grosseiros e finos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Descrever sensores solares grosseiros (CSS)",
                            "description": "Explicar o funcionamento de Coarse Sun Sensors (CSS), que fornecem direção aproximada do sol com campo de visão amplo (até 120°), baseados em furos e detectores de silício.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito básico e a finalidade dos CSS",
                                  "subSteps": [
                                    "Pesquisar a definição de Coarse Sun Sensors (CSS) como sensores que fornecem direção aproximada do sol.",
                                    "Identificar o campo de visão amplo (FOV) típico de até 120°.",
                                    "Explicar a diferença entre sensores solares grosseiros e finos.",
                                    "Relacionar o uso em sistemas de determinação de atitude de veículos espaciais.",
                                    "Anotar aplicações iniciais em missões espaciais de baixo custo."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo o conceito e propósito, comparando com outros sensores solares.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigos sobre sensores solares",
                                    "Vídeos introdutórios de aeroespacial no YouTube",
                                    "Diagrama básico de CSS"
                                  ],
                                  "tips": "Foque no 'grosseiro' como baixa precisão mas alta confiabilidade em ângulos amplos.",
                                  "learningObjective": "Compreender o papel fundamental dos CSS na orientação espacial inicial.",
                                  "commonMistakes": [
                                    "Confundir com sensores finos (FSS)",
                                    "Ignorar o FOV amplo como vantagem principal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os componentes principais do CSS",
                                  "subSteps": [
                                    "Descrever o furo (aperture) como entrada de luz solar.",
                                    "Explicar os detectores de silício (fotodiodos) posicionados atrás do furo.",
                                    "Detalhar o arranjo geométrico: múltiplos detectores para cobrir o hemisfério.",
                                    "Mencionar filtros ópticos opcionais para bloquear radiação não solar.",
                                    "Esboçar um diagrama simples mostrando furo e detectores."
                                  ],
                                  "verification": "Listar e desenhar os 4 componentes principais com funções breves.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas de CSS de fontes como NASA ou ESA",
                                    "Papel e caneta para esboço",
                                    "Simulador online de óptica básica"
                                  ],
                                  "tips": "Visualize o furo como uma pinhole camera primitiva.",
                                  "learningObjective": "Dominar a composição física dos CSS.",
                                  "commonMistakes": [
                                    "Omitir o papel dos múltiplos detectores",
                                    "Confundir silício com outros materiais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o princípio de funcionamento",
                                  "subSteps": [
                                    "Descrever como a luz solar passa pelo furo e ilumina detectores específicos.",
                                    "Explicar que o detector mais iluminado indica a direção do sol.",
                                    "Detalhar o cálculo da direção via intensidade relativa dos sinais.",
                                    "Simular com exemplo: sol em 45° ilumina detector Y mais que X.",
                                    "Discutir processamento do sinal analógico para digital."
                                  ],
                                  "verification": "Simular verbalmente ou por desenho o que acontece com o sol em diferentes posições.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Vídeo animado de funcionamento de CSS",
                                    "Software como MATLAB para simulação simples",
                                    "Luz e modelo físico caseiro (caixa com furos)"
                                  ],
                                  "tips": "Pense em termos de sombra projetada pelo furo nos detectores.",
                                  "learningObjective": "Entender o mecanismo óptico-elétrico de detecção.",
                                  "commonMistakes": [
                                    "Ignorar variação de intensidade",
                                    "Assumir precisão angular fina"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar características, vantagens e limitações",
                                  "subSteps": [
                                    "Listar vantagens: baixo custo, robustez, FOV amplo.",
                                    "Descrever limitações: precisão grosseira (±10°), sensível a obstruções.",
                                    "Comparar com FSS em termos de precisão e complexidade.",
                                    "Mencionar calibração e fatores ambientais (temperatura, radiação).",
                                    "Resumir em tabela comparativa."
                                  ],
                                  "verification": "Criar uma tabela com 5 prós, 5 contras e 1 comparação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabelas de especificações de CSS reais",
                                    "Folha de cálculo (Excel/Google Sheets)",
                                    "Documentos de missões espaciais"
                                  ],
                                  "tips": "Lembre que CSS é para 'backup' ou aquisição inicial de atitude.",
                                  "learningObjective": "Avaliar contextualmente os CSS em sistemas espaciais.",
                                  "commonMistakes": [
                                    "Superestimar precisão",
                                    "Esquecer impacto de eclipse solar"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat como o PocketQube, quatro CSS montados orthogonalmente detectam o sol: se o detector frontal recebe máxima intensidade, o sol está diretamente à frente, permitindo rotação inicial do satélite para painéis solares.",
                              "finalVerifications": [
                                "Descrever verbalmente o caminho da luz do sol através do CSS.",
                                "Explicar por que o FOV de 120° é crucial para aquisição rápida.",
                                "Identificar o detector iluminado para uma direção solar dada.",
                                "Listar 3 limitações e como mitigá-las.",
                                "Desenhar diagrama completo de um CSS.",
                                "Comparar CSS com Star Tracker em precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do princípio óptico (80% corretude).",
                                "Detalhamento de componentes com funções corretas.",
                                "Explicação clara de sinal para direção angular.",
                                "Identificação correta de vantagens/limitações.",
                                "Uso de exemplos reais ou diagramas.",
                                "Compreensão de contexto em determinação de atitude."
                              ],
                              "crossCurricularConnections": [
                                "Física Óptica: Princípio da câmara pinhole.",
                                "Eletrônica: Fotodiodos de silício e amplificação de sinal.",
                                "Matemática: Geometria esférica para FOV e vetores de direção.",
                                "Engenharia de Materiais: Resistência a vácuo e radiação.",
                                "Programação: Processamento de sinais em embedded systems."
                              ],
                              "realWorldApplication": "CSS são usados em satélites como o GOES da NOAA para orientação de emergência durante falhas de giroscópios, garantindo apontamento de antenas e painéis solares em órbita geoestacionária."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Caracterizar sensores solares finos (FSS)",
                            "description": "Detalhar Fine Sun Sensors (FSS), incluindo óptica com lentes e arrays de CCD para precisão angular de até 0.01°, e processamento de sinal para vetor solar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes ópticos dos FSS",
                                  "subSteps": [
                                    "Estudar o papel das lentes (geralmente asféricas) na focalização da luz solar em um ponto ou linha no plano focal.",
                                    "Analisar a geometria óptica, incluindo distância focal e campo de visão (FOV) típico de 30° a 60°.",
                                    "Identificar como as lentes minimizam aberrações cromáticas e esféricas para precisão angular.",
                                    "Calcular o tamanho da imagem solar no plano focal usando fórmulas ópticas básicas.",
                                    "Explorar filtros ópticos para bloquear intensidade excessiva da luz solar."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama óptico do FSS, explicando o caminho da luz solar.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Diagramas de FSS de referências como NASA ou ESA",
                                    "Software de simulação óptica (ex: OpticStudio gratuito)",
                                    "Calculadora ou planilha para fórmulas ópticas"
                                  ],
                                  "tips": "Use raios principais para simplificar cálculos iniciais de focalização.",
                                  "learningObjective": "Dominar os princípios ópticos que permitem resolução angular fina nos FSS.",
                                  "commonMistakes": [
                                    "Confundir campo de visão (FOV) com resolução angular",
                                    "Ignorar o impacto de temperaturas espaciais nas lentes",
                                    "Subestimar a necessidade de filtros anti-saturação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o funcionamento dos arrays de CCD",
                                  "subSteps": [
                                    "Descrever a estrutura de um array CCD: pixels, conversão fotoelétrica e leitura serial.",
                                    "Explicar como o sol focalizado ilumina uma faixa de pixels no CCD, criando um perfil de intensidade.",
                                    "Estudar a resolução espacial do CCD (ex: 1024x1024 pixels) e sua relação com precisão de 0.01°.",
                                    "Simular o perfil de intensidade gaussiano ou trapezoidal gerado pela imagem solar.",
                                    "Discutir calibração do CCD para ruído térmico e dark current em ambiente espacial."
                                  ],
                                  "verification": "Gerar um gráfico simulado do perfil de intensidade em pixels usando Python ou MATLAB.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação técnica de CCDs espaciais (ex: datasheets de E2V)",
                                    "Python com bibliotecas NumPy/Matplotlib",
                                    "Tutoriais sobre imageamento CCD"
                                  ],
                                  "tips": "Comece com simulações 1D para simplificar o perfil solar.",
                                  "learningObjective": "Entender como o CCD converte luz em dados digitais para medição angular.",
                                  "commonMistakes": [
                                    "Confundir saturação de pixels com ruído",
                                    "Ignorar não-linearidades na resposta fotoelétrica",
                                    "Esquecer calibração para radiação cósmica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o processamento de sinal para vetor solar",
                                  "subSteps": [
                                    "Implementar algoritmos de centroiding (ex: centro de massa ponderado) para encontrar o centro da imagem solar.",
                                    "Calcular o ângulo solar a partir da posição do centroide nos eixos X e Y do CCD.",
                                    "Analisar técnicas de filtragem (ex: Kalman) para reduzir ruído e melhorar precisão a 0.01°.",
                                    "Explicar a conversão de pixels para ângulos usando matriz de calibração pré-lançamento.",
                                    "Simular processamento em tempo real considerando taxa de amostragem (ex: 10 Hz)."
                                  ],
                                  "verification": "Codificar e testar um script simples de centroiding com dados simulados, obtendo erro <0.01°.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código exemplo em Python para processamento de sinal",
                                    "Ferramentas como MATLAB Signal Processing Toolbox ou SciPy",
                                    "Dados de teste de FSS públicos"
                                  ],
                                  "tips": "Use pesos gaussianos no centroiding para robustez contra bordas da imagem.",
                                  "learningObjective": "Mestrar algoritmos que transformam dados brutos em vetor solar preciso.",
                                  "commonMistakes": [
                                    "Usar centroiding simples sem filtragem de ruído",
                                    "Erro na escala pixel-ângulo sem calibração",
                                    "Sobrecarregar processamento em hardware embarcado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar caracterização completa e validar precisão",
                                  "subSteps": [
                                    "Combinar óptica, CCD e processamento em um modelo end-to-end do FSS.",
                                    "Avaliar precisão total de 0.01° considerando erros cumulativos (ópticos, CCD, sinal).",
                                    "Estudar montagem multi-FSS (ex: 6 unidades) para vetor solar completo 3D.",
                                    "Realizar simulação de determinação de atitude usando vetor solar em conjunto com outros sensores.",
                                    "Documentar limitações como obstrução pelo sol ou degradação por radiação."
                                  ],
                                  "verification": "Produzir um relatório com simulação integrada mostrando precisão angular alcançada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação de atitude (ex: Orekit ou GMAT)",
                                    "Referências de missões reais (ex: CubeSat com FSS)",
                                    "Planilha para análise de erro orçamentária"
                                  ],
                                  "tips": "Monitore o orçamento de erro em cada subsistema para otimização.",
                                  "learningObjective": "Caracterizar integralmente o FSS para aplicações em controle de atitude.",
                                  "commonMistakes": [
                                    "Ignorar alinhamento entre múltiplos FSS",
                                    "Superestimar precisão sem validação experimental",
                                    "Esquecer dependência de modelo orbital para validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat como o ESTCube-1, o FSS usa lentes asféricas e CCD de 512x512 pixels para capturar o sol, processando o centroid com algoritmo de centro de massa para fornecer vetor solar com precisão de 0.01°, essencial para deploy de velas solares.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo de luz solar ao vetor de atitude.",
                                "Simular e calcular precisão angular de 0.01° em cenário com ruído.",
                                "Identificar 3 limitações reais dos FSS em órbita.",
                                "Desenhar esquema de montagem de 6 FSS para cobertura 4π.",
                                "Comparar FSS com outros sensores solares (ex: coarse sun sensors).",
                                "Validar modelo simulado contra dados públicos de missões."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na descrição de componentes ópticos e CCD (80% cobertura).",
                                "Correção matemática em cálculos de centroiding e ângulos (erro <0.001° em simulações).",
                                "Profundidade no processamento de sinal, incluindo tratamento de ruído.",
                                "Integração coerente de subsistemas em caracterização end-to-end.",
                                "Uso de exemplos reais e análise de erros realistas.",
                                "Clareza em diagramas, códigos e relatórios produzidos."
                              ],
                              "crossCurricularConnections": [
                                "Física Óptica: Aberrações e focalização de luz.",
                                "Eletrônica: Arquitetura e ruído em detectores CCD/CMOS.",
                                "Processamento de Sinais Digitais: Algoritmos de estimação e filtragem.",
                                "Matemática Computacional: Geometria vetorial e otimização.",
                                "Engenharia de Sistemas: Integração de sensores em veículos espaciais."
                              ],
                              "realWorldApplication": "FSS são cruciais em satélites como os da constelação Starlink ou missões da NASA (ex: James Webb Space Telescope auxiliares), fornecendo medições precisas do vetor solar para controle de atitude autônomo, estabilização e orientação solar em ambientes hostis do espaço."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Comparar sensores solares com outros sensores de atitude",
                            "description": "Comparar sensores solares com sensores terrestres infravermelho e de estrelas em termos de precisão, campo de visão e disponibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os princípios de funcionamento dos sensores solares, terrestres IR e de estrelas",
                                  "subSteps": [
                                    "Pesquise o funcionamento básico dos sensores solares: detecção de direção do Sol via painéis ou fotorresistores.",
                                    "Estude sensores terrestres infravermelho (IR): rastreamento do horizonte terrestre emitindo IR para detectar limbos.",
                                    "Analise sensores de estrelas: uso de catálogos estelares e CCDs para medir posições de estrelas conhecidas.",
                                    "Identifique limitações iniciais: eclipse solar para sensores solares, obstruções terrestres para IR, e necessidade de céu claro para estrelas.",
                                    "Registre definições chave em um documento de notas."
                                  ],
                                  "verification": "Resuma em 3-5 frases por sensor se você compreende o princípio e limitações principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigos ou PDFs sobre sensores de atitude (NASA ou textbooks como 'Spacecraft Attitude Determination'), caderno de notas, acesso à internet."
                                  ],
                                  "tips": "Use diagramas visuais para ilustrar campos de visão e detecções.",
                                  "learningObjective": "Compreender os mecanismos fundamentais de cada sensor para basear comparações precisas.",
                                  "commonMistakes": "Confundir sensores solares com painéis solares de energia; foque em sensores de atitude."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar dados quantitativos sobre precisão, campo de visão (FOV) e disponibilidade",
                                  "subSteps": [
                                    "Busque especificações típicas: precisão solar (~0.1-1°), FOV amplo (180° ou hemisférico).",
                                    "Colete para IR terrestre: precisão (~0.05-0.2°), FOV estreito (tipicamente 30-60° por sensor).",
                                    "Reúna para estrelas: precisão alta (~0.001-0.01°), FOV estreito (10-20°).",
                                    "Anote disponibilidade: solar (alta, exceto eclipse), IR (boa em órbita LEO, ruim em alta altitude), estrelas (alta em céu escuro, baixa em luz diurna).",
                                    "Crie uma tabela inicial com valores numéricos de fontes confiáveis."
                                  ],
                                  "verification": "Preencha uma tabela com pelo menos 3 métricas por sensor e fonte citada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de cálculo (Excel/Google Sheets), referências técnicas (ex: 'Analytical Mechanics of Space Systems' de Schaub, sites da NASA/ESA)."
                                  ],
                                  "tips": "Priorize dados de missões reais como valores médios para realismo.",
                                  "learningObjective": "Adquirir dados empíricos padronizados para comparações objetivas.",
                                  "commonMistakes": "Usar dados genéricos sem fontes; sempre cite origens."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar comparação lado a lado nos três parâmetros chave",
                                  "subSteps": [
                                    "Compare precisão: estrelas > IR > solar; discuta impactos em controle de atitude.",
                                    "Analise FOV: solar amplo vs. IR/estrelas estreitos; implique redundância necessária.",
                                    "Avalie disponibilidade: solar/IR diurnos vs. estrelas noturnos; considere cobertura orbital.",
                                    "Crie gráficos ou tabelas comparativas destacando diferenças percentuais.",
                                    "Identifique cenários onde um supera os outros (ex: eclipse para solar)."
                                  ],
                                  "verification": "Gere uma tabela ou gráfico comparativo com conclusões qualitativas por parâmetro.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software de planilhas ou ferramentas como Tableau/Matplotlib, dados do Step 2."
                                  ],
                                  "tips": "Use cores para destacar forças/fraquezas em tabelas.",
                                  "learningObjective": "Desenvolver habilidade em análise comparativa quantitativa e qualitativa.",
                                  "commonMistakes": "Ignorar contextos orbitais; sempre relacione a regimes específicos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar trade-offs, prós/contras e recomendações de uso",
                                  "subSteps": [
                                    "Liste prós/contras: solar (barato, robusto mas impreciso), IR (preciso, mas sensível a nuvens), estrelas (muito preciso, caro/complexo).",
                                    "Discuta combinações híbridas em sistemas reais.",
                                    "Avalie custo-benefício para missões (ex: CubeSats vs. satélites grandes).",
                                    "Formule recomendações baseadas em precisão vs. custo/FOV.",
                                    "Escreva um parágrafo resumo da comparação geral."
                                  ],
                                  "verification": "Produza um relatório de 1 página com trade-offs e uma recomendação hipotética.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documento de texto ou slides, dados dos steps anteriores."
                                  ],
                                  "tips": "Pense em fusão de sensores (Kalman filter) para integrações.",
                                  "learningObjective": "Aplicar análise para decisões de design em sistemas espaciais.",
                                  "commonMistakes": "Ser muito subjetivo; ancorar em dados quantitativos."
                                }
                              ],
                              "practicalExample": "Em um CubeSat em órbita LEO, compare sensores: use solar para aquisição rápida inicial (FOV amplo), IR para precisão média durante passes terrestres, e estrelas para calibração noturna de alta precisão, simulando cobertura 24h com redundância.",
                              "finalVerifications": [
                                "Pode listar precisão típica de cada sensor com margens de erro?",
                                "Descreve FOV e impactos em cobertura orbital?",
                                "Explica disponibilidade em diferentes fases orbitais/orbitas?",
                                "Identifica pelo menos 2 cenários onde solar é preferível?",
                                "Cria tabela comparativa correta sem erros factuais?",
                                "Discute trade-offs em um sistema híbrido?"
                              ],
                              "assessmentCriteria": [
                                "Precisão factual dos dados (90%+ acurácia com fontes)",
                                "Profundidade da comparação (cobertura completa de 3 parâmetros)",
                                "Uso de visualizações/tabulares para clareza",
                                "Análise qualitativa equilibrada (prós/contras evidentes)",
                                "Recomendações contextuais realistas",
                                "Estrutura lógica e completude dos steps"
                              ],
                              "crossCurricularConnections": [
                                "Física: Óptica e detecção de radiação (IR, visível)",
                                "Engenharia: Design de sistemas embarcados e fusão de sensores",
                                "Matemática: Estatística para análise de precisão e filtros Kalman",
                                "Programação: Simulação de atitude em Python/MATLAB"
                              ],
                              "realWorldApplication": "Na missão Hubble Space Telescope, sensores de estrelas fornecem precisão arcsegundo para apontamento, complementados por solares/IR para aquisição; em CubeSats como o MarCO da NASA, solares/IR são priorizados por custo/FOV em missões de baixo orçamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.4",
                            "name": "Selecionar sensores solares para missões específicas",
                            "description": "Avaliar critérios como FOV, resolução angular e redundância para escolher sensores solares adequados a órbitas LEO ou GEO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Requisitos da Missão Espacial",
                                  "subSteps": [
                                    "Identifique o tipo de órbita (LEO ou GEO) e suas características principais, como altitude, período orbital e exposição solar.",
                                    "Determine os objetivos da determinação de atitude, como precisão necessária (±1° ou ±5°).",
                                    "Liste fatores ambientais como ciclos de eclipse, radiação e velocidade angular do Sol.",
                                    "Especifique restrições de massa, potência e volume para o sensor.",
                                    "Documente os requisitos em uma tabela comparativa."
                                  ],
                                  "verification": "Confira se a tabela de requisitos cobre órbita, precisão, ambiente e restrições físicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Documentação de missões espaciais (NASA/ESA), calculadora orbital online (ex: Heavens-Above).",
                                  "tips": "Comece com missões reais como ISS (LEO) para contextualizar.",
                                  "learningObjective": "Compreender como os requisitos da missão influenciam a escolha de sensores.",
                                  "commonMistakes": "Ignorar ciclos de eclipse em LEO, que reduzem disponibilidade solar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Critérios Técnicos Chave",
                                  "subSteps": [
                                    "Defina FOV mínimo baseado na taxa de rotação da spacecraft (ex: >30° para LEO rápida).",
                                    "Calcule resolução angular necessária (ex: <0.1° para alta precisão em GEO).",
                                    "Avalie redundância: pelo menos 2-3 sensores para falha tolerante.",
                                    "Considere outros specs: linearidade, faixa dinâmica, tempo de resposta e sensibilidade à temperatura.",
                                    "Priorize critérios em uma matriz de decisão ponderada."
                                  ],
                                  "verification": "Verifique se a matriz inclui pesos para cada critério (ex: FOV 30%, resolução 25%).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Datasheets de sensores solares (ex: Adcole, Sinclair Interplanetary), planilha Excel/Google Sheets.",
                                  "tips": "Use fórmulas: FOV > 2 * (velocidade angular Sol * tempo amostragem).",
                                  "learningObjective": "Mapear specs técnicas aos requisitos da missão.",
                                  "commonMistakes": "Subestimar redundância, levando a single point of failure."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Pesquisar e Comparar Sensores Disponíveis",
                                  "subSteps": [
                                    "Compile lista de sensores comerciais (ex: Coarse Sun Sensor - CSS, Fine Sun Sensor - FSS).",
                                    "Preencha matriz de decisão com dados reais de FOV, resolução, massa, potência.",
                                    "Calcule scores normalizados para cada sensor por critério.",
                                    "Simule performance em software (ex: STK para órbitas).",
                                    "Identifique top 3 candidatos."
                                  ],
                                  "verification": "Scores calculados corretamente e top 3 justificados na matriz.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Catálogos de fornecedores (Honeywell, Blue Canyon), software STK ou GMAT gratuito.",
                                  "tips": "Foquem em COTS (Commercial Off-The-Shelf) para custo-benefício.",
                                  "learningObjective": "Comparar quantitativamente opções de hardware espacial.",
                                  "commonMistakes": "Comparar apples-to-oranges, ignorando unidades consistentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar Sensor e Planejar Integração",
                                  "subSteps": [
                                    "Escolha o sensor vencedor baseado na pontuação mais alta.",
                                    "Planeje configuração: montagem, calibração e redundância (ex: 4 sensores em tetraedro).",
                                    "Estime custo total e impacto no budget da missão.",
                                    "Desenvolva plano de teste em solo (ex: mesa giratória).",
                                    "Documente relatório final com justificativa."
                                  ],
                                  "verification": "Relatório inclui seleção, config e testes propostos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Template de relatório, ferramentas de CAD para mockup (ex: SolidWorks).",
                                  "tips": "Sempre inclua margem de erro de 20% em estimativas.",
                                  "learningObjective": "Justificar escolhas técnicas para equipes multidisciplinares.",
                                  "commonMistakes": "Não considerar integração com outros sensores como star trackers."
                                }
                              ],
                              "practicalExample": "Para um CubeSat em LEO (500km, 90min órbita), selecione um CSS com FOV 110°, resolução 1°, 3 unidades redundantes (ex: Sinclair Interplanetary CSS-50), priorizando baixa massa (10g/un) sobre precisão fina, evitando blackout em eclipses.",
                              "finalVerifications": [
                                "Matriz de decisão completa com scores >80% para sensor selecionado.",
                                "Simulação orbital confirma cobertura solar >95%.",
                                "Relatório justifica escolha vs. alternativas.",
                                "Plano de redundância cobre falhas únicas.",
                                "Estimativas de massa/potência dentro do budget.",
                                "Testes em solo definidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de requisitos orbitais (30%).",
                                "Correção quantitativa de critérios (FOV, resolução) (25%).",
                                "Qualidade da matriz comparativa e scores (20%).",
                                "Justificativa robusta da seleção (15%).",
                                "Planejamento de integração e testes (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Óptica: Princípios de lentes e detecção angular.",
                                "Eletrônica: Análise de consumo de potência e interfaces I2C.",
                                "Programação: Simulações em Python/MATLAB para performance.",
                                "Gestão de Projetos: Matrizes de decisão e trade-offs."
                              ],
                              "realWorldApplication": "Em missões como o satélite Amazônia-1 (LEO, INPE), sensores solares CSS foram selecionados para atitude robusta em órbitas eclipse-prone, garantindo comunicação precisa com estações terrestres."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Técnicas de Determinação de Atitude com Sensores Solares",
                        "description": "Métodos de processamento de dados de sensores solares para estimar a matriz de atitude do veículo espacial em relação ao referencial inercial.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Processar sinais de múltiplos sensores solares",
                            "description": "Combinar medições de 2 ou mais sensores não coplanares para determinar o vetor unitário do sol no referencial do corpo (body frame).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Geometria e Princípios de Medição dos Sensores Solares",
                                  "subSteps": [
                                    "Estude o modelo matemático de um sensor solar: medição s_i proporcional a cos(θ_i) = u · n_i, onde u é o vetor unitário do sol e n_i a normal unitária do sensor.",
                                    "Analise a configuração não coplanar: pelo menos 3 sensores cujas normais não estão no mesmo plano para determinação única de u.",
                                    "Revise calibração: normalizar medições para obter valores entre 0 e 1, considerando sombreamento e offsets.",
                                    "Visualize geometricamente: cada medição define um cone ao redor da normal do sensor.",
                                    "Discuta limitações: sensores cegos quando sol oposto (s_i ≈ 0)."
                                  ],
                                  "verification": "Desenhe um diagrama 3D mostrando 3 sensores não coplanares e o vetor u satisfazendo as medições.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação técnica de sensores solares (ex: ADCS CubeSat)",
                                    "Software de visualização 3D como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": [
                                    "Use vetores unitários sempre para evitar erros de escala.",
                                    "Comece com 3 sensores ortogonais para intuição."
                                  ],
                                  "learningObjective": "Dominar o modelo físico-matemático das medições de sensores solares e requisitos geométricos para resolução única.",
                                  "commonMistakes": [
                                    "Assumir sensores coplanares, levando a ambiguidade.",
                                    "Ignorar normalização das medições, causando inconsistências numéricas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Pré-processar Sinais dos Sensores",
                                  "subSteps": [
                                    "Colete medições brutas s_raw de pelo menos 3 sensores não coplanares.",
                                    "Aplique calibração: s_i = (s_raw_i - offset_i) / scale_i, garantindo 0 ≤ s_i ≤ 1.",
                                    "Filtre ruído usando média móvel ou filtro Kalman simples.",
                                    "Verifique validade: descarte amostras onde todos s_i < threshold (sol invisível).",
                                    "Armazene em vetor de medições S = [s1, s2, s3]^T e matriz de normais N = [n1, n2, n3]."
                                  ],
                                  "verification": "Implemente um script que leia dados simulados e produza S normalizado e N.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados simulados ou reais de sensores (CSV)",
                                    "Python com NumPy/Pandas"
                                  ],
                                  "tips": [
                                    "Sempre valide soma de s_i > 0 para evitar processamento inválido.",
                                    "Use threshold adaptativo baseado em órbita."
                                  ],
                                  "learningObjective": "Preparar dados de sensores de forma robusta para o processamento posterior.",
                                  "commonMistakes": [
                                    "Não normalizar, levando a soluções não unitárias.",
                                    "Processar dados com sol eclipsado, gerando vetores errados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e Resolver o Sistema de Equações Não Lineares",
                                  "subSteps": [
                                    "Formule o problema: encontrar u tal que ||u||=1 e s_i ≈ u · n_i para i=1..m (m≥3).",
                                    "Linearize aproximando: para pequenos ângulos, mas prefira método exato via otimização.",
                                    "Use least squares: min ||N^T u - S||^2 sujeito a ||u||=1 (QUEST ou método analítico).",
                                    "Implemente solução analítica para 3 sensores: resolver interseção de cones.",
                                    "Aplique método numérico (ex: fmincon no MATLAB ou scipy.optimize) se m>3."
                                  ],
                                  "verification": "Resolva manualmente para um caso toy com normais ortogonais e verifique u · n_i = s_i.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB ou Python (SciPy, NumPy)",
                                    "Referência: 'Spacecraft Attitude Determination and Control' de Wertz"
                                  ],
                                  "tips": [
                                    "Para 3 sensores, use fórmula fechada envolvendo produto triplo escalar.",
                                    "Inclua regularização para ruído alto."
                                  ],
                                  "learningObjective": "Derivar e aplicar algoritmos matemáticos para estimar u a partir de medições multi-sensores.",
                                  "commonMistakes": [
                                    "Esquecer restrição ||u||=1, resultando em vetores não unitários.",
                                    "Usar pseudoinverso simples sem Lagrange para norma."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, Simular e Validar a Solução",
                                  "subSteps": [
                                    "Codifique o algoritmo completo em Python/MATLAB: input N, S → output u.",
                                    "Simule cenários: varie posição do sol e adicione ruído gaussiano (σ=0.05).",
                                    "Compare com verdade terrestre: compute erro angular acos(u · u_true).",
                                    "Teste edge cases: sensores quase coplanares, um sensor cego.",
                                    "Gere relatório com histogramas de erro e convergência."
                                  ],
                                  "verification": "Execute 100 simulações e confirme erro médio < 5 graus.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código template em GitHub (ex: pyADCS)",
                                    "Ferramentas de plotagem (Matplotlib/Plotly)"
                                  ],
                                  "tips": [
                                    "Vetorize operações com NumPy para eficiência.",
                                    "Salve u em quaternion para integração com sistemas de atitude."
                                  ],
                                  "learningObjective": "Desenvolver uma implementação funcional e validada do processador de sensores solares.",
                                  "commonMistakes": [
                                    "Não adicionar ruído nas simulações, superestimando precisão.",
                                    "Ignorar rotação do body frame nas simulações."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e Integrar em um Sistema de Determinação de Atitude",
                                  "subSteps": [
                                    "Otimize performance: reduza tempo de computação para <1ms por ciclo.",
                                    "Integre com outros sensores (ex: magnetômetro) via fusão sensorial.",
                                    "Implemente detecção de falhas: rejeite u se erro residual > threshold.",
                                    "Teste em loop fechado com simulação de dinâmica orbital (ex: Orekit).",
                                    "Documente API para uso em flight software."
                                  ],
                                  "verification": "Demonstre integração em simulação full: attitude converge em <10s.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Simulador orbital (Orekit, GMAT)",
                                    "Flight software framework (ex: FSW CubeSat)"
                                  ],
                                  "tips": [
                                    "Use C++ para versão embarcada após protótipo Python.",
                                    "Monitore covariância de u para confiança."
                                  ],
                                  "learningObjective": "Aplicar o processador em contexto real de controle de atitude espacial.",
                                  "commonMistakes": [
                                    "Sobrecarga computacional em microcontroladores.",
                                    "Não considerar taxa de amostragem (tipicamente 1-10 Hz)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat com 3 sensores solares nas faces XY, XZ, YZ (normais [1,0,0], [0,1,0], [0,0,1]), medições S=[0.8, 0.6, 0.2]. Resolva para u ≈ [0.745, 0.559, 0.372], verificando u · n1=0.8, etc., com erro angular <2° em simulação com ruído.",
                              "finalVerifications": [
                                "||u|| = 1 dentro de 1e-6.",
                                "Erro de projeção max |u · n_i - s_i| < 0.05 para todos i.",
                                "Ângulo com verdade terrestre <5° em 95% das simulações.",
                                "Tempo de processamento <10ms.",
                                "Detecção correta de 100% dos casos inválidos (todos s_i<0.1).",
                                "Consistência com outros sensores (ex: gyro drift <0.1°/s)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa: erro angular médio <3° com ruído σ=0.03.",
                                "Robustez: taxa de sucesso >98% em 1000 simulações variadas.",
                                "Eficiência computacional: <5ms em hardware embarcado (RPi).",
                                "Qualidade do código: modular, comentado, com testes unitários.",
                                "Correção matemática: derivar solução analítica para caso 3 sensores.",
                                "Documentação: relatório com análise de sensibilidade a ruído."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: resolução de sistemas com restrições (método dos multiplicadores de Lagrange).",
                                "Programação Numérica: otimização não linear (SciPy, MATLAB Optimization Toolbox).",
                                "Física Astronômica: modelo de irradiância solar e geometria orbital.",
                                "Processamento de Sinais: filtragem de ruído e validação de sensores.",
                                "Controle Automático: fusão sensorial para estimação de estado."
                              ],
                              "realWorldApplication": "Em satélites como o CubeSat da NASA MarCO, processadores de sensores solares fornecem estimativas de atitude de baixo custo e alta taxa de atualização, essenciais para pointing de antenas e painéis solares durante missões interplanetárias, reduzindo dependência de rodas de reação caras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Implementar algoritmos de estimação de atitude",
                            "description": "Aplicar métodos como TRIAD ou QUEST para fusão de vetor solar com outros sensores, calculando ângulos de Euler ou quaternions de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Determinação de Atitude com Sensores Solares",
                                  "subSteps": [
                                    "Estude o conceito de vetor solar e sua direção de referência inercial (ex: Sun Vector em J2000).",
                                    "Revise medições de sensores solares (coarse sun sensors ou fine sun sensors) e ruído associado.",
                                    "Entenda a representação de atitude via quaternions e ângulos de Euler.",
                                    "Analise limitações de sensores solares isolados (degenerescência em 90 graus)."
                                  ],
                                  "verification": "Crie um diagrama explicando o processo de observação solar e representações de atitude.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação de sensores solares (NASA/ESA papers)",
                                    "Livro 'Spacecraft Attitude Determination and Control' de Wertz",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use visualizações 3D para entender rotações de atitude.",
                                  "learningObjective": "Compreender como vetores solares fornecem informações parciais de atitude.",
                                  "commonMistakes": [
                                    "Ignorar o ruído nos sensores solares",
                                    "Confundir coordenadas corpo com inerciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Algoritmo TRIAD",
                                  "subSteps": [
                                    "Revise a matemática do TRIAD: seleção de vetores observados e de referência.",
                                    "Aprenda a construir matriz de direção usando produto cruzado mínimo.",
                                    "Estude cálculo do quaternion de atitude a partir da matriz de rotação.",
                                    "Implemente fórmulas analíticas em pseudocódigo."
                                  ],
                                  "verification": "Derive manualmente a matriz de rotação para um exemplo simples de dois vetores.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigo original TRIAD (Shuster 1978)",
                                    "SciPy/NumPy reference para vetores",
                                    "Simulador orbital como Orekit ou GMAT"
                                  ],
                                  "tips": "TRIAD é ótimo para iniciantes por ser determinístico e simples.",
                                  "learningObjective": "Dominar o algoritmo TRIAD para estimação básica de atitude.",
                                  "commonMistakes": [
                                    "Erro na normalização de vetores",
                                    "Seleção errada do par de vetores (usar o menor produto cruzado)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar TRIAD em Código com Dados de Sensores Solares",
                                  "subSteps": [
                                    "Colete ou simule dados: vetor solar medido e referência.",
                                    "Code a função para produto cruzado e construção da matriz B.",
                                    "Calcule a matriz de rotação via SVD e extraia quaternion.",
                                    "Teste com dados ruidosos adicionando Gaussian noise."
                                  ],
                                  "verification": "Execute o código e verifique se norma do quaternion é 1.0 ± 0.01.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy, SciPy",
                                    "Dados simulados de sensores (gerados via script)",
                                    "MATLAB Aerospace Toolbox (opcional)"
                                  ],
                                  "tips": "Use funções vetoriais para eficiência; evite loops.",
                                  "learningObjective": "Implementar funcionalmente o TRIAD processando dados reais/simulados.",
                                  "commonMistakes": [
                                    "Não tratar casos singulares (vetores colineares)",
                                    "Inversão errada da ordem de vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir QUEST e Fusão com Outros Sensores",
                                  "subSteps": [
                                    "Estude QUEST: minimização de custo via Rayleigh quotient.",
                                    "Integre segundo sensor (ex: magnetômetro) para observabilidade completa.",
                                    "Implemente iteração QUEST para quaternion ótimo.",
                                    "Funda dados multi-sensores com pesos baseados em covariâncias."
                                  ],
                                  "verification": "Compare resultados TRIAD vs QUEST; QUEST deve ter menor erro.",
                                  "estimatedTime": "3.5 horas",
                                  "materials": [
                                    "Código QUEST de referência (GitHub repos aeroespaciais)",
                                    "Dados de magnetômetro simulados",
                                    "Ferramentas de plotagem: Matplotlib/Plotly"
                                  ],
                                  "tips": "QUEST é mais robusto para múltiplos vetores; ajuste pesos por precisão do sensor.",
                                  "learningObjective": "Aplicar QUEST para fusão sensorial melhorada.",
                                  "commonMistakes": [
                                    "Convergência ruim sem inicialização boa (use TRIAD)",
                                    "Ignorar covariâncias nos pesos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Converter para Ângulos de Euler e Validar Implementação",
                                  "subSteps": [
                                    "Implemente conversão quaternion para Euler angles (ZYX convention).",
                                    "Gere plots de atitude ao longo do tempo (simulação orbital).",
                                    "Valide contra verdade de navegação (truth data).",
                                    "Calcule métricas de erro (RMS em graus)."
                                  ],
                                  "verification": "Erros RMS < 5 graus em simulação sem ruído pesado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Funções de conversão quaternion-Euler (SciPy.spatial.transform)",
                                    "Simulador de órbita (ex: poliastro Python)",
                                    "Dados de verdade de missão CubeSat"
                                  ],
                                  "tips": "Cuidado com gimbal lock em Euler; prefira quaternions para armazenamento.",
                                  "learningObjective": "Finalizar pipeline completo com validação quantitativa.",
                                  "commonMistakes": [
                                    "Erro de sinal em conversões de rotação",
                                    "Não plotar para inspeção visual"
                                  ]
                                },
                                {
                                  "stepNumber": 6,
                                  "title": "Testes e Otimização Final",
                                  "subSteps": [
                                    "Crie cenários de teste: eclipse solar, falha de sensor.",
                                    "Otimize código para tempo real (vectorize).",
                                    "Documente código com comentários e exemplos.",
                                    "Exporte resultados para relatório."
                                  ],
                                  "verification": "Todos testes passam; tempo de execução < 1ms por ciclo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Unit test framework (pytest)",
                                    "Profiler (cProfile)",
                                    "Relatório LaTeX template"
                                  ],
                                  "tips": "Simule ciclos de attitude determination a 1Hz.",
                                  "learningObjective": "Garantir robustez e eficiência da implementação.",
                                  "commonMistakes": [
                                    "Testes insuficientes em edge cases",
                                    "Código não escalável"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO com sensores solares e magnetômetro. Use dados reais de missão (ex: ISS telemetry adaptada) para implementar TRIAD/QUEST, fundir vetores, calcular quaternions e converter para Euler angles, validando contra attitude conhecida com erro <3 graus.",
                              "finalVerifications": [
                                "Quaternion resultante tem norma unitária igual a 1.0.",
                                "Matriz de rotação é ortogonal (produto com transposta = identidade).",
                                "Erros de atitude RMS < 5 graus em simulações ruidosas.",
                                "Conversão Euler produz valores dentro de [-180,180] graus.",
                                "Fusão multi-sensor reduz variância em 50% vs sensor único.",
                                "Código executa em <10ms por iteração em hardware embarcado simulado.",
                                "Visualizações mostram continuidade suave de atitude."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro médio <2 graus em testes nominais.",
                                "Robustez: Maneja 20% ruído e falhas parciais de sensores.",
                                "Eficiência: Tempo computacional <1ms/ciclo.",
                                "Correção matemática: Verificações de normalização e ortogonalidade passam.",
                                "Documentação: Código comentado com fórmulas derivadas.",
                                "Modularidade: Funções separadas para TRIAD, QUEST e conversões.",
                                "Validação: Comparação quantitativa com benchmarks publicados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear (SVD, quaternions), Otimização (QUEST).",
                                "Programação: NumPy/SciPy para computação numérica vetorizada.",
                                "Física: Mecânica Orbital e Cinemática de Corpo Rígido.",
                                "Engenharia de Controle: Fusão Sensorial e Estimadores (EKF intro).",
                                "Ciência de Dados: Tratamento de Ruído e Validação Estatística."
                              ],
                              "realWorldApplication": "Implementado em CubeSats como o CPOD da ESA ou missões NASA (ex: MarCO) para determinação autônoma de atitude sem GPS, essencial para apontamento de antenas, painéis solares e câmeras em ambientes espaciais hostis."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Simular determinação de atitude em software",
                            "description": "Usar ferramentas de simulação como MATLAB/Simulink para modelar sensores solares e validar estimação de atitude sob ruído e eclipse.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de simulação e modelar sensor solar básico",
                                  "subSteps": [
                                    "Instalar e verificar MATLAB/Simulink com toolboxes relevantes (Aerospace Blockset opcional).",
                                    "Criar novo modelo Simulink e configurar solver para simulações em tempo real.",
                                    "Implementar modelo matemático do sensor solar: calcular cosseno do ângulo entre normal do sensor e vetor solar.",
                                    "Definir parâmetros iniciais: órbita circular LEO, posição/orientação do satélite.",
                                    "Executar simulação básica sem ruído para validar saídas esperadas."
                                  ],
                                  "verification": "O modelo produz saídas unitárias para alinhamento perfeito e zero para sensor oposto ao Sol.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MATLAB/Simulink instalado",
                                    "Documentação de modelagem de sensores solares (NASA ou papers)"
                                  ],
                                  "tips": "Use blocos 'MATLAB Function' para equações vetoriais e normalize todos os vetores.",
                                  "learningObjective": "Dominar modelagem cinemática de sensores solares em ambiente Simulink.",
                                  "commonMistakes": [
                                    "Não converter coordenadas inerciais para corpo corretamente",
                                    "Esquecer de normalizar vetor solar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Incorporar ruído gaussiano e modelar condições de eclipse",
                                  "subSteps": [
                                    "Adicionar bloco 'Band-Limited White Noise' aos sinais do sensor com SNR realista (ex: 20-30 dB).",
                                    "Implementar detecção de eclipse: se projeção solar < threshold (ex: 0.1), mascarar leitura.",
                                    "Configurar propagador orbital simples (SGP4 ou analítico) para gerar vetor solar ao longo da órbita.",
                                    "Simular uma órbita completa (90 min LEO) com períodos de eclipse.",
                                    "Ajustar parâmetros de ruído e eclipse baseados em dados reais de satélites."
                                  ],
                                  "verification": "Durante eclipse, leituras são suprimidas e ruído não causa picos artificiais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplos de propagadores orbitais em MATLAB File Exchange",
                                    "Dados de sensores solares de CubeSats"
                                  ],
                                  "tips": "Use 'If Action Subsystem' no Simulink para lógica condicional de eclipse.",
                                  "learningObjective": "Simular condições ambientais reais afetando sensores.",
                                  "commonMistakes": [
                                    "Ruído excessivo levando a instabilidade numérica",
                                    "Threshold de eclipse muito baixo causando falsos positivos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar algoritmo de estimação de atitude (método TRIAD)",
                                  "subSteps": [
                                    "Implementar algoritmo TRIAD em bloco MATLAB Function: calcular matriz de direção de medições e verdadeiros vetores.",
                                    "Integrar múltiplos sensores solares (2-3 faces) para observabilidade completa.",
                                    "Inicializar com atitude conhecida e atualizar a cada ciclo de amostragem (1-10 Hz).",
                                    "Adicionar filtro simples (média móvel) para suavizar estimativas sob ruído.",
                                    "Testar convergência em condições nominais."
                                  ],
                                  "verification": "Estimativa de atitude converge para verdade ground em <10 ciclos sem ruído.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Referência: 'TRIAD algorithm for attitude determination' (Wertz livro)",
                                    "Quaternions toolbox MATLAB"
                                  ],
                                  "tips": "Represente atitude com quaternions para evitar gimbal lock.",
                                  "learningObjective": "Aplicar métodos determinísticos de estimação de atitude.",
                                  "commonMistakes": [
                                    "Inversão de vetores de referência",
                                    "Falta de observabilidade com <2 sensores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações, validar e analisar desempenho",
                                  "subSteps": [
                                    "Definir verdade ground: injetar atitude conhecida no modelo dinâmico.",
                                    "Executar Monte Carlo: 100 runs variando ruído e eclipse inicial.",
                                    "Calcular métricas: erro de ângulo (deg), desvio padrão, tempo de convergência.",
                                    "Gerar plots: atitude estimada vs verdade, durante eclipse.",
                                    "Otimizar parâmetros e documentar resultados."
                                  ],
                                  "verification": "Erro médio <3° fora eclipse, recuperação <5 min pós-eclipse.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Scripts MATLAB para análise estatística (boxplots, histograms)"
                                  ],
                                  "tips": "Use 'Simulink Test' para automação de cenários.",
                                  "learningObjective": "Validar robustez da simulação contra incertezas reais.",
                                  "commonMistakes": [
                                    "Comparação errada de quaternions (sinais opostos equivalentes)",
                                    "Amostragem insuficiente em Monte Carlo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e estender para cenários avançados",
                                  "subSteps": [
                                    "Implementar EKF simples para fusão com outros sensores (ex: giroscópio).",
                                    "Testar órbitas elípticas ou GEO com eclipses longos.",
                                    "Analisar sensibilidade a desalinhamentos de sensores (±1°).",
                                    "Exportar modelo para C-code (Simulink Coder) para prototipagem.",
                                    "Preparar relatório com conclusões e limitações."
                                  ],
                                  "verification": "EKF reduz erro em 50% vs TRIAD sob ruído alto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Extended Kalman Filter examples em MATLAB"
                                  ],
                                  "tips": "Monitore Jacobianas no EKF para estabilidade.",
                                  "learningObjective": "Estender simulação para sistemas reais de ADCS.",
                                  "commonMistakes": [
                                    "Instabilidade do filtro por tuning ruim de covariâncias",
                                    "Ignorar bias em sensores"
                                  ]
                                },
                                {
                                  "practicalExample": "Simule um CubeSat em órbita LEO (400km, 90° inclinação) com 3 sensores solares. Injete ruído gaussiano (σ=5%) e eclipse de 35min por órbita. Valide se TRIAD estima atitude com erro <2° fora eclipse, recuperando em <2min pós-eclipse.",
                                  "finalVerifications": [
                                    "Simulação executa 10 órbitas sem crashes numéricos.",
                                    "Erro de roll/pitch/yaw <5° em 95% do tempo fora eclipse.",
                                    "Degradação controlada durante eclipse (drift <10°).",
                                    "Métricas estatísticas (mean/std) documentadas em plots.",
                                    "Código modular e comentado para reutilização."
                                  ],
                                  "assessmentCriteria": [
                                    "Precisão: erro médio <3° em condições nominais (peso 30%).",
                                    "Robustez: performance sob ruído/eclipse (peso 25%).",
                                    "Eficiência: tempo de simulação <1min/órbita (peso 15%).",
                                    "Clareza: código/plots legíveis e documentados (peso 20%).",
                                    "Extensibilidade: fácil adicionar sensores/filtros (peso 10%)."
                                  ],
                                  "crossCurricularConnections": [
                                    "Matemática: Álgebra linear (matrizes de rotação), estatística (análise de ruído).",
                                    "Física: Mecânica orbital, óptica geométrica de sensores.",
                                    "Programação: Scripting MATLAB, modelagem orientada a blocos.",
                                    "Engenharia de Controle: Filtros de estimação (EKF).",
                                    "Ciência de Dados: Análise Monte Carlo e visualização."
                                  ],
                                  "realWorldApplication": "Desenvolvimento e teste de subsistemas ADCS em CubeSats para missões universitárias ou comerciais (ex: validação de software para satélites como o CAPE-USat, reduzindo custos de testes em hardware).",
                                  "stepNumber": 5,
                                  "title": "Simulação de Estimativa de Atitude TRIAD com Sensores Solares em Condições Reais",
                                  "subSteps": [
                                    "1. Configurar modelo orbital: LEO a 400 km, inclinação 90°, propagar 10 órbitas usando modelo Kepleriano ou SGP4.",
                                    "2. Definir 3 sensores solares com campos de visão e gerar vetores de referência (direção Sol no BCI).",
                                    "3. Implementar algoritmo TRIAD: calcular DCM a partir de dois vetores observados/referência, converter para ângulos de Euler.",
                                    "4. Injetar ruído gaussiano (σ=5%) nas medições dos sensores e modelar eclipse (35 min/órbita, sensores zerados).",
                                    "5. Executar simulação em loop, armazenando quaternions verdadeiros e estimados.",
                                    "6. Computar erros de roll/pitch/yaw, gerar plots de tempo vs. erro e histogramas estatísticos.",
                                    "7. Validar: erro <2° fora eclipse, recuperação <2 min pós-eclipse."
                                  ],
                                  "verification": "Simulação roda 10 órbitas sem crashes; erro médio <2° fora eclipse em plots; recuperação confirmada em <2 min.",
                                  "estimatedTime": "180 minutos",
                                  "materials": [
                                    "MATLAB ou Octave com Aerospace Toolbox",
                                    "Funções de propagação orbital (SGP4 ou poliastro)",
                                    "Templates de TRIAD e modelagem de sensores solares"
                                  ],
                                  "tips": [
                                    "Normalize todos os vetores antes do TRIAD para evitar erros numéricos.",
                                    "Use quaternions para representação de atitude e converta para Euler apenas para análise.",
                                    "Fixe a seed do randn para reprodutibilidade.",
                                    "Vectorize loops em MATLAB para eficiência (<1 min/órbita).",
                                    "Adicione logging de condições de eclipse para debug."
                                  ],
                                  "learningObjective": "Implementar e validar o algoritmo TRIAD para determinação de atitude em CubeSat, considerando ruído gaussiano e eclipses, alcançando erro <2° fora de eclipse e recuperação rápida pós-eclipse.",
                                  "commonMistakes": [
                                    "Não normalizar vetores, resultando em quaternions com norma ≠1.",
                                    "Ignorar eclipse, causando erros persistentes durante sombra.",
                                    "Falta de tratamento de singularidades no TRIAD (vetores paralelos).",
                                    "Plots sem médias/desvios padrão ou escalas inadequadas.",
                                    "Simulação lenta por loops não vetorizados."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO (400km, 90° inclinação) com 3 sensores solares. Injete ruído gaussiano (σ=5%) e eclipse de 35min por órbita. Valide se TRIAD estima atitude com erro <2° fora eclipse, recuperando em <2min pós-eclipse.",
                              "finalVerifications": [
                                "Simulação executa 10 órbitas sem crashes numéricos.",
                                "Erro de roll/pitch/yaw <5° em 95% do tempo fora eclipse.",
                                "Degradação controlada durante eclipse (drift <10°).",
                                "Métricas estatísticas (mean/std) documentadas em plots.",
                                "Código modular e comentado para reutilização."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro médio <3° em condições nominais (peso 30%).",
                                "Robustez: performance sob ruído/eclipse (peso 25%).",
                                "Eficiência: tempo de simulação <1min/órbita (peso 15%).",
                                "Clareza: código/plots legíveis e documentados (peso 20%).",
                                "Extensibilidade: fácil adicionar sensores/filtros (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rotação), estatística (análise de ruído).",
                                "Física: Mecânica orbital, óptica geométrica de sensores.",
                                "Programação: Scripting MATLAB, modelagem orientada a blocos.",
                                "Engenharia de Controle: Filtros de estimação (EKF).",
                                "Ciência de Dados: Análise Monte Carlo e visualização."
                              ],
                              "realWorldApplication": "Desenvolvimento e teste de subsistemas ADCS em CubeSats para missões universitárias ou comerciais (ex: validação de software para satélites como o CAPE-USat, reduzindo custos de testes em hardware)."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Sensor de Estrelas",
                    "description": "Uso de sensores de estrelas para obter medições precisas de atitude através da identificação de padrões estelares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Princípio de Funcionamento do Sensor de Estrelas",
                        "description": "Explicação dos fundamentos operacionais do sensor de estrelas, incluindo captura de imagens estelares e processamento inicial para determinação de atitude em veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Identificar componentes ópticos e detectores do sensor",
                            "description": "Descrever os elementos principais como lentes, filtros ópticos, CCD ou CMOS detectors, e sua função na aquisição de imagens estelares com alta precisão angular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes ópticos básicos do sensor de estrelas",
                                  "subSteps": [
                                    "Pesquise a função geral de um sensor de estrelas na determinação de atitude.",
                                    "Identifique as lentes principais: lente objetiva e lentes de campo.",
                                    "Estude filtros ópticos: filtros de banda estreita para isolamento de comprimentos de onda estelares.",
                                    "Analise diagramas esquemáticos de sensores ópticos.",
                                    "Registre as funções primárias: coleta e foco de luz estelar."
                                  ],
                                  "verification": "Desenhe um diagrama simples rotulando lentes e filtros com suas funções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagramas de sensores de estrelas (ex: PDF de manuais da Ball Aerospace), vídeo introdutório sobre óptica astronômica.",
                                  "tips": "Comece com imagens reais de sensores para visualizar melhor.",
                                  "learningObjective": "Reconhecer e descrever lentes e filtros ópticos em sensores de estrelas.",
                                  "commonMistakes": "Confundir filtros ópticos com filtros eletrônicos; ignorar o papel na rejeição de luz solar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os detectores de imagem CCD e CMOS",
                                  "subSteps": [
                                    "Defina CCD (Charge-Coupled Device) e CMOS (Complementary Metal-Oxide-Semiconductor).",
                                    "Compare características: sensibilidade, ruído, resolução angular.",
                                    "Estude pixels e matrizes: como capturam fótons de estrelas.",
                                    "Analise o processo de conversão fotoelétrica em sinal elétrico.",
                                    "Examine exemplos de detectores usados em sensores como o Star Tracker da Sodern."
                                  ],
                                  "verification": "Liste 3 diferenças chave entre CCD e CMOS e explique por que CCD é preferido para precisão angular.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigos técnicos sobre CCD/CMOS (ex: NASA reports), simulador online de detectores de imagem.",
                                  "tips": "Use tabelas comparativas para memorizar specs como quantum efficiency.",
                                  "learningObjective": "Diferenciar detectores e entender sua captura de imagens estelares.",
                                  "commonMistakes": "Achar que CMOS é sempre superior; subestimar impacto do ruído térmico em observações espaciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar componentes ópticos e detectores no fluxo de aquisição de imagens",
                                  "subSteps": [
                                    "Descreva o caminho da luz: entrada pela lente, filtragem, foco no detector.",
                                    "Explique aquisição: exposição curta para estrelas puntiformes, alta precisão angular (<10 arcsegundos).",
                                    "Estude calibração óptica para alinhamento e distorção.",
                                    "Simule o processo com software de modelagem óptica.",
                                    "Identifique interfaces: readout electronics conectando detector ao processador."
                                  ],
                                  "verification": "Crie um fluxograma mostrando o caminho da luz do céu ao sinal digital.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software gratuito como Zemax demo ou OpticStudio trial, diagramas de fluxo de sensores de estrelas.",
                                  "tips": "Pense em termos de 'luz -> elétrico -> digital' para simplificar.",
                                  "learningObjective": "Mapear a interação entre óptica e detecção para precisão estelar.",
                                  "commonMistakes": "Ignorar efeitos como aberração cromática nas lentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em exemplos reais e diagramas",
                                  "subSteps": [
                                    "Analise fotos reais de sensores desmontados (ex: CubeSat star trackers).",
                                    "Rotule componentes em 3 imagens diferentes.",
                                    "Explique funções em contexto de missão espacial.",
                                    "Compare com sensores terrestres como câmeras DSLR.",
                                    "Teste com quiz interativo sobre identificação."
                                  ],
                                  "verification": "Identifique corretamente todos os componentes em uma imagem não vista anteriormente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Imagens de alta resolução de star trackers (ex: de papers IEEE), quiz online personalizado.",
                                  "tips": "Aumente zoom nas imagens para ver detalhes como montagens de lentes.",
                                  "learningObjective": "Aplicar conhecimento para identificar componentes em cenários reais.",
                                  "commonMistakes": "Confundir lente de campo com objetiva; não considerar tamanho miniaturizado em espaço."
                                }
                              ],
                              "practicalExample": "Em um star tracker do satélite CYGNSS da NASA, identifique a lente objetiva (foco de luz estelar), filtro bandpass de 500-900nm (rejeita ruído solar), e detector CCD de 512x512 pixels (captura posições estelares com 3 arcsegundos de precisão para orientação do satélite).",
                              "finalVerifications": [
                                "Liste e descreva 4 componentes principais com funções corretas.",
                                "Explique o papel da óptica na resolução angular <10 arcsegundos.",
                                "Diferencie CCD vs CMOS em contexto espacial.",
                                "Desenhe e rotule um diagrama completo do sensor.",
                                "Responda a 5 perguntas de identificação em imagens reais.",
                                "Simule aquisição de imagem explicando cada etapa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de lentes, filtros e detectores (90%+).",
                                "Compreensão profunda das funções ópticas e de detecção.",
                                "Uso correto de terminologia técnica (ex: quantum efficiency, focal length).",
                                "Qualidade de diagramas e fluxogramas (clareza e completude).",
                                "Aplicação correta em exemplos reais espaciais.",
                                "Identificação de erros comuns e correções."
                              ],
                              "crossCurricularConnections": [
                                "Física Óptica: Princípios de refração, difração e filtros espectrais.",
                                "Eletrônica: Funcionamento de semicondutores em detectores de imagem.",
                                "Astronomia: Catálogos estelares e observação de estrelas puntiformes.",
                                "Engenharia de Software: Processamento de imagens em algoritmos de tracking.",
                                "Matemática: Cálculo de precisão angular e geometria óptica."
                              ],
                              "realWorldApplication": "Em missões espaciais como o James Webb Space Telescope ou satélites GPS, sensores de estrelas usam esses componentes para determinar atitude com precisão de arcossegundos, essencial para apontamento de antenas, estabilização e navegação autônoma em órbita."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Explicar o processo de aquisição de imagens estelares",
                            "description": "Detalhar como o sensor aponta para o céu, captura campos de visão estreitos (tipicamente 10-20 graus) e registra posições de estrelas brilhantes acima de uma magnitude limite.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o apontamento inicial do sensor para o céu",
                                  "subSteps": [
                                    "Estude a orientação do sensor de estrelas em relação ao veículo espacial, tipicamente fixo em um eixo óptico.",
                                    "Aprenda como o mecanismo de apontamento usa atuadores ou a própria rotação da nave para direcionar o campo de visão (FOV) de 10-20 graus.",
                                    "Identifique o papel do software de controle para selecionar regiões do céu baseadas em previsões de atitude.",
                                    "Simule o cálculo de ângulos de Euler ou quaternions para alinhamento inicial.",
                                    "Revise diagramas de montagem de star trackers em satélites reais."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando o sensor apontando para o céu e label os componentes chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagramas de star trackers online, software de simulação como STK (Systems Tool Kit) gratuito.",
                                  "tips": "Visualize o sensor como uma câmera apontada para uma pequena janela do céu noturno.",
                                  "learningObjective": "Compreender como o sensor é direcionado para capturar uma porção específica do céu.",
                                  "commonMistakes": "Confundir o FOV estreito com telescópios de campo amplo; lembrar que é ~10-20 graus."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Captura do campo de visão estreito através de exposição",
                                  "subSteps": [
                                    "Configure o tempo de exposição (tipicamente 0.1-10 segundos) para evitar saturação de estrelas brilhantes.",
                                    "Ative o obturador óptico e o sensor CCD/CMOS para converter luz em elétrons.",
                                    "Monitore ruído térmico e cósmico durante a integração de carga.",
                                    "Registre a imagem raw como uma matriz de pixels com intensidades de brilho.",
                                    "Ajuste ganho e offset para otimizar o sinal-ruído."
                                  ],
                                  "verification": "Gere uma imagem simulada de estrelas usando software como MATLAB ou Python (astropy) e identifique o FOV.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software Python com bibliotecas astropy e matplotlib, imagens de star trackers públicas da NASA.",
                                  "tips": "Pense na exposição como tirar uma foto longa da noite para capturar estrelas fracas.",
                                  "learningObjective": "Dominar o processo físico de captura de luz estelar em uma imagem digital.",
                                  "commonMistakes": "Ignorar efeitos de movimento da nave; assumir exposição estática sem compensação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detecção e registro de estrelas brilhantes acima da magnitude limite",
                                  "subSteps": [
                                    "Aplique threshold de intensidade para identificar pixels acima da magnitude limite (ex: mag 4-6).",
                                    "Use algoritmos de centróide (como centroiding ou PSF fitting) para determinar posições sub-pixel.",
                                    "Filtre falsos positivos como ruído ou planetas usando padrões de brilho.",
                                    "Registre coordenadas relativas (RA/DEC locais ou ângulos no FOV) e magnitudes aparentes.",
                                    "Compare com catálogo onboard (ex: 10.000 estrelas) para validação inicial."
                                  ],
                                  "verification": "Implemente um script simples em Python para processar uma imagem de estrelas e liste 5 estrelas detectadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com OpenCV e astropy, catálogo de estrelas como Hipparcos.",
                                  "tips": "Comece com imagens limpas de estrelas isoladas para praticar detecção.",
                                  "learningObjective": "Aprender a extrair posições precisas de estrelas da imagem capturada.",
                                  "commonMistakes": "Detectar artefatos como estrelas; sempre validar com múltiplos pontos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração e validação do processo completo de aquisição",
                                  "subSteps": [
                                    "Combine dados de múltiplas exposições ou sensores para robustez.",
                                    "Avalie qualidade da aquisição via métricas como número de estrelas detectadas (>10 ideal).",
                                    "Simule perda de aquisição devido a Sol/Lua e estratégias de recuperação.",
                                    "Documente o pipeline em um fluxograma.",
                                    "Teste com cenários reais de missão."
                                  ],
                                  "verification": "Crie um fluxograma completo do processo e simule uma aquisição falha/h bem-sucedida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de diagramação como Draw.io, vídeos de star trackers da ESA/NASA.",
                                  "tips": "Integre steps anteriores em uma simulação end-to-end para visão holística.",
                                  "learningObjective": "Integrar todos os passos em um processo coeso de aquisição estelar.",
                                  "commonMistakes": "Subestimar interferências ambientais; incluir sempre checks de qualidade."
                                }
                              ],
                              "practicalExample": "Em um CubeSat como o CPOD da Universidade de Toronto, o star tracker aponta para o céu zenital, captura um FOV de 15 graus durante órbita noturna, detecta 20 estrelas acima de mag 5, e registra suas posições para corrigir a atitude em 0.001 graus de precisão.",
                              "finalVerifications": [
                                "Explique verbalmente os 4 passos principais sem consultar notas.",
                                "Simule uma aquisição com software e identifique pelo menos 10 estrelas.",
                                "Descreva impactos de magnitude limite em cenários de baixa luminosidade.",
                                "Crie um diagrama annotado do pipeline de aquisição.",
                                "Responda a perguntas sobre erros comuns em aquisição real.",
                                "Compare aquisição de star tracker vs. outros sensores como horizonte."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correta descrição de FOV (10-20°), magnitude limite e centróides.",
                                "Completude: Cobertura de todos substeps e verificações.",
                                "Profundidade: Inclusão de física (exposição, ruído) e software (processamento).",
                                "Clareza: Títulos, dicas e exemplos acionáveis e concisos.",
                                "Aplicação: Ligação explícita a contextos reais de aeroespacial.",
                                "Originalidade: Exemplos práticos personalizados, não copiados."
                              ],
                              "crossCurricularConnections": [
                                "Física Óptica: Princípios de imagem formação e detecção fotoelétrica.",
                                "Processamento de Imagens: Algoritmos de visão computacional (OpenCV).",
                                "Astronomia: Catálogos estelares e coordenadas celestes.",
                                "Matemática: Cálculos de vetores de atitude e estatística de ruído.",
                                "Programação: Scripts Python para simulação de aquisição."
                              ],
                              "realWorldApplication": "Sensores de estrelas são usados em missões como James Webb Space Telescope e GPS satélites para determinação autônoma de atitude, permitindo manobras precisas sem GPS, essenciais em deep space onde outros sensores falham."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Compreender limitações ambientais do sensor",
                            "description": "Analisar impactos de luz solar, luar, radiação e vibrações na performance do sensor de estrelas em órbita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar fontes ambientais principais afetando sensores de estrelas",
                                  "subSteps": [
                                    "Listar fontes ambientais comuns em órbita: luz solar direta, luz lunar/refletida da Terra, radiação cósmica e solar, vibrações mecânicas da spacecraft.",
                                    "Explicar como cada fonte interage com o sensor óptico (ex.: CCD ou CMOS).",
                                    "Revisar especificações técnicas de sensores reais (ex.: Ball Aerospace Star Tracker).",
                                    "Mapear condições orbitais (LEO, GEO) e sua influência nas exposições ambientais.",
                                    "Criar um diagrama de fluxo mostrando caminhos de impacto."
                                  ],
                                  "verification": "Diagrama completo submetido e fontes ambientais corretamente identificadas com referências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Datasheets de sensores de estrelas (NASA/ESA), software de desenho (Draw.io), vídeos tutoriais sobre órbitas (YouTube/Khan Academy).",
                                  "tips": "Priorize fontes por severidade: luz solar é a mais crítica em órbita baixa.",
                                  "learningObjective": "Reconhecer e categorizar todas as limitações ambientais relevantes para sensores de estrelas.",
                                  "commonMistakes": "Ignorar luz difusa da Terra ou confundir vibrações com ruído térmico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar impactos da luz solar e lunar na performance do sensor",
                                  "subSteps": [
                                    "Estudar saturação do detector por luz solar: calcular ângulos de exclusão (tipicamente 40-60°).",
                                    "Simular bloom/stray light usando ferramentas ópticas básicas.",
                                    "Examinar efeito do luar: intensidade relativa vs. estrelas (magnitude -12.6 para Lua cheia).",
                                    "Quantificar redução de sinal-ruído (SNR) em cenários de contaminação luminosa.",
                                    "Comparar curvas de resposta de sensores sob luz ambiente controlada."
                                  ],
                                  "verification": "Relatório com cálculos de SNR e gráficos de saturação gerados.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de simulação óptica (Zemax trial ou Python com Astropy), planilhas Excel para cálculos.",
                                  "tips": "Use equações de fotometria estelar para quantificar impactos precisamente.",
                                  "learningObjective": "Quantificar como luz solar/lunar degrada detecção de estrelas fracas.",
                                  "commonMistakes": "Subestimar luz scattered interna no sensor ou ignorar fases lunares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar efeitos da radiação em componentes eletrônicos e ópticos",
                                  "subSteps": [
                                    "Descrever tipos de radiação: partículas solares, raios cósmicos galácticos, Van Allen belts.",
                                    "Analisar degradação: single event upsets (SEU), total ionizing dose (TID) em CCDs.",
                                    "Revisar taxas de erro em missões reais (ex.: Hubble STIS failures).",
                                    "Calcular lifetime do sensor baseado em fluência de radiação orbital.",
                                    "Explorar técnicas de shielding e error correction."
                                  ],
                                  "verification": "Tabela de taxas de erro e lifetime estimado para órbitas específicas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Dados de radiação (SPENVIS tool), artigos NASA sobre radiação em star trackers.",
                                  "tips": "Acesse ferramentas online gratuitas como SPENVIS para modelagem precisa.",
                                  "learningObjective": "Avaliar riscos de radiação e impactos na precisão de atitude.",
                                  "commonMistakes": "Confundir efeitos agudos (SEU) com crônicos (TID) ou ignorar recuperação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar influência de vibrações na estabilidade do sensor",
                                  "subSteps": [
                                    "Classificar vibrações: launch-induced, reaction wheels, thruster firings.",
                                    "Medir impactos: blur de imagem, misalignment óptico (tipicamente <1 arcsec requirement).",
                                    "Simular usando modelos dinâmicos (ex.: frequência natural do mount).",
                                    "Analisar filtros Kalman para compensação de vibração em attitude determination.",
                                    "Comparar specs de sensores gyrostabilized vs. fixed."
                                  ],
                                  "verification": "Simulação dinâmica com gráficos de blur vs. frequência vibracional.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB/Simulink (trial), dados de testes de vibração (ESA reports).",
                                  "tips": "Foquem em frequências ressonantes (10-100 Hz) comuns em spacecraft.",
                                  "learningObjective": "Compreender como vibrações afetam precisão de pointing do sensor.",
                                  "commonMistakes": "Negligenciar vibrações micro (termicas) ou superestimar damping passivo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar limitações e estratégias de mitigação",
                                  "subSteps": [
                                    "Integrar todos impactos em um modelo de performance holístico (ex.: disponibilidade do sensor).",
                                    "Propor mitigações: baffles ópticos, redundancy, software blackout zones.",
                                    "Avaliar trade-offs: FOV vs. rejeição de luz, peso vs. shielding.",
                                    "Simular missão completa com falhas ambientais.",
                                    "Documentar em relatório executivo."
                                  ],
                                  "verification": "Modelo integrado e relatório com recomendações viáveis.",
                                  "estimatedTime": "2 horas",
                                  "materials": "STK (Systems Tool Kit trial), templates de relatório.",
                                  "tips": "Priorize mitigações custo-efetivas para missões CubeSat.",
                                  "learningObjective": "Integrar conhecimentos para otimizar uso do sensor em ambiente orbital.",
                                  "commonMistakes": "Focar só em uma limitação, ignorando interações (ex.: radiação + vibração)."
                                }
                              ],
                              "practicalExample": "Em uma simulação de CubeSat em LEO usando STK, configure o sensor de estrelas para orbitar próximo ao Sol; observe saturação quando o ângulo Sol-sensor <45°, resultando em perda de 30% das estrelas detectáveis, e aplique baffle virtual para recuperação.",
                              "finalVerifications": [
                                "Lista completa de 4 limitações ambientais com quantificações precisas.",
                                "Gráficos/simulações demonstrando degradação de performance.",
                                "Estratégias de mitigação específicas para cada limitação.",
                                "Análise de trade-offs em cenários orbitais reais.",
                                "Relatório sintetizando impactos na determinação de atitude.",
                                "Auto-avaliação de compreensão via quiz interno."
                              ],
                              "assessmentCriteria": [
                                "Precisão científica nas descrições de impactos (90%+ correção).",
                                "Profundidade quantitativa (cálculos/SNR/lifetimes incluídos).",
                                "Criatividade e viabilidade das mitigações propostas.",
                                "Qualidade de visualizações (diagramas/gráficos claros).",
                                "Integração interdisciplinar (óptica + dinâmica + radiação).",
                                "Clareza e estrutura do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Física Óptica: stray light e fotometria estelar.",
                                "Engenharia Mecânica: análise de vibrações e controle.",
                                "Física de Partículas: efeitos de radiação em semicondutores.",
                                "Computação: simulações numéricas e filtros Kalman.",
                                "Gestão de Projetos: trade-offs em design espacial."
                              ],
                              "realWorldApplication": "Na missão James Webb Space Telescope (JWST), sensores de estrelas evitam zonas de luz solar/lunar com precisão, combinando baffles e algoritmos para manter atitude estável apesar de vibrações de cryo-coolers e radiação em L2 halo orbit."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Identificação de Padrões Estelares",
                        "description": "Técnicas para reconhecimento e catalogação de estrelas observadas, utilizando bancos de dados estelares para mapear o campo de visão.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Utilizar catálogos estelares como Hipparcos ou Gaia",
                            "description": "Explicar o uso de catálogos com posições precisas (erro <1 arcsegundo) de milhares de estrelas para matching inicial de observações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Acessar e Explorar a Estrutura de Catálogos Estelares",
                                  "subSteps": [
                                    "Pesquise e identifique fontes oficiais para baixar catálogos como Hipparcos (ESA) ou Gaia (ESA Gaia Archive).",
                                    "Baixe um subconjunto do catálogo em formato FITS ou CSV, focando em estrelas brilhantes (magnitude <6).",
                                    "Use software como TOPCAT, Aladin ou Python (astropy) para visualizar colunas chave: RA, Dec, magnitude, erro posicional.",
                                    "Filtre o catálogo por regiões celestes relevantes (ex: hemisfério visível).",
                                    "Documente estatísticas básicas: número de estrelas, precisão média de posições (<1 arcsegundo)."
                                  ],
                                  "verification": "Confirme o download bem-sucedido e gere um mapa estelar filtrado com pelo menos 1000 estrelas visualizáveis.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Computador com internet",
                                    "Software: Astropy (Python), TOPCAT ou Aladin",
                                    "Catálogo Hipparcos/DR3 Gaia (arquivo ~GB)"
                                  ],
                                  "tips": "Comece com subconjuntos pequenos para evitar sobrecarga; use tutoriais oficiais da ESA.",
                                  "learningObjective": "Compreender a estrutura e precisão dos dados em catálogos estelares para uso em astrometria.",
                                  "commonMistakes": [
                                    "Baixar catálogo completo sem filtrar (demora excessiva)",
                                    "Ignorar unidades (RA/Dec em graus vs horas)",
                                    "Confundir colunas de erro posicional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar Estrelas Candidatas para Matching",
                                  "subSteps": [
                                    "Defina critérios de seleção: magnitude visual (V<6 para detecção), erro posicional <1\", campo de visão do sensor (ex: 10x10 graus).",
                                    "Crie uma lista de candidatos em uma região de interesse usando queries SQL no Gaia Archive ou filtros em Python.",
                                    "Calcule vetores unitários ou coordenadas cartesianas a partir de RA/Dec para geometria esférica.",
                                    "Ordene candidatos por brilho e isole estrelas únicas (evite duplicatas).",
                                    "Gere um arquivo de candidatos com IDs, posições e magnitudes para uso posterior."
                                  ],
                                  "verification": "Lista de 50-200 estrelas candidatas gerada, com filtros aplicados e sem duplicatas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com astropy/astroquery",
                                    "Gaia Archive interface",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use astroquery para queries automáticas; visualize seleções em sky plots.",
                                  "learningObjective": "Selecionar subconjuntos otimizados de estrelas para eficiência em matching de observações.",
                                  "commonMistakes": [
                                    "Incluir estrelas muito fracas (não detectáveis)",
                                    "Esquecer rotação da Terra (precessão)",
                                    "Selecionar fora do FOV do sensor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Matching Inicial de Padrões Observados",
                                  "subSteps": [
                                    "Simule observações: gere posições pixeladas de 5-10 estrelas detectadas no sensor (use modelo de lost-in-space).",
                                    "Aplique algoritmo básico de matching: triangle matcher ou k-vector search comparando ângulos observados vs catálogo.",
                                    "Calcule scores de similaridade (ex: RMSD <1\") e identifique correspondências únicas.",
                                    "Estime quaternion de atitude inicial a partir do matching (usando Wahba's problem básico).",
                                    "Itere para refinar, rejeitando falsos positivos por magnitude ou erro."
                                  ],
                                  "verification": "Matching bem-sucedido com >80% de estrelas corretamente pareadas em simulação.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Biblioteca PyAstronomy ou custom script Python",
                                    "Simulador de sensor estelar (ex: STK ou código simples)"
                                  ],
                                  "tips": "Teste com padrões conhecidos como Cintura de Órion; limite buscas para performance.",
                                  "learningObjective": "Implementar matching lost-in-space usando posições precisas do catálogo.",
                                  "commonMistakes": [
                                    "Matching ambíguo sem verificação de magnitude",
                                    "Ignorar distorções de lente do sensor",
                                    "Sobrecarga computacional sem pruning"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar o Matching",
                                  "subSteps": [
                                    "Compare posições catalogadas vs observadas: compute resíduos (RA/Dec errors <1\").",
                                    "Verifique consistência global: ângulos entre estrelas devem coincidir dentro de erros.",
                                    "Teste robustez: adicione ruído gaussiano e re-matche para simular condições reais.",
                                    "Gere relatório: taxa de sucesso, tempo de processamento, atitude estimada vs verdadeira.",
                                    "Otimize: ajuste thresholds baseados em testes múltiplos."
                                  ],
                                  "verification": "Relatório com resíduos médios <0.5\", sucesso >90% em 10 simulações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Scripts Python para análise estatística (numpy, matplotlib)",
                                    "Dados de teste com ground truth"
                                  ],
                                  "tips": "Use métricas como NEA (Navigation Error Angle) para validação quantitativa.",
                                  "learningObjective": "Garantir precisão e robustez no uso de catálogos para determinação de atitude.",
                                  "commonMistakes": [
                                    "Aceitar matchings com poucos estrelas (baixa redundância)",
                                    "Não testar com ruído realista",
                                    "Confundir erro sistemático vs aleatório"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat com sensor estelar, detecta 8 estrelas em FOV de 20°. Usando Gaia DR3, seleciona 150 candidatas, aplica triangle matching, identifica padrão da Ursa Major, estima atitude com erro <0.1°, permitindo controle preciso de apontamento.",
                              "finalVerifications": [
                                "Baixa e filtra catálogo corretamente com precisão <1\".",
                                "Seleciona candidatos otimizados para FOV específico.",
                                "Executa matching lost-in-space com >85% sucesso.",
                                "Valida resíduos e gera atitude inicial precisa.",
                                "Relata métricas quantitativas de performance.",
                                "Aplica em simulação realista de missão espacial."
                              ],
                              "assessmentCriteria": [
                                "Precisão do matching: resíduos <1\" em 90% dos casos.",
                                "Eficiência: tempo <10s por matching em hardware embarcado.",
                                "Robustez: sucesso sob ruído e obstruções parciais.",
                                "Compreensão: explica escolhas de filtros e algoritmos.",
                                "Documentação: código comentado e relatório claro.",
                                "Inovação: adapta para cenários não-nominais."
                              ],
                              "crossCurricularConnections": [
                                "Astronomia: Astrometria e coordenadas celestes.",
                                "Programação: Processamento de dados FITS com Python/Astropy.",
                                "Matemática: Geometria esférica e otimização (Wahba).",
                                "Física: Óptica de sensores e dinâmica orbital.",
                                "Engenharia: Sistemas embarcados em aeroespacial."
                              ],
                              "realWorldApplication": "Satélites como Gaia (próprio uso), Hubble Space Telescope, ou missões CubeSat usam catálogos Hipparcos/Gaia para aquisição autônoma de atitude, essencial para navegação precisa em deep space sem GPS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Aplicar algoritmos de reconhecimento de padrões",
                            "description": "Descrever métodos como Lost-in-Space (LIS), TRIAD ou q-method para identificar constelações ou padrões geométricos em imagens estelares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Aquisição e Pré-processamento da Imagem Estelar",
                                  "subSteps": [
                                    "Carregue a imagem estelar de um sensor de estrelas usando bibliotecas como OpenCV ou Astropy.",
                                    "Aplique filtros para redução de ruído, como mediana ou Gaussiano, para melhorar a qualidade.",
                                    "Detecte e extraia coordenadas (RA, DEC ou pixels) e magnitudes aparentes das estrelas candidatas.",
                                    "Crie uma lista de vetores de estrelas com posições angulares relativas.",
                                    "Normalize os dados para remover distorções de lente ou rotação."
                                  ],
                                  "verification": "Verifique se pelo menos 10 estrelas candidatas foram detectadas com coordenadas precisas e magnitudes acima de um threshold (ex: 6.5).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software Python com OpenCV/Astropy; imagem estelar de teste (ex: de satélite CubeSat).",
                                  "tips": "Use thresholding adaptativo para detecção em imagens com fundo irregular.",
                                  "learningObjective": "Compreender o impacto do pré-processamento na precisão do reconhecimento.",
                                  "commonMistakes": "Ignorar saturação de estrelas brilhantes, levando a falsos positivos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção e Configuração do Algoritmo de Reconhecimento",
                                  "subSteps": [
                                    "Estude catálogos estelares (ex: Hipparcos) e selecione um algoritmo: LIS para buscas exaustivas, TRIAD para triângulos iniciais ou q-method para quaternions.",
                                    "Gere uma base de dados de padrões conhecidos: triângulos ou quadriláteros estelares com ângulos e distâncias.",
                                    "Configure parâmetros: tamanho da janela de busca, threshold de similaridade (ex: 0.8 cosine similarity).",
                                    "Implemente a função de matching inicial em código Python.",
                                    "Teste com padrões sintéticos para validar configuração."
                                  ],
                                  "verification": "Confirme que o algoritmo gera pelo menos 3 matches candidatos com scores acima de 0.7.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Catálogo Hipparcos/Bright Star Catalogue; Jupyter Notebook para prototipagem.",
                                  "tips": "Comece com TRIAD para simplicidade em cenários com poucas estrelas.",
                                  "learningObjective": "Escolher o algoritmo adequado baseado no número de estrelas visíveis e ruído.",
                                  "commonMistakes": "Usar catálogos desatualizados, causando mismatches com estrelas variáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicação do Algoritmo e Matching de Padrões",
                                  "subSteps": [
                                    "Execute o LIS/TRIAD/q-method comparando padrões observados com o catálogo.",
                                    "Calcule métricas de similaridade: distâncias euclidianas normalizadas ou ângulos entre vetores.",
                                    "Identifique o melhor match selecionando o maior score e rejeitando falsos positivos via RANSAC.",
                                    "Estime a matriz de rotação (quaternion) a partir do match.",
                                    "Registre logs de todos os matches tentados para depuração."
                                  ],
                                  "verification": "O algoritmo retorna um match único com erro de atitude < 5 graus.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código Python com NumPy/SciPy para cálculos vetoriais; amostra de imagem real.",
                                  "tips": "Paralelize a busca em LIS para imagens com >50 estrelas.",
                                  "learningObjective": "Aplicar matching robusto contra ruído e oclusões.",
                                  "commonMistakes": "Não aplicar rejeição de outliers, levando a atitudes erradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação e Refinamento da Identificação",
                                  "subSteps": [
                                    "Compare a atitude estimada com verdade-terra (ground truth) usando métricas como erro de ângulo.",
                                    "Aplique refinamento iterativo (ex: least-squares) para minimizar discrepâncias.",
                                    "Teste robustez adicionando ruído artificial à imagem.",
                                    "Gere relatório com confiança do match e estrelas usadas.",
                                    "Integre com sistema de determinação de atitude completo."
                                  ],
                                  "verification": "Erro final de atitude < 2 arcminutos em testes simulados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de simulação como STK ou Orekit; ground truth de atitudes.",
                                  "tips": "Use métricas de reprojeção para validar matches.",
                                  "learningObjective": "Avaliar e melhorar a precisão da identificação em cenários reais.",
                                  "commonMistakes": "Sobreajustar o modelo, reduzindo generalização."
                                }
                              ],
                              "practicalExample": "Em uma imagem de sensor de estrelas de um CubeSat sobre a órbita LEO, aplique LIS para identificar o padrão da constelação de Órion (estrelas Betelgeuse, Rigel, Bellatrix), estimando a atitude do veículo com precisão de 0.1 grau, ignorando 20% de falsos positivos devido a flares solares.",
                              "finalVerifications": [
                                "Algoritmo identifica corretamente ≥90% dos padrões em dataset de teste com 50 imagens.",
                                "Tempo de processamento < 1 segundo por imagem para aplicações em tempo real.",
                                "Erro médio de atitude < 3 arcminutos em validação cruzada.",
                                "Robustez comprovada: funciona com 30-70% de estrelas visíveis.",
                                "Relatório gerado inclui scores de confiança > 0.85 para todos matches.",
                                "Integração bem-sucedida com quaternions de atitude em simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão do matching: taxa de acerto > 95% em testes padronizados.",
                                "Eficiência computacional: complexidade O(n log n) ou melhor.",
                                "Robustez a ruído: performance estável com SNR > 10 dB.",
                                "Documentação do código: comentários em ≥80% das funções.",
                                "Capacidade de depuração: identificação correta de 5 erros comuns simulados.",
                                "Criatividade: adaptação do algoritmo para cenários não-padrão (ex: eclipse)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria esférica e álgebra linear para cálculos de rotação.",
                                "Programação: Algoritmos de busca e otimização em Python/NumPy.",
                                "Física/Astronomia: Cinemática orbital e fotometria estelar.",
                                "Engenharia de Software: Testes unitários e validação em sistemas embarcados."
                              ],
                              "realWorldApplication": "Em missões espaciais como o satélite Starlink ou telescópios como James Webb, esses algoritmos permitem determinação autônoma de atitude usando sensores de estrelas, essencial para apontamento preciso de antenas e câmeras em ambientes sem GPS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Avaliar taxa de aquisição e falsos positivos",
                            "description": "Calcular métricas de performance como taxa de identificação (>99% em condições nominais) e estratégias para rejeitar ruído ou falsos astros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Métricas de Performance",
                                  "subSteps": [
                                    "Defina taxa de aquisição como a porcentagem de estrelas corretamente identificadas em relação ao total esperado.",
                                    "Explique falsos positivos como detecções errôneas de padrões estelares não reais.",
                                    "Discuta condições nominais (ex.: sem obstruções, baixa ruído) e seu impacto na meta de >99% de taxa.",
                                    "Revise métricas relacionadas: precisão, recall e F1-score no contexto de identificação estelar.",
                                    "Estude fontes de ruído: flares solares, detritos espaciais ou artefatos ópticos."
                                  ],
                                  "verification": "Resuma os conceitos em um diagrama de Venn comparando taxa de aquisição e falsos positivos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de sensores de estrelas (ex.: PDF da NASA Star Tracker), caderno de notas.",
                                  "tips": "Use analogias como 'pesca seletiva' para visualizar falsos positivos.",
                                  "learningObjective": "Dominar definições e relações entre métricas de performance em sensores estelares.",
                                  "commonMistakes": "Confundir taxa de aquisição com taxa de detecção total, ignorando condições nominais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Preparar Dados de Simulação",
                                  "subSteps": [
                                    "Gere ou carregue dados simulados de um catálogo estelar (ex.: Hipparcos) com ruído adicionado.",
                                    "Simule condições nominais: 1000 observações com >99% estrelas reais.",
                                    "Introduza cenários de ruído: adicione 5-10% falsos astros via distorções gaussianas.",
                                    "Registre ground truth: posições reais vs. detectadas.",
                                    "Estruture dados em formato tabular (ex.: CSV com colunas: ID_estrela, detectada, real)."
                                  ],
                                  "verification": "Valide dataset com pelo menos 1000 entradas e distribuições de ruído verificadas via histograma.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com bibliotecas Astropy e NumPy, Jupyter Notebook, catálogo estelar Hipparcos.",
                                  "tips": "Use seeds fixos no gerador de ruído para reprodutibilidade.",
                                  "learningObjective": "Preparar datasets realistas para avaliação de sensores de estrelas.",
                                  "commonMistakes": "Não balancear dataset, levando a métricas enviesadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Métricas de Taxa de Aquisição e Falsos Positivos",
                                  "subSteps": [
                                    "Calcule taxa de aquisição: (estrelas_corretas / estrelas_esperadas) * 100.",
                                    "Compute falsos positivos: (detecções_errôneas / total_detecções) * 100.",
                                    "Gere matriz de confusão para precisão e recall.",
                                    "Compare resultados com benchmark >99% em nominais usando testes estatísticos (ex.: t-test).",
                                    "Plote gráficos: taxa vs. níveis de ruído."
                                  ],
                                  "verification": "Produza relatório com cálculos numéricos e gráficos mostrando >99% em nominais.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "Python com Pandas, Matplotlib, Scikit-learn para métricas.",
                                  "tips": "Automatize cálculos em funções reutilizáveis para eficiência.",
                                  "learningObjective": "Executar cálculos precisos de performance em dados estelares.",
                                  "commonMistakes": "Arredondar prematuramente, afetando a precisão >99%."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver e Avaliar Estratégias de Rejeição de Ruído",
                                  "subSteps": [
                                    "Implemente filtros: threshold de magnitude e verificação de padrões multi-estrelas.",
                                    "Aplique algoritmos de rejeição: matching perdido (lost-in-space) com bancos de dados estelares.",
                                    "Teste estratégias em dados ruidosos, medindo redução de falsos positivos.",
                                    "Otimize parâmetros via grid search para maximizar taxa mantendo >99%.",
                                    "Documente trade-offs: sensibilidade vs. especificidade."
                                  ],
                                  "verification": "Demonstre redução >50% em falsos positivos sem perda na taxa de aquisição.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": "Código Python estendendo Step 3, banco de dados estelar (ex.: Yale Bright Star Catalog).",
                                  "tips": "Comece com thresholds conservadores e ajuste iterativamente.",
                                  "learningObjective": "Criar estratégias robustas para mitigar ruído em identificação estelar.",
                                  "commonMistakes": "Sobrerregularização, rejeitando estrelas reais válidas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Validar Avaliação Completa",
                                  "subSteps": [
                                    "Combine métricas de todos steps em dashboard interativo.",
                                    "Realize validação cruzada em subconjuntos de dados.",
                                    "Simule variação orbital para testar robustez.",
                                    "Gere relatório final com recomendações.",
                                    "Compare com literatura (ex.: papers de star trackers)."
                                  ],
                                  "verification": "Dashboard funcional com métricas validadas em múltiplos cenários.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Dash/Plotly para dashboard, código dos steps anteriores.",
                                  "tips": "Versione código com Git para rastrear mudanças.",
                                  "learningObjective": "Sintetizar avaliação completa de performance de sensores.",
                                  "commonMistakes": "Ignorar variações contextuais como rotação da spacecraft."
                                }
                              ],
                              "practicalExample": "Em uma simulação de CubeSat em órbita LEO, usando dados do catálogo Hipparcos com 5% ruído de detritos, calcule taxa de aquisição de 99.2% em nominais e implemente filtro de magnitude para reduzir falsos positivos de 8% para 2%, garantindo atitude precisa para manobras.",
                              "finalVerifications": [
                                "Taxa de aquisição calculada corretamente >99% em condições nominais.",
                                "Falsos positivos quantificados e plotados vs. níveis de ruído.",
                                "Estratégias de rejeição implementadas e testadas com redução mensurável.",
                                "Matriz de confusão gerada e analisada.",
                                "Relatório com gráficos e recomendações produzido.",
                                "Código executável e reprodutível fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das métricas (erro <0.1%).",
                                "Qualidade e detalhe dos substeps implementados.",
                                "Eficácia das estratégias de rejeição (redução >40% FP).",
                                "Clareza de visualizações e relatórios.",
                                "Robustez em cenários variados (ruído, órbita).",
                                "Documentação de trade-offs e otimizações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de métricas de confusão e testes de hipótese.",
                                "Programação: Manipulação de dados com Python/NumPy.",
                                "Física Astronômica: Catálogos estelares e óptica espacial.",
                                "Engenharia de Software: Validação e otimização de algoritmos.",
                                "Processamento de Sinais: Filtros para ruído em imagens."
                              ],
                              "realWorldApplication": "Em missões como o James Webb Space Telescope ou satélites Starlink, onde star trackers avaliam atitude com precisão <0.001° rejeitando falsos astros causados por flares ou debris, garantindo navegação autônoma e sucesso da missão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Cálculo de Atitude e Integração",
                        "description": "Processamento das medições estelares para estimar a matriz de atitude e fusão com outros sensores para precisão global.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Calcular vetores de atitude a partir de pares de estrelas",
                            "description": "Implementar o método QUEST ou Wahba's problem para determinar ângulos de roll, pitch e yaw com precisão de 1-10 arcsegundos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos Teóricos do Problema de Wahba e Método QUEST",
                                  "subSteps": [
                                    "Estude a formulação do Problema de Wahba: minimizar a perda de Davenport para alinhar vetores observados (body frame) com vetores de referência (inertial frame).",
                                    "Revise representações de atitude: quaternions, matrizes de rotação e ângulos de Euler (roll, pitch, yaw).",
                                    "Analise o algoritmo QUEST: inicialização com solução analítica e refinamento iterativo para quaternions.",
                                    "Entenda medições de sensores de estrelas: catalogos estelares (ex: Hipparcos) e detecção de pares de estrelas.",
                                    "Calcule manualmente um exemplo simples com 2 vetores para Loss of Lock."
                                  ],
                                  "verification": "Escreva um resumo de 1 página explicando Wahba's problem e QUEST, incluindo equações chave, e resolva um exemplo manual.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Paper original de Wahba (1965)",
                                    "Documentação QUEST (NASA TN D-7468)",
                                    "Notebook Jupyter com equações simbólicas (SymPy)"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades em gimbal lock; visualize vetores em 3D com Matplotlib.",
                                  "learningObjective": "Dominar a matemática subjacente para formular o problema de determinação de atitude.",
                                  "commonMistakes": [
                                    "Confundir vetores no body frame com inertial frame",
                                    "Ignorar normalização de quaternions",
                                    "Usar ângulos Euler prematuramente sem quaternion intermediário"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Dados de Observação de Pares de Estrelas",
                                  "subSteps": [
                                    "Carregue um catalogo estelar (ex: 50 estrelas brilhantes com coordenadas RA/DEC).",
                                    "Simule observações do sensor: gere vetores unitários no body frame a partir de ângulos azimute/elevação.",
                                    "Identifique pares de estrelas: use algoritmo de reconhecimento de padrões (ex: k-vector ou lost-in-space).",
                                    "Forme a matriz de observações B: B = sum(w_i * b_i * r_i^T), onde b_i são observados, r_i referências.",
                                    "Aplique pesos w_i baseados em magnitude e separação angular (tipicamente >20 graus)."
                                  ],
                                  "verification": "Gere uma matriz B válida para 4-6 pares e verifique que det(B) > 0 (indicando rotação válida).",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Catálogo Hipparcos/Bright Star Catalogue (CSV)",
                                    "Python: NumPy, Pandas, Astropy para coordenadas celestiais"
                                  ],
                                  "tips": "Use pelo menos 3 pares não coplanares para observabilidade; filtre estrelas por magnitude <6.",
                                  "learningObjective": "Preparar dados reaisisticos de sensores de estrelas para input no QUEST.",
                                  "commonMistakes": [
                                    "Não normalizar vetores unitários",
                                    "Selecionar pares muito próximos causando ambiguidade",
                                    "Ignorar ruído gaussiano nas observações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Algoritmo QUEST para Estimativa de Quaternion",
                                  "subSteps": [
                                    "Implemente a inicialização QUEST: compute autovalores de K = 4B^T B - trace(B) I.",
                                    "Selecione o maior autovalor λ_max e forme quaternion q = [β; λ_max α], onde α/β de K.",
                                    "Execute iterações de refinamento: minimize J(q) = 1 - q^T B q com Newton-Raphson ou gradient descent.",
                                    "Normalize o quaternion final: q = q / ||q||.",
                                    "Teste com dados simulados: compare com rotação conhecida."
                                  ],
                                  "verification": "Código QUEST converge para ||q||=1 e erro de rotação <0.1 graus em simulação sem ruído.",
                                  "estimatedTime": "4 hours",
                                  "materials": [
                                    "Python: NumPy, SciPy (eig, optimize)",
                                    "Código QUEST open-source (GitHub: pyattitude ou similar)"
                                  ],
                                  "tips": "Limite iterações a 10 para eficiência em tempo real; use SVD como fallback se QUEST falhar.",
                                  "learningObjective": "Codificar o solver QUEST para quaternions de atitude precisos.",
                                  "commonMistakes": [
                                    "Erro na matriz K (falta trace)",
                                    "Não tratar ambiguidade de sinal no quaternion (q vs -q)",
                                    "Convergência lenta por step size inadequado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair Ângulos de Roll, Pitch e Yaw e Validar Precisão",
                                  "subSteps": [
                                    "Converta quaternion para matriz de rotação DCM: use fórmula Rodrigues ou quaternion-to-DCM.",
                                    "Extraia ângulos Euler: roll = atan2(DCM[3,2], DCM[3,3]), pitch = asin(-DCM[3,1]), yaw = atan2(DCM[2,1], DCM[2,2]).",
                                    "Adicione ruído realista (1-10 arcsec) e reexecute para testar robustez.",
                                    "Calcule erro residual: RMS = sqrt( média (1 - b_i · A r_i) ), mire <10 arcsec.",
                                    "Visualize resultados: plote vetores alinhados before/after."
                                  ],
                                  "verification": "Ângulos Euler reproduzem verdadeiros com erro <10 arcsegundos em 90% dos testes.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Python: NumPy para DCM, Matplotlib para plots 3D"
                                  ],
                                  "tips": "Use convenção 3-2-1 Euler para aeroespacial; converta arcsec para radianos (1 arcsec = 4.848e-6 rad).",
                                  "learningObjective": "Converter quaternion em ângulos Euler navegáveis com precisão astrométrica.",
                                  "commonMistakes": [
                                    "Gimbal lock perto de pitch=±90°",
                                    "Erro de sinal em atan2",
                                    "Unidades erradas (graus vs radianos)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Otimizar para Cenários Reais",
                                  "subSteps": [
                                    "Simule cenários: baixa quantidade de estrelas (2-3 pares), obstruções, ruído alto.",
                                    "Integre com Kalman filter mockup para fusão multi-sensor.",
                                    "Meça performance: tempo de execução <100ms, precisão vs N pares.",
                                    "Otimize código: vetorize com NumPy, profile com %timeit.",
                                    "Documente pipeline completo em notebook reproduzível."
                                  ],
                                  "verification": "Pipeline processa 100 simulações com média de erro <5 arcsec e taxa de sucesso >95%.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Ferramentas: Jupyter, Git para versionamento",
                                    "Dados: simulações com ruído (SciPy stats)"
                                  ],
                                  "tips": "Para CubeSats, priorize low-compute; teste com dados reais de missão (ex: CubeSat attitude logs).",
                                  "learningObjective": "Aplicar e refinar o método em condições operacionais espaciais.",
                                  "commonMistakes": [
                                    "Sobrecarga computacional em iterações excessivas",
                                    "Não testar edge cases como alinhamento singular",
                                    "Ignorar covariância de erros para fusão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat com sensor de estrelas APS (Autonomous Star Tracker), detecte 4 pares de estrelas durante órbita LEO. Use QUEST para estimar quaternion de uma atitude conhecida (roll=10°, pitch=-5°, yaw=45°), adicionando ruído de 5 arcsec. Converta para Euler e verifique alinhamento residual <3 arcsec, simulando controle de apontamento para aquisição de imagem terrestre.",
                              "finalVerifications": [
                                "Código implementa QUEST com convergência em <10 iterações.",
                                "Precisão de atitude: erro RMS <10 arcsegundos em testes com ruído.",
                                "Conversão quaternion-to-Euler sem singularidades em faixa operacional.",
                                "Pipeline processa dados em <200ms para uso em tempo real.",
                                "Visualizações confirmam alinhamento vetorial (ângulo <0.01°).",
                                "Testes com 2-8 pares mantêm observabilidade."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: equações de Wahba/QUEST implementadas precisamente (90% match com referências).",
                                "Precisão numérica: erro <10 arcsec em 80% dos cenários simulados.",
                                "Eficiência: tempo de CPU <100ms por solução em hardware embarcado simulado.",
                                "Robustez: sucesso >95% com ruído e poucos pares.",
                                "Documentação: código comentado, notebook com exemplos reproduzíveis.",
                                "Inovação: otimizações ou extensões (ex: QUEST+GYRO).",
                                "Apresentação: relatório explicando resultados com plots."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores, SVD), Otimização não-linear.",
                                "Computação: Métodos numéricos, Programação científica (NumPy/SciPy).",
                                "Física: Mecânica celeste, Cinemática de rotação rígida.",
                                "Engenharia: Sistemas embarcados, Controle de atitude (Kalman filtering).",
                                "Astronomia: Catálogos estelares, Astrometria precisa."
                              ],
                              "realWorldApplication": "Em satélites como o Hubble Space Telescope ou Swarm (ESA), sensores de estrelas usam QUEST/Wahba para determinação de atitude com precisão sub-arcsegundo, essencial para apontamento de antenas, aquisição de alvos terrestres e estabilização em órbitas perturadas, consumindo <1% da potência do veículo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Integrar medições em filtros de Kalman",
                            "description": "Explicar a fusão de dados do sensor de estrelas com giroscópios inerciais ou magnetômetros para estimativa contínua de atitude em tempo real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Modelo de Estado do Filtro de Kalman para Atitude",
                                  "subSteps": [
                                    "Definir o vetor de estado usando quaternions para representar a atitude (q = [q0, q1, q2, q3]) e velocidades angulares (ω = [ωx, ωy, ωz]).",
                                    "Escrever as equações de transição de estado baseadas na cinemática de quaternions: dq/dt = 0.5 * Ω(ω) * q, onde Ω é a matriz skew-symmetric.",
                                    "Discretizar o modelo para tempo discreto usando integração numérica (ex: Runge-Kutta de ordem 4).",
                                    "Definir a matriz de covariância inicial P0 e vetores de ruído de processo Q para giroscópios.",
                                    "Implementar a função de predição inicial em código."
                                  ],
                                  "verification": "Execute a predição sem medições e verifique se a covariância P cresce monotonicamente e a atitude propaga corretamente de um estado inicial conhecido.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com NumPy e SciPy; documentação de filtros de Kalman estendidos (EKF); Jupyter Notebook.",
                                  "tips": "Use quaternions normalizados para evitar deriva numérica; normalize após cada propagação.",
                                  "learningObjective": "Compreender e implementar o modelo de estado não-linear para estimativa de atitude.",
                                  "commonMistakes": "Esquecer de normalizar quaternions, levando a magnitudes >1; confundir ordem dos componentes do quaternion."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Medições de Sensores e Matriz de Observação",
                                  "subSteps": [
                                    "Modelar medições do sensor de estrelas como vetor unitário de direção da estrela no frame corporal transformado para o frame inercial via quaternion.",
                                    "Derivar a matriz de observação H para sensor de estrelas: h = C(q) * s, onde C(q) é a matriz de rotação DCM e s é o vetor da estrela.",
                                    "Incluir modelos de ruído para sensor de estrelas (alta precisão, ~arcsec) e magnetômetros (vetor magnético local).",
                                    "Definir matriz de covariância de medição R baseada em especificações de sensores reais.",
                                    "Implementar função para linearizar H em torno do estado atual para EKF."
                                  ],
                                  "verification": "Calcule H para um quaternion conhecido e uma estrela; verifique se h corresponde à rotação esperada comparando com DCM explícita.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código Python anterior; referências como 'Strapdown Inertial Navigation' de Titterton; calculadora simbólica (SymPy).",
                                  "tips": "Use múltiplas estrelas para observabilidade; selecione estrelas não alinhadas com o eixo de rotação.",
                                  "learningObjective": "Modelar observações não-lineares de sensores vetoriais em filtros de Kalman.",
                                  "commonMistakes": "Não linearizar corretamente para EKF, causando divergência; ignorar ruído correlacionado entre eixos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Predição e Atualização no Filtro de Kalman Estendido",
                                  "subSteps": [
                                    "Implementar passo de predição: x_pred = f(x_est, u), P_pred = F P F^T + Q, onde F é a jacobiana.",
                                    "Implementar passo de atualização: K = P_pred H^T (H P_pred H^T + R)^-1; x_est = x_pred + K(z - h(x_pred)); P_est = (I - K H) P_pred.",
                                    "Integre medições de estrelas quando disponíveis (ex: a cada 10s) com propagação contínua via giroscópios.",
                                    "Adicionar lógica para detecção de outlier em medições (ex: teste de Mahalanobis).",
                                    "Codificar o loop principal do filtro em uma simulação de tempo real."
                                  ],
                                  "verification": "Rode uma simulação com ruído e verifique se erro de atitude cai abaixo de 0.1° após convergência.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Biblioteca SciPy para inversão de matrizes; simulador de dinâmica orbital simples.",
                                  "tips": "Monitore determinante de P para detectar singularidades; use fatorização QR para estabilidade numérica.",
                                  "learningObjective": "Executar fusão de dados em tempo real usando EKF para atitude.",
                                  "commonMistakes": "Inverter ordem de predição/atualização; não computar jacobianas analiticamente, levando a imprecisão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, Testar e Otimizar o Filtro",
                                  "subSteps": [
                                    "Gerar dados simulados: trajetória de atitude real + ruído em giroscópios e estrelas.",
                                    "Executar filtro múltiplas vezes variando tuning de Q e R.",
                                    "Calcular métricas: RMSE de quaternion, tempo de convergência, taxa de rejeição de outliers.",
                                    "Otimizar hiperparâmetros via grid search ou otimização bayesiana.",
                                    "Visualizar resultados com plots de erro vs tempo e elipses de covariância."
                                  ],
                                  "verification": "Compare estimativa com verdade fundamental; erro RMS < especificação do sensor (ex: 10 arcsec).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Matplotlib/Plotly para visualização; dados de sensores reais (ex: de CubeSat missions).",
                                  "tips": "Simule falhas de sensor para testar robustez; logue todos os estados para debug.",
                                  "learningObjective": "Validar e refinar filtros de Kalman em cenários realistas.",
                                  "commonMistakes": "Sobreajustar Q/R causando overfitting ao ruído simulado; ignorar wrap-around em ângulos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com Dados Reais e Análise de Sensibilidade",
                                  "subSteps": [
                                    "Baixar dataset real de missão (ex: ASTERIX ou IRASSI para sensor de estrelas).",
                                    "Ajustar modelo para biases e scale factors dos sensores reais.",
                                    "Executar análise de sensibilidade variando condições (ex: campo estelar denso vs escasso).",
                                    "Comparar performance com filtros alternativos (ex: UKF ou PF).",
                                    "Documentar limitações e recomendações para implementação embarcada."
                                  ],
                                  "verification": "Performance em dados reais dentro de 2x da simulação; relatório com plots.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Datasets públicos de attitude determination (NASA, ESA); hardware simulado (ex: STM32 com Python wrapper).",
                                  "tips": "Calibre biases offline primeiro; considere processamento em tempo real com deadlines.",
                                  "learningObjective": "Aplicar filtro a dados empíricos e analisar trade-offs.",
                                  "commonMistakes": "Não calibrar biases, causando drift; assumir simetria em ruídos assimétricos."
                                }
                              ],
                              "practicalExample": "Em um CubeSat como o da missão QB50, integre medições do sensor de estrelas (1 medida/min) com giroscópios (100 Hz) para manter atitude precisa durante manobras de pointing nadir, reduzindo erro de 5° (open-loop) para 0.05° em regime estacionário.",
                              "finalVerifications": [
                                "O filtro converge em <30s para condições nominais.",
                                "Erro RMS de atitude < 10 arcsec em simulação longa (1 órbita).",
                                "Covariância P estabiliza sem crescimento ilimitado.",
                                "Rejeita >95% dos outliers injetados.",
                                "Performance em tempo real: ciclo <10ms em hardware alvo.",
                                "Quaternions permanecem normalizados (|q| = 1 ± 1e-6)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: RMSE de atitude vs ground truth < especificação.",
                                "Robustez: Mantém performance com 50% de medições perdidas.",
                                "Eficiência: Tempo computacional < limite embarcado.",
                                "Linearização: Jacobianas derivadas corretamente (teste unitário).",
                                "Tuning: Q/R otimizados via métrica de custo (ex: NEES).",
                                "Documentação: Código comentado com equações inline."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (jacobianas, SVD), probabilidade (distribuições gaussianas).",
                                "Física: Cinemática rotacional, campos magnéticos terrestres.",
                                "Programação: Otimização numérica, simulação em tempo discreto.",
                                "Engenharia de Controle: Observabilidade, estabilizadores LQR.",
                                "Ciência de Dados: Fusão sensorial bayesiana."
                              ],
                              "realWorldApplication": "Em satélites como o James Webb Space Telescope ou CubeSats para observação terrestre, onde filtros de Kalman fundem sensores de estrelas com giro/IMUs para controle preciso de attitude, essencial para imaging de alta resolução e comunicações apontadas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Simular erros e calibração do sensor",
                            "description": "Modelar erros sistemáticos (distorsão óptica, alinhamento) e técnicas de calibração in-flight para manter precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Modelar Erros Sistemáticos em Sensores de Estrelas",
                                  "subSteps": [
                                    "Estude os tipos principais de erros: distorção óptica (radial e tangencial), desalinhamento do eixo boresight e erros de escala.",
                                    "Colete dados de catálogo de estrelas (ex: Hipparcos) e parâmetros típicos de sensores reais (FOV, resolução).",
                                    "Desenvolva equações matemáticas para modelar cada erro, como modelo polinomial para distorção: r' = r (1 + k1 r^2 + k2 r^4).",
                                    "Implemente um script inicial em Python para gerar posições de estrelas ideais vs. distorcidas.",
                                    "Valide o modelo comparando com dados simulados ou reais de sensores conhecidos."
                                  ],
                                  "verification": "Gere um gráfico comparando posições ideais e com erro; o desvio deve coincidir com parâmetros de entrada (±5%).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com NumPy, Matplotlib e Astropy",
                                    "Catálogo Hipparcos (download gratuito)",
                                    "Documentação de sensores como CYGNSS Star Tracker"
                                  ],
                                  "tips": "Comece com distorção radial simples antes de adicionar termos complexos; use unidades consistentes (radianos).",
                                  "learningObjective": "Compreender e quantificar fontes de erro sistemático em sensores ópticos espaciais.",
                                  "commonMistakes": [
                                    "Ignorar normalização de coordenadas de imagem",
                                    "Confundir erros sistemáticos com aleatórios",
                                    "Usar graus em vez de radianos nas equações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Simulação de Sensor com Erros Injetados",
                                  "subSteps": [
                                    "Crie um simulador de cena estelar: posicione o sensor em uma atitude conhecida e projete estrelas no plano focal.",
                                    "Injete erros modelados: aplique matriz de rotação para desalinhamento e distorção não-linear às coordenadas.",
                                    "Adicione ruído gaussiano para simular erros aleatórios e efeitos de saturação para estrelas brilhantes.",
                                    "Gere datasets de observações simuladas para múltiplas atitudes (ex: 1000 cenários aleatórios).",
                                    "Exporte dados em formato compatível com algoritmos de atitude (quaternions verdadeiros vs. observados)."
                                  ],
                                  "verification": "Execute simulação e compute RMSE entre atitudes verdadeiras e medidas; deve ser >1 arcmin sem calibração.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Python com SciPy para otimização",
                                    "Biblioteca Skyfield para efemérides estelares",
                                    "Jupyter Notebook para visualização"
                                  ],
                                  "tips": "Use vetores unitários para direções estelares; teste com estrelas conhecidas como Sirius para validação visual.",
                                  "learningObjective": "Construir um ambiente de simulação realista para testar robustez de sistemas de atitude.",
                                  "commonMistakes": [
                                    "Não sincronizar tempo de observação com posição da Terra",
                                    "Escala errada no plano focal (pixels vs. mm)",
                                    "Sobrecarregar simulação com muitos erros de uma vez"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Técnicas de Calibração In-Flight",
                                  "subSteps": [
                                    "Implemente método de Lost-in-Space (LIS) para aquisição inicial usando bancos de dados de padrões estelares.",
                                    "Aplique otimização não-linear (Levenberg-Marquardt) para estimar parâmetros de erro minimizando resíduos.",
                                    "Desenvolva loop de calibração iterativa: meça attitude, atualize parâmetros, re-simule e refine.",
                                    "Incorpore restrições físicas (ex: k1 > 0 para distorção pincushion) e detecção de outliers.",
                                    "Teste convergência em simulações com ruído crescente e atitudes dinâmicas."
                                  ],
                                  "verification": "Após 5 iterações, RMSE deve cair para <0.1 arcmin; plote convergência dos parâmetros.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "SciPy.optimize para LM",
                                    "Biblioteca PyQuaternion para manipulação de atitudes",
                                    "Dados de teste gerados no Step 2"
                                  ],
                                  "tips": "Inicialize parâmetros com valores nominais do fabricante; use múltiplos LIS para robustez.",
                                  "learningObjective": "Dominar algoritmos de auto-calibração adaptativos para ambientes espaciais.",
                                  "commonMistakes": [
                                    "Sobreajuste (overfitting) devido a poucos dados",
                                    "Ignorar covariância entre parâmetros de erro",
                                    "Não tratar ambiguidades de quadrante em ângulos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Otimizar a Simulação de Calibração",
                                  "subSteps": [
                                    "Compare resultados calibrados com verdadeiros em cenários variados (órbita LEO, GEO).",
                                    "Analise sensibilidade: varie parâmetros de erro e meça impacto na precisão final.",
                                    "Implemente métricas de performance: tempo de convergência, taxa de sucesso (>95%).",
                                    "Otimize código para eficiência (vetorização NumPy) e adicione logging para depuração.",
                                    "Documente relatório com gráficos e conclusões sobre limitações."
                                  ],
                                  "verification": "Taxa de sucesso >95% em 500 testes; precisão <0.05 arcmin em condições nominais.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Pandas para análise de dados",
                                    "Matplotlib/Seaborn para plots avançados",
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": "Use Monte Carlo para análise estatística; foque em edge cases como baixa densidade estelar.",
                                  "learningObjective": "Avaliar e refinar sistemas de simulação para aplicações mission-critical.",
                                  "commonMistakes": [
                                    "Testes só em condições ideais",
                                    "Confundir precisão com acurácia",
                                    "Não reportar intervalos de confiança"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO com sensor de estrelas CYGNSS distorcido (k1=0.01). Injete desalinhamento de 0.5° no roll. Execute calibração in-flight usando observações de 20 estrelas por frame, reduzindo erro de atitude de 2 arcmin para 0.03 arcmin após 10 iterações.",
                              "finalVerifications": [
                                "Simulação reproduz erros realistas validados contra dados de sensores conhecidos.",
                                "Calibração converge consistentemente (<10 iterações) com RMSE <0.1 arcmin.",
                                "Sistema lida com ruído SNR=20dB e falhas de detecção de 10% das estrelas.",
                                "Parâmetros calibrados fisicamente plausíveis (ex: |desalinhamento| <1°).",
                                "Análise de sensibilidade mostra robustez a variações orbitais.",
                                "Código executa em <1s por frame para simulações em tempo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem de erros (desvio <5% dos valores teóricos).",
                                "Eficiência da calibração (redução >90% no erro de atitude).",
                                "Robustez em cenários variados (sucesso >95%).",
                                "Clareza e completude do código com comentários e visualizações.",
                                "Análise quantitativa com métricas e gráficos interpretáveis.",
                                "Identificação correta de limitações e sugestões de melhoria."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e geometria projetiva.",
                                "Física: Óptica geométrica e mecânica orbital.",
                                "Programação: Simulação numérica e análise de dados.",
                                "Engenharia: Sistemas embarcados e controle de atitude.",
                                "Estatística: Análise de Monte Carlo e estimação de parâmetros."
                              ],
                              "realWorldApplication": "Em missões como o telescópio James Webb ou constelações Starlink, sensores de estrelas calibrados in-flight mantêm atitude precisa para comunicações e imagens, compensando degradação por radiação e vibrações de lançamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.4",
                            "name": "Avaliar aplicações em simulação de veículos espaciais",
                            "description": "Demonstrar uso em simulações de estabilização de atitude, referenciando dinâmicas de Sidi e Wiesel.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos Teóricos de Dinâmicas de Atitude",
                                  "subSteps": [
                                    "Estude os capítulos relevantes de 'Spacecraft Dynamics and Control' de Sidi, focando em equações de Euler e cinemática de atitude.",
                                    "Analise as contribuições de Wiesel em dinâmica de veículos espaciais, incluindo modelos de torque e perturbações.",
                                    "Derive as equações de estabilização de atitude para um corpo rígido.",
                                    "Compare modelos lineares e não-lineares para estabilização.",
                                    "Anote diferenças entre referências de Sidi e Wiesel."
                                  ],
                                  "verification": "Criar um resumo de 1 página com equações chave derivadas corretamente.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livros de Sidi e Wiesel (PDFs), caderno de anotações, calculadora simbólica como SymPy.",
                                  "tips": "Use diagramas vetoriais para visualizar quaternions de atitude.",
                                  "learningObjective": "Compreender as equações matemáticas subjacentes à estabilização de atitude.",
                                  "commonMistakes": "Confundir coordenadas de Euler com quaternions; ignorar termos de Coriolis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Simulação de Veículo Espacial",
                                  "subSteps": [
                                    "Instale software de simulação como MATLAB/Simulink ou Python com bibliotecas Orekit/Poliastro.",
                                    "Defina parâmetros do veículo: momento de inércia, sensores (star tracker), atuadores (reaction wheels).",
                                    "Implemente modelo dinâmico básico baseado em Sidi (equações 6.1-6.5).",
                                    "Adicione perturbações reais: gradiente gravitacional, pressão solar.",
                                    "Teste o modelo em estado livre para validar estabilidade."
                                  ],
                                  "verification": "Executar simulação inicial sem controlador e plotar trajetória de atitude estável.",
                                  "estimatedTime": "6 horas",
                                  "materials": "MATLAB/Simulink ou Python (Jupyter Notebook), documentação de Orekit.",
                                  "tips": "Comece com parâmetros de um CubeSat padrão para simplicidade.",
                                  "learningObjective": "Configurar um modelo realista de dinâmica de spacecraft simulável.",
                                  "commonMistakes": "Escala incorreta de unidades (km/s vs m/s); esquecer matriz de inércia diagonal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Algoritmo de Estabilização de Atitude",
                                  "subSteps": [
                                    "Escolha e codifique um controlador PD ou LQR referenciado em Wiesel.",
                                    "Integre dados de star tracker para determinação de atitude (QUEST algorithm).",
                                    "Aplique comandos de torque aos reaction wheels.",
                                    "Inclua filtros para ruído sensorial.",
                                    "Simule loop fechado com condições iniciais variadas."
                                  ],
                                  "verification": "Plotar gráficos de convergência de ângulos de atitude para <1 grau em 100s.",
                                  "estimatedTime": "8 horas",
                                  "materials": "Código fonte em MATLAB/Python, referências de algoritmos QUEST.",
                                  "tips": "Use quaternions para evitar singularidades de Euler.",
                                  "learningObjective": "Desenvolver e integrar um controlador funcional de atitude.",
                                  "commonMistakes": "Ganho de controlador excessivo causando oscilações; não linearizar modelo adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Simulações e Coletar Dados de Performance",
                                  "subSteps": [
                                    "Rode múltiplas simulações variando condições iniciais e perturbações.",
                                    "Registre métricas: erro de atitude, uso de combustível, tempo de settling.",
                                    "Compare resultados com benchmarks teóricos de Sidi/Wiesel.",
                                    "Analise sensibilidade a parâmetros (ex: ruído no star tracker).",
                                    "Gere relatórios com plots e tabelas estatísticas."
                                  ],
                                  "verification": "Gerar relatório com pelo menos 5 cenários simulados e métricas tabuladas.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Scripts de simulação, ferramentas de plotagem (Matplotlib).",
                                  "tips": "Automatize simulações com loops para eficiência.",
                                  "learningObjective": "Coletar dados empíricos de simulações para análise.",
                                  "commonMistakes": "Poucas runs levando a conclusões enviesadas; ignorar variância estatística."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar Aplicações e Validar Contra Referências",
                                  "subSteps": [
                                    "Compare performance simulada com resultados publicados em Sidi e Wiesel.",
                                    "Avalie robustez: falhas de sensor, saturação de atuadores.",
                                    "Identifique limitações do modelo e sugestões de melhoria.",
                                    "Calcule índices de performance (ISE, settling time).",
                                    "Documente conclusões sobre aplicabilidade em missões reais."
                                  ],
                                  "verification": "Escrever avaliação final de 500 palavras com recomendações.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Dados de simulação, papers originais de Sidi/Wiesel.",
                                  "tips": "Use métricas quantitativas para objetividade.",
                                  "learningObjective": "Criticar e validar aplicações simuladas criticamente.",
                                  "commonMistakes": "Sobrestimar precisão sem testes de Monte Carlo; desconsiderar trade-offs reais."
                                }
                              ],
                              "practicalExample": "Simule a estabilização de atitude de um CubeSat em órbita LEO usando star tracker e reaction wheels. Aplique controlador PD de Sidi, inicializando com 10 graus de erro, e demonstre convergência em 60 segundos apesar de perturbações solares, validando contra equação 7.12 de Wiesel.",
                              "finalVerifications": [
                                "Simulação executa sem crashes numéricos por 1000s.",
                                "Erro de atitude RMS < 0.5 graus em steady-state.",
                                "Tempo de settling < 120s para 90% dos casos.",
                                "Uso de momentum de wheels dentro de limites físicos.",
                                "Análise sensível mostra robustez a ±20% ruído sensorial.",
                                "Relatório compara quantitativamente com Sidi/Wiesel."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação teórica (equações corretas: 30%).",
                                "Qualidade dos resultados simulados (convergência e robustez: 25%).",
                                "Profundidade da análise comparativa (com referências: 20%).",
                                "Clareza de documentação e plots (15%).",
                                "Identificação de limitações e melhorias (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (quaternions, matrizes de rotação).",
                                "Física: Mecânica clássica e dinâmica orbital.",
                                "Programação: Modelagem numérica e controle em MATLAB/Python.",
                                "Engenharia de Sistemas: Integração sensor-atualador.",
                                "Estatística: Análise de Monte Carlo para validação."
                              ],
                              "realWorldApplication": "Em missões como o Telescópio Espacial James Webb ou satélites Starlink, onde estabilização precisa de atitude é crítica para apontamento de antenas e imaging, usando simulações validadas contra dinâmicas de Sidi/Wiesel para certificar controladores antes do lançamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Sensores Inerciais",
                    "description": "Determinação de atitude com base em giroscópios e acelerômetros inerciais para rastreamento de orientação relativa.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Giroscópios Inerciais",
                        "description": "Sensores que medem a taxa angular de rotação do veículo espacial, permitindo o rastreamento da variação relativa de atitude por integração temporal das medições.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Princípio de Funcionamento dos Giroscópios",
                            "description": "Explicar o princípio físico do efeito giroscópico, incluindo precessão e nutação, e como ele é utilizado para detectar rotações em três eixos ortogonais em veículos espaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos de Momento Angular e Giroscópio Básico",
                                  "subSteps": [
                                    "Estude a definição de momento angular como L = Iω, onde I é o momento de inércia e ω é a velocidade angular.",
                                    "Aprenda sobre a conservação do momento angular em sistemas isolados.",
                                    "Identifique as propriedades de um giroscópio: rotor simétrico girando em alta velocidade.",
                                    "Visualize diagramas de um giroscópio simples com eixos de rotação.",
                                    "Calcule exemplos numéricos simples de momento angular para rotores."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos de momento angular e giroscópio, e resolva um problema de cálculo básico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre momento angular (Khan Academy)",
                                    "Diagrama de giroscópio impresso ou digital",
                                    "Calculadora"
                                  ],
                                  "tips": "Use analogias como uma patinadora girando para entender conservação de momento angular.",
                                  "learningObjective": "Compreender os princípios físicos fundamentais que sustentam o funcionamento de um giroscópio.",
                                  "commonMistakes": [
                                    "Confundir momento angular com momento linear",
                                    "Ignorar a importância da alta velocidade de rotação do rotor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Efeito Giroscópico e Rigidez",
                                  "subSteps": [
                                    "Explique a rigidez giroscópica: resistência à mudança na orientação do eixo de rotação.",
                                    "Demonstre com equações vetoriais: torque τ = Ω × L, onde Ω é a taxa de rotação do eixo.",
                                    "Simule mentalmente ou com software o comportamento quando se aplica torque ao giroscópio.",
                                    "Diferencie rigidez de estabilidade estática.",
                                    "Analise exemplos de giroscópios de fibra óptica vs. mecânicos."
                                  ],
                                  "verification": "Desenhe um diagrama vetorial mostrando o torque resultante e explique por que o eixo não cai.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador online de giroscópio (PhET ou Gyroscope Simulator)",
                                    "Papel e lápis para diagramas",
                                    "Livro de física clássica (capítulo de rotação)"
                                  ],
                                  "tips": "Gire um pião físico para observar a rigidez na prática.",
                                  "learningObjective": "Dominar o efeito giroscópico primário e sua manifestação como rigidez.",
                                  "commonMistakes": [
                                    "Pensar que o giroscópio resiste ao torque diretamente em vez de perpendicularmente",
                                    "Subestimar o papel da simetria do rotor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Precessão e Nutação",
                                  "subSteps": [
                                    "Defina precessão: rotação lenta do eixo de spin em torno de um eixo vertical devido a torque gravitacional.",
                                    "Calcule a taxa de precessão Ω_p = τ / L.",
                                    "Explique nutação: oscilação rápida do eixo combinada com precessão.",
                                    "Compare precessão estável vs. nutação instável com gráficos de movimento.",
                                    "Discuta amortecimento em giroscópios reais para minimizar nutação."
                                  ],
                                  "verification": "Resolva um problema numérico de taxa de precessão para um pião e descreva a trajetória do eixo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Vídeos de precessão de piões (YouTube: Veritasium)",
                                    "Software de simulação (MATLAB ou Python com matplotlib)",
                                    "Folha de exercícios com problemas resolvidos"
                                  ],
                                  "tips": "Assista demonstrações em câmera lenta para visualizar precessão vs. nutação.",
                                  "learningObjective": "Entender os movimentos dinâmicos secundários do giroscópio sob torque externo.",
                                  "commonMistakes": [
                                    "Confundir precessão com nutação",
                                    "Esquecer que nutação é uma resposta transitória"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicação em Detecção de Rotações em Três Eixos Ortogonais",
                                  "subSteps": [
                                    "Descreva um Rate Gyro: mede taxa angular em um eixo específico.",
                                    "Explique configuração triaxial: três giroscópios ortogonais para medir ω_x, ω_y, ω_z.",
                                    "Discuta integração para determinar atitude: θ = ∫ω dt.",
                                    "Aborde erros como bias e drift em giroscópios inerciais espaciais.",
                                    "Analise uso em veículos espaciais como IMU (Inertial Measurement Unit)."
                                  ],
                                  "verification": "Monte um diagrama conceitual de um sistema triaxial e calcule atitude a partir de taxas angulares dadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Documentação NASA sobre giroscópios espaciais",
                                    "Simulador de IMU online",
                                    "Planilha Excel para integração numérica"
                                  ],
                                  "tips": "Pense em quaternions para evitar singularidades na integração de atitude.",
                                  "learningObjective": "Aplicar princípios giroscópicos à instrumentação aeroespacial para determinação de atitude.",
                                  "commonMistakes": [
                                    "Ignorar acoplamento entre eixos em configurações reais",
                                    "Confundir taxa angular com ângulo absoluto"
                                  ]
                                }
                              ],
                              "practicalExample": "Use um smartphone com app de giroscópio (como Sensor Kinetics) para medir rotações em três eixos enquanto gira o dispositivo. Observe os dados de ω_x, ω_y, ω_z em tempo real e compare com precessão simulada girando um pião físico sobre uma mesa, medindo a taxa de mudança da orientação com vídeo em câmera lenta.",
                              "finalVerifications": [
                                "Explicar verbalmente o efeito giroscópico usando vetores.",
                                "Resolver problema de precessão com números reais.",
                                "Desenhar configuração triaxial de giroscópios.",
                                "Identificar nutação em um vídeo de demonstração.",
                                "Calcular atitude integrada de dados de taxa angular.",
                                "Discutir limitações em ambientes espaciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual de momento angular e conservação (20%)",
                                "Compreensão correta de rigidez, precessão e nutação (30%)",
                                "Aplicação quantitativa com cálculos corretos (25%)",
                                "Clareza em diagramas e explicações (15%)",
                                "Integração ao contexto aeroespacial (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores, cálculo diferencial e integrais.",
                                "Física: Dinâmica de rotações e mecânica clássica.",
                                "Engenharia: Sensores e sistemas de controle.",
                                "Informática: Simulações numéricas em Python/MATLAB.",
                                "Química: Materiais para rotores de alta precisão."
                              ],
                              "realWorldApplication": "Em veículos espaciais como o Hubble Space Telescope ou satélites CubeSat, conjuntos de giroscópios inerciais detectam rotações em três eixos para manter atitude estável durante manobras, permitindo correções precisas sem depender de estrelas ou GPS, essencial em ambientes sem referências externas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Tipos de Giroscópios Utilizados em Espaçonaves",
                            "description": "Identificar e comparar tipos como Giroscópio de Laser de Anel (RLG), Giroscópio de Fibra Óptica (FOG) e MEMS, destacando vantagens, desvantagens e aplicações em sistemas de determinação de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Princípios Básicos dos Giroscópios Inerciais",
                                  "subSteps": [
                                    "Estude o princípio do efeito Sagnac, base para giroscópios ópticos como RLG e FOG.",
                                    "Revise conceitos de rotação angular e detecção de taxas de giro em sistemas inerciais.",
                                    "Identifique diferenças fundamentais entre giroscópios mecânicos tradicionais e os modernos baseados em óptica e MEMS.",
                                    "Analise diagramas esquemáticos de giroscópios inerciais genéricos.",
                                    "Pesquise a evolução histórica dos giroscópios em aplicações aeroespaciais."
                                  ],
                                  "verification": "Crie um diagrama anotado explicando o princípio de funcionamento de um giroscópio inercial e liste 3 diferenças chave entre tipos mecânicos e ópticos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro-texto de dinâmica de voo espacial",
                                    "Vídeos tutoriais sobre efeito Sagnac (YouTube/Khan Academy)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com analogias cotidianas, como um pião, para visualizar o momento angular.",
                                  "learningObjective": "Compreender os fundamentos físicos que permitem a detecção de rotações em giroscópios usados em espaçonaves.",
                                  "commonMistakes": [
                                    "Confundir taxa de giro com aceleração angular",
                                    "Ignorar o papel da inércia em ambientes de microgravidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Giroscópio de Laser de Anel (RLG)",
                                  "subSteps": [
                                    "Descreva a estrutura: anel quadrado ou triangular com lasers contrapropagantes.",
                                    "Explique como o efeito Sagnac gera diferença de frequência proporcional à rotação.",
                                    "Liste vantagens: alta precisão, sem partes móveis, longa vida útil.",
                                    "Identifique desvantagens: sensibilidade a vibrações, alto custo, tamanho maior.",
                                    "Pesquise exemplos de uso em espaçonaves como o Hubble Space Telescope."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras sobre RLG, incluindo equação do efeito Sagnac e uma aplicação específica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigos da NASA sobre RLG",
                                    "Simulador online de efeito Sagnac",
                                    "Folhas de cálculo para equações"
                                  ],
                                  "tips": "Use animações 3D para visualizar os feixes de laser se contrapondo.",
                                  "learningObjective": "Dominar o funcionamento, prós, contras e aplicações do RLG em determinação de atitude.",
                                  "commonMistakes": [
                                    "Esquecer que RLG requer dithering para evitar lock-in",
                                    "Superestimar robustez em ambientes de alta vibração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Giroscópio de Fibra Óptica (FOG) e MEMS",
                                  "subSteps": [
                                    "Para FOG: entenda o bobina de fibra óptica e interferômetro Sagnac passivo.",
                                    "Liste vantagens do FOG: compacto, custo menor que RLG, bom para taxas médias.",
                                    "Descreva desvantagens: drift térmico, menor precisão em longo prazo.",
                                    "Para MEMS: revise fabricação em silício, vibração-resistente, baixo custo.",
                                    "Compare limitações de MEMS: ruído maior, mas ideal para cubesats."
                                  ],
                                  "verification": "Crie uma tabela comparativa inicial entre FOG e MEMS com 4 colunas: estrutura, vantagens, desvantagens, aplicações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Datasheets de FOG da KVH Industries",
                                    "Documentos sobre MEMS da Analog Devices",
                                    "Ferramenta de tabela como Excel ou Google Sheets"
                                  ],
                                  "tips": "Foque em trade-offs quantitativos, como bias stability em °/h.",
                                  "learningObjective": "Comparar tecnicamente FOG e MEMS, destacando suitability para missões espaciais.",
                                  "commonMistakes": [
                                    "Confundir FOG ativo com passivo",
                                    "Subestimar escalabilidade de MEMS para nano-satélites"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Tipos e Aplicações em Sistemas de Atitude",
                                  "subSteps": [
                                    "Compile tabela final: RLG vs FOG vs MEMS em precisão, custo, tamanho, robustez.",
                                    "Analise seleções reais: RLG em naves tripuladas (Shuttle), FOG em satélites, MEMS em cubesats.",
                                    "Discuta integração em AHRS (Attitude and Heading Reference Systems).",
                                    "Simule cenários de falha e redundância em espaçonaves.",
                                    "Crie fluxograma de escolha de giroscópio baseado em requisitos da missão."
                                  ],
                                  "verification": "Apresente uma tabela comparativa completa e justifique escolha para 2 missões hipotéticas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Relatórios de missões da NASA/ESA",
                                    "Software de simulação como MATLAB para AHRS",
                                    "Templates de tabelas comparativas"
                                  ],
                                  "tips": "Use métricas padronizadas como ARW (Angular Random Walk) para comparações objetivas.",
                                  "learningObjective": "Aplicar conhecimentos para selecionar e justificar giroscópios em contextos de determinação de atitude espacial.",
                                  "commonMistakes": [
                                    "Ignorar calibração in-flight",
                                    "Generalizar aplicações sem considerar constraints de potência"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um cubesat para monitoramento climático, selecione MEMS para baixo custo e tamanho, mas integre FOG como backup para precisão em órbita baixa; simule no MATLAB a determinação de atitude durante manobras.",
                              "finalVerifications": [
                                "Liste corretamente os 3 tipos de giroscópios e suas bases físicas.",
                                "Explique vantagens/desvantagens de cada um com exemplos quantitativos.",
                                "Crie uma tabela comparativa precisa.",
                                "Justifique uso em pelo menos 2 missões reais de espaçonaves.",
                                "Desenhe diagrama de integração em um sistema de atitude.",
                                "Identifique 3 cenários onde um tipo é preferível sobre os outros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição técnica (80% das specs corretas).",
                                "Profundidade da comparação (cobertura de prós/contras e métricas).",
                                "Relevância às aplicações espaciais (exemplos contextualizados).",
                                "Clareza em diagramas e tabelas (legíveis e anotados).",
                                "Criatividade em simulações práticas ou fluxogramas.",
                                "Ausência de erros conceituais comuns (ex: confusão Sagnac)."
                              ],
                              "crossCurricularConnections": [
                                "Física Óptica: Efeito Sagnac e interferometria.",
                                "Engenharia Elétrica: Sensores e processamento de sinal.",
                                "Matemática: Equações diferenciais de rotação e filtros Kalman.",
                                "Programação: Simulações em Python/MATLAB para AHRS.",
                                "Gestão de Projetos: Trade-offs custo vs performance em missões espaciais."
                              ],
                              "realWorldApplication": "Na Estação Espacial Internacional (ISS), RLGs fornecem dados precisos de atitude para alinhamento solar; em missões como Mars Rover, FOGs e MEMS otimizam navegação autônoma em ambientes hostis, garantindo estabilidade durante correções orbitais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Integração de Sinais de Giroscópios para Atitude Relativa",
                            "description": "Demonstrar a integração numérica (usando métodos como Euler ou Runge-Kutta) das taxas angulares medidas para obter ângulos de atitude relativos, considerando erros de deriva e bias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos dos Sinais de Giroscópios e Atitude Relativa",
                                  "subSteps": [
                                    "Estude o princípio de funcionamento dos giroscópios inerciais e como eles medem taxas angulares (ωx, ωy, ωz).",
                                    "Aprenda a relação matemática entre taxa angular e ângulo de atitude: dθ/dt = ω.",
                                    "Identifique conceitos de atitude relativa em veículos espaciais, como ângulos em relação a outro corpo.",
                                    "Revise limitações iniciais: acumulação de erros por deriva (drift) e bias.",
                                    "Explore representações de atitude (quaternions vs. ângulos de Euler) para contexto."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo os conceitos chave e envie para revisão.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação técnica de giroscópios (ex: ADIS16488 datasheet)",
                                    "Livro 'Spacecraft Dynamics and Control' (Sidi)",
                                    "Vídeos introdutórios sobre IMU"
                                  ],
                                  "tips": "Use animações 3D para visualizar rotações e acumulação de erros.",
                                  "learningObjective": "Entender a física subjacente e equações diferenciais envolvidas na integração de atitude.",
                                  "commonMistakes": [
                                    "Confundir taxa angular com aceleração angular",
                                    "Ignorar não-linearidades em rotações 3D"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar e Selecionar Métodos de Integração Numérica",
                                  "subSteps": [
                                    "Implemente o método de Euler forward: θ_{n+1} = θ_n + ω Δt.",
                                    "Estude e codifique o método Runge-Kutta de ordem 4 (RK4) para maior precisão.",
                                    "Compare estabilidade e precisão dos métodos em cenários com ruído.",
                                    "Discuta trade-offs: simplicidade vs. precisão, custo computacional.",
                                    "Adapte para integração vetorial em 3 eixos, considerando matrizes de rotação."
                                  ],
                                  "verification": "Gere gráficos comparando Euler e RK4 para uma taxa angular constante; erro <5% em 10s.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB/Simulink",
                                    "Tutorial 'Numerical Recipes' capítulo de integração"
                                  ],
                                  "tips": "Sempre normalize Δt pequeno (ex: 0.01s) para estabilidade.",
                                  "learningObjective": "Dominar métodos numéricos básicos para resolver EDOs de primeira ordem.",
                                  "commonMistakes": [
                                    "Passo de tempo Δt muito grande causando instabilidade",
                                    "Não tratar overflow em ângulos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Integração em Simulação com Dados de Giroscópio",
                                  "subSteps": [
                                    "Carregue dados simulados ou reais de giroscópio (taxas angulares com ruído).",
                                    "Codifique loop de integração em Python/MATLAB usando Euler ou RK4.",
                                    "Visualize resultados: plote ω vs. t e θ integrado vs. t.",
                                    "Teste com cenários reais: rotação constante, manobras sinusoidais.",
                                    "Salve ângulos em quaternions para evitar gimbal lock."
                                  ],
                                  "verification": "Execute simulação de 60s; ângulo final coincide com analítico θ=ωt dentro de 2°.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Bibliotecas: NumPy, Matplotlib, SciPy.integrate",
                                    "Dados de exemplo de IMU (Kaggle datasets)"
                                  ],
                                  "tips": "Use vetores unitários para quaternions e teste com rotação conhecida.",
                                  "learningObjective": "Aplicar métodos numéricos em código para processar sinais reais de sensores.",
                                  "commonMistakes": [
                                    "Não adicionar ruído realista aos dados de entrada",
                                    "Ignorar sincronização de amostragem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Modelar e Compensar Erros de Bias e Deriva",
                                  "subSteps": [
                                    "Estime bias médio dos dados de giroscópio (média em período quiescente).",
                                    "Subtraia bias antes da integração: ω_corrected = ω_measured - bias.",
                                    "Modele deriva como rampa linear e implemente correção (ex: least-squares).",
                                    "Integre com e sem correções; compare drift acumulado.",
                                    "Valide com fusão sensorial simulada (ex: adicionar magnetômetro para reset)."
                                  ],
                                  "verification": "Após correção, drift <0.1°/min em teste quiescente de 10min.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código da Step 3",
                                    "Ferramentas de filtering: Kalman filter basics (opcional)",
                                    "Referência: ' strapdown inertial navigation' papers"
                                  ],
                                  "tips": "Calcule bias dinamicamente com janela móvel para adaptação.",
                                  "learningObjective": "Identificar e mitigar fontes de erro sistemático em sensores inerciais.",
                                  "commonMistakes": [
                                    "Assumir bias zero sem medição",
                                    "Não reestimar bias periodicamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Otimizar a Integração Completa",
                                  "subSteps": [
                                    "Simule missão completa: aquisição de dados, integração, correção de erros.",
                                    "Compare com verdade terrestre (ground truth) gerada analiticamente.",
                                    "Otimize parâmetros: Δt, ordem do método, thresholds de bias.",
                                    "Gere relatório com métricas: RMSE, max error, tempo de execução.",
                                    "Teste robustez: adicione vibrações, variações de temperatura."
                                  ],
                                  "verification": "RMSE total <1° após 30min de simulação; código roda em <1s.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código integrado das steps anteriores",
                                    "Ferramentas de profiling (timeit em Python)"
                                  ],
                                  "tips": "Use version control (Git) para iterar otimizações.",
                                  "learningObjective": "Avaliar performance holística e iterar melhorias.",
                                  "commonMistakes": [
                                    "Sobreajuste a um cenário específico",
                                    "Esquecer validação cruzada"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um satélite em órbita baixa girando a 0.1 rad/s em torno do eixo z por 600s. Use dados de giroscópio com bias de 0.01 rad/s e ruído gaussiano (σ=0.005 rad/s). Integre com RK4 após correção de bias e compare θ_integrado com θ_verdadeiro = 0.1 * t, visando erro <0.5°.",
                              "finalVerifications": [
                                "Ângulos de atitude integrados coincidem com solução analítica dentro de 1% em testes controlados.",
                                "Drift acumulado após correção de bias é inferior a 0.05°/min.",
                                "Simulação roda em tempo real (fator >1x) com Δt=0.01s.",
                                "Visualizações mostram convergência suave sem oscilações numéricas.",
                                "Código é modular e comentado, reproduzível por terceiros.",
                                "Testes com ruído variado mantêm precisão >95%."
                              ],
                              "assessmentCriteria": [
                                "Precisão da integração: RMSE <1° em 10min.",
                                "Estabilidade numérica: sem divergência em simulações longas (>1h).",
                                "Correção de erros: redução de bias >90% efetiva.",
                                "Eficiência computacional: <10ms por iteração em hardware padrão.",
                                "Robustez: performance consistente com ±20% variação em ruído/bias.",
                                "Qualidade do código: limpo, com testes unitários para funções chave."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Métodos numéricos para EDOs (Euler, Runge-Kutta).",
                                "Programação: Algoritmos numéricos em Python/MATLAB, visualização de dados.",
                                "Física: Cinemática e dinâmica rotacional, mecânica orbital.",
                                "Engenharia de Controle: Estimadores de estado, filtros (Kalman intro).",
                                "Estatística: Análise de ruído, estimação de parâmetros (bias)."
                              ],
                              "realWorldApplication": "Em satélites e sondas espaciais (ex: CubeSats), essa técnica permite determinação autônoma de atitude durante fases sem GPS ou estrelas visíveis, essencial para manobras de controle e apontamento de antenas/câmeras, como na missão Mars Rover ou estações espaciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Acelerômetros Inerciais",
                        "description": "Sensores que medem acelerações lineares específicas em três eixos, contribuindo para a determinação de atitude relativa ao detectar componentes de aceleração não-gravitacional e auxiliar na correção de erros giroscópicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Princípio de Funcionamento dos Acelerômetros",
                            "description": "Descrever os princípios de medição baseados em força (capacitivo, piezorresistivo) e como eles detectam acelerações lineares em ambientes de microgravidade em espaçonaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos de Aceleração e Sensores Inerciais",
                                  "subSteps": [
                                    "Defina aceleração linear e sua importância em veículos espaciais.",
                                    "Explique o princípio inercial: massa em repouso relativo detecta forças via Segunda Lei de Newton (F=ma).",
                                    "Descreva componentes básicos de um acelerômetro: prova-massa, molas e transdutores.",
                                    "Compare aceleração em gravidade terrestre vs. microgravidade.",
                                    "Identifique tipos de medição baseados em força (capacitiva e piezorresistiva)."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes e o princípio inercial, confirmando com fórmulas básicas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro-texto de física (mecânica), papel e lápis para diagramas, vídeo introdutório sobre sensores inerciais (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use analogias como um pendulo em um carro acelerando para visualizar a prova-massa.",
                                  "learningObjective": "Compreender os princípios físicos fundamentais por trás da detecção de aceleração.",
                                  "commonMistakes": [
                                    "Confundir aceleração linear com angular.",
                                    "Ignorar o papel da microgravidade na sensibilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Princípio Capacitivo de Medição",
                                  "subSteps": [
                                    "Descreva como a deslocamento da prova-massa altera a capacitância entre placas.",
                                    "Estude a fórmula C = εA/d e como variação de d afeta C.",
                                    "Explique o circuito de detecção: oscilador ou ponte de capacitância para medir mudanças.",
                                    "Analise calibração e linearidade da resposta.",
                                    "Simule com software como LTSpice um modelo capacitivo simples."
                                  ],
                                  "verification": "Calcule capacitância para deslocamentos de 1μm e 10μm, plotando gráfico de resposta.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software de simulação (LTSpice ou Tinkercad), calculadora, datasheet de acelerômetro capacitivo (ex: ADXL series)"
                                  ],
                                  "tips": "Comece com valores pequenos de deslocamento para evitar não-linearidades em grandes acelerações.",
                                  "learningObjective": "Dominar o funcionamento e modelagem de acelerômetros capacitivos.",
                                  "commonMistakes": [
                                    "Esquecer o efeito da área das placas ou permissividade.",
                                    "Confundir capacitância com resistência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Princípio Piezorresistivo de Medição",
                                  "subSteps": [
                                    "Explique o efeito piezorresistivo: mudança na resistividade sob tensão mecânica.",
                                    "Descreva configuração Wheatstone bridge com strain gauges na prova-massa.",
                                    "Analise a equação ΔR/R = GF * ε, onde GF é fator de gauge e ε é deformação.",
                                    "Discuta temperatura compensation e ruído térmico.",
                                    "Compare sensibilidade com método capacitivo via gráficos de resposta."
                                  ],
                                  "verification": "Monte um circuito Wheatstone virtual e meça variação de tensão para deformação simulada.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Multisim ou similar para simulação, strain gauge datasheet (ex: MEMS piezoresistivo), osciloscópio virtual"
                                  ],
                                  "tips": "Foque em bridges balanceadas para máxima sensibilidade diferencial.",
                                  "learningObjective": "Entender detecção piezorresistiva e suas vantagens em precisão.",
                                  "commonMistakes": [
                                    "Ignorar deriva térmica.",
                                    "Confundir piezorresistivo com piezoelétrico."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicação em Microgravidade e Espaçonaves",
                                  "subSteps": [
                                    "Discuta desafios em microgravidade: ausência de bias gravitacional, maior sensibilidade a vibrações.",
                                    "Explique integração em IMU (Inertial Measurement Units) para determinação de atitude.",
                                    "Analise filtros (Kalman) para dados de acelerômetros em espaçonaves.",
                                    "Estude casos reais: acelerômetros em satélites CubeSat ou ISS.",
                                    "Avalie limitações: drift, resolução em baixa aceleração."
                                  ],
                                  "verification": "Desenvolva um fluxograma de como dados de acelerômetros contribuem para controle de atitude.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Artigos NASA sobre IMU em microgravidade, software MATLAB para simulação Kalman básica"
                                  ],
                                  "tips": "Pesquise missões reais como Apollo ou SpaceX para contextualizar.",
                                  "learningObjective": "Aplicar princípios a cenários aeroespaciais reais.",
                                  "commonMistakes": [
                                    "Subestimar ruído em microgravidade.",
                                    "Confundir aceleração com velocidade integrada."
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um acelerômetro capacitivo DIY usando um capacitor variável e um smartphone app para medir inclinação; aplique aceleração manual simulando microgravidade (rotação lenta) e registre mudanças de capacitância via multímetro.",
                              "finalVerifications": [
                                "Explique verbalmente diferenças entre métodos capacitivo e piezorresistivo com diagramas.",
                                "Resolva problema: calcule deslocamento para 1g em acelerômetro capacitivo.",
                                "Simule resposta piezorresistiva para 0.01g em microgravidade.",
                                "Descreva pipeline de dados de IMU em espaçonave.",
                                "Identifique 3 vantagens de cada método em aplicações espaciais.",
                                "Crie tabela comparativa de sensibilidade e ruído."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual nos princípios físicos (80%+ correto).",
                                "Profundidade nos cálculos e simulações (gráficos lineares).",
                                "Relevância ao contexto aeroespacial/microgravidade.",
                                "Criatividade em exemplos práticos e verificações.",
                                "Clareza em diagramas e explicações.",
                                "Identificação correta de erros comuns e mitigações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica newtoniana e eletromagnetismo.",
                                "Eletrônica: Circuitos analógicos e sensores MEMS.",
                                "Matemática: Cálculo diferencial e filtros digitais.",
                                "Engenharia: Sistemas de controle e navegação inercial.",
                                "Computação: Simulações numéricas e processamento de sinais."
                              ],
                              "realWorldApplication": "Em espaçonaves como o Satélite James Webb ou Dragon da SpaceX, acelerômetros detectam acelerações lineares mínimas em microgravidade para correções de órbita, estabilização de atitude e navegação autônoma durante manobras, integrados a giroscópios em IMUs para precisão de microradianos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Tipos de Acelerômetros em Sistemas Inerciais",
                            "description": "Comparar acelerômetros quartz, MEMS e outros tipos usados em IMUs espaciais, focando em faixa dinâmica, ruído e estabilidade para aplicações de controle de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos e Classificação de Acelerômetros Inerciais",
                                  "subSteps": [
                                    "Revise os princípios de funcionamento de acelerômetros inerciais baseados em força (servo-pendulares) e capacitivos.",
                                    "Classifique os tipos principais: Quartz (resonadores de quartzo), MEMS (Micro-Eletro-Mecânicos Sistemas), e outros como ópticos ou piezelétricos usados em IMUs espaciais.",
                                    "Identifique contextos de uso em IMUs para controle de atitude em veículos espaciais.",
                                    "Pesquise exemplos históricos de IMUs espaciais (ex: Apollo Guidance Computer).",
                                    "Anote definições chave de faixa dinâmica, ruído (bias instability, angle random walk) e estabilidade (scale factor)."
                                  ],
                                  "verification": "Crie um diagrama de classificação com pelo menos 4 tipos e suas bases físicas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livros/textos sobre sensores inerciais (ex: 'Inertial Navigation Systems' de Titterton)",
                                    "Artigos da NASA sobre IMUs",
                                    "Acesso à internet para datasheets"
                                  ],
                                  "tips": [
                                    "Use tabelas para organizar classificações iniciais.",
                                    "Foquem em aplicações espaciais para filtrar irrelevantes."
                                  ],
                                  "learningObjective": "Compreender a taxonomia e princípios físicos dos acelerômetros em IMUs espaciais.",
                                  "commonMistakes": [
                                    "Confundir acelerômetros com giroscópios.",
                                    "Ignorar variações ambientais como temperatura em aplicações espaciais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Características Detalhadas de Acelerômetros Quartz",
                                  "subSteps": [
                                    "Estude o mecanismo de duplo pendulo servo-controlado em acelerômetros quartz (ex: Honeywell QA-2000).",
                                    "Analise faixa dinâmica típica (até 50g), baixo ruído (10-100 µg/√Hz) e alta estabilidade (scale factor <10 ppm).",
                                    "Examine calibração e compensação de bias para ambientes espaciais (vibração zero-g).",
                                    "Compare com specs de IMUs como Litton LN-200 para missões espaciais.",
                                    "Simule impacto de ruído em controle de atitude usando equações básicas."
                                  ],
                                  "verification": "Preencha uma tabela com specs numéricas de pelo menos 2 modelos quartz usados em espaço.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Datasheets de Honeywell/Safran (QA-series)",
                                    "Software MATLAB/Simulink para simulações simples",
                                    "Vídeos tutoriais sobre servo-pendulos"
                                  ],
                                  "tips": [
                                    "Priorize métricas Allan variance para ruído e estabilidade.",
                                    "Busque papers do AIAA sobre performance em orbit."
                                  ],
                                  "learningObjective": "Dominar specs e vantagens dos acelerômetros quartz em IMUs de alta precisão.",
                                  "commonMistakes": [
                                    "Superestimar faixa dinâmica sem considerar saturação em manobras.",
                                    "Não diferenciar bias repeatability de estabilidade de longo prazo."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Características de Acelerômetros MEMS e Outros Tipos",
                                  "subSteps": [
                                    "Descreva estrutura MEMS (ex: ADI ADXL series ou KVH): massas proof com detecção capacitiva.",
                                    "Avalie faixa dinâmica ampla (até 100g+), ruído maior (100-1000 µg/√Hz) e estabilidade moderada (50-200 ppm).",
                                    "Discuta outros tipos: piezelétricos para alta frequência, ópticos (laser interferométricos) para ultra-baixo ruído.",
                                    "Analise trade-offs em IMUs espaciais como CubeSats (ex: VectorNav VN-100).",
                                    "Colete dados de performance em testes de vácuo/temperatura."
                                  ],
                                  "verification": "Crie gráfico comparativo de ruído vs. custo para MEMS vs. Quartz.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Datasheets Analog Devices/EMCORE",
                                    "Relatórios CubeSat da NASA",
                                    "Ferramentas de plotagem (Excel/Python)"
                                  ],
                                  "tips": [
                                    "Considere miniaturização e custo para aplicações low-cost espaciais.",
                                    "Use logs Allan para quantificar ruído angular equivalente."
                                  ],
                                  "learningObjective": "Comparar limitações e usos de MEMS/outros em cenários espaciais.",
                                  "commonMistakes": [
                                    "Subestimar drift térmico em MEMS.",
                                    "Confundir resolução com precisão."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparação e Aplicações em Controle de Atitude",
                                  "subSteps": [
                                    "Compile tabela comparativa: faixa dinâmica, ruído, estabilidade, custo, tamanho para Quartz vs. MEMS vs. outros.",
                                    "Avalie seleção para IMUs espaciais: Quartz para alta precisão (ex: telescópios), MEMS para agilidade (ex: drones espaciais).",
                                    "Simule erro de atitude propagado por ruído de acelerômetro em filtro Kalman.",
                                    "Discuta mitigações: fusão com star trackers, calibração in-flight.",
                                    "Crie matriz de decisão para missões específicas."
                                  ],
                                  "verification": "Justifique escolha de tipo para 2 cenários espaciais hipotéticos com base em specs.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Ferramenta de simulação (MATLAB Toolbox Inercial)",
                                    "Papers IEEE sobre IMU fusion",
                                    "Planilhas comparativas"
                                  ],
                                  "tips": [
                                    "Foquem em métricas normalizadas para comparação justa.",
                                    "Inclua exemplos reais como James Webb IMU."
                                  ],
                                  "learningObjective": "Aplicar comparações para otimizar seleção em sistemas de atitude.",
                                  "commonMistakes": [
                                    "Ignorar acoplamento giro-aceleração.",
                                    "Não considerar vida útil em radiação espacial."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o IMU do satélite CubeSat Cal Poly (usando MEMS) vs. o do Hubble (Quartz-like): compare ruído em dados de telemetria pública, simule propagação de erro em controle de atitude e recomende upgrades para missões de pointing preciso.",
                              "finalVerifications": [
                                "Liste e explique 3 tipos principais com suas bases físicas.",
                                "Compare numericamente faixa dinâmica, ruído e estabilidade para 2 exemplos de cada.",
                                "Justifique seleção para controle de atitude em satélite geoestacionário.",
                                "Crie tabela de trade-offs com pelo menos 5 parâmetros.",
                                "Descreva impacto de ruído em precisão de atitude (<0.1°).",
                                "Identifique mitigações comuns em IMUs espaciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção das specs técnicas (80%+ acurácia numérica).",
                                "Profundidade da comparação quantitativa (gráficos/tabelas claras).",
                                "Relevância para aplicações espaciais (contexto de IMUs).",
                                "Clareza na justificativa de trade-offs.",
                                "Uso de evidências de fontes reais (datasheets/papers).",
                                "Capacidade de simular/aplicar em cenários práticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica newtoniana e dinâmica de vibrações.",
                                "Engenharia Elétrica: Sensores capacitivos e eletrônica analógica.",
                                "Matemática: Análise estatística (Allan variance) e filtros (Kalman).",
                                "Ciência de Materiais: Propriedades do quartzo e micromachinagem Si.",
                                "Ciência da Computação: Processamento de sinais em tempo real."
                              ],
                              "realWorldApplication": "Seleção de acelerômetros em IMUs para satélites como Starlink (MEMS para custo/volume) ou sondas interplanetárias como Perseverance (Quartz para estabilidade em manobras precisas de controle de atitude)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Uso de Acelerômetros na Determinação de Atitude",
                            "description": "Explicar como duplas integrações das acelerações fornecem posição e velocidade relativas, e como projeções vetoriais auxiliam na estimação de atitude quando combinadas com giroscópios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos de Acelerômetros Inerciais",
                                  "subSteps": [
                                    "Estude o princípio de funcionamento de um acelerômetro: medição de aceleração específica em 3 eixos (x, y, z).",
                                    "Diferencie aceleração gravitacional de aceleração dinâmica, usando vetores de gravidade como referência.",
                                    "Revise coordenadas do corpo (body frame) versus coordenadas inerciais (inertial frame).",
                                    "Analise equações básicas: a = dv/dt e v = dx/dt.",
                                    "Explore limitações: sensibilidade a vibrações e deriva por bias."
                                  ],
                                  "verification": "Desenhe um diagrama vetorial mostrando aceleração medida em body frame e sua decomposição.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de dinâmica de voo (ex: Etkin)",
                                    "Vídeos tutoriais sobre IMU (Inertial Measurement Unit)",
                                    "Software MATLAB ou Python com NumPy"
                                  ],
                                  "tips": "Use animações 3D para visualizar frames de referência rotativos.",
                                  "learningObjective": "Compreender como acelerômetros medem acelerações e suas referências de frame.",
                                  "commonMistakes": [
                                    "Confundir aceleração específica com aceleração absoluta",
                                    "Ignorar rotação do body frame"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dupla Integração de Acelerações para Posição e Velocidade",
                                  "subSteps": [
                                    "Subtraia o vetor gravidade da aceleração medida para obter aceleração tangencial.",
                                    "Integre uma vez a aceleração tangencial para obter velocidade relativa: v(t) = ∫ a(t) dt.",
                                    "Integre novamente para posição relativa: x(t) = ∫ v(t) dt.",
                                    "Implemente filtros (ex: low-pass) para mitigar ruído e deriva numérica.",
                                    "Simule numericamente em software, comparando com trajetórias conhecidas."
                                  ],
                                  "verification": "Gere gráficos de posição/velocidade a partir de dados de acelerômetro simulados e valide contra solução analítica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com SciPy para integração numérica",
                                    "Dados de acelerômetro de voo real (ex: dataset público de foguetes)",
                                    "Planilha Excel para protótipo simples"
                                  ],
                                  "tips": "Use método de Trapezoidal Rule para integração discreta em dados amostrados.",
                                  "learningObjective": "Dominar dupla integração para derivar posição e velocidade de medidas de acelerômetro.",
                                  "commonMistakes": [
                                    "Não compensar gravidade",
                                    "Acumular deriva sem inicialização de velocidade/posição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projeções Vetoriais para Estimação de Atitude",
                                  "subSteps": [
                                    "Defina matriz de direção de rotação (DCM) entre body e inertial frames.",
                                    "Projete vetor gravidade medido no body frame no inertial frame: g_body = DCM * g_inertial.",
                                    "Use produto escalar e norma para estimar ângulos de roll e pitch: θ = asin(g_body_y / |g|).",
                                    "Estenda para yaw usando campo magnético se disponível, ou combine com outros sensores.",
                                    "Calcule Jacobiano para análise de erros em estimação."
                                  ],
                                  "verification": "Compute atitude estimada de um conjunto de dados estáticos e compare com ângulos conhecidos (erro < 2°).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB Aerospace Toolbox ou Python com sympy para vetores",
                                    "Documentação de AHRS (Attitude Heading Reference System)"
                                  ],
                                  "tips": "Visualize com plot3D para ver alinhamento de vetores gravidade.",
                                  "learningObjective": "Aplicar projeções vetoriais de gravidade para estimar roll e pitch.",
                                  "commonMistakes": [
                                    "Normalizar incorretamente vetores",
                                    "Confundir seno com arco-cosseno para ângulos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinação com Giroscópios para Estimação Robusta de Atitude",
                                  "subSteps": [
                                    "Integre taxas angulares de giroscópio: ω para obter ângulos Euler: φ = ∫ ω dt.",
                                    "Fundamente filtro complementar: attitude = α * (gyro_integration) + (1-α) * (accel_projection).",
                                    "Implemente Kalman Filter básico para fusão de dados (acel + gyro).",
                                    "Teste em simulação dinâmica, avaliando deriva e precisão.",
                                    "Analise trade-offs: precisão de curto prazo (gyro) vs correção de longo prazo (accel)."
                                  ],
                                  "verification": "Simule manobras e verifique erro de atitude RMS < 1° após 60s.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código open-source de IMU fusion (ex: Madgwick filter em GitHub)",
                                    "Simulador de voo como JSBSim"
                                  ],
                                  "tips": "Comece com α=0.98 para priorizar gyro em dinâmicas rápidas.",
                                  "learningObjective": "Integrar acelerômetros e giroscópios para estimação de atitude precisa.",
                                  "commonMistakes": [
                                    "Deriva não corrigida do gyro",
                                    "Ganho α mal tunado levando a oscilações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um drone quadrotor, use acelerômetros para estimar pitch/roll projetando gravidade durante hover, integrando duplamente para rastrear posição relativa em GPS-denied environments, e fusione com gyros para manobras ágeis, simulando em Gazebo com dados reais de PX4 autopilot.",
                              "finalVerifications": [
                                "Explicar verbalmente dupla integração e suas limitações em 2 minutos.",
                                "Implementar código Python que processa dados IMU reais e plota atitude/posição.",
                                "Identificar e corrigir deriva em uma simulação de 5 minutos.",
                                "Comparar resultados com referências (magnetômetro ou GPS) com erro <5%.",
                                "Desenhar fluxograma completo de pipeline de processamento.",
                                "Discutir cenários onde acelerômetros falham (ex: aceleração centrífuga alta)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre frames e integrações (90%+).",
                                "Implementação prática: Código funcional sem erros numéricos graves.",
                                "Análise de erros: Identificação de pelo menos 3 fontes de erro e mitigações.",
                                "Criatividade: Extensão para cenários reais como reentrada atmosférica.",
                                "Clareza: Gráficos e explicações legíveis e concisas.",
                                "Eficiência: Tempo de processamento <1s para 10s de dados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral, álgebra linear (matrizes de rotação).",
                                "Física: Cinemática newtoniana, vetores inerciais.",
                                "Programação: Processamento de sinais (filtros), simulação numérica.",
                                "Engenharia de Controle: Fusão sensorial, filtros Kalman.",
                                "Ciência de Dados: Tratamento de ruído em séries temporais."
                              ],
                              "realWorldApplication": "Sistemas de navegação inercial em satélites (ex: GPS backup no SpaceX Starship), drones militares em jamming de GPS, aviões comerciais durante falhas de instrumentos, e missões espaciais como Mars rovers para determinação de atitude autônoma."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Unidade de Medição Inercial (IMU)",
                        "description": "Sistema integrado de giroscópios e acelerômetros para fornecer medições combinadas de taxa angular e aceleração, essencial para o rastreamento contínuo de orientação relativa em veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Arquitetura e Calibração de IMUs",
                            "description": "Descrever a configuração típica de uma IMU strapdown, processos de calibração em solo e compensação de erros como misalignments e scale factors.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Arquitetura Típica de uma IMU Strapdown",
                                  "subSteps": [
                                    "Estude os componentes principais: acelerômetros (3 eixos), giroscópios (3 eixos) e processadores embarcados.",
                                    "Analise a configuração strapdown: sensores fixos na estrutura do veículo sem plataformas estabilizadas.",
                                    "Desenhe um diagrama esquemático mostrando alinhamento com o sistema de referência do corpo (body frame).",
                                    "Revise princípios de funcionamento: medição de acelerações específicas e taxas angulares.",
                                    "Compare com IMUs gimbaled para destacar vantagens da strapdown (menor tamanho, custo e peso)."
                                  ],
                                  "verification": "Crie e explique um diagrama completo da arquitetura, identificando todos os componentes e fluxos de dados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Inertial Navigation Systems Analysis' de Britting",
                                    "Datasheets de IMUs como ADIS16488",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Use analogias com um 'gimbal humano' para visualizar strapdown vs. gimbaled.",
                                  "learningObjective": "Descrever e diagramar a configuração física e funcional de uma IMU strapdown.",
                                  "commonMistakes": [
                                    "Confundir body frame com navigation frame",
                                    "Ignorar o papel do processador de sinal digital (DSP)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Fontes de Erros em IMUs",
                                  "subSteps": [
                                    "Liste erros determinísticos: bias, scale factor, misalignments e não-linearidades.",
                                    "Discuta erros estocásticos: ruído aleatório, drift de bias e vibrações.",
                                    "Estude impactos: como misalignments causam crosstalk entre eixos.",
                                    "Realize uma análise qualitativa de erros em aceleração e rotação.",
                                    "Compile uma tabela de erros típicos com valores de magnitude (ex: bias 0.01°/s)."
                                  ],
                                  "verification": "Produza uma tabela de erros com exemplos numéricos e explique impactos em uma trajetória simulada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo 'Error Sources in IMU' do IEEE",
                                    "Planilhas Excel para tabelas",
                                    "Vídeos tutoriais no YouTube sobre IMU errors"
                                  ],
                                  "tips": "Priorize erros por magnitude: scale factor > misalignment > bias.",
                                  "learningObjective": "Classificar e quantificar fontes principais de erro em IMUs strapdown.",
                                  "commonMistakes": [
                                    "Subestimar erros ambientais como temperatura",
                                    "Confundir bias com scale factor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Processos de Calibração em Solo",
                                  "subSteps": [
                                    "Aprenda calibração estática: nivelamento para bias de acelerômetros usando gravidade.",
                                    "Realize calibração dinâmica: rotações conhecidas para scale factor e bias de giroscópios.",
                                    "Implemente método de multi-position: 6-12 posições para estimar misalignments.",
                                    "Colete dados com IMU real ou simulada e aplique least-squares para parâmetros.",
                                    "Valide calibração comparando leituras pré e pós-calibração em condições conhecidas."
                                  ],
                                  "verification": "Simule ou execute uma calibração multi-position e reduza erros em >50%.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "IMU acessível como MPU-6050",
                                    "MATLAB/Simulink toolbox para IMU",
                                    "Arduino para aquisição de dados"
                                  ],
                                  "tips": "Mantenha temperatura constante durante testes para isolar erros térmicos.",
                                  "learningObjective": "Aplicar procedimentos padrão de calibração em solo para IMUs.",
                                  "commonMistakes": [
                                    "Movimentos durante calibração estática",
                                    "Poucas posições levando a singularidades na matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Compensação de Erros como Misalignments e Scale Factors",
                                  "subSteps": [
                                    "Desenvolva modelo matemático: vetor medido = A * (S * vetor verdadeiro + bias), onde A é misalignment, S scale.",
                                    "Estime matrizes A e S usando dados calibrados via otimização.",
                                    "Codifique compensação em software: função que corrige raw data.",
                                    "Teste em simulação: injete erros conhecidos e verifique correção.",
                                    "Integre com filtro Kalman para compensação online em operação."
                                  ],
                                  "verification": "Implemente código que compense erros artificiais com precisão <1% em testes.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB Inertial Navigation Toolbox",
                                    "Código exemplo de GitHub para IMU compensation"
                                  ],
                                  "tips": "Use decomposição SVD para estimar matrizes de misalignment.",
                                  "learningObjective": "Modelar e compensar erros sistemáticos em dados de IMU.",
                                  "commonMistakes": [
                                    "Inverter ordem de scale e misalignment na equação",
                                    "Ignorar correlações entre parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Validar Arquitetura e Calibração Completa",
                                  "subSteps": [
                                    "Monte um sistema simulado: IMU + compensação + navegação inercial básica.",
                                    "Execute testes end-to-end: compare atitude estimada com verdade-terra.",
                                    "Analise métricas: RMSE de ângulos, drift acumulado.",
                                    "Documente procedimento completo em relatório.",
                                    "Discuta limitações e melhorias (ex: calibração in-flight)."
                                  ],
                                  "verification": "Gere relatório com gráficos mostrando redução de erros pós-compensação.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Simulador X-Plane ou custom Python sim",
                                    "Ferramentas de plotagem: Matplotlib"
                                  ],
                                  "tips": "Use dados reais de voo open-source para validação realista.",
                                  "learningObjective": "Validar uma IMU calibrada em contexto de navegação integrada.",
                                  "commonMistakes": [
                                    "Falta de baseline sem calibração",
                                    "Sobreajuste de parâmetros"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat, configure uma IMU strapdown (ex: Bosch BMI088), calibre em bancada com multi-position para misalignments <0.1°, compense scale factors via software embarcado em microcontrolador, reduzindo erro de atitude de 2° para 0.2° em órbita simulada.",
                              "finalVerifications": [
                                "Diagramar corretamente arquitetura IMU strapdown com componentes chave.",
                                "Listar e explicar 5+ fontes de erro com magnitudes típicas.",
                                "Executar calibração multi-position reduzindo bias em >70%.",
                                "Implementar código de compensação validado em simulação.",
                                "Analisar impactos de erros não compensados em trajetória inercial.",
                                "Relatar limitações de calibração em solo vs. in-flight."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 90%+ acerto em quiz sobre arquitetura e erros.",
                                "Profundidade prática: Código funcional com testes <5% erro residual.",
                                "Análise quantitativa: Uso correto de métricas como RMSE e Allan variance.",
                                "Documentação: Relatório claro com diagramas e resultados.",
                                "Criatividade: Sugestões de melhorias interdisciplinares.",
                                "Tempo gestão: Conclusão dentro de 13 horas totais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para matrizes de misalignment e otimização least-squares.",
                                "Programação: Implementação em Python/MATLAB para processamento de sensores.",
                                "Física: Dinâmica newtoniana e cinemática para modelagem de erros.",
                                "Engenharia de Controle: Integração com filtros Kalman para navegação.",
                                "Estatística: Análise de variância Allan para caracterização de ruído."
                              ],
                              "realWorldApplication": "Em missões espaciais como o James Webb Space Telescope ou foguetes Falcon 9, IMUs calibradas strapdown fornecem atitude precisa para controle de atitude e rendezvous orbital, compensando misalignments para evitar deriva >0.01°/h."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.2",
                              "10.1.1.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Propagação de Erros em Sistemas Inerciais",
                            "description": "Analisar modelos de erro (random walk, bias instability) e técnicas de modelagem como filtros Kalman para mitigar deriva na determinação de atitude relativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Erros em Sensores Inerciais",
                                  "subSteps": [
                                    "Estudar os principais fontes de erro em IMUs: ruído, bias e deriva.",
                                    "Diferenciar erros determinísticos (bias) de estocásticos (random walk).",
                                    "Analisar especificações típicas de IMUs comerciais (ex: gyros com bias instability).",
                                    "Visualizar graficamente a evolução temporal de erros em sensores.",
                                    "Resolver exercícios simples de identificação de erros em dados de sensores."
                                  ],
                                  "verification": "Criar um diagrama classificando 5 tipos de erros comuns em IMUs e justificá-los com referências.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Datasheet de IMU (ex: ADIS16488)",
                                    "Vídeos tutoriais sobre erros inerciais (YouTube/Khan Academy)",
                                    "Planilha Excel para plotar dados"
                                  ],
                                  "tips": "Comece com exemplos reais de datasheets para contextualizar os erros.",
                                  "learningObjective": "Identificar e classificar fontes de erro em sistemas inerciais.",
                                  "commonMistakes": [
                                    "Confundir bias com ruído branco",
                                    "Ignorar a dependência temporal nos erros de baixa frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Erros Específicos: Random Walk e Bias Instability",
                                  "subSteps": [
                                    "Derivar a equação matemática do modelo random walk para ângulo (integrador de ruído branco).",
                                    "Modelar bias instability como um processo de 1/f noise ou modelo AR(1).",
                                    "Calcular covariâncias e variâncias para propagação temporal desses erros.",
                                    "Implementar simulação numérica simples em Python/MATLAB para gerar trajetórias de erro.",
                                    "Comparar simulações com Allan Variance plots de sensores reais."
                                  ],
                                  "verification": "Gerar plot de variância Allan para um modelo random walk e validar contra fórmula teórica.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Artigo 'Allan Variance Tutorial' de IEEE",
                                    "Notebook Jupyter pronto para simulação"
                                  ],
                                  "tips": "Use dt pequeno (0.01s) nas simulações para precisão numérica.",
                                  "learningObjective": "Derivar e simular modelos matemáticos de random walk e bias instability.",
                                  "commonMistakes": [
                                    "Usar variância em vez de covariância na propagação",
                                    "Esquecer de normalizar pelo tempo no Allan plot"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Propagação de Erros na Determinação de Atitude Relativa",
                                  "subSteps": [
                                    "Revisar cinemática de atitude (quaternions ou ângulos de Euler).",
                                    "Derivar equações de propagação de erro giroscópico para matriz de covariância de atitude.",
                                    "Analisar deriva cumulativa em missões longas sem correção.",
                                    "Estudar impacto relativo em roll, pitch e yaw devido a acoplamentos.",
                                    "Realizar análise de sensibilidade variando taxas de random walk."
                                  ],
                                  "verification": "Calcular erro RMS de atitude após 1 hora para um gyro típico e plotar.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Livro 'Strapdown Inertial Navigation' de Titterton",
                                    "Software de simulação como JSBSim",
                                    "Equações de propagação em PDF"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades em simulações.",
                                  "learningObjective": "Quantificar propagação de erros inerciais na estimativa de atitude.",
                                  "commonMistakes": [
                                    "Negligenciar correlação entre eixos",
                                    "Confundir velocidade angular com aceleração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Filtros Kalman para Mitigar Deriva de Erros",
                                  "subSteps": [
                                    "Estudar o modelo state-space para IMU: estado inclui atitude, bias e velocidades angulares.",
                                    "Implementar Extended Kalman Filter (EKF) discreto para fusão de dados inerciais.",
                                    "Configurar matrizes Q (processo) e R (medida) baseadas em modelos de erro.",
                                    "Simular filtro em loop fechado e comparar com propagação livre.",
                                    "Otimizar tuning do filtro via simulações Monte Carlo."
                                  ],
                                  "verification": "Demonstrar redução de erro de atitude >80% após 10 minutos em simulação.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com filterpy ou MATLAB Aerospace Toolbox",
                                    "Tutorial EKF para INS",
                                    "Dados reais de IMU de dataset público (ex: EuRoC MAV)"
                                  ],
                                  "tips": "Inicialize covariâncias com valores conservadores para convergência rápida.",
                                  "learningObjective": "Implementar e validar filtro Kalman para correção de deriva inercial.",
                                  "commonMistakes": [
                                    "Subestimar Q para random walk",
                                    "Linearizar incorretamente no EKF para grandes ângulos"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma missão de satélite em órbita baixa usando Python: integre dados de giroscópios com random walk (σ=0.01°/√h) por 30 minutos sem filtro (deriva >5°), aplique EKF com magnetômetro auxiliar e reduza erro para <0.5°. Plote trajetórias de atitude e covariâncias.",
                              "finalVerifications": [
                                "Derivar corretamente a covariância de random walk: σ²(t) = σ² * t.",
                                "Gerar Allan Variance plot identificando bias instability.",
                                "Implementar EKF que converge em <1 minuto.",
                                "Analisar impacto de tuning Q/R em RMS de erro.",
                                "Explicar deriva em atitude relativa sem estrelas/magnetômetros.",
                                "Simular 3 cenários reais e reportar métricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações derivadas (100% correção matemática).",
                                "Qualidade das simulações (plots legíveis, <5% erro numérico).",
                                "Redução efetiva de erro com Kalman (>70%).",
                                "Análise de sensibilidade completa (variação de parâmetros).",
                                "Relatório claro com conclusões acionáveis.",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Processos estocásticos e equações diferenciais estocásticas.",
                                "Programação: Simulações numéricas e filtros recursivos.",
                                "Física: Mecânica orbital e cinemática de corpos rígidos.",
                                "Estatística: Análise de variância e estimação bayesiana.",
                                "Engenharia de Controle: Observadores e fusão de sensores."
                              ],
                              "realWorldApplication": "Em veículos espaciais como o CubeSat da USP (Tancredo-1), filtros Kalman mitigam deriva de IMUs para manter precisão de apontamento de câmeras em <0.1°, essencial para imagens terrestres e comunicações."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.3",
                              "10.1.1.4.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Dinâmica de Atitude",
                "description": "Análise da dinâmica associada à atitude dos veículos espaciais.",
                "totalSkills": 45,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Determinação de Atitude com Sensores Terrestres Infravermelho e Solares",
                    "description": "Utilização de sensores terrestres infravermelho e sensores solares para medir a atitude dos veículos espaciais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Sensores Terrestres Infravermelho",
                        "description": "Sensores que utilizam a radiação infravermelha emitida pela Terra para detectar o horizonte e determinar os ângulos de atitude roll e pitch em veículos espaciais em órbita baixa.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Princípio de Funcionamento dos Sensores Infravermelho",
                            "description": "Explicar o princípio físico baseado na detecção da borda do horizonte terrestre através da transição de radiação infravermelha do espaço frio para a atmosfera quente da Terra, incluindo o papel de filtros ópticos e detectores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos da Radiação Infravermelha e Contraste Térmico",
                                  "subSteps": [
                                    "Estude a lei de Planck e a emissão de radiação térmica por corpos negros.",
                                    "Compare as temperaturas: espaço profundo (~3K, frio) vs. atmosfera terrestre (~250-300K, quente).",
                                    "Analise o espectro IR (8-12 μm) onde o contraste é máximo.",
                                    "Visualize gráficos de intensidade de radiação vs. comprimento de onda.",
                                    "Discuta por que o IR é preferível ao visível para detecção de horizonte."
                                  ],
                                  "verification": "Desenhe um gráfico comparando espectros de emissão do espaço e Terra, identificando o pico IR.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos de lei de Planck",
                                    "Vídeo sobre radiação térmica",
                                    "Calculadora ou software como Python/Matplotlib"
                                  ],
                                  "tips": "Use simulações online de corpos negros para visualizar curvas em tempo real.",
                                  "learningObjective": "Compreender o contraste térmico fundamental que permite a detecção do horizonte.",
                                  "commonMistakes": [
                                    "Confundir IR com luz visível",
                                    "Ignorar a dependência da temperatura na lei de Planck",
                                    "Subestimar o papel da atmosfera na emissão IR"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Princípio de Detecção da Borda do Horizonte",
                                  "subSteps": [
                                    "Explique como o sensor varre o horizonte ao girar com o spacecraft.",
                                    "Descreva a transição abrupta no sinal: de baixo (espaço) para alto (Terra).",
                                    "Identifique a borda como o ponto de 50% de transição no sinal.",
                                    "Calcule o ângulo de atitude baseado na posição da borda no campo de visão.",
                                    "Simule numericamente a varredura com uma função degrau."
                                  ],
                                  "verification": "Crie um gráfico simples de sinal IR vs. ângulo, marcando a borda do horizonte.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Diagrama de varredura de sensor IR",
                                    "Software de plotagem (Excel ou Python)",
                                    "Vídeo de animação de sensor horizon"
                                  ],
                                  "tips": "Pense no sensor como um 'termômetro angular' que detecta mudanças de temperatura.",
                                  "learningObjective": "Dominar como a transição de sinal define a borda do horizonte e relaciona à atitude.",
                                  "commonMistakes": [
                                    "Confundir varredura com imagem fixa",
                                    "Não considerar rotação do spacecraft",
                                    "Ignorar ruído na transição real"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Componentes Ópticos: Filtros e Lentes",
                                  "subSteps": [
                                    "Descreva o papel das lentes para focar radiação IR no detector.",
                                    "Explique filtros de banda estreita (8-12 μm) para rejeitar radiação solar ou outras.",
                                    "Analise o campo de visão típico (tipicamente 90-120 graus).",
                                    "Discuta materiais ópticos como germânio ou silício para IR.",
                                    "Calcule basicamente a resolução angular baseada no tamanho do detector."
                                  ],
                                  "verification": "Liste componentes ópticos e desenhe um raio óptico simples do sensor.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Diagramas ópticos de sensores IR",
                                    "Tabela de materiais IR",
                                    "Simulador óptico online"
                                  ],
                                  "tips": "Filtros são cruciais para evitar falsos positivos de nuvens ou Sol.",
                                  "learningObjective": "Entender como a óptica otimiza a detecção seletiva de IR terrestre.",
                                  "commonMistakes": [
                                    "Esquecer filtros anti-solar",
                                    "Confundir resolução com campo de visão",
                                    "Ignorar absorção atmosférica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectores, Processamento de Sinal e Integração",
                                  "subSteps": [
                                    "Estude detectores como fotodiodos HgCdTe ou bolômetros sensíveis a IR.",
                                    "Descreva amplificação, filtragem e limiar para extrair a borda.",
                                    "Explique algoritmos para estimar ângulo de roll/pitch a partir de múltiplos sensores.",
                                    "Discuta calibração e compensação de offsets.",
                                    "Integre com outros sensores (estrelas, Sol) para atitude completa."
                                  ],
                                  "verification": "Descreva o fluxo de sinal do fóton IR ao vetor de atitude.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Esquemático de detector IR",
                                    "Código exemplo de processamento em Python",
                                    "Documentação de sensores reais como STR-100"
                                  ],
                                  "tips": "Processamento digital reduz ruído; pratique com dados simulados.",
                                  "learningObjective": "Compreender a conversão de sinal óptico em dados de atitude utilizáveis.",
                                  "commonMistakes": [
                                    "Subestimar ruído térmico",
                                    "Ignorar necessidade de múltiplos canais",
                                    "Confundir detecção com rastreamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python e Matplotlib, simule um sensor IR varrendo o horizonte: gere um sinal degrau de 0 (espaço frio) para 1 (Terra quente), adicione ruído gaussiano, aplique filtro passa-baixa e detecte a borda em 50% de amplitude para calcular o ângulo de atitude. Compare com dados reais de satélites GOES.",
                              "finalVerifications": [
                                "Explicar verbalmente o contraste IR Terra-espaço com números de temperatura.",
                                "Desenhar diagrama completo do sensor com óptica, detector e sinal.",
                                "Simular e plotar detecção de borda com variação de ângulo.",
                                "Identificar 3 fontes de erro comuns e mitigações.",
                                "Calcular erro angular para ruído dado.",
                                "Comparar com sensores solares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do contraste térmico e espectro IR (30%)",
                                "Clareza no diagrama da detecção de borda e óptica (25%)",
                                "Correção na simulação de sinal e processamento (20%)",
                                "Identificação de erros e aplicações reais (15%)",
                                "Integração com sistemas de atitude (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Termodinâmica e radiação de corpo negro",
                                "Matemática: Processamento de sinal e detecção de bordas (funções degrau, filtros)",
                                "Engenharia: Design óptico e eletrônica de sensores",
                                "Computação: Simulações numéricas e algoritmos de Kalman para fusão",
                                "Ciência da Terra: Perfis térmicos atmosféricos"
                              ],
                              "realWorldApplication": "Sensores IR horizon como o ITHIR em satélites GOES ou o RSS21 em CubeSats determinam atitude autônoma, essencial para apontamento de antenas, imagens e manobras orbitais, reduzindo dependência de GPS em órbita baixa."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Processamento de Sinais dos Sensores",
                            "description": "Descrever o processamento de sinais analógicos e digitais para identificar o horizonte, incluindo algoritmos de limiarização, filtragem de ruído e triangulação de múltiplos sensores para precisão angular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Aquisição e Compreensão de Sinais Analógicos e Digitais de Sensores IR",
                                  "subSteps": [
                                    "Explicar a diferença entre sinais analógicos contínuos e digitais discretos de sensores infravermelhos terrestres.",
                                    "Simular a captura de sinais de sensores IR detectando o horizonte terrestre (transição quente-frio).",
                                    "Converter sinais analógicos para digitais usando amostragem ADC (Analog-to-Digital Converter).",
                                    "Visualizar sinais usando ferramentas como MATLAB ou Python (Matplotlib).",
                                    "Identificar componentes do sinal: sinal útil (horizonte) vs. ruído ambiente."
                                  ],
                                  "verification": "Gráfico de sinal cru exibido corretamente com picos identificando o horizonte.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software Python/MATLAB",
                                    "Dados simulados de sensores IR (ex: datasets públicos de satélites)"
                                  ],
                                  "tips": "Use frequências de amostragem acima de 100 Hz para capturar transições rápidas do horizonte.",
                                  "learningObjective": "Compreender e simular a aquisição inicial de sinais de sensores IR para detecção de horizonte.",
                                  "commonMistakes": [
                                    "Amostragem insuficiente levando a aliasing",
                                    "Ignorar offset DC nos sinais analógicos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementação de Algoritmos de Limiarização para Detecção de Horizonte",
                                  "subSteps": [
                                    "Definir limiares fixos e adaptativos baseados em histograma do sinal.",
                                    "Aplicar limiarização simples: binarizar sinal acima/abaixo do threshold.",
                                    "Implementar limiarização dinâmica (ex: Otsu ou média móvel) para variações ambientais.",
                                    "Detectar borda do horizonte como ponto de transição no sinal binarizado.",
                                    "Testar com dados ruidosos para ajustar sensibilidade."
                                  ],
                                  "verification": "Algoritmo identifica corretamente a posição do horizonte em pelo menos 90% dos testes simulados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Bibliotecas Python: NumPy, SciPy",
                                    "Código-fonte de exemplos de thresholding"
                                  ],
                                  "tips": "Comece com limiar fixo e evolua para adaptativo para lidar com nuvens ou auroras.",
                                  "learningObjective": "Dominar limiarização para isolar o sinal de horizonte de fundos variáveis.",
                                  "commonMistakes": [
                                    "Threshold muito baixo causando falsos positivos",
                                    "Não normalizar sinal antes da limiarização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Filtragem de Ruído nos Sinais Processados",
                                  "subSteps": [
                                    "Aplicar filtros passa-baixa (média móvel) para remover ruído de alta frequência.",
                                    "Implementar filtro mediana para ruído impulsivo (ex: flares solares).",
                                    "Usar filtro Kalman simples para estimar sinal limpo considerando dinâmica do veículo.",
                                    "Comparar sinais filtrados vs. originais via métricas como SNR (Signal-to-Noise Ratio).",
                                    "Otimizar parâmetros do filtro com dados de teste variados."
                                  ],
                                  "verification": "SNR melhora em pelo menos 10 dB após filtragem em testes controlados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "SciPy.signal para filtros",
                                    "Gerador de ruído sintético em Python"
                                  ],
                                  "tips": "Escolha tamanho da janela do filtro baseado na taxa de rotação esperada do spacecraft.",
                                  "learningObjective": "Aplicar técnicas de filtragem para melhorar a qualidade do sinal de horizonte.",
                                  "commonMistakes": [
                                    "Filtro muito agressivo suavizando a transição real do horizonte",
                                    "Ignorar fase do filtro em sinais dinâmicos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Triangulação de Múltiplos Sensores para Precisão Angular",
                                  "subSteps": [
                                    "Coletar dados sincronizados de 2-4 sensores IR em posições conhecidas no veículo.",
                                    "Calcular ângulos relativos de detecção de horizonte por sensor.",
                                    "Implementar triangulação geométrica: interseção de planos de visão para vetor nadir.",
                                    "Fundir resultados via média ponderada ou filtro estendido Kalman.",
                                    "Validar precisão angular contra ângulos verdadeiros simulados."
                                  ],
                                  "verification": "Erro angular médio < 0.5 graus em simulações com ruído.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Bibliotecas: NumPy para vetores, SymPy para geometria",
                                    "Simulador de atitude (ex: Orekit ou custom)"
                                  ],
                                  "tips": "Assuma geometria conhecida dos sensores; calibre offsets em solo.",
                                  "learningObjective": "Integrar dados de múltiplos sensores para estimativa precisa de atitude.",
                                  "commonMistakes": [
                                    "Desalinhamento temporal entre sensores",
                                    "Erro em transformação de coordenadas do body para inertial"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integração, Testes e Validação Final do Pipeline Completo",
                                  "subSteps": [
                                    "Construir pipeline end-to-end: aquisição → limiar → filtro → triangulação.",
                                    "Testar em cenários reais simulados (ex: rotação, obstruções parciais).",
                                    "Medir latência total e requisitos computacionais.",
                                    "Implementar logging e visualização para depuração.",
                                    "Documentar pipeline com diagrama de fluxo."
                                  ],
                                  "verification": "Pipeline processa dados em tempo real com precisão <1 grau em 95% dos casos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ambiente Jupyter Notebook",
                                    "Dados de missão real (ex: CubeSat telemetry)"
                                  ],
                                  "tips": "Use threading para processamento paralelo em hardware embarcado.",
                                  "learningObjective": "Validar e otimizar o sistema completo de processamento de sinais.",
                                  "commonMistakes": [
                                    "Sobrecarga computacional em microcontroladores",
                                    "Falta de tratamento de falhas de sensor"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat simulando órbita LEO, processe dados de 4 sensores IR: aplique limiarização para detectar horizonte em cada, filtre ruído de vibrações, triangule para estimar roll/pitch com erro <0.3°, visualizando o vetor nadir em 3D.",
                              "finalVerifications": [
                                "Pipeline detecta horizonte em dados ruidosos com acurácia >95%.",
                                "Triangulação produz ângulos consistentes entre simulações e referências.",
                                "SNR pós-processamento >20 dB.",
                                "Latência total <100 ms para taxa de 10 Hz.",
                                "Robustez testada contra 20% de sensores falhando.",
                                "Código documentado e reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão angular: erro médio <0.5°.",
                                "Robustez ao ruído: performance estável com SNR inicial 10-30 dB.",
                                "Eficiência computacional: viável em MCU como ARM Cortex-M.",
                                "Modularidade do código: fácil isolamento de steps.",
                                "Qualidade da documentação: inclui testes e edge cases.",
                                "Inovação: adaptações para cenários específicos (ex: eclipse)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para triangulação e vetores.",
                                "Física: Óptica infravermelha e termodinâmica atmosférica.",
                                "Programação: Processamento de sinais em Python/C++ embarcado.",
                                "Engenharia de Controle: Fusão de sensores com Kalman.",
                                "Estatística: Análise de ruído e validação de algoritmos."
                              ],
                              "realWorldApplication": "Em satélites como o CYGNSS da NASA ou CubeSats educacionais, este processamento permite determinação autônoma de atitude sem GPS, essencial para missões em órbitas polares ou durante blackout de comunicações, melhorando estabilidade de imageamento e antenas direcionais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Cálculo de Atitude Roll e Pitch",
                            "description": "Demonstrar os cálculos matemáticos para determinar os ângulos de roll e pitch a partir das posições do horizonte detectadas, considerando modelo geométrico da Terra elipsoidal e equações de transformação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Sensores Infravermelhos e Geometria do Horizonte",
                                  "subSteps": [
                                    "Estudar o princípio de operação de sensores infravermelhos terrestres que detectam o horizonte pela transição térmica.",
                                    "Revisar definições de roll (rotação em torno do eixo longitudinal) e pitch (rotação em torno do eixo lateral).",
                                    "Analisar a geometria básica: vetor de linha de visão do sensor ao horizonte e normal à superfície terrestre.",
                                    "Explorar como múltiplas detecções de horizonte (ex.: 2-4 pontos) definem o plano do horizonte local.",
                                    "Desenhar diagramas 2D/3D ilustrando a relação entre o vetor nadir, horizonte e eixos de atitude."
                                  ],
                                  "verification": "Criar um diagrama anotado mostrando roll e pitch derivados de posições de horizonte detectadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de dinâmica de atitude (ex: Wertz 'Spacecraft Attitude Determination'), software de desenho (ex: GeoGebra), artigos sobre sensores IR"
                                  ],
                                  "tips": "Use visualizações 3D para intuitivamente entender as rotações; comece com modelo esférico simplificado antes do elipsoidal.",
                                  "learningObjective": "Identificar e diagramar os componentes geométricos essenciais para determinação de roll e pitch.",
                                  "commonMistakes": [
                                    "Confundir roll com yaw; ignorar a curvatura terrestre em diagramas iniciais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a Terra como Elipsoide e Calcular Posições do Horizonte",
                                  "subSteps": [
                                    "Implementar o modelo elipsoide WGS84: equações para raio equatorial (a=6378.137 km) e polar (b=6356.752 km).",
                                    "Calcular o vetor posição do satélite em ECEF (Earth-Centered Earth-Fixed) a partir de coordenadas geodéticas.",
                                    "Derivar o plano tangente local no ponto subsatélite usando gradiente do elipsoide.",
                                    "Simular detecções de horizonte: interseção de cones de visão do sensor com a superfície elipsoidal.",
                                    "Computar ângulos azimut/elevação dos pontos de horizonte detectados no frame do sensor."
                                  ],
                                  "verification": "Gerar coordenadas ECEF de 4 pontos de horizonte para uma órbita LEO específica e validar contra software como STK.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Biblioteca NumPy/Python para vetores, modelo WGS84 parâmetros, MATLAB ou Python com SciPy"
                                  ],
                                  "tips": "Use parametrização elipsoidal (u,v) para evitar singularidades; teste com órbitas equatoriais primeiro.",
                                  "learningObjective": "Construir e aplicar modelo geométrico elipsoidal para posições precisas do horizonte.",
                                  "commonMistakes": [
                                    "Usar modelo esférico em vez de elipsoidal, levando a erros de ~0.1°; erros em conversões geodéticas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Implementar Equações de Transformação para Roll e Pitch",
                                  "subSteps": [
                                    "Definir matriz de rotação de atitude: DCM (Direction Cosine Matrix) relacionando frame do corpo ao frame orbital.",
                                    "Estabelecer equações: roll = atan2( (y_h1 - y_h2)/(x_h1 - x_h2) ) para pontos opostos; similar para pitch.",
                                    "Incorporar correções elipsoidais: ajuste no vetor nadir usando achatamento (f=1/298.257).",
                                    "Implementar em código: função que recebe posições de horizonte normalizadas e retorna roll/pitch em graus.",
                                    "Tratar ruído: aplicar filtro médio ou least-squares para múltiplos sensores."
                                  ],
                                  "verification": "Executar código com inputs sintéticos e comparar saídas com valores conhecidos (erro < 0.05°).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib para plotar vetores, referências: 'Analytical Mechanics of Space Systems' Curtis"
                                  ],
                                  "tips": "Normalizar vetores de horizonte para unitários; use quaternion intermediário para evitar gimbal lock.",
                                  "learningObjective": "Derivar e codificar equações matemáticas precisas para roll e pitch considerando elipsoide.",
                                  "commonMistakes": [
                                    "Inverter sinais em atan2; negligenciar projeção ortogonal do horizonte."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Validar Cálculos em Cenários Realistas",
                                  "subSteps": [
                                    "Configurar simulação orbital completa: propagar posição/velocidade com SGP4 e adicionar ruído sensor (σ=0.1°).",
                                    "Comparar roll/pitch calculados com verdade de navegação (ground truth de simulação).",
                                    "Analisar sensibilidade: variar achatamento terrestre e altitude orbital (200-1000 km).",
                                    "Otimizar equações para eficiência computacional em tempo real (ex.: <1 ms por ciclo).",
                                    "Documentar resultados em gráficos: erro vs. latitude, convergência do least-squares."
                                  ],
                                  "verification": "Relatório com simulações mostrando RMSE < 0.2° para 100 órbitas variadas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Orekit ou GMAT para simulação orbital, Jupyter Notebook para análise"
                                  ],
                                  "tips": "Inclua eclipse solar para testar cenários sem horizonte IR; valide contra dados de missão real (ex: GOES).",
                                  "learningObjective": "Validar implementação através de simulações realistas e análise de erros.",
                                  "commonMistakes": [
                                    "Ignorar efeitos dinâmicos como J2 perturbação; overfitting a ruído sem generalização."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar com Outros Sensores e Avaliar Desempenho Global",
                                  "subSteps": [
                                    "Combinar roll/pitch IR com dados solares para yaw completo (triangulação).",
                                    "Implementar fusão Kalman para atitude total, usando roll/pitch como medições.",
                                    "Testar em loop fechado: feedback para controle de atuadores (RWAs).",
                                    "Avaliar métricas: precisão, taxa de amostragem, robustez a falhas de sensor.",
                                    "Preparar relatório final com código fonte e casos de teste."
                                  ],
                                  "verification": "Demonstrar atitude estável (<0.5° erro) em simulação de 1 órbita com falha simulada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Filtro Kalman em Python (filterpy lib), dados de missão pública (ex: NASA CDDIS)"
                                  ],
                                  "tips": "Priorize modularidade no código para fácil integração; use unit tests para funções chave.",
                                  "learningObjective": "Integrar cálculos em sistema de determinação de atitude completo e avaliar holisticamente.",
                                  "commonMistakes": [
                                    "Sobrestimar precisão IR sem modelar emissividade atmosférica; loops instáveis sem ganho tuning."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um satélite em órbita LEO a 500 km sobre o equador (posição ECEF: [4000, 3000, 4000] km), com detecções de horizonte em ângulos sensoriais (az1=45°, el1=0°; az2=225°, el2=0°), calcular roll ≈ 2.3° e pitch ≈ -1.1° usando elipsoide WGS84, validando com plot de vetores e erro <0.05° vs. ground truth.",
                              "finalVerifications": [
                                "Implementar código que calcula roll/pitch com erro médio <0.1° em 50 cenários orbitais variados.",
                                "Explicar derivação das equações considerando achatamento elipsoidal em apresentação oral.",
                                "Gerar gráficos de validação mostrando convergência e sensibilidade a ruído.",
                                "Integrar com sensor solar mockup e demonstrar atitude 3D precisa.",
                                "Documentar limitações (ex.: latitudes altas) e mitigações em relatório.",
                                "Passar testes unitários para funções de modelo elipsoidal e transformação."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: equações corretas com elipsoide (peso 30%).",
                                "Implementação funcional: código executável e eficiente (peso 25%).",
                                "Validação rigorosa: simulações com métricas quantitativas (peso 20%).",
                                "Compreensão conceitual: diagramas e explicações claras (peso 15%).",
                                "Integração e robustez: handling de edge cases (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rotação), geometria diferencial (elipsoides).",
                                "Física: Mecânica orbital, gradientes gravitacionais, termodinâmica IR.",
                                "Programação: NumPy/SciPy para computação científica, simulação numérica.",
                                "Engenharia: Sistemas embarcados, filtros de estimação (Kalman).",
                                "Geodesia: Modelos de referência terrestre (WGS84), coordenadas geodéticas."
                              ],
                              "realWorldApplication": "Em satélites como CubeSats ou missões como GOES/IMERG, esses cálculos habilitam determinação autônoma de atitude sem GPS, essencial para imagens precisas da Terra, controle de painéis solares e manobras seguras em ambientes hostis como LEO com detritos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.4",
                            "name": "Análise de Erros e Limitações",
                            "description": "Analisar fontes de erro como nuvens, auroras, alumbramento lunar e altitude orbital, além de métodos de calibração e compensação para melhorar a precisão da determinação de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Classificar Fontes de Erro Ambientais e Orbitais",
                                  "subSteps": [
                                    "Estude o impacto de nuvens na detecção de horizonte IR, revisando literatura sobre atenuação de sinal.",
                                    "Analise o efeito de auroras boreais/auistrais na medição de temperatura do horizonte IR.",
                                    "Examine o alumbramento lunar como fonte de ruído em sensores IR durante órbitas noturnas.",
                                    "Investigue variações devido à altitude orbital, como diluição angular do horizonte.",
                                    "Compile uma tabela comparativa de magnitudes de erro para cada fonte."
                                  ],
                                  "verification": "Crie um diagrama ou tabela listando fontes de erro com descrições e exemplos quantitativos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Artigos científicos sobre sensores IR espaciais (ex: NASA reports), software de visualização como MATLAB ou Python com bibliotecas astropy.",
                                  "tips": "Use imagens reais de satélites para visualizar efeitos como auroras.",
                                  "learningObjective": "Compreender as principais fontes de erro ambientais e orbitais em sensores IR terrestres.",
                                  "commonMistakes": "Ignorar dependências sazonais ou geográficas nos erros de auroras."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar e Quantificar Erros em Determinação de Atitude",
                                  "subSteps": [
                                    "Desenvolva equações matemáticas para modelar atenuação por nuvens (ex: modelo de Beer-Lambert adaptado).",
                                    "Simule erros de alumbramento lunar usando parâmetros orbitais (ângulo de fase lunar).",
                                    "Calcule desvios angulares induzidos por altitude orbital via geometria esférica.",
                                    "Execute simulações numéricas para gerar curvas de erro vs. condições ambientais.",
                                    "Compare resultados simulados com dados empíricos de missões reais."
                                  ],
                                  "verification": "Gere gráficos de erro angular (graus) versus variáveis ambientais e valide com benchmarks conhecidos.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python (NumPy, SciPy, Matplotlib), dados orbitais de satélites (ex: Two-Line Elements - TLEs).",
                                  "tips": "Comece com casos simplificados (órbita baixa equatorial) antes de cenários complexos.",
                                  "learningObjective": "Capacitar modelagem quantitativa de erros para previsão de precisão.",
                                  "commonMistakes": "Não considerar propagação de erros em cadeias de medição múltipla."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar e Aplicar Métodos de Calibração",
                                  "subSteps": [
                                    "Revise técnicas de calibração em solo para sensores IR (ex: câmara térmica controlada).",
                                    "Aprenda calibração in-orbit usando estrelas conhecidas ou horizonte diurno.",
                                    "Implemente algoritmos de calibração multi-pontos para compensar offsets.",
                                    "Teste calibração em simulações com ruído adicionado representando erros reais.",
                                    "Documente parâmetros calibrados (ganho, bias) e sua estabilidade temporal."
                                  ],
                                  "verification": "Aplique calibração em dados simulados e reduza erro RMS em pelo menos 20%.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Ferramentas de simulação como STK (Systems Tool Kit) ou Orekit, planilhas para ajuste de parâmetros.",
                                  "tips": "Use otimização de mínimos quadrados para ajustes automáticos.",
                                  "learningObjective": "Dominar calibração para minimizar vieses sistemáticos em sensores.",
                                  "commonMistakes": "Subestimar deriva térmica durante calibração in-orbit."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Compensações e Avaliar Melhoria na Precisão",
                                  "subSteps": [
                                    "Desenvolva filtros (ex: Kalman) para compensar erros ambientais dinâmicos.",
                                    "Integre modelos preditivos de nuvens/auroras baseados em dados meteorológicos.",
                                    "Aplique fusão de sensores (IR + solar) para mitigar limitações individuais.",
                                    "Simule cenários completos de determinação de atitude e meça precisão pós-compensação.",
                                    "Otimize parâmetros de compensação via iterações iterativas."
                                  ],
                                  "verification": "Demonstre redução de erro total de atitude de >1° para <0.1° em simulações.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com filtro Kalman (filterpy), dados de missões como GOES ou DSCOVR.",
                                  "tips": "Priorize compensações probabilísticas para eventos raros como auroras.",
                                  "learningObjective": "Aplicar técnicas de compensação para alcançar precisão operacional.",
                                  "commonMistakes": "Sobrecarregar o modelo com compensações desnecessárias, aumentando complexidade."
                                }
                              ],
                              "practicalExample": "Em uma simulação de satélite em órbita LEO (500km), durante uma passagem noturna com aurora austral detectada, aplique modelagem de erro (aumentando ruído IR em 30%), calibre o sensor com dados diurnos prévios e compense via filtro Kalman, reduzindo o erro de roll de 2.5° para 0.2°.",
                              "finalVerifications": [
                                "Tabela completa de fontes de erro com quantificações numéricas.",
                                "Gráficos de simulação mostrando erros antes/depois de calibração e compensação.",
                                "Relatório com análise de sensibilidade a variações orbitais.",
                                "Código funcional para modelagem e compensação reproduzível.",
                                "Comparação com dados reais de uma missão (ex: Hubble Fine Guidance Sensor).",
                                "Verificação de precisão final <0.5° em 95% dos cenários simulados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todas as fontes de erro listadas (nuvens, auroras, etc.).",
                                "Correção matemática nos modelos de erro (equações validadas).",
                                "Efetividade da calibração (redução >15% em erro RMS).",
                                "Robustez das compensações em cenários variados.",
                                "Clareza e completude da documentação e visualizações.",
                                "Criatividade em conexões com dados reais de missões."
                              ],
                              "crossCurricularConnections": [
                                "Física: Termodinâmica e radiação IR (leis de Planck e Stefan-Boltzmann).",
                                "Matemática: Geometria esférica e filtros estocásticos (Kalman).",
                                "Programação: Simulações numéricas e processamento de dados orbitais.",
                                "Ciência da Terra: Meteorologia espacial (auroras, nuvens).",
                                "Engenharia: Sistemas de controle e fusão de sensores."
                              ],
                              "realWorldApplication": "Melhoria da determinação de atitude em satélites como os da constelação Starlink ou CubeSats científicos, permitindo apontamento preciso de antenas apesar de perturbações ambientais, essencial para comunicações e observações terrestres em missões da NASA/ESA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Sensores Solares",
                        "description": "Sensores que medem a direção do vetor Sol através de células fotossensíveis para determinar o ângulo de atitude yaw e auxiliar na determinação completa da orientação do veículo espacial.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Princípio de Funcionamento dos Sensores Solares",
                            "description": "Explicar o uso de múltiplas células solares dispostas em um hemisfério para medir intensidades luminosas e computar o vetor unitário do Sol via relações trigonométricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Geometria do Arranjo Hemisférico de Células Solares",
                                  "subSteps": [
                                    "Visualize um hemisfério com células solares posicionadas em múltiplos ângulos, tipicamente 6 a 12 células distribuídas uniformemente.",
                                    "Identifique as posições das células como vetores unitários apontando para fora do hemisfério, cada uma com coordenadas esféricas (θ, φ).",
                                    "Entenda que o hemisfério garante que pelo menos algumas células recebam luz direta do Sol de qualquer direção.",
                                    "Desenhe um diagrama 3D simples do hemisfério com 8 células nos octantes para ilustrar a cobertura angular.",
                                    "Discuta por que a disposição hemisférica é superior a planos lineares para detecção omnidirecional."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama do arranjo hemisférico com pelo menos 6 células e suas direções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis para diagrama",
                                    "Software de modelagem 3D como Blender ou GeoGebra (opcional)",
                                    "Referências sobre sensores solares espaciais"
                                  ],
                                  "tips": "Comece com uma esfera e corte pela metade para visualizar o hemisfério; use coordenadas esféricas para precisão.",
                                  "learningObjective": "Dominar a geometria espacial das células solares em sensores hemisféricos para cobertura completa do céu.",
                                  "commonMistakes": [
                                    "Confundir hemisfério com semicírculo 2D",
                                    "Ignorar a normalização dos vetores de posição das células",
                                    "Assumir distribuição aleatória em vez de uniforme"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Medir e Interpretar Intensidades Luminosas das Células",
                                  "subSteps": [
                                    "Explique que cada célula gera corrente proporcional ao cosseno do ângulo entre sua normal e a direção do Sol (lei dos cossenos).",
                                    "Colete dados simulados de correntes (I_i) de cada célula sob luz solar incidente.",
                                    "Normalize as intensidades medindo a soma total ou usando uma célula de referência para compensar variações de intensidade solar.",
                                    "Registre intensidades em uma tabela com colunas para célula ID, posição vetorial e intensidade medida.",
                                    "Simule ruído ou sombreamento parcial para entender impactos reais nas medições."
                                  ],
                                  "verification": "Crie uma tabela com intensidades simuladas para 8 células e explique a normalização aplicada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Calculadora científica",
                                    "Dados simulados de intensidades (fornecidos ou gerados via script Python simples)"
                                  ],
                                  "tips": "Use I_i = I_sun * cos(θ_i) como modelo básico, onde θ_i é o ângulo de incidência.",
                                  "learningObjective": "Relacionar medições elétricas das células solares à direção angular da fonte luminosa.",
                                  "commonMistakes": [
                                    "Esquecer normalização levando a erros de escala",
                                    "Confundir intensidade com potência absoluta",
                                    "Ignorar efeitos de temperatura nas células"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Relações Trigonométricas para Modelar Respostas",
                                  "subSteps": [
                                    "Derive a equação I_i ≈ k * (n_i · s), onde n_i é o vetor unitário da célula i e s é o vetor unitário do Sol.",
                                    "Expresse o produto escalar como relação trigonométrica: cos(θ_i) = n_i,x * s_x + n_i,y * s_y + n_i,z * s_z.",
                                    "Formule o sistema de equações lineares a partir das múltiplas medições I_i para estimar s.",
                                    "Resolva usando mínimos quadrados para sobredeterminação (mais células que incógnitas).",
                                    "Valide com simulações numéricas alterando a direção do Sol e verificando predições."
                                  ],
                                  "verification": "Derive e resolva um sistema de 3 equações para um caso simples com Sol em (1,0,0) e 3 células ortogonais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB, Python (NumPy/SciPy) ou Wolfram Alpha",
                                    "Papel para derivações manuais"
                                  ],
                                  "tips": "Lembre-se: o problema é linear em s após normalização, permitindo soluções analíticas rápidas.",
                                  "learningObjective": "Usar trigonometria vetorial para conectar medições escalares a um vetor direcional desconhecido.",
                                  "commonMistakes": [
                                    "Usar seno em vez de cosseno para incidência",
                                    "Não normalizar vetores levando a magnitudes erradas",
                                    "Resolver como sistema exato em vez de mínimos quadrados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar e Validar o Vetor Unitário do Sol",
                                  "subSteps": [
                                    "Implemente o algoritmo de mínimos quadrados: s = argmin || A s - b || onde A tem linhas n_i e b tem I_i normalizados.",
                                    "Normalize o vetor resultante para garantir ||s|| = 1.",
                                    "Calcule o erro angular entre s estimado e direção real usando acos(s · s_true).",
                                    "Teste com dados reais ou simulados de múltiplas direções solares ao longo do dia.",
                                    "Discuta calibração e compensações para eficiência não-ideal das células."
                                  ],
                                  "verification": "Implemente um script que estime s com erro < 5° para 10 direções aleatórias simuladas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com bibliotecas NumPy e Matplotlib para plotar vetores",
                                    "Dados de teste pré-gerados"
                                  ],
                                  "tips": "Use np.linalg.lstsq() no Python para solução eficiente; plote o hemisfério com setas para visualização.",
                                  "learningObjective": "Sintetizar medições em um vetor unitário preciso representando a direção solar.",
                                  "commonMistakes": [
                                    "Esquecer normalização final do vetor",
                                    "Sobreajustar a ruído sem regularização",
                                    "Confundir eixo de rotação com direção solar"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat como o CubeSat-1 da NASA, 8 células solares em hemisfério medem correntes sob luz solar simulada; normaliza-se as intensidades, aplica-se mínimos quadrados para estimar s, resultando em direção solar com precisão de 3°, usada para controlar painéis solares e evitar eclipse.",
                              "finalVerifications": [
                                "Descreva verbalmente o arranjo hemisférico e justifique sua cobertura angular.",
                                "Calcule manualmente o vetor s para um caso com 4 células e Sol equatorial.",
                                "Implemente e rode um script Python reproduzindo o algoritmo com erro médio < 4°.",
                                "Explique impactos de sombreamento ou baixa intensidade solar nas medições.",
                                "Compare precisão com sensores de horizonte infravermelho.",
                                "Desenhe diagrama mostrando produto escalar geométrico."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na explicação trigonométrica (90% correto).",
                                "Correção matemática nos cálculos e derivações (erro < 5%).",
                                "Profundidade nos substeps com exemplos numéricos reais.",
                                "Criatividade na simulação prática e análise de erros.",
                                "Clareza na comunicação via diagramas e código comentado.",
                                "Integração de dicas para evitar erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores unitários, produtos escalares e mínimos quadrados.",
                                "Física: Lei dos cossenos em óptica fotovoltaica e radiometria.",
                                "Engenharia: Sensores em sistemas embarcados aeroespaciais.",
                                "Computação: Algoritmos numéricos e processamento de sinais.",
                                "Química: Propriedades semicondutoras de células solares."
                              ],
                              "realWorldApplication": "Satélites como o Hubble e estações espaciais ISS usam sensores solares hemisféricos para determinação autônoma de atitude, otimizando orientação de painéis solares, navegação sem GPS e estabilização sem consumo excessivo de propelente, essencial para missões de longa duração."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Modelagem Matemática do Vetor Sol",
                            "description": "Derivar as equações matemáticas para reconstruir o vetor Sol a partir de medidas de sensores, incluindo normalização e resolução de ambiguidades de 180 graus.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos do Vetor Sol e Sensores Solares",
                                  "subSteps": [
                                    "Definir o vetor Sol unitário como direção do Sol no referencial do corpo do satélite.",
                                    "Explicar o princípio de funcionamento dos sensores solares: medição de intensidade proporcional ao cosseno do ângulo entre o vetor Sol e a normal do sensor.",
                                    "Descrever a configuração típica: 6 sensores em faces opostas (±x, ±y, ±z).",
                                    "Identificar a ambiguidade de 180 graus: s e -s produzem as mesmas medições.",
                                    "Revisar transformações de coordenadas entre referencial inercial e do corpo."
                                  ],
                                  "verification": "Criar um diagrama esquemático mostrando sensores, vetor Sol e equação cos θ = s · n_i.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagramas de sensores solares",
                                    "Referência: 'Spacecraft Attitude Determination and Control' de Wertz"
                                  ],
                                  "tips": "Visualize o satélite como um cubo com sensores nas faces para intuitar as projeções.",
                                  "learningObjective": "Dominar os conceitos físicos e geométricos subjacentes às medições solares.",
                                  "commonMistakes": [
                                    "Ignorar o campo de visão finito dos sensores",
                                    "Confundir vetor Sol com vetor magnético",
                                    "Esquecer que medições são zero quando θ > 90°"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar as Medições dos Sensores",
                                  "subSteps": [
                                    "Estabelecer a equação de medição: S_i = k * max(0, s · n_i), onde n_i é a normal unitária do sensor i.",
                                    "Listar vetores normais para configuração padrão: n_{+x} = [1,0,0], n_{-x} = [-1,0,0], etc.",
                                    "Derivar a relação para pares opostos: S_{+x} - S_{-x} ≈ k * |s_x| (aproximação para reconstrução).",
                                    "Normalizar as medições: definir soma total ΣS_i para escalar k.",
                                    "Discutir ruído e calibração: assumir medições normalizadas ΣS_i = 1."
                                  ],
                                  "verification": "Calcular medições simuladas para um vetor Sol conhecido s = [0.6, 0.8, 0] e verificar consistência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para simulações",
                                    "Planilha para cálculos manuais"
                                  ],
                                  "tips": "Use vetores unitários sempre; teste com s e -s para ver ambiguidade.",
                                  "learningObjective": "Formular o modelo matemático exato das saídas dos sensores.",
                                  "commonMistakes": [
                                    "Usar seno em vez de cosseno",
                                    "Não considerar saturação ou sombra",
                                    "Esquecer normalização da soma das medições"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Equações de Reconstrução do Vetor Sol",
                                  "subSteps": [
                                    "Definir o vetor bruto v = [ (S_{+x}-S_{-x}), (S_{+y}-S_{-y}), (S_{+z}-S_{-z}) ] / ΣS_i.",
                                    "Reconhecer que ||v|| ≤ 1 devido a não-linearidades, então s ≈ v / ||v||.",
                                    "Derivar a normalização: s = v / ||v|| para obter vetor unitário.",
                                    "Analisar precisão: erro quadrático médio entre s · n_i e S_i normalizadas.",
                                    "Implementar algoritmo iterativo se necessário para refinar (método de mínimos quadrados)."
                                  ],
                                  "verification": "Resolver para medições dadas e comparar com vetor Sol verdadeiro usado na simulação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software NumPy/Python ou MATLAB",
                                    "Papel e lápis para derivação analítica"
                                  ],
                                  "tips": "Comece com casos 1D (apenas eixo x) para validar antes de 3D.",
                                  "learningObjective": "Derivar e aplicar as equações para estimar o vetor Sol a partir de medições.",
                                  "commonMistakes": [
                                    "Dividir por soma incorreta",
                                    "Não normalizar para unidade",
                                    "Confundir diferenças de sensores opostos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver Ambiguidade de 180 Graus e Validar",
                                  "subSteps": [
                                    "Explicar ambiguidade: s e -s dão v idêntico em magnitude.",
                                    "Propor métodos de resolução: assumir hemisfério baseado em modelo orbital ou sensor auxiliar.",
                                    "Implementar lógica: escolher sinal baseado em direção esperada do Sol (ex: dot product com modelo).",
                                    "Validar consistência: verificar se todas S_i ≥ 0 e s · n_i ≈ S_i.",
                                    "Testar com ruído: adicionar Gaussian noise e avaliar robustez."
                                  ],
                                  "verification": "Gerar dois candidatos (s e -s), resolver ambiguidade e confirmar match com verdade terrestre.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python com bibliotecas astropy para modelo orbital",
                                    "Dados simulados de sensores"
                                  ],
                                  "tips": "Use ephemerides solares para priorizar direção real em órbita LEO.",
                                  "learningObjective": "Lidar com ambiguidades inerentes e produzir estimativa única e precisa.",
                                  "commonMistakes": [
                                    "Sempre escolher direção positiva arbitrariamente",
                                    "Ignorar contexto orbital",
                                    "Não testar com ambiguidade real"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um CubeSat em órbita LEO com medições normalizadas S = [0.3, 0.1, 0.4, 0.05, 0.6, 0.05], compute v = [0.2, 0.35, 0.55], normalize s ≈ [0.25, 0.44, 0.69]. Resolva ambiguidade usando modelo orbital indicando Sol em quadrante positivo-z, validando s · n_i ≈ S_i.",
                              "finalVerifications": [
                                "Magnitude do vetor Sol reconstruído é exatamente 1 (erro < 1e-6).",
                                "Projeções s · n_i coincidem com medições normalizadas (erro médio < 5%).",
                                "Ambiguidade de 180° resolvida corretamente com base em contexto orbital.",
                                "Robustez testada com ruído: erro < 10° para SNR > 10.",
                                "Consistência com modelo físico: nenhuma medição negativa projetada.",
                                "Implementação computacional reproduz resultados analíticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação matemática (equações corretas e normalizadas).",
                                "Correta modelagem de não-linearidades e ambiguidade.",
                                "Qualidade da implementação numérica e testes de validação.",
                                "Explicação clara de passos e justificativas físicas.",
                                "Criatividade na resolução de ambiguidade com métodos reais.",
                                "Eficiência computacional para aplicação embarcada."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: vetores unitários, produtos escalares e normalização.",
                                "Física: óptica geométrica e radiação solar.",
                                "Programação: implementação numérica em Python/MATLAB para simulações.",
                                "Engenharia de Controle: integração em loops de determinação de atitude.",
                                "Astronomia: uso de efemérides solares para resolução de ambiguidades."
                              ],
                              "realWorldApplication": "Em missões como CubeSats (ex: MarCO da NASA) ou estações espaciais, essa modelagem permite determinação precisa de atitude usando sensores solares baratos, essencial para apontamento de antenas, painéis solares e manobras autônomas sem GPS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Integração com Outros Sensores para Atitude Completa",
                            "description": "Descrever métodos de fusão de dados com sensores infravermelhos ou magnetômetros usando filtros de Kalman para obter a matriz de atitude completa (roll, pitch, yaw).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão de Sensores e Modelos de Atitude",
                                  "subSteps": [
                                    "Identifique as medições de cada sensor: vetores solares de sensores solares, vetores terrestres de infravermelhos, e campo magnético de magnetômetros.",
                                    "Defina representações de atitude: quaternions ou matrizes de rotação para roll, pitch, yaw.",
                                    "Estabeleça modelos de ruído e bias para cada sensor com base em especificações típicas.",
                                    "Crie diagramas de referência de corpo e inercial para alinhamento.",
                                    "Compile uma tabela comparativa de precisão e taxas de amostragem dos sensores."
                                  ],
                                  "verification": "Tabela de modelos de sensores completada e diagramas validados contra referências padrão.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Documentação de sensores (datasheets), software de diagramação (Draw.io), referências em dinâmica de atitude (ex: Sidi 'Spacecraft Dynamics and Control').",
                                  "tips": "Use quaternions para evitar singularidades em gimbal lock.",
                                  "learningObjective": "Compreender as saídas e limitações de sensores complementares para determinação de atitude.",
                                  "commonMistakes": "Ignorar alinhamentos de montagem dos sensores ou assumir ruído gaussiano puro sem bias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Fundamentos do Filtro de Kalman Estendido (EKF)",
                                  "subSteps": [
                                    "Revise equações do EKF: predição (state transition, covariance), update (innovation, Kalman gain).",
                                    "Defina estado: vetor de atitude (quaternions) e biases de sensores.",
                                    "Derive funções de observabilidade para cada sensor (H matrices).",
                                    "Implemente linearização jacobianas para não-linearidades de rotação.",
                                    "Simule um EKF simples em 1D para validar compreensão."
                                  ],
                                  "verification": "Simulação 1D converge para verdadeiros valores com ruído adicionado.",
                                  "estimatedTime": "6 horas",
                                  "materials": "MATLAB/Simulink ou Python (NumPy, SciPy), tutoriais EKF (ex: papers de Crassidis).",
                                  "tips": "Normalice quaternions após cada predição para estabilidade numérica.",
                                  "learningObjective": "Dominar a estrutura matemática do EKF para fusão de dados não-lineares de atitude.",
                                  "commonMistakes": "Erro na derivação de jacobianas, levando a divergência do filtro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projeto do Modelo de Fusão Multi-Sensor",
                                  "subSteps": [
                                    "Integre modelos de todos sensores no vetor de observação.",
                                    "Defina matriz de covariância de processo Q e de medição R baseada em testes empíricos.",
                                    "Implemente lógica de switching ou weighting para sensores disponíveis (ex: eclipse para solares).",
                                    "Ajuste tuning parameters via simulações Monte Carlo.",
                                    "Valide observabilidade do sistema combinado via rank de matriz."
                                  ],
                                  "verification": "Matriz de observabilidade tem rank completo; erro RMS < 1° em simulações ideais.",
                                  "estimatedTime": "8 horas",
                                  "materials": "Python/MATLAB com bibliotecas de álgebra linear, dados simulados de sensores.",
                                  "tips": "Comece com dois sensores e adicione gradualmente para isolar problemas.",
                                  "learningObjective": "Projetar um EKF robusto para fusão assíncrona e multi-sensor de atitude.",
                                  "commonMistakes": "Subestimar covariâncias R, causando overweight em sensores ruidosos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementação e Simulação em Código",
                                  "subSteps": [
                                    "Codifique o EKF completo com loop de predição-update.",
                                    "Gere dados de verdade de simulação (ex: rotação arbitrária de satélite).",
                                    "Adicione ruído realista e teste convergência.",
                                    "Implemente visualizações: plots de erro de atitude vs tempo.",
                                    "Otimize código para taxa de amostragem real (ex: 10 Hz)."
                                  ],
                                  "verification": "Código roda sem erros; plots mostram convergência < 0.5° em 10s.",
                                  "estimatedTime": "10 horas",
                                  "materials": "Python (filterpy ou custom), Jupyter Notebook, dados de simulação (ex: Orekit ou custom kinematics).",
                                  "tips": "Use unit tests para funções jacobianas individuais.",
                                  "learningObjective": "Implementar funcionalmente um sistema de fusão de atitude em software.",
                                  "commonMistakes": "Mismatch de timestamps entre sensores, causando instabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação e Análise de Desempenho",
                                  "subSteps": [
                                    "Compare desempenho vs filtros single-sensor.",
                                    "Teste cenários edge: eclipse, campos magnéticos distorcidos.",
                                    "Calcule métricas: RMSE, NEES (Normalized Estimation Error Squared).",
                                    "Ajuste hyperparameters para robustez.",
                                    "Documente limitações e melhorias (ex: UKF)."
                                  ],
                                  "verification": "Relatório com métricas mostrando melhoria >30% em precisão.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Ferramentas de plotting (Matplotlib), scripts de Monte Carlo.",
                                  "tips": "Registre seeds para reprodutibilidade em simulações estocásticas.",
                                  "learningObjective": "Avaliar e refinar sistemas de determinação de atitude multi-sensor.",
                                  "commonMistakes": "Overfitting a um cenário, falhando em testes reais."
                                }
                              ],
                              "practicalExample": "Em um CubeSat simulado, integre sensores solares (2 vetores), infravermelho terrestre (1 vetor) e magnetômetro de 3 eixos. Use EKF para fundir dados durante órbita LEO, obtendo atitude precisa mesmo durante eclipses parciais, com roll/pitch <0.5° e yaw <2° após convergência.",
                              "finalVerifications": [
                                "EKF converge consistentemente em <10s para condições nominais.",
                                "Erro RMS de atitude <1° em simulações com ruído realista.",
                                "Sistema lida com falha de um sensor sem divergência.",
                                "Visualizações mostram alinhamento correto com verdade de simulação.",
                                "Código é modular e documentado para reutilização.",
                                "Métricas NEES dentro de bounds de chi-quadrado."
                              ],
                              "assessmentCriteria": [
                                "Precisão da fusão: RMSE <1° para todos eixos.",
                                "Robustez: Performance em 80% dos cenários Monte Carlo.",
                                "Eficiência computacional: <1ms por iteração em hardware embarcado.",
                                "Correção matemática: Jacobianas validadas numericamente.",
                                "Documentação: Explicação clara de tuning e limitações.",
                                "Inovação: Adaptação para cenários específicos como eclipses."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rotação), estatística (estimadores bayesianos).",
                                "Programação: Algoritmos numéricos, simulação orientada a objetos.",
                                "Física: Cinemática de rotação rígida, magnetostática.",
                                "Engenharia de Controle: Observadores de estado, feedback.",
                                "Ciência de Dados: Fusão sensorial, validação estatística."
                              ],
                              "realWorldApplication": "Em satélites como o CubeSat da NASA ou missões da SpaceX Starlink, onde filtros de Kalman multi-sensor garantem controle preciso de atitude para comunicações, imageamento terrestre e manobras orbitais, reduzindo consumo de combustível e risco de colisão."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.4",
                            "name": "Calibração e Tratamento de Ocultação",
                            "description": "Explicar procedimentos de calibração em solo e órbita, além de algoritmos para lidar com ocultação pelo veículo ou pela Terra, garantindo robustez na determinação de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos de Calibração em Solo",
                                  "subSteps": [
                                    "Configurar o sensor solar em uma bancada de testes controlada com fontes de luz conhecidas.",
                                    "Realizar medições de resposta angular em múltiplas direções relativas ao Sol simulado.",
                                    "Aplicar modelo matemático para mapear saídas do sensor para vetores unitários.",
                                    "Ajustar parâmetros de calibração minimizando erro quadrático médio.",
                                    "Documentar coeficientes de calibração e condições ambientais."
                                  ],
                                  "verification": "Gerar relatório com curvas de calibração e erro residual abaixo de 0.5 graus.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Sensor solar de teste",
                                    "Fonte de luz colimada",
                                    "Software MATLAB ou Python (SciPy)",
                                    "Giroscópio de referência"
                                  ],
                                  "tips": "Use iluminação uniforme e controle temperatura para evitar deriva térmica.",
                                  "learningObjective": "Compreender e executar calibração estática em solo para sensores solares.",
                                  "commonMistakes": [
                                    "Ignorar não-linearidades na resposta do sensor",
                                    "Não calibrar em todo o campo de visão",
                                    "Falta de normalização de vetores de saída"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Procedimentos de Calibração em Órbita",
                                  "subSteps": [
                                    "Coletar dados iniciais de sensores solares durante fase de comissionamento orbital.",
                                    "Comparar medições com modelo orbital preciso (ephemerides do Sol e veículo).",
                                    "Estimar rotação do veículo usando dados de outros sensores (ex: magnetômetros).",
                                    "Otimizar parâmetros de calibração via filtro de Kalman ou minimização de custo.",
                                    "Validar calibração com manobras conhecidas de atitude."
                                  ],
                                  "verification": "Demonstrar convergência de parâmetros com erro de atitude < 1 grau em simulação.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Simulador orbital (STK ou Orekit)",
                                    "Dados telemétricos simulados",
                                    "Biblioteca de processamento de attitude (ex: Orekit Attitudes)",
                                    "Notebook com Python/Jupyter"
                                  ],
                                  "tips": "Inicie com valores de calibração de solo como chute inicial para convergência rápida.",
                                  "learningObjective": "Aplicar técnicas adaptativas de calibração dinâmica em ambiente orbital.",
                                  "commonMistakes": [
                                    "Não contabilizar acelerações residuais",
                                    "Sobrestimar precisão inicial",
                                    "Ignorar efeitos de alumbramento parcial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detecção de Eventos de Ocultação",
                                  "subSteps": [
                                    "Modelar geometria de ocultação pelo veículo usando CAD do satélite e direção solar.",
                                    "Simular sinal do sensor durante entrada/saída de sombra (eclipse ou obstrução).",
                                    "Implementar detecção por limiar em magnitude de sinal e taxa de variação.",
                                    "Integrar modelo orbital para prever períodos de ocultação pela Terra.",
                                    "Testar detecção em dados simulados com ruído gaussiano."
                                  ],
                                  "verification": "Classificar corretamente 95% dos eventos de ocultação em conjunto de teste.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Modelo 3D do veículo (CAD/STL)",
                                    "Software de simulação orbital",
                                    "Python com NumPy e Matplotlib",
                                    "Dados de eclipse TLE/ ephemerides"
                                  ],
                                  "tips": "Use derivadas temporais do sinal para detectar transições rápidas de sombra.",
                                  "learningObjective": "Identificar e modelar condições de ocultação para sensores solares.",
                                  "commonMistakes": [
                                    "Limiares fixos sem adaptação a órbita",
                                    "Confundir flares com ocultações",
                                    "Não considerar penumbra"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Algoritmos de Tratamento de Ocultação e Robustez",
                                  "subSteps": [
                                    "Desenvolver algoritmo de rejeição de amostras durante ocultação detectada.",
                                    "Implementar fusão com outros sensores (ex: IR terrestre) via filtro estendido de Kalman.",
                                    "Adicionar lógica de predição de atitude usando dinâmica inercial durante breves ocultações.",
                                    "Otimizar para latência em tempo real (< 10ms por ciclo).",
                                    "Validar robustez com cenários Monte Carlo de falhas múltiplas."
                                  ],
                                  "verification": "Simulação end-to-end mostra erro de atitude máximo < 2 graus em 99% dos casos.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Ferramenta EKF (Python FilterPy ou MATLAB)",
                                    "Simulador de dinâmica de atitude",
                                    "Hardware-in-the-loop se disponível"
                                  ],
                                  "tips": "Priorize sensores redundantes e use covariâncias adaptativas no filtro.",
                                  "learningObjective": "Criar sistema robusto de determinação de atitude lidando com ocultações.",
                                  "commonMistakes": [
                                    "Falta de validação em órbitas eclipse",
                                    "Sobrecarga computacional em filtros",
                                    "Não tratar histerese em detecção"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat de observação terrestre como o Aether, calibrar sensores solares em solo com rotação em gimbals, refinar em órbita LEO comparando com GPS e estrelas, detectar ocultações pela estrutura solar usando modelo CAD, e tratar via EKF fundindo com horizonte IR, mantendo precisão de 0.5 graus durante 30% do tempo em eclipse.",
                              "finalVerifications": [
                                "Explicar diferenças entre calibração em solo e órbita com exemplos numéricos.",
                                "Implementar detecção de ocultação em código e testar com dados simulados.",
                                "Demonstrar algoritmo de tratamento reduzindo erro em simulação orbital completa.",
                                "Gerar relatório com métricas de precisão e robustez.",
                                "Discutir impactos de erros de calibração em missões reais.",
                                "Realizar peer-review de código e simulações."
                              ],
                              "assessmentCriteria": [
                                "Precisão de calibração: erro < 0.5 graus em solo e <1 grau em órbita.",
                                "Taxa de detecção de ocultação: >95% de acurácia em testes variados.",
                                "Robustez do algoritmo: manutenção de atitude <2 graus durante ocultações.",
                                "Eficiência computacional: latência <50ms em hardware embarcado simulado.",
                                "Documentação: clareza e completude de relatórios e código.",
                                "Criatividade em tratamento de edge cases (ex: múltiplas ocultações)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (vetores unitários, quaternions) e otimização não-linear.",
                                "Física: Óptica geométrica, dinâmica orbital e termodinâmica de sensores.",
                                "Programação: Algoritmos numéricos, filtros de Kalman e simulação em Python/MATLAB.",
                                "Engenharia: Modelagem CAD e análise de sistemas embarcados.",
                                "Estatística: Análise de Monte Carlo e validação de ruído."
                              ],
                              "realWorldApplication": "Em satélites como os da constelação Starlink ou missões Artemis, garante determinação precisa de atitude durante eclipses terrestres, evitando perda de apontamento em comunicações laser ou imagens ópticas, reduzindo custos de redundância e melhorando vida útil da missão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Determinação de Atitude com Sensores de Estrelas e Inerciais",
                    "description": "Aplicação de sensores de estrelas e sensores inerciais na determinação precisa da atitude.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Sensores de Estrelas",
                        "description": "Princípios de funcionamento dos sensores de estrelas (star trackers), incluindo aquisição de imagens estelares, reconhecimento de padrões e geração de quaternions de atitude com alta precisão.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Identificar estrelas em imagens capturadas",
                            "description": "Analisar imagens de campo de visão do sensor de estrelas para identificar e catalogar estrelas conhecidas utilizando bancos de dados estelares como o catálogo Hipparcos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do ambiente e aquisição de dados",
                                  "subSteps": [
                                    "Instalar Python 3.8+ e bibliotecas essenciais: numpy, scipy, astropy, opencv-python via pip.",
                                    "Baixar o catálogo Hipparcos completo ou subset (ex: do CDS Strasbourg) em formato CSV ou FITS.",
                                    "Obter imagem de teste de sensor de estrelas (ex: simulações de STK ou datasets públicos como Gaia DR3 imagens estelares).",
                                    "Criar workspace no Jupyter Notebook e testar carregamento da imagem e catálogo.",
                                    "Definir parâmetros do sensor: FOV (campo de visão), resolução de pixels e pointing aproximado."
                                  ],
                                  "verification": "Script executa sem erros; imagem carrega com shape correto e catálogo acessível com query básica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com Python",
                                    "Conexão à internet",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use ambientes virtuais (venv) para isolar dependências e evite conflitos de versões.",
                                  "learningObjective": "Configurar ferramentas e dados necessários para processamento de imagens estelares.",
                                  "commonMistakes": [
                                    "Baixar catálogo em formato incompatível (use astropy para conversão)",
                                    "Ignorar metadados da imagem como escala de pixels",
                                    "Não testar carregamento inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pré-processamento da imagem capturada",
                                  "subSteps": [
                                    "Carregar imagem em escala de cinza usando OpenCV ou Astropy.",
                                    "Aplicar filtro de redução de ruído (ex: median blur com kernel 3x3).",
                                    "Realizar subtração de fundo usando estimativa local (ex: Astropy background).",
                                    "Normalizar a intensidade de pixels para faixa [0,1].",
                                    "Visualizar e salvar imagem pré-processada para inspeção."
                                  ],
                                  "verification": "Imagem resultante mostra estrelas nítidas sem artefatos de ruído ou fundo irregular.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python com OpenCV/Astropy",
                                    "Imagem de teste"
                                  ],
                                  "tips": "Ajuste o tamanho do kernel de blur baseado no nível de ruído observado na imagem original.",
                                  "learningObjective": "Limpar imagem para melhorar detecção de estrelas subsequente.",
                                  "commonMistakes": [
                                    "Over-blur que funde estrelas próximas",
                                    "Subtração de fundo agressiva removendo estrelas fracas",
                                    "Esquecer normalização levando a saturação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detecção de centróides de estrelas",
                                  "subSteps": [
                                    "Aplicar thresholding adaptativo para binarizar a imagem pré-processada.",
                                    "Detectar regiões conectadas (blobs) ou usar DAOStarFinder do Astropy para encontrar estrelas.",
                                    "Calcular centróides precisos (sub-pixel) usando momentos ou Gaussian fit.",
                                    "Medir intensidades e filtrar candidatos por brilho (magnitude aparente simulada).",
                                    "Gerar lista de centróides com posições (x,y pixels) e fluxos."
                                  ],
                                  "verification": "Lista contém pelo menos 10-20 centróides válidos com posições precisas e fluxos positivos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Bibliotecas Astropy/Scipy",
                                    "Imagem pré-processada"
                                  ],
                                  "tips": "Use sigma de detecção ~5 para evitar falsos positivos em campos estrelados.",
                                  "learningObjective": "Extrair posições precisas de estrelas candidatas da imagem.",
                                  "commonMistakes": [
                                    "Threshold fixo em vez de adaptativo",
                                    "Não filtrar ruído cósmico como falsos centróides",
                                    "Centroiding impreciso em estrelas saturadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Consulta ao catálogo Hipparcos e projeção de posições",
                                  "subSteps": [
                                    "Definir região de busca no catálogo baseada em pointing estimado e FOV do sensor.",
                                    "Query o catálogo Hipparcos por estrelas dentro do FOV (RA, Dec, magnitude).",
                                    "Implementar modelo de projeção simples (gnomônica) para mapear coordenadas celestes (RA/Dec) a pixels.",
                                    "Calcular posições esperadas de estrelas catalogadas no plano da imagem.",
                                    "Filtrar estrelas catalogadas por magnitude visível no sensor."
                                  ],
                                  "verification": "Lista de 20+ estrelas candidatas do catálogo com posições pixel projetadas gerada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Catálogo Hipparcos carregado",
                                    "Funções de astrometria Astropy"
                                  ],
                                  "tips": "Use coordenadas J2000 para consistência com Hipparcos; teste projeção com estrelas conhecidas.",
                                  "learningObjective": "Gerar previsões de posições estelares baseadas em banco de dados.",
                                  "commonMistakes": [
                                    "Erro na rotação/distorsão do modelo de projeção",
                                    "Query muito ampla levando a excesso de candidatos",
                                    "Ignorar limite de magnitude do sensor"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Matching e catalogação de estrelas identificadas",
                                  "subSteps": [
                                    "Calcular matriz de distâncias angulares entre centróides detectados e posições projetadas.",
                                    "Aplicar algoritmo de matching (ex: nearest neighbor com threshold ou triangle matcher).",
                                    "Atribuir identidades (nomes Hipparcos) às estrelas detectadas com scores de confiança.",
                                    "Calcular erro RMS de matching e rejeitar outliers.",
                                    "Gerar relatório final: lista catalogada com nomes, posições, magnitudes e IDs."
                                  ],
                                  "verification": "Matching com >80% de acurácia, RMS < 1 pixel, lista final sem ambiguidades.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Listas de centróides e catálogo projetado",
                                    "Algoritmos de matching customizados"
                                  ],
                                  "tips": "Comece com matching pyramid para robustez em pointing desconhecido (lost-in-space).",
                                  "learningObjective": "Identificar e catalogar estrelas conectando detecção com dados astrométricos.",
                                  "commonMistakes": [
                                    "Matching ambíguo sem validação angular",
                                    "Não lidar com falsos positivos/negativos",
                                    "Ignorar rotação do sensor no matching"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de satélite CubeSat em órbita LEO, capture uma imagem de 10x10 graus FOV contendo o asterismo do Verão (Altair, Deneb, Vega). Processe para detectar 15 centróides, match com Hipparcos, identifique as 3 principais estrelas com precisão sub-pixel, e gere catálogo com RA/Dec, magnitudes e erros.",
                              "finalVerifications": [
                                "Lista catalogada inclui pelo menos 5 estrelas nomeadas com matching confirmado.",
                                "Erro RMS de posições < 0.5 pixels entre detectado e projetado.",
                                "Todas estrelas identificadas têm magnitudes consistentes com fluxos medidos.",
                                "Visualização overlay mostra matches corretos sem cruzamentos.",
                                "Relatório exportado em JSON/CSV com metadados completos.",
                                "Teste de robustez: funciona em 3 imagens diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão de identificação >85% em estrelas brilhantes (mag <6).",
                                "Eficiência computacional: processamento <5 minutos por imagem.",
                                "Código modular, comentado e reproduzível.",
                                "Tratamento de edge cases (ex: campo vazio ou nublado).",
                                "Validação quantitativa com métricas (recall, precision).",
                                "Documentação de parâmetros do sensor usados."
                              ],
                              "crossCurricularConnections": [
                                "Astronomia: Catálogos estelares e coordenadas celestes.",
                                "Processamento de Imagens: Visão computacional e detecção de features.",
                                "Programação: Python científico (Astropy, OpenCV, NumPy).",
                                "Matemática: Geometria projetiva e otimização de matching.",
                                "Física: Óptica de sensores CCD e fotometria estelar."
                              ],
                              "realWorldApplication": "Fundamental para sistemas de determinação de atitude autônoma em satélites e sondas espaciais (ex: Hubble, James Webb), permitindo orientação precisa em ambientes sem GPS, como deep space missions ou constelações de nanosats."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Aplicar algoritmos de reconhecimento de atitude",
                            "description": "Implementar métodos como QUEST ou STAR para determinar a matriz de rotação a partir de vetores observados e referenciados de estrelas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Determinação de Atitude com Sensores de Estrelas",
                                  "subSteps": [
                                    "Estude representações de atitude: matrizes de direção (DCM), quaternions e ângulos de Euler.",
                                    "Aprenda como sensores de estrelas fornecem vetores unitários observados e referenciados em catálogos estelares.",
                                    "Entenda o problema Wahba: minimizar perda quadrática entre vetores observados e referenciados.",
                                    "Revise álgebra linear necessária: produtos escalares, matrizes de covariância e autovalores.",
                                    "Explore ruído em medições de estrelas e modelos de erro."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes do processo de determinação de atitude e resolva um problema simples de perda de Wahba manualmente.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Spacecraft Attitude Determination and Control' de Wertz",
                                    "Catálogo Hipparcos de estrelas",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use visualizações 3D para entender rotações; foque em quaternions para evitar gimbal lock.",
                                  "learningObjective": "Dominar os conceitos teóricos base para algoritmos de estimação de atitude.",
                                  "commonMistakes": [
                                    "Confundir vetores observados (body frame) com referenciados (inertial frame)",
                                    "Ignorar normalização de vetores unitários",
                                    "Subestimar impacto do ruído gaussiano"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar e Derivar o Algoritmo QUEST",
                                  "subSteps": [
                                    "Analise a formulação de máxima verossimilhança para estimação de quaternions.",
                                    "Derive a matriz B (correlação) a partir de pares vetor-observado/referenciado.",
                                    "Implemente analiticamente a decomposição em autovalores da matriz 4x4 de Davenport.",
                                    "Calcule o quaternion eigen com maior autovalor.",
                                    "Converta quaternion para matriz de rotação DCM."
                                  ],
                                  "verification": "Derive manualmente a matriz B para 2 vetores e compute o quaternion resultante.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Artigo original QUEST de Shuster (1981)",
                                    "MATLAB/Python para simular decomposição eig",
                                    "Folhas de cálculo para derivação manual"
                                  ],
                                  "tips": "Verifique simetria positiva definida da matriz K; use bibliotecas como SciPy para validar eig.",
                                  "learningObjective": "Capacitar derivação e compreensão matemática do QUEST.",
                                  "commonMistakes": [
                                    "Erro na construção da matriz 4x4 (esquecer termos off-diagonal)",
                                    "Não normalizar quaternion final",
                                    "Ignorar ambiguidade de sinal no quaternion"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar e Comparar o Algoritmo STAR",
                                  "subSteps": [
                                    "Revise o método STAR como alternativa iterativa ao QUEST para múltiplos vetores.",
                                    "Entenda a inicialização com média de produtos escalares e iterações de refinamento.",
                                    "Compare convergência e robustez ao QUEST em cenários com ruído.",
                                    "Implemente pseudocódigo para loop iterativo de STAR.",
                                    "Analise sensibilidade a número de estrelas observadas (mínimo 2, ideal 3+)."
                                  ],
                                  "verification": "Compare resultados QUEST vs STAR para um conjunto de dados com 4 estrelas ruidosas.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Artigo STAR de Mortari",
                                    "Simulador de dados estelares (ex: MATLAB Aerospace Toolbox)",
                                    "Gráficos de convergência"
                                  ],
                                  "tips": "STAR é mais simples para implementação rápida; use para validação cruzada do QUEST.",
                                  "learningObjective": "Diferenciar e aplicar variantes de algoritmos de estimação.",
                                  "commonMistakes": [
                                    "Loop infinito por tolerância inadequada",
                                    "Inicialização pobre levando a convergência local",
                                    "Não tratar perda de observabilidade com <2 estrelas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Algoritmos em Código",
                                  "subSteps": [
                                    "Escreva função QUEST: input vetores observados/referenciados, output quaternion/DCM.",
                                    "Implemente função STAR com parâmetros de iteração e tolerância.",
                                    "Gere dados simulados: posições de estrelas verdadeiras + ruído + rotação conhecida.",
                                    "Integre filtros de outlier (ex: rejeitar estrelas com ângulo >45°).",
                                    "Otimize código para eficiência (vetorização NumPy)."
                                  ],
                                  "verification": "Execute código em dataset simulado e compute erro de atitude <1° RMS.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "GitHub repo para versionamento",
                                    "Exemplos de código de bibliotecas espaciais como Orekit"
                                  ],
                                  "tips": "Teste unitário cada função; use asserts para vetores unitários.",
                                  "learningObjective": "Desenvolver implementação numérica funcional e testável.",
                                  "commonMistakes": [
                                    "Índices errados em loops de vetores",
                                    "Não lidar com singularidades numéricas",
                                    "Confundir convenções de quaternion (scalar-last vs scalar-first)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar Implementação",
                                  "subSteps": [
                                    "Simule cenários reais: diferentes níveis de ruído, número de estrelas, taxas de rotação.",
                                    "Calcule métricas: erro RMS de quaternion, tempo de execução, taxa de falha.",
                                    "Compare com soluções de referência (ex: GYRO toolbox).",
                                    "Realize análise de sensibilidade e Monte Carlo.",
                                    "Documente limitações e melhorias (ex: fusão com giroscópio)."
                                  ],
                                  "verification": "Gere relatório com gráficos de erro vs ruído, confirmando precisão <0.1° com 3+ estrelas.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Ferramentas de plotagem (Matplotlib)",
                                    "Datasets públicos de simulação estelar",
                                    "Relatório LaTeX ou Markdown"
                                  ],
                                  "tips": "Use seeds fixos para reprodutibilidade em simulações Monte Carlo.",
                                  "learningObjective": "Avaliar robustez e performance da implementação.",
                                  "commonMistakes": [
                                    "Amostragem insuficiente em Monte Carlo",
                                    "Métricas erradas (ex: usar ângulo euclidiano em quaternions)",
                                    "Ignorar bias sistemático em ruído"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat simulando órbita LEO, capture vetores de 4 estrelas (Sirius, Vega, etc.) no body frame com ruído 1 arcmin. Aplique QUEST para estimar DCM, corrigindo desvio de 5° da atitude verdadeira; valide rotacionando o modelo 3D do satélite.",
                              "finalVerifications": [
                                "Implementar QUEST e STAR convergindo para erro <0.5° RMS com 3 estrelas ruidosas.",
                                "Código executa em <1ms por chamada para aplicações em tempo real.",
                                "Relatório documenta derivação, código e análise de 100 simulações Monte Carlo.",
                                "Comparar resultados com biblioteca padrão (ex: Poliastro ou Orekit).",
                                "Identificar e mitigar 3 erros comuns em cenários de baixa observabilidade.",
                                "Visualizar convergência STAR em gráfico iterativo."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro de atitude médio <1 arcmin com dados nominais.",
                                "Robustez: Taxa de sucesso >95% em ruído até 5 arcmin e 2 estrelas.",
                                "Eficiência: Tempo computacional <10ms em hardware embarcado simulado.",
                                "Correção matemática: Derivações validadas contra referências originais.",
                                "Qualidade de código: Testes unitários >80% cobertura, documentação inline.",
                                "Análise: Gráficos de sensibilidade e discussão de limitações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição em autovalores e quaternions.",
                                "Programação Numérica: Otimização vetorial e simulações Monte Carlo.",
                                "Probabilidade e Estatística: Modelos de ruído gaussiano e máxima verossimilhança.",
                                "Física Orbital: Cinemática de rotação em mecânica celeste.",
                                "Engenharia de Software: Testes unitários e validação em sistemas embarcados."
                              ],
                              "realWorldApplication": "Esses algoritmos são essenciais em satélites como o Hubble Space Telescope e CubeSats da NASA para orientação autônoma precisa, permitindo imagens estáveis e correções de apontamento em missões de observação astronômica e Terra."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Tratar modo Lost-in-Space (LIS)",
                            "description": "Resolver aquisição inicial de atitude quando a orientação inicial é desconhecida, utilizando busca exaustiva ou triangulação de triângulos estelares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema Lost-in-Space (LIS) e Preparar Catálogo Estelar",
                                  "subSteps": [
                                    "Estude a definição de modo LIS: perda completa de orientação inicial em veículos espaciais.",
                                    "Analise imagens de sensores de estrelas (star trackers) e identifique características de detecção de estrelas (centroiding).",
                                    "Construa ou carregue um catálogo estelar limitado (ex: 100-500 estrelas brilhantes com posições RA/DEC).",
                                    "Implemente pré-processamento de imagem: remoção de ruído e detecção de candidatos a estrelas.",
                                    "Filtre candidatos usando magnitude e separação angular mínima."
                                  ],
                                  "verification": "Catálogo carregado corretamente e pelo menos 5 estrelas detectadas em uma imagem de teste com precisão < 1 pixel.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Catálogo estelar (Bright Star Catalogue ou Hipparcos)",
                                    "Software de processamento de imagem (MATLAB, Python com OpenCV/AstroPy)",
                                    "Imagens simuladas de star trackers"
                                  ],
                                  "tips": "Use catálogos reais para autenticidade; visualize detecções com plots para depuração.",
                                  "learningObjective": "Entender o contexto LIS e preparar dados de entrada padronizados para aquisição de atitude.",
                                  "commonMistakes": [
                                    "Ignorar ruído cósmico ou flares estelares",
                                    "Usar catálogo muito grande inicialmente (aumenta tempo de busca)",
                                    "Erro em coordenadas equatoriais (RA/DEC)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Busca Exaustiva para Aquisição LIS",
                                  "subSteps": [
                                    "Gere todas as combinações possíveis de estrelas observadas vs. catálogo (brute-force matching).",
                                    "Para cada combinação, calcule ângulos angulares observados e compare com catálogo.",
                                    "Use métrica de similaridade (ex: soma de diferenças angulares quadradas).",
                                    "Determine quaternion de atitude candidato via solução de Wahba ou TRIAD para cada match.",
                                    "Selecione o melhor candidato baseado em threshold de erro angular.",
                                    "verification]: "
                                  ],
                                  "verification": "Busca exaustiva resolve LIS em simulação com < 5 graus de erro em 90% dos casos, tempo < 10s para 10 estrelas.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Código Python/MATLAB para quaternions (PyQuaternion ou Aerospace Toolbox)",
                                    "Simulador de star tracker (ex: STK ou custom Monte Carlo)"
                                  ],
                                  "tips": "Otimize com pyramid algorithm para reduzir combinações; teste com ruído gaussiano.",
                                  "learningObjective": "Dominar algoritmo básico de aquisição LIS via matching exaustivo.",
                                  "commonMistakes": [
                                    "Não normalizar vetores unitários",
                                    "Overflow em loops aninhados para >8 estrelas",
                                    "Ignorar ordem de estrelas (permutações)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Triangulação de Triângulos Estelares para LIS Eficiente",
                                  "subSteps": [
                                    "Construa grafo de triângulos do catálogo: todos os triângulos únicos de 3 estrelas dentro de FOV do sensor.",
                                    "Para estrelas observadas, gere triângulos observados e busque matches no grafo pré-computado.",
                                    "Calcule quaternions para cada match triangular usando K-nearest neighbors.",
                                    "Votação ou clustering para resolver ambiguidades múltiplas.",
                                    "Refine com estrelas adicionais para validar solução.",
                                    "verification: "
                                  ],
                                  "verification": "Algoritmo triangular resolve LIS 20x mais rápido que exaustivo, com erro < 3 graus em simulações.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Biblioteca de grafos (NetworkX Python)",
                                    "Catálogo triangular pré-computado (gerar com script)"
                                  ],
                                  "tips": "Pré-compute triângulos offline; use hash tables para lookup rápido.",
                                  "learningObjective": "Aplicar geometria computacional para otimizar aquisição LIS.",
                                  "commonMistakes": [
                                    "Triângulos degenerados (colineares)",
                                    "Falsos positivos por triângulos isomorfos",
                                    "Não escalar por magnitude"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, Testar e Validar Solução LIS Completa",
                                  "subSteps": [
                                    "Integre busca exaustiva como fallback e triangular como primária.",
                                    "Simule cenários reais: tumbling, partial FOV, nuvens de estrelas densas.",
                                    "Meça métricas: taxa de sucesso, tempo de convergência, precisão de atitude.",
                                    "Implemente fusão com sensores inerciais (Kalman filter básico).",
                                    "Documente pipeline e gere relatório de performance."
                                  ],
                                  "verification": "Sistema LIS completo atinge >95% sucesso em 100 simulações variadas, com atitude precisa a 1 grau RMS.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Simulador completo (ex: MATLAB Aerospace Blockset ou Orekit)",
                                    "Ferramentas de plot (Matplotlib)"
                                  ],
                                  "tips": "Use Monte Carlo com variações de ruído e rotação; compare com benchmarks publicados.",
                                  "learningObjective": "Construir e validar um sistema robusto de aquisição LIS.",
                                  "commonMistakes": [
                                    "Sobreajuste a cenários ideais",
                                    "Esquecer validação cruzada com estrelas extras",
                                    "Ignorar consumo computacional embarcado"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat perdido após separação orbital, o star tracker captura uma imagem com 8 estrelas desconhecidas. O algoritmo LIS identifica triângulos correspondentes no catálogo Hipparcos, calcula quaternion de atitude em <1s, permitindo reinicialização do controle de atitude e apontamento para downlink.",
                              "finalVerifications": [
                                "Identificação correta de pelo menos 4 estrelas em imagem simulada LIS.",
                                "Cálculo de quaternion com erro <2 graus vs. verdade terrestre.",
                                "Tempo total de aquisição <5s em hardware embarcado simulado.",
                                "Robustez a 20% de falsos positivos em detecção.",
                                "Validação cruzada com vetor inercial (giros)",
                                "Relatório gerado com métricas estatísticas de 50 runs."
                              ],
                              "assessmentCriteria": [
                                "Precisão da atitude determinada (RMS error <1 grau).",
                                "Eficiência computacional (tempo <10s para 12 estrelas).",
                                "Taxa de sucesso (>95% em cenários variados).",
                                "Robustez a ruído e obstruções (sucesso >90% com 30% ruído).",
                                "Qualidade do código (modular, comentado, testes unitários).",
                                "Análise de trade-offs (exaustivo vs. triangular)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria esférica, quaternions, otimização combinatorial.",
                                "Programação: Algoritmos de grafos, processamento de imagens, simulações Monte Carlo.",
                                "Física: Óptica astronômica, dinâmica orbital.",
                                "Engenharia de Software: Pipelines modulares, validação embarcada.",
                                "Estatística: Análise de erro, filtros de Kalman."
                              ],
                              "realWorldApplication": "Usado em missões como James Webb Space Telescope para aquisição inicial de atitude, CubeSats da NASA (ex: MarCO), e constelações comerciais como Starlink para recuperação autônoma após falhas de giroscópio, garantindo apontamento preciso para comunicações e ciência."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Sensores Inerciais",
                        "description": "Funcionamento de giroscópios e acelerômetros inerciais para medição de taxas angulares e acelerações lineares, com ênfase na propagação de atitude em curto prazo.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Calcular taxas angulares com giroscópios",
                            "description": "Interpretar sinais de giroscópios de estado sólido (RLG ou FOG) para obter vetor de velocidade angular em coordenadas do corpo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Princípios de Funcionamento de Giroscópios RLG e FOG",
                                  "subSteps": [
                                    "Estudar o efeito Sagnac, base para RLG e FOG, onde a diferença de fase entre feixes de luz contrarrotativos é proporcional à taxa angular.",
                                    "Diferenciar RLG (giroscópio laser em anel) de FOG (giroscópio de fibra ótica), focando em vantagens como ausência de partes móveis.",
                                    "Identificar os três eixos ortogonais de medição (roll, pitch, yaw) e suas coordenadas no referencial do corpo.",
                                    "Aprender unidades de saída típicas: volts, frequência (Hz) ou digital (bits) proporcionais a °/s ou rad/s.",
                                    "Explorar diagramas esquemáticos de sinal de saída vs. taxa angular."
                                  ],
                                  "verification": "Criar um diagrama anotado explicando o efeito Sagnac e eixos de sensibilidade, sem erros conceituais.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Datasheets de RLG (ex: Honeywell GG1320) e FOG (ex: KVH DSP-1750)",
                                    "Vídeos tutoriais sobre giroscópios inerciais (YouTube/Khan Academy)",
                                    "Livro 'Strapdown Inertial Navigation' de Titterton"
                                  ],
                                  "tips": "Use analogias como 'interferômetro rotativo' para visualizar o efeito Sagnac.",
                                  "learningObjective": "Compreender os princípios físicos que permitem medir vetor de velocidade angular com giroscópios de estado sólido.",
                                  "commonMistakes": "Confundir giroscópios com acelerômetros (taxa angular vs. aceleração linear); ignorar deriva de bias em repouso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adquirir e Interpretar Sinais Brutos dos Giroscópios",
                                  "subSteps": [
                                    "Conectar ou simular interface de dados (ADC, serial como RS-422 ou CAN) para ler sinais de cada eixo.",
                                    "Converter sinal bruto (tensão/frequência) em taxa angular usando fator de escala do datasheet (ex: 1V = 100°/s).",
                                    "Filtrar ruído inicial com filtro passa-baixa simples (média móvel ou Butterworth).",
                                    "Mapear sinais para componentes do vetor: ω_x (roll), ω_y (pitch), ω_z (yaw) no body frame.",
                                    "Plotar sinais em tempo real para visualizar resposta a rotações conhecidas."
                                  ],
                                  "verification": "Gerar gráfico de ω vs. tempo para uma rotação de 90°/s, confirmando linearidade e ausência de offset excessivo.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Software MATLAB/Python com bibliotecas (scipy.signal, matplotlib)",
                                    "Simulador de dados inerciais (ex: X-Plane ou custom script)",
                                    "IMU de teste como MPU-6050 para prática inicial"
                                  ],
                                  "tips": "Sempre normalize dados para rad/s para consistência em simulações aeroespaciais.",
                                  "learningObjective": "Interpretar sinais raw de giroscópios e convertê-los em componentes iniciais de velocidade angular.",
                                  "commonMistakes": "Não converter unidades corretamente (ex: confundir °/s com rad/s); ignorar alinhamento de eixos com body frame."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Calibração e Compensações",
                                  "subSteps": [
                                    "Medir e subtrair bias (offset em zero taxa) usando teste estático (média de 1000 amostras em repouso).",
                                    "Calcular fator de escala com rotações conhecidas em bancada de taxa (rate table).",
                                    "Compensar cross-coupling e não-linearidades com modelo polinomial ou lookup table.",
                                    "Corrigir misalignments (erros de ortogonalidade entre eixos) via matriz de calibração.",
                                    "Implementar compensação de temperatura usando sensores integrados e coeficientes do fabricante."
                                  ],
                                  "verification": "Comparar vetor calibrado com valores conhecidos de uma rotação controlada; erro < 0.1°/s.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Script Python/MATLAB para calibração Allan variance",
                                    "Bancada de teste rotacional ou simulador (Gazebo ROS)",
                                    "Datasheet com matrizes de calibração"
                                  ],
                                  "tips": "Use variância de Allan para quantificar bias instability e random walk.",
                                  "learningObjective": "Calibrar giroscópios para precisão, removendo erros sistemáticos e aleatórios.",
                                  "commonMistakes": "Subestimar efeitos de temperatura; aplicar calibração estática sem dinâmica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e Validar o Vetor de Velocidade Angular no Body Frame",
                                  "subSteps": [
                                    "Combinar componentes calibrados em vetor ω = [ω_x, ω_y, ω_z]^T no referencial do corpo.",
                                    "Integrar numericamente para estimar ângulos de Euler/Quaternion (para validação cruzada).",
                                    "Validar contra sensores complementares (ex: estrelas ou magnetômetro) em loop de fusão.",
                                    "Implementar detecção de falhas (ex: limites de taxa > 500°/s indicam saturação).",
                                    "Exportar vetor para simulação de dinâmica de atitude (ex: entrada para EKF)."
                                  ],
                                  "verification": "Simular manobra completa; erro de atitude acumulada < 1° após 10 minutos.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "MATLAB Aerospace Toolbox ou Python (numpy, scipy.integrate)",
                                    "Dados reais de missão (ex: NASA open datasets)",
                                    "Ferramenta de fusão como Madgwick filter"
                                  ],
                                  "tips": "Evite deriva integrando apenas para curtos períodos; prefira strapdown vs. gimbaled.",
                                  "learningObjective": "Gerar vetor de velocidade angular preciso e utilizável em sistemas de controle de atitude.",
                                  "commonMistakes": "Erro no referencial (confundir body com inertial); acumular erros sem reset periódico."
                                }
                              ],
                              "practicalExample": "Em um CubeSat simulando rotação de 2°/s ao redor do eixo Z (yaw), leia sinais de um FOG: Vx=0V, Vy=0V, Vz=0.02V (escala 1V=100°/s). Calibre bias (-0.001V), aplique escala → ω_z=2°/s, monte vetor [0,0,0.035 rad/s], valide integrando para 36° em 18s contra dados de estrelas.",
                              "finalVerifications": [
                                "Vetor ω tem magnitude e direção consistentes com manobras conhecidas (erro <0.05°/s).",
                                "Calibração reduz bias para <0.01°/h e escala para 0.1% precisão.",
                                "Ausência de cross-coupling (>99% ortogonalidade).",
                                "Resposta em tempo real <10ms latência em simulação.",
                                "Validação cruzada com IMU complementar mostra concordância >95%.",
                                "Detecção de anomalias (saturação/ruído) ativa alertas corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão do vetor ω: erro RMS <0.1°/s em testes dinâmicos.",
                                "Correta implementação de calibração (bias, scale, misalignment).",
                                "Uso apropriado do body frame sem confusão com coordenadas inerciais.",
                                "Eficiência computacional: processamento <1ms por amostra em embedded.",
                                "Documentação clara de código e resultados com plots.",
                                "Capacidade de depuração de erros comuns como deriva térmica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rotação, vetores) e análise de sinais (filtros, variância de Allan).",
                                "Física: Mecânica rotacional e óptica (efeito Sagnac, interferometria).",
                                "Engenharia Elétrica: Aquisição de dados (ADC, interfaces seriais) e calibração de sensores.",
                                "Programação: Processamento numérico (Python/MATLAB) e simulações (ROS/Gazebo).",
                                "Controle de Sistemas: Integração em EKF/UKF para navegação inercial."
                              ],
                              "realWorldApplication": "Em satélites como o James Webb Space Telescope ou CubeSats da NASA, giroscópios RLG/FOG calculam taxas angulares para controle preciso de atitude, permitindo apontamento de antenas/câmeras com arco-segundo de precisão durante órbitas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Integrar sinais inerciais para propagação de atitude",
                            "description": "Realizar integração numérica (Euler ou Runge-Kutta) de taxas angulares para propagar quaternions ou matrizes de atitude ao longo do tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Representação de Atitude e Sinais Inerciais",
                                  "subSteps": [
                                    "Estudar quaternions unitários e matrizes de direção como representações de atitude.",
                                    "Aprender sobre taxas angulares (ω) medidas por giroscópios inerciais.",
                                    "Derivar a equação diferencial de propagação: ḣ = (1/2) q ⊗ ω (para quaternions).",
                                    "Entender a necessidade de integração numérica devido à ausência de solução analítica simples.",
                                    "Explorar normalização de quaternions para manter |q| = 1."
                                  ],
                                  "verification": "Escrever e derivar corretamente as equações em um caderno ou documento, confirmando com referências padrão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Spacecraft Attitude Determination and Control' (Wertz), notas de dinâmica orbital, calculadora simbólica como SymPy."
                                  ],
                                  "tips": "Use a convenção quaternion escalar-primeiro para simplificar multiplicações.",
                                  "learningObjective": "Dominar as equações cinemáticas de atitude e sua representação matemática.",
                                  "commonMistakes": [
                                    "Confundir taxa angular com aceleração angular.",
                                    "Esquecer o fator 1/2 na equação de propagação.",
                                    "Não normalizar quaternions após integração."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Analisar Métodos de Integração Numérica",
                                  "subSteps": [
                                    "Comparar método de Euler forward (simples, baixo custo) com Runge-Kutta ordem 4 (mais preciso).",
                                    "Implementar Euler em papel para um exemplo simples com ω constante.",
                                    "Calcular erro local e global para cada método usando análise teórica.",
                                    "Determinar passo de tempo dt adequado baseado na taxa de amostragem do giroscópio (ex: 100 Hz).",
                                    "Estudar tratamento de ruído nos sinais inerciais."
                                  ],
                                  "verification": "Resolver numericamente um exemplo manual e comparar com solução exata, com erro < 5%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para simulações iniciais.",
                                    "Documentação de métodos numéricos (ex: Burden & Faires)."
                                  ],
                                  "tips": "Comece com Euler para protótipo rápido, migre para RK4 para precisão em simulações longas.",
                                  "learningObjective": "Escolher método de integração apropriado para precisão e eficiência computacional.",
                                  "commonMistakes": [
                                    "Passo de tempo dt muito grande causando instabilidade.",
                                    "Ignorar ordem de multiplicação em quaternions (não comutativos).",
                                    "Não considerar bias do giroscópio."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Integração Numérica em Software",
                                  "subSteps": [
                                    "Configurar ambiente de programação com bibliotecas (NumPy/SciPy para Python ou MATLAB).",
                                    "Codificar função de propagação para quaternions usando Euler ou RK4.",
                                    "Implementar loop temporal: ler ω(t), integrar, normalizar q.",
                                    "Adicionar visualização de atitude (gráficos de Euler angles ou quaternion components).",
                                    "Testar com dados sintéticos de ω (ex: rotação constante)."
                                  ],
                                  "verification": "Executar código e verificar que quaternions permanecem unitários (norma ≈1) após 1000 passos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy, SciPy, Matplotlib; ou MATLAB; dados de teste de giroscópio simulados."
                                  ],
                                  "tips": "Use funções vetorizadas para eficiência; normalize a cada passo para evitar drift numérico.",
                                  "learningObjective": "Desenvolver código funcional para propagação de atitude em tempo discreto.",
                                  "commonMistakes": [
                                    "Índices errados em arrays de tempo.",
                                    "Conversão incorreta de ω body para inercial.",
                                    "Sobrecarga de memória em simulações longas sem vetorização."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar a Propagação de Atitude",
                                  "subSteps": [
                                    "Comparar propagação com solução conhecida (ex: rotação constante tem solução analítica).",
                                    "Adicionar ruído gaussiano a ω e analisar drift de atitude.",
                                    "Implementar métricas de erro (desvio angular RMS).",
                                    "Otimizar dt e método para minimizar erro em 10 minutos de simulação.",
                                    "Documentar código com comentários e gerar relatório de resultados."
                                  ],
                                  "verification": "Erro de atitude < 0.1° após 600s de simulação com ruído realista.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Dados reais de giroscópio (ex: datasets NASA ou simulados com bias/ruído)."
                                  ],
                                  "tips": "Use Monte Carlo para estatísticas de erro; compare com filtros como EKFs para benchmark.",
                                  "learningObjective": "Garantir robustez da implementação contra ruído e erros reais.",
                                  "commonMistakes": [
                                    "Não subtrair bias do giroscópio.",
                                    "Ignorar acumulação de erro em longas simulações.",
                                    "Visualizações enganosas sem unwrap de ângulos."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita baixa executando uma manobra de 90° em 300s. Use dados de giroscópio com ruído (σ=0.01°/s) e bias (0.005°/s). Propague quaternion inicial [1,0,0,0] usando RK4 com dt=0.01s, visualize ângulos de Euler e verifique convergência para atitude final esperada.",
                              "finalVerifications": [
                                "Norma do quaternion permanece unitária (|q| = 1 ± 1e-10) em todos os timesteps.",
                                "Propagação com ω=0 mantém atitude constante.",
                                "Erro RMS de atitude < 0.05° em simulação de 10min com ruído baixo.",
                                "Transição suave para método analítico em casos constantes.",
                                "Código executa em <1s para 1h de dados (eficiência).",
                                "Gráficos mostram ausência de gimbal lock ou singularidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro de propagação <1% vs referência em 30min.",
                                "Robustez: Desempenho estável com ruído/bias realista.",
                                "Eficiência: Tempo de computação < dt real-time factor 10.",
                                "Documentação: Código comentado e relatório com análise de erros.",
                                "Flexibilidade: Fácil troca entre Euler/RK4 e quaternion/matriz.",
                                "Validação: Múltiplos testes com métricas quantitativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução numérica de EDOs não-lineares (Runge-Kutta).",
                                "Programação: Vetorização e otimização em Python/MATLAB.",
                                "Física: Cinemática e dinâmica rotacional de corpos rígidos.",
                                "Engenharia de Controle: Integração em ADCS com filtros Kalman.",
                                "Estatística: Modelagem e mitigação de ruído em sensores."
                              ],
                              "realWorldApplication": "Em sistemas ADCS de satélites como o CubeSat ou estações espaciais, integra sinais de giroscópios para propagar atitude entre observações de estrelas, essencial durante eclipses ou manobras rápidas onde sensores ópticos falham."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Compensar erros inerciais como bias e drift",
                            "description": "Modelar e corrigir erros sistemáticos em sensores inerciais, incluindo calibração inicial e modelagem de ruído aleatório.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Tipos de Erros em Sensores Inerciais",
                                  "subSteps": [
                                    "Estude definições de bias (erro constante), drift (variação temporal sistemática) e ruído aleatório em acelerômetros e giroscópios.",
                                    "Analise diagramas de erros típicos de IMUs (Inertial Measurement Units).",
                                    "Colete dados de sensores reais ou simulados para identificar padrões de erro.",
                                    "Compare erros determinísticos vs. estocásticos usando gráficos.",
                                    "Revise literatura sobre modelos matemáticos de erros inerciais."
                                  ],
                                  "verification": "Crie um relatório resumindo os três tipos de erros com exemplos gráficos de dados reais/simulados.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação de IMUs (ex: datasheet Bosch BMI088), Python com Matplotlib e NumPy, dados de sensores públicos (ex: dataset Kaggle IMU).",
                                  "tips": "Use plots de tempo para visualizar drift claramente; normalize dados antes de análise.",
                                  "learningObjective": "Identificar e diferenciar bias, drift e ruído em sensores inerciais.",
                                  "commonMistakes": [
                                    "Confundir bias com ruído (bias é DC offset), ignorar temperatura como causa de drift, não considerar alinhamento do sensor."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Calibração Inicial dos Sensores",
                                  "subSteps": [
                                    "Posicione o sensor em 6 posições ortogonais estáticas para bias de acelerômetro.",
                                    "Registre dados em repouso por 10-15 minutos para capturar drift de giroscópio.",
                                    "Aplique método de mínimos quadrados para estimar bias médio.",
                                    "Salve parâmetros de calibração em um arquivo de configuração.",
                                    "Teste calibração rotacionando o sensor lentamente e verificando saídas esperadas."
                                  ],
                                  "verification": "Gere plots before/after calibração mostrando redução de bias para <0.01 g em acelerômetro.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Hardware IMU (ex: Arduino + MPU6050), Python/SciPy para least-squares, plataforma de teste rotativa.",
                                  "tips": "Mantenha temperatura constante durante testes; use múltiplas amostras (1000+) por posição.",
                                  "learningObjective": "Executar calibração estática para remover bias inicial em sensores inerciais.",
                                  "commonMistakes": [
                                    "Poucas amostras levando a estimativas ruidosas, não compensar gravidade em posições não-niveladas, ignorar vibrações ambientais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar Bias, Drift e Ruído Aleatório",
                                  "subSteps": [
                                    "Desenvolva modelo ARIMA ou polinomial para drift temporal.",
                                    "Estime covariância de ruído usando análise Allan Variance.",
                                    "Implemente modelo de erro: output = true + bias + drift(t) + noise.",
                                    "Ajuste parâmetros via otimização (ex: Kalman filter tuning).",
                                    "Valide modelo simulando dados sintéticos e comparando com reais."
                                  ],
                                  "verification": "Compare RMSE entre dados reais e modelo predito de erros (<5% erro).",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB ou Python (SciPy, PyKalman), Allan Variance toolbox, dados longos de IMU (>1 hora).",
                                  "tips": "Use log-log plots para Allan Variance; modele drift como linear + quadrático inicialmente.",
                                  "learningObjective": "Criar modelo matemático preciso para erros sistemáticos e aleatórios.",
                                  "commonMistakes": [
                                    "Sobreamostragem sem anti-aliasing, assumir drift linear quando é não-linear, não validar com dados independentes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Compensação de Erros",
                                  "subSteps": [
                                    "Integre modelo de erro em um filtro complementar ou EKF (Extended Kalman Filter).",
                                    "Aplique correções em tempo real: subtraia bias/drift estimado das leituras raw.",
                                    "Inclua modelagem de ruído no filtro para fusão com sensores de estrelas.",
                                    "Otimize parâmetros para minimizar divergência em simulações longas.",
                                    "Implemente rotina de rec calibração dinâmica a cada 10 minutos."
                                  ],
                                  "verification": "Execute simulação de atitude por 1 hora; verifique erro de atitude <1 grau.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python (FilterPy ou custom EKF), simulador de dinâmica de atitude (ex: JSBSim), dados de sensores de estrelas simulados.",
                                  "tips": "Inicialize filtro com calibração estática; monitore covariância para detecção de falhas.",
                                  "learningObjective": "Desenvolver algoritmo de compensação em tempo real para erros inerciais.",
                                  "commonMistakes": [
                                    "Falta de inicialização adequada do filtro causando divergência, ignorar correlações entre eixos, sobrecarga computacional em embedded."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Testar a Compensação Completa",
                                  "subSteps": [
                                    "Simule manobras de veículo espacial com erros injetados.",
                                    "Compare atitude estimada com verdade-ground (GPS/IMU fusion).",
                                    "Analise métricas: bias residual, taxa de drift, SNR pós-compensação.",
                                    "Teste em hardware real com rotação controlada.",
                                    "Documente limitações e sugestões de melhoria."
                                  ],
                                  "verification": "Relatório com métricas: redução de bias >90%, drift <0.01°/h.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Simulador aeroespacial (ex: MATLAB Aerospace Toolbox), hardware de teste, osciloscópio para validação.",
                                  "tips": "Use Monte Carlo simulations para robustez; teste em faixas de temperatura.",
                                  "learningObjective": "Avaliar eficácia da compensação em cenários realistas.",
                                  "commonMistakes": [
                                    "Testes só em condições ideais, não quantificar incertezas, ignorar latência de processamento."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um cubsat, use dados do giroscópio MPU-9250 para compensar drift de 0.5°/h durante órbita, fusionando com sensor de estrelas para manter atitude precisa em <0.1° após 30 minutos, evitando perda de lock em alvos terrestres.",
                              "finalVerifications": [
                                "Bias residual <0.005 g em acelerômetro e <0.01°/s em giroscópio.",
                                "Drift compensado para <0.001°/h em testes de 1 hora.",
                                "Ruído reduzido em 50% via SNR em análise de frequência.",
                                "Erro de atitude integrado <0.5° em simulação de manobra.",
                                "Recalibração dinâmica converge em <30s.",
                                "Sistema roda em tempo real a 100Hz sem sobrecarga."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo de erro (RMSE <5%).",
                                "Eficiência da compensação (redução >85% em métricas de erro).",
                                "Robustez a variações (temperatura, vibração).",
                                "Clareza da implementação e documentação.",
                                "Validação quantitativa com métricas padronizadas.",
                                "Integração com fusão de sensores externos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística (Allan Variance), Otimização (Mínimos Quadrados), Filtros Estocásticos (Kalman).",
                                "Programação: Implementação numérica em Python/MATLAB, Processamento em Tempo Real.",
                                "Física: Dinâmica Newtoniana, Cinemática de Rotação.",
                                "Engenharia de Controle: Fusão Sensorial, Estabilidade de Sistemas."
                              ],
                              "realWorldApplication": "Em satélites como o CubeSat da NASA, compensação de erros inerciais garante determinação precisa de atitude para comunicações e imageamento terrestre, evitando bilhões em perdas por desalinhamento orbital."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.4",
                            "name": "Combinar acelerômetros para estimativa de posição",
                            "description": "Usar dupla integração de acelerações para estimar variações de velocidade e posição, reconhecendo limitações devido ao acúmulo de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Princípios de Acelerômetros e Integração Numérica",
                                  "subSteps": [
                                    "Estude o funcionamento de acelerômetros: medem aceleração linear em 3 eixos (x, y, z).",
                                    "Revise conceitos de integração numérica: método trapezoidal ou de Euler para discretizar integrais.",
                                    "Aprenda a relação física: velocidade = ∫ aceleração dt; posição = ∫ velocidade dt.",
                                    "Identifique fontes de ruído e bias em dados de acelerômetros reais.",
                                    "Pratique com dados sintéticos de aceleração constante para validar integração básica."
                                  ],
                                  "verification": "Resolva um exercício simples onde integra aceleração constante e compara com valores analíticos esperados.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de dinâmica (ex: Ogata), Python/MATLAB com NumPy/SciPy, tutoriais online sobre IMU.",
                                  "tips": "Sempre subtraia a aceleração da gravidade (g) para obter aceleração relativa.",
                                  "learningObjective": "Compreender como acelerômetros fornecem dados brutos e por que a integração numérica é necessária para derivar velocidade e posição.",
                                  "commonMistakes": "Ignorar o bias DC do sensor ou confundir aceleração própria com gravidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Integração Simples: Aceleração para Velocidade",
                                  "subSteps": [
                                    "Colete ou gere dados de aceleração de um acelerômetro simulado (ex: senoide).",
                                    "Aplique filtro passa-baixa para remover ruído de alta frequência.",
                                    "Implemente integração numérica usando método trapezoidal em código.",
                                    "Inicialize velocidade em zero e plote velocidade vs. tempo.",
                                    "Valide com movimento conhecido (ex: aceleração constante de 1 m/s² por 10s)."
                                  ],
                                  "verification": "Gráfico da velocidade deve coincidir com solução analítica dentro de 5% de erro.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com bibliotecas pandas, matplotlib, scipy.integrate; dados de acelerômetro de dataset público (ex: Kaggle IMU).",
                                  "tips": "Use taxa de amostragem alta (≥100 Hz) para minimizar erro de discretização.",
                                  "learningObjective": "Desenvolver código para converter dados de aceleração em estimativas de velocidade via integração única.",
                                  "commonMistakes": "Não resetar velocidade inicial ou usar integração sem remover offset de gravidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Dupla Integração: Velocidade para Posição",
                                  "subSteps": [
                                    "Use saída da Step 2 como entrada para segunda integração.",
                                    "Implemente dupla integração sequencial no mesmo script.",
                                    "Plote trajetória de posição em 2D/3D e compare com trajetória conhecida.",
                                    "Ajuste parâmetros de filtro (ex: cutoff frequency) para otimizar precisão.",
                                    "Teste com movimento circular ou parabólico simulado."
                                  ],
                                  "verification": "Trajetória estimada deve fechar o loop (retornar à origem) com erro <10% em simulações curtas.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Mesmos da Step 2 + software de visualização 3D (ex: Plotly).",
                                  "tips": "Monitore drift: erro cresce quadraticamente com tempo devido a ruído.",
                                  "learningObjective": "Estimar posição via dupla integração e observar acúmulo inicial de erros.",
                                  "commonMistakes": "Integração dupla sem filtragem leva a divergência explosiva."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Limitações e Mitigações de Erros",
                                  "subSteps": [
                                    "Simule ruído gaussiano e bias em dados de entrada e quantifique drift.",
                                    "Calcule erro médio quadrático (RMSE) para posição vs. tempo.",
                                    "Explore mitigações: fusão com GPS (Kalman filter básico) ou reset periódico.",
                                    "Compare desempenho em janelas curtas vs. longas.",
                                    "Documente limitações: inadequado para navegação autônoma sem correções."
                                  ],
                                  "verification": "Relatório com gráficos de erro mostrando crescimento quadrático e redução com filtro Kalman simples.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com filterpy (para Kalman), Jupyter Notebook para relatórios.",
                                  "tips": "Use high-pass filter para remover bias de baixa frequência após integração.",
                                  "learningObjective": "Reconhecer e quantificar o acúmulo de erros na dupla integração, identificando cenários de uso limitados.",
                                  "commonMistakes": "Subestimar impacto do ruído: teste com níveis realistas (0.01-0.1 m/s²)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em Simulação de Veículo Espacial",
                                  "subSteps": [
                                    "Integre com modelo de dinâmica de atitude (quaternions).",
                                    "Simule manobra de espaçonave com acelerômetros em IMU.",
                                    "Estime posição relativa durante burn de thruster.",
                                    "Avalie precisão em dead reckoning curto prazo.",
                                    "Otimize código para tempo real (ex: taxa 200 Hz)."
                                  ],
                                  "verification": "Simulação completa reproduz trajetória esperada com erro <5% em 60s.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Simulador orbital (ex: Orekit, poliastro em Python), dados de missão real (ex: ISS telemetry).",
                                  "tips": "Combine com giroscópios para strapdown INS completo.",
                                  "learningObjective": "Aplicar técnica em contexto aeroespacial, integrando com outros sensores inerciais.",
                                  "commonMistakes": "Esquecer rotação da frame do sensor para frame inercial."
                                }
                              ],
                              "practicalExample": "Em uma simulação de drone quadrotor, use dados de acelerômetros da IMU para estimar posição durante voo estacionário: dupla integração revela drift de 0.5m após 30s, necessitando fusão com GPS para correção.",
                              "finalVerifications": [
                                "Código implementa dupla integração corretamente com filtros anti-drift.",
                                "Gráficos mostram velocidade e posição consistentes com inputs conhecidos.",
                                "Análise de erro quantifica drift quadrático (RMSE posição ~ t²).",
                                "Relatório discute limitações e mitigações (ex: Kalman filter).",
                                "Simulação aeroespacial roda sem erros e valida precisão relativa.",
                                "Teste com dados reais de IMU (ex: smartphone) reproduz resultados esperados."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação numérica (erro <5% em validações).",
                                "Compreensão de erros: explicação correta do drift por dupla integração.",
                                "Qualidade do código: modular, comentado, eficiente.",
                                "Análise quantitativa: uso de métricas como RMSE e gráficos claros.",
                                "Aplicação contextual: integração com dinâmica de veículos espaciais.",
                                "Criatividade em mitigações: proposta viável além do básico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo numérico e análise de erros em integrais discretas.",
                                "Física: Cinemática newtoniana e dinâmica de partículas rígidas.",
                                "Programação: Processamento de sinais em tempo real com Python/MATLAB.",
                                "Engenharia de Controle: Fundamentos de filtros Kalman para fusão sensorial.",
                                "Estatística: Modelagem de ruído gaussiano e análise de variância."
                              ],
                              "realWorldApplication": "Em espaçonaves como o Mars Rover ou satélites CubeSat, acelerômetros combinados via dupla integração fornecem navegação dead reckoning de curto prazo durante blackouts de GPS, corrigidos por estrelas ou landmarks, essencial para manobras autônomas em órbita."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Integração de Sensores para Determinação Precisa",
                        "description": "Fusão de dados de sensores de estrelas e inerciais para determinação de atitude robusta, utilizando filtros para combinar medições absolutas e relativas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Implementar filtro complementar",
                            "description": "Desenvolver estrutura de filtro complementar onde estrelas fornecem atitude absoluta e inerciais propagam entre atualizações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Modelos Matemáticos de Atitude e Sensores",
                                  "subSteps": [
                                    "Estudar a cinemática de atitude usando quaternions para representar rotações.",
                                    "Modelar o sensor de estrelas como medições diretas de vetor de atitude com ruído gaussiano.",
                                    "Modelar os giroscópios inerciais como taxas angulares com bias e ruído.",
                                    "Derivar as equações de propagação da covariância de erro de atitude usando gyros.",
                                    "Definir o estado do filtro: quaternio de atitude e vetor de bias dos gyros."
                                  ],
                                  "verification": "Modelos matemáticos codificados e documentados, com equações validadas contra referências padrão como 'Spacecraft Attitude Determination and Control'.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Livros de referência (e.g., Wertz 'Spacecraft Attitude Determination'), MATLAB/Python com bibliotecas NumPy/SciPy.",
                                  "tips": "Use quaternions normalizados para evitar singularidades em matrizes de rotação.",
                                  "learningObjective": "Compreender e formalizar os modelos dinâmicos e de observação para o filtro complementar.",
                                  "commonMistakes": "Confundir representação de atitude (Euler vs. quaternions) ou ignorar normalização do quaternio."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Propagação de Estado e Covariância (Time Update)",
                                  "subSteps": [
                                    "Implementar integração numérica das taxas angulares dos gyros para propagar o quaternio.",
                                    "Calcular a matriz de transição discreta para o estado [quaternio, bias gyros].",
                                    "Propagar a matriz de covariância P usando a equação discreta de Riccati.",
                                    "Incorporar modelo de ruído de processo para gyros (Q matrix).",
                                    "Testar propagação isolada com dados sintéticos de rotação constante."
                                  ],
                                  "verification": "Erro de atitude propagado abaixo de 1 grau após 10 minutos simulados sem updates.",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "Ambiente de programação (MATLAB/Simulink ou Python com SymPy para derivações).",
                                  "tips": "Use método de Runge-Kutta de 4ª ordem para integração precisa de taxas angulares.",
                                  "learningObjective": "Dominar a propagação temporal no filtro complementar usando sensores inerciais.",
                                  "commonMistakes": "Não processar bias dos gyros, levando a deriva linear no tempo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Correção com Medições de Estrelas (Measurement Update)",
                                  "subSteps": [
                                    "Definir a função de observação: projeção do vetor inercial medido pelo star tracker no frame do corpo.",
                                    "Calcular a matriz de observação H linearizada em torno do estado atual.",
                                    "Computar o ganho de Kalman K = P H^T (H P H^T + R)^{-1}, onde R é covariância do star tracker.",
                                    "Atualizar estado: x = x + K (z - h(x)), e covariância P = (I - K H) P.",
                                    "Resetar covariância de atitude pós-update para refletir precisão absoluta das estrelas."
                                  ],
                                  "verification": "Ganho K converge para valores esperados em simulação com ruído.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "Bibliotecas de álgebra linear (SciPy.linalg, MATLAB matrices).",
                                  "tips": "Linearize H usando aproximações de primeira ordem para eficiência computacional.",
                                  "learningObjective": "Implementar corretamente a fusão de medições absolutas com estados propagados.",
                                  "commonMistakes": "Inverter a ordem de propagação e correção, ou usar R muito pequeno causando oscilações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Loop Completo e Ajustar Parâmetros",
                                  "subSteps": [
                                    "Estruturar loop principal: propagar até próxima medição de estrela, então corrigir.",
                                    "Ajustar covariâncias iniciais P0, Q (processo), R (medição) via tuning ou simulações Monte Carlo.",
                                    "Implementar lógica de detecção de falhas (e.g., outlier rejection em star data).",
                                    "Adicionar logging de estados, erros e covariâncias para análise.",
                                    "Executar simulação end-to-end com perfil de missão realista."
                                  ],
                                  "verification": "Filtro mantém erro RMS de atitude < 0.01 graus com updates esporádicos.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Ferramentas de plotagem (Matplotlib, MATLAB plots), dados de simulação de star tracker.",
                                  "tips": "Comece com Q e R conservadores e ajuste iterativamente para evitar divergência.",
                                  "learningObjective": "Configurar e otimizar o filtro complementar para operação em loop fechado.",
                                  "commonMistakes": "Covariâncias mal tunadas levando a filtro 'lento' ou instável."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Testar o Filtro Implementado",
                                  "subSteps": [
                                    "Gerar dados de verdade (ground truth) de atitude via simulação dinâmica 6DOF.",
                                    "Executar testes com ruído realista e falhas (e.g., blackout de estrelas).",
                                    "Comparar performance com filtro de Kalman estendido como benchmark.",
                                    "Analisar convergência, steady-state error e robustez.",
                                    "Documentar resultados com gráficos de erro vs. tempo."
                                  ],
                                  "verification": "Relatório de validação com métricas quantitativas (RMSE < 0.005 graus).",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Simulador de dinâmica orbital (e.g., Orekit, GMAT), scripts de teste unitário.",
                                  "tips": "Use cenários de worst-case como manobras rápidas para testar limites.",
                                  "learningObjective": "Avaliar rigorosamente a implementação contra requisitos de precisão.",
                                  "commonMistakes": "Testar apenas com condições ideais, ignorando cenários reais de missão."
                                }
                              ],
                              "practicalExample": "Em uma simulação de satélite CubeSat em órbita LEO, use dados de giroscópios simulados com bias de 0.01 deg/s e star tracker atualizando a cada 60s. O filtro mantém atitude precisa durante uma manobra de apontamento para aquisição de imagem terrestre, corrigindo deriva inercial com resets estelares.",
                              "finalVerifications": [
                                "Erro RMS de atitude < 0.01° em steady-state.",
                                "Covariância de erro converge e permanece estável.",
                                "Filtro recupera de blackout de 5 minutos de estrelas em < 2 minutos.",
                                "Bias dos gyros é estimado com precisão < 0.005 deg/s.",
                                "Nenhum overflow ou NaN em simulações longas (>1 órbita).",
                                "Performance computacional < 1ms por ciclo em hardware embarcado simulado."
                              ],
                              "assessmentCriteria": [
                                "Precisão: RMSE de atitude ≤ 0.01° em testes padrão.",
                                "Robustez: Sobrevive a 20% de falhas em medições de estrelas.",
                                "Eficiência: Tempo de execução < 10ms/ciclo.",
                                "Correção de bias: Erro residual < 0.01% da taxa nominal.",
                                "Documentação: Código comentado com equações derivadas.",
                                "Modularidade: Funções separadas para propagate/update fáceis de testar."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de covariância), Probabilidade (filtros bayesianos).",
                                "Física: Dinâmica rotacional newtoniana e cinemática de corpos rígidos.",
                                "Programação: Algoritmos numéricos, controle de versão (Git), testes unitários.",
                                "Engenharia de Sistemas: Integração de sensores, análise de requisitos de missão."
                              ],
                              "realWorldApplication": "Usado em satélites como o Hubble Space Telescope e constelações Starlink para controle preciso de apontamento, permitindo imagens nítidas e comunicações estáveis apesar de perturbações orbitais e ruído sensorial."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Aplicar Filtro de Kalman Estendido (EKF)",
                            "description": "Configurar EKF para fusão de medições vetoriais de estrelas e taxas inerciais, linearizando o modelo não-linear de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Filtro de Kalman Linear e Introdução ao EKF",
                                  "subSteps": [
                                    "Estude o Filtro de Kalman (KF) linear: equações de predição e update.",
                                    "Identifique limitações do KF em sistemas não-lineares, como dinâmica de atitude.",
                                    "Aprenda a estrutura do EKF: linearização local via Taylor de primeira ordem.",
                                    "Revise notação: estado x, covariância P, ganho K, ruídos Q e R.",
                                    "Pratique com exemplo simples de EKF unidimensional."
                                  ],
                                  "verification": "Resolva um problema de EKF 1D manualmente e compare com simulação numérica.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Livro 'Optimal State Estimation' de Simon",
                                    "Tutoriais MATLAB sobre KF/EKF",
                                    "Notebook Jupyter com exemplos"
                                  ],
                                  "tips": "Comece com KF linear antes de não-lineares para construir confiança.",
                                  "learningObjective": "Compreender como o EKF estende o KF para modelos não-lineares.",
                                  "commonMistakes": [
                                    "Confundir Jacobianas F e H",
                                    "Ignorar normalização de quaternions"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Modelo de Estado Não-Linear para Dinâmica de Atitude",
                                  "subSteps": [
                                    "Escolha representação de atitude: quaternions para evitar singularidades.",
                                    "Defina vetor de estado: quaternions q e bias de giroscópio b.",
                                    "Escreva equação de estado: dq/dt = 1/2 * Ω(ω - b) * q + w.",
                                    "Defina modelo de medição: vetor de estrelas h(q) = A(q) * s_true.",
                                    "Especifique matrizes de ruído Q (processo) e R (medição)."
                                  ],
                                  "verification": "Implemente funções f(x,u) e h(x) em código e plote trajetórias sem filtro.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Documentação NASA sobre dinâmica de atitude",
                                    "MATLAB Aerospace Toolbox",
                                    "Python: PyQuaternion library"
                                  ],
                                  "tips": "Use quaternions unitários; normalize após cada integração.",
                                  "learningObjective": "Modelar precisamente a dinâmica não-linear de atitude com sensores inerciais e estrelas.",
                                  "commonMistakes": [
                                    "Erro na multiplicação de quaternions",
                                    "Esquecer bias nos giroscópios"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Matrizes de Jacobiana para Linearização",
                                  "subSteps": [
                                    "Calcule Jacobiana da transição de estado F = df/dx no ponto atual.",
                                    "Derive Jacobiana da medição H = dh/dx para vetores de estrelas.",
                                    "Implemente computação analítica ou numérica das Jacobianas.",
                                    "Verifique Jacobianas com diferenças finitas para validação.",
                                    "Inclua Jacobianas para bias e ruídos aditivos."
                                  ],
                                  "verification": "Compare Jacobianas analíticas e numéricas; erro < 1e-6.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": [
                                    "Paper 'Quaternion kinematics for error-state KF' de Sola",
                                    "SymPy para derivação simbólica",
                                    "Código MATLAB para validação"
                                  ],
                                  "tips": "Use sympy para derivadas simbólicas iniciais, depois código eficiente.",
                                  "learningObjective": "Dominar linearização essencial para EKF em sistemas rotacionais.",
                                  "commonMistakes": [
                                    "Sinais errados em Jacobianas de rotação",
                                    "Dimensões incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o Algoritmo EKF Completo",
                                  "subSteps": [
                                    "Codifique passo de predição: x_pred = f(x_est, u), P_pred = F P F^T + Q.",
                                    "Implemente passo de update: K = P_pred H^T (H P_pred H^T + R)^-1, etc.",
                                    "Integre com simulação discreta: use RK4 para propagação.",
                                    "Adicione inicialização: estado inicial e covariância P0.",
                                    "Teste em loop fechado com dados simulados de estrelas e IMU."
                                  ],
                                  "verification": "Execute 1000 passos; plote erro de atitude vs tempo.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": [
                                    "GitHub repos de EKF para attitude (ex: pyEKF)",
                                    "MATLAB/Simulink para simulação espacial",
                                    "Dados sintéticos de estrelas (catalog CATSTAR)"
                                  ],
                                  "tips": "Use fatorização de Cholesky para P estável numericamente.",
                                  "learningObjective": "Implementar EKF funcional para fusão de sensores vetoriais e inerciais.",
                                  "commonMistakes": [
                                    "Inversão instável de matrizes",
                                    "Não resetar covariância após update"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simular, Tunar e Validar o EKF",
                                  "subSteps": [
                                    "Gere dados reais: simule movimento de satélite com ruído.",
                                    "Tune covariâncias Q e R via trial-error ou otimização.",
                                    "Analise convergência: trace de P, resíduos de inovação.",
                                    "Compare com verdade do solo e EKF multiplicativo.",
                                    "Teste robustez: adicione falhas de sensor."
                                  ],
                                  "verification": "Erro RMS de atitude < 0.1 graus após convergência.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": [
                                    "Ferramenta STK para simulação orbital",
                                    "Python: FilterPy library",
                                    "Gráficos com Matplotlib"
                                  ],
                                  "tips": "Monitore Mahalanobis distance para detecção de outliers.",
                                  "learningObjective": "Avaliar e otimizar performance do EKF em cenários realistas.",
                                  "commonMistakes": [
                                    "Overfitting de Q/R",
                                    "Ignorar wrap-around em ângulos"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita baixa da Terra: use medições de 4 estrelas (vetores unitários) a 1 Hz e taxas de giroscópio a 100 Hz com bias. Implemente EKF para estimar quaternions de atitude; valide contra trajetória conhecida, alcançando precisão de 0.05 graus.",
                              "finalVerifications": [
                                "O EKF converge em < 30 segundos para estado inicial incerto.",
                                "Erro RMS de atitude < 0.1 graus em simulação de 10 minutos.",
                                "Covariância P estabiliza e reflete incerteza real.",
                                "Filtro rejeita outliers de estrelas oclusas.",
                                "Implementação roda em tempo real (latência < 10 ms).",
                                "Comparação com UKF mostra performance similar ou superior."
                              ],
                              "assessmentCriteria": [
                                "Correção das equações de estado, medição e Jacobianas (90% precisão).",
                                "Estabilidade numérica em simulações longas (>1 hora).",
                                "Precisão de estimativa: RMSE < 0.2 graus.",
                                "Eficiência computacional: < 1 ms por iteração em hardware embarcado.",
                                "Relatório documenta tuning e análise de resíduos.",
                                "Código modular, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes Jacobianas), Probabilidade (distribuições gaussianas).",
                                "Programação: Otimização numérica (SciPy), Controle de versão (Git).",
                                "Física: Mecânica orbital, Cinemática de corpos rígidos.",
                                "Engenharia de Software: Testes unitários para filtros.",
                                "Estatística: Análise de resíduos e testes de hipóteses."
                              ],
                              "realWorldApplication": "Usado em satélites como o James Webb Space Telescope para determinação autônoma de atitude, fusão de Star Trackers e gyros, permitindo pointing preciso de instrumentos científicos apesar de perturbações orbitais."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Avaliar precisão e robustez da determinação",
                            "description": "Simular cenários com ruído, obstruções e taxas altas para quantificar erro de atitude (ex: arcosegundos) e tempo de convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de simulação para determinação de atitude",
                                  "subSteps": [
                                    "Instalar e configurar software de simulação como MATLAB/Simulink ou Python com bibliotecas astropy e scipy.",
                                    "Definir modelo cinemático e dinâmico do veículo espacial, incluindo matrizes de rotação e quaternions.",
                                    "Integrar modelos de sensores: estrelas (CCD) com catálogo de estrelas e IMU (giros e acelerômetros).",
                                    "Implementar algoritmo de determinação de atitude (ex: QUEST ou TRIAD com filtro Kalman).",
                                    "Testar simulação nominal sem perturbações para baseline."
                                  ],
                                  "verification": "Executar simulação nominal e confirmar que erro de atitude é inferior a 0.1 arcosegundos em condições ideais.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "MATLAB/Simulink ou Python (astropy, scipy, numpy); documentação de sensores de estrelas; catálogo Hipparcos.",
                                  "tips": "Use quaternions para evitar singularidades em rotações; normalize vetores de medição.",
                                  "learningObjective": "Compreender e implementar o framework básico de simulação para determinação de atitude.",
                                  "commonMistakes": "Ignorar normalização de quaternions levando a deriva; usar ângulos de Euler causando gimbal lock."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e implementar cenários adversos",
                                  "subSteps": [
                                    "Modelar ruído gaussiano nos sensores: σ = 1-10 arcseg para estrelas, 0.01 deg/s para giros.",
                                    "Simular obstruções: remover 30-70% das estrelas visíveis com base em campo de visão bloqueado.",
                                    "Incorporar altas taxas angulares: rotações de 1-10 deg/s em eixos principais.",
                                    "Combinar perturbações: ruído + obstruções + taxas altas em sequências realistas.",
                                    "Parametrizar cenários para varredura (Monte Carlo: 100-500 runs por caso)."
                                  ],
                                  "verification": "Gerar logs confirmando aplicação de perturbações (ex: % estrelas obstruídas, estatísticas de ruído).",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "Scripts Python/MATLAB para geração de ruído (numpy.random); perfis de missão reais (ex: CubeSat).",
                                  "tips": "Use sementes fixas para reprodutibilidade em Monte Carlo; visualize obstruções em sky maps.",
                                  "learningObjective": "Modelar realisticamente fontes de degradação em sistemas de atitude.",
                                  "commonMistakes": "Ruído não zero-mean causando bias; obstruções aleatórias sem correlação temporal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações e coletar dados de performance",
                                  "subSteps": [
                                    "Rodar simulações para cada cenário, registrando quaternions verdadeiros vs. estimados ao longo do tempo.",
                                    "Calcular erro de atitude: ||q_true - q_est|| em arcosegundos (converter de quaternions).",
                                    "Medir tempo de convergência: tempo até erro < threshold (ex: 5 arcseg).",
                                    "Coletar estatísticas: média, desvio padrão, RMSE, percentil 95% sobre runs.",
                                    "Exportar dados para análise (CSV ou HDF5)."
                                  ],
                                  "verification": "Plots de erro vs. tempo mostrando convergência e oscilações em todos cenários.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "Código de simulação; ferramentas de plot (matplotlib, plotly); cluster computacional se necessário.",
                                  "tips": "Paralelize runs com multiprocessing para eficiência; monitore uso de memória em simulações longas.",
                                  "learningObjective": "Executar experimentos numéricos robustos e coletar métricas relevantes.",
                                  "commonMistakes": "Erro calculado em graus ao invés de arcosegundos; ignorar wrap-around em ângulos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar precisão, robustez e quantificar métricas",
                                  "subSteps": [
                                    "Computar métricas agregadas: erro médio (arcseg), tempo médio de convergência (s), taxa de falha (> threshold).",
                                    "Realizar análise de sensibilidade: varrer níveis de ruído/obstrução e plotar curvas.",
                                    "Comparar performance nominal vs. adversa; identificar thresholds de degradação.",
                                    "Aplicar testes estatísticos (t-test) para significância entre cenários.",
                                    "Gerar relatório com tabelas, gráficos e conclusões sobre robustez."
                                  ],
                                  "verification": "Relatório com métricas quantificadas (ex: erro < 10 arcseg em 95% runs com 50% obstrução).",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Ferramentas de análise (pandas, scipy.stats); LaTeX ou Jupyter para relatório.",
                                  "tips": "Use boxplots para visualizar variabilidade; normalize métricas por baseline.",
                                  "learningObjective": "Interpretar dados de simulação para avaliar performance do sistema.",
                                  "commonMistakes": "Confundir precisão (erro bias) com acurácia (erro RMS); amostras insuficientes em Monte Carlo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e otimizar robustez do sistema",
                                  "subSteps": [
                                    "Identificar fraquezas (ex: altas taxas >5 deg/s causam divergência).",
                                    "Testar mitigações: tuning de Kalman gains, fusão multi-sensor avançada.",
                                    "Simular otimizações e reavaliar métricas.",
                                    "Documentar recomendações para design (ex: FOV maior para estrelas).",
                                    "Validar contra dados reais ou benchmarks publicados."
                                  ],
                                  "verification": "Melhoria quantificável (ex: tempo de convergência reduzido 20%) pós-otimização.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Literatura (papers IEEE Aerospace); dados de benchmark (ex: TABS dataset).",
                                  "tips": "Itere rapidamente com poucos runs para tuning inicial; documente mudanças em git.",
                                  "learningObjective": "Aplicar insights para melhorar robustez em sistemas reais.",
                                  "commonMistakes": "Overfitting a cenários específicos sem generalização; ignorar trade-offs custo/performance."
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO com 50% das estrelas obstruídas por painéis solares, ruído de 5 arcseg nos sensores CCD e rotação de 3 deg/s durante manobra. Meça se o filtro EKF mantém erro < 10 arcseg e converge em < 30s.",
                              "finalVerifications": [
                                "Erro médio de atitude < 5 arcseg em cenários com ruído moderado.",
                                "Tempo de convergência < 60s em 90% dos runs com obstruções.",
                                "Taxa de falha < 5% mesmo com taxas angulares de 5 deg/s.",
                                "Análise de sensibilidade mostra thresholds claros de degradação.",
                                "Relatório inclui plots, tabelas e conclusões acionáveis.",
                                "Otimização demonstra melhoria quantificável em pelo menos uma métrica."
                              ],
                              "assessmentCriteria": [
                                "Precisão das implementações de simulação e métricas (80% acurácia em baselines).",
                                "Abrangência e realismo dos cenários adversos testados.",
                                "Qualidade da análise estatística e visualizações.",
                                "Profundidade das conclusões sobre robustez e otimizações propostas.",
                                "Clareza e completude do relatório final.",
                                "Capacidade de reproduzir resultados (código versionado)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise Monte Carlo, testes de hipótese.",
                                "Programação: Simulação numérica, paralelização.",
                                "Física: Cinemática de rotações, dinâmica orbital.",
                                "Engenharia de Controle: Filtros Kalman, observabilidade.",
                                "Ciência de Dados: Visualização e análise de séries temporais."
                              ],
                              "realWorldApplication": "Em missões como o telescópio James Webb ou constelações Starlink, onde obstruções por estruturas e manobras rápidas são comuns, garantindo apontamento preciso para comunicações e imagens científicas sem perda de dados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Sistemas Propulsivos e Torques Externos no Controle de Atitude",
                    "description": "Sistemas propulsivos, torque de pressão solar e torque magnético para controle de atitude.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Sistemas Propulsivos no Controle de Atitude",
                        "description": "Estudo dos sistemas propulsivos utilizados para gerar torques e controlar a atitude de veículos espaciais, incluindo princípios de operação e integração com dinâmica de atitude.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Identificar princípios de funcionamento de propulsores para controle de atitude",
                            "description": "Compreender como propulsores de baixa tração, como propulsores frios e thrusters químicos, geram torques por ejeção de massa para correções de atitude em satélites.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de controle de atitude e propulsão",
                                  "subSteps": [
                                    "Defina controle de atitude como a orientação e estabilização rotacional de um satélite no espaço.",
                                    "Explique a conservação do momento angular e como torques externos são necessários para alterá-lo.",
                                    "Identifique propulsores como sistemas que ejetam massa para gerar força e torque.",
                                    "Diferencie tração baixa (micronewtons a newtons) de propulsores principais.",
                                    "Revise equação básica de impulso: F = m_dot * v_e, onde m_dot é taxa de ejeção e v_e é velocidade de exaustão."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe um diagrama simples de um satélite com vetores de torque.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Spacecraft Dynamics and Control' de Sidi (capítulo 1)",
                                    "Vídeo Khan Academy sobre momento angular",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias como girar uma cadeira ejetando ar para visualizar torque.",
                                  "learningObjective": "Entender a base física do controle de atitude via propulsão.",
                                  "commonMistakes": [
                                    "Confundir força linear com torque rotacional",
                                    "Ignorar que no vácuo não há atrito para estabilização passiva"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar funcionamento de propulsores frios (cold gas thrusters)",
                                  "subSteps": [
                                    "Descreva o design: tanque de gás pressurizado (ex: nitrogênio), válvula e bico.",
                                    "Explique geração de thrust: expansão adiabática do gás através do bocal gera v_e ~ 100-300 m/s.",
                                    "Calcule thrust aproximado: F = P * A * Cd, onde P é pressão, A área do bico, Cd coeficiente de descarga.",
                                    "Discuta posicionamento: thrusters em pares opostos para torque puro sem translação.",
                                    "Liste vantagens: simplicidade, confiabilidade; desvantagens: baixa Isp (~50-70s)."
                                  ],
                                  "verification": "Calcule thrust para P=10 bar, A=1 cm² e verifique se atende requisitos de um CubeSat.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador online de thrusters (NASA tools)",
                                    "Planilha Excel para cálculos",
                                    "Artigo Wikipedia 'Cold gas thruster'"
                                  ],
                                  "tips": "Visualize com animações 3D de ejeção de gás para entender direção do torque.",
                                  "learningObjective": "Dominar princípios e equações de propulsores frios.",
                                  "commonMistakes": [
                                    "Esquecer direção oposta da reação pelo 3ª lei de Newton",
                                    "Superestimar v_e sem considerar temperatura"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar thrusters químicos para controle de atitude",
                                  "subSteps": [
                                    "Classifique tipos: monolpropelentes (hidrazina), bipropelentes (N2O4/MMH).",
                                    "Descreva ciclo: catalisador decompõe propelente em gases quentes, v_e ~2000 m/s.",
                                    "Compare com frios: maior thrust e Isp (200-300s), mas complexidade e toxicidade.",
                                    "Analise configuração: matriz de thrusters em eixos x,y,z para controle 3D de atitude.",
                                    "Estude duty cycle: pulsos curtos (ms) para precisão em correções."
                                  ],
                                  "verification": "Desenhe esquema de um thruster químico e liste 3 diferenças chave vs. frios.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Documentação CubeSat propulsion (NASA)",
                                    "Vídeo animação de decomposição de hidrazina",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Foquem em eficiência específica (Isp) para missões longas.",
                                  "learningObjective": "Comparar e contrastar thrusters químicos com frios.",
                                  "commonMistakes": [
                                    "Confundir Isp com thrust total",
                                    "Ignorar requisitos de armazenamento seguro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar propulsores ao controle de atitude em satélites",
                                  "subSteps": [
                                    "Explique geração de torque: τ = r × F, onde r é braço de alavanca do thruster.",
                                    "Simule correção: para rotação em roll, ative thrusters assimétricos.",
                                    "Discuta controle: loops PID integrando dados de giroscópios e star trackers.",
                                    "Avalie limitações: ΔV total finito, plumas interferindo em sensores.",
                                    "Revise exemplos reais: uso em satélites GEO para station-keeping."
                                  ],
                                  "verification": "Crie um diagrama vetorial mostrando torque corrigindo yaw de 1°/s.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Software STK ou GMAT para simulação básica",
                                    "Paper 'Attitude Control Systems' de satélites",
                                    "Calculadora simbólica como Wolfram Alpha"
                                  ],
                                  "tips": "Use vetores cruzados para calcular direção do torque.",
                                  "learningObjective": "Aplicar princípios em sistemas reais de satélites.",
                                  "commonMistakes": [
                                    "Negligir momento de inércia do satélite no cálculo de aceleração angular",
                                    "Assumir thrust constante sem considerar depleção de propelente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat como o CPOD da UTIAS, propulsores frios de nitrogênio são usados para desorbitalização: dois thrusters opostos ejetam gás a 200 m/s, gerando torque de 0.1 Nm para corrigir rotação de 0.5°/s em 10 pulsos de 100ms, estabilizando para aquisição de imagem terrestre.",
                              "finalVerifications": [
                                "Explique verbalmente como ejeção de massa gera torque sem rotação do centro de massa.",
                                "Calcule ΔV para correção de atitude com massa ejetada de 10g a 250 m/s.",
                                "Identifique configuração ideal de 12 thrusters para controle completo 6DOF.",
                                "Diferencie aplicações de frios vs. químicos em missões LEO vs. GEO.",
                                "Simule falha: como compensar thruster defeituoso com outros.",
                                "Descreva impacto de plumas em painéis solares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de leis físicas (3ª Newton, conservação angular).",
                                "Correção em cálculos de thrust e torque (erro <10%).",
                                "Completude de comparações entre tipos de propulsores.",
                                "Clareza em diagramas e exemplos práticos.",
                                "Identificação de limitações reais e mitigações.",
                                "Integração com sensores de atitude."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica newtoniana e conservação de momento.",
                                "Matemática: Vetores cruzados e álgebra linear para torques.",
                                "Engenharia Mecânica: Design de válvulas e bocais.",
                                "Química: Propriedades de propelentes e reações catalíticas.",
                                "Informática: Simulações em Python/MATLAB para controle PID."
                              ],
                              "realWorldApplication": "Em satélites como os da constelação Starlink, thrusters químicos corrigem atitude para manter links laser precisos, evitando perda de sinal; na ISS, propulsores frios ajustam orientação para experimentos microgravidade, consumindo <1% do propelente total por órbita."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Modelar torques gerados por sistemas propulsivos",
                            "description": "Desenvolver equações matemáticas para calcular o torque resultante de propulsores, considerando vetor de empuxo, braço de momento e eficiência específica em cenários de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Torque, Empuxo e Eficiência",
                                  "subSteps": [
                                    "Definir torque como τ = r × F, onde r é o vetor de posição do propisor e F o vetor de empuxo.",
                                    "Estudar o vetor de empuxo F = m_dot * v_e * η, incorporando eficiência específica η.",
                                    "Analisar o braço de momento como componente perpendicular entre r e F.",
                                    "Revisar convenções de coordenadas em dinâmica de atitude (body frame).",
                                    "Explorar exemplos de propulsores como RCS thrusters em satélites."
                                  ],
                                  "verification": "Criar um diagrama vetorial manual ilustrando τ, r e F para um propisor único.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Spacecraft Dynamics and Control' (Sidi)",
                                    "Software de desenho vetorial (ex: GeoGebra)",
                                    "Vídeos Khan Academy sobre produto vetorial"
                                  ],
                                  "tips": "Sempre desenhe os vetores no plano XY do body frame para visualização inicial.",
                                  "learningObjective": "Dominar os princípios físicos e matemáticos básicos para modelagem de torques propulsivos.",
                                  "commonMistakes": [
                                    "Confundir magnitude escalar de torque com vetor completo",
                                    "Ignorar a eficiência η na formulação do empuxo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Parâmetros e Geometria do Sistema Propulsivo",
                                  "subSteps": [
                                    "Identificar posição r_i de cada propisor i no sistema (coordenadas no body frame).",
                                    "Determinar direção unitária û_i do empuxo para cada propisor.",
                                    "Calcular magnitude do empuxo F_i = ṁ_i * v_ei * η_i, com taxas de massa ṁ_i e velocidade de exaustão v_ei.",
                                    "Montar matriz de configuração de propulsores com r_i e û_i para múltiplos propulsores.",
                                    "Verificar ortogonalidade e redundâncias na configuração."
                                  ],
                                  "verification": "Listar parâmetros em uma tabela para um sistema com 4 propulsores e calcular r × û para um.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Excel ou Python (NumPy) para tabelas",
                                    "Documentação de CubeSat com RCS",
                                    "Artigo sobre Reaction Control Systems"
                                  ],
                                  "tips": "Padronize unidades: N para força, m para posição, s para tempos.",
                                  "learningObjective": "Configurar precisamente os parâmetros geométricos e operacionais de sistemas propulsivos.",
                                  "commonMistakes": [
                                    "Usar coordenadas inerciais em vez de body frame",
                                    "Esquecer variação de η com temperatura ou saturação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Equação Matemática do Torque Resultante",
                                  "subSteps": [
                                    "Escrever torque individual τ_i = r_i × (F_i * û_i).",
                                    "Somar torques totais τ_total = Σ τ_i para N propulsores.",
                                    "Incorporar limitações: saturação de empuxo e eficiência variável.",
                                    "Linearizar para controle: τ = B * u, onde B é matriz de alocação e u comandos de duty cycle.",
                                    "Derivar expressão escalar em componentes (roll, pitch, yaw)."
                                  ],
                                  "verification": "Derivar e simplificar equação para 2 propulsores opostos; comparar com fórmula padrão.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (SymPy para simbólico)",
                                    "Papel e lápis para derivação",
                                    "Referência 'Fundamentals of Astrodynamics' (Bate)"
                                  ],
                                  "tips": "Use produto vetorial em componentes: τ_x = r_y F_z - r_z F_y, etc.",
                                  "learningObjective": "Desenvolver equações analíticas precisas para torque propulsivo em simulações.",
                                  "commonMistakes": [
                                    "Não somar vetores corretamente para múltiplos propulsores",
                                    "Linearizar prematuramente sem validar não-linearidades"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Validar em Cenário de Simulação",
                                  "subSteps": [
                                    "Codificar modelo em simulador (ex: função torque_propulsors(state, commands)).",
                                    "Simular rotação de atitude com torques aplicados e integrar equações de Euler.",
                                    "Comparar torque calculado com torque angular medido na simulação.",
                                    "Testar cenários: falha em propisor, saturação e eficiência reduzida.",
                                    "Analisar estabilidade e precisão numérica."
                                  ],
                                  "verification": "Gerar gráfico de torque vs. tempo para correção de 10° de yaw; erro < 1%.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Simulador 6DOF como JSBSim",
                                    "Dados de thruster real (ex: NASA Cold Gas Thruster)"
                                  ],
                                  "tips": "Use solvers numéricos com passo adaptativo para precisão em rotações rápidas.",
                                  "learningObjective": "Aplicar modelo em ambiente simulado e validar resultados.",
                                  "commonMistakes": [
                                    "Erro de indexação em loops de propulsores",
                                    "Ignorar momento de inércia I na dinâmica angular"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat com 12 RCS thrusters, modelar torque para correção de atitude: propulsores em ±x geram roll torque de 0.01 Nm com r = [0.1, 0, 0] m, F = 0.5 N, η=0.9, simulando estabilização pós-desestabilização por distúrbios gravitacionais.",
                              "finalVerifications": [
                                "Equação τ_total = Σ (r_i × F_i û_i η_i) derivada e codificada corretamente.",
                                "Simulação numérica converge com erro de torque < 0.5%.",
                                "Matriz de alocação B tem posto completo para controle 3-axis.",
                                "Testes com falhas mantêm modelagem robusta.",
                                "Gráficos de torque vs. tempo mostram resposta física realista.",
                                "Eficiência variável afeta torque conforme esperado."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação matemática (100% match com teoria).",
                                "Corretude da implementação computacional (testes unitários passados).",
                                "Tratamento de não-linearidades e limitações (saturação, eficiência).",
                                "Validação quantitativa em simulações (RMSE < 1e-3 Nm).",
                                "Documentação clara de equações e premissas.",
                                "Eficiência computacional para simulações em tempo real."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra vetorial e produto cruzado.",
                                "Física: Mecânica newtoniana e dinâmica rotacional.",
                                "Programação: Modelagem numérica e simulação (Python/MATLAB).",
                                "Engenharia de Controle: Alocação de atuadores e linearização.",
                                "Ciência de Materiais: Impacto de eficiência em propulsores químicos."
                              ],
                              "realWorldApplication": "No controle de atitude de satélites como o ISS ou Starlink, onde thrusters modelados geram torques precisos para apontamento de antenas, evitando deriva e otimizando combustível em missões de longa duração."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Aplicar sistemas propulsivos em manobras de atitude",
                            "description": "Simular sequências de disparos de propulsores para estabilização e manobras de apontamento, avaliando consumo de propelente e precisão angular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Princípios de Sistemas Propulsivos e Dinâmica de Atitude",
                                  "subSteps": [
                                    "Estude os tipos de propulsores (químicos, elétricos, cold gas) e seus vetores de empuxo em veículos espaciais.",
                                    "Revise equações de dinâmica de atitude: momento de inércia, equações de Euler e torques de controle.",
                                    "Analise o impacto do consumo de propelente na vida útil da missão.",
                                    "Identifique parâmetros chave: precisão angular (graus ou arcosegundos), taxa de rotação e eficiência de empuxo.",
                                    "Explore exemplos reais de missões como Hubble ou ISS para manobras de atitude."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes de um sistema propulsivo e liste 3 equações fundamentais de atitude.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro texto de dinâmica orbital (ex: Curtis 'Orbital Mechanics'),",
                                    "Vídeos tutoriais sobre dinâmica de atitude (NASA ou YouTube),",
                                    "Folha de cálculo para equações."
                                  ],
                                  "tips": "Use diagramas vetoriais para visualizar torques; foque em simetria do veículo.",
                                  "learningObjective": "Dominar fundamentos teóricos para modelagem precisa de manobras propulsivas.",
                                  "commonMistakes": [
                                    "Confundir empuxo com torque (lembre: torque = r × F),",
                                    "Ignorar assimetrias na distribuição de propulsores.",
                                    "Subestimar perdas de eficiência por ângulos de disparo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Veículo Espacial e Sistema Propulsivo",
                                  "subSteps": [
                                    "Defina parâmetros do satélite: matriz de inércia, posição e configuração dos propulsores (8 thrusters típicos).",
                                    "Implemente modelo cinemático e dinâmico em software de simulação (ex: MATLAB/Simulink ou Python com Orekit).",
                                    "Calcule vetores de torque para combinações de disparos (on/off pulsing).",
                                    "Incorpore perturbações externas mínimas para foco em propulsão.",
                                    "Valide modelo com cenários estáticos de equilíbrio."
                                  ],
                                  "verification": "Execute simulação estática e confirme torque zero com configuração balanceada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (bibliotecas: numpy, scipy, poliastro),",
                                    "Modelos de satélite de referência (ex: CubeSat specs),",
                                    "Documentação de bibliotecas espaciais."
                                  ],
                                  "tips": "Comece com modelo 3DOF rotacional; use vetores unitários para propulsores.",
                                  "learningObjective": "Criar um modelo digital fiel do sistema para simulações realistas.",
                                  "commonMistakes": [
                                    "Erro em unidades (Nm vs. mNms),",
                                    "Não normalizar vetores de empuxo.",
                                    "Ignorar delays de resposta dos propulsores."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Estabilização e Manobras de Apontamento",
                                  "subSteps": [
                                    "Configure cenário inicial: veículo com erro de atitude de 10 graus em roll/pitch/yaw.",
                                    "Implemente lógica de controle: sequência de disparos para nulificar erro (PD controller simples).",
                                    "Simule estabilização: registre ângulos, velocidades angulares e duração dos disparos.",
                                    "Execute manobra de apontamento: rotacione 90 graus em yaw, avaliando overshoot.",
                                    "Repita com variações: diferentes erros iniciais e massas de propelente."
                                  ],
                                  "verification": "Gráficos mostram convergência para erro <0.1 grau em <60 segundos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software de simulação configurado do Step 2,",
                                    "Templates de controladores PD para atitude.",
                                    "Ferramentas de plotagem (matplotlib)."
                                  ],
                                  "tips": "Use duty cycle para simular pulsos finitos; monitore overshoot para tuning.",
                                  "learningObjective": "Executar simulações dinâmicas de manobras propulsivas com controle efetivo.",
                                  "commonMistakes": [
                                    "Disparos excessivos levando a saturação de propelente.",
                                    "Não dampen oscilações (aumente ganho derivativo).",
                                    "Escala temporal errada (simule em segundos reais)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Consumo de Propelente e Precisão Angular",
                                  "subSteps": [
                                    "Calcule delta-V total e massa de propelente consumida (equação de Tsiolkovsky adaptada).",
                                    "Meça precisão: erro final RMS em ângulos e desvios de trajetória desejada.",
                                    "Compare múltiplas runs: eficiência vs. precisão trade-off.",
                                    "Otimize sequência de disparos minimizando consumo para mesma precisão.",
                                    "Gere relatório com métricas: Isp efetivo, tempo de manobra."
                                  ],
                                  "verification": "Relatório mostra <5% variação em precisão e consumo otimizado vs. baseline.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código de simulação do Step 3,",
                                    "Planilhas para análise de métricas (Excel/Google Sheets)."
                                  ],
                                  "tips": "Priorize propulsores opostos para torques puros; use otimização numérica se possível.",
                                  "learningObjective": "Analisar performance quantitativa de manobras propulsivas.",
                                  "commonMistakes": [
                                    "Calcular consumo sem considerar eficiência direcional.",
                                    "Métrica de precisão errada (use quaternion para evitar gimbal lock).",
                                    "Omitir margem de segurança em propelente."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Iterar e Refinar Simulações",
                                  "subSteps": [
                                    "Identifique falhas em runs anteriores e ajuste modelo (ex: adicionar ruído).",
                                    "Teste cenários edge: baixo propelente, falha de thruster.",
                                    "Documente melhores práticas para sequências de disparos.",
                                    "Compare com dados reais de missões (ex: telemetry de CubeSats).",
                                    "Prepare apresentação de resultados."
                                  ],
                                  "verification": "Simulações refinadas alcançam precisão <0.05 grau com 20% menos consumo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dados reais de missões (NASA CDSN),",
                                    "Ferramentas de versionamento (Git)."
                                  ],
                                  "tips": "Sempre valide com energy methods (conservação angular).",
                                  "learningObjective": "Refinar modelos para robustez em aplicações reais.",
                                  "commonMistakes": [
                                    "Não testar falhas (redundância é chave).",
                                    "Overfitting a um cenário único."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO com erro de atitude de 5 graus em pitch devido a perturbações magnéticas. Use 4 pares de thrusters cold gas para estabilizar em 30 segundos, consumindo <1g de propelente, alcançando precisão de 0.1 grau para aquisição de imagem terrestre.",
                              "finalVerifications": [
                                "Simulação estabiliza atitude em <1 minuto com erro <0.5 grau.",
                                "Consumo de propelente calculado com precisão e abaixo de limite de missão.",
                                "Gráficos de ângulos/velocidades mostram convergência suave sem oscilações.",
                                "Otimização reduz consumo em 15-25% mantendo precisão.",
                                "Relatório inclui trade-offs precisão vs. eficiência.",
                                "Modelo lida com falhas de thruster sem perda de controle."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem propulsiva (vetores torque corretos: 90%).",
                                "Efetividade da simulação (convergência estável: 85%).",
                                "Análise quantitativa completa (métricas RMS, delta-m: 90%).",
                                "Otimização e iterações demonstradas (redução consumo: 80%).",
                                "Documentação clara com gráficos e conclusões (100%).",
                                "Tratamento de edge cases e validação (80%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica rotacional e conservação de momento angular.",
                                "Matemática: Álgebra linear (quaternions, matrizes de rotação) e otimização numérica.",
                                "Programação: Simulação numérica e controle de sistemas (Python/MATLAB).",
                                "Engenharia: Design de sistemas redundantes e análise de trade-offs.",
                                "Ciência de Dados: Análise de séries temporais de telemetria."
                              ],
                              "realWorldApplication": "Em satélites como Starlink ou missões da NASA (ex: James Webb), sistemas propulsivos executam manobras de atitude para apontamento de antenas/painéis solares, estabilização pós-lançamento e evasão de detritos, otimizando vida útil limitada pelo propelente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Torque de Pressão Solar",
                        "description": "Análise do torque gerado pela pressão de radiação solar sobre superfícies de veículos espaciais e seu uso passivo ou ativo no controle de atitude.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Explicar a origem e magnitude do torque de pressão solar",
                            "description": "Derivar a fórmula do torque solar baseado na pressão de radiação, área projetada, coeficiente de reflexão e vetor normal à superfície do satélite.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a origem da pressão de radiação solar",
                                  "subSteps": [
                                    "Estudar a intensidade do fluxo solar constante (aprox. 1366 W/m² na Terra).",
                                    "Explicar como fótons colidem com a superfície, transferindo momento linear.",
                                    "Derivar a pressão de radiação para absorção total: P = I/c, onde I é intensidade e c é velocidade da luz.",
                                    "Discutir diferença entre absorção e reflexão especular/difusa.",
                                    "Calcular pressão para reflexão perfeita: P = 2I/c."
                                  ],
                                  "verification": "Escrever e derivar corretamente as fórmulas de pressão para casos de absorção e reflexão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de dinâmica orbital ou astrodinâmica",
                                    "Calculadora científica",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Visualize fótons como partículas com momento p = E/c para facilitar a intuição física.",
                                  "learningObjective": "Entender o mecanismo físico da pressão de radiação como base para forças em satélites.",
                                  "commonMistakes": "Confundir pressão com intensidade energética; esquecer fator 2 na reflexão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a força resultante na superfície do satélite",
                                  "subSteps": [
                                    "Definir a área projetada A_proj = A * |cos θ|, onde θ é ângulo entre vetor solar e normal à superfície.",
                                    "Calcular força F = P * A_proj * (1 + ρ), onde ρ é coeficiente de reflexão (0 para absorção, 1 para reflexão perfeita).",
                                    "Determinar direção da força: paralela ao vetor incidência para absorção, com componente refletida para reflexão.",
                                    "Expressar vetor força F = P * A * (1 + ρ) * (n · s) * s, onde n é normal unitária e s é direção solar unitária.",
                                    "Verificar unidades: força em Newtons."
                                  ],
                                  "verification": "Derivar e computar numericamente F para um painel solar de 1 m² perpendicular ao Sol.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de cálculo simbólico como SymPy ou Mathematica",
                                    "Tabela de constantes solares"
                                  ],
                                  "tips": "Use vetores unitários para evitar erros em componentes direcionais.",
                                  "learningObjective": "Aplicar pressão para obter força vetorial considerando geometria da superfície.",
                                  "commonMistakes": "Ignorar projeção da área ou usar ângulo incorreto; confundir normal com direção solar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o torque a partir da força e momento de inércia",
                                  "subSteps": [
                                    "Recordar definição de torque τ = r × F, onde r é vetor posição do centro de pressão ao CG.",
                                    "Identificar centro de pressão como ponto médio da área iluminada para superfícies planas.",
                                    "Expressar τ = r × [P * A_proj * (1 + ρ) * s], com direção perpendicular ao plano r-F.",
                                    "Incorporar dependência angular completa: magnitude |τ| = P * A * (1 + ρ) * |r × (n · s) s|.",
                                    "Simplificar para casos comuns, como painéis solares assimétricos."
                                  ],
                                  "verification": "Derivar fórmula vetorial completa do torque e plotar magnitude vs. ângulo θ.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib para vetores e plots",
                                    "Referência de astrodinâmica (ex: Vallado)"
                                  ],
                                  "tips": "Desenhe diagramas vetoriais para visualizar cruzamento r × F.",
                                  "learningObjective": "Conectar força distribuída a torque resultante no sistema de atitude do satélite.",
                                  "commonMistakes": "Usar força escalar em produto vetorial; assumir r zero para CG coincidente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e generalizar a fórmula do torque solar",
                                  "subSteps": [
                                    "Comparar com fórmula padrão: τ = (P A / 2) * (1 + ρ) * sin(2α) * unit_vector, para painéis retangulares.",
                                    "Discutir variações: sombra da Terra, degradação superficial, múltiplas faces.",
                                    "Implementar em código simples para simulação numérica.",
                                    "Analisar magnitude típica: ~10^-7 a 10^-5 Nm para CubeSats.",
                                    "Documentar limitações, como modelo de pressão isotrópica."
                                  ],
                                  "verification": "Simular torque para órbita LEO e comparar com valores de literatura.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Dados orbitais de satélites reais"
                                  ],
                                  "tips": "Teste limites: θ=0 (zero torque), θ=90° (máximo).",
                                  "learningObjective": "Generalizar derivação para aplicações reais em controle de atitude.",
                                  "commonMistakes": "Negligenciar fator sin(2θ) em magnitudes angulares; superestimar para grandes satélites."
                                }
                              ],
                              "practicalExample": "Para um CubeSat 1U com painel solar de 0.01 m² (ρ=0.8), perpendicular ao Sol: P≈4.5e-6 N/m², F≈4e-8 N, torque≈1e-9 Nm se r=0.05m (desbalanceamento). Simule rotação induzida em 1 dia.",
                              "finalVerifications": [
                                "Deriva corretamente P = I/c e F = P A_proj (1+ρ).",
                                "Escreve fórmula vetorial τ = r × F com direção solar e normal.",
                                "Calcula magnitude numérica para exemplo real com erro <5%.",
                                "Explica impacto em estabilidade de atitude de satélites.",
                                "Identifica 3 fontes de variação (ângulo, reflexão, sombra)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação física (80% peso).",
                                "Correção vetorial e unidades (15% peso).",
                                "Clareza em diagramas e exemplos (5% peso)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletromagnetismo (momentum de fótons).",
                                "Matemática: Álgebra vetorial e produtos cruzados.",
                                "Engenharia: Modelagem em simulações de dinâmica orbital.",
                                "Computação: Programação numérica para validação."
                              ],
                              "realWorldApplication": "Em satélites como o CubeSat MarCO, o torque solar causa desvios de atitude de até 1°/dia, exigindo rodas de reação ou propulsores para correção; essencial em missões interplanetárias sem estabilização ativa."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Modelar efeitos do torque solar na dinâmica de atitude",
                            "description": "Incorporar o torque de pressão solar nas equações de Euler para rotação rígida, analisando perturbações em órbitas geoestacionárias ou LEO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Torque de Pressão Solar",
                                  "subSteps": [
                                    "Estudar a radiação solar como fluxo de fótons e sua interação com superfícies espaciais.",
                                    "Derivar a força de pressão solar usando momento linear dos fótons (P = 2I/c para reflexão especular).",
                                    "Calcular o torque resultante τ = r × F, considerando geometria do satélite e vetor incidência solar.",
                                    "Analisar dependência angular com vetor normal à superfície e ângulos de incidência.",
                                    "Revisar propriedades ópticas de materiais espaciais (absorção, reflexão difusa/especular)."
                                  ],
                                  "verification": "Derivar corretamente a expressão do torque solar para uma placa plana e validar com valores típicos (ex: 10^{-6} Nm para satélite 1m² a 1AU).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Spacecraft Dynamics and Control' de Sidi",
                                    "Artigos NASA sobre pressão solar",
                                    "Calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Use diagramas vetoriais para visualizar r, F_solar e τ; comece com casos simplificados (placa perpendicular).",
                                  "learningObjective": "Dominar a física e derivação matemática do torque de pressão solar em veículos espaciais.",
                                  "commonMistakes": [
                                    "Ignorar fator 2 para reflexão especular",
                                    "Confundir pressão com força sem momento de alavanca",
                                    "Negligenciar variação com distância heliocêntrica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Equações de Euler para Rotação Rígida",
                                  "subSteps": [
                                    "Recordar as equações cinemáticas de Euler: ω̇ + ω × ω = 0 (para vetor de rotação).",
                                    "Estudar equações dinâmicas: I ω̇ + ω × (I ω) = τ_total, onde I é tensor de inércia.",
                                    "Definir parâmetros de atitude (ângulos de Euler: roll, pitch, yaw) e quaternions para evitar singularidades.",
                                    "Implementar linearização para pequenas perturbações em equilíbrio.",
                                    "Verificar unidades e normalizações (kg m² para I, Nm para τ)."
                                  ],
                                  "verification": "Resolver analiticamente um caso sem torque externo e plotar evolução de ω(t) para condição inicial.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de curso de dinâmica de atitude",
                                    "MATLAB/Simulink ou Python (SciPy) para simulações básicas",
                                    "Tensor de inércia exemplo para CubeSat"
                                  ],
                                  "tips": "Prefira quaternions sobre ângulos de Euler para simulações numéricas; teste com I diagonal simplificado.",
                                  "learningObjective": "Aplicar corretamente as equações de Euler à dinâmica de atitude de satélites.",
                                  "commonMistakes": [
                                    "Esquecer termo de Coriolis ω × (I ω)",
                                    "Usar ângulos de Euler sem cuidado com gimbal lock",
                                    "Inverter convenções de rotação dextra/sinistra"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Torque Solar nas Equações de Euler",
                                  "subSteps": [
                                    "Expressar τ_solar como função de atitude (A(t)), posição orbital e vetor solar unitário ŝ.",
                                    "Adicionar τ_solar ao lado direito das equações: I ω̇ + ω × (I ω) = τ_control + τ_solar + outros.",
                                    "Linearizar τ_solar em torno de ponto de equilíbrio (ex: τ_solar ≈ K φ para pequeno ângulo φ).",
                                    "Derivar matriz de perturbação A_solar para análise de estabilidade.",
                                    "Validar dimensionalmente e com literatura (ex: Vallado 'Fundamentals of Astrodynamics')."
                                  ],
                                  "verification": "Implementar equações completas em código e comparar torque médio com valores teóricos para GEO.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software de simulação (Python com NumPy/SciPy ou MATLAB)",
                                    "Dados orbitais (TLE para satélite LEO/GEO)",
                                    "Referências: Wiesel 'Spacecraft Attitude Dynamics'"
                                  ],
                                  "tips": "Modele painéis solares como fontes principais de τ_solar; use expansão em série de Fourier para periodicidade orbital.",
                                  "learningObjective": "Integrar perturbações não lineares como torque solar nas equações de atitude.",
                                  "commonMistakes": [
                                    "Não atualizar vetor solar com movimento orbital",
                                    "Linearizar incorretamente levando a instabilidade numérica",
                                    "Ignorar assimetrias no tensor de inércia"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Analisar Perturbações em Órbitas GEO e LEO",
                                  "subSteps": [
                                    "Definir cenários: satélite em LEO (h=500km, período~90min) vs GEO (h=36000km, período=24h).",
                                    "Integrar equações numericamente (RK4 ou odeint) com τ_solar incluído, sem controle inicial.",
                                    "Plotar evolução de ângulos/ω ao longo de múltiplas órbitas; quantificar drift (ex: deg/dia).",
                                    "Comparar com/ sem τ_solar; calcular métricas como RMS de erro de atitude.",
                                    "Analisar sensibilidade a área projetada, albedo terrestre e eclipse."
                                  ],
                                  "verification": "Gerar gráficos mostrando perturbação >1°/orbita em LEO sem correção, validando com simulações referenciadas.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python (Matplotlib, SciPy.integrate)",
                                    "STK ou GMAT para validação orbital",
                                    "Dados ephemeris solar (SPICE kernel)"
                                  ],
                                  "tips": "Inicie com LEO (efeitos mais pronunciados); use passos de tempo adaptativos para precisão em singularidades.",
                                  "learningObjective": "Avaliar impactos quantitativos do torque solar em missões reais via simulação.",
                                  "commonMistakes": [
                                    "Erro em propagação orbital (posição errada para ŝ)",
                                    "Sobrestimar torque ignorando sombras",
                                    "Numérica instável por timestep grande"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat (1U, painéis solares assimétricos) em órbita LEO a 500km: integre equações por 10 órbitas sem controle, observe drift de yaw ~5°/dia devido a τ_solar; plote ω_x,y,z e attitude quaternion vs tempo.",
                              "finalVerifications": [
                                "Derivação correta de τ_solar para geometria arbitrária.",
                                "Simulação numérica converge sem divergência numérica.",
                                "Análise mostra perturbação maior em LEO que GEO por maior gradiente solar.",
                                "Cálculo de torque médio bate com literatura (±10%).",
                                "Identificação de periodicidades orbitais em plots de atitude.",
                                "Linearização captura dinâmica para pequenas amplitudes."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (equações balanceadas, unidades corretas).",
                                "Qualidade da simulação (estabilidade, precisão temporal, visualizações claras).",
                                "Análise quantitativa (métricas de drift, comparação cenários).",
                                "Compreensão conceitual (explicação física de efeitos em LEO/GEO).",
                                "Tratamento de não-linearidades e validações cruzadas.",
                                "Relatório estruturado com código reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica clássica e eletromagnetismo (radiação).",
                                "Matemática: Álgebra linear (tensores), EDOs não lineares.",
                                "Programação: Métodos numéricos (integração, visualização).",
                                "Engenharia: Design de satélites (balanço de torque).",
                                "Astrodinâmica: Propagação orbital e perturbações."
                              ],
                              "realWorldApplication": "Em satélites geoestacionários como os de comunicação (ex: Intelsat), modelagem de τ_solar permite dimensionar rodas de reação ou propulsores para compensar drifts, garantindo pointing preciso para antenas terrestres; essencial em missões CubeSat low-cost como as da NASA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Utilizar torque solar para controle passivo de atitude",
                            "description": "Projetar configurações de painéis solares assimétricos para gerar torques de restauração passiva, simulando estabilidade em ausência de atuadores ativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Torque Solar e Pressão de Radiação Solar",
                                  "subSteps": [
                                    "Estude a física da pressão de radiação solar e como ela gera forças em superfícies expostas.",
                                    "Derive a fórmula para o torque gerado por pressão solar assimétrica: τ = r × F, onde F é a força de pressão.",
                                    "Analise exemplos de configurações passivas em satélites reais, como painéis desbalanceados.",
                                    "Identifique condições orbitais ideais para restauração passiva (ex.: órbita baixa com iluminação assimétrica).",
                                    "Calcule a magnitude típica da pressão solar (cerca de 4.5 μN/m² na Terra)."
                                  ],
                                  "verification": "Resuma em um diagrama os vetores de força e torque resultantes de uma configuração assimétrica.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livros de dinâmica orbital (ex.: Vallado), simulador online de pressão solar, calculadora simbólica (SymPy).",
                                  "tips": "Visualize com desenhos 3D para entender assimetrias.",
                                  "learningObjective": "Dominar a geração de torque passivo via pressão solar assimétrica.",
                                  "commonMistakes": "Confundir pressão solar com arrasto atmosférico ou ignorar variação com ângulo de incidência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Matematicamente o Sistema de Atitude com Torque Solar",
                                  "subSteps": [
                                    "Defina as equações cinemáticas e dinâmicas de atitude: Ḣ = -ω × H + τ_solar.",
                                    "Implemente o modelo de torque solar como função da orientação: τ_solar = A × cos(θ) × P_sr × r_cm.",
                                    "Incorpore matrizes de inércia assimétricas para painéis solares.",
                                    "Linearize o modelo em torno do equilíbrio para análise de estabilidade (autovalores negativos).",
                                    "Teste o modelo com parâmetros reais de um CubeSat (massa 1kg, área solar 0.1m²)."
                                  ],
                                  "verification": "Execute simulação numérica simples e confirme que torque restaura perturbações pequenas.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python/MATLAB com bibliotecas Orekit ou poliastro, planilha para cálculos iniciais.",
                                  "tips": "Use coordenadas principais de inércia para simplificar.",
                                  "learningObjective": "Construir um modelo matemático preciso do torque solar passivo.",
                                  "commonMistakes": "Negligenciar o braço de momento (r) ou assumir incidência normal constante."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar Configurações Assimétricas de Painéis Solares",
                                  "subSteps": [
                                    "Esboce layouts assimétricos: painéis offset ou de tamanhos diferentes em eixos perpendiculares.",
                                    "Otimize posição e área para maximizar torque de restauração no eixo alvo (ex.: roll).",
                                    "Calcule o centro de pressão vs. centro de massa para gerar torque restaurador.",
                                    "Avalie trade-offs: geração de energia vs. torque (área maior aumenta ambos).",
                                    "Itere designs com software CAD para visualização 3D."
                                  ],
                                  "verification": "Gere gráfico de torque vs. ângulo mostrando estabilidade (torque oposto à perturbação).",
                                  "estimatedTime": "4 horas",
                                  "materials": "Software CAD (FreeCAD), planilhas de otimização, dados de painéis solares espaciais.",
                                  "tips": "Comece com assimetria simples em um eixo antes de 3D.",
                                  "learningObjective": "Criar designs práticos que gerem torque passivo estável.",
                                  "commonMistakes": "Colocar centro de pressão coincidente com CM, anulando torque."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Validar Estabilidade Passiva",
                                  "subSteps": [
                                    "Configure simulador de dinâmica de atitude com torque solar como único atuador.",
                                    "Aplique perturbações iniciais e simule por várias órbitas (ex.: 10 períodos orbitais).",
                                    "Analise convergência para atitude nominal e tempo de assentamento.",
                                    "Sensitividade a parâmetros: variação orbital, envelhecimento de painéis.",
                                    "Compare com benchmarks analíticos ou dados de missões reais."
                                  ],
                                  "verification": "Demonstre que ângulos de atitude retornam a zero em <5 minutos simulados.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Simulador GMAT ou Python (scipy.integrate para ODEs), dados orbitais reais.",
                                  "tips": "Use step-size adaptativo para precisão em transientes.",
                                  "learningObjective": "Validar o design via simulação realista.",
                                  "commonMistakes": "Simular sem sombreamento eclipse ou ignorar outros torques (gravitacional)."
                                }
                              ],
                              "practicalExample": "Para um CubeSat em órbita LEO (500km), projete painéis solares assimétricos com área extra de 0.05m² no eixo Y, offset 5cm do CM. Simule perturbação de 10° em roll: o torque solar (~10^{-6} Nm) restaura em 3 órbitas, sem consumo de energia ativa.",
                              "finalVerifications": [
                                "Torque gerado é restaurador e proporcional ao erro de atitude.",
                                "Simulação mostra convergência estável sem oscilações divergentes.",
                                "Design mantém eficiência energética >80% nominal.",
                                "Análise de sensibilidade confirma robustez a ±20% variação de parâmetros.",
                                "Gráficos de atitude vs. tempo exibem amortecimento passivo.",
                                "Comparação com literatura valida magnitude do torque."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo matemático (erro <5% vs. analítico).",
                                "Qualidade do design assimétrico (torque máximo >10^{-6} Nm).",
                                "Tempo de simulação de restauração <10 períodos orbitais.",
                                "Documentação completa com diagramas e código.",
                                "Análise de trade-offs quantitativa.",
                                "Robustez demonstrada em cenários variados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica orbital e vetores (torque cruzado).",
                                "Matemática: Equações diferenciais não-lineares e linearização.",
                                "Engenharia Mecânica: Design de estruturas leves espaciais.",
                                "Programação: Simulação numérica (Python/MATLAB).",
                                "Energia Sustentável: Otimização de painéis solares multifuncionais."
                              ],
                              "realWorldApplication": "Usado em CubeSats de baixo custo como o ESTCube-1 para detumbling passivo, reduzindo massa de rodas de reação e prolongando vida útil em missões sem atuadores ativos, economizando até 20% do orçamento de propulsão."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Torque Magnético",
                        "description": "Exploração do torque magnético resultante da interação entre dipolos magnéticos do satélite e o campo geomagnético terrestre para controle de atitude.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Compreender o mecanismo de geração de torque magnético",
                            "description": "Calcular o torque como produto vetorial entre o momento magnético das bobinas de torque e o vetor campo magnético terrestre, usando modelo dipolo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Vetores e Produto Vetorial",
                                  "subSteps": [
                                    "Defina vetores posição, força e momento em contextos físicos.",
                                    "Explique a magnitude e direção do produto vetorial usando a regra da mão direita.",
                                    "Derive a fórmula geral do torque como τ = r × F e generalize para τ = m × B.",
                                    "Pratique cálculos escalares de produto vetorial em 3D com componentes cartesianas.",
                                    "Visualize o produto vetorial usando software como GeoGebra ou desenhos manuais."
                                  ],
                                  "verification": "Resolva 3 problemas de produto vetorial e confirme que a direção é perpendicular ao plano formado pelos vetores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de física vetorial, calculadora, software GeoGebra ou MATLAB.",
                                  "tips": "Sempre normalize os vetores para verificar magnitudes unitárias antes do cálculo.",
                                  "learningObjective": "Dominar o produto vetorial como base para torque magnético.",
                                  "commonMistakes": "Confundir produto escalar com vetorial; ignorar a direção usando regra da mão esquerda."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Momento Magnético das Bobinas de Torque",
                                  "subSteps": [
                                    "Descreva o momento magnético m de uma bobina como m = N * I * A * n̂, onde N é o número de espiras, I corrente, A área e n̂ normal.",
                                    "Explique o modelo dipolo magnético para bobinas em satélites (magnetorquers).",
                                    "Calcule m para uma bobina típica: N=1000, I=0.5A, A=0.01m².",
                                    "Discuta como controlar m variando corrente I via comandos de controle de atitude.",
                                    "Simule variação de m em diferentes eixos (x, y, z) para um sistema triaxial."
                                  ],
                                  "verification": "Derive e calcule m para uma bobina dada, confirmando unidades em Am².",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Fórmulas de eletromagnetismo, planilha Excel ou Python para cálculos.",
                                  "tips": "Lembre-se: direção de m segue a regra da mão direita para corrente na bobina.",
                                  "learningObjective": "Calcular e manipular o vetor momento magnético m.",
                                  "commonMistakes": "Esquecer o vetor normal n̂ ou usar unidades erradas (ex: confundir A com m²)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar o Campo Magnético Terrestre como Dipolo",
                                  "subSteps": [
                                    "Descreva o modelo dipolo magnético da Terra com polo norte magnético.",
                                    "Use a fórmula B(r, θ) = (μ₀ / 4π) * (2M / r³) para componente meridional e (μ₀ / 4π) * (M / r³) para equatorial, onde M é o momento dipolo terrestre (~8×10²² Am²).",
                                    "Calcule B em órbita LEO (r=6871 km) para diferentes latitudes.",
                                    "Represente B como vetor em coordenadas ECEF ou orbitais.",
                                    "Compare magnitude de B (~30-60 μT) com valores medidos por satélites."
                                  ],
                                  "verification": "Calcule |B| em equador e polos orbitais, plotando variação com altitude.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Dados IGRF modelo, Python com NumPy/SciPy ou MATLAB.",
                                  "tips": "Use r = R_terra + h para altitude h; converta km para metros.",
                                  "learningObjective": "Modelar precisamente o vetor B terrestre.",
                                  "commonMistakes": "Usar r equatorial sem ajustar para altura orbital; ignorar dependência angular."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o Torque Magnético τ = m × B",
                                  "subSteps": [
                                    "Combine m e B: derive τ = |m| |B| sinθ n̂, onde θ é ângulo entre vetores.",
                                    "Calcule τ numericamente para m alinhado/perpendicular a B.",
                                    "Implemente em código: defina m e B vetoriais e compute cross product.",
                                    "Analise como τ desalinha o momento de inércia do satélite para controle.",
                                    "Otimize corrente I para maximizar |τ| (~10⁻⁵ Nm típico em CubeSats)."
                                  ],
                                  "verification": "Simule τ para 3 configurações e verifique que |τ| = 0 quando m || B.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Código Python/MATLAB, exemplos de dados orbitais.",
                                  "tips": "Use np.cross() em NumPy para simplicidade; valide com magnitude analítica.",
                                  "learningObjective": "Executar cálculo completo de torque e interpretá-lo.",
                                  "commonMistakes": "Confundir ordem de cross product (m × B ≠ B × m); escalar incorretamente sinθ."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em Simulação de Controle de Atitude",
                                  "subSteps": [
                                    "Integre τ em equações de dinâmica de atitude: I ω̇ + ω × Iω = τ_mag + outros.",
                                    "Simule desvio de atitude corrigido por magnetorquers em LEO.",
                                    "Avalie limitações: τ pequeno, depende de B variável.",
                                    "Compare com rodas de reação ou propulsores.",
                                    "Crie gráfico de evolução de ângulos de Euler sob torque magnético."
                                  ],
                                  "verification": "Execute simulação e confirme estabilização de atitude em <5° erro.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Simulador Orekit/STK ou Python com scipy.integrate.odeint.",
                                  "tips": "Comece com caso 2D para depuração antes de 3D.",
                                  "learningObjective": "Contextualizar torque em sistemas reais de controle.",
                                  "commonMistakes": "Negligenciar termos de Coriolis ω × τ; supor B constante."
                                }
                              ],
                              "practicalExample": "Em um CubeSat em órbita LEO a 500km, com bobinas triaxiais (m_x=10 Am², m_y=0, m_z=0) e B = [20, 30, 40] μT, calcule τ = m × B ≈ [-1.2, 0.8, -0.1] ×10^{-3} Nm, resultando em rotação primária no plano yz para correção de rol.",
                              "finalVerifications": [
                                "Deriva corretamente τ = m × B do modelo dipolo.",
                                "Calcula m para bobina com >95% precisão em unidades Am².",
                                "Modela B terrestre com variação <10% erro vs. IGRF.",
                                "Simula τ em código e valida direção/magnitude.",
                                "Explica limitações em controle de atitude.",
                                "Identifica ângulo θ ótimo (90°) para torque máximo."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: fórmulas corretas e cálculos exatos (40%).",
                                "Compreensão conceitual: explica vetores e interações (25%).",
                                "Aplicação prática: simulação funcional e análise (20%).",
                                " Clareza na verificação: métodos de validação robustos (10%).",
                                "Criatividade em dicas/erros: insights acionáveis (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra vetorial e cálculo diferencial.",
                                "Física: Eletromagnetismo e dinâmica clássica.",
                                "Engenharia: Controle de sistemas e simulação orbital.",
                                "Computação: Programação numérica (Python/MATLAB).",
                                "Geofísica: Modelos magnéticos terrestres."
                              ],
                              "realWorldApplication": "Magnetorquers em CubeSats como o PocketQube ou missões NASA (ex: CubeSat 101) usam torque magnético para controle de atitude passivo e econômico, reduzindo massa/propulsor em nano-satélites para monitoramento ambiental e comunicações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Modelar torque magnético nas equações de atitude",
                            "description": "Integrar o torque magnético nas equações diferenciais de atitude em quaternions ou ângulos de Euler, considerando variação do campo magnético orbital.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações diferenciais de atitude em quaternions",
                                  "subSteps": [
                                    "Estudar a representação de atitude usando quaternions unitários (q = [q0, q1, q2, q3]).",
                                    "Derivar as equações cinemáticas: dq/dt = (1/2) * Ω * q, onde Ω é a matriz de velocidades angulares.",
                                    "Derivar as equações dinâmicas: J * dω/dt + ω × (J ω) = τ_total, onde J é o tensor de inércia e τ_total inclui todos os torques.",
                                    "Comparar brevemente com ângulos de Euler para contextualizar limitações (singularidades).",
                                    "Implementar uma simulação básica sem torques externos em Python ou MATLAB."
                                  ],
                                  "verification": "Simulação roda sem erros e reproduz rotação livre estável; plotar componentes do quaternion.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Spacecraft Dynamics and Control' de Sidi",
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Sempre normalizar quaternions para manter |q| = 1; use funções prontas como quatnormalize no MATLAB.",
                                  "learningObjective": "Compreender e implementar as equações de atitude base em quaternions.",
                                  "commonMistakes": [
                                    "Esquecer normalização do quaternion",
                                    "Confundir cinemática com dinâmica",
                                    "Usar ângulos de Euler sem cuidado com gimbal lock"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o torque magnético gerado por magnetotorquers",
                                  "subSteps": [
                                    "Definir o momento magnético do satélite m = M * c, onde M é a matriz de comando e c o vetor de campo de controle.",
                                    "Estudar a fórmula do torque: τ_m = m × B, onde B é o vetor campo magnético local.",
                                    "Implementar a multiplicação vetorial em código, considerando o sistema de coordenadas do corpo (body frame).",
                                    "Analisar dependência do torque na orientação (devido a B no body frame: B_b = A(q) * B_o, A matriz de direção).",
                                    "Testar com valores fixos de B e m para validar magnitude e direção."
                                  ],
                                  "verification": "Código computa τ_m corretamente para casos teste (ex: m = [1,0,0], B=[0,1,0] → τ_m=[0,0,1]); comparar com cálculos manuais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação de magnetotorquers (NASA ou CubeSat kits)",
                                    "Python/MATLAB",
                                    "Ferramenta de plotting como Matplotlib"
                                  ],
                                  "tips": "Use vetores coluna para consistência matricial; visualize setas 3D para intuitar o torque.",
                                  "learningObjective": "Derivar e codificar o modelo vetorial do torque magnético.",
                                  "commonMistakes": [
                                    "Confundir frames orbital e body",
                                    "Esquecer o produto vetorial (×)",
                                    "Ignorar saturação dos magnetotorquers"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar torque magnético nas equações de dinâmica de atitude",
                                  "subSteps": [
                                    "Modificar τ_total = τ_control + τ_m + τ_distúrbios, adicionando τ_m às equações dinâmicas.",
                                    "Atualizar o solver numérico (ex: ode45 no MATLAB ou solve_ivp no SciPy) com o novo termo.",
                                    "Implementar a transformação do campo magnético: B_b = DCM(q) * B_i (DCM = direction cosine matrix).",
                                    "Simular uma manobra simples com torque magnético constante.",
                                    "Plotar evolução de ω, q e τ_m ao longo do tempo."
                                  ],
                                  "verification": "Simulação converge e mostra desvio de atitude devido a τ_m; norma do quaternion permanece ~1.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código do Step 1",
                                    "Modelo IGRF ou dipolo para B_i",
                                    "Solver ODE"
                                  ],
                                  "tips": "Use Runge-Kutta de ordem 4-5 para precisão; monitore step size para estabilidade.",
                                  "learningObjective": "Incorporar τ_m nas EDOs completas de atitude.",
                                  "commonMistakes": [
                                    "Erro na matriz de rotação DCM(q)",
                                    "Não atualizar B_b a cada timestep",
                                    "Escala errada de unidades (Nm vs mNm)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar variação orbital do campo magnético",
                                  "subSteps": [
                                    "Modelar B_orbital usando modelo dipolo terrestre: B_i = f(posição orbital, declinação magnética).",
                                    "Implementar propagação orbital simples (ex: modelo Kepleriano) para obter r, v ao longo da órbita.",
                                    "Calcular B_i em cada timestep baseado em posição: |B| ~ μ / r^3, direção radial/dipolar.",
                                    "Integrar na simulação completa e analisar variação de τ_m sobre uma órbita.",
                                    "Otimizar código para eficiência em simulações longas."
                                  ],
                                  "verification": "B_i varia realisticamente (ex: ~20-60 μT em LEO); τ_m oscila com período orbital.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Modelo IGRF11/12 (biblioteca Python pygmo ou MATLAB)",
                                    "Dados orbitais TLE de satélites reais"
                                  ],
                                  "tips": "Comece com órbita circular equatorial para simplificar; valide com dados de CubeSats como QB50.",
                                  "learningObjective": "Simular efeitos dinâmicos do campo magnético orbital variável.",
                                  "commonMistakes": [
                                    "Modelo dipolo invertido",
                                    "Ignorar rotação da Terra",
                                    "Resolução temporal insuficiente para órbita"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e analisar o modelo completo",
                                  "subSteps": [
                                    "Comparar simulação com casos analíticos ou literatura (ex: torque médio zero em órbita polar).",
                                    "Testar sensibilidade a parâmetros (J, m_max, órbita).",
                                    "Implementar métricas: erro de apontamento, consumo de torque.",
                                    "Documentar resultados em relatório com plots.",
                                    "Explorar extensões como controle ADCS com τ_m."
                                  ],
                                  "verification": "Resultados batem com referências (±5% em magnitude); simulação estável por >10 órbitas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Referências: 'Analytical Mechanics of Space Systems' de Schaub",
                                    "Ferramentas de análise (plots, stats)"
                                  ],
                                  "tips": "Use logging para debug; version control com Git.",
                                  "learningObjective": "Validar numericamente o modelo integrado.",
                                  "commonMistakes": [
                                    "Overfitting a um caso",
                                    "Numeração errada de quaternions",
                                    "Instabilidade numérica em solvers"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a dinâmica de atitude de um CubeSat 1U em órbita LEO (400km, 98° inclinação) equipado com 3 magnetotorquers ortogonais (m_max=0.2 Am²). Aplique comandos para desaturar rodas de reação, observando como o torque magnético variável estabiliza a atitude nadir-pointing ao longo de 3 órbitas, plotando quaternions, velocidades angulares e τ_m.",
                              "finalVerifications": [
                                "Norma do quaternion permanece unitária em toda simulação.",
                                "Torque magnético varia com período orbital e magnitude realista (10^-6 a 10^-5 Nm).",
                                "Equações dinâmicas balanceiam corretamente (conservação de momento angular sem τ_m).",
                                "Simulação roda sem crashes por 10+ órbitas (>1 dia).",
                                "Plots mostram estabilização de atitude com τ_m.",
                                "Comparação com modelo Euler qualitativamente similar (sem singularidades)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação das EDOs (erro <1% vs analítico).",
                                "Correta modelagem vetorial de τ_m e transformação de frames.",
                                "Tratamento realista da variação orbital de B (uso de modelo dipolo/IGRF).",
                                "Eficiência e estabilidade numérica da simulação.",
                                "Análise qualitativa/quantitativa dos resultados (plots, métricas).",
                                "Documentação clara do código e suposições."
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletromagnetismo (interação dipolo-campo) e Mecânica Orbital.",
                                "Matemática: Sistemas de EDOs não-lineares e Álgebra Linear (quaternions, matrizes de rotação).",
                                "Programação: Simulação numérica (ODE solvers) e Visualização de dados.",
                                "Engenharia de Controle: Integração em loops ADCS (Attitude Determination and Control Systems)."
                              ],
                              "realWorldApplication": "Desenvolvimento de sistemas de controle de atitude passivo/ativo para CubeSats e nanosatélites, como na missão QB50 ou Swarm da ESA, onde magnetotorquers são usados para desaturação de momentum e apontamento preciso, reduzindo custos e massa em comparação a propulsores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Implementar controle de atitude via atuadores magnéticos",
                            "description": "Desenvolver leis de controle B-dot ou PID para bobinas de torque, simulando desaturação de rodas de reação e estabilização em LEO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a Dinâmica de Atitude e o Campo Magnético em Órbita LEO",
                                  "subSteps": [
                                    "Derive as equações cinemáticas e dinâmicas de atitude usando quaternions ou ângulos de Euler.",
                                    "Implemente o modelo do campo magnético dipolar da Terra usando o modelo IGRF ou simplificado.",
                                    "Calcule o vetor de campo magnético B no referencial inercial e no corpo do satélite para órbita LEO.",
                                    "Inclua perturbações como gradiente gravitacional e pressão de radiação solar.",
                                    "Valide o modelo com dados reais de órbita LEO (ex: 400-600 km de altitude)."
                                  ],
                                  "verification": "Execute simulação inicial sem controle; verifique se o modelo reproduz tumbs (rotações descontroladas) realistas em LEO.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python com NumPy/SciPy",
                                    "Dados IGRF do NOAA",
                                    "Referência: Sidi 'Spacecraft Dynamics and Control'"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades; normalize vetores magnéticos periodicamente.",
                                  "learningObjective": "Compreender e implementar modelos físicos precisos para dinâmica de atitude e torque magnético.",
                                  "commonMistakes": [
                                    "Ignorar rotação da Terra no modelo B",
                                    "Usar coordenadas cartesianas sem conversão para o referencial do corpo",
                                    "Escala errada de unidades (B em Tesla vs Gauss)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Controlador B-dot para Despin Inicial",
                                  "subSteps": [
                                    "Defina a lei B-dot: m = -k * B × dB/dt, onde m é o momento magnético das bobinas.",
                                    "Estime dB/dt numericamente usando diferenças finitas no simulação.",
                                    "Sature o comando de corrente nas bobinas considerando limitações reais (ex: 1-10 Am²).",
                                    "Integre o controlador na simulação de dinâmica e teste em tumbs iniciais.",
                                    "Ajuste ganho k para convergência em <30 minutos simulados."
                                  ],
                                  "verification": "Monitore a taxa angular ω; confirme redução para |ω| < 0.1 deg/s em 10 órbitas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código da Step 1",
                                    "Documentação de magnetotorquers (ex: CubeSat specs)",
                                    "Ferramenta de plotagem (Matplotlib ou MATLAB plots)"
                                  ],
                                  "tips": "Filtre ruído em dB/dt com média móvel para estabilidade; teste sensibilidade ao ganho k.",
                                  "learningObjective": "Desenvolver e aplicar o algoritmo B-dot para estabilização passiva inicial.",
                                  "commonMistakes": [
                                    "Não saturar comandos de momento",
                                    "Erro no produto vetorial B × dB/dt",
                                    "dB/dt calculado no frame errado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Controlador PID com Atuadores Magnéticos e Rodas de Reação",
                                  "subSteps": [
                                    "Projete PID para atitude: erro em quaternions, com termos proporcional, integral e derivativo.",
                                    "Mapeie comandos de torque PID para correntes nas bobinas: m = N * I * A, considerando eixos.",
                                    "Modele rodas de reação com momento de inércia e desaturação por torque magnético de unload.",
                                    "Implemente lógica de desaturação: use torque magnético transversal para dump de momento.",
                                    "Sintonize PID gains via Ziegler-Nichols ou simulação para overshoot <10%."
                                  ],
                                  "verification": "Simule aquisição de atitude; verifique apontamento para nadir com erro <5 deg e desaturação sem perda de controle.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Código anterior",
                                    "Biblioteca de controle (Python Control Systems ou MATLAB Control Toolbox)",
                                    "Dados de rodas RW (ex: Sinclair Interplanetary)"
                                  ],
                                  "tips": "Use anti-windup no integrador PID; priorize unload magnético durante passes noturnos.",
                                  "learningObjective": "Integrar controle ativo PID com hardware magnético e gerenciamento de momentum.",
                                  "commonMistakes": [
                                    "Ganho derivativo alto causando oscilação",
                                    "Não modelar cross-coupling entre eixos",
                                    "Esquecimento do limite de slew rate nas RW"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Estabilização Completa em LEO e Validar Desempenho",
                                  "subSteps": [
                                    "Configure propagador orbital completo com TLE para LEO realista (ex: ISS-like).",
                                    "Execute simulação de longa duração (1-7 dias) com falhas simuladas (ex: falha de RW).",
                                    "Analise métricas: tempo de estabilização, consumo de energia, uso de bobinas.",
                                    "Compare B-dot vs PID em cenários; otimize para eficiência.",
                                    "Gere relatórios com plots de atitude, ω, B e comandos."
                                  ],
                                  "verification": "Confirme estabilização 3-σ <3 deg, desaturação RW <5% por órbita, robustez a ruídos.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Orekit ou GMAT para propagação orbital",
                                    "Código integrado",
                                    "Templates de análise (Jupyter Notebook)"
                                  ],
                                  "tips": "Inclua modelo de eclipse para variação de potência; salve checkpoints para debug.",
                                  "learningObjective": "Validar sistema de controle em ambiente orbital realista e analisar trade-offs.",
                                  "commonMistakes": [
                                    "Propagador orbital sem J2 perturbação",
                                    "Simulação muito curta para capturar drifts",
                                    "Ignorar deadbands no controle"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat 3U como o CP9 da Universidade de São Paulo, implemente B-dot para detumble pós-deploy e PID magnético para desaturação de RW, simulando em MATLAB para órbita LEO a 500 km, alcançando apontamento nadir com 2 deg de precisão e unload de momentum a cada órbita.",
                              "finalVerifications": [
                                "Simulação estabiliza atitude em <1 hora com erro RMS <3 deg.",
                                "Desaturação de RW mantém momentum acumulado <10% da capacidade máxima.",
                                "Controlador resiste a falhas (ex: uma bobina off) sem perda de estabilidade.",
                                "Consumo de potência das bobinas <5W médio por órbita.",
                                "Plots mostram convergência suave sem oscilações sustentadas.",
                                "Comparação B-dot vs PID demonstra superioridade do PID em precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo dinâmico (erro em B <1% vs dados reais).",
                                "Correta implementação de leis de controle (B-dot e PID sem bugs algébricos).",
                                "Efetividade na desaturação RW (tempo e eficiência).",
                                "Robustez da simulação (teste com variações de parâmetros ±20%).",
                                "Qualidade da análise (métricas quantificadas e plots claros).",
                                "Código modular e comentado para reprodutibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (produtos vetoriais, quaternions) e cálculo numérico (derivadas finitas).",
                                "Física: Eletromagnetismo (dipolo magnético) e mecânica orbital.",
                                "Programação: Simulação numérica (ODE solvers) e controle de sistemas.",
                                "Engenharia: Análise de sistemas lineares e otimização de controladores."
                              ],
                              "realWorldApplication": "Usado em missões CubeSat como o AOXi (Argentina) e PocketQubes para detumble e momentum dumping, reduzindo massa/missão ao eliminar propulsores, essencial para constelações LEO como Starlink para manutenção de atitude econômica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Atuadores de Troca de Momentos",
                    "description": "Rodas de reação e roda de reação com gimbal como atuadores para gerenciamento de momento angular.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Rodas de Reação",
                        "description": "Atuadores de troca de momentos que utilizam o princípio de conservação do momento angular para gerar torques internos no veículo espacial, acelerando ou desacelerando rotores flywheels montados em eixos fixos, permitindo controle preciso de atitude sem expulsão de massa.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Princípio de Conservação do Momento Angular em Rodas de Reação",
                            "description": "Compreender e derivar matematicamente como o torque aplicado à roda de reação altera o momento angular total do sistema spacecraft + roda, resultando em rotação do corpo principal para manter a conservação do momento angular total zero em ausência de torques externos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão do Princípio de Conservação do Momento Angular",
                                  "subSteps": [
                                    "Defina momento angular como L = I ω, onde I é o momento de inércia e ω é a velocidade angular.",
                                    "Explique que em sistemas isolados (sem torques externos), o momento angular total é conservado: L_total = constante.",
                                    "Discuta exemplos clássicos, como patinador girando os braços.",
                                    "Estenda para sistemas compostos: L_total = L1 + L2 + ... = constante.",
                                    "Enfatize que o torque τ = dL/dt, então sem τ_ext, dL_total/dt = 0."
                                  ],
                                  "verification": "Resuma o princípio em um parágrafo e resolva um problema simples de conservação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Física Clássica (ex: Marion & Thornton)",
                                    "Vídeo Khan Academy sobre momento angular"
                                  ],
                                  "tips": "Sempre considere o sistema como um todo e use vetores para direção.",
                                  "learningObjective": "Compreender a conservação vetorial do momento angular em sistemas isolados.",
                                  "commonMistakes": [
                                    "Ignorar a direção vetorial do momento angular",
                                    "Confundir com conservação de energia",
                                    "Esquecer que torque externo altera o total"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelagem do Sistema Spacecraft + Roda de Reação",
                                  "subSteps": [
                                    "Descreva o spacecraft como um corpo rígido com momento de inércia I_sc e velocidade angular inicial ω_sc = 0.",
                                    "Modele a roda de reação como um disco com I_rw e velocidade angular ω_rw variável.",
                                    "Defina o sistema isolado: sem torques externos, L_total = I_sc ω_sc + I_rw ω_rw = 0.",
                                    "Identifique o motor da roda aplicando torque τ_rw à roda, gerando reação -τ_rw no spacecraft.",
                                    "Estabeleça equações iniciais: dω_rw/dt = τ_rw / I_rw."
                                  ],
                                  "verification": "Desenhe um diagrama esquemático do sistema e escreva as equações iniciais de momento angular.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Software como MATLAB ou Python para esboço"
                                  ],
                                  "tips": "Use coordenadas de corpo principal fixas no spacecraft para simplificar.",
                                  "learningObjective": "Modelar matematicamente o sistema composto spacecraft-roda.",
                                  "commonMistakes": [
                                    "Negligenciar o acoplamento dinâmico entre roda e spacecraft",
                                    "Assumir I_sc constante incorretamente",
                                    "Esquecer o sinal oposto das velocidades"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação Matemática da Rotação do Spacecraft",
                                  "subSteps": [
                                    "Parta de L_total = I_sc ω_sc + I_rw ω_rw = 0, então ω_sc = - (I_rw / I_sc) ω_rw.",
                                    "Derive a taxa de mudança: dω_sc/dt = - (I_rw / I_sc) dω_rw/dt = - (I_rw / I_sc) (τ_rw / I_rw) = - τ_rw / I_sc.",
                                    "Integre para mudança finita: Δθ_sc = ∫ ω_sc dt = - (I_rw / I_sc) Δθ_rw.",
                                    "Discuta saturação da roda: quando ω_rw max, precisa de desaturação.",
                                    "Verifique dimensionalmente: torque altera momento, conservando total."
                                  ],
                                  "verification": "Derive e resolva numericamente para valores exemplo: I_sc=100 kg m², I_rw=1 kg m², τ_rw=0.1 Nm por 100s.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora ou Python (NumPy/SciPy)",
                                    "Folha de derivação"
                                  ],
                                  "tips": "Mantenha os sinais consistentes: roda + implica spacecraft -.",
                                  "learningObjective": "Derivar analiticamente como torque na roda induz rotação no spacecraft.",
                                  "commonMistakes": [
                                    "Erro de sinal na conservação",
                                    "Confundir ω_sc com ω_rw",
                                    "Ignorar integração para ângulo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise e Simulação Prática",
                                  "subSteps": [
                                    "Implemente uma simulação simples em Python ou MATLAB da dinâmica.",
                                    "Plote ω_sc vs tempo para aceleração/desaceleração da roda.",
                                    "Analise o controle: como usar múltiplas rodas para 3 eixos.",
                                    "Discuta limitações: momentum dump via propulsores.",
                                    "Compare com dados reais de satélites."
                                  ],
                                  "verification": "Execute simulação e confirme que L_total permanece zero dentro de tolerância numérica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "Código template de simulação dinâmica"
                                  ],
                                  "tips": "Use loop de Euler simples para integração numérica inicial.",
                                  "learningObjective": "Aplicar e validar a derivação via simulação computacional.",
                                  "commonMistakes": [
                                    "Passos de tempo grandes causando instabilidade",
                                    "Não zerar L_total inicial",
                                    "Esquecer unidades consistentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat, para girar 10° em torno do eixo Z, acelere uma roda de reação com I_rw=0.01 kg m² até Δθ_rw=1000° (assumindo I_sc=0.1 kg m²), resultando em Δθ_sc ≈ -10° para conservação.",
                              "finalVerifications": [
                                "Deriva corretamente ω_sc = - (I_rw / I_sc) ω_rw.",
                                "Explica o papel do torque interno em sistemas conservados.",
                                "Simula numericamente e confirma L_total ≈ 0.",
                                "Identifica necessidade de desaturação da roda.",
                                "Discute aplicações em controle de atitude.",
                                "Calcula ângulo de rotação para cenários dados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (equações corretas e sinais).",
                                "Compreensão conceitual da conservação (explicação clara).",
                                "Qualidade da simulação (plots corretos, L_total conservado).",
                                "Identificação de erros comuns e limitações.",
                                "Aplicação a exemplos reais (ex: satélites).",
                                "Profundidade nos subpassos (detalhes quantitativos)."
                              ],
                              "crossCurricularConnections": [
                                "Física Clássica: Mecânica Lagrangiana para dinâmica rígida.",
                                "Engenharia de Controle: PID para velocidade da roda.",
                                "Programação: Simulação numérica em Python/MATLAB.",
                                "Matemática: Vetores, integrais e análise dimensional.",
                                "Eletrônica: Motores brushless para rodas de reação."
                              ],
                              "realWorldApplication": "Nas estações espaciais como a ISS e satélites como o Hubble, rodas de reação controlam atitude sem propelentes, economizando combustível; usadas em missões como James Webb para apontamento preciso de telescópios."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Configurações e Capacidades de Controle",
                            "description": "Analisar configurações típicas de 3 ou 4 rodas de reação em eixos ortogonais, calcular o envelope de torque e momento angular disponível, e identificar singularidades ou limitações como saturação de velocidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Configurações Típicas de Rodas de Reação",
                                  "subSteps": [
                                    "Estude diagramas de configurações com 3 rodas (triangular) e 4 rodas (piramidal ou ortogonal).",
                                    "Identifique os eixos de rotação das rodas e sua orientação ortogonal (x, y, z).",
                                    "Revise propriedades básicas: momento de inércia, velocidade máxima e torque máximo por roda.",
                                    "Compare redundância: 3 rodas vs. 4 rodas em termos de falhas e cobertura.",
                                    "Desenhe esquemas simples para cada configuração usando ferramentas vetoriais."
                                  ],
                                  "verification": "Desenhe e rotule corretamente diagramas de ambas as configurações, explicando redundância.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livros de dinâmica de atitude (ex: Sidi 'Spacecraft Dynamics'), diagramas online de RWGs, software de desenho (ex: Draw.io)"
                                  ],
                                  "tips": "Comece com 4 rodas ortogonais para simplicidade, pois é comum em CubeSats.",
                                  "learningObjective": "Compreender e visualizar configurações padrão de RWAs em eixos ortogonais.",
                                  "commonMistakes": [
                                    "Confundir eixos de rotação com eixos do veículo; ignorar ângulos de skew em configs não-ortogonais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Torque e Momento Angular Individuais",
                                  "subSteps": [
                                    "Defina vetores de direção de giro para cada roda (matrizes de direção D).",
                                    "Escreva equações para torque gerado: τ = D * τ_wheel, onde τ_wheel é vetor de torques das rodas.",
                                    "Calcule momento angular armazenado: h = D * h_wheel, com h_wheel = J * ω_wheel (J inércia, ω velocidade).",
                                    "Implemente limites: |ω_wheel| ≤ ω_max, |τ_wheel| ≤ τ_max.",
                                    "Codifique um modelo simples em Python/MATLAB para uma roda única."
                                  ],
                                  "verification": "Implemente e teste código que calcula h e τ para inputs válidos, verificando limites.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy, MATLAB, planilhas Excel para cálculos iniciais"
                                  ],
                                  "tips": "Use notação matricial consistente; normalize direções de giro para unitários.",
                                  "learningObjective": "Modelar matematicamente contribuições individuais de torque e momento angular das RWAs.",
                                  "commonMistakes": [
                                    "Esquecer sinal de direção nas matrizes D; não converter unidades (Nm vs. Nms)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Envelope de Capacidades",
                                  "subSteps": [
                                    "Monte matriz de direção completa D para 3 ou 4 rodas.",
                                    "Calcule envelope de torque: maximize |τ| sujeito a |τ_wheel| ≤ τ_max usando otimização linear.",
                                    "Determine envelope de momento angular: similar para |h|, com |ω| ≤ ω_max.",
                                    "Plote envelopes em 3D (ou projeções 2D) para torque e h usando software.",
                                    "Compare envelopes para configs de 3 vs. 4 rodas."
                                  ],
                                  "verification": "Gere plots corretos de envelopes e explique variações por configuração.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python (Matplotlib, SciPy.optimize), MATLAB Optimization Toolbox"
                                  ],
                                  "tips": "Use LP (programação linear) para envelopes; teste com valores realistas (ex: τ_max=0.01 Nm).",
                                  "learningObjective": "Computar e visualizar limites agregados de torque e momento angular do sistema.",
                                  "commonMistakes": [
                                    "Não considerar pseudoinversas para singularidades; escalas erradas nos plots."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Singularidades e Limitações",
                                  "subSteps": [
                                    "Analise det(D): identifique configurações singulares onde rank(D)<3.",
                                    "Simule saturação de velocidade: evolua h ao longo do tempo até |ω|=ω_max.",
                                    "Identifique deadbands ou zonas de baixa autoridade em envelopes.",
                                    "Avalie momentum dumping: capacidade de desaturar via thrusters.",
                                    "Crie relatório resumindo limitações para uma missão específica."
                                  ],
                                  "verification": "Identifique e mitigue pelo menos 2 singularidades em simulação, com relatório escrito.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código dos steps anteriores, papers sobre RWAs (ex: NASA reports)"
                                  ],
                                  "tips": "Simule dinâmicas reais com perturbações para ver saturação prática.",
                                  "learningObjective": "Diagnosticar e mitigar limitações operacionais como singularidades e saturação.",
                                  "commonMistakes": [
                                    "Ignorar efeitos dinâmicos como gimbal angles; superestimar capacidades sem limites reais."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um CubeSat com 4 RWAs ortogonais (τ_max=5mNm, ω_max=6000rpm), calcule e plote o envelope de torque, simulando uma manobra de slew de 90° que leva à saturação em uma roda, identificando a singularidade no plano xy.",
                              "finalVerifications": [
                                "Descreve corretamente configs de 3/4 RWAs com diagramas.",
                                "Calcula envelopes de τ e h com precisão <5% de erro.",
                                "Identifica singularidades via det(D)=0.",
                                "Simula saturação e propõe desaturação.",
                                "Gera plots profissionais de envelopes.",
                                "Explica limitações em contexto de missão."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (90%+ correto).",
                                "Qualidade visual e legibilidade de plots/envelopes.",
                                "Profundidade na análise de singularidades e limitações.",
                                "Capacidade de codificar e debugar simulações independentes.",
                                "Clareza na comunicação de resultados (relatório).",
                                "Integração de conceitos em exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, pseudoinversas, otimização).",
                                "Física: Dinâmica rotacional e conservação de momento angular.",
                                "Programação: NumPy/SciPy para modelagem e visualização.",
                                "Engenharia de Sistemas: Análise de redundância e falhas.",
                                "Controle: Introdução a controle ótimo sob restrições."
                              ],
                              "realWorldApplication": "Em satélites como o Hubble ou Starlink, otimizar RWAs previne falhas em manobras de atitude, gerenciando saturação durante dumping de momento via thrusters, essencial para missões de longa duração."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Desaturação e Gerenciamento de Momento",
                            "description": "Explicar métodos de desaturação usando propulsores ou torque magnético para resetar o momento acumulado nas rodas, incluindo modelagem dinâmica da transição entre modos de controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Rodas de Reação e Acumulação de Momento",
                                  "subSteps": [
                                    "Estude o princípio de conservação de momento angular em sistemas espaciais.",
                                    "Analise como rodas de reação armazenam momento para controle de atitude.",
                                    "Identifique limites de saturação das rodas e consequências de sobrecarga.",
                                    "Revise equações básicas de dinâmica de rotação: J ω_dot + ω × J ω = τ.",
                                    "Explore exemplos de missões reais onde saturação ocorreu."
                                  ],
                                  "verification": "Resuma em um diagrama o ciclo de acumulação e saturação de momento.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Dinâmica Espacial (Sidi ou Kaplan)",
                                    "Vídeos da NASA sobre controle de atitude",
                                    "Folha de papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias como uma girândola de brinquedo para visualizar conservação de momento.",
                                  "learningObjective": "Explicar como e por que o momento se acumula nas rodas de reação.",
                                  "commonMistakes": "Confundir momento angular com torque; ignorar efeitos de desacoplamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Métodos de Desaturação Usando Propulsores",
                                  "subSteps": [
                                    "Descreva o uso de thrusters para aplicar torque oposto ao momento acumulado.",
                                    "Calcule o impulso necessário: Δh = ∫ τ dt, onde τ = F × r.",
                                    "Simule uma manobra de desaturação em software básico.",
                                    "Avalie consumo de propelente e impactos na órbita.",
                                    "Compare thrusters químicos vs. elétricos em eficiência."
                                  ],
                                  "verification": "Implemente uma simulação simples mostrando redução de momento a zero.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python com NumPy/SciPy",
                                    "Documentação de thrusters da SpaceX ou Ariane"
                                  ],
                                  "tips": "Comece com modelo 1D para simplificar antes de 3D.",
                                  "learningObjective": "Modelar e calcular desaturação via propulsores com precisão.",
                                  "commonMistakes": "Negligenciar distúrbios externas durante a queima; superestimar eficiência de thrust."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desaturação Usando Torque Magnético",
                                  "subSteps": [
                                    "Explique interação dipolo magnético com campo terrestre: τ_m = m × B.",
                                    "Modele o campo magnético orbital usando modelo IGRF.",
                                    "Desenhe estratégia de 'magnetorquing' para descarregar momento específico.",
                                    "Simule ciclo de desaturação ao longo de órbitas múltiplas.",
                                    "Discuta limitações em órbitas polares vs. equatoriais."
                                  ],
                                  "verification": "Gere gráfico de momento vs. tempo mostrando desaturação gradual.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com bibliotecas Orekit ou poliastro",
                                    "Dados de campo magnético da NOAA"
                                  ],
                                  "tips": "Use simulações de Monte Carlo para variabilidade do campo B.",
                                  "learningObjective": "Aplicar física eletromagnética para gerenciamento passivo de momento.",
                                  "commonMistakes": "Assumir campo magnético uniforme; ignorar histerese em magnetorquers."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Modelagem Dinâmica da Transição entre Modos de Controle",
                                  "subSteps": [
                                    "Defina modos: controle de momento (rodas) vs. desaturação (thrusters/magnetorquers).",
                                    "Modele comutação usando lógica fuzzy ou thresholds de saturação.",
                                    "Implemente equações de estado: x_dot = A x + B u, com u alternando.",
                                    "Simule transientes e estabilidade durante switches.",
                                    "Otimize parâmetros de transição para minimizar erros de atitude."
                                  ],
                                  "verification": "Execute simulação completa de ciclo e valide estabilidade com Lyapunov.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "MATLAB Control Systems Toolbox",
                                    "Documentos de AOCS da ESA"
                                  ],
                                  "tips": "Teste sensibilidade a ruído para robustez realista.",
                                  "learningObjective": "Desenvolver modelo dinâmico híbrido para gerenciamento integrado.",
                                  "commonMistakes": "Chattering em switches; instabilidade pós-transição não modelada."
                                }
                              ],
                              "practicalExample": "Em um satélite CubeSat em órbita LEO, as rodas de reação saturam após 30 dias de manobras. Ative magnetorquers por 2 órbitas para desaturação parcial (70% h), seguido de uma queima de thruster de 10s para reset completo, mantendo precisão de apontamento <1°.",
                              "finalVerifications": [
                                "Simulação mostra momento resetado a <5% da capacidade máxima.",
                                "Transição de modos sem overshoot >10% em taxa angular.",
                                "Consumo de propelente < limite de missão (ex: 1% do total).",
                                "Estabilidade confirmada por eigenvalues negativos.",
                                "Gráficos de atitude mostram erro <0.5° durante desaturação.",
                                "Relatório resume trade-offs entre métodos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem dinâmica (equações corretas e implementadas).",
                                "Qualidade das simulações (realismo orbital e distúrbios).",
                                "Explicação clara de trade-offs (propelente vs. tempo vs. precisão).",
                                "Análise de erros comuns e mitigação.",
                                "Integração de conexões interdisciplinares.",
                                "Documentação completa com gráficos e código comentado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletromagnetismo e conservação de momento angular.",
                                "Matemática: Equações diferenciais e controle ótimo.",
                                "Programação: Simulação numérica e visualização de dados.",
                                "Engenharia Elétrica: Modelagem de atuadores magnéticos."
                              ],
                              "realWorldApplication": "Na Estação Espacial Internacional (ISS), desaturação de CMGs usa thrusters primários e magnetorquers secundários para gerenciar momento, evitando saturação que poderia comprometer experimentos científicos e segurança orbital."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Roda de Reação com Gimbal",
                        "description": "Atuadores avançados de troca de momentos, também conhecidos como Control Moment Gyros (CMGs), onde uma roda de alta velocidade é montada em um gimbal rotativo, gerando torque através da precessão gimbal para fornecer maior capacidade de momento angular em comparação às rodas fixas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Princípio de Precessão em CMGs",
                            "description": "Derivar a equação do torque gerado pela taxa de rotação do gimbal (δ̇) perpendicular ao vetor de momento angular da roda (h), resultando em τ = δ̇ × h, e analisar a direção e magnitude do torque resultante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Momento Angular e Torque",
                                  "subSteps": [
                                    "Defina o vetor de momento angular da roda de reação como h = I ω, onde I é o momento de inércia e ω é a velocidade angular da roda.",
                                    "Explique que o torque τ é a derivada temporal do momento angular: τ = dh/dt.",
                                    "Discuta como em referenciais rotativos, a mudança no momento angular pode ser devida a rotações adicionais.",
                                    "Visualize o vetor h fixo na direção do spin da roda e como gimbal afeta sua orientação.",
                                    "Pratique notação vetorial para produtos cruzados."
                                  ],
                                  "verification": "Escreva e explique a relação τ = dh/dt com um diagrama simples do vetor h.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de dinâmica de atitude",
                                    "Vídeo sobre momento angular (Khan Academy)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use a analogia de um pião: torque causa precessão alterando a direção de h sem mudar sua magnitude.",
                                  "learningObjective": "Compreender a base física do momento angular e torque para derivações em atuadores rotativos.",
                                  "commonMistakes": [
                                    "Tratar h como escalar em vez de vetor",
                                    "Confundir ω (spin) com δ̇ (gimbal rate)",
                                    "Ignorar a dependência da orientação no dh/dt"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Configuração e Cinemática do CMG",
                                  "subSteps": [
                                    "Descreva os componentes: roda de reação girando em alta velocidade (eixo spin), montada em um gimbal que rotaciona com taxa δ̇.",
                                    "Defina os eixos: h alinhado ao eixo spin, δ̇ perpendicular a h inicialmente.",
                                    "Explique que o gimbal rotaciona h no plano perpendicular ao eixo gimbal.",
                                    "Calcule a velocidade angular total da roda: Ω_total = ω (spin) + δ̇ (gimbal).",
                                    "Desenhe diagramas vetoriais mostrando h, δ̇ e seu produto cruzado."
                                  ],
                                  "verification": "Desenhe um diagrama 3D rotulado de um CMG mostrando vetores h e δ̇, e indique a direção esperada de τ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama de CMG (imagem ou software como GeoGebra)",
                                    "Referência: 'Spacecraft Attitude Dynamics' de Peter Hughes",
                                    "Ferramenta de desenho vetorial online"
                                  ],
                                  "tips": "Pense no gimbal como girando o vetor h como uma seta em um globo.",
                                  "learningObjective": "Modelar geometricamente o CMG e identificar as contribuições cinemáticas de spin e gimbal.",
                                  "commonMistakes": [
                                    "Assumir δ̇ paralela a h (torque seria zero)",
                                    "Esquecer que h é constante em magnitude mas muda direção",
                                    "Confundir eixos de rotação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Equação do Torque τ = δ̇ × h",
                                  "subSteps": [
                                    "Comece com dh/dt no referencial inercial: como |h| constante, dh/dt = h × Ω, onde Ω é a taxa de rotação do frame da roda.",
                                    "Identifique Ω ≈ δ̇ para gimbal lento comparado ao spin (aproximação padrão).",
                                    "Mostre que τ = dh/dt = δ̇ × h (produto cruzado).",
                                    "Derive algebricamente usando coordenadas cartesianas: assuma h = (0,0,h_z), δ̇ = (δ̇_x, 0, 0), então τ = (0, -h_z δ̇_x, 0).",
                                    "Verifique unidades: δ̇ em rad/s, h em N m s, τ em N m."
                                  ],
                                  "verification": "Escreva a derivação passo a passo em um caderno e confira com a forma final τ = δ̇ × h.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Caderno de equações",
                                    "Calculadora simbólica (SymPy online)",
                                    "Artigo sobre CMGs (NASA technical paper)"
                                  ],
                                  "tips": "Use a identidade vetorial dh/dt = ∂h/∂t + Ω × h, onde ∂h/∂t = 0 por spin constante.",
                                  "learningObjective": "Derivar matematicamente a equação do torque de precessão em CMGs.",
                                  "commonMistakes": [
                                    "Usar soma vetorial em vez de cruzado",
                                    "Inverter a ordem no produto cruzado (direção errada)",
                                    "Incluir termos de spin desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Direção e Magnitude do Torque Resultante",
                                  "subSteps": [
                                    "Calcule magnitude: |τ| = |δ̇| |h| sinθ, onde θ é ângulo entre δ̇ e h (geralmente 90° para máximo).",
                                    "Determine direção via regra da mão direita: apontar dedos de δ̇ para h, polegar em τ.",
                                    "Discuta como torque é perpendicular tanto a δ̇ quanto h, criando ciclo de controle.",
                                    "Simule variação: se δ̇ || h, τ=0; otimize para θ=90°.",
                                    "Compare com roda de reação simples (torque via mudança em ω)."
                                  ],
                                  "verification": "Para h = [0,0,10] Nms, δ̇ = [0.1,0,0] rad/s, calcule τ e sua direção.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de vetores (MATLAB/Octave ou Python NumPy)",
                                    "Exemplo numérico pronto",
                                    "Gráficos de direção de torque"
                                  ],
                                  "tips": "Visualize em 3D: torque forma triângulo com δ̇ e h.",
                                  "learningObjective": "Interpretar física do torque: magnitude proporcional a δ̇ e h, direção perpendicular.",
                                  "commonMistakes": [
                                    "Confundir direção com produto escalar",
                                    "Ignorar sinθ na magnitude",
                                    "Pensar torque na direção de δ̇"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um satélite com CMG de h = 50 N m s (eixo z), gire o gimbal a δ̇ = 0.05 rad/s (eixo x). Calcule τ = [0, -2.5, 0] N m, que rotaciona o satélite em torno do eixo y. Simule em Python: use numpy.cross([0.05,0,0], [0,0,50]) para verificar.",
                              "finalVerifications": [
                                "Deriva corretamente τ = δ̇ × h a partir de dh/dt.",
                                "Calcula magnitude |τ| = |δ̇| |h| sinθ para ângulos dados.",
                                "Identifica direção de τ usando regra da mão direita em diagramas.",
                                "Explica por que CMGs produzem torque grande sem mudar spin.",
                                "Compara torque de CMG vs. roda de reação em eficiência.",
                                "Simula numericamente um caso com variação de θ."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação (equação final e passos corretos: 30%)",
                                "Correta análise vetorial de direção e magnitude (25%)",
                                "Uso apropriado de diagramas e visualizações (20%)",
                                "Compreensão conceitual via explicações em palavras próprias (15%)",
                                "Aplicação em exemplo numérico sem erros de cálculo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra vetorial e produtos cruzados.",
                                "Física: Mecânica clássica e dinâmica rotacional.",
                                "Engenharia de Controle: Geradores de torque em sistemas de feedback.",
                                "Computação: Simulações numéricas em Python/MATLAB para dinâmica.",
                                "Aeroespacial: Integração em controladores de atitude de satélites."
                              ],
                              "realWorldApplication": "CMGs baseados no princípio de precessão são usados na Estação Espacial Internacional (ISS) para controle de atitude preciso e eficiente em combustível, gerando torques de até 200 N m por unidade sem expelir massa, essencial para manobras orbitais longas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Configurações de Conjuntos de CMGs",
                            "description": "Estudar configurações pyramidais ou em pirâmide de 4 CMGs para cobertura esférica de torque, calcular o envelope de output e identificar singularidades gimbal onde o torque colapsa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as configurações pyramidais de 4 CMGs",
                                  "subSteps": [
                                    "Estudar a geometria piramidal: dois CMGs com ângulos de gimbal +54.74° e dois com -54.74° em relação ao eixo local vertical.",
                                    "Analisar a cobertura esférica de torque: entender como os vetores de momento se combinam para gerar torque em qualquer direção.",
                                    "Revisar os princípios de operação de CMGs individuais: rotação da roda de inércia e articulação do gimbal.",
                                    "Visualizar diagramas 3D das configurações pyramidais usando ferramentas de modelagem.",
                                    "Comparar com outras configurações (ex.: planar) para destacar vantagens da piramidal."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama da configuração piramidal mostrando ângulos e eixos, com cobertura esférica anotada.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livros de dinâmica de atitude (ex.: Sidi 'Spacecraft Dynamics and Control'), diagramas online de CMGs, software de visualização 3D como Blender ou MATLAB.",
                                  "tips": "Use animações 3D para visualizar rotações de gimbal; foque nos ângulos tetraédricos para simetria.",
                                  "learningObjective": "Dominar a geometria e princípios que permitem cobertura esférica de torque com 4 CMGs.",
                                  "commonMistakes": "Confundir ângulos de pirâmide (arccos(1/3) ≈ 54.74°) com 45°; ignorar a necessidade de skew para evitar singularidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a cinemática e dinâmica dos conjuntos de CMGs",
                                  "subSteps": [
                                    "Definir vetores de momento unitário para cada CMG: h_i = h * A_i(g_i), onde A_i é a matriz de direção do gimbal.",
                                    "Escrever a equação de torque total: τ = ∑ (h * dA_i/dg_i * ġ_i), com Jacobiana de gimbal.",
                                    "Implementar modelo matemático em software: matriz de Jacobiana J(g) para 4 CMGs pyramidais.",
                                    "Simular variações de ângulos de gimbal (g1 a g4) para gerar torques direcionais.",
                                    "Verificar propriedades de simetria na configuração piramidal."
                                  ],
                                  "verification": "Implementar e executar um script MATLAB/Python que compute torque para ângulos de gimbal aleatórios, plotando vetores resultantes.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB ou Python com NumPy/SciPy, referências como 'Spacecraft Attitude Determination and Control' de Wertz.",
                                  "tips": "Padronize notação: use ângulos gimbal δ_i e momento h constante; teste com valores simétricos primeiro.",
                                  "learningObjective": "Construir modelo matemático preciso para torque gerado por configurações de 4 CMGs.",
                                  "commonMistakes": "Esquecer o skew nos eixos de rotação; usar derivadas incorretas na Jacobiana, levando a torques nulos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o envelope de output de torque",
                                  "subSteps": [
                                    "Definir o envelope como o conjunto máximo de torques τ_max = h * ||J(g)|| para ||ġ|| ≤ ġ_max.",
                                    "Usar otimização numérica para mapear o envelope esférico: maximizar |τ| sujeito a limites de velocidade gimbal.",
                                    "Plotar o envelope em 3D: superfície delimitada por singularidades e limites de hardware.",
                                    "Analisar o volume do envelope e eficiência: comparar com configurações ideais.",
                                    "Implementar algoritmo de busca em grade ou convexo para pontos de envelope."
                                  ],
                                  "verification": "Gerar plot 3D do envelope de torque mostrando cobertura quase-esférica, com raio mínimo/máximo quantificado.",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB Optimization Toolbox ou Python CVXPY, exemplos de código de literatura aeroespacial.",
                                  "tips": "Comece com ġ_max = 1 rad/s; use simetria para reduzir computação em 1/8 da esfera.",
                                  "learningObjective": "Calcular e visualizar o envelope máximo de torque para validação de desempenho.",
                                  "commonMistakes": "Ignorar limites reais de ġ (tipicamente 0.5-2 rad/s); superestimar envelope sem considerar singularidades."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e analisar singularidades gimbal",
                                  "subSteps": [
                                    "Detectar singularidades onde det(J(g)) = 0 ou rank(J) < 3, perdendo cobertura de torque.",
                                    "Classificar tipos: gimbal lock (alinhamento planar) e pseudo-singularidades em pyramidais.",
                                    "Simular trajetórias que levam a singularidades e estratégias de escape (reativação).",
                                    "Mapear regiões de singularidade no espaço de ângulos gimbal (g1-g4).",
                                    "Analisar colapso de torque: plotar ||τ|| próximo a singularidades."
                                  ],
                                  "verification": "Identificar pelo menos 4 singularidades principais, plotando mapa de det(J) e trajetórias de evasão.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Mesmo software dos steps anteriores, papers sobre CMGs (ex.: NASA reports on ISS CMGs).",
                                  "tips": "Use SVD para rank(J); evite singularidades mantendo ângulos skew > 30°.",
                                  "learningObjective": "Reconhecer e mitigar singularidades onde torque colapsa, garantindo operação robusta.",
                                  "commonMistakes": "Confundir singularidades de configuração com limites de hardware; não testar evasão em simulações."
                                }
                              ],
                              "practicalExample": "Em um satélite de observação terrestre, configure 4 CMGs pyramidais para manter atitude precisa durante manobras de apontamento. Calcule envelope para h=50 Nms, ġ_max=1 rad/s, simulando slews de 10°/s sem entrar em singularidades.",
                              "finalVerifications": [
                                "Diagrama da configuração piramidal com ângulos corretos e cobertura esférica.",
                                "Modelo de Jacobiana implementado e testado com torques em 6 direções cardinais.",
                                "Plot do envelope de torque mostrando volume >95% esférico.",
                                "Mapa de singularidades com pelo menos 3 exemplos de colapso de torque.",
                                "Simulação de manobra real evitando singularidades por >90% do tempo.",
                                "Relatório quantificando eficiência: raio médio do envelope e taxa de singularidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão geométrica: ângulos de pirâmide exatos (±0.1°).",
                                "Corretude matemática: Jacobiana gera torques consistentes com literatura (±5%).",
                                "Qualidade do envelope: plot 3D com cobertura esférica quantificada.",
                                "Análise de singularidades: detecção via SVD/determinante com exemplos válidos.",
                                "Implementação prática: código executável e comentado.",
                                "Compreensão conceitual: explicação clara de colapso de torque em relatório."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes Jacobianas, SVD), otimização convexa.",
                                "Física: Dinâmica de corpo rígido, conservação de momento angular.",
                                "Programação: Simulação numérica (MATLAB/Python), visualização 3D (Matplotlib/Plotly).",
                                "Engenharia de Controle: Cinemática de manipuladores, análise de singularidades robóticas.",
                                "Geometria Computacional: Mapeamento esférico e envelopes de performance."
                              ],
                              "realWorldApplication": "Estações espaciais como a ISS utilizam configurações pyramidais de 4 CMGs para controle de atitude preciso e eficiente, evitando uso de propulsores e economizando combustível, com envelopes calculados para manobras orbitais e correções de perturbações gravitacionais."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Estratégias de Evitação de Singularidades",
                            "description": "Implementar algoritmos de steering law para modulação das taxas gimbal e evitar singularidades, incluindo simulação numérica de manobras de atitude com CMGs em software de dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Singularidades em CMGs",
                                  "subSteps": [
                                    "Estudar a cinemática de Control Moment Gyros (CMGs) e o conceito de momento de controle angular.",
                                    "Analisar o Jacobiano de gimbal e identificar configurações de singularidade (degeneradas).",
                                    "Revisar tipos de singularidades: singularidades de direção zero, de alcance e de momentum.",
                                    "Explorar impactos das singularidades na capacidade de controle de atitude.",
                                    "Visualizar geometricamente o poliedro de momento usando diagramas."
                                  ],
                                  "verification": "Resumir em um diagrama os tipos de singularidades e suas implicações em um relatório curto.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livros de dinâmica de atitude (ex: Sidi 'Spacecraft Dynamics and Control'), artigos sobre CMGs, software de visualização como MATLAB.",
                                  "tips": "Use animações 3D para visualizar rotações de gimbal e perda de torque.",
                                  "learningObjective": "Dominar os conceitos teóricos de singularidades e sua detecção em configurações de CMGs.",
                                  "commonMistakes": "Confundir singularidades com saturação de gimbal; ignorar o papel do Jacobiano."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Leis de Steering para Modulação de Taxas de Gimbal",
                                  "subSteps": [
                                    "Aprender algoritmos clássicos de steering law, como o de Margulies e Akella.",
                                    "Entender a modulação de velocidades de gimbal para maximizar o torque disponível.",
                                    "Implementar pseudocódigo para detecção de proximidade de singularidades.",
                                    "Analisar métricas de performance: eficiência de steering e evasão de singularidades.",
                                    "Comparar leis de steering reativas vs. preditivas."
                                  ],
                                  "verification": "Implementar um pseudocódigo simples e testá-lo com configurações sintéticas.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Papers IEEE sobre steering laws (ex: 'Singularity Avoidance for CMGs'), Python ou MATLAB para prototipagem.",
                                  "tips": "Priorize leis que minimizem desvios de torque desejado.",
                                  "learningObjective": "Compreender e selecionar leis de steering adequadas para evitar singularidades.",
                                  "commonMistakes": "Escolher leis que causem oscilações excessivas nas taxas de gimbal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar Matematicamente o Sistema de CMGs",
                                  "subSteps": [
                                    "Definir o modelo matemático: vetores de momento de roda e Jacobiano A(γ).",
                                    "Derivar equações de dinâmica de atitude com CMGs: ω̇ = J^{-1} (τ_cmgs - ω × h).",
                                    "Implementar detecção de singularidade via decomposição SVD do Jacobiano.",
                                    "Calcular taxas de gimbal: γ̇ = A^+ u, com evasão via steering law.",
                                    "Validar modelo com casos analíticos conhecidos."
                                  ],
                                  "verification": "Resolver numericamente um caso simples e comparar com resultados teóricos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB/Simulink ou Python (NumPy, SciPy), referências matemáticas de álgebra linear.",
                                  "tips": "Use SVD para métricas robustas de singularidade (σ_min < threshold).",
                                  "learningObjective": "Construir um modelo matemático preciso para simulação de CMGs.",
                                  "commonMistakes": "Negligenciar conservação de momento angular total do sistema."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Algoritmo de Steering Law em Software",
                                  "subSteps": [
                                    "Codificar a lei de steering em Python/MATLAB, integrando com o modelo dinâmico.",
                                    "Adicionar lógica de detecção e evasão de singularidades em tempo real.",
                                    "Integrar controlador de atitude (ex: PD ou LQR) com o atuador CMG.",
                                    "Testar unitariamente com perfis de comando de torque variados.",
                                    "Otimizar parâmetros da steering law para minimizar uso de combustível."
                                  ],
                                  "verification": "Executar testes unitários e confirmar evasão em cenários próximos a singularidades.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Ambiente de programação (Python com SciPy/Control, MATLAB Aerospace Toolbox).",
                                  "tips": "Implemente em loop fechado com step size pequeno para estabilidade.",
                                  "learningObjective": "Desenvolver código funcional para controle de CMGs com evasão de singularidades.",
                                  "commonMistakes": "Usar inversa direta do Jacobiano em vez de pseudoinversa."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simular e Analisar Manobras de Atitude Numéricas",
                                  "subSteps": [
                                    "Definir cenários de manobra: apontamento rápido, slew de 90 graus, evasão de singularidade.",
                                    "Executar simulações com ruído e perturbações realistas.",
                                    "Analisar métricas: erro de atitude, taxas de gimbal, consumo de momentum.",
                                    "Visualizar trajetórias de gimbal e poliedro de momento.",
                                    "Iterar otimizações baseadas em resultados."
                                  ],
                                  "verification": "Gerar gráficos de erro < 1° e evasão bem-sucedida em todos os casos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Software de simulação (MATLAB Simulink ou Python com ODE solvers).",
                                  "tips": "Registre singular value mínimo ao longo da simulação para validar evasão.",
                                  "learningObjective": "Validar o algoritmo através de simulações realistas de manobras.",
                                  "commonMistakes": "Simular sem desvio inicial de singularidade, mascarando problemas."
                                }
                              ],
                              "practicalExample": "Simule uma manobra de slew de 180° em um satélite com 4 CMGs pyramidais, iniciando próximo a uma singularidade de direção zero. Aplique steering law para modular γ̇, mantendo erro de quaternion abaixo de 0.01 e evitando σ_min < 0.1.",
                              "finalVerifications": [
                                "O algoritmo evade singularidades em todas as simulações testadas (σ_min > threshold).",
                                "Erro de atitude RMS < 0.5° em manobras nominais.",
                                "Taxas de gimbal dentro de limites físicos (±5°/s).",
                                "Conservação de momento angular total verificada.",
                                "Tempo de computação < 1 ms por ciclo para tempo real.",
                                "Robustez a ruído de sensores demonstrada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção e evasão de singularidades (90%+ sucesso).",
                                "Eficiência da modulação de gimbal (desvio de torque < 10%).",
                                "Qualidade da simulação numérica (estabilidade e precisão).",
                                "Clareza e modularidade do código implementado.",
                                "Análise quantitativa completa com métricas e gráficos.",
                                "Documentação de resultados e lições aprendidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (SVD, pseudoinversas) e equações diferenciais.",
                                "Programação: Numérica (ODE solvers) e visualização de dados.",
                                "Física: Dinâmica rotacional e conservação de momento angular.",
                                "Engenharia de Controle: Controladores estatais e otimização."
                              ],
                              "realWorldApplication": "Em satélites como o Hubble ou estações espaciais (ISS usa CMGs), onde steering laws evitam singularidades durante manobras de apontamento preciso, garantindo longevidade da missão sem intervenção humana."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.4",
                            "name": "Comparação com Rodas de Reação Fixas",
                            "description": "Comparar vantagens (maior torque) e desvantagens (complexidade, singularidades, consumo de potência) das rodas com gimbal versus rodas fixas em cenários de controle de atitude de longa duração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Funcionamento das Rodas de Reação Fixas (Reaction Wheels - RWs)",
                                  "subSteps": [
                                    "Estude o princípio básico: aceleração de uma roda flywheel para gerar torque reativo no veículo espacial via conservação de momento angular.",
                                    "Analise os eixos de rotação fixos (geralmente 3 ortogonais) e como eles fornecem controle em 3 graus de liberdade.",
                                    "Explore limitações como saturação de momento angular, requerendo desaturação periódica com thrusters.",
                                    "Revise equações fundamentais: torque τ = I α, onde I é inércia da roda e α aceleração angular.",
                                    "Simule um exemplo simples de mudança de atitude usando software como MATLAB ou Python."
                                  ],
                                  "verification": "Explique em um parágrafo como uma RW controla a atitude sem expelir massa e liste suas limitações principais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Texto de dinâmica de atitude (ex: Sidi 'Spacecraft Dynamics and Control')",
                                    "Vídeos Khan Academy sobre momento angular",
                                    "MATLAB/Simulink ou Python com NumPy/SciPy"
                                  ],
                                  "tips": "Visualize o sistema como um patinador girando os braços para girar o corpo.",
                                  "learningObjective": "Descrever precisamente o mecanismo de controle de atitude usando RWs e suas restrições inerentes.",
                                  "commonMistakes": [
                                    "Confundir torque gerado com força linear",
                                    "Ignorar a necessidade de desaturação em missões longas",
                                    "Assumir controle ilimitado sem saturação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Funcionamento das Rodas de Reação com Gimbal (Control Moment Gyros - CMGs)",
                                  "subSteps": [
                                    "Aprenda o conceito: roda flywheel com gimbal permitindo orientação variável do eixo de rotação para gerar torque direcional via momento de controle.",
                                    "Estude configurações comuns como cluster de 4 CMGs em pirâmide para cobertura total sem singularidades internas.",
                                    "Analise o torque gerado: h × ω_g, onde h é momento angular da roda e ω_g taxa de gimbal.",
                                    "Identifique singularidades de gimbal: configurações onde torque é zero apesar de potência aplicada.",
                                    "Compare inerentemente com RWs: maior torque disponível sem mudança de velocidade da roda."
                                  ],
                                  "verification": "Desenhe um diagrama de um CMG mostrando vetores de momento e gimbal, explicando como torque é maximizado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigo NASA sobre CMGs",
                                    "Simulador online de atuadores espaciais",
                                    "Ferramentas de visualização 3D como Blender ou GMAT"
                                  ],
                                  "tips": "Pense no gimbal como um 'braço' que direciona o 'peso' da roda para torque ótimo.",
                                  "learningObjective": "Explicar como o gimbal amplifica torque em CMGs e introduz complexidades únicas.",
                                  "commonMistakes": [
                                    "Confundir CMG com RW simples",
                                    "Subestimar consumo de potência no gimbal",
                                    "Ignorar singularidades como falhas de design"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Vantagens e Desvantagens em Termos de Desempenho",
                                  "subSteps": [
                                    "Liste vantagens das CMGs: torque muito maior (até 10x) devido a momento de controle vs aceleração direta.",
                                    "Compare desvantagens: maior complexidade mecânica, consumo de potência contínuo no gimbal, vulnerabilidade a singularidades.",
                                    "Calcule exemplos numéricos: torque máx RW ~0.1 Nm vs CMG ~10 Nm para roda similar.",
                                    "Avalie eficiência energética: RWs eficientes em repouso, CMGs consomem para manter gimbal.",
                                    "Crie uma tabela comparativa de parâmetros chave (torque, massa, potência, confiabilidade)."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 métricas quantitativas e qualitativas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilhas Excel/Google Sheets para tabelas",
                                    "Dados técnicos de satélites reais (ex: Hubble RW vs ISS CMG)",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use unidades consistentes (Nm, W, kg) para comparações justas.",
                                  "learningObjective": "Quantificar e qualificar trade-offs entre CMGs e RWs em métricas chave.",
                                  "commonMistakes": [
                                    "Superestimar torque RW sem considerar inércia",
                                    "Ignorar massa extra dos gimbals",
                                    "Não considerar contexto de missão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Aplicabilidade em Cenários de Controle de Atitude de Longa Duração",
                                  "subSteps": [
                                    "Defina cenários: missões LEO/GEO com perturbações contínuas (gradiente gravitacional, pressão solar).",
                                    "Avalie RWs: saturação rápida em manobras finas prolongadas, requerendo thrusters (custo propelente).",
                                    "Avalie CMGs: ideal para longa duração sem desaturação frequente, mas gerencie singularidades com algoritmos.",
                                    "Simule um caso: controle de satélite por 1 ano, comparando consumo de potência/propelente.",
                                    "Conclua trade-offs: CMGs para alta performance longa, RWs para simplicidade/missões curtas."
                                  ],
                                  "verification": "Produza um relatório curto (1 página) recomendando atuador para uma missão específica com justificativa.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software de simulação orbital (ex: STK, Orekit)",
                                    "Dados de missões reais (ex: ISS CMG logs)",
                                    "Templates de relatório LaTeX/Word"
                                  ],
                                  "tips": "Considere ciclo de vida total: custo inicial vs operacional.",
                                  "learningObjective": "Aplicar comparação a contextos reais de missões espaciais de longa duração.",
                                  "commonMistakes": [
                                    "Generalizar sem contexto de perturbações",
                                    "Esquecer redundância em clusters",
                                    "Subestimar falhas mecânicas em CMGs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um satélite geoestacionário mantendo apontamento preciso por 10 anos, use CMGs para rejeitar perturbações diárias sem thrusters frequentes, simulando em MATLAB: compare saturação RW (diária) vs CMG (mensal com evasão de singularidades).",
                              "finalVerifications": [
                                "Liste e explique 3 vantagens principais das CMGs sobre RWs em torque e duração.",
                                "Descreva 2 tipos de singularidades de gimbal e como evitá-las.",
                                "Calcule torque relativo para roda de 10 kg m² a 5000 rpm em ambas configurações.",
                                "Justifique escolha de atuador para missão de 5 anos em LEO com perturbações moderadas.",
                                "Crie tabela de prós/contras com pelo menos 4 itens cada."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de princípios (torque, momento angular).",
                                "Profundidade na comparação quantitativa (números, equações).",
                                "Análise contextualizada para longa duração (saturação vs singularidades).",
                                "Clareza na comunicação (diagramas, tabelas usadas).",
                                "Identificação correta de trade-offs reais (complexidade vs performance).",
                                "Criatividade em exemplos/simulações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para vetores de momento e matrizes de Jacobiano em singularidades.",
                                "Física: Dinâmica rotacional e conservação de momento angular.",
                                "Engenharia de Controle: Algoritmos de steer law para evasão de singularidades.",
                                "Ciência de Materiais: Impacto de fadiga mecânica em gimbals vs rolamentos de RW.",
                                "Gestão de Projetos: Análise custo-benefício em seleção de atuadores espaciais."
                              ],
                              "realWorldApplication": "Na Estação Espacial Internacional (ISS), CMGs fornecem controle de atitude de alta precisão por anos sem propelente excessivo, permitindo experimentos científicos contínuos, enquanto RWs são usadas em satélites menores como CubeSats por simplicidade e baixo custo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.3",
                              "10.1.2.4.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Simulação de Estabilização e Manobras de Atitude",
                    "description": "Simulação computacional para controle de estabilização e execução de manobras de atitude em veículos espaciais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Determinação de Atitude a partir de Sensores",
                        "description": "Conceitos fundamentais para estimar a orientação (atitude) de veículos espaciais utilizando dados de diversos sensores, essenciais para a simulação precisa de estabilização e manobras.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Uso de Sensores Terrestres Infravermelho",
                            "description": "Implementar algoritmos para determinar a atitude do veículo espacial processando medidas de sensores infravermelhos terrestres, considerando ruído e calibração para simulações realistas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Princípios dos Sensores Infravermelhos Terrestres",
                                  "subSteps": [
                                    "Estude a física da detecção infravermelha terrestre, focando em emissividade e temperatura da superfície da Terra.",
                                    "Analise como a atitude do veículo afeta o vetor de medida do sensor IR.",
                                    "Revise coordenadas: inercial, corpo do veículo e campo de visão do sensor.",
                                    "Explore exemplos de uso em satélites para determinação de atitude.",
                                    "Identifique fontes de erro como variação atmosférica e geometria orbital."
                                  ],
                                  "verification": "Resuma em um diagrama os vetores de medida IR em diferentes atitudes e liste 3 fontes de erro principais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação técnica de sensores IR espaciais (ex: NASA reports)",
                                    "Software de visualização 3D como Blender ou MATLAB para diagramas"
                                  ],
                                  "tips": "Use animações para visualizar rotação do veículo em relação à Terra.",
                                  "learningObjective": "Compreender como sensores IR terrestres fornecem medidas dependentes da atitude do veículo.",
                                  "commonMistakes": [
                                    "Ignorar a curvatura da Terra em modelagens simples",
                                    "Confundir coordenadas de corpo com inercial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Sensor e Calibração",
                                  "subSteps": [
                                    "Defina o modelo geométrico: direção do boresight e campo de visão (FOV).",
                                    "Escreva equações para o vetor unitário apontando para o centro da Terra em função da atitude.",
                                    "Implemente calibração: ajuste parâmetros como offset e ganho usando dados simulados.",
                                    "Crie uma matriz de calibração para compensar desalinhamentos.",
                                    "Teste o modelo com atitudes conhecidas."
                                  ],
                                  "verification": "Gere medidas modelo para 5 atitudes conhecidas e compare com valores esperados (erro < 1°).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Jupyter Notebook para prototipagem"
                                  ],
                                  "tips": "Comece com órbita circular baixa para simplificar geometria.",
                                  "learningObjective": "Desenvolver um modelo matemático preciso do sensor IR incluindo calibração.",
                                  "commonMistakes": [
                                    "Não linearizar o modelo para pequenas atitudes",
                                    "Esquecer de normalizar vetores unitários"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Medidas com Ruído e Perturbações Realistas",
                                  "subSteps": [
                                    "Gere trajetória orbital realista usando SGP4 ou modelo kepleriano.",
                                    "Adicione ruído gaussiano às medidas (σ típico de 0.1-1°).",
                                    "Inclua biases e ruído correlacionado para realismo.",
                                    "Simule múltiplas medições ao longo de uma órbita.",
                                    "Visualize distribuições de erro em gráficos."
                                  ],
                                  "verification": "Plotar 100 medições simuladas vs. verdade e confirmar estatísticas de ruído (média ~0, desvio ~σ).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB ou Python (astropy para órbitas)",
                                    "Bibliotecas: Orekit ou poliastro"
                                  ],
                                  "tips": "Use seeds fixos para reprodutibilidade em testes.",
                                  "learningObjective": "Gerar dados de sensor realistas para treinamento de algoritmos.",
                                  "commonMistakes": [
                                    "Ruído excessivamente alto/low sem base física",
                                    "Não sincronizar tempo de simulação com amostragem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Algoritmo de Determinação de Atitude",
                                  "subSteps": [
                                    "Escolha método: QUEST ou least-squares para múltiplas medições.",
                                    "Formule o problema como minimização de custo: ||y - H(q)||^2 onde q é quaternion de atitude.",
                                    "Inclua pesos para calibração e ruído covariância.",
                                    "Implemente filtro (ex: EKF) para processamento sequencial.",
                                    "Otimize com gradiente descendente ou analítico."
                                  ],
                                  "verification": "Aplique a 10 conjuntos de dados simulados; erro RMS de atitude < 0.5°.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com SciPy.optimize e pyquaternion",
                                    "Código base de QUEST algorithm"
                                  ],
                                  "tips": "Use quaternions para evitar gimbal lock.",
                                  "learningObjective": "Criar algoritmo robusto que estima atitude a partir de medidas IR ruidosas.",
                                  "commonMistakes": [
                                    "Singularidades em representações Euler",
                                    "Não tratar ambiguidade de 180° em roll"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Integrar em Simulação de Veículo",
                                  "subSteps": [
                                    "Integre o algoritmo em simulador de dinâmica de atitude (6DOF).",
                                    "Execute simulação fechada com atuadores (RWGs) e perturbações.",
                                    "Compare estimada vs. verdade ao longo de manobras.",
                                    "Analise convergência e sensibilidade a parâmetros.",
                                    "Gere relatório com métricas de performance."
                                  ],
                                  "verification": "Simulação de 1 órbita: erro médio < 0.3°, max < 2°.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Simulador como JSBSIM ou custom Python com scipy.integrate",
                                    "Ferramentas de plotting: Matplotlib"
                                  ],
                                  "tips": "Teste cenários edge como eclipse ou alta latitude.",
                                  "learningObjective": "Demonstrar funcionamento do sistema em ambiente simulado completo.",
                                  "commonMistakes": [
                                    "Integração numérica instável",
                                    "Ignorar delays de processamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de satélite CubeSat em órbita LEO (500km), use sensores IR terrestres para estimar atitude durante uma manobra de apontamento para downlink. Processe 20 medições por órbita com ruído de 0.5°, calibração via least-squares, alcançando precisão de 0.2° após 5 minutos.",
                              "finalVerifications": [
                                "Algoritmo estima atitude com erro RMS < 0.5° em dados ruidosos.",
                                "Calibração reduz bias em >90%.",
                                "Simulação fechada mantém estabilidade durante manobras.",
                                "Código roda em tempo real (<1s por ciclo).",
                                "Relatório inclui análise de sensibilidade a ruído.",
                                "Visualizações confirmam convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimação: erro <1° em 95% dos casos.",
                                "Robustez a ruído: performance degradada <20% com 2x ruído.",
                                "Eficiência computacional: <100ms por iteração.",
                                "Documentação: código comentado e equações derivadas.",
                                "Validação: testes com 50+ cenários variados.",
                                "Integração: compatível com simuladores padrão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (quaternions, minimização), Estatística (covariância de ruído).",
                                "Programação: Otimização numérica (SciPy), Simulação dinâmica.",
                                "Física: Óptica infravermelha, Dinâmica orbital.",
                                "Engenharia: Sistemas embarcados, Controle de atitude.",
                                "Ciência de Dados: Processamento de sinais ruidosos."
                              ],
                              "realWorldApplication": "Em missões como o James Webb Space Telescope ou CubeSats para Earth observation, sensores IR terrestres fornecem estimativa de atitude autônoma de baixo custo, essencial para aquisição de imagens precisas e docking orbital, reduzindo dependência de GPS ou star trackers em cenários oclusos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Processamento de Sensores Solares",
                            "description": "Desenvolver métodos computacionais para estimar atitude a partir de sensores solares, modelando a posição do Sol e vetores de entrada para integração em simulações de controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos de Sensores Solares e Cinemática Orbital",
                                  "subSteps": [
                                    "Estude o princípio de funcionamento de sensores solares (fotodiodos ou células solares que medem intensidade luminosa).",
                                    "Revise coordenadas celestes: equatorial (RA/Dec), horizonte e ECI (Earth-Centered Inertial).",
                                    "Aprenda a relação entre atitude do veículo espacial e vetores de entrada solar.",
                                    "Explore limitações: obstruções, campo de visão e ruído.",
                                    "Pratique conversão de coordenadas usando exemplos simples."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes de um sensor solar e suas saídas esperadas para diferentes atitudes.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Livro 'Spacecraft Attitude Determination and Control' (Wertz), Notebook Jupyter, Documentação de sensores solares (ex: AdCSS-301)"
                                  ],
                                  "tips": "Use visualizações 3D para entender vetores incidentes; comece com casos ideais sem atmosfera.",
                                  "learningObjective": "Compreender como sensores solares fornecem medições parciais da atitude via direção do Sol.",
                                  "commonMistakes": [
                                    "Confundir coordenadas ECI com ECF",
                                    "Ignorar o campo de visão cônico do sensor",
                                    "Subestimar efeitos de sombreamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelagem da Posição do Sol",
                                  "subSteps": [
                                    "Implemente o modelo analítico da posição do Sol em coordenadas ECI usando elementos orbitais solares.",
                                    "Calcule o vetor unitário do Sol para uma data/época específica com fórmulas de Meeus ou VSOP87.",
                                    "Desenvolva funções em Python/MATLAB para propagar a posição solar ao longo do tempo.",
                                    "Valide contra bibliotecas como Skyfield ou Orekit.",
                                    "Teste para diferentes órbitas LEO/GEO."
                                  ],
                                  "verification": "Compare sua função com uma biblioteca padrão; erro < 0.1° em posição.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Biblioteca Python Skyfield ou PyEphem",
                                    "MATLAB Aerospace Toolbox",
                                    "Documentação VSOP87"
                                  ],
                                  "tips": "Use datas julianas para precisão; evite aproximações de baixo ordem para missões longas.",
                                  "learningObjective": "Modelar precisamente a direção do Sol como referência inercial para determinação de atitude.",
                                  "commonMistakes": [
                                    "Erro em precessão/nutação",
                                    "Uso incorreto de constantes astronômicas",
                                    "Não converter para vetor unitário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Algoritmos de Processamento e Estimativa de Atitude",
                                  "subSteps": [
                                    "Implemente o modelo de sensor: cosθ = S · u_sun, onde S é vetor de sensibilidade, u_sun é direção solar.",
                                    "Desenvolva o algoritmo TRIAD para estimativa inicial usando dois vetores (Sol + referência).",
                                    "Aplique filtros (ex: Kalman) para múltiplas medições, lidando com ambiguidades (roll 180°).",
                                    "Gere simulações de dados com ruído gaussiano e teste convergência.",
                                    "Otimize para hardware embarcado (baixa complexidade computacional)."
                                  ],
                                  "verification": "Execute simulação: RMSE de atitude < 5° com ruído realista.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Python (NumPy, SciPy), MATLAB Simulink",
                                    "Código exemplo de TRIAD do GitHub (NASA repos)"
                                  ],
                                  "tips": "Sempre normalize vetores; use QUEST para melhor precisão se >2 sensores.",
                                  "learningObjective": "Processar medições solares para estimar matriz de atitude DCM com precisão aceitável.",
                                  "commonMistakes": [
                                    "Não tratar ambiguidades de sinal",
                                    "Ignorar calibração de sensores",
                                    "Sobrecarga computacional em loops"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração em Simulações de Controle de Atitude",
                                  "subSteps": [
                                    "Integre o estimador solar em um simulador de dinâmica de atitude (6DOF).",
                                    "Combine com outros sensores (magnetômetro, giroscópio) em um filtro EKF/UKF.",
                                    "Teste cenários: aquisição inicial, manobras, falhas de sensores.",
                                    "Avalie desempenho em loop fechado com atuadores (RW, magnetorquers).",
                                    "Documente código e gere relatórios de performance."
                                  ],
                                  "verification": "Simule missão completa: tempo de convergência < 10 min, erro estacionário < 2°.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Simulador Orekit ou GMAT",
                                    "Biblioteca PyKEP para propagação orbital"
                                  ],
                                  "tips": "Use quaternion para representação de atitude; inicialize com modelo coarse.",
                                  "learningObjective": "Incorporar processamento solar em sistemas de controle autônomo de atitude.",
                                  "commonMistakes": [
                                    "Desacoplamento inadequado de dinâmica",
                                    "Falta de modelagem de delays",
                                    "Ignorar covariâncias no filtro"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat em órbita LEO, use 6 sensores solares para determinar atitude durante eclipse solar parcial; implemente TRIAD para aquisição rápida e integre ao controlador PD para apontamento nadir.",
                              "finalVerifications": [
                                "Modelo solar reproduz posição com erro < 0.05° vs. ephemerides.",
                                "Estimativa de atitude converge em <5 min com ruído 10%.",
                                "Integração em simulação mantém erro <3° em manobra de 90°.",
                                "Código roda em tempo real (<1s por ciclo).",
                                "Relatório documenta trade-offs (precisão vs. computação).",
                                "Testes de robustez passam para 100 Monte Carlo runs."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem solar (erro angular <0.1°).",
                                "Convergência e estabilidade do estimador de atitude.",
                                "Eficiência computacional para embarcado.",
                                "Robustez a ruído, falhas e ambiguidades.",
                                "Qualidade da integração em simulação fechada.",
                                "Clareza e modularidade do código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (vetores, quaternions, DCM), Cinemática orbital.",
                                "Programação: Numéricos (filtros Kalman), Simulação (ODE solvers).",
                                "Física: Astronomia posicional, Óptica de sensores.",
                                "Engenharia: Sistemas embarcados, Controle automático."
                              ],
                              "realWorldApplication": "Satélites CubeSat (ex: missions universitárias como QB50), estações espaciais (backup para STAR trackers), sondas interplanetárias para aquisição de atitude em deep space."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Integração de Sensores de Estrelas",
                            "description": "Simular catálogos de estrelas e algoritmos de reconhecimento para determinação precisa de atitude, incluindo filtros de Kalman para fusão de dados em cenários dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração e Simulação de Catálogos de Estrelas",
                                  "subSteps": [
                                    "Pesquise e baixe um catálogo de estrelas reais, como o Hipparcos ou Gaia DR3, focando em estrelas brilhantes visíveis (magnitudes < 6).",
                                    "Implemente um modelo 3D para simular a posição aparente das estrelas no céu de um satélite, usando coordenadas celestiais (RA/DEC) e transformações de rotação.",
                                    "Crie uma função para gerar imagens simuladas de estrelas com ruído gaussiano e distorções de lente.",
                                    "Valide o catálogo gerando um céu estrelado para uma atitude conhecida e comparando com imagens reais.",
                                    "Adicione parâmetros dinâmicos como rotação da Terra e movimento orbital."
                                  ],
                                  "verification": "Gere uma imagem simulada e confirme que pelo menos 95% das estrelas do catálogo aparecem nas posições corretas quando comparadas a uma rotação identidade.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Catálogo Hipparcos (CSV)",
                                    "Python com bibliotecas Astropy, NumPy, Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use coordenadas equatoriais para simplicidade inicial; normalize vetores de direção para evitar erros numéricos.",
                                  "learningObjective": "Compreender e simular catálogos estelares realistas para observações de sensores.",
                                  "commonMistakes": [
                                    "Ignorar precessão das estrelas",
                                    "Usar magnitudes sem filtro de visibilidade",
                                    "Não converter unidades de ângulo corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolvimento de Algoritmo de Reconhecimento de Estrelas",
                                  "subSteps": [
                                    "Implemente detecção de estrelas em imagens usando threshold adaptativo e centroiding (ex: OpenCV StarDetector).",
                                    "Crie um banco de dados de padrões estelares (lost-in-space algorithm como Pyramid ou Sphere).",
                                    "Aplique matching de grafos ou k-vetor nearest neighbor para identificar estrelas candidatas.",
                                    "Calcule scores de confiança baseados em ângulos entre estrelas e rejeite falsos positivos.",
                                    "Teste com imagens rotacionadas e com ruído crescente."
                                  ],
                                  "verification": "Aplique o algoritmo a 10 imagens simuladas com rotações aleatórias; taxa de reconhecimento > 90%.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "OpenCV, SciPy para matching",
                                    "Catálogo do Step 1",
                                    "Imagens de teste geradas"
                                  ],
                                  "tips": "Limite o número de estrelas bright para reduzir complexidade computacional; use KD-Tree para buscas rápidas.",
                                  "learningObjective": "Construir um robusto reconhecedor de estrelas autônomo.",
                                  "commonMistakes": [
                                    "Sobrecarregar com muitas estrelas fracas",
                                    "Não lidar com oclusões parciais",
                                    "Matching sem validação angular"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Cálculo de Atitude a partir de Observações de Estrelas",
                                  "subSteps": [
                                    "Converta observações de pixels para vetores unitários no campo de visão do sensor.",
                                    "Use pelo menos duas estrelas reconhecidas para estimar a matriz de rotação (QUEST ou Wahba's problem).",
                                    "Implemente solução analítica com SVD para quaternion de atitude.",
                                    "Calcule covariância da estimativa e bounds de erro.",
                                    "Integre múltiplas observações sequenciais para refinar."
                                  ],
                                  "verification": "Para atitude conhecida, erro de quaternion < 0.1 graus em simulações sem ruído.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "NumPy, SciPy.linalg para SVD",
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": "Sempre normalize quaternions; use ângulos pequenos para aproximações iniciais.",
                                  "learningObjective": "Determinar atitude precisa usando observações estelares.",
                                  "commonMistakes": [
                                    "Não resolver ambiguidade de 180 graus em soluções QUEST",
                                    "Ignorar covariância no cálculo",
                                    "Erro em transformação pixel-para-vetor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração de Filtro de Kalman para Fusão de Dados Dinâmicos",
                                  "subSteps": [
                                    "Modele dinâmica de atitude com propagador (ex: cinemática de quaternions + torque).",
                                    "Defina estado estendido (quaternion + velocidades angulares) e matrizes de transição/processo.",
                                    "Implemente EKF (Extended Kalman Filter) com medições de estrelas como updates.",
                                    "Adicione ruído processual e de sensor realista; tune covariâncias Q e R.",
                                    "Simule loop fechado com taxas de amostragem variáveis."
                                  ],
                                  "verification": "Em simulação dinâmica com ruído, erro RMS de atitude < 0.05 graus após convergência.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "FilterPy ou implementação custom em NumPy",
                                    "Modelo dinâmico simples"
                                  ],
                                  "tips": "Linearize Jacobian numericamente se analítico for complexo; monitore divergência do filtro.",
                                  "learningObjective": "Fusar dados de estrelas com dinâmica para estimativa robusta em movimento.",
                                  "commonMistakes": [
                                    "Jacobianas incorretas no EKF",
                                    "Covariâncias mal tunadas causando instabilidade",
                                    "Representação não consistente de atitude"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes e Validação em Cenários Dinâmicos",
                                  "subSteps": [
                                    "Crie cenários: aquisição lost-in-space, manobras slew, vibrações orbitais.",
                                    "Execute Monte Carlo com 100 runs variando ruído e falhas de sensor.",
                                    "Analise métricas: tempo de convergência, precisão, taxa de falha.",
                                    "Otimize hiperparâmetros via grid search.",
                                    "Documente relatório com plots de erro vs tempo."
                                  ],
                                  "verification": "Relatório mostra performance estável em todos cenários (erro < 0.1 graus, 95% runs).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Códigos integrados",
                                    "Matplotlib/Seaborn para análise"
                                  ],
                                  "tips": "Use paralelização para Monte Carlo; grave seeds para reprodutibilidade.",
                                  "learningObjective": "Validar sistema completo em condições realistas.",
                                  "commonMistakes": [
                                    "Poucas runs em Monte Carlo",
                                    "Ignorar cenários edge como baixa visibilidade",
                                    "Plots sem estatísticas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita baixa da Terra executando uma manobra de apontamento: use o catálogo Hipparcos para gerar observações de estrelas durante rotação a 1 deg/s, aplique reconhecimento para identificar 5 estrelas, calcule atitude inicial via QUEST, e fuse com EKF considerando dinâmica orbital. Verifique recuperação de atitude em <10s.",
                              "finalVerifications": [
                                "Sistema reconhece estrelas com >90% acurácia em imagens ruidosas.",
                                "Estimativa de atitude sem filtro tem erro <0.5 graus.",
                                "Com EKF, erro RMS <0.05 graus em dinâmica.",
                                "Convergência em <5s para lost-in-space.",
                                "Robustez a 20% falhas de detecção.",
                                "Análise Monte Carlo confirma consistência."
                              ],
                              "assessmentCriteria": [
                                "Precisão da atitude final (erro quaternion <10^-4).",
                                "Eficiência computacional (<100ms por ciclo).",
                                "Robustez a ruído (desvio padrão de entrada variado).",
                                "Taxa de sucesso em cenários dinâmicos (>95%).",
                                "Qualidade do código (modular, comentado, testes unitários).",
                                "Relatório completo com visualizações e métricas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (SVD, quaternions), Probabilidade (Kalman).",
                                "Física/Astronomia: Cinemática orbital, coordenadas celestrais.",
                                "Programação: Processamento de imagens (OpenCV), Simulação numérica.",
                                "Engenharia de Controle: Estimadores de estado, fusão sensorial.",
                                "Ciência de Dados: Otimização de hiperparâmetros, análise estatística."
                              ],
                              "realWorldApplication": "Em satélites como o Hubble Space Telescope ou CubeSats da NASA, sensores de estrelas (Star Trackers) fornecem atitude precisa para apontamento de antenas/payloads, essencial para comunicações, imageamento terrestre e missões interplanetárias, tolerando vibrações e órbitas dinâmicas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.4",
                            "name": "Aplicação de Sensores Inerciais",
                            "description": "Modelar giroscópios e acelerômetros em simulações, propagando atitude via integração numérica e compensando deriva para suporte a manobras de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Princípios Fundamentais de Sensores Inerciais",
                                  "subSteps": [
                                    "Estudar o funcionamento de giroscópios: medição de velocidades angulares (ωx, ωy, ωz) em rad/s no referencial do corpo.",
                                    "Analisar acelerômetros: medição de acelerações específicas (ax, ay, az) excluindo gravidade, em m/s².",
                                    "Diferenciar referências: inercial (ECI) vs. corpo (body frame), e conceitos de atitude (quaternions ou ângulos de Euler).",
                                    "Revisar fontes de erro: bias, ruído, scale factor e deriva de giroscópio.",
                                    "Explorar unidades e calibração básica de IMUs (Inertial Measurement Units)."
                                  ],
                                  "verification": "Criar um diagrama esquemático mostrando saídas de sensores e transformação para propagação de atitude.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação técnica de IMUs (ex: datasheet MPU-6050)",
                                    "Vídeos Khan Academy ou YouTube sobre giroscópios/acelerômetros",
                                    "Livro 'Spacecraft Dynamics and Control' (Sidi) - Capítulo sobre sensores"
                                  ],
                                  "tips": [
                                    "Use animações 3D (ex: em Blender ou MATLAB) para visualizar rotações.",
                                    "Anote fórmulas chave: ω para taxas angulares, integração para ângulos."
                                  ],
                                  "learningObjective": "Explicar com precisão como giroscópios e acelerômetros fornecem dados brutos para estimativa de atitude em veículos espaciais.",
                                  "commonMistakes": [
                                    "Confundir acelerações específicas com acelerações totais (ignorar gravidade).",
                                    "Não diferenciar frame de corpo de frame inercial desde o início.",
                                    "Subestimar impacto de bias estático nos sensores."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Sensores Inerciais em Simulações Numéricas",
                                  "subSteps": [
                                    "Definir modelo matemático: giroscópio ŷ = S * ω + b + n; acelerômetro f = S * a + b + n (S=scale, b=bias, n=ruído).",
                                    "Implementar ruído gaussiano e bias aleatório em código (Python/MATLAB).",
                                    "Gerar dados sintéticos: simular rotação conhecida e adicionar erros realistas.",
                                    "Calibrar modelo: estimar bias médio de dados estáticos simulados.",
                                    "Validar modelo comparando saídas com dinâmica conhecida (ex: rotação constante)."
                                  ],
                                  "verification": "Executar script que gera dados de sensor para rotação de 10°/s e plotar vs. verdade fundamental.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib",
                                    "MATLAB Aerospace Toolbox (opcional)",
                                    "Tutoriais GitHub sobre simulação IMU"
                                  ],
                                  "tips": [
                                    "Comece com ruído simples (gaussiano branco) antes de adicionar cor.",
                                    "Use seed para reprodutibilidade em simulações."
                                  ],
                                  "learningObjective": "Construir e validar um modelo numérico realista de giroscópio e acelerômetro incluindo erros.",
                                  "commonMistakes": [
                                    "Usar integração analítica em vez de numérica para propagação.",
                                    "Ignorar não-linearidades em scale factors.",
                                    "Não normalizar quaternions após integração."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Propagação de Atitude via Integração Numérica",
                                  "subSteps": [
                                    "Escolher representação: quaternions para evitar gimbal lock (q_dot = 0.5 * Ω(ω) * q).",
                                    "Implementar integração: Euler forward, RK4 ou trapezoidal para dq/dt.",
                                    "Propagar de ω para q: discretizar Δt pequeno (ex: 0.01s).",
                                    "Incorporar dados de acelerômetro para roll/pitch (magnetômetro opcional para yaw).",
                                    "Testar com manobra simples: rotação em eixo único."
                                  ],
                                  "verification": "Simular manobra de 90° em 10s; verificar erro de atitude <1° sem deriva.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código Python/MATLAB para quaternions (biblioteca pyquaternion ou Aerospace Blockset)",
                                    "Referência: 'Quaternion kinematics for error-state Kalman filter' (Trawny)"
                                  ],
                                  "tips": [
                                    "Sempre renormalize quaternions após cada step: q = q / ||q||.",
                                    "Compare métodos de integração para precisão vs. custo computacional."
                                  ],
                                  "learningObjective": "Propagar atitude corretamente de taxas angulares medidas usando integração numérica estável.",
                                  "commonMistakes": [
                                    "Passo de tempo Δt muito grande causando instabilidade.",
                                    "Erro na matriz Ω(ω) para quaternions.",
                                    "Não tratar wrap-around em ângulos de Euler."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compensar Deriva e Integrar em Simulação de Manobras",
                                  "subSteps": [
                                    "Identificar deriva: simular longo prazo e medir drift em atitude.",
                                    "Implementar compensação: filtro complementar, Kalman simples ou subtração de bias estimado.",
                                    "Integrar em loop de simulação: sensores → integração → correção → controle de manobra.",
                                    "Simular manobra completa: slew de 180° com estabilização.",
                                    "Analisar performance: erro RMS, tempo de convergência."
                                  ],
                                  "verification": "Rodar simulação de 1 hora; deriva <0.1°/h após compensação.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "SciPy para filtros (signal.butter para complementar)",
                                    "Exemplos GitHub de ADCS (Attitude Determination and Control System)"
                                  ],
                                  "tips": [
                                    "Use filtro de alta-passagem para giroscópio e baixa para acelerômetro.",
                                    "Log todos os dados para pós-análise com plots."
                                  ],
                                  "learningObjective": "Aplicar técnicas de compensação de deriva para suportar manobras precisas de atitude em simulação.",
                                  "commonMistakes": [
                                    "Sobrecompensar levando a oscilações.",
                                    "Não alinhar frames de sensor e veículo.",
                                    "Ignorar vibrações em simulações realistas."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva uma simulação em Python de um CubeSat executando uma manobra de apontamento: inicie com atitude arbitrária, use giroscópio para propagar durante rotação de 180° em yaw (usando rodas de reação simuladas), integre acelerômetro para estimar roll/pitch, aplique filtro complementar para compensar deriva de 0.5°/h, e plote trajetória de quaternions vs. verdade fundamental.",
                              "finalVerifications": [
                                "Simulação executa sem crashes numéricos por 3600s.",
                                "Erro de atitude RMS < 0.5° durante manobra dinâmica.",
                                "Deriva compensada mantém erro < 0.1° após 30 minutos quiescente.",
                                "Plots mostram convergência suave do filtro.",
                                "Validação cruzada com método analítico para rotação constante.",
                                "Código modular permite trocar sensores ou métodos de integração."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo de sensor (erro de ruído/bias <5%).",
                                "Estabilidade da integração numérica (erro acumulado <1° em 10min).",
                                "Eficácia da compensação de deriva (redução >90%).",
                                "Eficiência computacional (tempo real em <1x fator).",
                                "Robustez a variações de parâmetros (ex: Δt, ruído).",
                                "Clareza e documentação do código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Métodos numéricos de ODEs (RK4, Euler) e álgebra de quaternions.",
                                "Programação: Simulação orientada a objetos e análise de dados (Pandas/Matplotlib).",
                                "Física: Cinemática rotacional e dinâmica de corpo rígido.",
                                "Engenharia de Controle: Filtros de Kalman/complementares para fusão de sensores.",
                                "Ciência de Dados: Modelagem estocástica e validação de simulações."
                              ],
                              "realWorldApplication": "Em missões espaciais como o satélite Göktürk ou CubeSats da NASA, sensores inerciais modelados com compensação de deriva permitem determinação autônoma de atitude para manobras precisas de imageamento terrestre ou alinhamento solar, essencial quando GPS está indisponível em órbita."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Dinâmica e Atuadores de Controle de Atitude",
                        "description": "Princípios de dinâmica rotacional e atuadores utilizados para gerar torques de controle, fundamentais para simular estabilização e manobras em veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Modelagem de Sistemas Propulsivos",
                            "description": "Implementar simulações de jatos de atitude e propulsores, calculando torques e consumos de combustível para manobras precisas de reorientação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Sistemas Propulsivos em Veículos Espaciais",
                                  "subSteps": [
                                    "Estude os tipos de propulsores: jatos de atitude (thrusters) e sistemas RCS (Reaction Control System).",
                                    "Analise características: impulso específico (Isp), thrust (F), massa de propelente e configuração geométrica.",
                                    "Revise princípios de conservação de momento linear e angular em ambientes de microgravidade.",
                                    "Identifique componentes: tanques, válvulas, nozzles e sensores de pressão.",
                                    "Explore exemplos reais de missões como ISS ou CubeSats."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes e funções de um RCS típico.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livros de dinâmica orbital (ex: Curtis 'Orbital Mechanics'), artigos da NASA sobre RCS",
                                    "Vídeos tutoriais sobre thrusters espaciais"
                                  ],
                                  "tips": "Use diagramas esquemáticos para visualizar configurações de thrusters assimétricas.",
                                  "learningObjective": "Dominar conceitos básicos de propulsores e seu papel na dinâmica de atitude.",
                                  "commonMistakes": [
                                    "Confundir thrust com torque",
                                    "Ignorar efeitos de plume impingement"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Equações Matemáticas para Torque e Consumo de Combustível",
                                  "subSteps": [
                                    "Derive a equação de thrust: F = ṁ * ve, onde ṁ é taxa de fluxo de massa e ve é velocidade de exaustão.",
                                    "Calcule torque gerado: τ = r × F, considerando vetor posição do thruster.",
                                    "Modele consumo de combustível: m(t) = m0 - ∫ ṁ dt.",
                                    "Inclua eficiência e perdas: fator de correção para thrust off-nominal.",
                                    "Formule equações para manobras: Δω = ∫ τ / I dt, onde I é momento de inércia."
                                  ],
                                  "verification": "Resolva analiticamente um exemplo simples de torque para um thruster único.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Folha de cálculo ou SymPy para derivações simbólicas",
                                    "Referências: Sidi 'Spacecraft Dynamics and Control'"
                                  ],
                                  "tips": "Use vetores unitários para posições de thrusters em coordenadas corpo.",
                                  "learningObjective": "Capacitar derivação precisa de modelos matemáticos para simulações.",
                                  "commonMistakes": [
                                    "Esquecer vetorização do torque",
                                    "Negligenciar variação de massa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Modelo Numérico de Propulsores em Software",
                                  "subSteps": [
                                    "Configure ambiente: Python com NumPy/SciPy ou MATLAB.",
                                    "Defina classes ou funções para Thruster: parâmetros (posição, thrust, Isp, massa inicial).",
                                    "Implemente funções de firing: calcular Δv, Δm, τ por intervalo de tempo Δt.",
                                    "Integre com modelo de rígido body: atualize estado de atitude.",
                                    "Adicione lógica de controle: on/off baseado em comandos de manobra."
                                  ],
                                  "verification": "Execute simulação unitária: verifique se torque e Δm batem com cálculos analíticos.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python/MATLAB, bibliotecas poliastro ou Orekit para referências",
                                    "Templates de código de simulação de atitude"
                                  ],
                                  "tips": "Use Runge-Kutta para integração numérica de alta precisão.",
                                  "learningObjective": "Desenvolver código modular e reutilizável para modelagem propulsiva.",
                                  "commonMistakes": [
                                    "Erros de indexação em arrays vetoriais",
                                    "Passos de tempo Δt muito grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Manobras de Reorientação Precisa",
                                  "subSteps": [
                                    "Defina cenário: reorientação de 90° em satélite com 4 thrusters opostos.",
                                    "Implemente sequência de firing: pulse-width modulation para precisão.",
                                    "Simule dinâmica completa: cinemática quaternion + equações de Euler.",
                                    "Monitore overshoot, tempo de settling e consumo total.",
                                    "Varie parâmetros: teste sensibilidade a Isp ou misalignment."
                                  ],
                                  "verification": "Gere plots de ângulo vs tempo e consumo cumulativo; verifique convergência.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Matplotlib/Plotly para visualizações 3D",
                                    "Dados reais de CubeSat missions"
                                  ],
                                  "tips": "Implemente deadbands para evitar chattering em controle.",
                                  "learningObjective": "Aplicar modelo em cenários realistas de manobra.",
                                  "commonMistakes": [
                                    "Ignorar gimbal lock em rotações",
                                    "Sobrestimar eficiência de thrusters"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, Analisar e Otimizar a Simulação",
                                  "subSteps": [
                                    "Compare resultados com benchmarks analíticos ou dados de literatura.",
                                    "Calcule métricas: precisão angular (<0.1°), eficiência de combustível.",
                                    "Otimize: ajuste sequência de thrusters para minimizar Δm.",
                                    "Teste edge cases: baixa massa de propelente, falha de thruster.",
                                    "Documente código e gere relatório com insights."
                                  ],
                                  "verification": "Realize teste de regressão: resultados consistentes em múltiplas runs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de profiling (cProfile)",
                                    "Papers de controle de atitude"
                                  ],
                                  "tips": "Use otimização gradient-free como Nelder-Mead para sequências.",
                                  "learningObjective": "Garantir robustez e aplicabilidade prática do modelo.",
                                  "commonMistakes": [
                                    "Falta de validação quantitativa",
                                    "Overfitting a um cenário"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat de 10kg reorientando 180° usando 8 thrusters de 0.1N cada, calculando torque total de 0.05 Nm e consumo de 5g de hidrazina para settling em 10 segundos.",
                              "finalVerifications": [
                                "Simulação executa sem erros numéricos por 1000s de tempo simulado.",
                                "Torques calculados coincidem com valores analíticos em <1% erro.",
                                "Consumo de combustível varia corretamente com duração de firing.",
                                "Manobra atinge precisão angular de <0.5° sem overshoot excessivo.",
                                "Código é modular e reutilizável para diferentes configurações de thrusters.",
                                "Plots mostram evolução estável de quaternion e ω."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: equações derivadas corretamente (90%+).",
                                "Implementação de código: limpo, comentado, eficiente (tempo de run <1min).",
                                "Validação: métricas de erro <5% vs benchmarks.",
                                "Análise: identificação de trade-offs (ex: precisão vs consumo).",
                                "Criatividade: extensão para cenários não triviais (ex: falhas).",
                                "Documentação: relatório claro com plots e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Física: Conservação de momento e mecânica orbital.",
                                "Matemática: Álgebra linear (quaternions, vetores) e EDOs.",
                                "Programação: OOP, numéricos (SciPy), visualização (Matplotlib).",
                                "Engenharia Mecânica: Dinâmica de rígidos e controle PID.",
                                "Gestão de Projetos: Simulação para design iterativo."
                              ],
                              "realWorldApplication": "Desenvolvimento de software de controle para satélites CubeSat em missões como monitoramento terrestre, onde manobras precisas de atitude economizam propelente limitado, similar ao usado na missão MarCO da NASA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Torque de Pressão Solar",
                            "description": "Simular efeitos perturbadores e de controle via pressão solar em superfícies assimétricas, integrando ao modelo dinâmico para estabilização passiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Pressão Solar e seu Torque",
                                  "subSteps": [
                                    "Estudar a física da pressão de radiação solar, incluindo momento de quantidade de movimento fotônico.",
                                    "Derivar a fórmula básica do torque gerado por pressão solar: τ = (P * A * cosθ * r) onde P é pressão, A área projetada, θ ângulo, r braço de alavanca.",
                                    "Analisar exemplos de superfícies assimétricas, como painéis solares desbalanceados em satélites.",
                                    "Calcular numericamente torque para casos simples usando vetores posição e normal à superfície.",
                                    "Discutir diferenças entre perturbação e controle passivo via design assimétrico."
                                  ],
                                  "verification": "Resolver 3 exercícios analíticos e comparar resultados com referências teóricas (erro <5%).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Spacecraft Dynamics and Control' (Sidi)",
                                    "Calculadora ou Python/MATLAB para cálculos vetoriais",
                                    "Artigos sobre pressão solar (NASA)"
                                  ],
                                  "tips": "Visualize vetores com diagramas 3D para melhor intuição geométrica.",
                                  "learningObjective": "Dominar a física e matemática do torque de pressão solar em superfícies espaciais.",
                                  "commonMistakes": [
                                    "Ignorar o cosseno do ângulo de incidência",
                                    "Confundir pressão com força total sem multiplicar pela área",
                                    "Esquecer o braço de alavanca assimétrico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Torque de Pressão Solar em Superfícies Assimétricas",
                                  "subSteps": [
                                    "Definir geometria da spacecraft: superfícies com áreas, normals e centros de pressão assimétricos.",
                                    "Implementar função computacional para calcular pressão projetada: P_proj = P_solar * cosθ * A.",
                                    "Computar torque total somando contribuições de todas as superfícies: τ_total = Σ (r_i × F_i).",
                                    "Incorporar variação orbital: P_solar varia com distância ao Sol e orientação.",
                                    "Validar modelo com cenários estáticos (e.g., face para o Sol)."
                                  ],
                                  "verification": "Gerar gráficos de torque vs. ângulo e validar contra simulações analíticas conhecidas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink ou Python (NumPy, SciPy)",
                                    "Modelos 3D de satélites (Blender ou CAD gratuito)",
                                    "Dados orbitais da NASA"
                                  ],
                                  "tips": "Use vetores unitários para normals e posicione origens no CG da spacecraft.",
                                  "learningObjective": "Criar modelo matemático preciso de torque solar assimétrico.",
                                  "commonMistakes": [
                                    "Erro na projeção de área (usar A total em vez de projetada)",
                                    "Não normalizar vetores de força",
                                    "Ignorar sombra mútua entre superfícies"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar o Modelo de Torque Solar à Dinâmica de Atitude",
                                  "subSteps": [
                                    "Revisar equações de Euler rígido: I ω̇ + ω × (I ω) = τ_total, incluindo τ_solar.",
                                    "Adicionar τ_solar como perturbação no vetor de torques externos.",
                                    "Implementar integração numérica (RK4 ou ode45) para propagar estado de atitude (quaternions/ângulos de Euler).",
                                    "Testar estabilidade passiva variando assimetria geométrica.",
                                    "Analisar Jacobiano para modos de movimento induzidos pelo torque solar."
                                  ],
                                  "verification": "Simular 1 órbita completa e plotar ângulos de atitude; verificar convergência passiva.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "MATLAB Aerospace Toolbox ou Python (SymPy para simbólico)",
                                    "Tutoriais de dinâmica de atitude (MIT OpenCourseWare)"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades em simulações longas.",
                                  "learningObjective": "Integrar perturbação solar ao modelo dinâmico completo de atitude.",
                                  "commonMistakes": [
                                    "Erro no sinal do torque (direção errada)",
                                    "Integração numérica instável (passo grande)",
                                    "Esquecer termos de Coriolis ω × Iω"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Analisar Estabilização Passiva via Torque Solar",
                                  "subSteps": [
                                    "Configurar simulação orbital realista (LEO, parâmetros Keplerianos).",
                                    "Executar Monte Carlo: variar condições iniciais e assimetrias para robustez.",
                                    "Analisar métricas: tempo de estabilização, overshoot, sensibilidade a parâmetros.",
                                    "Otimizar design assimétrico para maximizar estabilização passiva (min τ_rms).",
                                    "Gerar relatório com plots e conclusões sobre viabilidade."
                                  ],
                                  "verification": "Simulação converge para atitude estável em <3 órbitas em 90% dos casos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Simulink para modelagem ou Python (Matplotlib para plots)",
                                    "Ferramentas de otimização (SciPy.optimize)"
                                  ],
                                  "tips": "Paralelize simulações Monte Carlo para eficiência.",
                                  "learningObjective": "Avaliar e otimizar estabilização passiva usando torque solar.",
                                  "commonMistakes": [
                                    "Condições iniciais irreais (ângulos grandes)",
                                    "Ignorar outros torques (gradiente gravitacional)",
                                    "Sobre-otimização sem validação física"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat com painéis solares assimétricos em órbita LEO: configure o modelo para que o torque solar gire passivamente o satélite com a face de maior arrasto solar contra o Sol, estabilizando a atitude sem rodas de reação.",
                              "finalVerifications": [
                                "O torque solar calculado coincide com fórmulas teóricas (erro <2%).",
                                "Simulação orbital mostra estabilização passiva em até 2 órbitas.",
                                "Gráficos de atitude exibem convergência sem oscilações divergentes.",
                                "Análise de sensibilidade identifica parâmetros críticos (área, órbita).",
                                "Relatório inclui código fonte e dados reproduzíveis.",
                                "Testes com variações de órbita confirmam robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo de torque (validação analítica/numerica).",
                                "Correta integração dinâmica e estabilidade simulada.",
                                "Qualidade dos plots e análise quantitativa (métricas claras).",
                                "Otimização de design passivo com justificativa física.",
                                "Clareza do código e documentação.",
                                "Criatividade em cenários de aplicação real."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica clássica, radiação eletromagnética e momentum fotônico.",
                                "Matemática: Álgebra linear (vetores, matrizes de inércia), EDOs e integração numérica.",
                                "Programação: Modelagem computacional em MATLAB/Python, visualização de dados.",
                                "Engenharia Mecânica: Dinâmica de corpos rígidos e controle passivo.",
                                "Astronomia: Órbitas keplerianas e ambiente espacial."
                              ],
                              "realWorldApplication": "Em missões de satélites como o CubeSats da NASA ou o telescópio James Webb, o torque de pressão solar é explorado para estabilização passiva, reduzindo consumo de energia e massa de atuadores ativos, essencial para longas missões interplanetárias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Atuadores de Troca de Momentos: Rodas de Reação",
                            "description": "Desenvolver modelos de rodas de reação, incluindo saturação e desaturação, para controle ativo de atitude em simulações de estabilização contínua.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Princípios Fundamentais de Rodas de Reação",
                                  "subSteps": [
                                    "Estude o conceito de conservação de momento angular e como rodas de reação o utilizam para controle de atitude sem expelir massa.",
                                    "Analise os componentes principais: motor elétrico, roda inercial e eixos ortogonais (tipicamente 3-4 rodas).",
                                    "Revise equações básicas de torque gerado: τ = I * α, onde I é o momento de inércia e α é a aceleração angular.",
                                    "Explore limitações físicas como velocidade máxima de rotação e efeitos de fricção.",
                                    "Discuta vantagens sobre propulsores: precisão, ausência de perturbações químicas."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes e equações chave, explicando como o momento angular é transferido.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livros/textos sobre dinâmica de spacecraft (ex: Sidi 'Spacecraft Dynamics and Control')",
                                    "Vídeos tutoriais sobre reaction wheels (NASA ou YouTube)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Visualize com animações 3D para melhor compreensão intuitiva.",
                                  "learningObjective": "Compreender os princípios físicos e componentes de rodas de reação para controle de atitude.",
                                  "commonMistakes": [
                                    "Confundir com control moment gyros (CMGs), que usam gimbal.",
                                    "Ignorar que múltiplas rodas são necessárias para 3 eixos.",
                                    "Esquecer conservação de momento total do sistema."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver Modelo Matemático Básico de Rodas de Reação",
                                  "subSteps": [
                                    "Defina o estado do sistema: vetor de momento angular da roda ω_rw e momento de inércia J_rw.",
                                    "Escreva as equações de dinâmica: ḣ_rw = -u, onde u é o torque de controle e h_rw = J_rw * ω_rw.",
                                    "Inclua a cinemática de atitude do spacecraft: q̇ = (1/2) Ω(ω) q, com ω incluindo contribuição das rodas.",
                                    "Modele o acoplamento com o corpo rígido: I_sc * ω̇_sc + ω_sc × (I_sc * ω_sc + h_rw) = -u.",
                                    "Implemente em software simbólico para derivar equações."
                                  ],
                                  "verification": "Implemente um modelo simples em Python/MATLAB e plote a resposta a um torque unitário constante.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB/Simulink",
                                    "Referência: Wie 'Space Vehicle Dynamics and Control'"
                                  ],
                                  "tips": "Use notação vetorial consistente (body frame) para evitar erros de coordenadas.",
                                  "learningObjective": "Construir e validar o modelo matemático básico de dinâmica de rodas de reação.",
                                  "commonMistakes": [
                                    "Não linearizar corretamente os termos cruzados.",
                                    "Usar frame inercial em vez de body frame.",
                                    "Esquecer sinal negativo no torque de controle."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Modelos de Saturação e Desaturação",
                                  "subSteps": [
                                    "Defina limites de saturação: |ω_rw| ≤ ω_max, tipicamente 5000-6000 RPM.",
                                    "Modele saturação: u = u_cmd se |h_rw| < h_max, senão u = 0 ou torque de desaturação.",
                                    "Implemente desaturação: torque oposto proporcional à saturação, ou via magnetotorquers/propulsores.",
                                    "Adicione histerese para evitar oscilações na borda de saturação.",
                                    "Simule cenários de saturação contínua sob distúrbios gravitacionais."
                                  ],
                                  "verification": "Simule uma manobra que cause saturação e verifique recuperação via desaturação.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Simulink ou Python com controle não-linear (ex: saturation block)",
                                    "Dados reais de satélites (ex: CubeSat specs)"
                                  ],
                                  "tips": "Teste com diferentes ω_max para observar impactos na estabilidade.",
                                  "learningObjective": "Modelar comportamentos não-lineares de saturação e estratégias de desaturação.",
                                  "commonMistakes": [
                                    "Ignorar histerese, causando chatter.",
                                    "Desaturação muito agressiva levando a overshoot.",
                                    "Não considerar acoplamento entre eixos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar em Simulação de Estabilização Contínua de Atitude",
                                  "subSteps": [
                                    "Combine modelo de rodas com controlador PD ou LQR para estabilização.",
                                    "Defina planta completa: dinâmica de atitude + rodas + sensores (gyros, star trackers).",
                                    "Inclua ruídos e distúrbios: gradiente gravitacional, pressão solar.",
                                    "Implemente alocador de torque para distribuir u entre rodas.",
                                    "Execute simulações de longa duração para verificar drift e saturação."
                                  ],
                                  "verification": "Execute simulação de 1 órbita e confirme erro de apontamento < 0.1°.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "MATLAB Aerospace Toolbox ou Python Orekit/GMlib",
                                    "Scripts de exemplo de controle de atitude"
                                  ],
                                  "tips": "Use quaternion para evitar singularidades em ângulos de Euler.",
                                  "learningObjective": "Integrar rodas de reação em um loop de controle fechado para estabilização.",
                                  "commonMistakes": [
                                    "Alocador de torque singular quando rodas alinhadas.",
                                    "Gain scheduling inadequado pós-desaturação.",
                                    "Simulações curtas que mascaram saturação acumulada."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Otimizar a Simulação",
                                  "subSteps": [
                                    "Calcule métricas: tempo de estabilização, uso de rodas, frequência de desaturação.",
                                    "Sensibilidade a parâmetros: J_rw, ω_max, gains de controle.",
                                    "Otimize via simulações Monte Carlo com variações de distúrbios.",
                                    "Compare com benchmarks reais (ex: dados de GOCE ou GRACE satélites).",
                                    "Documente trade-offs: precisão vs. capacidade de armazenamento de momento."
                                  ],
                                  "verification": "Gere relatório com plots de ω_sc, ω_rw e erro de atitude ao longo do tempo.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ferramentas de plotting (Matplotlib/Plotly)",
                                    "Dados públicos de missões (NASA CDS)"
                                  ],
                                  "tips": "Automatize sweeps paramétricos para eficiência.",
                                  "learningObjective": "Avaliar performance e otimizar o modelo de rodas de reação em simulação.",
                                  "commonMistakes": [
                                    "Métricas insuficientes (só steady-state).",
                                    "Ignorar consumo de energia.",
                                    "Overfitting a um cenário específico."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO estabilizando atitude para aquisição de imagem terrestre: aplique distúrbio de eclipse, use rodas para nulá-lo, gerencie saturação com desaturação magnética, mantendo apontamento nadir < 0.5° por 10 órbitas.",
                              "finalVerifications": [
                                "Modelo simula corretamente conservação de momento angular total.",
                                "Saturação ocorre dentro de limites realistas e é gerenciada sem perda de controle.",
                                "Erro de atitude estabiliza abaixo de 0.1° em < 300s.",
                                "Desaturação recupera 90% da capacidade em uma órbita.",
                                "Simulação roda sem crashes numéricos por 24h simuladas.",
                                "Plots mostram ausência de drift secular."
                              ],
                              "assessmentCriteria": [
                                "Completude do modelo (equações, limites, acoplamentos): 20%",
                                "Precisão da simulação (matching com teoria/benchmarks): 25%",
                                "Gerenciamento de não-linearidades (saturação/desaturação): 20%",
                                "Análise quantitativa (métricas, sensibilidade): 20%",
                                "Clareza da documentação e plots: 10%",
                                "Criatividade em cenários de teste: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Física: Conservação de momento angular e dinâmica rígida.",
                                "Matemática: Equações diferenciais não-lineares e álgebra linear (alocador).",
                                "Programação: Modelagem numérica e simulação em tempo real.",
                                "Engenharia de Controle: Controladores PD/LQR e observadores.",
                                "Eletrônica: Modelagem de motores brushless e sensores giroscópicos."
                              ],
                              "realWorldApplication": "Rodas de reação são usadas em satélites como os da constelação Starlink para apontamento preciso de antenas, no telescópio James Webb para rastreamento de estrelas, e na ISS para micro-ajustes de atitude, permitindo manobras sem combustível e longevidade missionária estendida."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.4",
                            "name": "Roda de Reação com Gimbal e Torque Magnético",
                            "description": "Simular control moment gyros (CMGs) e bobinas magnéticas interagir com o campo magnético terrestre para geração de torques, otimizando para manobras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos Teóricos de RWG e Torque Magnético",
                                  "subSteps": [
                                    "Estudar o princípio de operação das Rodas de Reação com Gimbal (RWG), incluindo o efeito gimbal para gerar torque vetorial",
                                    "Analisar o torque magnético gerado por bobinas (torqueadores magnéticos) interagindo com o campo magnético terrestre (B)",
                                    "Revisar equações básicas: torque de RWG (h × ω_gimbal) e torque magnético (m × B)",
                                    "Identificar limitações, como saturação de momento angular e dependência do campo magnético",
                                    "Comparar RWG com CMGs e torqueadores puros"
                                  ],
                                  "verification": "Elaborar um diagrama esquemático e resumir os princípios em um relatório de 1 página",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livros de dinâmica de atitude (ex: Sidi 'Spacecraft Dynamics and Control')",
                                    "Artigos IEEE sobre CMGs",
                                    "Vídeos tutoriais sobre attitude dynamics"
                                  ],
                                  "tips": "Use animações 3D para visualizar o movimento do gimbal",
                                  "learningObjective": "Dominar os conceitos físicos e matemáticos subjacentes aos atuadores RWG e magnéticos",
                                  "commonMistakes": [
                                    "Confundir torque de precessão com rotação simples",
                                    "Ignorar a direção vetorial do campo magnético terrestre",
                                    "Subestimar efeitos de não-linearidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Matematicamente o Sistema Combinado",
                                  "subSteps": [
                                    "Definir o estado do sistema: vetor de momento angular das RWGs (h_rw), ângulos de gimbal (γ), momento dipolar magnético (m)",
                                    "Escrever as equações cinemáticas e dinâmicas de atitude: ḣ = T_control + m × B + distúrbios",
                                    "Incorporar modelo do campo magnético terrestre (ex: modelo DIP1 ou IGRF)",
                                    "Linearizar o modelo para análise inicial ou usar simulação não-linear",
                                    "Implementar matrizes de Jacobiano para otimização"
                                  ],
                                  "verification": "Derivar e codificar as equações em um script simbólico (ex: SymPy ou MATLAB)",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink ou Python (SymPy/NumPy)",
                                    "Modelos de campo magnético (bibliotecas espaciais)"
                                  ],
                                  "tips": "Comece com modelo 3DOF para simplificar antes de ir para 6DOF",
                                  "learningObjective": "Construir um modelo matemático preciso da interação RWG-magnético",
                                  "commonMistakes": [
                                    "Esquecer termos de acoplamento entre eixos",
                                    "Usar campo magnético constante em vez de modelo real",
                                    "Erro em convenções de quaternion para atitude"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Simulação Numérica",
                                  "subSteps": [
                                    "Configurar integrador numérico (ex: RK4 ou ode45) para propagar dinâmica de atitude",
                                    "Simular interação: calcular torque RWG via velocidades de gimbal e torque magnético via lei de Lorentz",
                                    "Adicionar leis de controle simples (ex: PD para gimbal, B-dot para magnético)",
                                    "Incluir ruídos e distúrbios realistas (ex: gradientes gravitacionais, pressão solar)",
                                    "Visualizar resultados: plots de ângulos de Euler, torques e momentos angulares"
                                  ],
                                  "verification": "Executar simulação básica e verificar conservação de momento angular total",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python (SciPy, Matplotlib) ou MATLAB/Simulink",
                                    "Bibliotecas como Orekit ou poliastro para órbita"
                                  ],
                                  "tips": "Teste com cenários estacionários (LEO) onde B é conhecido",
                                  "learningObjective": "Criar uma simulação funcional que reproduza dinâmicas reais",
                                  "commonMistakes": [
                                    "Passo de tempo muito grande causando instabilidade",
                                    "Escala errada de unidades (Nm vs mNm)",
                                    "Não normalizar quaternions"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar para Manobras de Atitude",
                                  "subSteps": [
                                    "Definir objetivo: manobra de slew (ex: 90° em 10 minutos) minimizando uso de combustível",
                                    "Implementar otimizador (ex: gradient descent ou GPOPS) para trajetórias de gimbal e m",
                                    "Avaliar métricas: tempo de manobra, overshoot, consumo de Δv equivalente",
                                    "Testar robustez com variações de órbita e falhas (ex: uma RWG saturada)",
                                    "Refinar com controle preditivo (MPC) integrando previsões de B"
                                  ],
                                  "verification": "Gerar relatório com plots comparativos antes/depois otimização",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Otimizadores (SciPy.optimize, CasADi)",
                                    "Ferramentas de MPC (ex: do-mpc)"
                                  ],
                                  "tips": "Use pesos no custo para priorizar torque magnético (economia)",
                                  "learningObjective": "Otimizar atuadores combinados para eficiência em manobras",
                                  "commonMistakes": [
                                    "Otimização local em vez de global",
                                    "Ignorar constraints físicas como limites de gimbal (±30°)",
                                    "Sobrestimar capacidade magnética em órbitas altas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar a Simulação Completa",
                                  "subSteps": [
                                    "Comparar com benchmarks literários ou dados de missões reais",
                                    "Realizar análise de sensibilidade (Monte Carlo) para parâmetros incertos",
                                    "Testar manobras múltiplas em sequência",
                                    "Documentar código e resultados para reprodutibilidade",
                                    "Propor melhorias (ex: hibridização com thrusters)"
                                  ],
                                  "verification": "Simulação passa em todos os testes de validação com erro <5%",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dados de missões (NASA CDS)",
                                    "Ferramentas de análise estatística"
                                  ],
                                  "tips": "Grave vídeos da simulação 3D para apresentação",
                                  "learningObjective": "Garantir validade e robustez da simulação otimizada",
                                  "commonMistakes": [
                                    "Validação só em casos ideais",
                                    "Não considerar latência de sensores",
                                    "Relatório incompleto"
                                  ]
                                }
                              ],
                              "practicalExample": "Simular uma manobra de apontamento de 180° para um CubeSat em órbita LEO, usando 4 RWGs com gimbals para torque principal e torqueadores magnéticos para desaturação, otimizando para completar em 15 minutos com erro de apontamento <0.1°.",
                              "finalVerifications": [
                                "A simulação gera torques vetoriais corretos via RWG e magnéticos, com conservação de momento angular",
                                "Manobras otimizadas completam dentro do tempo alvo sem saturação excessiva",
                                "Interação com campo magnético terrestre varia realisticamente com órbita",
                                "Erros de atitude pós-manobra <1° em 95% dos casos Monte Carlo",
                                "Código é modular e reprodutível com seed fixa",
                                "Plots mostram convergência suave sem oscilações instáveis"
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo dinâmico (erro <2% vs analítico)",
                                "Eficiência da otimização (redução >30% em custo vs baseline)",
                                "Robustez a perturbações (desempenho mantido em ±20% variação de B)",
                                "Qualidade da documentação e visualizações",
                                "Capacidade de generalizar para novas órbitas/manobras",
                                "Tempo de computação <5 min por simulação"
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletromagnetismo e mecânica orbital",
                                "Matemática: Álgebra linear, otimização não-linear e análise numérica",
                                "Programação: Simulação dinâmica e visualização científica",
                                "Engenharia de Controle: Leis de controle e MPC",
                                "Ciência de Dados: Análise de sensibilidade e Monte Carlo"
                              ],
                              "realWorldApplication": "Controle de atitude em satélites como o James Webb Space Telescope ou Swarm da ESA, onde RWGs e torqueadores magnéticos permitem manobras precisas e desaturação sem propelentes, estendendo vida útil da missão."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Simulação Computacional de Estabilização e Manobras",
                        "description": "Técnicas de simulação numérica para validar controladores de atitude, focando em estabilização e execução de manobras específicas em ambientes espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Implementação de Controladores de Estabilização",
                            "description": "Desenvolver e simular leis de controle (PD, LQR) para manter atitude nominal, incorporando perturbações e fusão de sensores em MATLAB/Simulink ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Simulação",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias: Control Systems Library (Python: control, scipy; MATLAB: Control System Toolbox).",
                                    "Definir parâmetros do veículo espacial: momento de inércia (I), vetor de atitude inicial (quaternions ou ângulos de Euler).",
                                    "Criar modelo cinemático e dinâmico básico de rotação rígida (equações de Euler).",
                                    "Testar script inicial com simulação livre (sem controle) para validar dinâmica.",
                                    "Configurar visualização: plotar trajetórias de atitude ao longo do tempo."
                                  ],
                                  "verification": "Executar simulação livre e confirmar que a atitude deriva realisticamente devido a perturbações iniciais, sem erros de código.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python (control, scipy, numpy, matplotlib) ou MATLAB/Simulink",
                                    "Documentação de dinâmica de atitude (ex: Sidi 'Spacecraft Dynamics and Control')"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades em simulações de atitude; inicialize com seed randômico para reprodutibilidade.",
                                  "learningObjective": "Configurar um ambiente de simulação funcional para dinâmica de atitude de veículos espaciais.",
                                  "commonMistakes": [
                                    "Esquecer unidades consistentes (rad/s vs deg/s)",
                                    "Não normalizar quaternions",
                                    "Ignorar dependências de bibliotecas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Dinâmica de Atitude com Perturbações",
                                  "subSteps": [
                                    "Implementar equações dinâmicas: ω̇ = I⁻¹(-ω×Iω + u + d), onde d são perturbações (gradiente gravitacional, pressão solar).",
                                    "Adicionar modelo de sensores ruidosos: giroscópios (ruído gaussiano), magnetômetros, star trackers.",
                                    "Implementar fusão básica de sensores usando filtro complementar ou Kalman simples para estimar atitude.",
                                    "Simular perturbações realistas: torque de restauração gravitacional para orbitador LEO.",
                                    "Plotar estados: quaternions, velocidades angulares, erros de estimação."
                                  ],
                                  "verification": "Simulação aberta mostra deriva de atitude <5°/min e estimação de sensores com erro <0.1° RMS.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Notebooks Jupyter ou scripts MATLAB",
                                    "Modelos de perturbações de referências aeroespaciais (NASA/ESA)"
                                  ],
                                  "tips": "Linearize o modelo não-linear ao redor do ponto de equilíbrio para análise inicial; use odeint/solve_ivp para integração numérica.",
                                  "learningObjective": "Modelar dinâmicas reais incluindo perturbações e sensores para simulações precisas.",
                                  "commonMistakes": [
                                    "Não modelar acoplamento entre eixos",
                                    "Escala errada de ruído de sensores",
                                    "Integração numérica instável (passo grande)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Controlador PD",
                                  "subSteps": [
                                    "Derivar lei de controle PD: u = -K_p * q_error - K_d * ω_error, com q_error de quaternions.",
                                    "Ajustar gains K_p, K_d via método de Ziegler-Nichols ou simulação trial-and-error.",
                                    "Integrar controlador no loop de simulação fechada.",
                                    "Adicionar saturação de atuadores (momentum wheels: ±0.01 Nm).",
                                    "Simular resposta a distúrbio inicial e analisar settling time, overshoot."
                                  ],
                                  "verification": "Sistema estabiliza atitude em <10s com overshoot <10% e erro estacionário <0.5°.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de análise de step response (Python control.step_response)",
                                    "Tabelas de tuning PD para sistemas aeroespaciais"
                                  ],
                                  "tips": "Comece com K_d alto para amortecimento, depois aumente K_p; monitore norma de controle para viabilidade.",
                                  "learningObjective": "Desenvolver e tunar um controlador PD proporcional-derivativo para estabilização de atitude.",
                                  "commonMistakes": [
                                    "Cálculo errado de erro de quaternion (use vector part)",
                                    "Gains muito altos causando oscilações",
                                    "Ignorar delays de sensores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Controlador LQR",
                                  "subSteps": [
                                    "Linearizar modelo não-linear em torno de atitude nominal (A, B matrizes).",
                                    "Definir matrizes Q (pesos em estado: atitude > velocidade) e R (controle).",
                                    "Calcular K = lqr(A, B, Q, R) usando funções built-in.",
                                    "Implementar u = -K*x em simulação não-linear com estado estimado.",
                                    "Comparar performance PD vs LQR em métricas (ITAE, controle effort)."
                                  ],
                                  "verification": "LQR atinge settling time <5s e menor energia de controle que PD em simulações idênticas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Função lqr() em Python control ou MATLAB lqr()",
                                    "Guia de seleção de Q/R (ex: exemplos de satélites)"
                                  ],
                                  "tips": "Q diagonal com pesos altos em quaternion errors; itere Q/R para trade-off performance vs effort.",
                                  "learningObjective": "Projetar um controlador ótimo LQR considerando custos quadráticos.",
                                  "commonMistakes": [
                                    "Linearização incorreta (Jacobianas erradas)",
                                    "Q/R mal escalados",
                                    "Não usar estado estimado"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com Fusão de Sensores e Análise Final",
                                  "subSteps": [
                                    "Implementar EKF (Extended Kalman Filter) para fusão: giro + star tracker.",
                                    "Testar robustez: variações de perturbações, falhas parciais de sensores.",
                                    "Analisar métricas: RMS error, robustez a ruído, tempo de convergência.",
                                    "Otimizar hiperparâmetros via grid search ou otimização.",
                                    "Gerar relatório com plots comparativos PD/LQR."
                                  ],
                                  "verification": "Simulação completa mantém erro de atitude <0.1° RMS por 1000s com ruído realista.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Biblioteca filterpy (Python) ou EKF toolbox MATLAB",
                                    "Datasets de sensores reais (ex: CubeSat telemetry)"
                                  ],
                                  "tips": "Tune covariâncias do EKF iterativamente; salve seeds para reproducibilidade em análises.",
                                  "learningObjective": "Integrar fusão de sensores e validar controladores em cenários realistas.",
                                  "commonMistakes": [
                                    "Divergência do filtro por covariâncias ruins",
                                    "Não testar Monte Carlo para estatísticas",
                                    "Plots sem legendas/unidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO (500km) com rodas de reação, inicializando com erro de 10° em roll. Aplique torque solar perturbação; PD estabiliza em 15s, LQR em 8s com 30% menos effort, usando EKF com star tracker (0.01° acc.) + giro (0.001 rad/s noise).",
                              "finalVerifications": [
                                "Erro de atitude RMS <0.1° em simulação de 1 órbita.",
                                "Controladores saturam <10% do tempo.",
                                "EKF converge em <5s com innovation bounded.",
                                "LQR outperform PD em ITAE por >20%.",
                                "Sistema robusto a +50% ruído de sensores.",
                                "Código roda sem warnings/erros numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão de estabilização (erro <0.5°).",
                                "Tempo de settling (<10s).",
                                "Eficiência energética (integral |u| mínima).",
                                "Robustez a perturbações/sensores.",
                                "Clareza e modularidade do código.",
                                "Análise comparativa PD vs LQR."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes A/B), otimização quadrática.",
                                "Física: Mecânica orbital, torques ambientais.",
                                "Programação: OOP para classes de simulador/controlador.",
                                "Estatística: Filtros estocásticos, análise Monte Carlo.",
                                "Engenharia de Software: Versionamento Git, testes unitários."
                              ],
                              "realWorldApplication": "Estabilização de atitude em CubeSats (ex: missão QB50), manutenção de pointing preciso na ISS para experimentos científicos, ou controladores de reação wheels em satélites geoestacionários resistindo a perturbações magnéticas/gravitacionais."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Simulação de Manobras de Reorientação",
                            "description": "Planejar e simular sequências de manobras de slew (rotações rápidas), otimizando tempo e consumo de atuadores com representações quaternion ou DCM.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão de Representações de Atitude: Quaternions e DCM",
                                  "subSteps": [
                                    "Estude as propriedades matemáticas de quaternions unitários e matrizes de direção de cosenos (DCM).",
                                    "Implemente conversões entre quaternions, ângulos de Euler e DCM em código.",
                                    "Visualize rotações em 3D usando ferramentas gráficas para entender slew maneuvers.",
                                    "Pratique composição de rotações múltiplas representando sequências de manobras.",
                                    "Valide implementações com casos teste conhecidos, como rotações de 90 graus em eixos principais."
                                  ],
                                  "verification": "Implementações de conversão produzem resultados idênticos a bibliotecas padrão (ex: scipy.spatial.transform) com erro < 1e-6.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação de quaternions (NASA TN D-6702)",
                                    "Python com NumPy e SciPy",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Sempre normalize quaternions para evitar deriva numérica; use representações duais para comparações.",
                                  "learningObjective": "Dominar representações matemáticas de atitude para modelar rotações precisas em simulações.",
                                  "commonMistakes": [
                                    "Não normalizar quaternions levando a magnitudes >1",
                                    "Confundir ordem de multiplicação em composições de rotações",
                                    "Ignorar singularidades em ângulos de Euler"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelagem da Cinemática e Dinâmica de Manobras de Slew",
                                  "subSteps": [
                                    "Defina a cinemática de atitude usando derivadas de quaternions ou DCM em função de velocidades angulares.",
                                    "Incorpore dinâmica simplificada: torque de atuadores (momentum wheels ou thrusters) e inércia do satélite.",
                                    "Estabeleça modelo de slew: aceleração angular constante ou perfil trapezoidal para rotações rápidas.",
                                    "Implemente equações diferenciais em um resolvedor numérico (ex: odeint no SciPy).",
                                    "Teste o modelo com slew simples de 180 graus em um eixo."
                                  ],
                                  "verification": "O modelo simula corretamente um slew conhecido, com tempo de rotação coincidente com cálculos analíticos (±5%).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Livro 'Spacecraft Attitude Determination and Control' (Wertz)",
                                    "Python: SciPy.integrate, Matplotlib",
                                    "Modelo de satélite simples (matriz de inércia 3x3)"
                                  ],
                                  "tips": "Use pequenos passos de tempo (dt < 0.01s) para estabilidade numérica em rotações rápidas.",
                                  "learningObjective": "Construir modelo físico preciso de dinâmica de atitude para simular manobras realistas.",
                                  "commonMistakes": [
                                    "Esquecer normalização de quaternions na integração",
                                    "Usar inércia incorreta levando a torques irreais",
                                    "Não limitar velocidades angulares máximas dos atuadores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Planejamento de Sequências de Manobras de Slew",
                                  "subSteps": [
                                    "Defina orientação inicial e final para uma sequência multi-eixo (ex: de (0,0,0) para (90,45,30) graus).",
                                    "Planeje trajetória ótima minimizando tempo total ou consumo de combustível (usando Euler angles ou Lost-in-Space).",
                                    "Gere sequência de slews unitários: divida rotação composta em rotações eixo-por-eixo.",
                                    "Implemente algoritmo de planejamento (ex: método de Bang-Coast-Bang para thrusters).",
                                    "Calcule métricas preliminares: tempo total, Δv ou Δh (momentum)."
                                  ],
                                  "verification": "Sequência planejada atinge orientação final com erro de atitude < 0.1 grau em simulação aberta.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Algoritmos de planejamento (paper 'Optimal Slew Maneuvers')",
                                    "Python com otimização (SciPy.optimize)",
                                    "Ferramentas de visualização 3D (ex: Plotly)"
                                  ],
                                  "tips": "Priorize slews em eixos principais para minimizar acoplamentos; use quaternions para rotções grandes (>90°).",
                                  "learningObjective": "Planejar sequências eficientes de manobras considerando restrições de atuadores.",
                                  "commonMistakes": [
                                    "Dividir rotações incorretamente causando overshoot",
                                    "Ignorar limites de taxa angular",
                                    "Não considerar gimbal lock em planejamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementação e Simulação Computacional Completa",
                                  "subSteps": [
                                    "Integre modelo dinâmico com plano de manobras em um loop de simulação fechado.",
                                    "Adicione controle PD ou LQR para tracking da trajetória planejada.",
                                    "Simule com ruído e perturbações (ex: gradiente gravitacional, ruído de sensores).",
                                    "Registre métricas: tempo, consumo de atuadores, erro final de apontamento.",
                                    "Visualize trajetórias de atitude, velocidades e torques ao longo do tempo."
                                  ],
                                  "verification": "Simulação completa executa sem erros e plota gráficos de convergência para orientação alvo.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código base de steps anteriores",
                                    "Python: control library ou custom PD",
                                    "Matplotlib/Seaborn para plots"
                                  ],
                                  "tips": "Salve estados em arrays para análise pós-simulação; use vetores de estado [quaternion, omega].",
                                  "learningObjective": "Executar simulações numéricas robustas de manobras de reorientação.",
                                  "commonMistakes": [
                                    "Instabilidade no controlador devido a ganhos altos",
                                    "Acúmulo de erro numérico em simulações longas",
                                    "Visualizações confusas sem normalização de ângulos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimização e Análise de Resultados",
                                  "subSteps": [
                                    "Otimize parâmetros: minimize função custo (tempo + consumo) via gradiente ou genético.",
                                    "Compare quaternions vs DCM em termos de precisão e eficiência computacional.",
                                    "Analise sensibilidade a parâmetros (ex: variação de inércia ou limites de atuadores).",
                                    "Gere relatório com métricas chave e plots comparativos.",
                                    "Itere otimizações para pelo menos 3 cenários diferentes."
                                  ],
                                  "verification": "Otimização reduz tempo/consumo em >10% comparado ao baseline, com estabilidade comprovada.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "SciPy.optimize ou PyGMO",
                                    "Dados de simulações anteriores",
                                    "Templates de relatório LaTeX ou Markdown"
                                  ],
                                  "tips": "Use otimização multi-objetivo para trade-offs realistas; valide com benchmarks analíticos.",
                                  "learningObjective": "Otimizar simulações para eficiência, preparando para aplicações reais.",
                                  "commonMistakes": [
                                    "Ótimo local em vez de global devido a inicialização ruim",
                                    "Sobre-otimização ignorando constraints físicas",
                                    "Análises sem quantificação de incertezas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma manobra de reorientação de um CubeSat de 90° em roll e 45° em yaw para alinhar painel solar com o Sol, usando rodas de reação com limite de 0.01 Nm.s, otimizando para tempo mínimo (<300s) com quaternions, resultando em consumo de 15% da capacidade total.",
                              "finalVerifications": [
                                "Erro final de atitude < 0.05° após slew.",
                                "Tempo total de manobra dentro de plano otimizado (±10%).",
                                "Consumo de atuadores não excede limites físicos.",
                                "Trajetória suave sem oscilações excessivas (>5° overshoot).",
                                "Simulação converge independentemente de representação (quaternion/DCM).",
                                "Visualizações confirmam rotações corretas em 3D."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem cinemática/dinâmica (erro <1e-4).",
                                "Eficiência da otimização (redução >15% em métrica custo).",
                                "Robustez à perturbações (desvio <5% com ruído).",
                                "Clareza e completude do código e visualizações.",
                                "Correta interpretação de resultados com análise quantitativa.",
                                "Adequação ao contexto real de veículos espaciais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e cálculo diferencial para quaternions/DCM.",
                                "Programação: Simulação numérica e otimização em Python/MATLAB.",
                                "Física: Dinâmica rotacional e controle de sistemas.",
                                "Engenharia de Software: Modularidade em simulações científicas.",
                                "Computação Científica: Integração de EDOs e visualização 3D."
                              ],
                              "realWorldApplication": "Em missões como o satélite CYGNSS da NASA, simulações de slew otimizadas permitem reorientação rápida para aquisição de dados, economizando combustível e prolongando vida útil em órbita, essencial para constelações de CubeSats em telecomunicações ou observação Earth."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Validação com Bibliografia Referenciada",
                            "description": "Reproduzir exemplos de simulações de Sidi, Wiesel e Wertz, comparando resultados para validar modelos de dinâmica e controle de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Estudo da Bibliografia Referenciada",
                                  "subSteps": [
                                    "Identifique e acesse as publicações originais de Sidi (Spacecraft Dynamics and Control), Wiesel (Spacecraft Attitude Dynamics) e Wertz (Space Mission Analysis and Design).",
                                    "Extraia exemplos específicos de simulações de dinâmica de atitude, como manobras de estabilização ou apontamento, incluindo equações, parâmetros iniciais e resultados esperados.",
                                    "Anote parâmetros chave: condições iniciais (quaternions, velocidades angulares), modelos cinemáticos/dinâmicos e métodos de controle.",
                                    "Crie um sumário comparativo das simulações entre os autores em uma tabela.",
                                    "Verifique a consistência das referências cruzadas entre os textos."
                                  ],
                                  "verification": "Sumário comparativo completo com citações exatas e tabelas de parâmetros extraídos.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Livros/PDFs de Sidi, Wiesel e Wertz; leitor de PDF; caderno digital (ex: Notion ou Excel).",
                                  "tips": "Use busca por palavras-chave como 'attitude simulation example' ou 'quaternion maneuver' para localizar seções rapidamente.",
                                  "learningObjective": "Compreender os exemplos canônicos de simulação de atitude e extrair dados precisos para reprodução.",
                                  "commonMistakes": "Ignorar unidades de medida (rad/s vs deg/s) ou assumir parâmetros sem verificar equações originais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração do Ambiente de Simulação",
                                  "subSteps": [
                                    "Selecione e instale software de simulação (MATLAB/Simulink ou Python com SciPy/NumPy).",
                                    "Implemente os modelos matemáticos básicos: cinemática de quaternions, equações de Euler e torques de controle.",
                                    "Defina funções para os parâmetros exatos dos exemplos de Sidi, Wiesel e Wertz (ex: momento de inércia, gains de controlador PD).",
                                    "Crie scripts modulares para cada simulação autor-specific.",
                                    "Teste com condições iniciais simples para validar implementação básica."
                                  ],
                                  "verification": "Scripts executáveis sem erros que reproduzem uma simulação trivial (ex: rotação constante).",
                                  "estimatedTime": "5-8 horas",
                                  "materials": "MATLAB/Simulink ou Python (Anaconda); bibliotecas (scipy, numpy, matplotlib); referências bibliográficas anotadas.",
                                  "tips": "Use vetores colunas para estados consistentes com convenções aeroespaciais; versionar código com Git.",
                                  "learningObjective": "Configurar um simulador fiel aos modelos referenciados para reprodução precisa.",
                                  "commonMistakes": "Erros de sinal nas equações de Poisson para quaternions ou inversão de matrizes de inércia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Execução das Simulações Reprodutivas",
                                  "subSteps": [
                                    "Execute simulações idênticas aos exemplos de cada autor, usando parâmetros exatos.",
                                    "Registre saídas: trajetórias de quaternions, ângulos de Euler, velocidades angulares ao longo do tempo.",
                                    "Gere gráficos comparativos (plots de tempo vs estado) para visualização.",
                                    "Salve dados numéricos em formato CSV para análise posterior.",
                                    "Repita simulações com solver de alta precisão (ex: ode45 com RelTol=1e-9)."
                                  ],
                                  "verification": "Gráficos e dados CSV gerados para todas as três simulações, sem crashes ou divergências numéricas.",
                                  "estimatedTime": "6-10 horas",
                                  "materials": "Ambiente de simulação configurado; templates de plotting; storage para dados (Google Drive ou local).",
                                  "tips": "Monitore tempo de CPU e ajuste step size para eficiência; use legendas claras nos plots.",
                                  "learningObjective": "Gerar resultados reprodutíveis das simulações referenciadas com alta fidelidade numérica.",
                                  "commonMistakes": "Solver inadequado levando a instabilidades; escalas erradas nos plots ocultando discrepâncias."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparação e Validação dos Resultados",
                                  "subSteps": [
                                    "Compare numericamente: calcule erros RMS para quaternions, Euler angles e rates vs resultados bibliográficos.",
                                    "Analise qualitativamente: superponha curvas e discuta convergência/estabilidade.",
                                    "Calcule métricas de validação (ex: erro máximo <5%, tempo de settling similar).",
                                    "Identifique e justifique discrepâncias (ex: diferenças em aproximações lineares).",
                                    "Documente relatório com tabelas de erros e conclusões sobre validade do modelo."
                                  ],
                                  "verification": "Relatório com métricas de erro < threshold aceitável e gráficos sobrepostos.",
                                  "estimatedTime": "4-7 horas",
                                  "materials": "Dados CSV das simulações; ferramentas de análise (Excel, Python pandas/matplotlib); template de relatório LaTeX/Word.",
                                  "tips": "Use métricas normalizadas (ex: erro percentual) para comparações justas entre escalas.",
                                  "learningObjective": "Aplicar métodos quantitativos/qualitativos para validar modelos contra benchmarks estabelecidos.",
                                  "commonMistakes": "Comparar curvas sem alinhar tempo zero ou ignorar fases transitórias."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentação e Reflexão Final",
                                  "subSteps": [
                                    "Compile relatório completo: introdução, métodos, resultados, comparação e conclusões.",
                                    "Inclua código fonte, dados e referências bibliográficas.",
                                    "Reflita sobre lições aprendidas e sugestões para melhorias no modelo.",
                                    "Compartilhe repositório GitHub com README explicativo.",
                                    "Autoavalie aderência aos critérios de validação."
                                  ],
                                  "verification": "Relatório final e repositório público acessíveis e completos.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Template de relatório; GitHub; ferramentas de edição (Overleaf para LaTeX).",
                                  "tips": "Estruture relatório como paper acadêmico para prática profissional.",
                                  "learningObjective": "Sintetizar processo de validação em documento profissional e reflexivo.",
                                  "commonMistakes": "Omitir código ou dados raw, tornando resultados irreprodutíveis."
                                }
                              ],
                              "practicalExample": "Reproduza a simulação de manobra de apontamento de 90° de Sidi (Capítulo 8), usando quaternions iniciais [0.707,0,0,0.707], ω0=[0,0,0.1] rad/s, e compare erro RMS de Euler angles com figura 8.12, visando <2% discrepância; repita para exemplos equivalentes de Wiesel (Ex. 4.5) e Wertz (Seção 15.3).",
                              "finalVerifications": [
                                "Erros RMS em estados de atitude <5% dos valores bibliográficos para todas simulações.",
                                "Gráficos sobrepostos mostram convergência qualitativa idêntica.",
                                "Relatório documenta todas métricas e justificativas de discrepâncias.",
                                "Código é executável e reproduz resultados em máquina padrão.",
                                "Referências bibliográficas citadas corretamente com páginas/exemplos específicos.",
                                "Repositório Git inclui dados raw e instruções de reprodução."
                              ],
                              "assessmentCriteria": [
                                "Precisão da reprodução: fidelidade numérica aos parâmetros originais (30%).",
                                "Qualidade da comparação: métricas quantitativas e análise qualitativa (25%).",
                                "Documentação: clareza, completude e profissionalismo do relatório (20%).",
                                "Robustez do código: modularidade, comentários e reprodutibilidade (15%).",
                                "Análise de erros: identificação e correção de discrepâncias (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: álgebra linear (quaternions, matrizes de rotação) e EDOs numéricas.",
                                "Programação: desenvolvimento de scripts em MATLAB/Python com visualização de dados.",
                                "Física: mecânica clássica (momentos angulares, torques) e dinâmica rígida.",
                                "Engenharia de Software: versionamento (Git) e validação de modelos computacionais.",
                                "Pesquisa Científica: revisão bibliográfica e métodos de validação experimental."
                              ],
                              "realWorldApplication": "Em missões espaciais como CubeSats ou satélites da NASA/ESA, validar software de controle de atitude contra benchmarks como Sidi/Wiesel garante confiabilidade antes do lançamento, evitando falhas como a perda de contato do satélite UARS em 2005 devido a erros de modelagem."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Controle de Atitude",
                "description": "Métodos de controle incluindo sistemas propulsivos, torque de pressão solar, atuadores de troca de momentos (rodas de reação e roda com gimbal) e torque magnético.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Sistemas Propulsivos",
                    "description": "Métodos de controle de atitude utilizando propulsores para gerar torque de forma precisa.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Princípios de Funcionamento dos Propulsores",
                        "description": "Fundamentos físicos e operacionais dos propulsores utilizados no controle de atitude, incluindo geração de força e torque por ejeção de massa.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Identificar componentes principais de um sistema propulsivo",
                            "description": "Reconhecer e descrever tanques, válvulas, bicos e sistemas de controle em propulsores de gás frio, monopropelentes e bipropelentes para aplicações em atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender componentes comuns em sistemas propulsivos",
                                  "subSteps": [
                                    "Revise definições básicas de tanques (armazenamento de propelente), válvulas (controle de fluxo), bicos (expansão e ejeção) e sistemas de controle (eletrônicos para acionamento).",
                                    "Estude diagramas esquemáticos genéricos de thrusters para controle de atitude.",
                                    "Identifique funções primárias de cada componente em contextos espaciais.",
                                    "Compare tamanhos e materiais típicos usados em aplicações de atitude.",
                                    "Anote interconexões entre componentes em um fluxograma simples."
                                  ],
                                  "verification": "Crie um fluxograma rotulando corretamente tanques, válvulas, bicos e controles; verifique com uma referência padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagramas de thrusters online (NASA ou textbooks), papel e caneta para fluxograma.",
                                  "tips": "Use cores diferentes para cada componente para visualização melhor.",
                                  "learningObjective": "Reconhecer e descrever funções básicas dos quatro componentes principais em qualquer sistema propulsivo.",
                                  "commonMistakes": "Confundir válvulas com bicos; ignorar sistemas de controle como 'apenas eletrônicos'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar propulsores de gás frio",
                                  "subSteps": [
                                    "Descreva o princípio: expansão de gás armazenado sob pressão através de válvula e bico.",
                                    "Identifique tanque de alta pressão, válvula solenóide simples e bico convergente.",
                                    "Examine ausência de câmara de combustão e sistemas de controle mínimos (pressostatos).",
                                    "Revise exemplos como nitrogênio ou hélio em satélites CubeSat.",
                                    "Simule fluxo com um diagrama anotado."
                                  ],
                                  "verification": "Desenhe e label um diagrama específico de gás frio, listando componentes e funções.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Imagens/diagramas de cold gas thrusters (ex: ESA ou SpaceX docs), software de desenho simples como Draw.io.",
                                  "tips": "Foquem na simplicidade: menos componentes = mais confiável para atitude fina.",
                                  "learningObjective": "Identificar configuração única de gás frio e suas limitações para controle de atitude.",
                                  "commonMistakes": "Pensar que gás frio requer ignição; subestimar pressão no tanque."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar propulsores monopropelentes",
                                  "subSteps": [
                                    "Aprenda decomposição catalítica de propelentes como hidrazina em catalisador.",
                                    "Localize tanque de propelente, válvula de isolamento, injetor/catalisador e bico.",
                                    "Descreva sistemas de controle com sensores de temperatura e pressão.",
                                    "Compare com gás frio: adição de câmara de decomposição.",
                                    "Estude exemplos como RCS em naves espaciais (ex: Apollo)."
                                  ],
                                  "verification": "Liste diferenças de componentes vs. gás frio e justifique em um parágrafo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Vídeos de monopropelente thrusters (YouTube: NASA Glenn), diagramas anotados.",
                                  "tips": "Lembre: catalisador é chave; sem ele, não funciona.",
                                  "learningObjective": "Reconhecer adições específicas em monopropelentes para maior impulso.",
                                  "commonMistakes": "Confundir tanque com câmara de combustão; ignorar riscos de hidrazina."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar propulsores bipropelentes e sintetizar",
                                  "subSteps": [
                                    "Entenda combustão de combustível + oxidante (ex: MMH/NTO).",
                                    "Identifique tanques separados, válvulas duplas, misturador/injetor, câmara de combustão e bico.",
                                    "Analise sistemas de controle avançados (sequenciadores, ignitores).",
                                    "Compare todos os três tipos em uma tabela de componentes.",
                                    "Descreva aplicações em controle de atitude preciso."
                                  ],
                                  "verification": "Complete tabela comparativa com 100% acurácia verificada por fonte confiável.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabelas comparativas online (ex: Wikipedia Propulsion, textbooks aeroespaciais), planilha Excel.",
                                  "tips": "Use abreviações padrão: RCS para Reaction Control System.",
                                  "learningObjective": "Diferenciar configurações bipropelentes e integrar conhecimento de todos os tipos.",
                                  "commonMistakes": "Misturar tanques (não são separados em mono); superestimar simplicidade."
                                }
                              ],
                              "practicalExample": "Examine o diagrama de um thruster de atitude do satélite CubeSat da NASA: identifique o tanque de nitrogênio (gás frio), válvula solenóide, bico Laval e controlador PID; descreva como ajusta rotação em 0.1°/s.",
                              "finalVerifications": [
                                "Liste corretamente os 4 componentes principais para cada tipo de propelente.",
                                "Descreva funções de tanque, válvula, bico e controle sem erros.",
                                "Diferencie diagramas de gás frio vs. monopropelente vs. bipropelente.",
                                "Explique limitações de cada tipo para controle de atitude.",
                                "Crie fluxograma funcional de um sistema completo.",
                                "Identifique componentes em imagem real de thruster (ex: foto de SpaceX Draco)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (90%+ correto).",
                                "Descrições funcionais claras e concisas (mínimo 1 frase por componente).",
                                "Comparação precisa entre tipos de propelentes.",
                                "Uso correto de terminologia técnica (ex: 'bico convergente-divergente').",
                                "Demonstração de compreensão via diagrama ou tabela auto-explicativa.",
                                "Aplicação contextual a controle de atitude em veículos espaciais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios de termodinâmica e conservação de momento linear.",
                                "Química: Reações de decomposição e combustão de propelentes.",
                                "Engenharia Mecânica: Design de válvulas e fluxos de alta pressão.",
                                "Eletrônica: Sistemas de controle PID e sensores embarcados.",
                                "Matemática: Cálculos de impulso específico (Isp) e deltav."
                              ],
                              "realWorldApplication": "Em satélites como o Starlink ou missões Mars Rover, esses sistemas propulsivos corrigem atitude para manter painéis solares alinhados ou antenas apontando para Terra, garantindo comunicação e estabilidade orbital com precisão de miliradianos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Calcular impulso específico e variação de velocidade",
                            "description": "Aplicar equações I_sp = v_e / g_0 e Δv = v_e * ln(m0/mf) para quantificar o desempenho de propulsores em manobras de atitude precisas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Impulso Específico e Variação de Velocidade",
                                  "subSteps": [
                                    "Defina impulso específico (I_sp) como a eficiência do propursor, medida em segundos.",
                                    "Explique velocidade de exaustão (v_e) como a velocidade dos gases expelidos.",
                                    "Identifique g_0 como a aceleração gravitacional padrão (9.80665 m/s²).",
                                    "Descreva Δv como a mudança na velocidade do veículo devido ao propursor.",
                                    "Discuta m0 (massa inicial) e mf (massa final) no contexto de propelentes."
                                  ],
                                  "verification": "Resuma os conceitos em um diagrama ou tabela comparativa com definições corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de propulsão espacial, vídeo introdutório sobre foguetes (ex: Khan Academy).",
                                  "tips": "Use analogias como 'I_sp é como km/l em carros' para fixar ideias.",
                                  "learningObjective": "Dominar definições e unidades das variáveis envolvidas nas equações.",
                                  "commonMistakes": "Confundir v_e com velocidade do veículo ou ignorar unidades consistentes (SI)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Impulso Específico (I_sp)",
                                  "subSteps": [
                                    "Colete dados de v_e para um propursor típico (ex: 3000 m/s para hidrazina).",
                                    "Aplique a equação I_sp = v_e / g_0.",
                                    "Converta unidades se necessário (m/s para km/s).",
                                    "Calcule para 3 propulsores diferentes e compare resultados.",
                                    "Interprete o valor: I_sp > 200s indica alta eficiência."
                                  ],
                                  "verification": "Verifique se cálculos batem com valores tabelados em referências (erro <1%).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou Python para cálculos.",
                                  "tips": "Sempre use g_0 exato para precisão em missões espaciais.",
                                  "learningObjective": "Aplicar corretamente a equação I_sp e interpretar seu significado físico.",
                                  "commonMistakes": "Esquecer de dividir por g_0 ou usar g local em vez de padrão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Variação de Velocidade (Δv)",
                                  "subSteps": [
                                    "Obtenha v_e do passo anterior e massas m0/mf (ex: razão de massa 1.1 para manobras pequenas).",
                                    "Calcule ln(m0/mf) usando log natural.",
                                    "Aplique Δv = v_e * ln(m0/mf).",
                                    "Teste com diferentes razões de massa para manobras de atitude (Δv ~0.01-0.1 m/s).",
                                    "Analise impacto: Δv pequeno para controle preciso."
                                  ],
                                  "verification": "Compare Δv calculado com simulações de software como GMAT (erro <0.5%).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de cálculo (MATLAB/Python), tabela de propulsores espaciais.",
                                  "tips": "Use logaritmo natural (ln), não log10; verifique com calculadora.",
                                  "learningObjective": "Executar cálculo de Δv e relacioná-lo a orçamentos de propelente.",
                                  "commonMistakes": "Usar log comum em vez de natural ou inverter m0/mf."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Manobras de Atitude Precisas",
                                  "subSteps": [
                                    "Defina cenário: satélite CubeSat com propulsores de 1N para correção de 0.05°/s.",
                                    "Integre I_sp e Δv para estimar tempo de queima e consumo de propelente.",
                                    "Simule iterações múltiplas para manobras compostas.",
                                    "Avalie limitações: precisão vs. eficiência.",
                                    "Otimize parâmetros para minimizar Δv residual."
                                  ],
                                  "verification": "Gere relatório com gráficos de Δv vs. massa, validado por equação de Tsiolkovsky.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador de atitude (ex: FreeFlyer trial), dados reais de missões CubeSat.",
                                  "tips": "Comece com valores realistas de missões como MarCO para grounding.",
                                  "learningObjective": "Integrar cálculos em contexto operacional de controle de atitude.",
                                  "commonMistakes": "Ignorar efeitos de arrasto ou torque em Δv linear."
                                }
                              ],
                              "practicalExample": "Para um propursor de hidrazina em CubeSat (v_e=2200 m/s, g_0=9.80665 m/s², m0=2kg, mf=1.95kg): I_sp=224.3s, Δv=109 m/s. Use para manobra de 1° em 10s, consumindo 5% do propelente.",
                              "finalVerifications": [
                                "Cálculos de I_sp coincidem com especificações do fabricante (±2%).",
                                "Δv calculado permite manobra precisa sem exceder orçamento de propelente.",
                                "Gráficos mostram relação logarítmica correta entre massa e Δv.",
                                "Interpretação física está alinhada com princípios de conservação de momento.",
                                "Simulação integrada reproduz trajetória de atitude esperada."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro <1%).",
                                "Correta aplicação e interpretação das equações.",
                                "Uso apropriado de unidades SI consistentes.",
                                "Análise contextual para manobras de atitude.",
                                "Capacidade de otimizar parâmetros para eficiência.",
                                "Clareza na documentação de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Conservação de momento linear e equação do foguete.",
                                "Matemática: Logaritmos naturais e funções exponenciais.",
                                "Engenharia: Design de sistemas propulsivos e orçamentos de missão.",
                                "Programação: Implementação em Python para simulações dinâmicas."
                              ],
                              "realWorldApplication": "Em missões como o satélite MarCO da NASA, esses cálculos determinam o propelente necessário para manobras de atitude precisas durante flybys planetários, garantindo apontamento de antenas e estabilidade orbital."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Analisar conservação de momento angular",
                            "description": "Explicar como a ejeção de propelente gera torque reativo em veículos espaciais sem atmosfera, considerando momento inercial da spacecraft.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de momento angular",
                                  "subSteps": [
                                    "Defina momento angular como L = I ω, onde I é o momento de inércia e ω é a velocidade angular.",
                                    "Explique a conservação do momento angular em sistemas isolados sem torque externo.",
                                    "Discuta a ausência de atmosfera em veículos espaciais, tornando o sistema isolado.",
                                    "Identifique torque reativo como mudança no momento angular da spacecraft."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e forneça um exemplo simples como um patinador girando.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de física (Mecânica), calculadora, papel e caneta",
                                  "tips": "Use analogias cotidianas como um gato caindo para ilustrar conservação.",
                                  "learningObjective": "Compreender a base teórica da conservação do momento angular.",
                                  "commonMistakes": "Confundir momento linear com angular; ignorar que o sistema é isolado no vácuo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o sistema spacecraft-propelente",
                                  "subSteps": [
                                    "Represente a spacecraft com momento de inércia I_sc e velocidade angular inicial ω_0.",
                                    "Inclua o propelente como massa m_p com velocidade relativa v_e (velocidade de exaustão).",
                                    "Defina o sistema total inicial com momento angular L_total = I_sc ω_0.",
                                    "Considere a ejeção assimétrica para gerar torque.",
                                    "Calcule o momento de inércia efetivo pós-ejeção."
                                  ],
                                  "verification": "Desenhe um diagrama vetorial do sistema antes e após ejeção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de desenho vetorial (ex: GeoGebra), caderno de anotações",
                                  "tips": "Comece com valores numéricos simples para testar o modelo.",
                                  "learningObjective": "Construir um modelo matemático preciso do sistema isolado.",
                                  "commonMistakes": "Esquecer a direção vetorial do momento angular; assumir ejeção simétrica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a ejeção de propelente e conservação",
                                  "subSteps": [
                                    "Aplique conservação: L_inicial = L_final = I_sc ω_final + m_p v_e r, onde r é o braço de alavanca.",
                                    "Derive a mudança ΔL = - m_p v_e r (torque reativo).",
                                    "Calcule a aceleração angular α = ΔL / I_sc.",
                                    "Simule numericamente com valores: m_p = 0.1 kg, v_e = 200 m/s, r = 1 m, I_sc = 10 kg m²."
                                  ],
                                  "verification": "Resolva um problema numérico e verifique se L_inicial ≈ L_final (erro <1%).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python ou MATLAB para cálculos, tabela de valores típicos de propulsores",
                                  "tips": "Use vetores unitários para direções precisas do thrust.",
                                  "learningObjective": "Aplicar conservação para prever rotação induzida.",
                                  "commonMistakes": "Negligenciar o braço de alavanca r; confundir massa ejetada com total."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar momento de inércia e validar torque reativo",
                                  "subSteps": [
                                    "Calcule I_sc considerando geometria da spacecraft (ex: tensor de inércia).",
                                    "Integre torque ao longo do tempo para rotação total θ = ∫ α dt.",
                                    "Compare com dados reais de thrusters (ex: velocidade de exaustão específica).",
                                    "Analise estabilidade: como variações em I afetam o controle.",
                                    "Crie uma simulação simples de rotação."
                                  ],
                                  "verification": "Gere gráfico de ω vs tempo e confirme torque proporcional à ejeção.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com NumPy/Matplotlib, referências de propulsores espaciais",
                                  "tips": "Linearize para pequenas rotações se necessário.",
                                  "learningObjective": "Integrar momento de inércia no cálculo de torque reativo.",
                                  "commonMistakes": "Usar momento de inércia escalar em vez de tensor; ignorar depleção de massa."
                                }
                              ],
                              "practicalExample": "Em um CubeSat com thrusters de gás frio, ejetar 5g de nitrogênio a 150 m/s por um nozzle a 0.5m do centro de massa gera ΔL ≈ 0.375 kg m²/s, rotacionando o satélite (I=2 kg m²) em ≈10.7°/s, usado para correção de atitude.",
                              "finalVerifications": [
                                "Explica corretamente conservação em vácuo sem forças externas.",
                                "Calcula torque reativo com erro <5% em exemplo numérico.",
                                "Desenha diagrama vetorial preciso do sistema.",
                                "Identifica impacto do momento de inércia na magnitude da rotação.",
                                "Simula rotação induzida em software básico.",
                                "Discute limitações como depleção de propelente."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual da conservação do momento angular (30%)",
                                "Correção matemática nos cálculos de torque (25%)",
                                "Incorporação adequada do momento de inércia (20%)",
                                "Qualidade da simulação e gráficos (15%)",
                                "Clareza na explicação e exemplos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica Clássica e Dinâmica Rotacional",
                                "Matemática: Álgebra Vetorial e Cálculo Diferencial",
                                "Engenharia Mecânica: Análise de Tensores de Inércia",
                                "Computação: Programação Numérica e Simulações",
                                "Química: Propriedades de Propelentes e Velocidade de Exaustão"
                              ],
                              "realWorldApplication": "No controle de atitude da Estação Espacial Internacional (ISS), thrusters de controle de reação ejetam propelente para gerar torque reativo preciso, mantendo orientação sem atmosfera, considerando o grande momento de inércia da estrutura."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Configurações Geométricas para Geração de Torque",
                        "description": "Arranjos espaciais de propulsores para produzir torques controlados nos eixos roll, pitch e yaw de forma independente e precisa.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Desenhar configurações de thrusters off-axis",
                            "description": "Projetar posicionamento de propulsores desalinhados do centro de massa para maximizar torque com mínimo impulso linear indesejado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Dinâmica de Atitude e Propulsão",
                                  "subSteps": [
                                    "Identifique o centro de massa (CoM) de um veículo espacial típico e seu papel no controle de atitude.",
                                    "Estude vetores de força e momento gerados por thrusters, diferenciando impulso linear e torque angular.",
                                    "Analise configurações on-axis vs. off-axis, destacando como o braço de momento (distância perpendicular ao CoM) afeta o torque.",
                                    "Revise equações básicas: Torque τ = r × F, onde r é o vetor posição do thruster relativo ao CoM.",
                                    "Explore trade-offs: maximizar torque minimiza impulso linear indesejado via otimização geométrica."
                                  ],
                                  "verification": "Resuma em um diagrama simples os conceitos chave e equações, confirmando compreensão com um colega ou autoavaliação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de dinâmica orbital (ex: Curtis 'Orbital Mechanics'), software de desenho vetorial (ex: Draw.io), notas de aula sobre controle de atitude"
                                  ],
                                  "tips": "Use diagramas 2D/3D para visualizar vetores; foque em exemplos reais como Reaction Control System (RCS) da ISS.",
                                  "learningObjective": "Compreender os princípios físicos que governam o torque off-axis em thrusters.",
                                  "commonMistakes": [
                                    "Confundir impulso linear com torque; ignorar direção do vetor r; assumir simetria perfeita no CoM."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Torque e Impulso para Configurações Off-Axis",
                                  "subSteps": [
                                    "Defina parâmetros: posição do thruster (r_x, r_y, r_z), força do thruster (F), direção do empuxo.",
                                    "Calcule torque resultante usando produto vetorial: τ = |r| * F * sin(θ), onde θ é o ângulo entre r e F.",
                                    "Compute impulso linear total: Δv = F * t / m, identificando componentes indesejadas.",
                                    "Teste múltiplas posições off-axis (ex: 10cm, 20cm do CoM) e compare métricas: torque/impulso ratio.",
                                    "Otimize matematicamente para maximizar τ minimizando ||Δv|| usando álgebra linear básica."
                                  ],
                                  "verification": "Produza uma tabela com 5 configurações calculadas, mostrando torque > 0.1 Nm com Δv < 0.01 m/s.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora simbólica (ex: MATLAB, Python com NumPy), planilha Excel para tabelas, referências de thrust levels (ex: cold gas thrusters 0.1-1N)"
                                  ],
                                  "tips": "Vectorize cálculos em Python para eficiência; normalize unidades (SI) para evitar erros.",
                                  "learningObjective": "Dominar cálculos quantitativos para avaliar eficiência de configurações off-axis.",
                                  "commonMistakes": [
                                    "Erros em produto vetorial (direção errada); esquecer massa do veículo; não considerar múltiplos thrusters."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar Configuração Geométrica Otimizada",
                                  "subSteps": [
                                    "Esboce layout 3D do veículo com CoM marcado e posicione 4-8 thrusters off-axis simetricamente.",
                                    "Aplique critérios: braços de momento iguais para pares opostos, ângulos otimizados para eixos X/Y/Z.",
                                    "Incorpore redundância: pelo menos 2 thrusters por eixo de rotação.",
                                    "Avalie estabilidade: verifique se configuração permite controle puro de torque sem drift linear.",
                                    "Documente design com especificações: dimensões, thrust, materiais sugeridos para thrusters."
                                  ],
                                  "verification": "Crie blueprint CAD ou diagrama com anotações, validado por simulação estática de torque.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software CAD (ex: FreeCAD, SolidWorks), papel milimetrado para esboços iniciais, templates de CubeSat chassis"
                                  ],
                                  "tips": "Comece com simetria axial; use otimização iterativa testando variações de ±5cm.",
                                  "learningObjective": "Criar designs geométricos práticos que maximizem torque com mínimo desperdício.",
                                  "commonMistakes": [
                                    "Assimetria levando a torques espúrios; posicionamento muito próximo ao CoM reduzindo torque; ignorar constraints de volume."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Iterar o Design",
                                  "subSteps": [
                                    "Implemente modelo dinâmico em simulador (ex: thruster forces em 6DOF).",
                                    "Execute manobras de atitude (ex: 10°/s slew) e meça overshoot e consumo de propelente.",
                                    "Analise resultados: plote torque vs. tempo e Δv residual.",
                                    "Itere design: ajuste posições baseadas em métricas (reduzir Δv >20%).",
                                    "Valide contra requisitos: torque mínimo 0.05 Nm/axis com Δv <0.005 m/s por manobra."
                                  ],
                                  "verification": "Gere relatório de simulação com gráficos e design final revisado.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de simulação (ex: GMAT, Python com PyBullet ou Orekit), dados de missão hipotética (CubeSat 1U)"
                                  ],
                                  "tips": "Use cenários realistas com inércia conhecida; grave simulações para revisão.",
                                  "learningObjective": "Validar designs através de simulação dinâmica e otimização iterativa.",
                                  "commonMistakes": [
                                    "Modelo incompleto (sem inércia ou perturbações); escalas erradas em simulação; não iterar o suficiente."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um CubeSat 1U (10x10x10cm, massa 1.3kg), posicione 4 thrusters cold-gas de 0.2N a 5cm off-axis nos cantos da face Z, gerando 0.08 Nm de torque em roll/pitch com Δv residual <0.002 m/s por firing de 1s.",
                              "finalVerifications": [
                                "Configuração gera torque ≥0.05 Nm por eixo com simetria perfeita.",
                                "Impulso linear total <0.01 m/s para manobra de 90°.",
                                "Design cabe em envelope de volume do veículo (ex: <20% da superfície).",
                                "Redundância permite falha de 1 thruster sem perda de controle.",
                                "Simulação confirma settling time <5s pós-manobra.",
                                "Documentação inclui cálculos, diagramas e resultados de simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de torque/impulso (erro <5%).",
                                "Otimização do ratio torque/Δv (>80% eficiência).",
                                "Criatividade e viabilidade do design geométrico.",
                                "Qualidade da simulação e análise de resultados.",
                                "Documentação clara e completa.",
                                "Integração de trade-offs reais (massa, volume, custo)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (produtos vetoriais, matrizes de inércia).",
                                "Física: Mecânica newtoniana e conservação de momento angular.",
                                "Programação: Modelagem numérica e simulação em Python/MATLAB.",
                                "Engenharia Mecânica: Design CAD e otimização estrutural.",
                                "Ciência de Materiais: Seleção de thrusters e montagens."
                              ],
                              "realWorldApplication": "Usado em CubeSats como o CPOD da NASA para detumbling pós-deploy, ou RCS da Starship para controle preciso durante docking, minimizando consumo de propelente e mantendo órbita estável."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Calcular torque gerado por clusters de propulsores",
                            "description": "Usar vetores de força e braços de alavanca para computar τ = r × F em configurações canted e orthogonal para os três eixos de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Torque e Produto Vetorial",
                                  "subSteps": [
                                    "Defina torque como τ = r × F, onde r é o vetor de posição do ponto de aplicação da força e F é o vetor força.",
                                    "Revise o produto vetorial em 3D: memorize a fórmula determinantal i(j×k) e pratique com exemplos simples em 2D.",
                                    "Identifique os eixos de atitude (roll, pitch, yaw) em veículos espaciais e como torque atua neles.",
                                    "Desenhe diagramas de braços de alavanca para forças perpendiculares e paralelas.",
                                    "Calcule magnitude de torque |τ| = r F sinθ para casos escalares iniciais."
                                  ],
                                  "verification": "Resolva 3 problemas básicos de produto vetorial e torque, verificando com software como MATLAB ou Python (SymPy).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de mecânica vetorial (ex: Beer & Johnston)",
                                    "Calculadora científica",
                                    "Software de vetores (GeoGebra ou Python com NumPy)"
                                  ],
                                  "tips": "Sempre normalize vetores para evitar erros de escala; use mão direita para direção do torque.",
                                  "learningObjective": "Compreender matematicamente o torque como grandeza vetorial e sua relação com vetores r e F.",
                                  "commonMistakes": [
                                    "Confundir produto escalar com vetorial",
                                    "Esquecer a direção perpendicular ao plano r-F",
                                    "Usar magnitudes sem senθ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Configurações Geométricas Orthogonais",
                                  "subSteps": [
                                    "Desenhe um cluster orthogonal: propulsores alinhados perpendicularmente aos eixos x, y, z do corpo do veículo.",
                                    "Defina posições r para cada propulsor (ex: r1 = (d,0,0), r2=(0,d,0), etc., onde d é distância do CG).",
                                    "Assuma forças F impulsivas idênticas em magnitude, direcionadas para fora.",
                                    "Calcule torque individual para um propulsor: τ = r × F.",
                                    "Some torques para o cluster: verifique cancelamento em eixos indesejados."
                                  ],
                                  "verification": "Crie diagrama vetorial e calcule τ total para rotação pura em um eixo, confirmando τ_y = τ_z = 0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel milimetrado ou software CAD (FreeCAD)",
                                    "Planilhas Excel para vetores",
                                    "Vídeos tutoriais sobre clusters RCS (Reaction Control System)"
                                  ],
                                  "tips": "Use coordenadas do corpo do veículo; rotule claramente CG (centro de gravidade).",
                                  "learningObjective": "Modelar geometricamente clusters orthogonais e prever torques decoplados por eixo.",
                                  "commonMistakes": [
                                    "Posicionar propulsores simetricamente mas somar torques errados",
                                    "Ignorar sinal das forças (empuxo vs. direção)",
                                    "Confundir eixos inerciais com eixos do corpo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Torque em Configurações Canted",
                                  "subSteps": [
                                    "Defina configuração canted: propulsores inclinados em ângulo θ em relação aos eixos principais.",
                                    "Estabeleça vetores r e F com componentes: F = (F cosθ, F sinθ, 0) para exemplo em plano xy.",
                                    "Compute τ = r × F usando matriz de produto vetorial para cada propulsor.",
                                    "Analise acoplamento: torque em eixo desejado + componentes espúrias em outros eixos.",
                                    "Otimize θ para maximizar torque principal minimizando spill-over (use derivadas ou simulação)."
                                  ],
                                  "verification": "Para θ=45°, calcule τ e verifique que tem componentes em dois eixos; compare com orthogonal.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python/MATLAB para computação vetorial",
                                    "Tabelas de seno/cosseno",
                                    "Artigo sobre thruster canted em CubeSats"
                                  ],
                                  "tips": "Implemente função vetorial em código para iterar ângulos; visualize com Matplotlib 3D.",
                                  "learningObjective": "Quantificar torques em configurações inclinadas, incluindo acoplamentos indesejados.",
                                  "commonMistakes": [
                                    "Erro no sinal do senθ no produto vetorial",
                                    "Assumir independência de eixos sem calcular",
                                    "Não converter unidades (N para mN, m para cm)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Clusters Multi-Propulsores nos Três Eixos",
                                  "subSteps": [
                                    "Monte cluster completo: 4-12 propulsores para controle 3D (ex: +X, -X, +Y, etc.).",
                                    "Calcule τ_net = Σ (r_i × F_i) para manobra específica (ex: rotação yaw 0.1 rad/s).",
                                    "Simule falha em um propulsor e recalcule τ degradado.",
                                    "Compare orthogonal vs. canted em eficiência (torque por massa de propelente).",
                                    "Valide com equação de atitude: I α = τ, onde I é inércia, α aceleração angular."
                                  ],
                                  "verification": "Simule cluster de 8 propulsores; produza tabela de τ por eixo e gráfico de vetores.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Simulador orbital (ex: GMAT ou Orekit)",
                                    "Jupyter Notebook com NumPy/SciPy",
                                    "Dados de CubeSat real (ex: NASA specifications)"
                                  ],
                                  "tips": "Vetorize cálculos em loop para eficiência; teste com I identidade primeiro.",
                                  "learningObjective": "Integrar cálculos para sistemas reais de controle de atitude multi-propulsor.",
                                  "commonMistakes": [
                                    "Não somar vetores corretamente em clusters assimétricos",
                                    "Esquecer inércia na dinâmica final",
                                    "Overlook thrust misalignment devido a fabricação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat 3U, cluster orthogonal de 4 propulsores a 10 cm do CG gera τ_x = 4 * (0.1 * 0.5 N * sin90°) = 0.2 Nm para roll; em canted θ=30°, τ_x = 0.15 Nm com τ_y spillover de 0.05 Nm, simulando correção de eclipse.",
                              "finalVerifications": [
                                "Calcula τ corretamente para orthogonal e canted com erro <1%.",
                                "Identifica e quantifica acoplamentos em configurações canted.",
                                "Simula cluster completo e prevê dinâmica de atitude básica.",
                                "Valida com software, matching resultados manuais.",
                                "Analisa impacto de falhas em τ_net.",
                                "Compara eficiência entre configurações."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos produtos vetoriais (100% correto).",
                                "Correta modelagem geométrica de r e F.",
                                "Análise qualitativa/quantitativa de acoplamentos.",
                                "Uso apropriado de ferramentas computacionais.",
                                "Clareza em diagramas e explicações.",
                                "Aplicação a cenários reais com unidades consistentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e vetores (produto cruzado).",
                                "Física: Dinâmica rotacional e leis de Newton.",
                                "Engenharia Mecânica: Design de sistemas de controle.",
                                "Programação: Simulação numérica (Python/MATLAB).",
                                "Ciência de Materiais: Tolerâncias em thrusters."
                              ],
                              "realWorldApplication": "Projeto de Reaction Control Systems (RCS) em satélites como Starlink ou missões Mars rovers, otimizando clusters para manobras precisas de pointing com mínimo propelente, evitando tumblings descontrolados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Avaliar redundância e falhas em configurações",
                            "description": "Analisar impactos de falha de um propuidor em arranjos redundantes e estratégias de reconfiguração para manter controle de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Configurações Geométricas Redundantes de Propulsores",
                                  "subSteps": [
                                    "Estude diagramas de configurações comuns como cruzada (+), collinear e pseudo-ortogonal para geração de torque.",
                                    "Identifique graus de redundância (ex.: mínimo 6 propulsores para 3 eixos com falha tolerância).",
                                    "Calcule matrizes de alocação de torque para configurações nominais usando álgebra linear.",
                                    "Analise singularidades e condições de controllability via determinante da matriz de controle.",
                                    "Documente vantagens e limitações de cada geometria em termos de redundância."
                                  ],
                                  "verification": "Crie um relatório resumindo 3 configurações com matrizes e análise de redundância, validado por simulação básica de torque.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Diagramas de configurações de propulsores (PDFs ou imagens)",
                                    "Software MATLAB/Python com toolbox de controle (ex.: Control Systems Toolbox)",
                                    "Folha de cálculo para matrizes"
                                  ],
                                  "tips": "Use visualizações 3D para entender geometrias; priorize configurações com alta fault-tolerance.",
                                  "learningObjective": "Dominar princípios de redundância geométrica em sistemas de controle de atitude.",
                                  "commonMistakes": [
                                    "Confundir redundância de hardware com software",
                                    "Ignorar efeitos de montagem off-nominal",
                                    "Não normalizar vetores de thrust"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar e Simular Falha de um Propulsor",
                                  "subSteps": [
                                    "Defina modelo dinâmico do veículo: equações de Euler com matriz de inércia.",
                                    "Implemente simulação numérica da configuração nominal gerando torques em roll, pitch e yaw.",
                                    "Introduza falha: zere o thrust de um propulsor específico e ajuste duty cycles.",
                                    "Execute simulações para diferentes propulsores falhando, registrando desvios de atitude.",
                                    "Compare respostas transitórias e estacionárias com baseline nominal."
                                  ],
                                  "verification": "Gere gráficos de simulação mostrando desvios de atitude <5° após falha, com código comentado.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Código Python/MATLAB para simulação 6-DOF",
                                    "Dados de exemplo: I = diag([100,100,200] kg m²), thrust = 1N",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Use solvers numéricos estáveis (ode45/odeint); inicie com falhas simétricas para validação.",
                                  "learningObjective": "Simular impactos dinâmicos de falhas isoladas em sistemas redundantes.",
                                  "commonMistakes": [
                                    "Não modelar delays de atuadores",
                                    "Escalar incorretamente unidades de torque",
                                    "Omitir ruído ou saturação de thrust"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impactos da Falha nos Modos de Controle",
                                  "subSteps": [
                                    "Avalie perda de controllability: compute rank da matriz degradada e valores singulares.",
                                    "Quantifique impactos: aumento em uso de outros propulsores, desvios de pointing, consumo de combustível.",
                                    "Analise estabilidade: verifique polos do sistema fechado pós-falha via análise de Lyapunov.",
                                    "Identifique modos degradados (ex.: perda de agilidade em um eixo).",
                                    "Compare com métricas de performance (settling time, overshoot)."
                                  ],
                                  "verification": "Relatório com tabelas de singular values e gráficos de performance degradation para 3 cenários de falha.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Funções SVD em NumPy/SciPy",
                                    "Templates de análise de controllability",
                                    "Referências: Sidi 'Spacecraft Dynamics and Control'"
                                  ],
                                  "tips": "Foquem em falhas assimétricas primeiro; use thresholds para 'aceitável' vs 'crítico'.",
                                  "learningObjective": "Quantificar e qualificar efeitos de falhas em performance de controle.",
                                  "commonMistakes": [
                                    "Assumir linearidade em grandes desvios",
                                    "Ignorar acoplamentos entre eixos",
                                    "Não considerar falhas parciais (leakage)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver e Testar Estratégias de Reconfiguração",
                                  "subSteps": [
                                    "Proponha reconfigurações: remapeie comandos de torque para propulsores restantes.",
                                    "Otimize nova matriz de alocação minimizando norma L1 para eficiência de combustível.",
                                    "Implemente lógica de detecção de falha (threshold-based) e switchover automático.",
                                    "Simule recuperação: aplique reconfiguração e verifique retorno a precisão nominal.",
                                    "Avalie trade-offs: custo computacional vs robustez."
                                  ],
                                  "verification": "Demonstre simulação end-to-end com recuperação <10s e precisão restaurada, código funcional.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Otimizadores (CVXPY ou fmincon)",
                                    "Código de Fault Detection and Isolation (FDI)",
                                    "Benchmark datasets de attitude maneuvers"
                                  ],
                                  "tips": "Teste com ruído realista; priorize reconfigurações fault-tolerant a múltiplas falhas.",
                                  "learningObjective": "Projetar estratégias acionáveis para manter controle sob falhas.",
                                  "commonMistakes": [
                                    "Sobrecarregar propulsores restantes além de limites",
                                    "Delay excessivo na detecção",
                                    "Não validar em cenários não-nominais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat com configuração cruzada de 8 thrusters (4 pares redundantes), simule falha do thruster #3 (roll+). Analise desvio de 3° em roll após 60s, então reconfigure alocando torque extra aos thrusters #7 e #1, restaurando pointing em 8s com +20% consumo de propelente.",
                              "finalVerifications": [
                                "Simulações mostram desvios <5° sem reconfiguração em redundâncias mínimas.",
                                "Matrizes reconfiguradas têm rank completo e singular values >0.8 do nominal.",
                                "Recuperação de atitude em <15s para 80% dos cenários de falha única.",
                                "Relatório documenta trade-offs quantitativos (combustível, agilidade).",
                                "Código roda sem erros em hardware simulado (ex.: Raspberry Pi).",
                                "Análise cobre falhas em todos eixos e geometrias estudadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de falhas (erro <1% em torque simulado).",
                                "Profundidade da análise de impactos (métricas quantitativas em todos eixos).",
                                "Criatividade e viabilidade das estratégias de reconfiguração.",
                                "Qualidade das simulações (gráficos claros, código modular e comentado).",
                                "Compreensão de trade-offs (eficiência vs robustez).",
                                "Aplicação correta de conceitos matemáticos (SVD, controllability)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de alocação, SVD).",
                                "Programação: Simulação numérica e otimização (Python/MATLAB).",
                                "Engenharia Mecânica: Dinâmica de corpos rígidos e vibrações.",
                                "Sistemas: Teoria de controle e fault-tolerant design.",
                                "Física: Cinemática orbital e conservação de momento angular."
                              ],
                              "realWorldApplication": "Em missões como o satélite Starlink ou a ISS, onde falhas de thrusters ocorreram (ex.: falha em CMS de 2013); reconfigurações automáticas mantêm pointing preciso para comunicações e experimentos científicos, evitando perda de missão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.4",
                            "name": "Otimizar posicionamento minimizando acoplamentos",
                            "description": "Minimizar torques cruzados entre eixos através de simulação geométrica e ajuste de ângulos de inclinação dos bicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Torques Cruzados e Acoplamentos em Sistemas Propulsivos",
                                  "subSteps": [
                                    "Estude a definição de torque principal e torque cruzado em sistemas de controle de atitude.",
                                    "Analise como o posicionamento e ângulos de inclinação dos bicos geram forças e torques vetoriais.",
                                    "Revise vetores de força e momento resultantes de múltiplos thrusters.",
                                    "Identifique fontes comuns de acoplamento entre eixos (roll, pitch, yaw).",
                                    "Calcule manualmente um exemplo simples de torque cruzado com 2 thrusters."
                                  ],
                                  "verification": "Resuma em um diagrama vetorial os torques gerados por um thruster inclinado, confirmando ausência de confusão conceitual.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livros de dinâmica orbital (ex: Sidi 'Spacecraft Dynamics'), software de desenho vetorial (ex: GeoGebra).",
                                  "tips": "Use convenções de coordenadas do corpo (body frame) para consistência.",
                                  "learningObjective": "Dominar os princípios físicos de acoplamento torque em configurações geométricas de thrusters.",
                                  "commonMistakes": "Confundir torque principal com componente cruzada; ignorar direção da força propulsiva."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Geometricamente a Configuração dos Thrusters",
                                  "subSteps": [
                                    "Defina posições cartesianas (x,y,z) e vetores de direção unitária para cada thruster.",
                                    "Construa a matriz de configuração de thrusters (TCM) relacionando comandos de thrust a torques.",
                                    "Implemente a TCM em código considerando ângulos de inclinação (theta, phi).",
                                    "Visualize o modelo 3D da configuração usando ferramentas de simulação.",
                                    "Teste variações iniciais de posições para observar impactos qualitativos."
                                  ],
                                  "verification": "Gere uma visualização 3D da configuração e confirme que a TCM reproduz torques esperados para thrusts unitários.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB; modelo CAD simples (ex: Blender gratuito).",
                                  "tips": "Padronize unidades (N para força, m para posição) para evitar erros numéricos.",
                                  "learningObjective": "Criar um modelo matemático preciso da geometria propulsiva para análise de torques.",
                                  "commonMistakes": "Erros de sinal nos vetores de momento; normalização incorreta de vetores direção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular e Quantificar Acoplamentos Torque",
                                  "subSteps": [
                                    "Implemente simulação de thrusts arbitrários e compute torques resultantes via TCM.",
                                    "Calcule métricas de acoplamento: razão torque cruzado / torque principal por eixo.",
                                    "Gere heatmaps ou gráficos de acoplamento para diferentes comandos de atitude.",
                                    "Identifique thrusters dominantes em acoplamentos específicos.",
                                    "Execute Monte Carlo com ruído para robustez estatística."
                                  ],
                                  "verification": "Produza relatório com métricas de acoplamento <10% para configuração baseline, com gráficos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python (SciPy para otimização), Jupyter Notebook para visualizações.",
                                  "tips": "Use SVD (Singular Value Decomposition) na TCM para quantificar desacoplamento inerente.",
                                  "learningObjective": "Avaliar quantitativamente níveis de acoplamento em simulações geométricas.",
                                  "commonMistakes": "Não linearizar thrusts pequenos; ignorar simetrias da configuração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar Posicionamentos e Ângulos para Minimizar Acoplamentos",
                                  "subSteps": [
                                    "Defina função objetivo: soma de acoplamentos normalizados sobre comandos de teste.",
                                    "Aplique otimização numérica (ex: gradient descent ou genetic algorithm) em posições/ângulos.",
                                    "Impõe restrições: distâncias mínimas, envelopes de montagem.",
                                    "Itere simulações comparando baseline vs otimizado.",
                                    "Valide com cenários reais de manobras de atitude."
                                  ],
                                  "verification": "Demonstre redução >50% em métricas de acoplamento, com configuração final viável.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Bibliotecas de otimização (SciPy.optimize, PyGMO), simulador orbital (ex: Orekit gratuito).",
                                  "tips": "Comece com otimização separada por eixo para convergência rápida.",
                                  "learningObjective": "Aplicar técnicas de otimização para alcançar configurações geométricas desacopladas.",
                                  "commonMistakes": "Sobre-otimização levando a instabilidades; violar restrições físicas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar a Otimização Final",
                                  "subSteps": [
                                    "Teste sensibilidade a tolerâncias de fabricação e desalinhamentos.",
                                    "Integre com controlador de atitude (ex: PD) e simule loop fechado.",
                                    "Compare com benchmarks literários ou dados de missões reais.",
                                    "Documente trade-offs (ex: custo vs performance).",
                                    "Prepare relatório com código fonte e resultados."
                                  ],
                                  "verification": "Simulação em loop fechado mostra erro de apontamento <1° com acoplamentos minimizados.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Simulador full (ex: GMAT ou Python com poliastro), dados de CubeSat.",
                                  "tips": "Use métricas como condição number da TCM para qualidade global.",
                                  "learningObjective": "Garantir robustez e aplicabilidade prática da otimização geométrica.",
                                  "commonMistakes": "Testar apenas casos nominais; negligenciar dinâmica não-linear."
                                }
                              ],
                              "practicalExample": "Em um CubeSat 3U, otimize 8 thrusters canted em 30° inicialmente: posicione-os simetricamente nos cantos, ajuste inclinações para yaw puro gerando <2% roll cross-coupling, simulando manobras de 5°/s com MATLAB.",
                              "finalVerifications": [
                                "Métricas de acoplamento <5% em todos eixos para 100 comandos aleatórios.",
                                "TCM otimizada com condição number <10.",
                                "Simulação em loop fechado com erro de attitude <0.5° rms.",
                                "Configuração respeita envelope físico (ex: raio <10cm).",
                                "Redução de acoplamento >60% vs baseline.",
                                "Robustez a ±1mm desalinhamento mantendo performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem TCM (erro <1% em torques conhecidos).",
                                "Eficácia da otimização (redução quantificável de acoplamentos).",
                                "Qualidade das visualizações e relatórios (clareza, completude).",
                                "Correção conceitual em conceitos de torque e geometria.",
                                "Uso apropriado de ferramentas de simulação e otimização.",
                                "Análise de trade-offs e sensibilidade demonstrada.",
                                "Código limpo, reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, SVD), otimização não-linear.",
                                "Física: Dinâmica de corpo rígido, vetores e momentos.",
                                "Programação: Simulação numérica, visualização 3D.",
                                "Engenharia Mecânica: Design de montagem e tolerâncias.",
                                "Controle de Sistemas: Análise de desacoplamento em controladores."
                              ],
                              "realWorldApplication": "Aplicado em satélites como o Swarm da ESA ou Starlink da SpaceX, onde thrusters otimizados minimizam consumo de propelente em manobras de formação, reduzindo erros de apontamento e estendendo vida útil em órbita."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Estratégias de Controle e Simulação",
                        "description": "Técnicas de acionamento preciso e modelagem dinâmica para estabilização e manobras de atitude usando propulsores.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Implementar modulação por largura de pulso (PWM)",
                            "description": "Aplicar PWM para controlar magnitude de torque médio, ajustando duty cycle em pulsos discretos para precisão em veículos espaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais da Modulação por Largura de Pulso (PWM)",
                                  "subSteps": [
                                    "Estudar a definição de PWM como técnica de modulação onde a largura do pulso varia para controlar a potência média.",
                                    "Aprender o conceito de duty cycle (D = ton / T * 100%) e sua relação direta com a magnitude do torque médio (Torque_médio = D * Torque_máx).",
                                    "Analisar o impacto da frequência de PWM na precisão e ripple em sistemas de controle de atitude espaciais.",
                                    "Visualizar formas de onda PWM usando simuladores e calcular exemplos numéricos para torques desejados.",
                                    "Exercitar cálculos: dado torque desejado de 0.5 Nm e Torque_máx de 1 Nm, calcular D = 50%."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como o duty cycle afeta o torque médio e resolver 3 problemas de cálculo com precisão >95%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação técnica de PWM (datasheets de microcontroladores como STM32 ou Arduino)",
                                    "Simulador online como Falstad Circuit Simulator",
                                    "Vídeos tutoriais sobre PWM em YouTube (canais como GreatScott!)"
                                  ],
                                  "tips": [
                                    "Escolha frequência >10x a taxa de amostragem do sistema de controle para minimizar ripple.",
                                    "Sempre normalize torque desejado entre 0-100% antes de mapear para duty cycle."
                                  ],
                                  "learningObjective": "Dominar os princípios matemáticos e físicos do PWM aplicados ao controle de torque em propulsores espaciais.",
                                  "commonMistakes": [
                                    "Confundir duty cycle com frequência de pulso.",
                                    "Ignorar o efeito de perdas térmicas no torque médio real.",
                                    "Usar duty cycle >100% ou <0% em cálculos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Ambiente de Hardware e Software para Geração de PWM",
                                  "subSteps": [
                                    "Selecionar e configurar um microcontrolador com timers PWM (ex: Arduino Uno ou STM32 com biblioteca HAL).",
                                    "Instalar software de desenvolvimento (Arduino IDE ou STM32CubeIDE) e conectar hardware simulado ou real.",
                                    "Configurar pinos PWM com resolução de 10-12 bits e frequência de 1-20 kHz adequada para thrusters espaciais.",
                                    "Gerar sinal PWM fixo de 50% duty cycle e medir com osciloscópio virtual ou multímetro.",
                                    "Testar variação de duty cycle de 0% a 100% em incrementos de 10%."
                                  ],
                                  "verification": "Capturar e exibir screenshots de sinais PWM com duty cycles variados, confirmando precisão ±1%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Microcontrolador Arduino/STM32",
                                    "Breadboard e jumpers",
                                    "Osciloscópio virtual (em Tinkercad ou LTSpice)",
                                    "Cabo USB para programação"
                                  ],
                                  "tips": [
                                    "Use resolução alta (12 bits) para precisão fina em duty cycle (passos de 0.024%).",
                                    "Evite interrupções no timer PWM para estabilidade."
                                  ],
                                  "learningObjective": "Configurar independentemente um sistema PWM funcional para controle discreto.",
                                  "commonMistakes": [
                                    "Configurar frequência muito baixa causando vibrações audíveis.",
                                    "Não sincronizar timers múltiplos em sistemas multi-thruster.",
                                    "Esquecer de habilitar o periférico PWM no clock do MCU."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Controle de Torque via Ajuste Dinâmico de Duty Cycle",
                                  "subSteps": [
                                    "Desenvolver algoritmo para mapear torque desejado (de controlador PID) para duty cycle: D = (torque_desejado / torque_max) * 100.",
                                    "Integrar leitura de sensores (encoder ou giroscópio) para feedback de atitude do veículo espacial.",
                                    "Implementar loop de controle em tempo real ajustando PWM baseado em erro de atitude.",
                                    "Adicionar filtros low-pass para suavizar transições de duty cycle e reduzir overshoot.",
                                    "Codificar limites de segurança: clamp duty cycle entre 5-95% para evitar saturação."
                                  ],
                                  "verification": "Executar código que ajusta PWM responsivo a input de torque, registrando logs de duty vs torque.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "IDE de programação (Arduino IDE ou VS Code com PlatformIO)",
                                    "Código base de PID para atitude (biblioteca Arduino PID)",
                                    "Simulador de veículo espacial (ex: JSBSim ou custom Python)"
                                  ],
                                  "tips": [
                                    "Implemente deadband em duty cycle baixo para evitar 'chattering'.",
                                    "Monitore temperatura do atuador em simulações longas."
                                  ],
                                  "learningObjective": "Criar um controlador PWM fechado para precisão em torque médio de veículos espaciais.",
                                  "commonMistakes": [
                                    "Não linearizar a relação torque-duty devido a não-linearidades do atuador.",
                                    "Loop de controle instável por ganho PID mal tunado.",
                                    "Ignorar latência de PWM na taxa de amostragem."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Validar e Otimizar a Implementação PWM em Contexto Espacial",
                                  "subSteps": [
                                    "Simular cenário de controle de atitude: corrigir rotação de 5°/s usando 4 thrusters PWM.",
                                    "Medir precisão: erro de torque <0.01 Nm e tempo de estabilização <2s.",
                                    "Analisar ripple e ruído no torque médio via FFT do sinal simulado.",
                                    "Otimizar frequência PWM e deadtime baseado em métricas de performance.",
                                    "Documentar resultados e gerar relatório com gráficos de duty cycle vs resposta de atitude."
                                  ],
                                  "verification": "Demonstrar simulação estável com métricas dentro de specs espaciais (erro <1%).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink ou Python com SciPy para dinâmica espacial)",
                                    "Ferramentas de análise (Osciloscópio lógico Saleae ou software equivalente)",
                                    "Dados de thrusters reais (ex: specs de cold gas thrusters)"
                                  ],
                                  "tips": [
                                    "Teste em vácuo simulado ignorando efeitos aerodinâmicos.",
                                    "Valide com modelo físico do CubeSat para fidelidade."
                                  ],
                                  "learningObjective": "Validar PWM para aplicações reais de controle de atitude em veículos espaciais.",
                                  "commonMistakes": [
                                    "Testar apenas duty cycle fixo, ignorando dinâmicas.",
                                    "Não considerar delays de fase entre múltiplos PWMs.",
                                    "Sobreestimar precisão sem medição de ripple."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um simulador de CubeSat, implemente PWM em 4 thrusters para controlar torque de rotação: ajuste duty cycle de 20% (0.2 Nm) a 80% (0.8 Nm) para corrigir desalinhamento de 10° em órbita, alcançando precisão de 0.01 Nm em <3 segundos.",
                              "finalVerifications": [
                                "Gerar PWM com duty cycle ajustável de 0-100% com resolução <0.1%.",
                                "Calcular e validar torque médio = duty * torque_max com erro <1%.",
                                "Estabilizar atitude simulada de veículo espacial com overshoot <5%.",
                                "Medir ripple de torque <2% do valor médio.",
                                "Implementar código funcional em microcontrolador real ou simulado.",
                                "Documentar análise de performance com gráficos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no ajuste de duty cycle (±0.5%).",
                                "Estabilidade do loop de controle (sem oscilações sustentadas).",
                                "Eficiência computacional (ciclo CPU <20% para PWM).",
                                "Conformidade com specs espaciais (frequência >10 kHz, ripple baixo).",
                                "Robustez a variações de input (torque de 0.1-1 Nm).",
                                "Qualidade da documentação e análise de resultados."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Timers e periféricos de microcontroladores.",
                                "Programação Embarcada: Algoritmos em tempo real e RTOS basics.",
                                "Física de Controle: Sistemas dinâmicos e PID para atitude.",
                                "Engenharia Mecânica: Modelagem de atuadores propulsores.",
                                "Matemática: Análise de Fourier para ripple e sinal processing."
                              ],
                              "realWorldApplication": "Em satélites CubeSat como os da missão MarCO da NASA, PWM controla thrusters de gás frio para ajustes precisos de atitude, economizando propelente e mantendo orientação orbital com erro <0.1° usando duty cycles variáveis em microcontroladores embarcados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Modelar dinâmica de atitude com propulsores",
                            "description": "Derivar equações de Euler modificadas incorporando torques propulsivos discretos para simulação numérica de manobras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações de Euler padrão para dinâmica de atitude",
                                  "subSteps": [
                                    "Estude as equações de Euler para corpo rígido: derivadas angulares em quaternions ou ângulos de Euler.",
                                    "Identifique os termos de inércia (matriz I) e torques externos contínuos.",
                                    "Escreva as equações no frame do corpo: ω̇ = I⁻¹ (τ - ω × (I ω)).",
                                    "Revise representação de atitude com quaternions para evitar singularidades.",
                                    "Compile referências como Sidi 'Spacecraft Dynamics and Control'."
                                  ],
                                  "verification": "Escreva e derive corretamente as equações padrão sem torques propulsivos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro Sidi, notas de aula, MATLAB/Simulink ou Python (NumPy/SciPy).",
                                  "tips": "Use quaternions desde o início para simulações estáveis.",
                                  "learningObjective": "Compreender a base matemática da dinâmica de atitude sem propulsores.",
                                  "commonMistakes": "Confundir frame inercial com frame do corpo; ignorar simetria da matriz de inércia."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar torques propulsivos discretos",
                                  "subSteps": [
                                    "Defina parâmetros de propulsores: posição (r_i), direção (u_i), impulso específico (Δv ou thrust-time).",
                                    "Calcule torque impulsivo: τ_i Δt = r_i × (m_i u_i), onde m_i é massa expelida.",
                                    "Agrupe propulsores em conjuntos para manobras (roll, pitch, yaw).",
                                    "Incorpore modelo discreto: torque como delta functions em instantes t_k.",
                                    "Estime deadband e eficiência de propulsores reais (e.g., 0.1-1% perda)."
                                  ],
                                  "verification": "Crie uma tabela de torques para 6-12 propulsores em configuração típica de satélite.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Diagramas de satélites (e.g., CubeSat), calculadora simbólica (SymPy).",
                                  "tips": "Vectorize cálculos para múltiplos propulsores usando matrizes.",
                                  "learningObjective": "Modelar propulsores como fontes discretas de torque angular.",
                                  "commonMistakes": "Negligir momento linear induzido; assumir thrust infinito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar equações de Euler modificadas com torques impulsivos",
                                  "subSteps": [
                                    "Adicione termo propulsivo: τ_total = τ_contínuo + Σ δ(t - t_k) τ_p_k.",
                                    "Integre sobre intervalo pequeno: Δω = I⁻¹ τ_p_k para cada disparo.",
                                    "Mantenha propagação contínua entre disparos usando Runge-Kutta.",
                                    "Implemente em quaternions: q̇ = (1/2) q ⊗ ω, com ω atualizado discretamente.",
                                    "Valide linearidade para pequenos ângulos."
                                  ],
                                  "verification": "Derive analiticamente as equações híbridas contínuo-discretas.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Papel e lápis para derivação, LaTeX para documentar equações.",
                                  "tips": "Use Heaviside step function para formalizar impulsos.",
                                  "learningObjective": "Integrar torques discretos nas EDOs de atitude.",
                                  "commonMistakes": "Esquecer propagação de atitude entre impulsos; erros em produto quaternion-vetor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar simulação numérica de manobra",
                                  "subSteps": [
                                    "Escolha integrador: ode45 (MATLAB) ou solve_ivp (Python) para partes contínuas.",
                                    "Defina condições iniciais: atitude alvo, ω=0, sequência de disparos.",
                                    "Implemente loop de simulação com eventos discretos para disparos.",
                                    "Adicione ruído e deadband para realismo.",
                                    "Plote trajetórias de atitude e ω vs tempo."
                                  ],
                                  "verification": "Execute simulação que converge para atitude alvo em <10s.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB/Python, bibliotecas poliastros ou Orekit para validação.",
                                  "tips": "Use eventos em solvers para disparos exatos sem overshoot.",
                                  "learningObjective": "Simular dinâmicas híbridas numericamente.",
                                  "commonMistakes": "Passo de tempo muito grande causando instabilidade; escala errada de impulsos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e analisar a simulação",
                                  "subSteps": [
                                    "Compare com solução analítica para manobra simples (e.g., rotação 90°).",
                                    "Calcule erro de apontamento final e consumo de propelente.",
                                    "Sensitividade: varie I, posição de propulsores.",
                                    "Otimize sequência de disparos para minimizar overshoot.",
                                    "Documente código e resultados em relatório."
                                  ],
                                  "verification": "Erro de atitude <0.1° e conservação de momento angular (exceto impulsos).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Gráficos de simulação, ferramentas de profiling.",
                                  "tips": "Verifique conservação numérica com sympy para casos ideais.",
                                  "learningObjective": "Avaliar precisão e robustez do modelo.",
                                  "commonMistakes": "Ignorar gimbal lock em ângulos de Euler; não normalizar quaternions."
                                }
                              ],
                              "practicalExample": "Simule uma manobra de apontamento de um CubeSat: gire 180° em yaw usando 4 propulsores de 1 mN.s cada, posicionados em ±0.1m nos eixos, partindo de atitude quiescente, alcançando precisão de 0.5° em 20s.",
                              "finalVerifications": [
                                "Equações derivadas coincidem com referências padrão (e.g., Kaplan).",
                                "Simulação numérica converge sem divergência numérica.",
                                "Torque impulsivo altera ω corretamente em Δω = I⁻¹ τ Δt.",
                                "Atitude final atinge alvo com erro <1°.",
                                "Consumo de propelente calculado matches sequência de disparos.",
                                "Quaternions permanecem unitários (|q| = 1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação matemática (100% match com equações híbridas).",
                                "Corretude da implementação numérica (teste unitário em impulsos isolados).",
                                "Eficiência da simulação (tempo de execução <1min para 100s).",
                                "Análise de erros e sensitividade documentada.",
                                "Clareza do código e plots interpretáveis.",
                                "Integração realista de deadband e eficiência propulsiva."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução numérica de EDOs híbridas (Runge-Kutta).",
                                "Física: Conservação de momento angular em sistemas isolados.",
                                "Programação: Event-driven simulation em Python/MATLAB.",
                                "Engenharia de Controle: Dead reckoning e bang-bang control.",
                                "Mecânica Orbital: Integração com 6-DOF dynamics."
                              ],
                              "realWorldApplication": "Modelagem de sistemas de controle de atitude em satélites como Starlink ou missões da NASA (e.g., James Webb Telescope slews), otimizando uso de propelentes hidrazínicos para manobras precisas de longa duração."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Simular estabilização e manobras de atitude",
                            "description": "Usar ferramentas de simulação para testar controle proporcional-derivativo (PD) com propulsores em cenários de perturbações como pressão solar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de simulação",
                                  "subSteps": [
                                    "Instalar bibliotecas Python necessárias: numpy, scipy, matplotlib e poliastro para dinâmica orbital.",
                                    "Definir parâmetros do veículo espacial: momento de inércia (3x3 matriz), posição thrusters e propriedades (impulso específico, massa).",
                                    "Criar modelo cinemático e dinâmico básico de atitude (quaternions ou ângulos de Euler).",
                                    "Configurar condições iniciais: órbita LEO, atitude inicial desalinhada (ex: 30° erro).",
                                    "Testar script básico para plotar evolução livre da atitude."
                                  ],
                                  "verification": "Script roda sem erros e plota trajetória de atitude sem controle.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python 3.8+, bibliotecas: numpy, scipy, matplotlib, poliastro",
                                    "Editor de código (VS Code ou Jupyter Notebook)"
                                  ],
                                  "tips": "Use Jupyter Notebook para visualização interativa; comece com modelo 3DOF simplificado.",
                                  "learningObjective": "Entender e implementar o modelo básico de dinâmica de atitude de um SC.",
                                  "commonMistakes": [
                                    "Esquecer unidades consistentes (rad vs deg)",
                                    "Matriz de inércia não simétrica",
                                    "Quaternions não normalizados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o controlador PD para thrusters",
                                  "subSteps": [
                                    "Derivar equações do controlador PD: torque = -Kp * erro_atitude - Kd * taxa_angular.",
                                    "Mapear comandos de torque para ativação de thrusters (alocação considerando posição e direção).",
                                    "Implementar loop de controle em tempo discreto (dt = 1s).",
                                    "Adicionar saturação de thrusters (limite de força máxima).",
                                    "Testar resposta em malha fechada sem perturbações."
                                  ],
                                  "verification": "Simulação mostra estabilização rápida (erro <5° em 100s) para distúrbio inicial.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código Python do Step 1",
                                    "Documentação scipy.signal para PID-like"
                                  ],
                                  "tips": "Tune Kp e Kd inicialmente com Ziegler-Nichols; use quaternions para evitar gimbal lock.",
                                  "learningObjective": "Desenvolver e integrar um controlador PD com atuadores físicos (thrusters).",
                                  "commonMistakes": [
                                    "Ganho Kd muito alto causando oscilações",
                                    "Erro na alocação de thrusters (torque nulo)",
                                    "Não converter erro para vetor de controle"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir perturbações realistas como pressão solar",
                                  "subSteps": [
                                    "Modelar força de pressão solar: F = (P * A * cos(alpha)) / c, onde P=4.56e-6 N/m².",
                                    "Calcular torque perturbador: tau = r_cm × F, com r_cm vetor do centro de massa à área projetada.",
                                    "Implementar variação temporal: direção solar relativa à órbita (usar poliastro para efemérides).",
                                    "Adicionar ruído aleatório em sensores (gyros, star trackers).",
                                    "Executar simulação com perturbação ativa."
                                  ],
                                  "verification": "Torque de perturbação plotado e atinge valores realistas (~1e-5 Nm para CubeSat).",
                                  "estimatedTime": "1.5-2.5 horas",
                                  "materials": [
                                    "Código dos Steps anteriores",
                                    "Referências: Vallado 'Fundamentals of Astrodynamics'"
                                  ],
                                  "tips": "Simplifique área projetada como disco; valide com casos analíticos conhecidos.",
                                  "learningObjective": "Incorporar distúrbios ambientais no modelo de simulação.",
                                  "commonMistakes": [
                                    "Direção solar fixa (ignorar rotação orbital)",
                                    "Área A incorreta para configuração não-esférica",
                                    "Falta de normalização cos(alpha)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular estabilização e manobras, analisar e otimizar",
                                  "subSteps": [
                                    "Executar simulação de estabilização: de atitude randômica para nadir-pointing.",
                                    "Implementar manobra: slewing de 90° com perfil trapezoidal em velocidade angular.",
                                    "Coletar métricas: tempo de estabilização, overshoot, consumo de propelente.",
                                    "Analisar plots: attitude error, torque commands, evolução quaternions.",
                                    "Otimizar Kp/Kd minimizando ISE (Integral Square Error)."
                                  ],
                                  "verification": "Estabilização em <200s com erro <1°; manobra sem perda de estabilidade.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Código completo",
                                    "Ferramentas de otimização: scipy.optimize"
                                  ],
                                  "tips": "Grave vídeos da simulação 3D com matplotlib; compare com benchmarks de literatura.",
                                  "learningObjective": "Avaliar performance do sistema e iterar no design de controle.",
                                  "commonMistakes": [
                                    "Perfil de manobra muito agressivo (excitação de modos flexíveis)",
                                    "Ignorar consumo de propelente em tuning",
                                    "Análise qualitativa sem métricas quantitativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat 1U em órbita LEO a 500km, sofrendo torque de pressão solar de 1e-6 Nm. Implemente PD com thrusters de 1mN para estabilizar nadir-pointing (erro inicial 45°) em menos de 300s, consumindo <10% do propelente Delta-V.",
                              "finalVerifications": [
                                "Simulação completa executa sem crashes numéricos.",
                                "Erro de atitude estabiliza abaixo de 1° RMS após 200s.",
                                "Manobra de 90° slew completa em <150s sem overshoot >10%.",
                                "Torque de thrusters saturam corretamente sob perturbação.",
                                "Consumo de propelente <5% do total disponível.",
                                "Plots mostram rejeição efetiva de pressão solar."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo dinâmico (erro <5% vs analítico).",
                                "Efetividade do PD (tempo settling <300s, overshoot <15%).",
                                "Realismo das perturbações (magnitude e direção corretas).",
                                "Qualidade da análise (métricas + plots interpretados).",
                                "Otimização iterativa (melhoria >20% em ISE).",
                                "Documentação clara do código e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (quaternions, matrizes de rotação), EDOs não-lineares.",
                                "Física: Dinâmica newtoniana, mecânica orbital, radiação eletromagnética.",
                                "Programação: Simulação numérica (Runge-Kutta), visualização de dados.",
                                "Engenharia de Controle: Teoria de feedback, estabilidade Lyapunov.",
                                "Ciência de Dados: Análise de séries temporais, otimização."
                              ],
                              "realWorldApplication": "Controle de atitude em CubeSats como os da missão MarCO (NASA), onde PD com thrusters compensa perturbações solares para manter comunicação com Terra durante flyby de Marte; essencial para missões de observação Earth ou constelações como Starlink."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Torque de Pressão Solar",
                    "description": "Uso da pressão da radiação solar para produzir torque e controlar a orientação do veículo espacial.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Princípio da Pressão de Radiação Solar",
                        "description": "Explicação do fenômeno físico da pressão exercida pela radiação solar sobre superfícies expostas em veículos espaciais, incluindo o momentum transferido pelos fótons.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Derivar a fórmula da pressão solar",
                            "description": "Derivar matematicamente a pressão de radiação solar a partir da densidade de fluxo energético solar (aproximadamente 1366 W/m² na Terra) e da relação com o momento dos fótons, considerando superfícies perfeitamente absorventes e refletoras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Energia e Momento de Fótons",
                                  "subSteps": [
                                    "Lembre-se de que a energia de um fóton é E = hν, onde h é a constante de Planck e ν é a frequência.",
                                    "O momento linear de um fóton é p = E/c, onde c é a velocidade da luz, derivado da relação relativística E = pc para partículas sem massa.",
                                    "A densidade de fluxo energético solar (irradiância) S é aproximadamente 1366 W/m² na distância da Terra do Sol (constante solar).",
                                    "Entenda que o fluxo de momento é relacionado ao fluxo de energia dividido por c.",
                                    "Discuta a taxa de colisão de fótons com uma superfície unitária."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a relação p = E/c e calcule p para um fóton de energia típica do espectro solar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Calculadora",
                                    "Referência: constante solar S = 1366 W/m²"
                                  ],
                                  "tips": "Visualize fótons como pacotes de energia viajando a c, transferindo momento ao serem absorvidos.",
                                  "learningObjective": "Compreender a dualidade onda-partícula da luz e calcular momento de fótons individuais.",
                                  "commonMistakes": [
                                    "Confundir momento angular com linear",
                                    "Esquecer que fótons têm massa relativística zero",
                                    "Usar velocidade da luz incorreta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Pressão para Superfície Perfeitamente Absorvente",
                                  "subSteps": [
                                    "O poder incidente em uma área A é P = S * A (em joules/segundo).",
                                    "Taxa de energia absorvida é dE/dt = S * A.",
                                    "Taxa de momento absorvido é (dE/dt)/c = S * A / c.",
                                    "Força F = taxa de mudança de momento = S * A / c.",
                                    "Pressão P_abs = F/A = S / c."
                                  ],
                                  "verification": "Derive e escreva a fórmula P_abs = S / c, confirmando unidades: (W/m²)/(m/s) = N/m².",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para derivação",
                                    "Tabela de unidades SI"
                                  ],
                                  "tips": "Pense na pressão como força por área; cada fóton absorvido transfere p = E/c normal à superfície.",
                                  "learningObjective": "Derivar matematicamente a pressão de radiação para absorção total.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/c",
                                    "Confundir fluxo de energia com fluxo de momento",
                                    "Ignorar direção do momento (normal à superfície)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Pressão para Superfície Perfeitamente Refletora",
                                  "subSteps": [
                                    "Para reflexão especular perfeita, o fóton rebate, invertendo o componente normal do momento.",
                                    "Mudança de momento por fóton: Δp = 2 (E/c) (dobro da absorção).",
                                    "Taxa de momento transferido: 2 * (S * A / c).",
                                    "Força F = 2 * S * A / c.",
                                    "Pressão P_ref = F/A = 2 S / c."
                                  ],
                                  "verification": "Escreva P_ref = 2 S / c e compare com P_abs, justificando o fator 2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de reflexão de fóton (desenhe)",
                                    "Calculadora"
                                  ],
                                  "tips": "Desenhe setas de momento incidente e refletido para visualizar Δp = 2p_normal.",
                                  "learningObjective": "Entender o efeito de reflexão na transferência de momento dobrando a pressão.",
                                  "commonMistakes": [
                                    "Assumir Δp = p em vez de 2p para reflexão",
                                    "Não considerar ângulo de incidência normal",
                                    "Confundir reflexão difusa com especular"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Valores Numéricos e Generalizar",
                                  "subSteps": [
                                    "Calcule P_abs = 1366 / (3e8) ≈ 4.55 μN/m².",
                                    "Calcule P_ref = 2 * 4.55 ≈ 9.1 μN/m².",
                                    "Discuta generalização para ângulo θ: P = (S cosθ)/c para absorvente, 2(S cosθ)/c para refletor.",
                                    "Verifique consistência dimensional e compare com valores conhecidos.",
                                    "Aplique a um exemplo: torque em painel solar de satélite."
                                  ],
                                  "verification": "Forneça cálculos numéricos corretos e fórmula generalizada para incidência oblíqua.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Valor c = 2.998e8 m/s",
                                    "Referência de constante solar"
                                  ],
                                  "tips": "Use notação científica para evitar erros em números pequenos; arredonde apropriadamente.",
                                  "learningObjective": "Aplicar derivação a valores reais e estender para casos gerais.",
                                  "commonMistakes": [
                                    "Erro em unidades (W = J/s)",
                                    "Esquecer cosθ para ângulos não normais",
                                    "Cálculo numérico incorreto de S/c"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule a pressão solar em um painel solar de um satélite CubeSat com área 0.01 m² perfeitamente absorvente na órbita terrestre: F = P_abs * A ≈ 4.55e-6 * 0.01 = 4.55e-8 N. Discuta impacto no controle de atitude.",
                              "finalVerifications": [
                                "Deriva corretamente P_abs = S/c e P_ref = 2S/c.",
                                "Calcula valores numéricos precisos para S = 1366 W/m².",
                                "Explica mudança de momento para absorção e reflexão.",
                                "Generaliza para incidência em ângulo θ.",
                                "Verifica unidades e consistência física.",
                                "Identifica aplicações em veículos espaciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (fórmulas corretas).",
                                "Correção conceitual (momento de fótons, transferência).",
                                "Cálculos numéricos exatos (ordem de magnitude certa).",
                                "Explicação clara de diferenças absorvente vs. refletor.",
                                "Inclusão de generalizações (ângulo, torque).",
                                "Uso correto de unidades SI."
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: Dualidade onda-partícula da luz.",
                                "Relatividade Especial: Momento de partículas sem massa.",
                                "Engenharia Aeroespacial: Controle de atitude e velas solares.",
                                "Óptica: Reflexão e absorção de radiação.",
                                "Matemática: Cálculo de taxas e derivadas."
                              ],
                              "realWorldApplication": "Usado no design de satélites para prever torques perturbadores de pressão solar, essencial para sistemas de controle de atitude; aplicações em missões como velas solares (ex: LightSail da Planetary Society) para propulsão sem combustível."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Calcular a força resultante",
                            "description": "Calcular a força de pressão solar atuante sobre uma placa ou vela solar de área conhecida, diferenciando casos de absorção total, reflexão especular e difusa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio da Pressão de Radiação Solar",
                                  "subSteps": [
                                    "Estude a natureza da radiação solar como onda eletromagnética e seu momento linear.",
                                    "Derive a pressão de radiação para onda plana incidente perpendicularmente: P = I/c para absorção total.",
                                    "Explique o conceito de momento de fótons e transferência de momento para a superfície.",
                                    "Discuta ângulos de incidência e fator cosθ.",
                                    "Revise unidades: intensidade solar I ≈ 1366 W/m² na Terra."
                                  ],
                                  "verification": "Resuma em um parágrafo o mecanismo físico da pressão solar e derive P = I/c.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Física (Halliday ou similar)",
                                    "Vídeo sobre pressão de radiação (Khan Academy)",
                                    "Calculadora"
                                  ],
                                  "tips": "Visualize fótons colidindo como bolas de pingue-pongue para intuitar o momento.",
                                  "learningObjective": "Explicar o princípio físico da pressão de radiação solar e sua dependência na intensidade e velocidade da luz.",
                                  "commonMistakes": [
                                    "Confundir pressão com intensidade diretamente",
                                    "Ignorar o fator c (velocidade da luz)",
                                    "Esquecer que é radiação eletromagnética, não partículas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Fórmulas para Diferentes Casos de Interação",
                                  "subSteps": [
                                    "Memorize fórmula para absorção total: F = (I A cosθ)/c.",
                                    "Derive para reflexão especular (espelho perfeito): F = 2 (I A cosθ)/c (momento dobrado).",
                                    "Estude reflexão difusa (Lambertiana): F = (1 + r) (I A cosθ)/c, onde r é albedo/refletividade.",
                                    "Compare os casos em uma tabela: absorção (1), especular (2), difusa (1+r).",
                                    "Considere orientação: θ = 0° para perpendicular."
                                  ],
                                  "verification": "Escreva as três fórmulas principais e explique o fator multiplicador para cada caso.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de fórmulas de pressão solar",
                                    "Simulador online de radiação (PhET ou similar)",
                                    "Caderno para derivações"
                                  ],
                                  "tips": "Use diagrama de setas para momento incidente e refletido para visualizar o dobro na especular.",
                                  "learningObjective": "Dominar as fórmulas exatas para força resultante em absorção total, reflexão especular e difusa.",
                                  "commonMistakes": [
                                    "Usar fator 2 para difusa em vez de especular",
                                    "Esquecer cosθ para ângulo não perpendicular",
                                    "Confundir refletividade r com absorção"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Força Resultante para um Caso Prático",
                                  "subSteps": [
                                    "Defina parâmetros: A = 1 m², θ = 0°, I = 1366 W/m², c = 3e8 m/s.",
                                    "Calcule para absorção total: F_abs = I A / c.",
                                    "Calcule para especular: F_esp = 2 I A / c.",
                                    "Para difusa com r=0.8: F_dif = 1.8 I A / c.",
                                    "Registre valores numéricos em N (esperado ~9 μN para absorção)."
                                  ],
                                  "verification": "Realize os cálculos e confira se F_esp = 2 F_abs e F_dif entre eles.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel/Google Sheets para cálculos",
                                    "Constantes físicas (I, c)"
                                  ],
                                  "tips": "Trabalhe em unidades SI consistentes para evitar erros de escala (microNewtons).",
                                  "learningObjective": "Aplicar fórmulas para calcular forças numéricas precisas nos três casos.",
                                  "commonMistakes": [
                                    "Erro em potências de 10 com c=3×10^8",
                                    "Esquecer divisão por c",
                                    "Usar I em Terra sem ajustar para órbita"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Comparar Casos com Variações",
                                  "subSteps": [
                                    "Varie θ de 0° a 90° e plote F vs θ para cada caso.",
                                    "Discuta impacto no torque: τ = r × F, mas foque em F por agora.",
                                    "Compare forças: especular > difusa > absorção.",
                                    "Avalie eficiência para velas solares (prefira especular).",
                                    "Teste com A diferente, ex: 10 m²."
                                  ],
                                  "verification": "Crie gráfico comparativo e explique qual caso maximiza F.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de plotagem (Excel, Python Matplotlib)",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "cosθ cai quadraticamente no torque, mas linear em F; foque em F primeiro.",
                                  "learningObjective": "Analisar sensibilidade de F a parâmetros e otimizar configurações.",
                                  "commonMistakes": [
                                    "Plotar sinθ em vez de cosθ",
                                    "Ignorar que para θ=90° F=0",
                                    "Confundir força com pressão"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma vela solar de A=5 m² perpendicular ao Sol (θ=0°, I=1366 W/m²), calcule F: Absorção total F=9.1 μN; Especular F=18.2 μN; Difusa (r=0.9) F=17.4 μN. Use para estimar aceleração em satélite de 1 kg.",
                              "finalVerifications": [
                                "Deriva corretamente P = I/c e suas variantes.",
                                "Calcula F com precisão numérica para os três casos.",
                                "Explica diferenças físicas entre absorção, especular e difusa.",
                                "Aplica cosθ corretamente para ângulos obliquos.",
                                "Identifica caso ótimo para maximizar força em velas solares.",
                                "Compara valores com literatura (ex: 4.5-9 μN/m²)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas (100% correto).",
                                "Correção numérica (erro <1%).",
                                "Explicação física clara e concisa.",
                                "Uso apropriado de unidades e constantes.",
                                "Análise comparativa e gráficos qualitativos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores, trigonometria (cosθ), cálculo numérico.",
                                "Física: Eletromagnetismo, mecânica (força, torque).",
                                "Engenharia Aeroespacial: Design de velas solares, controle de atitude.",
                                "Computação: Simulações numéricas em Python/MATLAB.",
                                "Química: Propriedades de superfícies refletoras (albedo)."
                              ],
                              "realWorldApplication": "Projeto de velas solares como na missão IKAROS (JAXA, 2010), onde reflexão especular maximiza aceleração sem propelente para satélites e sondas interplanetárias, controlando atitude via torque de pressão solar."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Avaliar variação com distância solar",
                            "description": "Determinar como a pressão solar varia com a distância ao Sol usando a lei do inverso do quadrado, aplicando a unidades astronômicas (UA).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Lei do Inverso do Quadrado",
                                  "subSteps": [
                                    "Explicar a propagação esférica da radiação solar a partir do Sol.",
                                    "Derivar a fórmula da intensidade I = S / (4πr²), onde S é a constante solar e r a distância.",
                                    "Identificar que a intensidade I varia como 1/r².",
                                    "Comparar com exemplos como som ou luz de uma lâmpada.",
                                    "Resolver um problema simples: se r dobra, como I muda?"
                                  ],
                                  "verification": "Explicar a lei em uma frase e calcular a variação para r=2 UA.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Vídeo sobre lei inverso do quadrado (ex: Khan Academy)"
                                  ],
                                  "tips": "Visualize a superfície esférica expandindo com r² para entender a diluição da energia.",
                                  "learningObjective": "Entender matematicamente por que a radiação diminui com o quadrado da distância.",
                                  "commonMistakes": [
                                    "Confundir com variação linear 1/r",
                                    "Esquecer o fator 4π na fórmula esférica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar Intensidade à Pressão de Radiação Solar",
                                  "subSteps": [
                                    "Definir pressão de radiação P para superfícies perfeitamente absorventes: P = I / c, onde c é velocidade da luz.",
                                    "Para reflexão perfeita, P = 2I / c; usar caso absorvente para torque.",
                                    "Estabelecer P ∝ I ∝ 1/r², logo P(r) = P(1) × (1 UA / r)².",
                                    "Consultar valor típico de P na Terra: ~4.5 × 10^{-6} N/m² a 1 UA.",
                                    "Calcular P para r=1 UA e verificar consistência."
                                  ],
                                  "verification": "Derivar e escrever a fórmula P(r) em termos de r em UA.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela de constantes físicas (constante solar S ≈ 1366 W/m²)"
                                  ],
                                  "tips": "Lembre-se: pressão é força por área, derivada do momento linear dos fótons.",
                                  "learningObjective": "Conectar irradiância solar diretamente à pressão de radiação.",
                                  "commonMistakes": [
                                    "Usar P ∝ 1/r em vez de 1/r²",
                                    "Confundir I com potência total"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Variação em Diferentes Distâncias Astronômicas",
                                  "subSteps": [
                                    "Listar distâncias planetárias em UA: Terra=1, Marte=1.52, Júpiter=5.2, Saturno=9.5.",
                                    "Calcular P relativa para cada: P_Marte = P_Terra × (1/1.52)².",
                                    "Criar tabela comparativa de P em diferentes r.",
                                    "Analisar impacto: como o torque de pressão afeta controle de atitude em probes espaciais.",
                                    "Gráfica log-log de log(P) vs log(r) para confirmar inclinação -2."
                                  ],
                                  "verification": "Preencher tabela com cálculos corretos para 3 planetas e plotar gráfico simples.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Lista de distâncias planetárias",
                                    "Papel milimetrado para gráfico"
                                  ],
                                  "tips": "Use r em UA para simplificar: fator (1/r)² direto sem constantes grandes.",
                                  "learningObjective": "Aplicar a lei para prever pressão em missões espaciais reais.",
                                  "commonMistakes": [
                                    "Usar km em vez de UA",
                                    "Erro em cálculo de (1/r)² (ex: inverter)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Analisar Resultados",
                                  "subSteps": [
                                    "Comparar cálculos com valores tabelados de literatura astronômica.",
                                    "Discutir erros percentuais se r variar ±10%.",
                                    "Simular impacto em satélite: torque ∝ P × área.",
                                    "Resolver problema inverso: dada P medida, estimar r.",
                                    "Documentar conclusões em relatório curto."
                                  ],
                                  "verification": "Resolver problema inverso corretamente e discutir um erro comum.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de pressões solares reais",
                                    "Software de simulação básica (opcional, como Python)"
                                  ],
                                  "tips": "Sempre normalize a 1 UA para evitar erros de unidades.",
                                  "learningObjective": "Validar a lei com dados reais e analisar sensibilidade.",
                                  "commonMistakes": [
                                    "Ignorar variação angular do Sol em órbitas elípticas",
                                    "Não considerar orientação da superfície"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule a pressão solar em uma sonda a 5 UA (como em órbita de Júpiter): P = 4.5 μN/m² × (1/5)² = 0.18 μN/m². Isso reduz o torque de pressão em 25x comparado à Terra, afetando o controle de atitude.",
                              "finalVerifications": [
                                "Calcular P para r=1.5 UA com erro <1%.",
                                "Explicar verbalmente por que P ∝ 1/r².",
                                "Criar tabela para 4 distâncias com valores corretos.",
                                "Identificar que dobrar r reduz P em 4x.",
                                "Resolver problema inverso: r = 1 / sqrt(P/P1).",
                                "Discutir aplicação em velas solares."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro <5%).",
                                "Compreensão conceitual da propagação esférica.",
                                "Uso correto de UA como unidade normalizada.",
                                "Análise qualitativa do impacto em aeroespacial.",
                                "Clareza na tabela/gráfico de resultados.",
                                "Identificação de pelo menos 2 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Leis de potências e funções inversas.",
                                "Física: Eletromagnetismo e momento de fótons.",
                                "Astronomia: Órbitas planetárias e constante solar.",
                                "Engenharia: Dinâmica de veículos espaciais e controle de atitude."
                              ],
                              "realWorldApplication": "Em missões como Voyager ou James Webb, engenheiros usam essa variação para modelar torques perturbadores em painéis solares, ajustando atuadores de controle de atitude e otimizando consumo de combustível em órbitas distantes."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Geração de Torque por Pressão Solar",
                        "description": "Modelagem do torque resultante da pressão solar assimétrica sobre o veículo espacial, considerando distribuição de superfícies e braços de momento.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Modelar torque em um dipolo solar",
                            "description": "Calcular o torque gerado por pressão solar em configurações assimétricas, como painéis solares desalinhados, usando o vetor força cruzado com o vetor posição do centro de massa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Pressão de Radiação Solar",
                                  "subSteps": [
                                    "Explicar o conceito de pressão de radiação solar como momentum transferido por fótons.",
                                    "Derivar a pressão P para superfícies absorventes (P = I/c) e perfeitamente refletivas (P = 2I/c), onde I é irradiância solar.",
                                    "Calcular a força resultante F em uma superfície plana: F = P * A * cos(θ) * n̂, com θ ângulo de incidência.",
                                    "Discutir fatores como albedo e arrasto térmico, mas focar em pressão primária.",
                                    "Verificar unidades: pressão em N/m², força em N."
                                  ],
                                  "verification": "Calcule corretamente a força em uma placa de 1m² perpendicular ao sol (I=1366 W/m², absorvente): F ≈ 4.53 μN.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de dinâmica de spacecraft (e.g., Curtis 'Orbital Mechanics')",
                                    "Calculadora científica",
                                    "Folha de fórmulas de vetores"
                                  ],
                                  "tips": "Use irradiância solar padrão de 1366 W/m² no espaço; cos(θ) é crucial para direção.",
                                  "learningObjective": "Dominar cálculo de força devido à pressão solar em superfícies planas.",
                                  "commonMistakes": [
                                    "Esquecer fator 2 para reflexão especular",
                                    "Confundir θ com ângulo azimutal",
                                    "Ignorar direção normal da superfície"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Modelo de Dipolo Solar",
                                  "subSteps": [
                                    "Definir dipolo solar como duas superfícies (A1 e A2) separadas por vetor r_cm do centro de massa, com normais n1 e n2.",
                                    "Especificar configuração assimétrica: e.g., painéis solares desalinhados com ângulos θ1 ≠ θ2.",
                                    "Posicionar vetores: r1 e r2 relativos ao CM, com |r1| ≠ |r2| ou direções diferentes.",
                                    "Assumir propriedades idênticas (absorvente/refletiva) para simplicidade inicial.",
                                    "Desenhar diagrama esquemático em 2D/3D mostrando sol, CM, painéis."
                                  ],
                                  "verification": "Desenhe e rotule um diagrama de dipolo com desalinhamento de 10° gerando torque não-zero.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de desenho vetorial (e.g., GeoGebra ou papel)",
                                    "Referências sobre CubeSats com painéis solares"
                                  ],
                                  "tips": "Dipolo gera torque quando ∑(r × F) ≠ 0 devido a assimetria.",
                                  "learningObjective": "Modelar geometricamente uma configuração de dipolo solar assimétrico.",
                                  "commonMistakes": [
                                    "Assumir simetria perfeita cancelando torque",
                                    "Colocar CM incorretamente",
                                    "Ignorar orientação relativa ao vetor sol"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Forças Individuais nos Componentes do Dipolo",
                                  "subSteps": [
                                    "Calcule F1 = P * A1 * cos(θ1) * n̂1 para o primeiro painel.",
                                    "Calcule F2 = P * A2 * cos(θ2) * n̂2 para o segundo painel.",
                                    "Determine vetores posição r1 e r2 do CM para cada força.",
                                    "Verifique se forças líquidas ∑F ≈ 0 em dipolo balanceado, mas torque ≠ 0.",
                                    "Use coordenadas: defina sistema com z para sol, x-y para rotação."
                                  ],
                                  "verification": "Para A1=A2=0.5m², θ1=0°, θ2=30°, calcule F1 e F2 com magnitudes corretas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/MATLAB para vetores",
                                    "Planilha Excel para cálculos numéricos"
                                  ],
                                  "tips": "Vetorize tudo: F = |F| * unit vector na direção da projeção.",
                                  "learningObjective": "Computar forças vetoriais precisas para cada superfície do dipolo.",
                                  "commonMistakes": [
                                    "Erro no sinal de cos(θ) para sombras",
                                    "Não normalizar vetores de direção",
                                    "Confundir incidência com azimute"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Torque Total via Produto Vetorial",
                                  "subSteps": [
                                    "Calcule τ1 = r1 × F1 usando determinante ou função cross-product.",
                                    "Calcule τ2 = r2 × F2 similarmente.",
                                    "Some torques: τ_total = τ1 + τ2.",
                                    "Analise direção (perpendicular ao plano r-F) e magnitude |τ| = r F sinφ.",
                                    "Simule variação com ângulo de atitude para validar modelo."
                                  ],
                                  "verification": "Torque resultante aponta na direção esperada para desalinhamento, com magnitude ~ nN·m.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Biblioteca NumPy (Python) para cross product",
                                    "Simulador de atitude (e.g., Orekit gratuito)"
                                  ],
                                  "tips": "Em Python: np.cross(r, F); magnitude em ordem de micro/nano N·m para CubeSats.",
                                  "learningObjective": "Aplicar produto vetorial para obter torque em configurações espaciais.",
                                  "commonMistakes": [
                                    "Ordem errada em cross product (direção errada)",
                                    "Unidades inconsistentes (m·N)",
                                    "Esquecer soma vetorial de torques"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat com dois painéis solares de 10x10cm separados por 10cm do CM, desalinhados 15°: calcule torque gerado pelo sol (P≈4.5μN/m²), resultando em τ≈2 nN·m, exigindo correção via rodas de reação.",
                              "finalVerifications": [
                                "Torque calculado tem magnitude consistente com literatura (~nN·m para pequenos satélites).",
                                "Direção do torque coincide com eixo de rotação esperado.",
                                "Forças individuais somam a força líquida mínima (<1% da individual).",
                                "Modelo responde corretamente a alinhamento perfeito (τ=0).",
                                "Simulação numérica replica resultados analíticos.",
                                "Sensibilidade a ângulo θ varia como sin(2θ) aproximadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas de pressão e força (erro <5%).",
                                "Correta implementação de vetores posição e normais.",
                                "Uso apropriado de produto cruzado sem erros de sinal.",
                                "Análise qualitativa de assimetria gerando torque.",
                                "Validação numérica com exemplo prático.",
                                "Clareza no diagrama e documentação do modelo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra vetorial e produto cruzado.",
                                "Física: Mecânica newtoniana e radiação eletromagnética.",
                                "Engenharia: Design de spacecraft e controle de atitude.",
                                "Programação: Simulações numéricas em Python/MATLAB.",
                                "Química/Física: Interação luz-matéria (absorção/reflexão)."
                              ],
                              "realWorldApplication": "Modelagem essencial para CubeSats e satélites pequenos, onde torque de pressão solar perturba atitude; usado em missões como MarCO ou Lightsail para prever desvios e dimensionar atuadores de controle."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Analisar estabilidade de torque",
                            "description": "Analisar a direção e magnitude do torque restaurador ou desestabilizador em diferentes orientações orbitais, considerando o vetor radial solar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Pressão Solar e Torque",
                                  "subSteps": [
                                    "Estude a lei de pressão de radiação solar: P = (2I/c) cos²θ para superfícies perfeitas refletoras.",
                                    "Defina torque como τ = r × F, onde F é a força devido à pressão solar.",
                                    "Identifique componentes: momento de inércia, vetor posição r e vetor força F.",
                                    "Revise vetores unitários em coordenadas do veículo espacial.",
                                    "Calcule exemplos simples de magnitude de força solar em um painel."
                                  ],
                                  "verification": "Resolva 3 problemas básicos de cálculo de força solar e torque, conferindo com fórmulas padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de dinâmica orbital, calculadora, notas de aula sobre mecânica orbital.",
                                  "tips": "Use diagramas vetoriais para visualizar forças e momentos.",
                                  "learningObjective": "Compreender a origem física do torque de pressão solar.",
                                  "commonMistakes": "Confundir pressão absorvida com refletida; ignorar fator cos²θ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Coordenadas Orbitais e Vetor Radial Solar",
                                  "subSteps": [
                                    "Estabeleça sistema de coordenadas: LVLH (Local Vertical Local Horizontal) ou ECIF.",
                                    "Determine o vetor radial solar ŝ como direção do Sol relativa à órbita.",
                                    "Calcule ângulo entre normal do painel e vetor solar para diferentes orientações.",
                                    "Liste orientações típicas: nadir-pointing, sun-pointing, roll/yaw/ pitch variações.",
                                    "Implemente em software para plotar vetor solar ao longo da órbita."
                                  ],
                                  "verification": "Gere gráfico de vetor radial solar para uma órbita circular de 90 minutos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB, dados orbitais de referência (ex: ISS).",
                                  "tips": "Use ângulos verdadeiros de anomalia para parametrizar a órbita.",
                                  "learningObjective": "Modelar geometricamente o vetor solar em referência orbital.",
                                  "commonMistakes": "Negligenciar rotação da Terra ou eclipse orbital no vetor solar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Magnitude e Direção do Torque",
                                  "subSteps": [
                                    "Formule torque τ = ∫ (r × dF) sobre a superfície exposta ao Sol.",
                                    "Para painéis planos: τ = A * P * (r_cm × n_hat * cosθ), onde r_cm é vetor ao centro de massa.",
                                    "Compute componentes em eixos de roll, pitch, yaw para múltiplas orientações.",
                                    "Avalie sinal do torque: positivo (desestabilizador) ou negativo (restaurador).",
                                    "Valide com simulação numérica de 5 orientações diferentes."
                                  ],
                                  "verification": "Compare cálculos manuais com simulação em software; erro <5%.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software de simulação (Python/STK), planilha Excel para cálculos iniciais.",
                                  "tips": "Linearize para pequenas perturbações em ângulos de atitude.",
                                  "learningObjective": "Quantificar torque considerando geometria e vetor radial.",
                                  "commonMistakes": "Usar centro geométrico em vez de centro de pressão; erros em produto vetorial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Estabilidade em Diferentes Orientações",
                                  "subSteps": [
                                    "Classifique torque como restaurador (alinhando veículo) ou desestabilizador (aumentando desalinhamento).",
                                    "Plote curvas de torque vs ângulo de rotação para cada eixo.",
                                    "Identifique pontos de equilíbrio estável/instável baseados em derivada dτ/dθ.",
                                    "Simule dinâmica: integre equações de Euler com torque solar.",
                                    "Conclua estabilidade para órbitas eclipse/sunlit."
                                  ],
                                  "verification": "Identifique corretamente 3 orientações estáveis e 2 instáveis em simulação.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Simulador de atitude (ex: Python com SciPy odeint), gráficos de torque-angular.",
                                  "tips": "Analise sinal da rigidez torsional k = -dτ/dθ >0 para estabilidade.",
                                  "learningObjective": "Avaliar se torque promove ou combate desvios de atitude.",
                                  "commonMistakes": "Ignorar assimetrias na distribuição de painéis solares."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e Visualizar Resultados de Estabilidade",
                                  "subSteps": [
                                    "Gere relatório com tabelas de torque por orientação e classificações.",
                                    "Crie visualizações 3D do veículo com vetores de torque.",
                                    "Discuta impactos em controle de atitude (ex: necessidade de rodas de reação).",
                                    "Teste sensibilidade a variações orbitais ou albedo.",
                                    "Documente conclusões em um diagrama de fase."
                                  ],
                                  "verification": "Apresente análise completa com pelo menos 10 cenários testados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramentas de visualização (Blender/Paraview ou Matplotlib 3D), relatório template.",
                                  "tips": "Use animações para mostrar evolução temporal do torque.",
                                  "learningObjective": "Sintetizar análise para decisões de design orbital.",
                                  "commonMistakes": "Sobrestimar torque em regiões de eclipse."
                                }
                              ],
                              "practicalExample": "Para um CubeSat em órbita LEO (500km, 90° inclinação), analise torque quando painéis solares estão desalinhados 10° em roll com vetor solar radial apontando 45° da nadir: calcule τ_roll = -0.001 Nm (restaurador), confirmando estabilidade em sun-pointing.",
                              "finalVerifications": [
                                "Calcula corretamente torque para 5 orientações orbitais variadas.",
                                "Classifica torque como restaurador/desestabilizador com justificativa vetorial.",
                                "Simula dinâmica mostrando convergência a equilíbrio estável.",
                                "Identifica influência do vetor radial solar em todas as análises.",
                                "Gera gráficos precisos de torque vs ângulo com derivadas corretas.",
                                "Valida resultados contra referências literárias (erro <10%)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos vetoriais (90%+ acurácia).",
                                "Completude da análise em múltiplas orientações (cobertura >80%).",
                                "Correta interpretação de estabilidade baseada em sinais e derivadas.",
                                "Qualidade das visualizações e simulações (claras e rotuladas).",
                                "Integração do vetor radial solar em todos os passos.",
                                "Profundidade das discussões de erros e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica clássica e vetores (produto cruzado).",
                                "Matemática: Cálculo diferencial (derivadas para estabilidade).",
                                "Engenharia de Controle: Análise de sistemas lineares e não-lineares.",
                                "Ciência de Materiais: Propriedades óticas de superfícies solares.",
                                "Computação: Programação numérica e simulação dinâmica."
                              ],
                              "realWorldApplication": "Em missões como o satélite GOES ou CubeSats da NASA, essa análise otimiza orientação de painéis solares para maximizar energia enquanto mantém estabilidade de atitude sem gasto excessivo de combustível em propulsores, prevenindo tumblings desestabilizadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Identificar fatores perturbadores",
                            "description": "Listar e quantificar fatores que modulam o torque solar, como sombreamento parcial, envelhecimento de superfícies e variação de albedo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Pressão e Torque Solar",
                                  "subSteps": [
                                    "Estude a lei da pressão de radiação solar: P = (2I/c) cos²θ para superfícies perfeitas.",
                                    "Entenda como o torque é gerado: τ = r × F, onde F é a força de pressão solar.",
                                    "Identifique componentes do veículo espacial expostos ao Sol (painéis solares, corpo principal).",
                                    "Calcule torque nominal sem perturbações usando equações básicas.",
                                    "Registre anotações sobre dependências geométricas e angulares."
                                  ],
                                  "verification": "Resuma em um diagrama simples o cálculo de torque solar básico e confirme com fórmula derivada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de dinâmica orbital, calculadora, software de desenho (ex: Draw.io).",
                                  "tips": "Use diagramas vetoriais para visualizar forças e momentos.",
                                  "learningObjective": "Compreender a geração ideal de torque solar antes de perturbações.",
                                  "commonMistakes": "Confundir pressão absorvida com refletida; ignorar fator de incidência angular."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Fatores Perturbadores Principais",
                                  "subSteps": [
                                    "Liste sombreamento parcial: modelado por fração de área iluminada (A_ilum / A_total).",
                                    "Descreva envelhecimento de superfícies: redução no coeficiente de refletividade (ρ) ao longo do tempo.",
                                    "Explique variação de albedo: mudanças sazonais ou degradação por contaminação.",
                                    "Inclua outros fatores como temperatura (afeta propriedades ópticas) e rugosidade superficial.",
                                    "Crie uma tabela comparativa com exemplos numéricos iniciais para cada fator."
                                  ],
                                  "verification": "Produza uma lista de pelo menos 5 fatores com descrições breves e referências bibliográficas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Artigos científicos sobre pressão solar (NASA reports), planilha Excel.",
                                  "tips": "Priorize fatores com maior impacto quantitativo baseado em literatura.",
                                  "learningObjective": "Reconhecer e categorizar moduladores do torque solar.",
                                  "commonMistakes": "Omitir fatores secundários como vibrações; superestimar efeitos raros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar e Quantificar Cada Fator Perturbador",
                                  "subSteps": [
                                    "Para sombreamento: calcule fração iluminada usando geometria de órbita (ângulo de eclipse).",
                                    "Para envelhecimento: modele ρ(t) = ρ0 * e^(-kt), estime k de dados empíricos.",
                                    "Para albedo: use valores típicos (0.1-0.9) e simule variações ±20%.",
                                    "Quantifique impacto: Δτ / τ_nominal para cada fator isoladamente.",
                                    "Valide modelos com equações dimensionais e unidades consistentes."
                                  ],
                                  "verification": "Gere gráficos de torque modulado vs. tempo para 3 fatores usando planilha.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software MATLAB/Python para simulações, dados de missões reais (ex: GOES satélite).",
                                  "tips": "Use aproximações lineares para perturbações pequenas antes de modelos complexos.",
                                  "learningObjective": "Desenvolver modelos matemáticos para quantificação precisa de perturbações.",
                                  "commonMistakes": "Erros de unidade (N/m² vs. N); ignorar dependências não-lineares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Fatores e Analisar Impacto Total",
                                  "subSteps": [
                                    "Combine fatores multiplicativamente: τ_total = τ_nominal * f_somb * f_envel * f_albedo.",
                                    "Simule cenários: nominal, pior-caso, médio para uma órbita LEO.",
                                    "Avalie sensibilidade: ∂τ/∂parâmetro para cada fator.",
                                    "Compare com dados reais de telemetria de satélites.",
                                    "Documente relatório com conclusões sobre dominância de fatores."
                                  ],
                                  "verification": "Crie relatório de 1 página com cálculos, gráficos e análise de sensibilidade.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ferramenta de simulação orbital (ex: GMAT, STK trial), templates de relatório.",
                                  "tips": "Teste com valores extremos para validar robustez do modelo.",
                                  "learningObjective": "Aplicar análise integrada de múltiplos perturbadores no torque solar.",
                                  "commonMistakes": "Não normalizar impactos; assumir independência total entre fatores."
                                }
                              ],
                              "practicalExample": "Para um CubeSat em órbita LEO com painéis solares de 0.1 m², calcule torque nominal de 1e-6 Nm. Aplique sombreamento de 30% (eclipse), envelhecimento reduzindo ρ de 0.8 para 0.6 em 2 anos, e variação de albedo de 0.2: resulte em τ_total ≈ 0.45 * τ_nominal, demonstrando necessidade de compensação ativa.",
                              "finalVerifications": [
                                "Lista completa de 5+ fatores perturbadores com descrições precisas.",
                                "Modelos matemáticos quantificados para pelo menos 3 fatores principais.",
                                "Gráficos mostrando modulação de torque em cenários realistas.",
                                "Análise de sensibilidade identificando fator dominante.",
                                "Comparação com dados de missões espaciais reais.",
                                "Relatório integrado sem erros dimensionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações de modelagem (90%+ correção).",
                                "Profundidade da quantificação numérica (valores realistas citados).",
                                "Qualidade dos gráficos e visualizações (legendas claras, escalas adequadas).",
                                "Identificação correta de erros comuns e mitigação.",
                                "Integração interdisciplinar evidenciada.",
                                "Clareza e estrutura do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Física: Radiação eletromagnética e mecânica orbital.",
                                "Materiais: Degradação de superfícies e óptica.",
                                "Matemática: Modelagem diferencial e análise de sensibilidade.",
                                "Engenharia: Simulação de sistemas espaciais.",
                                "Ciência de Dados: Análise de telemetria e validação empírica."
                              ],
                              "realWorldApplication": "Em missões como o satélite Hubble ou constelações Starlink, identificar esses fatores permite otimizar algoritmos de controle de atitude, reduzindo consumo de combustível de rodas de reação em até 20% e prolongando vida útil da missão."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Aplicação em Controle de Atitude",
                        "description": "Integração do torque de pressão solar em sistemas de controle de atitude passivo ou híbrido para estabilização e manobras de orientação em veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Projetar sistema passivo de controle",
                            "description": "Projetar uma configuração de superfícies para gerar torque solar passivo que estabilize a atitude em órbita geoestacionária ou LEO, calculando taxas de deriva angular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Princípios de Torque Solar Passivo e Requisitos da Missão",
                                  "subSteps": [
                                    "Estude a física da pressão de radiação solar e como ela gera torque em superfícies assimétricas.",
                                    "Analise as órbitas GEO e LEO: período orbital, iluminação solar e requisitos de estabilização de atitude.",
                                    "Defina objetivos: estabilização em roll/pitch/yaw e tolerâncias para deriva angular (ex: <0.1°/dia).",
                                    "Revise literatura sobre sistemas passivos como caindores solares ou asas.",
                                    "Documente restrições: tamanho do satélite, massa, potência disponível."
                                  ],
                                  "verification": "Resumo escrito com equações chave de pressão solar e diagrama conceitual dos requisitos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livros de dinâmica orbital (ex: Vallado), artigos sobre controle passivo, calculadora simbólica (SymPy).",
                                  "tips": "Comece com equações vetoriais para torque: τ = (A × n) × F_solar, onde A é área, n normal.",
                                  "learningObjective": "Compreender como torque passivo estabiliza atitude sem atuadores ativos.",
                                  "commonMistakes": "Ignorar variação sazonal da pressão solar ou confundir com torque gravitacional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Dinâmica de Atitude do Satélite",
                                  "subSteps": [
                                    "Defina o modelo cinemático: quaternions ou ângulos de Euler para atitude.",
                                    "Escreva equações dinâmicas: I ω̇ + ω × I ω = τ_solar + τ_grav + τ_drag.",
                                    "Implemente modelo orbital: posição relativa ao Sol usando propagador simplificado (SGP4).",
                                    "Linearize para pequenas perturbações em LEO/GEO.",
                                    "Calcule momento de inércia do satélite assumido (ex: CubeSat 3U)."
                                  ],
                                  "verification": "Código ou planilha com simulação de atitude não controlada mostrando deriva >1°/dia.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Python/MATLAB com bibliotecas Orekit ou poliastro, planilhas Excel.",
                                  "tips": "Use quaternions para evitar singularidades em simulações.",
                                  "learningObjective": "Modelar precisamente a evolução da atitude sob perturbações solares.",
                                  "commonMistakes": "Negligenciar momento de inércia principal ou assumir órbita circular perfeita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar Configuração de Superfícies Geradoras de Torque",
                                  "subSteps": [
                                    "Escolha tipo: caindores laterais para roll ou asas dihedrais para pitch/yaw.",
                                    "Otimize dimensões: área A, ângulo de incidência α, posição relativa ao CG.",
                                    "Calcule coeficiente de arrasto solar: C_p = 2 para superfícies perfeitas.",
                                    "Gere torque restaurador: τ = (r × F), F = P_s A cosα, P_s = 4.56 μN/m².",
                                    "Itere designs com trade-offs: massa vs. torque (m <5% massa total)."
                                  ],
                                  "verification": "Diagrama CAD/sketch com parâmetros e torque médio calculado > perturbações.",
                                  "estimatedTime": "8 horas",
                                  "materials": "Software CAD (FreeCAD), Python para otimização (SciPy).",
                                  "tips": "Use otimização gradient-free como Nelder-Mead para parâmetros geométricos.",
                                  "learningObjective": "Criar geometria que produza torque assimétrico dependente da atitude.",
                                  "commonMistakes": "Sobrestimar eficiência (C_p real <2 devido a refletividade) ou ignorar sombreamento mútuo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Taxas de Deriva Angular e Simular Estabilização",
                                  "subSteps": [
                                    "Integre equações de atitude com torque passivo incluído.",
                                    "Calcule taxa de deriva residual: ω_drift = ∫(τ_net / I) dt sobre um órbita.",
                                    "Simule para LEO (eclipse 35%) e GEO (iluminação contínua).",
                                    "Analise convergência: tempo para |θ| <1°.",
                                    "Ajuste parâmetros para drift <0.05°/dia."
                                  ],
                                  "verification": "Gráficos de simulação mostrando estabilização em <7 dias e drift especificado.",
                                  "estimatedTime": "10 horas",
                                  "materials": "MATLAB/Simulink ou Python (SciPy ODEINT), plotters (Matplotlib).",
                                  "tips": "Simule múltiplas órbitas (30 dias) para capturar efeitos cumulativos.",
                                  "learningObjective": "Quantificar performance do sistema passivo via simulação numérica.",
                                  "commonMistakes": "Usar passos de integração grosseiros levando a instabilidade numérica."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, Otimizar e Documentar o Design",
                                  "subSteps": [
                                    "Compare com benchmarks: CubeSat passivos reais (ex: UniSat).",
                                    "Sensitividade: variação ±20% em P_s, I.",
                                    "Otimize para mínimo drift com restrições de massa.",
                                    "Crie relatório com specs finais.",
                                    "Proponha testes: tabela de arremesso ou simulação HIL."
                                  ],
                                  "verification": "Relatório PDF com design final, simulações e métricas de performance.",
                                  "estimatedTime": "4 horas",
                                  "materials": "LaTeX/Word para relatório, Git para versionamento.",
                                  "tips": "Inclua uncertainty quantification com Monte Carlo.",
                                  "learningObjective": "Garantir robustez do design contra incertezas.",
                                  "commonMistakes": "Não considerar envelhecimento de superfícies (degradação UV)."
                                }
                              ],
                              "practicalExample": "Para um CubeSat 3U em LEO (500km, 97° inclinação), projetar caindores laterais de 0.1m² a 30° de dihedral, gerando τ_roll = 1.2e-6 Nm, estabilizando roll em 3 dias com drift de 0.02°/dia.",
                              "finalVerifications": [
                                "Simulação mostra estabilização em <10 dias para LEO/GEO.",
                                "Drift angular calculado <0.1°/dia em ambos cenários.",
                                "Massa adicionada <3% do total do satélite.",
                                "Torque gerado excede perturbações em fator >2.",
                                "Design tolera ±10% variação em pressão solar.",
                                "Documentação inclui equações, código e diagramas."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de torque (erro <5%).",
                                "Adequação da estabilização (tempo <7 dias ideal).",
                                "Otimização de massa vs. performance.",
                                "Robustez em simulações variadas (LEO/GEO).",
                                "Clareza da documentação e visualizações.",
                                "Identificação correta de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica orbital e pressão de radiação.",
                                "Matemática: Equações diferenciais e otimização numérica.",
                                "Engenharia Mecânica: Dinâmica de corpos rígidos.",
                                "Programação: Simulação em Python/MATLAB.",
                                "Gestão de Projetos: Trade-offs e validação."
                              ],
                              "realWorldApplication": "Usado em satélites de baixo custo como CubeSats (ex: QB50 mission) e GEO comersiciais (ex: Intelsat), reduzindo consumo de energia em 20-50% ao eliminar rodas de reação para estabilização básica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Simular dinâmica de atitude",
                            "description": "Implementar simulação numérica do torque solar em equações de Euler rígido para prever evolução de atitude, usando ferramentas como MATLAB ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Derivar Equações de Euler Rígido para Dinâmica de Atitude",
                                  "subSteps": [
                                    "Estude as equações cinemáticas e dinâmicas de rotação para corpo rígido: ω̇ = I⁻¹ (τ - ω × (I ω)) onde ω é vetor de velocidade angular, I é tensor de inércia, τ é torque.",
                                    "Defina parâmetros do satélite: tensor de inércia principal (Ixx, Iyy, Izz) e condições iniciais de atitude (quaternions ou ângulos de Euler) e ω(0).",
                                    "Implemente representação de atitude usando quaternions para evitar singularidades gimbal lock.",
                                    "Verifique derivação derivando torque total τ = τ_solar + outros (inicialmente só solar).",
                                    "Teste equações analiticamente para caso sem torque (rotação constante)."
                                  ],
                                  "verification": "Equações derivadas corretamente e testadas com solução analítica simples (ex: ω constante).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Spacecraft Attitude Dynamics' de Peter Hughes; notebook Jupyter ou MATLAB script.",
                                  "tips": "Use quaternions desde o início para precisão; normalize quaternions periodicamente.",
                                  "learningObjective": "Compreender e formular matematicamente a dinâmica rotacional de um corpo rígido sob torques externos.",
                                  "commonMistakes": "Confundir frame inercial com body frame; esquecer skew-symmetric matrix para ω × termo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Torque de Pressão Solar",
                                  "subSteps": [
                                    "Calcule área projetada A_proj = A_panel * |cos θ| onde θ é ângulo incidência solar (usar vetor posição satélite e direção sol).",
                                    "Defina pressão solar P = 4.56e-6 N/m² (constante padrão); torque τ_solar = r_cm × (P * A_proj * n_hat) onde r_cm é vetor do centro de massa ao centro de pressão, n_hat normal do painel.",
                                    "Inclua variação orbital: direção sol relativa via vetor posição orbital e vetor sol (assumir órbita circular inicialmente).",
                                    "Implemente função τ_solar(q, ω, t) dependente de atitude q e tempo t.",
                                    "Valide modelo com valores típicos: τ ~ 1e-7 Nm para CubeSat."
                                  ],
                                  "verification": "Função τ_solar retorna valores físicos realistas para inputs de teste (ex: painel perpendicular ao sol).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Documentação NASA sobre pressão solar; calculadora simbólica como SymPy.",
                                  "tips": "Use vetores unitários corretamente; considere sombra da Terra para realismo (opcional).",
                                  "learningObjective": "Modelar forças não-gravitacionais específicas como torque solar em termos vetoriais.",
                                  "commonMistakes": "Ignorar direção do raio solar relativa ao body frame; usar área total em vez de projetada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Ambiente de Simulação Numérica",
                                  "subSteps": [
                                    "Instale bibliotecas: Python (numpy, scipy.integrate, matplotlib) ou MATLAB Aerospace Toolbox.",
                                    "Defina classe ou struct para satélite: I, A_panel, r_cm, órbita params (R_earth, h_orbita).",
                                    "Escreva função de estado x = [q; ω] onde q quaternion (4 elems), ω (3 elems), total 7D.",
                                    "Configure integrador: ode45 (MATLAB) ou solve_ivp(method='RK45') com tolerâncias rel=1e-9.",
                                    "Prepare plotters para attitude (quaternions), ω e τ ao longo do tempo."
                                  ],
                                  "verification": "Ambiente roda script de teste simples (equações sem torque, solução constante).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python 3.10+ com Anaconda; ou MATLAB R2023a; tutoriais SciPy ODE.",
                                  "tips": "Mantenha estado x(0) com ||q||=1; use eventos para detecção de sombra.",
                                  "learningObjective": "Preparar framework computacional para integração de EDOs rígidas.",
                                  "commonMistakes": "Não normalizar quaternion no estado; escala errada em I (kg m²)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Executar Simulação",
                                  "subSteps": [
                                    "Defina derivada estado: q̇ = 0.5 * Ω(ω) * q; ω̇ como equação Euler; Ω skew matrix.",
                                    "Integre por 1 órbita (ex: 90 min LEO): t_span = [0, 5400] s.",
                                    "Adicione torque solar na derivada; rode simulação com ω(0)=0, q(0)=[1,0,0,0].",
                                    "Visualize: plots de componentes quaternion, ω vs tempo, τ_solar magnitude.",
                                    "Experimente parâmetros: varie incidência solar ou I assimétrico."
                                  ],
                                  "verification": "Simulação converge sem crashes; attitude deriva monotonicamente devido a torque.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Scripts desenvolvidos nos steps anteriores; hardware com GPU opcional para plots.",
                                  "tips": "Salve soluções em .mat ou .csv; use animação 3D para visualização intuitiva.",
                                  "learningObjective": "Executar simulação numérica end-to-end de dinâmica não-linear.",
                                  "commonMistakes": "Erro na matriz Ω(ω); timestep muito grande causando instabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Validar Resultados",
                                  "subSteps": [
                                    "Compare com solução analítica aproximada (torque constante médio).",
                                    "Calcule métricas: drift angular total Δθ = ∫||ω|| dt; energia cinética conservada?",
                                    "Teste sensibilidade: varie P_solar ±10%, observe impacto em drift.",
                                    "Valide contra literatura (ex: papers CubeSat solar torque).",
                                    "Otimize: reduza ordem se necessário (quaternion redundant)."
                                  ],
                                  "verification": "Resultados físicos: drift ~ graus/dia para CubeSat típico; conservação numérica <1e-6 erro.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Referências: 'Analytical Solar Torque Model' papers; ferramentas plot como plotly.",
                                  "tips": "Use logscale para erros pequenos; documente assumptions orbitais.",
                                  "learningObjective": "Interpretar e validar simulações numéricas contra expectativas físicas.",
                                  "commonMistakes": "Atribuir drift a numéricos em vez de física; ignorar periodicidade orbital."
                                }
                              ],
                              "practicalExample": "Simule um CubeSat 1U (10x10x10 cm, I_diag=[0.001,0.001,0.002] kg m²) em órbita LEO a 500 km com painel solar de 0.01 m² perpendicular inicialmente. Preveja drift de roll devido a torque solar médio de 5e-7 Nm ao longo de 24h, visualizando evolução de quaternion e ω.",
                              "finalVerifications": [
                                "Simulação executa por múltiplas órbitas sem divergência numérica.",
                                "Torque solar varia periodicamente com órbita (eclipse modelado).",
                                "Attitude deriva consistentemente com direção do torque médio.",
                                "Conservação de momentos angulares sem atuadores (erro <1e-8).",
                                "Plots mostram estabilidade e realismo físico (drift <5°/dia).",
                                "Código reproduzível com seed randômico fixo."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem de torque solar (erro <5% vs analítico).",
                                "Estabilidade numérica do integrador (erro global <1e-6).",
                                "Correta implementação de quaternions (normalização mantida).",
                                "Visualizações claras e informativas de resultados.",
                                "Validação quantitativa contra benchmarks conhecidos.",
                                "Eficiência computacional (tempo <10s por órbita)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica de EDOs não-lineares (métodos RK).",
                                "Física: Mecânica clássica de rotação e forças não-conservativas.",
                                "Programação: OOP para modelagem física e solvers SciPy/MATLAB.",
                                "Engenharia: Design de sistemas espaciais e análise de perturbações.",
                                "Computação Científica: Visualização de dados multidimensionais."
                              ],
                              "realWorldApplication": "Em missões CubeSat como MarCO (NASA), simulações de torque solar preveem necessidade de rodas de reação para manter pointing preciso, evitando perda de comunicação ou imaging falho em constelações como Starlink."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.2",
                              "10.1.3.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Comparar com outros atuadores",
                            "description": "Comparar eficiência do torque solar com rodas de reação e propulsores, avaliando consumo de energia, precisão e aplicabilidade em missões de longa duração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Princípios Fundamentais dos Atuadores",
                                  "subSteps": [
                                    "Pesquise o funcionamento do torque de pressão solar: explique como a radiação solar gera torque via superfícies assimétricas.",
                                    "Descreva rodas de reação (RWs): discuta conservação de momento angular e saturação.",
                                    "Explique propulsores de controle (thrusters): detalhe tipos (químicos, elétricos) e seu uso em manobras.",
                                    "Identifique limitações inerentes de cada um: torque solar (lento, dependente de órbita), RWs (energia para desaturação), thrusters (propelente finito).",
                                    "Crie um diagrama comparativo simples dos mecanismos."
                                  ],
                                  "verification": "Resuma em um parágrafo por atuador e valide com fontes confiáveis como NASA ou papers acadêmicos.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Acesso à internet para artigos (NASA, AIAA), caderno para notas, software de diagramação (Draw.io)"
                                  ],
                                  "tips": "Use analogias terrestres, como velas solares para torque solar, para fixar conceitos.",
                                  "learningObjective": "Compreender os mecanismos físicos e limitações básicas de torque solar, rodas de reação e propulsores.",
                                  "commonMistakes": "Confundir torque solar com velas de propulsão (foco em atitude, não translação); ignorar dependência orbital do torque solar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Definir Métricas de Comparação",
                                  "subSteps": [
                                    "Liste métricas chave: consumo de energia (W/kg), precisão (arcsec), tempo de resposta (s), aplicabilidade em missões longas (anos).",
                                    "Pesquise valores típicos: torque solar (~10^-7 Nm/m²), RWs (alta precisão <0.001°/s), thrusters (baixa precisão ~0.1°).",
                                    "Defina critérios qualitativos: confiabilidade, custo, massa, manutenção.",
                                    "Crie uma tabela de métricas com unidades padronizadas.",
                                    "Priorize métricas para missões de longa duração (ex.: minimizar consumo de propelente)."
                                  ],
                                  "verification": "Tabela completa com pelo menos 5 métricas e valores referenciados preenchida.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Planilhas (Excel/Google Sheets), referências técnicas (ESA reports, textbooks como 'Spacecraft Attitude Determination')"
                                  ],
                                  "tips": "Padronize unidades (SI) para evitar erros de comparação.",
                                  "learningObjective": "Selecionar e quantificar métricas relevantes para avaliação comparativa de atuadores.",
                                  "commonMistakes": "Omitir contexto orbital (torque solar varia); usar dados genéricos sem fontes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Comparação Quantitativa e Qualitativa",
                                  "subSteps": [
                                    "Preencha a tabela com dados: compare energia (solar: zero fuel, RWs: elétrica, thrusters: propelente).",
                                    "Calcule exemplos: eficiência energética para mudança de atitude de 10° em 1 ano.",
                                    "Analise trade-offs: precisão (RWs > solar > thrusters), mas longa duração favorece solar (sem desgaste).",
                                    "Discuta cenários: LEO (solar variável), GEO (solar constante), deep space.",
                                    "Crie gráfico de radar comparativo das métricas."
                                  ],
                                  "verification": "Gráfico e tabela finalizados com análise escrita de 300 palavras.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Software de gráficos (Matlab/Python/Matplotlib, Excel), calculadora científica"
                                  ],
                                  "tips": "Use simulações simples em Python para cálculos dinâmicos se possível.",
                                  "learningObjective": "Aplicar dados para comparar eficiência, precisão e aplicabilidade entre atuadores.",
                                  "commonMistakes": "Ignorar não-linearidades (saturação RW, depleção thruster); superestimar torque solar em sombra."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Aplicabilidade em Missões de Longa Duração e Concluir",
                                  "subSteps": [
                                    "Simule missão exemplo: satélite de 5 anos em LEO, requisitos de atitude.",
                                    "Avalie híbridos: solar + RWs para eficiência ótima.",
                                    "Discuta prós/contras finais: solar ideal para passiva longa duração.",
                                    "Redija relatório de comparação com recomendações.",
                                    "Identifique gaps de conhecimento para pesquisa futura."
                                  ],
                                  "verification": "Relatório de 1 página com conclusões claras e referências.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Ferramenta de edição (Word/Google Docs), simulador básico (STK free trial se disponível)"
                                  ],
                                  "tips": "Foque em trade-offs quantitativos para missões reais como James Webb.",
                                  "learningObjective": "Sintetizar comparação para recomendar atuadores em contextos espaciais específicos.",
                                  "commonMistakes": "Generalizar sem contexto missional; negligenciar custos de implementação."
                                }
                              ],
                              "practicalExample": "Para um CubeSat em órbita LEO de 3 anos: calcule que torque solar mantém atitude com 0 energia extra, enquanto RWs precisam de 10% bateria para desaturação mensal, e thrusters esgotam propelente em 6 meses.",
                              "finalVerifications": [
                                "Pode listar 3 vantagens do torque solar sobre RWs em missões longas.",
                                "Explica com precisão as métricas de consumo de energia para cada atuador.",
                                "Identifica cenários onde thrusters são preferíveis apesar de ineficiência.",
                                "Cria tabela/gráfico comparativo sem erros factuais.",
                                "Recomenda híbrido corretamente para missão GEO.",
                                "Discute limitações orbitais do torque solar."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual dos princípios (30%)",
                                "Completude e relevância das métricas (25%)",
                                "Qualidade da análise quantitativa (20%)",
                                "Profundidade na aplicabilidade missional (15%)",
                                "Clareza e estrutura do relatório (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Momento angular e radiação eletromagnética",
                                "Matemática: Análise comparativa e gráficos de radar",
                                "Engenharia: Design de sistemas e trade-off analysis",
                                "Ciência de Dados: Coleta e visualização de métricas"
                              ],
                              "realWorldApplication": "Em missões como o satélite GOES (usa torque solar para economia em longa duração) ou Hubble (RWs principais, mas solar auxiliar), permitindo otimizar designs para reduzir custos de lançamento e operação em constelações como Starlink."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.4",
                            "name": "Discutir limitações e exemplos reais",
                            "description": "Analisar limitações como baixa magnitude do torque (10^-7 a 10^-5 Nm/m²) e citar exemplos de satélites como GOCE ou sailcraft que utilizam pressão solar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos e limitações teóricas do torque de pressão solar",
                                  "subSteps": [
                                    "Estude a fórmula do torque de pressão solar: τ = (P * A * cos²θ) / c, onde P é pressão, A área, θ ângulo, c velocidade da luz.",
                                    "Identifique fatores que limitam a magnitude: dependência da orientação, distância solar e propriedades do material.",
                                    "Compare com outros torques (gravitacional, magnético) para contextualizar a baixa magnitude (10^-7 a 10^-5 Nm/m²).",
                                    "Anote limitações como variabilidade diurna e insensibilidade a rotação rápida.",
                                    "Discuta impactos no controle de atitude: necessidade de amplificação ou compensação."
                                  ],
                                  "verification": "Resuma em um parágrafo as principais limitações teóricas e compare magnitudes com outros torques.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de dinâmica orbital",
                                    "Artigo sobre pressão de radiação solar",
                                    "Calculadora ou software como MATLAB"
                                  ],
                                  "tips": "Use diagramas para visualizar forças em painéis solares variando com θ.",
                                  "learningObjective": "Compreender as bases físicas que tornam o torque de pressão solar pequeno e variável.",
                                  "commonMistakes": [
                                    "Confundir pressão de radiação com vento solar",
                                    "Ignorar o fator cos²θ na magnitude"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar quantitativamente a magnitude do torque",
                                  "subSteps": [
                                    "Calcule a pressão solar padrão: P ≈ 4.56 × 10^-6 N/m² na Terra.",
                                    "Estime torque para um satélite típico: A = 10 m², τ ≈ 10^-7 a 10^-5 Nm/m².",
                                    "Simule variações com distância (lei inversa do quadrado) e ângulo de incidência.",
                                    "Compare com requisitos de controle de atitude (ex: 10^-6 Nm para estabilização).",
                                    "Crie uma tabela de magnitudes em diferentes órbitas (LEO, GEO)."
                                  ],
                                  "verification": "Produza uma tabela ou gráfico mostrando magnitudes calculadas e conclusões sobre viabilidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para cálculos",
                                    "Dados de pressão solar de NASA",
                                    "Referências de constantes físicas"
                                  ],
                                  "tips": "Use unidades consistentes (Nm/m²) e valide cálculos com fontes confiáveis.",
                                  "learningObjective": "Quantificar por que o torque é baixo e suas implicações numéricas.",
                                  "commonMistakes": [
                                    "Erro em unidades (confundir N/m² com Nm)",
                                    "Esquecer fator de refletividade do material"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Pesquisar e analisar exemplos reais de satélites",
                                  "subSteps": [
                                    "Estude o satélite GOCE: como usou velas solares para compensar arrasto aerodinâmico.",
                                    "Analise sailcraft como IKAROS ou LightSail: deployment de velas grandes para maximizar torque.",
                                    "Identifique como esses exemplos lidam com limitações: grandes áreas, órbitas específicas.",
                                    "Colete dados de missões: magnitudes reais medidas e estratégias de controle.",
                                    "Compare sucessos e falhas em controle de atitude."
                                  ],
                                  "verification": "Elabore um relatório curto com 2-3 exemplos, incluindo dados e lições aprendidas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Site da ESA/NASA para GOCE",
                                    "Papers sobre IKAROS/LightSail",
                                    "Vídeos de missões espaciais"
                                  ],
                                  "tips": "Busque fontes primárias como relatórios de missão para dados precisos.",
                                  "learningObjective": "Conectar teoria a aplicações reais através de casos de estudo.",
                                  "commonMistakes": [
                                    "Generalizar sem dados específicos",
                                    "Confundir sailcraft com painéis solares padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar discussão sobre limitações e recomendações",
                                  "subSteps": [
                                    "Integre análises: como mitigar baixa magnitude (ex: velas grandes, controle híbrido).",
                                    "Discuta cenários onde é útil: missões de longa duração sem combustível.",
                                    "Prepare argumentos para debate: prós/cons em controle de atitude.",
                                    "Crie uma apresentação ou ensaio final.",
                                    "Avalie trade-offs com outros atuadores."
                                  ],
                                  "verification": "Apresente uma discussão oral ou escrita cobrindo limitações, exemplos e conclusões.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de apresentação (PowerPoint/Google Slides)",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Estruture como: introdução, limitações, exemplos, conclusões.",
                                  "learningObjective": "Desenvolver habilidade de discutir criticamente limitações e aplicações reais.",
                                  "commonMistakes": [
                                    "Focar só em limitações sem exemplos positivos",
                                    "Não quantificar impactos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma missão como GOCE, o torque de pressão solar (∼10^-6 Nm) foi usado para balancear arrasto em órbita baixa; simule calculando torque para uma vela de 10 m² e discuta como isso afeta o controle de atitude em Python.",
                              "finalVerifications": [
                                "Explica corretamente a magnitude típica (10^-7 a 10^-5 Nm/m²) e fatores limitantes.",
                                "Cita pelo menos dois exemplos reais (GOCE, sailcraft) com detalhes precisos.",
                                "Identifica estratégias de mitigação como áreas grandes ou controle híbrido.",
                                "Compara com outros torques em contexto de atitude.",
                                "Discute aplicações viáveis em missões reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão quantitativa nos cálculos de magnitude (90%+ acurácia).",
                                "Profundidade na análise de exemplos reais (cita fontes e dados).",
                                "Clareza na discussão de limitações e implicações.",
                                "Uso de evidências científicas e conexões lógicas.",
                                "Criatividade em recomendações para controle de atitude.",
                                "Completude da estrutura (todos elementos cobertos)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Radiação eletromagnética e momento de fótons.",
                                "Matemática: Cálculos vetoriais e modelagem numérica.",
                                "Engenharia Mecânica: Design de estruturas espaciais leves.",
                                "Ciência de Materiais: Refletividade e propriedades de velas solares."
                              ],
                              "realWorldApplication": "Em missões de satélites como GOCE ou sailcraft experimentais (IKAROS), o torque de pressão solar permite manobras sem propelentes, essencial para observações gravitacionais precisas ou propulsão interestelar futura, otimizando custos e vida útil em controle de atitude."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Rodas de Reação",
                    "description": "Atuadores de troca de momento angular que armazenam e liberam momento para controle fino de atitude.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Princípios de Funcionamento das Rodas de Reação",
                        "description": "Conceitos fundamentais sobre como as rodas de reação atuam como atuadores de troca de momento angular, armazenando e liberando momento para controle fino de atitude em veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Entender a conservação de momento angular",
                            "description": "Explicar a lei de conservação de momento angular e como ela é aplicada nas rodas de reação para alterar a atitude do veículo espacial sem expelir massa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Momento Angular",
                                  "subSteps": [
                                    "Diferencie momento linear (p = mv) de momento angular (L = Iω).",
                                    "Identifique que o momento angular é uma grandeza vetorial associada à rotação.",
                                    "Revise o momento de inércia (I) como medida de resistência à rotação.",
                                    "Entenda a velocidade angular (ω) em radianos por segundo.",
                                    "Visualize exemplos cotidianos como um pião girando."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre momento linear e angular, com um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de física (capítulo rotação), vídeo introdutório sobre momento angular (Khan Academy)"
                                  ],
                                  "tips": "Use analogias: momento linear é como empurrar uma bola, angular é girá-la.",
                                  "learningObjective": "Definir e diferenciar momento angular de conceitos relacionados.",
                                  "commonMistakes": [
                                    "Confundir momento de inércia com massa, ignorar a natureza vetorial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Lei de Conservação do Momento Angular",
                                  "subSteps": [
                                    "Enuncie a lei: Em um sistema isolado, o momento angular total é constante.",
                                    "Derive qualitativamente: torque zero implica dL/dt = 0.",
                                    "Aplique em exemplos terrestres: patinador puxando braços (I diminui, ω aumenta).",
                                    "Discuta ausência de torque externo no vácuo espacial.",
                                    "Resolva equação L_inicial = L_final para cenários simples."
                                  ],
                                  "verification": "Resolva um problema: patinador com I1ω1 = I2ω2, calcule ω2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora, planilha Excel para simulações, simulador PhET Rotational Motion"
                                  ],
                                  "tips": "Lembre-se: conservação só vale sem torques externos como atrito.",
                                  "learningObjective": "Aplicar a lei de conservação em sistemas rotacionais isolados.",
                                  "commonMistakes": [
                                    "Esquecer que é vetorial (direção importa), aplicar em sistemas com atrito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Funcionamento das Rodas de Reação",
                                  "subSteps": [
                                    "Descreva rodas de reação: rotores de alta inércia montados em eixos ortogonais.",
                                    "Explique: acelerar roda aumenta seu L_roda, veículo ganha L_veículo oposto.",
                                    "Calcule mudança de atitude: Δθ_veículo = - (I_roda Δω_roda) / I_veículo.",
                                    "Discuta saturação: rodas param de girar quando atingem velocidade máxima.",
                                    "Compare com propulsores: sem expelir massa, ideal para microajustes."
                                  ],
                                  "verification": "Desenhe diagrama vetorial mostrando conservação L_total = L_roda + L_veículo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de simulação como GMAT ou Kerbal Space Program, diagramas de rodas de reação"
                                  ],
                                  "tips": "Pense no sistema fechado: roda + spacecraft = total L constante.",
                                  "learningObjective": "Explicar como rodas de reação usam conservação para controle de atitude.",
                                  "commonMistakes": [
                                    "Ignorar momento de inércia do veículo, confundir com thrust químico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Verificar Aplicações Práticas",
                                  "subSteps": [
                                    "Monte simulação simples: roda com I=0.1 kg m², acelere a 100 rad/s.",
                                    "Calcule rotação do veículo assumindo I_veículo=1000 kg m².",
                                    "Analise desaturação: usar propulsores para zerar rodas.",
                                    "Discuta limitações: gimbal lock em 3 eixos, eficiência energética.",
                                    "Compare com giroscópios de controle (CMG) para grandes veículos."
                                  ],
                                  "verification": "Execute simulação e confirme que atitude muda sem massa expelida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib para simulação, ou app online de dinâmica espacial"
                                  ],
                                  "tips": "Comece com 1D (um eixo) antes de 3D.",
                                  "learningObjective": "Simular e validar conservação em contexto de controle de atitude.",
                                  "commonMistakes": [
                                    "Negligir acoplamento entre eixos, superestimar torque disponível"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um satélite como o Hubble, acelere uma roda de reação em torno do eixo Z a 5000 rpm: o momento angular da roda aumenta em +L_z, fazendo o satélite girar -L_z para manter L_total=0, ajustando a orientação para apontar telescópio sem combustível.",
                              "finalVerifications": [
                                "Explicar verbalmente a conservação de L em rodas de reação.",
                                "Resolver cálculo: dada Δω_roda, encontre Δω_veículo.",
                                "Desenhar diagrama vetorial correto de L_roda e L_veículo.",
                                "Identificar quando rodas saturam e solução.",
                                "Diferenciar de métodos que expelam massa."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual da lei de conservação (80%+ correto).",
                                "Cálculos numéricos exatos com unidades.",
                                "Uso correto de vetores e direções.",
                                "Explicação clara de aplicação em espaço vs Terra.",
                                "Identificação de limitações reais.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores, cálculo diferencial (torque = dL/dt).",
                                "Engenharia Mecânica: Dinâmica rotacional, controle PID.",
                                "Física Geral: Conservação de energia/momento em sistemas.",
                                "Informática: Simulações numéricas em Python/MATLAB."
                              ],
                              "realWorldApplication": "Rodas de reação são usadas em satélites (ex: GPS, comunicações), Estação Espacial Internacional (ISS) e sondas como Voyager para controle preciso de orientação, economizando propelente para manobras orbitais críticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Descrever aceleração e desaceleração das rodas",
                            "description": "Detalhar o processo de aceleração das rodas para gerar torque no veículo e desaceleração para desaturação, incluindo limites de velocidade angular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios básicos de aceleração das rodas de reação",
                                  "subSteps": [
                                    "Estudar o conceito de momento de inércia das rodas e sua relação com o torque.",
                                    "Revisar a lei de conservação do momento angular no sistema veículo + rodas.",
                                    "Identificar como a aceleração angular da roda transfere momento para o veículo.",
                                    "Analisar equações básicas: τ = I * α, onde τ é torque, I é momento de inércia e α é aceleração angular.",
                                    "Explorar o papel do motor da roda em gerar aceleração controlada."
                                  ],
                                  "verification": "Desenhar um diagrama simples mostrando a direção da aceleração e o torque resultante no veículo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de dinâmica orbital",
                                    "Vídeos sobre rodas de reação (YouTube/Khan Academy)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Visualize a roda como um flywheel: acelere-a para 'roubar' momento angular do veículo.",
                                  "learningObjective": "Entender como a aceleração da roda afeta o momento angular do sistema.",
                                  "commonMistakes": [
                                    "Confundir aceleração da roda com aceleração linear",
                                    "Ignorar a direção do torque"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detalhar a geração de torque no veículo via aceleração das rodas",
                                  "subSteps": [
                                    "Calcular torque gerado: torque_veículo = -torque_roda.",
                                    "Simular cenários onde aceleração de rodas em direções opostas gera torque puro.",
                                    "Explicar o controle diferencial de múltiplas rodas para atitudes em 3 eixos.",
                                    "Discutir rampas de aceleração para evitar overshoot.",
                                    "Verificar unidades: rad/s² para aceleração angular."
                                  ],
                                  "verification": "Resolver um problema numérico simples: dada I_roda e α, calcular torque no veículo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou software como MATLAB/Python",
                                    "Folhas de exercícios de dinâmica",
                                    "Simulador online de rodas de reação"
                                  ],
                                  "tips": "Use vetores para representar momentos angulares e suas direções.",
                                  "learningObjective": "Dominar a relação quantitativa entre aceleração da roda e torque no veículo.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo na conservação de momento",
                                    "Não considerar configuração de rodas (skew ou orthogonal)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o processo de desaceleração das rodas para desaturação",
                                  "subSteps": [
                                    "Definir desaturação como reversão da velocidade acumulada nas rodas.",
                                    "Descrever uso de torques externos (magnetotorquers ou propulsores) para desacelerar rodas sem alterar atitude.",
                                    "Detalhar o processo: aplicar torque oposto ao acumulado para reduzir ω_roda.",
                                    "Analisar ciclos de operação: aceleração → atitude → desaturação.",
                                    "Calcular tempo de desaturação baseado em torque disponível."
                                  ],
                                  "verification": "Escrever uma sequência passo a passo de um ciclo de desaturação em pseudocódigo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Artigos da NASA sobre controle de atitude",
                                    "Software de simulação como GMAT ou STK"
                                  ],
                                  "tips": "Pense na desaturação como 'resetar' o flywheel usando forças externas.",
                                  "learningObjective": "Compreender como evitar saturação das rodas mantendo a atitude.",
                                  "commonMistakes": [
                                    "Confundir desaturação com frenagem interna",
                                    "Ignorar distúrbios durante desaturação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar limites de velocidade angular e gerenciamento operacional",
                                  "subSteps": [
                                    "Identificar limites típicos: ±3000 a ±6000 rpm para rodas de reação.",
                                    "Explicar detecção de saturação: monitoramento de ω_roda próxima ao limite.",
                                    "Discutir estratégias de gerenciamento: rotação de rodas, modos de baixa velocidade.",
                                    "Calcular capacidade de momento: h_max = I * ω_max.",
                                    "Planejar operações para evitar limites em missões longas.",
                                    "Revisar falhas comuns como vibrações em altas velocidades."
                                  ],
                                  "verification": "Listar 3 estratégias para gerenciar limites em um cenário de missão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Especificações de rodas de reação (ex: Honeywell HR14)",
                                    "Gráficos de capacidade de rodas"
                                  ],
                                  "tips": "Monitore ω continuamente no software de simulação para prever saturação.",
                                  "learningObjective": "Gerenciar limites operacionais para sustentabilidade do sistema.",
                                  "commonMistakes": [
                                    "Subestimar ramp-up time para altas velocidades",
                                    "Não planejar redundância em múltiplas rodas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de satélite CubeSat, acelere as rodas Y e Z para rotacionar 5 graus em roll, gerando torque de 0.01 Nm/s. Monitore ω até 2000 rpm, então use magnetotorquers para desaturar reduzindo ω a zero sem alterar a atitude, respeitando limite de 5000 rpm.",
                              "finalVerifications": [
                                "Explicar verbalmente o ciclo completo de aceleração-desaceleração.",
                                "Desenhar diagrama vetorial de momentos angulares.",
                                "Resolver cálculo de torque e tempo de saturação.",
                                "Simular um ciclo em software e mostrar resultados.",
                                "Identificar 2 riscos operacionais e mitigações.",
                                "Comparar com princípios de CMGs (Control Moment Gyros)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: uso correto de conservação de momento angular (90%).",
                                "Detalhe quantitativo: cálculos com unidades corretas (85%).",
                                "Completude: cobertura de aceleração, torque, desaturação e limites (100%).",
                                "Clareza na explicação: diagramas legíveis e lógicos.",
                                "Aplicação prática: exemplo realista e viável.",
                                "Originalidade: conexões além do básico."
                              ],
                              "crossCurricularConnections": [
                                "Física: Conservação de momento angular e dinâmica rotacional.",
                                "Matemática: Equações diferenciais e vetores (álgebra linear).",
                                "Engenharia Elétrica: Controle de motores brushless DC.",
                                "Ciência da Computação: Algoritmos de controle PID para rodas.",
                                "Astronomia: Manobras de pointing em telescópios espaciais."
                              ],
                              "realWorldApplication": "Nas estações espaciais como a ISS ou satélites como o Hubble, rodas de reação controlam atitude precisa para experimentos científicos e comunicações, com desaturação via magnetotorquers para missões de anos, evitando uso excessivo de combustível."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Identificar vantagens para controle fino",
                            "description": "Comparar as rodas de reação com outros atuadores, destacando sua precisão e ausência de perturbações químicas para manobras de atitude precisas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar atuadores comuns de controle de atitude",
                                  "subSteps": [
                                    "Liste os principais atuadores de atitude em veículos espaciais: rodas de reação, propulsores químicos, magnetotorquers e thrusters de gás frio.",
                                    "Descreva o princípio de funcionamento de cada um, focando em como geram torque.",
                                    "Identifique limitações iniciais, como consumo de propelente ou dependência de campos magnéticos.",
                                    "Crie um quadro comparativo básico com colunas para tipo, mecanismo e aplicações típicas.",
                                    "Pesquise exemplos reais de uso em missões espaciais."
                                  ],
                                  "verification": "Quadro comparativo completo preenchido com pelo menos 4 atuadores e descrições precisas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre controle de atitude, diagramas de atuadores (NASA ou textbooks como 'Spacecraft Dynamics and Control' de Sidi), vídeos do YouTube sobre sistemas de atitude.",
                                  "tips": "Use tabelas no Google Docs ou Excel para organizar visualmente as informações.",
                                  "learningObjective": "Compreender os fundamentos e limitações de atuadores de atitude para estabelecer base de comparação.",
                                  "commonMistakes": "Confundir rodas de reação com flywheels de energia; ignorar atuadores passivos como gimbal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar características de precisão das rodas de reação",
                                  "subSteps": [
                                    "Explique como as rodas de reação armazenam e controlam momento angular via rotação de massa.",
                                    "Compare a resolução de torque das rodas (tipicamente micronewton-metro) com propulsores (newton).",
                                    "Discuta o controle contínuo e bidirecional sem impulsos discretos.",
                                    "Calcule um exemplo simples de mudança de velocidade angular para torque gerado.",
                                    "Registre métricas quantitativas de precisão de fontes confiáveis."
                                  ],
                                  "verification": "Relatório curto com cálculos e comparações numéricas de precisão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora ou software como MATLAB/Python para simulações básicas, fichas técnicas de rodas de reação (ex: Reaction Wheel datasheets from Honeybee Robotics).",
                                  "tips": "Comece com equações básicas de torque: τ = I * α, onde I é momento de inércia.",
                                  "learningObjective": "Dominar as métricas de precisão das rodas de reação em comparação com outros atuadores.",
                                  "commonMistakes": "Superestimar precisão de thrusters; esquecer que rodas saturam em alta velocidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Destacar ausência de perturbações químicas e impactos",
                                  "subSteps": [
                                    "Descreva perturbações químicas: exaustão de propelentes criando torque residual e contaminação.",
                                    "Compare com rodas de reação: sem ejeção de massa, zero perturbação química ou momentum linear.",
                                    "Analise cenários onde perturbações químicas falham em controle fino, como apontamento de telescópios.",
                                    "Liste vantagens em ambientes sensíveis, como formação de satélites.",
                                    "Crie um fluxograma mostrando ciclo de operação sem perturbações."
                                  ],
                                  "verification": "Fluxograma e lista de 5 cenários onde perturbações químicas são problemáticas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigos da AIAA sobre controle de atitude, simulações STK (Systems Tool Kit) se disponível.",
                                  "tips": "Pense em conservação de momento angular: rodas mantêm sistema fechado.",
                                  "learningObjective": "Identificar e quantificar a ausência de perturbações como vantagem chave para manobras precisas.",
                                  "commonMistakes": "Ignorar perturbações secundárias como vibrações mecânicas nas rodas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar vantagens para controle fino de atitude",
                                  "subSteps": [
                                    "Compile uma lista priorizada de vantagens: precisão, ausência de perturbações, eficiência energética longa.",
                                    "Compare holisticamente em uma matriz de decisão para manobras finas vs. grossas.",
                                    "Discuta trade-offs, como necessidade de desaturação ocasional.",
                                    "Aplique a um caso de estudo: manutenção de atitude em satélite de observação.",
                                    "Escreva um parágrafo resumindo as vantagens principais."
                                  ],
                                  "verification": "Matriz de decisão e parágrafo de síntese submetidos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Case studies de missões como GOES ou Hubble Space Telescope.",
                                  "tips": "Use escalas qualitativas (alta/média/baixa) na matriz para clareza.",
                                  "learningObjective": "Integrar comparações para justificar rodas de reação em controle fino.",
                                  "commonMistakes": "Generalizar vantagens sem contexto específico de atitude fina."
                                }
                              ],
                              "practicalExample": "Em um satélite de imageamento terrestre como o Landsat, as rodas de reação ajustam a atitude em arcos-segundos para alinhar a câmera sem borrões causados por impulsos químicos, permitindo imagens nítidas de 30m de resolução.",
                              "finalVerifications": [
                                "Pode listar e explicar 4 vantagens das rodas de reação sobre atuadores químicos.",
                                "Consegue comparar torque mínimo: rodas (<10^-6 Nm) vs. thrusters (10^-3 Nm).",
                                "Identifica cenários onde perturbações químicas invalidam controle fino.",
                                "Cria tabela comparativa precisa sem erros factuais.",
                                "Explica conservação de momento angular em rodas vs. ejeção de massa.",
                                "Aplica vantagens a um exemplo real de missão espacial."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de mecanismos (90% acurácia em comparações).",
                                "Profundidade quantitativa: inclusão de valores numéricos de torque/precisão.",
                                "Clareza na explicação de perturbações químicas vs. mecânicas.",
                                "Completude da matriz comparativa com trade-offs.",
                                "Capacidade de síntese em parágrafo conciso e convincente.",
                                "Uso correto de terminologia aeroespacial (ex: slew maneuvers, pointing accuracy)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Conservação de momento angular e dinâmica rotacional.",
                                "Engenharia de Controle: Sistemas de feedback e atuadores em malhas fechadas.",
                                "Matemática: Vetores de Euler e cinemática de atitude (quaternions).",
                                "Ciência de Materiais: Rolamentos e motores brushless em vácuo.",
                                "Informática: Simulações em Python/MATLAB para modelagem de torque."
                              ],
                              "realWorldApplication": "Nas estações espaciais como a ISS ou telescópios como o James Webb, rodas de reação mantêm orientação precisa para experimentos científicos e comunicações, evitando deriva causada por propulsores e economizando propelente para manobras orbitais críticas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.1.2",
                        "name": "Tipos e Configurações de Rodas de Reação",
                        "description": "Classificação dos diferentes tipos de rodas de reação, incluindo rodas comuns e rodas de reação com gimbal (CMG), e suas configurações em clusters.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.2.1",
                            "name": "Diferenciar rodas de momento e rodas de reação",
                            "description": "Explicar a diferença entre rodas de momento (para estabilização) e rodas de reação (para controle dinâmico), com exemplos de aplicações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Momento Angular e Controle de Atitude",
                                  "subSteps": [
                                    "Estudar a conservação de momento angular em sistemas isolados como espaçonaves.",
                                    "Explicar o conceito de torque e sua relação com a variação de momento angular.",
                                    "Descrever os principais métodos de controle de atitude (RW, CMG, etc.).",
                                    "Visualizar o vetor de momento angular e sua direção.",
                                    "Analisar equações básicas: H = Iω."
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras explicando conservação de momento e controle de atitude.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Dinâmica de Espaçonaves (ex: Sidi)",
                                    "Vídeos Khan Academy sobre momento angular",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias como um patinador girando para demonstrar conservação.",
                                  "learningObjective": "Compreender os princípios físicos que diferenciam os tipos de rodas.",
                                  "commonMistakes": [
                                    "Confundir momento angular com momento linear",
                                    "Ignorar que espaçonaves são sistemas isolados sem torque externo significativo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Rodas de Reação (Reaction Wheels)",
                                  "subSteps": [
                                    "Definir rodas de reação: atuadores que armazenam momento para controle dinâmico.",
                                    "Explicar operação: aceleração da roda gera torque oposto na espaçonave.",
                                    "Discutir configurações (tipicamente 4 rodas em tetraedro para redundância).",
                                    "Estudar saturação: limite de velocidade da roda requer desaturação.",
                                    "Simular mudança de atitude usando RW."
                                  ],
                                  "verification": "Desenhar diagrama de uma RW controlando rotação em um eixo e rotulá-lo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Diagramas de RW online",
                                    "Software gratuito como FreeFlyer ou Python com poliastro",
                                    "Folha de cálculo para simulação simples"
                                  ],
                                  "tips": "Pense em RW como 'motores elétricos com flywheels' para torque preciso.",
                                  "learningObjective": "Dominar o funcionamento e limitações das rodas de reação.",
                                  "commonMistakes": [
                                    "Achar que RW mantêm momento bias",
                                    "Esquecer necessidade de desaturação externa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Rodas de Momento (Momentum Wheels)",
                                  "subSteps": [
                                    "Definir rodas de momento: usadas para estabilização com momento bias constante.",
                                    "Explicar operação: roda gira a velocidade constante para contrabalançar distúrbios.",
                                    "Comparar com single-axis: uma roda por eixo para momentum storage.",
                                    "Discutir aplicações em satélites geoestacionários.",
                                    "Analisar transferência de momento para roda durante distúrbios."
                                  ],
                                  "verification": "Listar 3 diferenças operacionais entre MW e RW em uma tabela.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigos NASA sobre AACS",
                                    "Vídeos de satélites com MW",
                                    "Planilha Excel para modelagem"
                                  ],
                                  "tips": "MW são como 'piões internos' mantendo a espaçonave apontada passivamente.",
                                  "learningObjective": "Compreender o papel estabilizador das rodas de momento.",
                                  "commonMistakes": [
                                    "Confundir MW com RW dinâmicas",
                                    "Ignorar uso de bias momentum para estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e Aplicar com Exemplos",
                                  "subSteps": [
                                    "Criar tabela comparativa: função, operação, limitações, aplicações.",
                                    "Dar exemplos: RW em CubeSats para manobras, MW em GEO para pointing.",
                                    "Simular cenários: manobra rápida (RW) vs. rejeição de distúrbios (MW).",
                                    "Discutir trade-offs: custo, precisão, complexidade.",
                                    "Testar conhecimento respondendo perguntas de diferenciação."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que uma missão usaria RW vs. MW.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Tabela comparativa em branco",
                                    "Simulador online de atitude (ex: JSAT)",
                                    "Casos de estudo de missões reais"
                                  ],
                                  "tips": "Use mnemônicos: 'Reação' para dinâmico, 'Momento' para estático/bias.",
                                  "learningObjective": "Aplicar diferenças em contextos reais de aeroespacial.",
                                  "commonMistakes": [
                                    "Generalizar todos como 'RW'",
                                    "Não considerar requisitos da missão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um simulador como o NASA's GMAT, configure uma espaçonave com 4 RW para uma manobra de 90° (controle dinâmico) e adicione uma MW para rejeitar distúrbios solares, observando saturação na RW vs. bias constante na MW.",
                              "finalVerifications": [
                                "Explicar a diferença principal em função (estabilização vs. controle dinâmico).",
                                "Identificar exemplo real de cada (ex: Hubble usa RW, Intelsat usa MW).",
                                "Desenhar diagrama comparativo de operação.",
                                "Prever comportamento em saturação para cada tipo.",
                                "Listar 2 vantagens e 2 desvantagens de cada.",
                                "Simular simples mudança de atitude com cada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e princípios físicos (30%).",
                                "Clareza na tabela comparativa e diagramas (25%).",
                                "Relevância e correção de exemplos reais (20%).",
                                "Compreensão de limitações e trade-offs (15%).",
                                "Capacidade de aplicação em cenários simulados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica rotacional e conservação de momento.",
                                "Matemática: Álgebra linear para vetores de momento e cinemática.",
                                "Engenharia de Controle: Feedback loops e atuadores.",
                                "Informática: Simulações numéricas em Python/MATLAB.",
                                "Ciência de Materiais: Flywheels de alta inércia."
                              ],
                              "realWorldApplication": "Na Estação Espacial Internacional (ISS), rodas de reação (CMG derivadas) controlam manobras dinâmicas, enquanto satélites geoestacionários como os da série Intelsat usam rodas de momento para manter pointing preciso contra gradiente gravitacional e pressão solar."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2.2",
                            "name": "Analisar rodas de reação com gimbal (CMG)",
                            "description": "Descrever o funcionamento das Control Moment Gyros (CMG) com gimbal, incluindo torque de guinada elevado e singularidades no envelope de torque.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Princípios Básicos das Control Moment Gyros (CMGs)",
                                  "subSteps": [
                                    "Estude o conceito de momento angular e conservação em sistemas rotacionais.",
                                    "Compare rodas de reação (RW) com CMGs: RW geram torque por aceleração angular, CMGs por mudança de direção do vetor de momento angular.",
                                    "Revise a configuração básica de um CMG: roda de alta velocidade com eixos de giro e gimbal.",
                                    "Analise a equação fundamental do torque gerado: τ = Ω × h, onde Ω é taxa de gimbal e h é momento angular da roda.",
                                    "Desenhe diagramas vetoriais ilustrando o torque perpendicular ao momento angular."
                                  ],
                                  "verification": "Desenhe e explique um diagrama vetorial de torque de um CMG simples, identificando componentes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de dinâmica de spacecraft (ex: Sidi 'Spacecraft Dynamics and Control')",
                                    "Vídeos tutoriais sobre momentum wheels",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use simulações visuais online como PhET para visualizar vetores rotacionais.",
                                  "learningObjective": "Compreender como CMGs geram torque via mudança de direção do momento angular, diferentemente de RWs.",
                                  "commonMistakes": [
                                    "Confundir torque com força angular direta",
                                    "Ignorar a magnitude constante do momento angular da roda"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Papel do Gimbal em CMGs",
                                  "subSteps": [
                                    "Defina gimbal: mecanismo que permite rotação controlada do eixo da roda em um ou mais ângulos.",
                                    "Estude configurações de gimbal: single-gimbal (SGCMG) vs double-gimbal (DGCMG).",
                                    "Simule o movimento do gimbal alterando a orientação do vetor h.",
                                    "Calcule torque para diferentes taxas de gimbal usando software como MATLAB.",
                                    "Discuta limitações: gimbal angles limitados para evitar colisões."
                                  ],
                                  "verification": "Implemente uma simulação simples em Python/MATLAB mostrando mudança de torque com gimbal rate.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Tutoriais de simulação de atitude (NASA resources)",
                                    "Artigos sobre SGCMG"
                                  ],
                                  "tips": "Comece com ângulos pequenos de gimbal para visualizar efeitos lineares.",
                                  "learningObjective": "Dominar como o gimbal permite torque em múltiplas direções sem alterar a velocidade da roda.",
                                  "commonMistakes": [
                                    "Assumir gimbal ilimitado",
                                    "Confundir gimbal rate com roda spin rate"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Torque de Guinada Elevado em CMGs",
                                  "subSteps": [
                                    "Identifique torque de guinada (yaw torque) em configurações pyramidais de CMGs.",
                                    "Calcule o envelope de torque máximo para uma cluster de 4 SGCMGs.",
                                    "Compare com RW: CMGs fornecem torque orders de magnitude maior para yaw.",
                                    "Simule cenários onde yaw torque é crítico, como reorientação rápida.",
                                    "Otimize ângulos de gimbal para maximizar yaw torque."
                                  ],
                                  "verification": "Gere gráfico do envelope de torque mostrando pico em yaw para uma configuração padrão.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software de simulação (ex: FreeFlyer ou GMAT)",
                                    "Papéis acadêmicos sobre CMG clusters (ex: IEEE Aerospace)",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use configurações simétricas pyramidais para simplicidade inicial.",
                                  "learningObjective": "Explicar por que CMGs excel em torque de guinada elevado comparado a RW.",
                                  "commonMistakes": [
                                    "Negligenciar interações entre múltiplos CMGs",
                                    "Confundir torque local com global do cluster"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Singularidades no Envelope de Torque",
                                  "subSteps": [
                                    "Defina singularidade: ponto onde o Jacobiano do cluster CMG perde rank, impedindo torque desejado.",
                                    "Classifique tipos: singularidades internas/externas em SGCMGs.",
                                    "Analise envelope de torque: regiões acessíveis e 'dead zones' perto de singularidades.",
                                    "Desenvolva estratégias de evasão: steering laws como Singularity Robust Inverse.",
                                    "Simule uma manobra passando por singularidade e recovery."
                                  ],
                                  "verification": "Identifique e plote singularidades em um envelope de torque 3D para 4 CMGs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código MATLAB de CMG steering (disponível em repositórios GitHub)",
                                    "Documentação ISS CMG (NASA technical reports)",
                                    "Ferramentas de plotagem 3D"
                                  ],
                                  "tips": "Visualize em 3D para entender geometria das singularidades.",
                                  "learningObjective": "Compreender e mitigar singularidades que limitam o desempenho de CMGs.",
                                  "commonMistakes": [
                                    "Ignorar pseudoinversas para steering",
                                    "Confundir singularidades com saturação de gimbal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de controle de atitude da ISS, configure 4 SGCMGs em arranjo piramidal. Execute uma manobra de reorientação de 90 graus em yaw, otimizando gimbal rates para torque elevado enquanto evade singularidades usando uma steering law robusta. Meça tempo de manobra e consumo de momentum.",
                              "finalVerifications": [
                                "Explicar verbalmente o mecanismo de torque via gimbal com diagramas vetoriais.",
                                "Simular e plotar envelope de torque de um cluster CMG, destacando yaw peak.",
                                "Identificar pelo menos 2 singularidades em uma configuração dada e propor evasão.",
                                "Comparar performance CMG vs RW em uma manobra de guinada rápida.",
                                "Implementar steering law básica em código e demonstrar evasão de singularidade.",
                                "Descrever aplicação real em veículos espaciais como ISS ou satélites ágil."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de equações de torque (τ = Ω × h).",
                                "Correta identificação e visualização de singularidades no envelope.",
                                "Demonstração de torque de guinada elevado via simulação quantitativa.",
                                "Explicação clara de diferenças entre CMG com gimbal e RW.",
                                "Criatividade em estratégias de evasão de singularidades.",
                                "Uso apropriado de ferramentas de simulação e interpretação de resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (Jacobianos, pseudoinversas) e geometria vetorial.",
                                "Física: Conservação de momento angular e dinâmica rotacional.",
                                "Programação: Simulações numéricas em Python/MATLAB para controle.",
                                "Engenharia de Controle: Steering laws e otimização em tempo real.",
                                "Informática: Visualização 3D e análise de dados de simulação."
                              ],
                              "realWorldApplication": "CMGs com gimbal são usados na Estação Espacial Internacional (ISS) para controle de atitude preciso e eficiente, permitindo reorientações rápidas com torque de guinada elevado sem alto consumo de energia, superando limitações de rodas de reação em missões de longa duração."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2.3",
                            "name": "Configurar clusters de rodas",
                            "description": "Estudar configurações pyramidais ou em cruz de 4 rodas para controle triaxial, calculando capacidades de momento e redundância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Rodas de Reação e Controle Triaxial",
                                  "subSteps": [
                                    "Estude o princípio de operação das rodas de reação (momentum exchange devices).",
                                    "Revise vetores de momento angular e como clusters fornecem torque em 3 eixos.",
                                    "Identifique requisitos para controle triaxial completo sem singularidades.",
                                    "Analise limitações de configurações de roda única versus clusters.",
                                    "Explore diagramas de orientação de eixos das rodas."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes do controle de atitude usando rodas de reação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de controle de atitude (ex: Sidi 'Spacecraft Dynamics and Control'),",
                                    "Vídeos tutoriais sobre rodas de reação (NASA ou YouTube acadêmico)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com analogias terrestres como giroscópios para visualizar momentum.",
                                  "learningObjective": "Compreender o papel das rodas de reação no controle triaxial de atitude.",
                                  "commonMistakes": [
                                    "Confundir rodas de reação com propulsores; ignorar acoplamento de eixos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Configurações Pyramidais e em Cruz de 4 Rodas",
                                  "subSteps": [
                                    "Descreva a configuração pyramidal (tetraédrica): ângulos de inclinação ~54.7° para eixos otimizados.",
                                    "Detalhe configuração em cruz (+ ou X): eixos ortogonais ou skew para cobertura triaxial.",
                                    "Compare singularidades e envelopes de torque para cada configuração usando gráficos.",
                                    "Calcule matrizes de alocação de torque para ambas usando álgebra linear básica.",
                                    "Simule orientações iniciais em software como MATLAB."
                                  ],
                                  "verification": "Desenhe e rotule diagramas 3D de ambas configurações com vetores de eixo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink ou Python (NumPy/SciPy)",
                                    "Artigos IEEE sobre RWAs (Reaction Wheel Assemblies)",
                                    "Templates de matrizes de configuração"
                                  ],
                                  "tips": "Use visualizações 3D gratuitas como GeoGebra para entender geometria.",
                                  "learningObjective": "Diferenciar e modelar geometricamente configurações pyramidais e em cruz.",
                                  "commonMistakes": [
                                    "Assumir ortogonalidade perfeita na cruz; ignorar assimetrias pyramidais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Capacidades de Momento dos Clusters",
                                  "subSteps": [
                                    "Defina capacidade de momento unitária (h_max) para cada roda.",
                                    "Construa a matriz de momento inercial A (4x3) para a configuração escolhida.",
                                    "Calcule envelope de torque máximo: max |A * u| onde |u| <= h_max.",
                                    "Avalie capacidade escalar: sqrt(det(A^T A)) ou norma de Moore-Penrose.",
                                    "Compare capacidades para pyramidal vs. cruz sob cargas nominais."
                                  ],
                                  "verification": "Implemente script que outputa capacidades numéricas para h_max=0.1 Nm*s.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB/Python com bibliotecas lineares",
                                    "Planilhas Excel para prototipagem rápida",
                                    "Referências: Wie 'Space Vehicle Dynamics and Control'"
                                  ],
                                  "tips": "Normalize unidades consistentemente (Nm*s para momentum angular).",
                                  "learningObjective": "Quantificar capacidades de torque triaxial para clusters de 4 rodas.",
                                  "commonMistakes": [
                                    "Erro em transposição de matriz; esquecer normalização de vetores unitários."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Redundância e Otimizar Configurações",
                                  "subSteps": [
                                    "Calcule graus de redundância: falha de uma roda mantém rank(A)=3?",
                                    "Simule falhas unitárias e verifique singularidades residuais.",
                                    "Otimize ângulos para maximizar redundância e capacidade mínima.",
                                    "Inclua considerações de massa, potência e vibrações.",
                                    "Gere relatório comparativo de ambas configurações."
                                  ],
                                  "verification": "Demonstre via simulação que cluster mantém controle após falha simulada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador de falhas em Python/MATLAB",
                                    "Ferramentas de otimização (fmincon ou scipy.optimize)",
                                    "Dados de RWAs reais (ex: CubeSat wheels)"
                                  ],
                                  "tips": "Teste múltiplos cenários de falha para robustez.",
                                  "learningObjective": "Avaliar e otimizar redundância em clusters de rodas.",
                                  "commonMistakes": [
                                    "Subestimar singularidades pós-falha; ignorar custos de redundância."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simular e Validar Configuração Completa",
                                  "subSteps": [
                                    "Integre modelo em simulador de atitude (ex: simples 6-DOF).",
                                    "Execute manobras triaxiais e monitore saturação/desaturação.",
                                    "Compare desempenho pyramidal vs. cruz em métricas (tempo de acerto, uso de momentum).",
                                    "Valide contra dados reais de missões (ex: ISS RWAs).",
                                    "Documente trade-offs finais."
                                  ],
                                  "verification": "Produza gráficos de simulação mostrando controle estável.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "41 North 'FreeFlyer' ou Orekit (Python)",
                                    "Dados de telemetria pública NASA",
                                    "Jupyter Notebook para relatórios"
                                  ],
                                  "tips": "Use controladores PD simples para focar em RWAs.",
                                  "learningObjective": "Validar configuração via simulação dinâmica.",
                                  "commonMistakes": [
                                    "Modelo dinâmico impreciso; escalas de tempo erradas."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um CubeSat de 10kg com requisito de slew de 5°/s em 3 eixos, configure um cluster pyramidal com 4 RWAs de 0.01 Nm*s: calcule A, verifique torque max ~0.02 Nm, e simule redundância falhando uma roda no eixo X.",
                              "finalVerifications": [
                                "Calcule corretamente matriz A para pyramidal e cruz.",
                                "Identifique capacidades de momento com erro <5%.",
                                "Simule falha e confirme controle triaxial mantido.",
                                "Compare trade-offs em relatório escrito.",
                                "Explique singularidades em ambas configurações.",
                                "Gere gráficos de envelope de torque."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de matriz e capacidades (90%+).",
                                "Compreensão conceitual demonstrada em diagramas e explicações.",
                                "Robustez da análise de redundância (todos cenários cobertos).",
                                "Qualidade da simulação e visualizações.",
                                "Integração de trade-offs reais (massa, custo).",
                                "Clareza e completude do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes pseudoinversas, determinantes).",
                                "Física: Dinâmica rotacional e conservação de momento angular.",
                                "Engenharia de Software: Simulação numérica (MATLAB/Python).",
                                "Sistemas: Teoria de controle e tolerância a falhas.",
                                "Design Mecânico: Otimização geométrica e vibrações."
                              ],
                              "realWorldApplication": "Configurações de RWAs em satélites como Starlink (cruz para agilidade) ou Hubble (pyramidal para redundância), garantindo pointing preciso para comunicações, observação terrestre e manobras de evasão em órbita."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.1.3",
                        "name": "Modelagem e Simulação de Rodas de Reação",
                        "description": "Desenvolvimento de modelos matemáticos e simulações para dinâmica e controle usando rodas de reação em veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.3.1",
                            "name": "Derivar equações de dinâmica",
                            "description": "Formular as equações de Euler modificadas incorporando o momento das rodas de reação: J ω̇ + Ω × (J ω + h) = τ_ext, onde h é o momento das rodas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as equações de Euler clássicas para corpo rígido",
                                  "subSteps": [
                                    "Lembre-se do teorema do momento angular: dH/dt |_inercial = τ_ext.",
                                    "No referencial do corpo: Ḣ_b + Ω × H_b = τ_ext, onde H_b = J ω.",
                                    "Expanda para componentes principais assumindo J diagonal: J1 ω1̇ - (J2 - J3) ω2 ω3 = τ1, e cíclico.",
                                    "Identifique limitações para sistemas com componentes internos como rodas de reação.",
                                    "Anote as equações em um caderno ou software simbólico."
                                  ],
                                  "verification": "Escreva corretamente as três equações de Euler escalares e explique sua origem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de dinâmica de spacecraft (ex: Sidi 'Spacecraft Dynamics and Control')",
                                    "Caderno ou MATLAB Symbolic Toolbox"
                                  ],
                                  "tips": "Use notação vetorial consistente (ω para velocidade angular, Ω também é ω geralmente).",
                                  "learningObjective": "Compreender a dinâmica de atitude básica de um corpo rígido sem atuadores internos.",
                                  "commonMistakes": [
                                    "Confundir referencial inercial com body frame",
                                    "Esquecer o termo de cross-product Ω × H",
                                    "Assumir J isomórfico sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o momento angular das rodas de reação (h)",
                                  "subSteps": [
                                    "Defina h como o vetor de momento angular total das rodas no body frame.",
                                    "Assuma rodas alinhadas com eixos principais: h = [h_x, h_y, h_z]^T.",
                                    "Note que h é controlável via torque nas rodas, mas para derivação dinâmica, trate como conhecido.",
                                    "Discuta hipóteses: rodas com momento de inércia pequeno comparado ao corpo, sem fricção significativa.",
                                    "Calcule um exemplo numérico simples para h baseado em velocidades de rotação das rodas."
                                  ],
                                  "verification": "Descreva h matematicamente e justifique por que ele modifica H total.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referências sobre reaction wheels (NASA docs ou papers)",
                                    "Calculadora ou Python com NumPy"
                                  ],
                                  "tips": "Lembre-se que h é aditivo ao momento do corpo, mas sua derivada ḣ é o torque de controle.",
                                  "learningObjective": "Modelar o contributo das rodas de reação ao momento angular total.",
                                  "commonMistakes": [
                                    "Tratar h como constante sem contexto",
                                    "Ignorar alinhamento das rodas com body axes",
                                    "Confundir h com torque τ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o momento angular total H = J ω + h",
                                  "subSteps": [
                                    "Expresse H_b = J ω + h no body frame.",
                                    "Verifique que J é o tensor de inércia do corpo excluindo rodas (aproximação comum).",
                                    "Discuta rotação relativa: rodas giram relativo ao corpo, mas h é medido no body frame.",
                                    "Derive a taxa de mudança inercial usando teorema de transporte.",
                                    "Escreva dH/dt |_inercial = dH/dt |_body + Ω × H_b = τ_ext."
                                  ],
                                  "verification": "Mostre H total corretamente e expresse o teorema de transporte.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Notas da Step 1"
                                  ],
                                  "tips": "Use subscritos _b para clareza no body frame.",
                                  "learningObjective": "Integrar o momento das rodas ao estado dinâmico total do sistema.",
                                  "commonMistakes": [
                                    "Incluir J das rodas em J do corpo",
                                    "Esquecer que h é vetorial",
                                    "Negligenciar o frame de referência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar as equações de Euler modificadas",
                                  "subSteps": [
                                    "Do teorema: Ḣ_b + Ω × H_b = τ_ext.",
                                    "Substitua H_b = J ω + h, então J ω̇ + ḣ + Ω × (J ω + h) = τ_ext.",
                                    "Para esta formulação, assuma ḣ = 0 ou separado (controle), obtendo J ω̇ + Ω × (J ω + h) = τ_ext.",
                                    "Expanda em componentes se J diagonal.",
                                    "Compare com equação clássica e destaque modificação."
                                  ],
                                  "verification": "Derive exatamente a equação: J ω̇ + Ω × (J ω + h) = τ_ext.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "SymPy para manipulação simbólica",
                                    "Exemplos de papers sobre attitude dynamics"
                                  ],
                                  "tips": "Ω é ω, a velocidade angular do body; use isso consistentemente.",
                                  "learningObjective": "Obter a equação dinâmica final incorporando rodas de reação.",
                                  "commonMistakes": [
                                    "Omitir ḣ incorretamente",
                                    "Erro no cross-product",
                                    "Confundir τ_ext com torque interno"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e simplificar a equação derivada",
                                  "subSteps": [
                                    "Substitua h=0 para recuperar Euler clássica.",
                                    "Considere caso especial: rodas em um eixo só.",
                                    "Discuta linearização para pequenos ângulos.",
                                    "Implemente numericamente em código para validar.",
                                    "Documente hipóteses e limitações (ex: rodas ideais)."
                                  ],
                                  "verification": "Valide com caso conhecido e numérico simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (SciPy)",
                                    "Código de simulação básica"
                                  ],
                                  "tips": "Teste com valores numéricos para depurar.",
                                  "learningObjective": "Validar a derivação e entender aplicações práticas.",
                                  "commonMistakes": [
                                    "Não testar limites",
                                    "Ignorar não-linearidades",
                                    "Erros de sinal no cross-product"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um satélite cúbico com J = diag(100,100,200) kg m², ω = [0.01, 0.02, 0]^T rad/s, h = [0.5, 0, 0]^T Nms sob τ_ext = [0,0,0.1]^T Nm, compute ω̇ da equação derivada e simule 10s de evolução em Python.",
                              "finalVerifications": [
                                "Equação derivada matches J ω̇ + ω × (J ω + h) = τ_ext.",
                                "Recupera Euler clássica quando h=0.",
                                "Componentes escalares corretas para J diagonal.",
                                "Validação numérica sem divergências.",
                                "Hipóteses explicitadas (ex: rodas alinhadas, J constante)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% match).",
                                "Clareza na explicação de cada termo.",
                                "Correta aplicação do teorema de transporte.",
                                "Identificação de 3+ limitações ou hipóteses.",
                                "Exemplo prático implementável e correto.",
                                "Uso consistente de notação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra vetorial e cálculo em frames rotantes.",
                                "Programação: Simulação numérica com ODE solvers (SciPy/MATLAB).",
                                "Física: Conservação de momento angular em sistemas compostos.",
                                "Engenharia de Controle: Preparação para leis de controle como PD.",
                                "Informática: Manipulação simbólica com SymPy."
                              ],
                              "realWorldApplication": "Usado no controle de atitude de satélites como o CubeSat ou Hubble Space Telescope, onde rodas de reação ajustam orientação sem propelentes, permitindo manobras precisas para imaging ou comunicações."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3.2",
                            "name": "Implementar simulação de controle",
                            "description": "Simular estabilização de atitude e manobras usando rodas de reação em software como MATLAB/Simulink, incluindo leis de controle PD ou LQR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o modelo cinemático e dinâmico do satélite com rodas de reação",
                                  "subSteps": [
                                    "Defina os parâmetros do satélite: momento de inércia (I), vetor de estado de atitude (quaternions ou ângulos de Euler).",
                                    "Modele as rodas de reação: torque gerado (τ = J ω), onde J é o momento de inércia da roda e ω sua velocidade angular.",
                                    "Implemente as equações de Euler rotacional: İ ω + ω × (I ω) = -τ_dist + τ_control, onde τ_control vem das rodas.",
                                    "Configure o ambiente no MATLAB/Simulink: crie um novo modelo Simulink com blocos Integrator para estados.",
                                    "Adicione ruído e distúrbios gravitacionais/magnéticos como entradas realistas."
                                  ],
                                  "verification": "Execute o modelo sem controlador; verifique se o estado inicial propaga corretamente sem divergências numéricas.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "MATLAB/Simulink instalado",
                                    "Documentação de Spacecraft Attitude Dynamics (referência como Sidi ou Wertz)",
                                    "Templates de modelos de satélite disponíveis online"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades em ângulos de Euler; normalize-os periodicamente.",
                                  "learningObjective": "Compreender e implementar as dinâmicas básicas de um satélite com atuadores de rodas de reação.",
                                  "commonMistakes": [
                                    "Esquecer o termo de cross-product ω × (I ω)",
                                    "Unidades inconsistentes (rad/s vs deg/s)",
                                    "Não limitar velocidades das rodas (±6000 rpm típico)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar sensores de medição de atitude",
                                  "subSteps": [
                                    "Adicione blocos de sensores: giroscópio para taxas angulares (ω_meas = ω + bias + noise), magnetômetro ou star tracker para vetor de atitude.",
                                    "Crie um bloco de estimação simples (EKF básico ou complementar filter) para estado completo [q, ω].",
                                    "Defina matriz de alocação de torque para 4 rodas em configuração tetrahedral: A = [unit vectors].",
                                    "Inclua saturação e deadzone nos atuadores das rodas.",
                                    "Teste o loop aberto com sensores: injete distúrbio e verifique leituras realistas."
                                  ],
                                  "verification": "Simule com ruído; plote ω_meas vs ω_true, confirme erro < 0.1 deg/s RMS.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Toolbox Aerospace Blockset (opcional)",
                                    "Scripts MATLAB para gerar ruído Gaussiano",
                                    "Dados de sensores reais de CubeSats (NASA CDHFS)"
                                  ],
                                  "tips": "Use low-pass filters nos sensores para reduzir ruído de alta frequência sem atraso de fase excessivo.",
                                  "learningObjective": "Modelar realisticamente medições de atitude com ruído e bias, preparando para loop fechado.",
                                  "commonMistakes": [
                                    "Não modelar bias do giroscópio (típico 0.01 deg/s)",
                                    "Matriz de alocação invertida incorretamente levando a torques singulares",
                                    "Falta de normalização de quaternions nas medições"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver e tunar lei de controle PD",
                                  "subSteps": [
                                    "Defina controlador PD: τ = -K_p (q_err) - K_d ω, onde q_err é erro de quaternion.",
                                    "Calcule gains iniciais via Ziegler-Nichols ou pole placement (polos em -1 a -5 rad/s).",
                                    "Implemente no Simulink: blocos Gain, Subtract para erro, derivativo para ω.",
                                    "Adicione feedforward para manobras ( slew): τ_ff = I α_desired.",
                                    "Tune iterativamente: simule step response, ajuste para overshoot <10%, settling time <30s."
                                  ],
                                  "verification": "Simule estabilização de 10 deg erro inicial; verifique settling time <20s sem oscilações.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Control System Toolbox",
                                    "Funções sisotool() ou rltool() para análise",
                                    "Referência: 'Spacecraft Attitude Determination and Control' by Wertz"
                                  ],
                                  "tips": "Comece com K_d alto para amortecimento, depois aumente K_p; use simulações lineares para tuning inicial.",
                                  "learningObjective": "Implementar e otimizar um controlador PD clássico para estabilização de atitude.",
                                  "commonMistakes": [
                                    "Derivativo puro sem filtro causando ruído amplificado",
                                    "Erro de quaternion calculado incorretamente (use 2q_err)",
                                    "Gains muito altos causando saturação imediata das rodas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar controlador LQR ótimo e simular manobras",
                                  "subSteps": [
                                    "Linearize o modelo não-linear ao redor de equilíbrio: estado x = [q_vec, ω, ω_wheels].",
                                    "Defina matrizes Q (pesos em erro atitude > taxas) e R (penalidade em torque); resolva ARE com lqr().",
                                    "Implemente LQR state-feedback no Simulink com observer se necessário.",
                                    "Simule manobras: slew de 90 deg em eixo, verifique tempo e uso de rodas.",
                                    "Compare PD vs LQR em métricas: tempo de estabilização, consumo de momentum."
                                  ],
                                  "verification": "Execute slew maneuver; confirme atitude final <0.1 deg erro, momentum wheels <80% capacidade.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Control System Toolbox para lqr()",
                                    "Scripts de linearização simbólica com syms()",
                                    "Exemplos de LQR para satélites no MathWorks File Exchange"
                                  ],
                                  "tips": "Escolha Q diagonal com q_err >> ω para priorizar precisão de apontamento; itere Q/R para trade-offs.",
                                  "learningObjective": "Aplicar controle ótimo LQR para desempenho superior em estabilização e manobras.",
                                  "commonMistakes": [
                                    "Linearização em ponto errado (não equilíbrio)",
                                    "Matrizes Q/R mal escaladas causando gains instáveis",
                                    "Ignorar dinâmica das rodas no estado estendido"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados, validar e otimizar",
                                  "subSteps": [
                                    "Gere plots: tempo vs atitude, ω, torque, velocidades rodas; compute IAC (integral absolute error).",
                                    "Valide contra benchmarks: compare com papers ou simulações open-source (Orekit/COSMOS).",
                                    "Otimize: reduza tempo de simulação com ode45 ou fixed-step solver.",
                                    "Teste robustez: varie parâmetros (I ±20%, ruído +50%).",
                                    "Documente: salve modelo, plots e script de tuning."
                                  ],
                                  "verification": "Robustez passiva: erro médio <0.5 deg em 10 Monte Carlo runs com variações.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "MATLAB plotting functions (plot, subplot, bode)",
                                    "Ferramentas de Monte Carlo como parfor",
                                    "Benchmarks de simulações (NASA GMAT)"
                                  ],
                                  "tips": "Use Simulink Data Inspector para análise comparativa PD/LQR; exporte para relatório PDF.",
                                  "learningObjective": "Avaliar criticamente simulações e garantir robustez para cenários reais.",
                                  "commonMistakes": [
                                    "Solver stiff não selecionado para dinâmicas rápidas",
                                    "Plots sem legendas/unidades",
                                    "Não testar com distúrbios realistas como eclipse"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat 3U em órbita LEO: após deploy com erro inicial de 30 deg em roll, use PD para estabilizar em <10s, então LQR para slew de 180 deg yaw para imaging target, mantendo rodas abaixo de 5000 rpm sob distúrbios aerodinâmicos.",
                              "finalVerifications": [
                                "Simulação executa sem erros numéricos por 1 órbita (90 min).",
                                "Estabilização de distúrbio inicial: erro de atitude <0.5 deg em 30s.",
                                "Manobra slew: tempo <60s com overshoot <5 deg.",
                                "Uso de rodas: momentum acumulado <90% capacidade total.",
                                "Robustez: performance mantida com ±25% variação em inércia.",
                                "Comparação PD/LQR: LQR 20% mais rápido sem exceder torque."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estabilização: RMSE atitude <0.2 deg após settling.",
                                "Eficiência de manobra: tempo slew / ângulo <1 s/deg.",
                                "Gerenciamento de atuadores: max ω_wheel <6000 rpm, sem windup.",
                                "Robustez a ruído: variação std <10% em 5 runs.",
                                "Qualidade do código: modular, comentado, reproduzível.",
                                "Análise: métricas quantificadas (ITAE, controle effort)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de transição, LQR Riccati), cálculo diferencial (linearização).",
                                "Física: Dinâmica rotacional, conservação de momento angular.",
                                "Programação: Modelagem orientada a objetos em MATLAB, otimização numérica.",
                                "Engenharia de Sistemas: Trade-offs em controle (performance vs robustez).",
                                "Estatística: Análise Monte Carlo para incertezas."
                              ],
                              "realWorldApplication": "Desenvolvimento de software de controle para satélites como o CubeSat da NASA MarCO (2018), onde rodas de reação estabilizam atitude para comunicação laser e imaging, ou estações espaciais como ISS com CMGs derivados de princípios similares, reduzindo custos de combustível e aumentando vida útil da missão."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3.3",
                            "name": "Gerenciar desaturação de rodas",
                            "description": "Explicar técnicas de desaturação usando propulsores ou torque magnético para resetar o momento acumulado nas rodas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de saturação e desaturação de rodas de reação",
                                  "subSteps": [
                                    "Estudar a função das rodas de reação no controle de atitude de veículos espaciais.",
                                    "Definir momento angular acumulado e explicar o fenômeno de saturação.",
                                    "Analisar as consequências da saturação, como perda de capacidade de controle.",
                                    "Identificar os principais métodos de desaturação: propulsores e torque magnético.",
                                    "Comparar vantagens e desvantagens de cada método em termos de consumo de recursos."
                                  ],
                                  "verification": "Responder corretamente a um quiz com 5 perguntas sobre conceitos chave, com no mínimo 90% de acerto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo técnico sobre rodas de reação (ex: NASA Technical Report)",
                                    "Vídeo explicativo da ESA sobre controle de atitude",
                                    "Diagrama de rodas de reação"
                                  ],
                                  "tips": [
                                    "Visualize as rodas como 'baterias de momento' que precisam ser 'recarregadas' periodicamente.",
                                    "Anote exemplos reais de missões espaciais afetadas por saturação."
                                  ],
                                  "learningObjective": "Ao final deste passo, o aluno será capaz de explicar o ciclo de saturação-desaturação e justificar a necessidade de gerenciamento.",
                                  "commonMistakes": [
                                    "Confundir rodas de reação com giroscópios.",
                                    "Ignorar o impacto no consumo de propelente nos métodos de desaturação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o momento angular acumulado nas rodas de reação",
                                  "subSteps": [
                                    "Derivar as equações cinemáticas do momento angular das rodas: H = J * ω.",
                                    "Implementar um modelo simples de acumulação de momento em software de simulação.",
                                    "Simular cenários de perturbações externas (gradiente gravitacional, pressão solar).",
                                    "Calcular limites de saturação baseados em especificações da roda (ex: ±30 Nm-s).",
                                    "Validar o modelo comparando com dados de referência de satélites reais."
                                  ],
                                  "verification": "Gerar gráfico de acumulação de momento que corresponda a um benchmark com erro <5%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink ou Python (com NumPy/SciPy)",
                                    "Documentação de modelo de rodas de reação (ex: STK ou GMAT)",
                                    "Planilha de cálculos de momento angular"
                                  ],
                                  "tips": [
                                    "Use unidades consistentes (Nm-s para momento).",
                                    "Comece com modelo 1D antes de expandir para 3D."
                                  ],
                                  "learningObjective": "Desenvolver e validar um modelo matemático preciso para prever saturação de rodas.",
                                  "commonMistakes": [
                                    "Esquecer de incluir dinâmicas de perturbação no modelo.",
                                    "Usar velocidades angulares em vez de momento acumulado."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar desaturação usando propulsores",
                                  "subSteps": [
                                    "Calcular o impulso necessário para contrabalançar o momento acumulado: ΔH = T * Δt.",
                                    "Projetar uma sequência de disparos de propulsores minimizando distúrbio de atitude.",
                                    "Integrar o comando de desaturação ao loop de controle de atitude.",
                                    "Simular o processo em um cenário de missão com saturação recorrente.",
                                    "Otimizar parâmetros para minimizar consumo de combustível."
                                  ],
                                  "verification": "Simulação mostra desaturação completa sem perda de atitude >1 grau.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulador de dinâmica orbital (ex: MATLAB Aerospace Toolbox)",
                                    "Especificações de propulsores (ex: cold gas thrusters)",
                                    "Código-fonte de exemplo de controle de atitude"
                                  ],
                                  "tips": [
                                    "Use modo 'dump' de momento para desaturações programadas.",
                                    "Teste com diferentes configurações de propulsores."
                                  ],
                                  "learningObjective": "Projetar e simular comandos de desaturação com propulsores de forma eficiente.",
                                  "commonMistakes": [
                                    "Causar overshoot de atitude devido a impulsos excessivos.",
                                    "Não sincronizar com janelas de visibilidade para dump."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar desaturação usando torque magnético e integração",
                                  "subSteps": [
                                    "Modelar o torque magnético: T_m = m × B, onde m é dipolo, B é campo magnético.",
                                    "Calcular dipolo necessário para desaturar: integrar ao longo de órbitas.",
                                    "Combinar métodos híbridos (propulsores + magnético) para eficiência.",
                                    "Simular ciclo completo de gerenciamento em ambiente orbital realista.",
                                    "Avaliar desempenho em métricas como tempo de ciclo e consumo total."
                                  ],
                                  "verification": "Sistema simulado mantém rodas dentro de 80% da capacidade por 1 órbita simulada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Modelo de campo magnético IGRF (Python library pymag)",
                                    "Simulink ou Python para simulação híbrida",
                                    "Dados orbitais de satélites LEO/GEO"
                                  ],
                                  "tips": [
                                    "Prefira torque magnético em LEO onde B é forte.",
                                    "Monitore alinhamento orbital para máxima eficiência."
                                  ],
                                  "learningObjective": "Integrar desaturação magnética e avaliar trade-offs em sistemas reais.",
                                  "commonMistakes": [
                                    "Ignorar variações do campo magnético terrestre.",
                                    "Subestimar tempo de desaturação magnética (horas vs. minutos)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat em órbita LEO, simule rodas saturadas após manobras de apontamento. Use propulsores para desaturação rápida em emergência e torque magnético para manutenção rotina, integrando ao controlador ADCS para manter precisão de apontamento <0.5° durante downlink de dados.",
                              "finalVerifications": [
                                "Explicar verbalmente as técnicas de desaturação com exemplos numéricos.",
                                "Executar simulação completa mostrando gerenciamento autônomo de saturação.",
                                "Identificar falhas em cenários simulados e propor correções.",
                                "Comparar desempenho de métodos em relatório com gráficos.",
                                "Demonstrar conhecimento de limitações reais em veículos espaciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo de momento (erro <5%).",
                                "Eficiência de desaturação (consumo < limite especificado).",
                                "Estabilidade de atitude durante processo (<1° erro).",
                                "Qualidade da simulação e documentação.",
                                "Capacidade de otimização e análise de trade-offs.",
                                "Compreensão conceitual demonstrada em verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Conservação de momento angular e dinâmica orbital.",
                                "Engenharia de Controle: Loops PID e atuadores híbridos.",
                                "Programação: Simulação numérica em Python/MATLAB.",
                                "Engenharia Elétrica: Modelagem de bobinas de torque magnético.",
                                "Matemática: Álgebra linear para vetores de momento."
                              ],
                              "realWorldApplication": "Em satélites como o Hubble ou estações CubeSat, o gerenciamento de desaturação permite operações de longa duração sem perda de controle, economizando propelente e estendendo a vida útil da missão em anos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Roda de Reação com Gimbal",
                    "description": "Atuadores avançados com roda montada em gimbal para gerar alto torque de controle de atitude.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Princípio de Funcionamento da Roda de Reação com Gimbal",
                        "description": "Explicação dos fundamentos físicos que permitem à roda de reação montada em gimbal gerar torques elevados de controle de atitude por meio da precessão giroscópica.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Identificar componentes principais",
                            "description": "Reconhecer e descrever os elementos essenciais de uma roda de reação com gimbal, incluindo a roda de inércia, os gimballs (anéis rotativos) e os atuadores de orientação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a roda de inércia como componente central",
                                  "subSteps": [
                                    "Pesquise definições de roda de reação e roda de inércia em fontes confiáveis como NASA ou artigos acadêmicos.",
                                    "Identifique características físicas: disco ou roda flywheel com alto momento de inércia.",
                                    "Analise o papel: armazenar e manipular momento angular para controle de atitude.",
                                    "Compare com rodas de reação simples para destacar a versão com gimbal.",
                                    "Anote diagrama esquemático focando na roda de inércia."
                                  ],
                                  "verification": "Crie um esboço rotulando a roda de inércia e descreva sua função em uma frase.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Diagrama de roda de reação com gimbal (impresso ou digital)",
                                    "Vídeo explicativo da NASA sobre rodas de reação",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use imagens 3D interativas online para visualizar rotação; foque no eixo principal da roda.",
                                  "learningObjective": "Reconhecer a roda de inércia como o elemento gerador de torque angular.",
                                  "commonMistakes": [
                                    "Confundir com propulsores; ignorar o alto momento de inércia necessário."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os gimballs (anéis rotativos)",
                                  "subSteps": [
                                    "Defina gimbal: estrutura de anéis ortogonais permitindo liberdade de movimento em 3 eixos.",
                                    "Identifique tipicamente 2-3 anéis rotativos que suspendem a roda de inércia.",
                                    "Estude graus de liberdade: rotação independente em roll, pitch e yaw.",
                                    "Examine rolamentos e juntas que permitem movimento suave sem fricção excessiva.",
                                    "Desenhe como os gimballs isolam vibrações e direcionam torque."
                                  ],
                                  "verification": "Liste os eixos de rotação dos gimballs e explique como eles expandem capacidades da roda.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Animações 3D de gimbal em sites como YouTube ou Khan Academy",
                                    "Modelo físico ou software de simulação como SolidWorks",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Pense nos gimballs como um 'gimbal de celular' ampliado; teste girando um objeto similar.",
                                  "learningObjective": "Descrever gimballs como mecanismo de orientação multi-eixo para a roda.",
                                  "commonMistakes": [
                                    "Confundir com Control Moment Gyros (CMGs), que usam rotores fixos; subestimar número de anéis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar os atuadores de orientação",
                                  "subSteps": [
                                    "Identifique atuadores: motores elétricos servo ou brushless acoplados aos gimballs.",
                                    "Descreva função: controlar ângulo e velocidade de rotação dos gimballs.",
                                    "Estude sensores integrados: encoders ou resolvers para feedback de posição.",
                                    "Examine alimentação e controle: sinais de um computador de bordo para precisão.",
                                    "Registre limitações: torque máximo e resolução angular."
                                  ],
                                  "verification": "Explique em um diagrama como um atuador move um gimbal e verifica posição.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Esquemas elétricos de atuadores em manuais de satélites",
                                    "Vídeos de desmontagem de sistemas de atitude",
                                    "Calculadora para estimar torque básico"
                                  ],
                                  "tips": "Compare com servos de drones; priorize precisão sobre velocidade.",
                                  "learningObjective": "Reconhecer atuadores como controladores ativos dos gimballs.",
                                  "commonMistakes": [
                                    "Ignorar feedback de sensores; confundir com motores da roda de inércia."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e descrever todos os componentes principais",
                                  "subSteps": [
                                    "Monte um diagrama completo rotulando roda de inércia, gimballs e atuadores.",
                                    "Descreva interações: como torque da roda é vetorizado pelos gimballs via atuadores.",
                                    "Compare com sistemas sem gimbal para justificar vantagens (maior envelope de torque).",
                                    "Crie uma tabela resumindo nome, função e localização de cada componente.",
                                    "Teste conhecimento respondendo perguntas de autoavaliação."
                                  ],
                                  "verification": "Produza uma descrição narrativa de 200 palavras identificando e descrevendo os três componentes.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Software de desenho como Draw.io ou PowerPoint",
                                    "Referências cruzadas de Steps 1-3",
                                    "Checklist de componentes"
                                  ],
                                  "tips": "Use setas no diagrama para mostrar fluxo de controle; revise com um colega.",
                                  "learningObjective": "Sintetizar visão holística dos componentes principais da roda de reação com gimbal.",
                                  "commonMistakes": [
                                    "Omitir interdependências; descrições vagas sem termos técnicos."
                                  ]
                                }
                              ],
                              "practicalExample": "Examine o diagrama da Double Gimbal Reaction Wheel (DG RW) usada no satélite GOCE da ESA: rotule a roda de inércia central, os dois gimballs ortogonais e os atuadores brushless em cada eixo, explicando como eles permitem controle de atitude em órbita baixa.",
                              "finalVerifications": [
                                "Liste corretamente os três componentes principais sem erros.",
                                "Descreva a função única de cada componente em uma frase precisa.",
                                "Desenhe um diagrama simples com todos os componentes rotulados.",
                                "Explique como os gimballs diferenciam esta roda de uma reação wheel padrão.",
                                "Identifique pelo menos um atuador e seu sensor associado.",
                                "Responda a perguntas orais sobre interações entre componentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (90-100% correto).",
                                "Profundidade descritiva: funções e interações claras (rubrica 1-5).",
                                "Qualidade visual de diagramas e esboços (legibilidade e acurácia).",
                                "Uso de terminologia técnica apropriada (ex: momento de inércia, graus de liberdade).",
                                "Completude da integração de todos os elementos.",
                                "Capacidade de diferenciar de sistemas similares."
                              ],
                              "crossCurricularConnections": [
                                "Física: Conservação de momento angular e dinâmica rotacional.",
                                "Engenharia Mecânica: Cinemática de mecanismos multi-grau de liberdade.",
                                "Eletrônica: Sistemas de controle em malha fechada com servomotores.",
                                "Matemática: Vetores unitários e matrizes de rotação para orientação.",
                                "Ciência da Computação: Algoritmos de controle PID para atuadores."
                              ],
                              "realWorldApplication": "Em satélites como o James Webb Space Telescope, rodas de reação com gimbal mantêm orientação precisa para observações astronômicas, gerenciando perturbações gravitacionais e magnéticas sem desperdiçar combustível, essencial para missões de longa duração."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Explicar geração de torque por precessão",
                            "description": "Derivar matematicamente o torque gerado pela mudança na orientação do vetor de momento angular da roda, utilizando a equação τ = Ω × h, onde Ω é a taxa de gimbal e h o momento angular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Momento Angular e Torque",
                                  "subSteps": [
                                    "Defina momento angular L = I ω, onde I é o momento de inércia e ω o vetor velocidade angular.",
                                    "Explique torque τ como dL/dt, a taxa de variação do momento angular.",
                                    "Discuta precessão: rotação da direção do eixo de rotação sem mudança no módulo de L.",
                                    "Revise produto vetorial e suas propriedades geométricas.",
                                    "Identifique como mudança de direção de L gera torque perpendicular."
                                  ],
                                  "verification": "Resuma em um diagrama vetorial como τ altera L e responda: 'O que acontece se τ for paralelo a L?'",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de mecânica clássica (ex: Goldstein), vídeo Khan Academy sobre momento angular, papel e caneta para diagramas.",
                                  "tips": "Desenhe vetores em 3D para visualizar melhor a precessão.",
                                  "learningObjective": "Compreender a relação fundamental entre torque, momento angular e precessão.",
                                  "commonMistakes": "Confundir torque com força; esquecer que τ é vetorial e perpendicular a L."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Configuração da Roda de Reação com Gimbal (RWG)",
                                  "subSteps": [
                                    "Descreva a RWG: roda de alta velocidade angular montada em um gimbal rotativo.",
                                    "Defina h como o momento angular da roda (h = I ω, com ω fixo em magnitude).",
                                    "Explique o gimbal: permite rotação controlada em um eixo perpendicular ao spin da roda.",
                                    "Introduza Ω como vetor da taxa angular do gimbal (magnitude da velocidade de precessão).",
                                    "Desenhe o sistema: roda girando em torno de seu eixo, gimbal rotacionando em Ω."
                                  ],
                                  "verification": "Esboce um diagrama da RWG mostrando h, Ω e o plano de rotação do gimbal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagramas online de RWG (NASA ou satélites), software como GeoGebra para vetores 3D.",
                                  "tips": "Pense no gimbal como um 'torqueador' que força h a precessar.",
                                  "learningObjective": "Visualizar geometricamente como o gimbal induz precessão em h.",
                                  "commonMistakes": "Assumir que ω da roda muda; Ω é apenas a rotação do suporte."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Equação τ = Ω × h",
                                  "subSteps": [
                                    "Comece com τ = dh/dt, onde h varia apenas em direção devido à precessão.",
                                    "Expresse dh/dt como mudança direccional: dh/dt = Ω × h (regra de derivação de vetores rotantes).",
                                    "Derive matematicamente: para vetor h precessando em Ω, a taxa de mudança é o produto vetorial.",
                                    "Calcule magnitude: |τ| = Ω h sinθ, onde θ é o ângulo entre Ω e h (geralmente 90°).",
                                    "Confirme unidades: τ em N·m, Ω em rad/s, h em kg·m²/s."
                                  ],
                                  "verification": "Escreva a derivação passo a passo e compute |τ| para Ω=1 rad/s, h=10 kg·m²/s, θ=90°.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno de equações, calculadora simbólica (Wolfram Alpha), referência: equações de rotação rígida.",
                                  "tips": "Use a identidade vetorial dh/dt = (dh/dt)_body + Ω × h, mas corpo fixo então só o cross.",
                                  "learningObjective": "Derivar rigorosamente a geração de torque via precessão.",
                                  "commonMistakes": "Esquecer o sinal vetorial; inverter Ω × h para h × Ω."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Aplicar a Derivação",
                                  "subSteps": [
                                    "Explique como controlar Ω gera τ direcionável para controle de atitude.",
                                    "Discuta limitações: torque pequeno, requer h grande (alta ω).",
                                    "Simule numericamente: varie Ω e veja τ mudar direção.",
                                    "Compare com roda de reação comum (sem gimbal, torque via mudança em ω).",
                                    "Resolva um problema: calcule τ necessário para uma manobra."
                                  ],
                                  "verification": "Resolva: 'Para h = 50 kg·m²/s ao longo x, Ω = 0.1 rad/s ao longo z, encontre τ.'",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python/MATLAB para simulação vetorial, exemplos de papers sobre CMG (Control Moment Gyro).",
                                  "tips": "Sempre normalize vetores para checar direção de τ.",
                                  "learningObjective": "Aplicar a equação em contextos de engenharia aeroespacial.",
                                  "commonMistakes": "Ignorar que magnitude de h é constante; confundir com nutação."
                                }
                              ],
                              "practicalExample": "Em um satélite como o ISS, uma RWG com h = 200 kg·m²/s é precessada a Ω = 0.05 rad/s em torno do eixo y, gerando τ = Ω × h ≈ 10 N·m ao longo do eixo x para corrigir a atitude sem expelir propelente.",
                              "finalVerifications": [
                                "Deriva corretamente τ = Ω × h a partir de dh/dt.",
                                "Desenha diagrama vetorial preciso mostrando direção de τ.",
                                "Calcula magnitude e direção para valores numéricos dados.",
                                "Explica diferença entre precessão induzida e torque direto.",
                                "Identifica aplicações em controle de atitude.",
                                "Discute limitações como singularidades de gimbal."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% das etapas corretas).",
                                "Clareza conceitual: explica mudança direccional vs. magnitude.",
                                "Uso correto de vetores e convenções de produto cruzado.",
                                "Profundidade de interpretação física.",
                                "Criatividade em exemplos ou extensões.",
                                "Ausência de erros unitários ou dimensionais."
                              ],
                              "crossCurricularConnections": [
                                "Física Clássica: Mecânica de Rotações Rígidas.",
                                "Engenharia de Controle: Sistemas Dinâmicos Não-Lineares.",
                                "Matemática: Álgebra Vetorial e Cálculo Multivariável.",
                                "Engenharia Mecânica: Projeto de Atuadores Rotativos."
                              ],
                              "realWorldApplication": "Usado em satélites e estações espaciais (ex: Control Moment Gyros no ISS) para manobras precisas de atitude, economizando combustível e permitindo controle fino em 3 eixos sem singularidades como em rodas comuns."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Comparar com roda de reação convencional",
                            "description": "Analisar as diferenças em capacidade de torque entre rodas de reação fixas e com gimbal, destacando a vantagem de alto torque sem necessidade de mudança de velocidade da roda.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Princípio de Funcionamento da Roda de Reação Convencional (Fixa)",
                                  "subSteps": [
                                    "Estude o conceito básico: rodas de reação fixas geram torque alterando a velocidade de rotação do rotor para conservar o momento angular.",
                                    "Analise a equação de torque: τ = I * α, onde I é o momento de inércia e α é a aceleração angular.",
                                    "Identifique limitações: torque máximo limitado pela velocidade máxima do rotor (tipicamente 6000-12000 RPM) e aceleração possível.",
                                    "Desenhe um diagrama simples mostrando o eixo fixo e o vetor de momento angular alinhado.",
                                    "Calcule um exemplo numérico: para I=0.1 kg·m² e α_max=10 rad/s², torque_max=1 Nm."
                                  ],
                                  "verification": "Crie um diagrama e cálculo que demonstrem o torque máximo de uma roda fixa; verifique se o valor é coerente com limites reais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de dinâmica orbital",
                                    "Calculadora ou software como MATLAB",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com equações fundamentais para solidificar a base; use unidades consistentes (SI).",
                                  "learningObjective": "Compreender como rodas fixas geram torque via mudança de velocidade e suas limitações inerentes.",
                                  "commonMistakes": [
                                    "Confundir torque com força linear",
                                    "Ignorar saturação de velocidade do rotor",
                                    "Usar momentos de inércia incorretos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Princípio da Roda de Reação com Gimbal",
                                  "subSteps": [
                                    "Defina o gimbal: um suporte que permite rotação do eixo da roda em 1-3 eixos ortogonais.",
                                    "Explique o torque via précessão: torque é gerado inclinando o vetor de momento angular (h = Iω) sem alterar a magnitude de ω.",
                                    "Estude a equação: τ = Ω × h, onde Ω é a taxa de gimbal (velocidade de inclinação).",
                                    "Compare vetores: na roda fixa, torque paralela ao eixo; no gimbal, torque perpendicular ao plano de inclinação.",
                                    "Visualize com animação ou vídeo de demonstração de CMG (Control Moment Gyro).",
                                    "Calcule exemplo: h=10 N·m·s, Ω=1 rad/s, τ=10 Nm perpendicular."
                                  ],
                                  "verification": "Desenhe vetores de h, Ω e τ, e calcule torque para um caso dado; confirme direção e magnitude.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Vídeos tutoriais sobre CMG (YouTube/NASA)",
                                    "Software de visualização vetorial (GeoGebra)",
                                    "Folhas de cálculo"
                                  ],
                                  "tips": "Use a regra da mão direita para vetores cruzados; foque na independência da velocidade do rotor.",
                                  "learningObjective": "Dominar como o gimbal permite torque direcional via mudança de orientação, não velocidade.",
                                  "commonMistakes": [
                                    "Confundir gimbal com thrusters",
                                    "Esquecer que ω permanece constante",
                                    "Erro na direção do torque (produto vetorial)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Capacidades de Torque entre os Dois Tipos",
                                  "subSteps": [
                                    "Liste métricas chave: torque máximo, taxa de slew (mudança de atitude), consumo de energia.",
                                    "Compare torque: fixa limitada por α_max (ex: 0.1-1 Nm); gimbal por Ω_max e h (ex: 10-100 Nm).",
                                    "Analise limitações: fixa satura em alta velocidade; gimbal pode 'singularizar' em alinhamentos específicos.",
                                    "Crie tabela comparativa: colunas para tipo, torque pico, limitações, aplicações.",
                                    "Simule numericamente: use Python/MATLAB para plotar curvas de torque vs. tempo.",
                                    "Discuta eficiência: gimbal oferece torque alto com baixa potência (manutenção de ω).",
                                    "Quantifique vantagem: torque gimbal pode ser 10-100x maior sem aceleração de rotor."
                                  ],
                                  "verification": "Produza uma tabela e gráfico comparativos mostrando superioridade em torque do gimbal.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python (NumPy/Matplotlib)",
                                    "Dados de rodas reais (ex: specs da Reaction Wheel de satélites CubeSat)"
                                  ],
                                  "tips": "Normalize unidades para comparação justa; inclua gráficos para visualização clara.",
                                  "learningObjective": "Quantificar diferenças em torque e identificar quando cada tipo é superior.",
                                  "commonMistakes": [
                                    "Superestimar torque de rodas fixas ignorando limites de RPM",
                                    "Não considerar singularidades do gimbal",
                                    "Comparar sem contexto de escala"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Vantagens e Aplicações Práticas da Roda com Gimbal",
                                  "subSteps": [
                                    "Enfatize vantagem chave: alto torque sem mudança de velocidade (evita saturação e histerese).",
                                    "Discuta desvantagens: complexidade mecânica, custo, necessidade de desingularização.",
                                    "Relacione com controle de atitude: ideal para manobras rápidas em satélites grandes.",
                                    "Exemplo real: ISS usa CMGs para controle suave sem combustível.",
                                    "Crie resumo em bullet points: prós/cons, cenários ideais.",
                                    "Debata trade-offs: para CubeSats pequenos, rodas fixas são suficientes e baratas."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a vantagem principal com números de exemplo e uma aplicação real.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigos NASA sobre CMG na ISS",
                                    "Documentação de satélites (ex: Hubble RWGS)"
                                  ],
                                  "tips": "Use exemplos reais para ancorar conceitos; pense em custos vs. performance.",
                                  "learningObjective": "Articular claramente por que rodas com gimbal superam convencionais em cenários de alto torque.",
                                  "commonMistakes": [
                                    "Ignorar desvantagens do gimbal (peso, falhas)",
                                    "Generalizar sem contexto de missão",
                                    "Confundir com flywheels de energia"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um satélite de observação terrestre como o Landsat, use rodas fixas para ajustes finos (torque ~0.05 Nm), mas rodas com gimbal (CMG) para slew rápido de 90° em minutos, gerando 50 Nm sem esgotar a bateria do rotor, permitindo imagens contínuas sem interrupções.",
                              "finalVerifications": [
                                "Explicar verbalmente a equação de torque para ambos os tipos.",
                                "Desenhar e rotular diagramas vetoriais corretos para gimbal.",
                                "Preencher tabela comparativa com valores numéricos realistas.",
                                "Identificar 3 cenários onde gimbal é preferível.",
                                "Simular uma manobra simples em software e discutir limitações.",
                                "Discutir impacto na vida útil da roda (sem saturação no gimbal)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas equações e cálculos de torque (90% correto).",
                                "Clareza na distinção entre mudança de velocidade vs. orientação.",
                                "Uso de exemplos quantitativos e qualitativos equilibrados.",
                                "Identificação correta de vantagens (alto torque constante) e limitações.",
                                "Qualidade dos diagramas e tabelas (legíveis e informativos).",
                                "Capacidade de relacionar a conceitos reais de missões espaciais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Conservação de momento angular e produto vetorial.",
                                "Matemática: Álgebra vetorial e simulações numéricas.",
                                "Engenharia Mecânica: Cinemática de gimbals e atuadores.",
                                "Ciência de Computação: Algoritmos de controle de atitude (desingularização).",
                                "Gestão de Projetos: Trade-offs custo/performance em design aeroespacial."
                              ],
                              "realWorldApplication": "Nas estações espaciais como a ISS, CMGs (rodas com gimbal) mantêm orientação precisa para experimentos científicos e acoplamentos de naves, fornecendo torque de até 200 Nm sem consumir combustível, estendendo a vida útil da missão em anos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Configurações e Dinâmica do Sistema",
                        "description": "Estudo das arquiteturas comuns de montagem de rodas com gimbal e sua integração na dinâmica de atitude de veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Descrever configurações pyramidais e coplanar",
                            "description": "Explicar configurações como cluster pyramidal (4 rodas) e coplanar, incluindo redundância e singularidades de controle associadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Configurações de Rodas de Reação com Gimbal",
                                  "subSteps": [
                                    "Revise o papel das rodas de reação (RWGs) no controle de atitude de veículos espaciais.",
                                    "Estude os graus de liberdade proporcionados pelo gimbal em RWGs.",
                                    "Identifique configurações básicas: mínima (1 roda), dupla e múltiplas rodas.",
                                    "Desenhe diagramas simples de eixos de rotação e gimbal.",
                                    "Analise como o torque é gerado pela combinação de spin e gimbal rates."
                                  ],
                                  "verification": "Crie um diagrama anotado explicando o torque 3D de uma única RWG e liste limitações de uma configuração mínima.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Diagrama de RWG (imagem ou PDF)",
                                    "Vídeo tutorial sobre controle de atitude (YouTube ou Khan Academy)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Comece visualizando animações 3D para intuitar o movimento do gimbal.",
                                  "learningObjective": "Compreender os princípios básicos que precedem configurações avançadas como pyramidal e coplanar.",
                                  "commonMistakes": "Confundir torque de spin com torque de gimbal; lembre-se que gimbal permite direção variável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever Configuração Coplanar",
                                  "subSteps": [
                                    "Defina configuração coplanar: rodas com planos de spin paralelos, tipicamente 4 rodas em um plano.",
                                    "Calcule o envelope de torque: mostre que cobre 3 eixos mas com singularidades quando eixos se alinham.",
                                    "Simule geometricamente o torque unitário para cada roda.",
                                    "Discuta instalação: simetria em cruz ou quadrado.",
                                    "Identifique limitações: perda de capacidade em certas direções."
                                  ],
                                  "verification": "Desenhe o vetor de torque para uma manobra de roll puro e verifique cobertura incompleta.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Software MATLAB ou Python com NumPy para plotar vetores de torque",
                                    "Referência: 'Spacecraft Attitude Determination and Control' de Wertz (capítulo sobre RWAs)"
                                  ],
                                  "tips": "Use vetores unitários para representar direções de torque; normalize para clareza.",
                                  "learningObjective": "Descrever precisamente a geometria, capacidades e limitações da configuração coplanar.",
                                  "commonMistakes": "Assumir cobertura isotrópica; coplanar tem assimetria direcional."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever Configuração Pyramidal (Cluster de 4 Rodas)",
                                  "subSteps": [
                                    "Defina cluster pyramidal: 4 rodas com eixos de spin em configuração piramidal (ângulos ~54.7° do eixo vertical).",
                                    "Explique simetria: cobertura quasi-isotrópica de torque em 3D.",
                                    "Deriva a matriz de alocação de torque para 4 RWGs pyramidais.",
                                    "Desenhe vistas 3D mostrando ângulos hiperbólicos (pyramidais).",
                                    "Compare com coplanar: maior redundância e menor singularidade."
                                  ],
                                  "verification": "Construa a matriz de configuração pyramidal e compute torque para uma entrada arbitrária.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "MATLAB Simulink para modelagem de attitude control",
                                    "Ferramenta de plot 3D como Plotly ou Blender",
                                    "Artigo IEEE sobre RWG configurations"
                                  ],
                                  "tips": "Use ângulo pyramidal padrão de arccos(1/sqrt(3)) para precisão.",
                                  "learningObjective": "Dominar a geometria e matemática da configuração pyramidal para controle robusto.",
                                  "commonMistakes": "Ignorar o skew angle; pyramidal usa ±α em pares opostos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Redundância e Singularidades de Controle",
                                  "subSteps": [
                                    "Defina redundância: graus de liberdade extras (4 rodas para 3 eixos).",
                                    "Identifique singularidades: configurações onde matriz de torque perde rank (coplanar pior que pyramidal).",
                                    "Calcule condições de singularidade usando determinante da matriz de Jacobiano.",
                                    "Discuta estratégias de des Singularização: pseudoinverso ou otimização.",
                                    "Compare: pyramidal oferece redundância inerente para falhas."
                                  ],
                                  "verification": "Simule uma singularidade em coplanar vs pyramidal e proponha solução de redundância.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Código Python para inversão de matrizes e detecção de singularidade",
                                    "Simulador de spacecraft como Orekit ou GMAT"
                                  ],
                                  "tips": "Teste com entradas de torque unitário; monitore cond number da matriz.",
                                  "learningObjective": "Avaliar robustez das configurações quanto a redundância e evitar singularidades.",
                                  "commonMistakes": "Confundir singularidade com saturação; singularidade é perda de rank."
                                }
                              ],
                              "practicalExample": "Em um satélite CubeSat, configure 4 RWGs pyramidais no simulador MATLAB: aplique comando de yaw de 10°/s, observe alocação de torque simétrica sem singularidades, e simule falha de uma roda usando redundância para manter controle.",
                              "finalVerifications": [
                                "Desenhar e rotular diagramas precisos de ambas configurações.",
                                "Explicar verbalmente diferenças em cobertura de torque.",
                                "Computar manualmente torque para caso simples em pyramidal.",
                                "Identificar pelo menos 2 singularidades em coplanar.",
                                "Propor uso de redundância em falha de roda.",
                                "Comparar eficiência em manobras reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição geométrica (ângulos corretos).",
                                "Correta derivação de matrizes de torque.",
                                "Identificação exata de singularidades e redundância.",
                                "Uso apropriado de terminologia técnica.",
                                "Clareza em diagramas e simulações.",
                                "Análise comparativa quantitativa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de alocação, pseudoinversas).",
                                "Física: Dinâmica de rotação rígida e vetores de momento angular.",
                                "Engenharia de Controle: Cinemática de manipuladores (análoga a RWGs).",
                                "Programação: Simulação numérica em Python/MATLAB.",
                                "Design Mecânico: Otimização geométrica de atuadores."
                              ],
                              "realWorldApplication": "Na Estação Espacial Internacional (ISS), CMGs em configuração pyramidal/quasi-pyramidal fornecem controle de atitude preciso com redundância para missões de longa duração, evitando singularidades durante manobras orbitais e compensando falhas sem perda de pointing."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Modelar equações cinemáticas",
                            "description": "Formular as equações que relacionam as taxas de gimbal às taxas angulares desejadas do veículo, considerando o Jacobiano do sistema de CMGs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de CMGs e Cinemática de Atitude",
                                  "subSteps": [
                                    "Estude a estrutura de uma Roda de Reação com Gimbal (CMG), identificando componentes como rotores, gimbals e eixos de rotação.",
                                    "Revise as taxas angulares do veículo (ω) e como elas se relacionam com o torque de controle.",
                                    "Entenda o papel das taxas de gimbal (ġ) na geração de momento de controle sem mudança na velocidade do rotor.",
                                    "Analise exemplos de configurações comuns de CMGs (ex: piramidal, coplanar).",
                                    "Identifique a necessidade do Jacobiano para mapear ġ para ω."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo os conceitos chave e explique verbalmente a relação cinemática básica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de dinâmica de spacecraft (ex: Sidi 'Spacecraft Dynamics and Control'), notas de aula, vídeo tutorial sobre CMGs.",
                                  "tips": "Use diagramas vetoriais para visualizar rotações; foque em convenções de sinal para eixos.",
                                  "learningObjective": "Compreender os princípios físicos e matemáticos subjacentes às CMGs e sua cinemática.",
                                  "commonMistakes": "Confundir torque dinâmico (relacionado à aceleração do rotor) com momento cinemático das gimbals."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Configuração Geométrica e Variáveis Cinemáticas",
                                  "subSteps": [
                                    "Escolha uma configuração específica (ex: 4 CMGs em piramidal simétrica) e defina ângulos de skew (β).",
                                    "Defina vetores unitários para spin (ŝ_i), gimbal (ĝ_i) e output (ô_i) de cada CMG i.",
                                    "Introduza variáveis: vetor de momentum angular do rotor h = h * ŝ_i, ângulos de gimbal δ_i, taxas ġ_i.",
                                    "Escreva a expressão geral para o momentum total do cluster H = Σ A_i(δ_i) h ŝ_0i, onde A_i é matriz de rotação.",
                                    "Liste as grandezas cinemáticas: ω_v (taxa do veículo), ġ (vetor de taxas de gimbal)."
                                  ],
                                  "verification": "Crie uma tabela ou sketch com todas as variáveis definidas e matrizes de rotação iniciais corretas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado ou software de desenho (ex: GeoGebra), MATLAB/Simulink para prototipagem.",
                                  "tips": "Padronize notação: use subscrito 'i' para CMG individual e vetores coluna para consistência matricial.",
                                  "learningObjective": "Estabelecer notação precisa e configuração para derivação subsequente.",
                                  "commonMistakes": "Ignorar dependência do ângulo de gimbal nas direções unitárias; usar convenções de rotação inconsistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Jacobiano do Sistema de CMGs",
                                  "subSteps": [
                                    "Parta da equação de momentum: Ḣ = ω_v × H + J ġ, onde J é o Jacobiano.",
                                    "Compute a derivada temporal de H em relação aos δ_i: ∂H/∂δ_i = -ô_i × h ŝ_i (para configuração rígida).",
                                    "Monte a matriz Jacobiana J (3xN, N= número de CMGs) com colunas j_i = ∂H/∂δ_i / h.",
                                    "Verifique propriedades: J depende de δ_i atuais; para singularidades, det(J^T J)=0.",
                                    "Implemente numericamente em código para uma configuração teste."
                                  ],
                                  "verification": "Derive explicitamente J para 3 CMGs coplanares e confirme com fórmula padrão da literatura.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB ou Python (SymPy para simbólico), calculadora matricial.",
                                  "tips": "Use regra da mão direita para cruzamentos vetoriais; derive simbolicamente antes de numérico.",
                                  "learningObjective": "Dominar a derivação analítica do Jacobiano cinemático.",
                                  "commonMistakes": "Esquecer o fator h na normalização das colunas do Jacobiano; confundir J com sua transposta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e Validar Equações Cinemáticas Completas",
                                  "subSteps": [
                                    "Escreva as equações cinemáticas: ω_v = J ġ (assumindo corpo inercial para simplificação inicial).",
                                    "Inclua correções para corpo não-inercial: ω_v = J ġ - ω_v × (J ġ) / ||ω_v|| ou itere numericamente.",
                                    "Simule um perfil de atitude (ex: slew maneuver) resolvendo para ġ = pinv(J) ω_d.",
                                    "Analise singularidades e proponha evasão (ex: null-motion).",
                                    "Compare com simulação dinâmica full-state para validar."
                                  ],
                                  "verification": "Execute simulação onde ω_v segue comando desejado sem erro >1%; plote trajetórias.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB/Simulink com Aerospace Toolbox, ou Python (SciPy/Control).",
                                  "tips": "Use pseudoinversa para redundância (N>3); teste com β=54.7° para piramidal.",
                                  "learningObjective": "Integrar Jacobiano em equações acionáveis e validar via simulação.",
                                  "commonMistakes": "Negligenciar acoplamento dinâmico; assumir J constante ao longo da manobra."
                                }
                              ],
                              "practicalExample": "Para um cluster de 4 CMGs piramidais (β=54.74°), com h=50 Nms, derive J(δ=0) = [[0.707,0.707,-0.707,-0.707]; [0.707,-0.707,0.707,-0.707]; [0.5,-0.5,-0.5,0.5]] (normalizado). Para ω_d = [0.1, 0, 0] rad/s, compute ġ = J^+ ω_d e simule rotação em roll.",
                              "finalVerifications": [
                                "Equações cinemáticas ω_v = J ġ derivadas corretamente para configuração escolhida.",
                                "Jacobiano J computado com colunas unitárias e dependência em δ_i explícita.",
                                "Simulação numérica reproduz ω_d com erro <0.01 rad/s.",
                                "Identificadas singularidades (ex: δ alinhados) e método de evasão proposto.",
                                "Notação consistente com literatura padrão (ex: Margulies & Aubrun).",
                                "Validação cruzada com código simbólico vs. numérico."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação do Jacobiano (100% match com fórmula analítica).",
                                "Completude da notação e definição de todas variáveis (sem ambiguidades).",
                                "Qualidade da simulação: estabilidade, precisão e visualizações claras.",
                                "Análise de edge cases como singularidades (profundidade conceitual).",
                                "Clareza na documentação: equações legíveis e explicadas.",
                                "Eficiência computacional na implementação (tempo de simulação <1s para 100s)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes Jacobianas, pseudoinversa), cálculo vetorial (derivadas parciais).",
                                "Física: Dinâmica rotacional, conservação de momento angular em sistemas não-holonômicos.",
                                "Engenharia de Controle: Cinemática vs. dinâmica, inversa cinemática para atuadores redundantes.",
                                "Programação: Simulação numérica (ODE solvers), visualização 3D de vetores.",
                                "Informática: Otimização quadrática para alocação de ġ em singularidades."
                              ],
                              "realWorldApplication": "Em satélites como o Hubble ou estações espaciais (ISS), CMGs controlam atitude com alta precisão e eficiência energética, evitando uso de propelentes; equações cinemáticas são centrais em algoritmos de apontamento para telescópios ou painéis solares."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Analisar singularidades",
                            "description": "Identificar e mitigar singularidades onde o sistema perde capacidade de gerar torque em certas direções, utilizando métricas como medida de momentum.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Singularidades em CMGs",
                                  "subSteps": [
                                    "Estude a configuração de rodas de reação com gimbal (CMG) e sua capacidade de gerar torque via momento de controle angular.",
                                    "Defina singularidades como configurações onde a matriz de Jacobian perde rank, impedindo torque em certas direções.",
                                    "Revise métricas como a medida de momentum (CM) e norma de Frobenius da pseudo-inversa da Jacobian.",
                                    "Analise diagramas de gimbal angles para visualizar estados singulares.",
                                    "Compare singularidades em clusters de CMGs pyramidais vs. coplanares."
                                  ],
                                  "verification": "Resuma em um diagrama os tipos de singularidades e métricas associadas, sem erros conceituais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro 'Spacecraft Attitude Determination and Control' de Wertz; slides de dinâmica de atitudes; MATLAB para plotar configurações.",
                                  "tips": "Use analogias com perda de mobilidade em robótica para intuitar singularidades.",
                                  "learningObjective": "Identificar definições e causas raiz de singularidades em sistemas CMG.",
                                  "commonMistakes": "Confundir singularidades com saturação de momentum; ignorar dependência de configurações de gimbal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a Dinâmica Matemática do Sistema CMG",
                                  "subSteps": [
                                    "Derive a equação do torque gerado: τ = A(γ) h, onde A é a matriz de Jacobian e γ são ângulos de gimbal.",
                                    "Implemente a medida de momentum CM = ||A^+||_F, onde A^+ é a pseudo-inversa.",
                                    "Calcule o rank da Jacobian para detectar singularidades (rank < 3 indica perda de torque).",
                                    "Simule trajetórias de gimbal em software para observar perda de capacidade.",
                                    "Valide o modelo com exemplos numéricos de clusters de 4 CMGs."
                                  ],
                                  "verification": "Execute simulação em MATLAB mostrando CM caindo para zero em gimbal angles específicos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB/Simulink com toolbox de controle; paper 'Singularity Analysis of CMG Systems'; notebook Jupyter.",
                                  "tips": "Normalice ângulos de gimbal entre -π e π para evitar ambiguidades trigonométricas.",
                                  "learningObjective": "Construir e validar modelo matemático para análise de singularidades.",
                                  "commonMistakes": "Erros em derivadas parciais da Jacobian; assumir simetria em configurações assimétricas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar e Analisar Singularidades Utilizando Métricas",
                                  "subSteps": [
                                    "Implemente algoritmo para escanear espaço de gimbal angles e mapear regiões singulares.",
                                    "Calcule métricas: CM, medida de torque disponível e índice de condição da Jacobian.",
                                    "Classifique singularidades (residentes vs. escape) baseadas em trajetórias.",
                                    "Visualize com heatmaps de CM no espaço 4D de gimbal (projetado em 2D).",
                                    "Analise impacto em controle de atitude sob perturbações."
                                  ],
                                  "verification": "Gere mapa de singularidades com pelo menos 3 regiões identificadas e métricas quantificadas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "MATLAB com funções svd() e pinv(); dados de simulação de ISS CMGs.",
                                  "tips": "Use SVD para análise robusta de rank em vez de det(A) para matrizes não quadradas.",
                                  "learningObjective": "Aplicar métricas quantitativas para detecção precisa de singularidades.",
                                  "commonMistakes": "Sobrepor regiões singulares sem considerar histérese; ignorar efeitos dinâmicos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver Estratégias de Mitigação de Singularidades",
                                  "subSteps": [
                                    "Estude algoritmos de steering como Singularity Escape Maneuvers (SEM).",
                                    "Implemente controle preditivo para evitar regiões singulares via otimização de CM.",
                                    "Teste mitigação com redirecionamento de torque usando thrusters auxiliares.",
                                    "Simule cenários de recuperação de singularidades em tempo real.",
                                    "Avalie trade-offs: consumo de momentum vs. evasão de singularidades."
                                  ],
                                  "verification": "Demonstre simulação onde sistema evade singularidade mantendo torque > 80% nominal.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Simulink para controle closed-loop; papers sobre MOOG CMG steering.",
                                  "tips": "Priorize métricas de CM em funções de custo de MPC para evasão proativa.",
                                  "learningObjective": "Projetar e validar métodos para mitigar impactos de singularidades.",
                                  "commonMistakes": "Subestimar latência em manobras de escape; negligenciar acoplamento com dinâmica orbital."
                                }
                              ],
                              "practicalExample": "Em uma simulação de satélite com cluster pyramidal de 4 CMGs, ao girar gimbal para [45°, 45°, -45°, -45°], CM cai para 0.2 (singularidade). Implemente steering para redirecionar gimbals para [30°, 60°, -30°, -60°], restaurando CM > 0.9 e mantendo torque em eixo Z.",
                              "finalVerifications": [
                                "Mapa completo de singularidades gerado com métricas CM precisas.",
                                "Simulação demonstra evasão de singularidade sem perda de controle.",
                                "Análise classifica corretamente tipos de singularidades no cluster.",
                                "Estratégias de mitigação testadas em pelo menos 3 cenários.",
                                "Relatório resume impactos e soluções com gráficos quantitativos.",
                                "Código reproduzível em MATLAB para detecção e mitigação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da Jacobian e métricas (erro < 1%).",
                                "Identificação correta de ≥80% das singularidades em simulações padrão.",
                                "Efetividade de mitigação: tempo de recuperação < 10s.",
                                "Visualizações claras e interpretáveis de regiões singulares.",
                                "Análise de trade-offs documentada com justificativas.",
                                "Código limpo, comentado e modular."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (pseudo-inversas, SVD) e otimização.",
                                "Física: Dinâmica rotacional e conservação de momento angular.",
                                "Programação: Simulação numérica em MATLAB/Python e visualização de dados.",
                                "Engenharia de Controle: Análise de singularidades em sistemas não-lineares."
                              ],
                              "realWorldApplication": "Na Estação Espacial Internacional (ISS), CMGs evitam singularidades durante manobras de atitude para minimizar uso de thrusters, economizando propelente e estendendo vida útil da missão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Controle e Simulação",
                        "description": "Técnicas de controle para estabilização de atitude usando rodas com gimbal e sua implementação em simulações de veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Implementar lei de controle básica",
                            "description": "Desenvolver uma lei de controle proporcional-derivativo (PD) para taxas de gimbal, visando rastreamento de quaternions de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Quaternions e Controle PD",
                                  "subSteps": [
                                    "Estude a representação de atitude por quaternions e extraia o erro de atitude entre quaternion atual e desejado.",
                                    "Revise a lei de controle PD: torque = -Kp * erro - Kd * derivada_erro.",
                                    "Identifique variáveis específicas: erro em quaternions para taxas de gimbal, taxas de gimbal como saída.",
                                    "Defina notação: q_d (desejado), q (atual), ω_g (taxas de gimbal).",
                                    "Calcule o vetor de erro de quaternion: 2 * q_d^* ⊗ q (parte vetorial)."
                                  ],
                                  "verification": "Resuma em um diagrama ou equação o erro de quaternion e a forma PD adaptada para gimbals.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": "Documentação de quaternions (NASA ou Sidi), MATLAB para cálculos simbólicos, notas de controle PD.",
                                  "tips": "Use quaternions unitários para evitar singularidades em ângulos de Euler.",
                                  "learningObjective": "Compreender como mapear erro de atitude em comandos para taxas de gimbal via PD.",
                                  "commonMistakes": "Confundir quaternion escalar com vetorial; ignorar normalização do quaternion."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Lei de Controle PD para Taxas de Gimbal",
                                  "subSteps": [
                                    "Defina o erro de atitude e: e = 2 * q_d^* ⊗ q (parte imaginária).",
                                    "Compute a derivada do erro: ė ≈ -ω × e, onde ω é taxa angular do corpo.",
                                    "Escreva u_g = -Kp * e - Kd * ė para torque nas taxas de gimbal.",
                                    "Incorpore limites de saturação para taxas de gimbal realistas (±30 deg/s).",
                                    "Selecione ganhos iniciais: Kp=10, Kd=5 via método de Ziegler-Nichols ou simulação preliminar."
                                  ],
                                  "verification": "Implemente equações em um script simbólico e plote resposta a um passo em atitude.",
                                  "estimatedTime": "2 hours",
                                  "materials": "MATLAB Symbolic Toolbox, paper e caneta para derivação, referências de controle de atitude (como Leveque).",
                                  "tips": "Linearize em torno de equilíbrio para simplificar ė.",
                                  "learningObjective": "Derivar uma lei PD específica para rastreamento de quaternions via gimbals.",
                                  "commonMistakes": "Não normalizar quaternions; escolher ganhos muito altos causando oscilação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Lei de Controle em Simulador",
                                  "subSteps": [
                                    "Configure modelo de roda de reação com gimbal no Simulink/MATLAB.",
                                    "Integre a função PD como bloco: inputs q, q_d, ω; output u_g.",
                                    "Adicione dinâmica do gimbal: θ_g_dot = u_g / J_g (J_g momento de inércia).",
                                    "Inclua ruído em sensores de quaternion e saturação em atuadores.",
                                    "Crie script para rodar simulação com perfil de referência (ex: slew de 90°)."
                                  ],
                                  "verification": "Execute simulação e confira que u_g rastreia erro sem overshoot excessivo.",
                                  "estimatedTime": "3 hours",
                                  "materials": "MATLAB/Simulink com Aerospace Toolbox, modelo base de spacecraft attitude.",
                                  "tips": "Use ode45 para integração numérica precisa; monitore norma do quaternion.",
                                  "learningObjective": "Codificar e integrar lei PD em ambiente de simulação dinâmica.",
                                  "commonMistakes": "Erros de sinal no erro de quaternion; esquecer integração numérica de estados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Tunar e Validar Performance",
                                  "subSteps": [
                                    "Simule cenários: passo, rampa, distúrbios (ex: gradiente gravitacional).",
                                    "Tune Kp/Kd minimizando ISE (Integral Square Error) em atitude.",
                                    "Analise métricas: tempo de estabilização <5s, overshoot <10%, erro steady-state <0.01.",
                                    "Compare com controlador P puro para validar benefício do D.",
                                    "Documente resultados em gráficos de erro vs tempo."
                                  ],
                                  "verification": "Gere relatório com plots mostrando rastreamento bem-sucedido em múltiplos testes.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": "Simulink com Signal Processing Toolbox, scripts de otimização (fmincon).",
                                  "tips": "Use root locus ou Bode para insight em tuning.",
                                  "learningObjective": "Avaliar e otimizar controlador PD para robustez em aplicações reais.",
                                  "commonMistakes": "Tunar sem considerar delays; ignorar efeitos de acoplamento entre eixos."
                                }
                              ],
                              "practicalExample": "Em um CubeSat com rodas de reação gimbaladas, implemente PD para corrigir desvio de 10° em roll causado por ejeção, rastreando quaternion desejado [1,0,0,0] para [0.98,0.14,0,0], estabilizando em 3s com erro <0.5°.",
                              "finalVerifications": [
                                "Lei PD gera torque proporcional ao erro vetorial de quaternion.",
                                "Simulação mostra settling time <5s para slew de 90°.",
                                "Overshoot em taxas de gimbal <20% do limite.",
                                "Erro steady-state em atitude <0.01 rad.",
                                "Controlador rejeita distúrbios senoidais de 0.1 Hz.",
                                "Código é modular e reutilizável para outros eixos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do erro de quaternion (nota 1-10).",
                                "Corretude da implementação PD no simulador (teste unitário passa).",
                                "Performance: ISE < threshold definido.",
                                "Robustez a variações de parâmetros (±20%).",
                                "Qualidade da documentação e plots.",
                                "Eficiência computacional (tempo de simulação <10s)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de quaternions e derivadas vetoriais.",
                                "Programação: Implementação numérica em MATLAB/Simulink.",
                                "Física: Dinâmica rotacional e momentos de inércia.",
                                "Engenharia de Sistemas: Integração sensor-atuar em loop fechado."
                              ],
                              "realWorldApplication": "Controle de atitude em satélites como o James Webb Space Telescope, onde gimbals em reaction wheels permitem pointing preciso para rastreamento de estrelas, compensando distúrbios orbitais e mantendo orientação com precisão de arcosegundos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Simular manobras de atitude",
                            "description": "Configurar simulação numérica de estabilização e manobras rápidas de atitude usando CMGs, validando com parâmetros realistas de veículos espaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros realistas do veículo espacial e CMGs",
                                  "subSteps": [
                                    "Pesquisar e selecionar parâmetros típicos de um satélite pequeno (ex: CubeSat): massa, tensor de inércia, dimensões.",
                                    "Configurar 4 CMGs em configuração piramidal: ângulos de gimbal, momento de inércia, torque máximo e velocidades limites.",
                                    "Definir condições iniciais: vetor de atitude inicial (quaternions), velocidades angulares iniciais e perturbações externas (gradiente gravitacional, pressão solar).",
                                    "Documentar todos os parâmetros em uma tabela para referência.",
                                    "Verificar consistência das unidades (SI: kg, m, rad/s)."
                                  ],
                                  "verification": "Tabela de parâmetros completa e validada contra referências reais (ex: papers da NASA).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação técnica de satélites (NASA/ESA), planilha Excel ou Jupyter Notebook"
                                  ],
                                  "tips": "Use valores conservadores para limites de CMGs para evitar singularidades.",
                                  "learningObjective": "Compreender e aplicar parâmetros físicos realistas em modelos de atitude.",
                                  "commonMistakes": [
                                    "Ignorar acoplamentos entre eixos de inércia",
                                    "Usar unidades inconsistentes (graus vs radianos)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de simulação numérica",
                                  "subSteps": [
                                    "Instalar e configurar software: MATLAB/Simulink ou Python (com NumPy, SciPy, Matplotlib).",
                                    "Implementar representação de atitude com quaternions para evitar gimbal lock.",
                                    "Criar script principal com loop de integração numérica (RK4 ou ode45 no MATLAB).",
                                    "Adicionar visualização: plot de trajetórias de atitude, velocidades angulares e comandos de CMG.",
                                    "Testar simulação vazia para verificar estabilidade numérica (dt < 0.01s)."
                                  ],
                                  "verification": "Simulação roda sem erros e plota gráficos básicos de tempo vs atitude.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python/Anaconda, tutoriais de integração numérica"
                                  ],
                                  "tips": "Comece com dt pequeno para precisão; otimize depois.",
                                  "learningObjective": "Dominar ferramentas numéricas para simulações dinâmicas espaciais.",
                                  "commonMistakes": [
                                    "Escolha inadequada de integrador levando a instabilidade",
                                    "Normalização incorreta de quaternions"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar dinâmica de atitude e controle com CMGs",
                                  "subSteps": [
                                    "Codificar equações de Euler rígido: derivada de quaternions e velocidades angulares.",
                                    "Modelar cinemática de CMGs: torque angular como função de velocidades de roda e gimbal.",
                                    "Desenvolver algoritmo de controle: B-dot para desaturação inicial, seguido de LQR ou PD para estabilização.",
                                    "Implementar manobras rápidas: perfil de comando em slew (ex: polinomial cúbico para 90° em 10s).",
                                    "Adicionar lógica de steering para evitar singularidades de CMG."
                                  ],
                                  "verification": "Simulação de estabilização converge para atitude zero em <30s.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Referências: Sidi 'Spacecraft Dynamics and Control', código-fonte aberto de CMG"
                                  ],
                                  "tips": "Teste módulos isoladamente: dinâmica sem controle primeiro.",
                                  "learningObjective": "Aplicar teoria de controle não-linear em sistemas espaciais.",
                                  "commonMistakes": [
                                    "Erro na matriz de direção de CMGs",
                                    "Sobrestimar torque disponível"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações e validar resultados",
                                  "subSteps": [
                                    "Rodar cenários: estabilização de perturbação inicial e manobra rápida de 90°.",
                                    "Comparar com benchmarks reais: tempo de acrise, overshoot, uso de CMGs.",
                                    "Analisar sensibilidade: variar parâmetros e perturbações.",
                                    "Gerar relatório com métricas: RMSE de atitude, eficiência energética.",
                                    "Otimizar se necessário (tuning de ganhos)."
                                  ],
                                  "verification": "Resultados coincidem com literatura (erro <5% em métricas chave).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Dados reais de missões (ex: GOCE satellite telemetry), ferramentas de plot avançadas"
                                  ],
                                  "tips": "Salve seeds para reprodutibilidade em simulações estocásticas.",
                                  "learningObjective": "Validar modelos numéricos contra realidade física.",
                                  "commonMistakes": [
                                    "Ignorar ruído de sensores",
                                    "Validação apenas qualitativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat desestabilizado por colisão micrometeorítica: estabilize a atitude em 20 segundos e execute uma manobra de apontamento solar de 180° em 15 segundos usando 4 CMGs, plotando quaternions, ângulos de Euler e utilidade de gimbal.",
                              "finalVerifications": [
                                "Atitude estabilizada com erro <0.1° em todos eixos após 30s.",
                                "Manobra rápida completa sem overshoot >5° e tempo <15s.",
                                "Utilidade de CMGs >0.7 durante toda simulação (sem singularidade).",
                                "Energia consumida plausível (<10% da capacidade).",
                                "Gráficos mostram convergência suave e ausência de oscilações.",
                                "Validação numérica: norma de quaternion =1 e conservação de energia."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação dinâmica (erro <1% vs analítico).",
                                "Eficiência do controle (tempo de resposta e uso de atuadores).",
                                "Robustez a variações de parâmetros (±20%).",
                                "Qualidade da documentação e visualizações.",
                                "Correspondência com dados reais de veículos espaciais.",
                                "Código modular e comentado para reutilização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (quaternions, matrizes de rotação), métodos numéricos (integração ODE).",
                                "Física: Mecânica clássica (dinâmica rotacional, torques).",
                                "Programação: Simulação computacional, controle de versão (Git).",
                                "Engenharia de Controle: LQR/PD, otimização.",
                                "Física Aplicada: Perturbações orbitais (gravitacional, aerodinâmica)."
                              ],
                              "realWorldApplication": "Controle de atitude em satélites como os da constelação Starlink para manobras ágeis de comunicação, ou na Estação Espacial Internacional (ISS) para ajustes rápidos usando CMGs, evitando uso excessivo de propulsores e economizando combustível."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Torque Magnético",
                    "description": "Geração de torque através da interação de bobinas com o campo magnético terrestre.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Campo Magnético Terrestre",
                        "description": "Características e modelagem do campo magnético da Terra utilizado no controle de atitude de veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Descrever o modelo dipolo do campo magnético terrestre",
                            "description": "Explicar o modelo simplificado de dipolo magnético da Terra, incluindo inclinação, declinação e intensidade típica em órbitas baixas (LEO), com valores aproximados de 20-60 μT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos de um dipolo magnético",
                                  "subSteps": [
                                    "Estude a definição de um dipolo magnético como dois pólos magnéticos opostos separados por uma pequena distância.",
                                    "Revise as linhas de campo geradas por um dipolo, semelhantes a um ímã de barra.",
                                    "Aprenda a fórmula vetorial básica do campo magnético de um dipolo: B(r) = (μ₀ / 4π) * (3(m·r̂)r̂ - m) / r³, onde m é o momento dipolar.",
                                    "Visualize o campo em polos norte e sul do dipolo.",
                                    "Compare com o campo uniforme aproximado em grandes distâncias."
                                  ],
                                  "verification": "Desenhe ou descreva o padrão de linhas de campo de um dipolo e cite a fórmula básica corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Física (Eletromagnetismo), vídeo Khan Academy sobre dipolos magnéticos, papel e caneta para esboços"
                                  ],
                                  "tips": "Use analogias como um ímã de geladeira para visualizar melhor.",
                                  "learningObjective": "Compreender a configuração e o campo gerado por um dipolo magnético ideal.",
                                  "commonMistakes": [
                                    "Confundir dipolo magnético com dipolo elétrico",
                                    "Ignorar a dependência 1/r³ da intensidade",
                                    "Esquecer o caráter vetorial do campo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o modelo dipolo ao campo magnético terrestre",
                                  "subSteps": [
                                    "Localize o dipolo equivalente no centro da Terra, alinhado aproximadamente com o eixo de rotação.",
                                    "Identifique o polo magnético norte (próximo ao polo geográfico sul) e sul magnético.",
                                    "Estude o desalinhamento: o eixo dipolar está inclinado ~11° em relação ao eixo de rotação.",
                                    "Discuta simplificações do modelo: ignora multipólos superiores para aproximação em grandes distâncias.",
                                    "Calcule o momento dipolar da Terra: ~8 × 10²² A m²."
                                  ],
                                  "verification": "Explique por que o modelo dipolo é uma boa aproximação para o campo terrestre em altitudes elevadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mapa do campo magnético terrestre (NOAA), calculadora, software como MATLAB ou Python para fórmulas"
                                  ],
                                  "tips": "Lembre-se: o 'norte magnético' aponta para o polo sul magnético devido à convenção.",
                                  "learningObjective": "Modelar o campo magnético da Terra como um dipolo central.",
                                  "commonMistakes": [
                                    "Confundir pólos magnéticos com geográficos",
                                    "Subestimar o desalinhamento axial",
                                    "Esquecer que a Terra tem um dipolo dominante mas não perfeito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever parâmetros chave: inclinação, declinação e intensidade",
                                  "subSteps": [
                                    "Defina declinação magnética: ângulo entre norte geográfico e norte magnético (varia de -25° a +25°).",
                                    "Explique inclinação magnética: ângulo do vetor B com o horizonte (90° nos polos, 0° no equador).",
                                    "Cite intensidade típica na superfície: ~25-65 μT; em LEO (~400-1000 km): 20-60 μT devido a 1/r³.",
                                    "Use coordenadas geográficas para expressar B em componentes: radial, norte e leste.",
                                    "Pratique cálculo aproximado de |B| no equador: B_eq ≈ (μ₀ / 4π) * M / R³ ≈ 30 μT."
                                  ],
                                  "verification": "Forneça valores aproximados e defina declinação e inclinação com exemplos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Modelos IGRF online, tabela de valores magnéticos, Python com biblioteca geomag"
                                  ],
                                  "tips": "Use apps como World Magnetic Model para valores reais em latitudes específicas.",
                                  "learningObjective": "Quantificar e qualificar os parâmetros do modelo dipolo terrestre.",
                                  "commonMistakes": [
                                    "Confundir declinação com inclinação",
                                    "Usar valores de superfície para LEO sem ajuste",
                                    "Ignorar variação latitudinal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contextualizar em órbitas baixas (LEO) e verificar o modelo",
                                  "subSteps": [
                                    "Calcule a redução de intensidade em LEO: fator (R_terra / (R_terra + h))³.",
                                    "Discuta limitações: erros de 10-20% devido a multipólos e assimetrias.",
                                    "Simule variação do campo ao longo de uma órbita polar.",
                                    "Compare com dados reais de satélites como Swarm.",
                                    "Avalie aplicações: previsão de torque magnético B × m."
                                  ],
                                  "verification": "Estime |B| em LEO equatorial e polar, justificando diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador online de campo magnético (ex: NOAA), dados de missão Swarm (ESA)"
                                  ],
                                  "tips": "Foquem em raios: R_terra = 6371 km, LEO h=400 km → r=6771 km.",
                                  "learningObjective": "Aplicar o modelo a cenários espaciais reais como LEO.",
                                  "commonMistakes": [
                                    "Não ajustar para altitude",
                                    "Assumir campo uniforme em órbita",
                                    "Ignorar rotação da Terra"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python, calcule e plote o vetor B em um ponto LEO (0° lat, 400 km alt): implemente a fórmula dipolo com M=8e22 Am², compare com valor real ~40 μT e discuta declinação zero no equador.",
                              "finalVerifications": [
                                "Descreva corretamente a fórmula do campo dipolo e seus componentes.",
                                "Cite valores aproximados de intensidade em LEO (20-60 μT).",
                                "Explique diferenças entre declinação e inclinação com exemplos.",
                                "Justifique o uso do modelo dipolo para controle de atitude em satélites.",
                                "Identifique limitações do modelo em altitudes baixas.",
                                "Calcule |B| em um ponto específico com erro <20%."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de dipolo, parâmetros e fórmulas (30%).",
                                "Uso de valores numéricos aproximados e consistentes (25%).",
                                "Clareza na explicação de variações espaciais (20%).",
                                "Integração de contexto aeroespacial/LEO (15%).",
                                "Identificação de erros comuns e limitações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física (Eletromagnetismo: campos vetoriais e momentos dipolares).",
                                "Matemática (Vetores, coordenadas esféricas e cálculo de gradientes).",
                                "Geofísica (Modelos do interior da Terra e magnetosfera).",
                                "Engenharia Aeroespacial (Controle de atitude via magnetotorquers).",
                                "Informática (Simulações numéricas em Python/MATLAB)."
                              ],
                              "realWorldApplication": "Em satélites CubeSat em LEO, o modelo dipolo é usado para prever o campo magnético e dimensionar magnetotorquers (bobinas que geram torque τ = m × B), permitindo controle de atitude passivo e eficiente sem propelentes, como na missão CubeSat da NASA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Calcular a intensidade do campo magnético em órbita",
                            "description": "Aplicar fórmulas para determinar o vetor B (campo magnético) em função da posição orbital, considerando modelo IGRF ou dipolo, e discutir variações com altitude e latitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Modelo de Dipolo Magnético da Terra",
                                  "subSteps": [
                                    "Estudar a representação do campo magnético terrestre como um dipolo centrado no núcleo da Terra.",
                                    "Memorizar a fórmula do campo magnético dipolar: B(r, θ) = (μ₀ / 4π) * (3(m · r̂)r̂ - m) / r³, onde m é o momento dipolar.",
                                    "Converter coordenadas geográficas (latitude, longitude) para coordenadas esféricas (r, θ, φ).",
                                    "Calcular manualmente o módulo e direção de B na superfície terrestre para latitude 0° e 90°.",
                                    "Discutir o momento dipolar da Terra (aprox. 8 × 10²² A m²) e unidades (nT)."
                                  ],
                                  "verification": "Resolver 3 exercícios simples de cálculo dipolar e comparar resultados com valores tabelados (erro <5%).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Física Espacial (ex: 'Introduction to Space Dynamics' de Thomson)",
                                    "Calculadora ou Python com NumPy",
                                    "Tabelas de campo magnético terrestre"
                                  ],
                                  "tips": "Sempre normalize vetores unitários corretamente; use convenções de coordenadas geo-magnéticas.",
                                  "learningObjective": "Compreender e aplicar o modelo dipolar simplificado para estimar B em baixas altitudes.",
                                  "commonMistakes": [
                                    "Confundir coordenadas geográficas com magnéticas",
                                    "Esquecer o fator 1/r³ na dependência radial",
                                    "Ignorar a inclinação dipolar (~11° do eixo de rotação)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Modelo IGRF e Fontes de Dados",
                                  "subSteps": [
                                    "Explicar o International Geomagnetic Reference Field (IGRF) como modelo de harmônicos esféricos até grau 13.",
                                    "Acessar coeficientes IGRF online (NOAA ou Python library como 'igrf' ou 'pymag' ).",
                                    "Entender a expansão em harmônicos: B = soma de termos gaussianos para componentes norte, leste, vertical.",
                                    "Implementar função básica em Python para calcular B em uma posição ECEF (Earth-Centered Earth-Fixed).",
                                    "Comparar resultados IGRF vs. dipolo para altitudes de 0-1000 km."
                                  ],
                                  "verification": "Gerar gráfico comparativo de |B| vs. altitude equatorial usando IGRF e dipolo (similaridade >90% em baixa altitude).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com bibliotecas: numpy, matplotlib, igrf-python",
                                    "Site NOAA IGRF calculator",
                                    "Documentação IGRF"
                                  ],
                                  "tips": "Use bibliotecas prontas para evitar erros em coeficientes; valide com calculadora online.",
                                  "learningObjective": "Selecionar e aplicar o modelo IGRF para cálculos precisos de B orbital.",
                                  "commonMistakes": [
                                    "Usar coeficientes errados para época (IGRF é época-dependente)",
                                    "Confundir unidades de entrada (km vs. m)",
                                    "Não converter para coordenadas corretas (GEI vs. ECEF)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Vetor B para Posições Orbitais Específicas",
                                  "subSteps": [
                                    "Definir posição orbital em coordenadas Keplerianas (a, e, i, Ω, ω, ν) e converter para cartesianas ECEF.",
                                    "Aplicar modelo escolhido (dipolo ou IGRF) para computar vetor B = (Bx, By, Bz).",
                                    "Implementar script Python para propagar órbita e calcular B ao longo de um período orbital.",
                                    "Calcular intensidade |B| = sqrt(Bx² + By² + Bz²) e componentes em frame orbital (ORB).",
                                    "Validar com dados de satélites reais (ex: Swarm mission da ESA)."
                                  ],
                                  "verification": "Calcular B para satélite em LEO (400 km, i=51.6°) e comparar com dados reais (erro <10 nT).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com Orekit ou poliastro para propagação orbital",
                                    "Dados Swarm/IGRF",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use frames de referência consistentes (TEME ou ITRF); plote trajetórias 3D para visualização.",
                                  "learningObjective": "Computar vetor B preciso para qualquer posição orbital usando ferramentas computacionais.",
                                  "commonMistakes": [
                                    "Erro na propagação orbital (esquecer precessão)",
                                    "Transformação incorreta de frames (ECEF para ORB)",
                                    "Unidades inconsistentes em r (RE vs. km)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Variações com Altitude e Latitude",
                                  "subSteps": [
                                    "Gerar mapas de |B| vs. altitude (100-2000 km) para diferentes latitudes (0°, 45°, 90°).",
                                    "Discutir dependências: |B| ~ 1/r³ para dipolo, anomalias em IGRF devido a litosfera.",
                                    "Analisar efeitos diurnos/seculares e impacto em torque magnético (m × B).",
                                    "Simular variação temporal usando IGRF para diferentes épocas.",
                                    "Interpretar resultados: fraqueza em equador (~20k nT superfície -> ~10k nT LEO) vs. polos."
                                  ],
                                  "verification": "Produzir relatório com gráficos e conclusões sobre variações (cobrir 3 altitudes x 3 latitudes).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python/Matplotlib para plots",
                                    "Dados IGRF históricos",
                                    "Artigos sobre campo magnético orbital"
                                  ],
                                  "tips": "Normalize por RE (raio equatorial ~6371 km); foque em tendências qualitativas primeiro.",
                                  "learningObjective": "Interpretar e discutir como altitude e latitude afetam B em contextos de controle de atitude.",
                                  "commonMistakes": [
                                    "Ignorar não-dipolaridade em altas latitudes",
                                    "Confundir variação diurna com orbital",
                                    "Escala errada nos gráficos (nT vs. µT)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um satélite em órbita LEO (407 km, inclinação 51.6°, como ISS): use IGRF para calcular B em posição (latitude 0°, altitude 407 km), obtendo |B| ≈ 25 µT apontando ~60° do nadir; implemente em Python e plote variação orbital.",
                              "finalVerifications": [
                                "Calcula B dipolar e IGRF para 5 posições orbitais com erro <5%.",
                                "Gera gráficos de |B| vs. altitude/latitude concordando com literatura.",
                                "Explica qualitativamente variações (ex: mais fraco no equador, mais forte nos polos).",
                                "Implementa script reutilizável para propagação e cálculo de B.",
                                "Discute limitações dos modelos em relatório curto.",
                                "Valida resultados com dados reais de missões (Swarm, GOCE)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erros <10% vs. referências.",
                                "Completude da implementação: todos componentes de B corretos.",
                                "Análise qualitativa: discute variações físicas adequadamente.",
                                "Uso de ferramentas: código limpo, comentado e reproduzível.",
                                "Interpretação: conecta a torque magnético em controle de atitude.",
                                "Criatividade: inclui visualizações ou extensões (ex: animação orbital)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletromagnetismo e magnetostática (fórmulas dipolares).",
                                "Matemática: Álgebra vetorial, coordenadas esféricas e harmônicos esféricos.",
                                "Programação: NumPy/SciPy para simulações numéricas e visualização.",
                                "Engenharia Aeroespacial: Dinâmica orbital e controle de atitude.",
                                "Geofísica: Modelos do campo magnético terrestre e dados espaciais."
                              ],
                              "realWorldApplication": "Em satélites como CubeSats ou ISS, calcular B orbital é essencial para sistemas de controle de atitude magnético-torquer (MTQ), que usam magnetômetros para medir B e gerar torque corretivo m × B, economizando propelente e estabilizando orientação para missões científicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Analisar variações temporais e espaciais do campo B",
                            "description": "Identificar efeitos como rotação diurna, anomalias regionais (ex: Anomalia do Atlântico Sul) e perturbações seculares que impactam o torque magnético.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Variações Temporais do Campo Magnético Terrestre",
                                  "subSteps": [
                                    "Estudar o conceito de rotação diurna e seu efeito na componente horizontal do campo B.",
                                    "Analisar variações diurnas causadas pela ionosfera e indução no solo.",
                                    "Explorar perturbações seculares, como mudanças no dipolo magnético ao longo de décadas.",
                                    "Coletar dados históricos de modelos como IGRF para variações temporais.",
                                    "Plotar gráficos de B(t) para diferentes componentes (Bx, By, Bz)."
                                  ],
                                  "verification": "Gerar um gráfico mostrando variação diurna de B em um local fixo ao longo de 24 horas.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Modelo IGRF (software Python com pyIGRF ou MATLAB), dados NOAA, planilha para gráficos.",
                                  "tips": "Use coordenadas geográficas fixas para isolar efeito diurno da rotação terrestre.",
                                  "learningObjective": "Identificar e quantificar como variações temporais afetam a magnitude e direção de B.",
                                  "commonMistakes": "Confundir variações diurnas com sazonais; ignorar convenções de coordenadas geográficas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Variações Espaciais e Anomalias Regionais",
                                  "subSteps": [
                                    "Mapear o campo B usando modelo gaussiano esférico e resíduos não-dipolares.",
                                    "Estudar a Anomalia do Atlântico Sul (SAA) como região de campo fraco.",
                                    "Identificar outras anomalias, como na Sibéria, e suas causas (fluxo no núcleo terrestre).",
                                    "Calcular gradientes espaciais de B em mapas globais.",
                                    "Visualizar isolinhas de intensidade B em projeção Mollweide."
                                  ],
                                  "verification": "Produzir um mapa global destacando a SAA com valores de B < 20.000 nT.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Software GIS (QGIS ou Python com Cartopy), dados IGRF atualizados, tutoriais NOAA.",
                                  "tips": "Foquem em altitude baixa (LEO) para relevância aeroespacial; normalize por latitude.",
                                  "learningObjective": "Reconhecer padrões espaciais não-uniformes no campo B terrestre.",
                                  "commonMistakes": "Negligenciar dependência de altitude; usar dados desatualizados para SAA em expansão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar Impacto das Variações no Torque Magnético",
                                  "subSteps": [
                                    "Recordar fórmula do torque magnético: τ = m × B, onde m é dipolo do satélite.",
                                    "Calcular variação de τ devido a mudanças em |B| e direção durante rotação diurna.",
                                    "Simular efeito da SAA em τ para uma órbita polar equatorial.",
                                    "Incorporar perturbações seculares em simulações de longo prazo.",
                                    "Derivar Jacobiano de τ em relação a variações de B para controle."
                                  ],
                                  "verification": "Computar e plotar τ ao longo de uma órbita, mostrando picos na SAA.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB/Simulink ou Python (NumPy/SciPy), modelo orbital simplificado (SGP4).",
                                  "tips": "Assuma m alinhado com eixo de atitude; teste sensibilidades com ±10% em B.",
                                  "learningObjective": "Quantificar como variações de B induzem torques perturbadores em veículos espaciais.",
                                  "commonMistakes": "Esquecer vetorização (τ depende de ângulo entre m e B); unidades inconsistentes (nT vs T)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Integrar Análise Completa",
                                  "subSteps": [
                                    "Integrar modelos IGRF em simulador de atitude com variações temporais/espaciais.",
                                    "Executar simulação de 1 órbita considerando rotação diurna e SAA.",
                                    "Analisar Fourier de τ para componentes diurnas e seculares.",
                                    "Comparar com dados reais de missões (ex: Swarm satellites).",
                                    "Otimizar modelo ajustando parâmetros para dados observados."
                                  ],
                                  "verification": "Relatório com simulação mostrando erro <5% vs dados reais em região SAA.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Simulador Orekit/Python (poliastro), dados ESA Swarm, Jupyter Notebook.",
                                  "tips": "Use propagador numérico Runge-Kutta para dinâmica; valide em múltiplas altitudes.",
                                  "learningObjective": "Aplicar análise integrada para prever torques em cenários reais.",
                                  "commonMistakes": "Sobrestimar efeitos ionosféricos sem dados; não sincronizar tempo UTC com modelo."
                                }
                              ],
                              "practicalExample": "Em uma simulação de satélite CubeSat em órbita LEO (400 km), analisar como o passage sobre a Anomalia do Atlântico Sul durante rotação diurna causa um torque magnético de até 10^{-5} Nm, desestabilizando a atitude em 2 graus, exigindo compensação por magnetotorquers.",
                              "finalVerifications": [
                                "Plotar corretamente variação diurna de B em localização fixa.",
                                "Identificar e localizar SAA em mapa global com valores precisos.",
                                "Calcular torque magnético com variação >20% devido a anomalias.",
                                "Simular órbita com impacto temporal/espacial em τ < erro de 5%.",
                                "Explicar perturbações seculares em relatório com dados IGRF.",
                                "Comparar simulação com dados reais de satélites Swarm."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de variações (diurna, secular, espacial): 25%.",
                                "Correção nos cálculos de torque (vetorial, unidades): 25%.",
                                "Qualidade de visualizações e simulações (gráficos claros, código comentado): 20%.",
                                "Análise de impactos em controle de atitude: 15%.",
                                "Uso adequado de modelos IGRF e dados reais: 10%.",
                                "Relatório coeso com conclusões acionáveis: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Física (Eletromagnetismo): Dipolo magnético e torque.",
                                "Matemática (Análise Numérica): Modelagem gaussiana e FFT.",
                                "Geofísica: Dinâmica do núcleo terrestre e anomalias.",
                                "Engenharia de Controle: Compensação de perturbações em sistemas dinâmicos.",
                                "Ciência de Dados: Análise e visualização de dados espaciais/temporais."
                              ],
                              "realWorldApplication": "No controle de atitude de satélites como os da constelação Starlink ou missões ESA Swarm, análise de variações de B permite calibrar magnetotorquers para mitigar torques na SAA, evitando perda de pointing e estendendo vida útil da missão em anos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Bobinas de Torque Magnético (Magnetorquers)",
                        "description": "Princípios de funcionamento e configuração de atuadores magnéticos para geração de dipolos magnéticos controlados.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Descrever a configuração de bobinas ortogonais",
                            "description": "Explicar o arranjo típico de três bobinas ortogonais em um satélite, com dimensões e número de espiras para gerar dipolos independentes nos eixos x, y, z.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Bobinas de Torque Magnético",
                                  "subSteps": [
                                    "Estude o princípio de operação das bobinas de torque magnético (magnetorquers) em satélites, focando na interação com o campo magnético terrestre.",
                                    "Revise conceitos de dipolo magnético e torque magnético usando a fórmula M × B, onde M é o momento magnético e B o campo magnético.",
                                    "Identifique a necessidade de três bobinas para controle em 3 eixos (roll, pitch, yaw).",
                                    "Analise diagramas básicos de bobinas em satélites, destacando a independência dos eixos.",
                                    "Resuma em suas palavras por que bobinas ortogonais são essenciais para controle de atitude."
                                  ],
                                  "verification": "Crie um resumo de 100 palavras explicando o papel das bobinas e confirme com uma autoavaliação ou quiz online.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de dinâmica de satélites, vídeo tutorial sobre magnetorquers (ex: YouTube NASA), calculadora.",
                                  "tips": "Use analogias como um ímã de geladeira interagindo com o campo da Terra para visualizar o torque.",
                                  "learningObjective": "Compreender o princípio físico por trás das bobinas ortogonais e sua aplicação em controle de atitude.",
                                  "commonMistakes": "Confundir torque magnético com força magnética; ignorar a dependência do campo terrestre variável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Configuração Geométrica Ortogonal",
                                  "subSteps": [
                                    "Desenhe os eixos x, y, z de um satélite e posicione bobinas ortogonais: uma ao longo de x, y e z.",
                                    "Estude arranjos típicos em CubeSats (ex: bobinas planas ou cilíndricas montadas perpendicularmente).",
                                    "Verifique ortogonalidade: vetores de momento magnético devem ser mutuamente perpendiculares (ângulo 90°).",
                                    "Simule rotação das bobinas para alinhamento com o campo magnético.",
                                    "Documente dimensões típicas: ex. 10 cm x 10 cm por bobina em um CubeSat 1U."
                                  ],
                                  "verification": "Desenhe e rotule um diagrama 3D das bobinas ortogonais e verifique ângulos com software como GeoGebra.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis ou software de desenho (SketchUp, Blender), diagramas de CubeSats online.",
                                  "tips": "Visualize as bobinas como eixos de um sistema cartesiano para facilitar a compreensão da independência.",
                                  "learningObjective": "Dominar o arranjo espacial das bobinas para gerar dipolos independentes nos três eixos.",
                                  "commonMistakes": "Posicionar bobinas paralelamente em vez de ortogonalmente; ignorar simetria do satélite."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar Parâmetros Elétricos e Magnéticos",
                                  "subSteps": [
                                    "Calcule o momento magnético M = N * I * A, onde N é número de espiras, I corrente, A área da bobina.",
                                    "Pesquise valores típicos: N=100-500 espiras, I=0.5-2A, A=0.01 m² para CubeSats.",
                                    "Discuta independência: corrente em uma bobina afeta apenas seu eixo devido à ortogonalidade.",
                                    "Simule cenários com diferentes N e dimensões usando planilhas Excel ou Python.",
                                    "Otimize parâmetros para torque desejado (ex: 10 mNm) no campo magnético orbital."
                                  ],
                                  "verification": "Realize cálculos para um caso exemplo e compare com especificações reais de magnetorquers comerciais.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Planilha Excel ou Python (biblioteca NumPy), datasheet de magnetorquers (ex: CubeSatShop).",
                                  "tips": "Comece com unidades SI consistentes para evitar erros em cálculos de M.",
                                  "learningObjective": "Calcular e especificar dimensões, espiras e correntes para dipolos independentes.",
                                  "commonMistakes": "Esquecer fator de área vetorial; superestimar corrente sem considerar limitações de potência do satélite."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Descrever a Configuração Completa",
                                  "subSteps": [
                                    "Compile uma descrição textual completa: arranjo, dimensões (ex: 10x10cm), N=300 espiras por bobina.",
                                    "Crie um diagrama anotado com legendas para cada eixo.",
                                    "Explique geração de dipolos independentes via controle de corrente seletiva.",
                                    "Teste a descrição explicando para um colega ou gravando um vídeo curto.",
                                    "Revise e refine com base em feedback ou autoavaliação."
                                  ],
                                  "verification": "Produza um relatório de 1 página com diagrama e descrição, validado contra referências padrão.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de edição (Word, LaTeX), referências como 'Spacecraft Attitude Determination and Control' de Wertz.",
                                  "tips": "Estruture a descrição como: introdução, geometria, parâmetros, independência, conclusão.",
                                  "learningObjective": "Articular uma descrição precisa e completa da configuração de bobinas ortogonais.",
                                  "commonMistakes": "Omitir unidades ou valores numéricos; não enfatizar independência dos eixos."
                                }
                              ],
                              "practicalExample": "Em um CubeSat 3U como o PocketQube, configure três bobinas ortogonais de 8x8 cm, 400 espiras cada, com corrente máxima de 1A. Ao energizar apenas a bobina x com 0.5A, gera M_x = 400*0.5*0.0064 ≈ 1.28 Am², produzindo torque apenas no eixo x para correção de roll, independente de y e z.",
                              "finalVerifications": [
                                "Pode desenhar corretamente o arranjo 3D das bobinas ortogonais?",
                                "Calcula com precisão o momento magnético para valores dados?",
                                "Explica verbalmente a independência dos dipolos nos eixos x, y, z?",
                                "Identifica dimensões e espiras típicas para CubeSats?",
                                "Simula um cenário de controle de atitude usando as bobinas?",
                                "Compara com configurações reais de missões espaciais?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição geométrica e ortogonalidade (30%)",
                                "Correção nos cálculos de parâmetros elétricos/magnéticos (25%)",
                                "Clareza e completude da explicação de independência (20%)",
                                "Uso de exemplos numéricos e diagramas (15%)",
                                "Conexão com aplicações reais em satélites (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletromagnetismo e vetores (lei de Biot-Savart para dipolos)",
                                "Matemática: Álgebra linear (matrizes de rotação e vetores ortogonais)",
                                "Engenharia Elétrica: Design de bobinas e controle de potência",
                                "Programação: Simulação em Python/MATLAB para modelagem de torque"
                              ],
                              "realWorldApplication": "Em missões CubeSat como as da NASA ou Planet Labs, bobinas ortogonais permitem controle de atitude passivo e de baixo custo, estabilizando o satélite para imagens da Terra sem propelentes, economizando massa e energia em órbitas LEO."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Relacionar corrente elétrica ao momento dipolar magnético",
                            "description": "Derivar e aplicar a fórmula m = N * I * A * n, onde N é número de espiras, I corrente, A área da bobina e n vetor unitário normal, calculando valores típicos para CubeSats.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de momento dipolar magnético e corrente em loops",
                                  "subSteps": [
                                    "Estude a definição de momento dipolar magnético para uma corrente elétrica em um loop: m = I * A * n.",
                                    "Revise a lei de Biot-Savart para entender o campo magnético gerado por uma corrente.",
                                    "Analise diagramas de um loop retangular ou circular carregado com corrente.",
                                    "Identifique os fatores que influenciam o momento: intensidade da corrente (I), área (A) e direção normal (n).",
                                    "Pratique cálculos simples de área vetorial para loops planos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como uma corrente em um loop cria um dipolo magnético equivalente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de eletromagnetismo (ex: Griffiths)",
                                    "Vídeos Khan Academy sobre dipolos magnéticos",
                                    "Papel e lápis para diagramas"
                                  ],
                                  "tips": "Visualize o loop como um pequeno ímã de barra para intuitividade.",
                                  "learningObjective": "Compreender a origem física do momento dipolar de uma corrente em um loop.",
                                  "commonMistakes": "Confundir momento magnético com campo magnético; ignorar a direção vetorial de n."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a fórmula para uma única espira",
                                  "subSteps": [
                                    "Comece com a definição vetorial: m = I ∫ dA (integral sobre a área do loop).",
                                    "Para loops planos, simplifique para m = I * A * n, onde A é a área escalar e n o vetor unitário normal pela regra da mão direita.",
                                    "Derive matematicamente usando vetores: prove que para loop fechado, resulta em dipolo.",
                                    "Calcule numericamente para um loop circular de raio r: A = π r².",
                                    "Teste com exemplo: I=1A, A=0.01 m², |m|=0.01 A m²."
                                  ],
                                  "verification": "Derive a fórmula m = I A n em um papel e verifique com equações padrão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno de derivadas",
                                    "Software simbólico como SymPy ou Wolfram Alpha",
                                    "Referência: Halliday Resnick Física"
                                  ],
                                  "tips": "Use a regra da mão direita consistentemente para definir n.",
                                  "learningObjective": "Derivar analiticamente o momento dipolar para uma espira única.",
                                  "commonMistakes": "Esquecer o sinal da corrente ou direção errada de n; confundir A escalar com vetor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Generalizar para bobina com N espiras",
                                  "subSteps": [
                                    "Explique que para N espiras idênticas e coincidentes, m_total = N * m_single.",
                                    "Derive m = N I A n, assumindo espiras apertadas (aproximação de dipolo).",
                                    "Discuta efeitos de espaçamento: para bobinas longas, considerar solenoides, mas focar em bobinas planas para torque magnético.",
                                    "Calcule variação com N: ex, N=100, I=0.5A, A=0.0025 m² (5x5cm).",
                                    "Valide com simulação simples em Python ou MATLAB."
                                  ],
                                  "verification": "Mostre derivação de N espiras e calcule m para N=50, I=1A, A=0.01 m².",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy para validação",
                                    "Artigo sobre magnetorquers",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Assuma espiras perfeitamente sobrepostas para simplicidade inicial.",
                                  "learningObjective": "Estender a fórmula para múltiplas espiras em bobinas de torque.",
                                  "commonMistakes": "Multiplicar incorretamente por N sem justificar superposição; ignorar perdas resistivas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a fórmula em contexto de CubeSats",
                                  "subSteps": [
                                    "Pesquise especificações típicas de CubeSats: dimensões 10x10cm (1U), bobinas ~5x5cm, N=100-500, I máx=0.5-2A.",
                                    "Calcule m típico: ex, N=200, I=1A, A=0.002 m² (4x5cm), |m|~0.4 A m².",
                                    "Compare com requisitos de torque: B terrestre ~30-60 μT, torque = m x B ~ 10^{-5} Nm.",
                                    "Simule variação de I para controle: m proporcional a I.",
                                    "Avalie limitações: saturação, aquecimento (P = I² R)."
                                  ],
                                  "verification": "Produza tabela com 3 cálculos de m para parâmetros CubeSat variados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados CubeSat (NASA ou papers)",
                                    "Excel ou Python para tabelas",
                                    "Simulador online de campo magnético"
                                  ],
                                  "tips": "Use unidades SI consistentes: A m² para m.",
                                  "learningObjective": "Calcular e interpretar valores realistas para magnetorquers em CubeSats.",
                                  "commonMistakes": "Usar unidades erradas (ex: cm² em vez de m²); superestimar I sem considerar bateria."
                                }
                              ],
                              "practicalExample": "Para um CubeSat 1U com bobina de torque de N=250 espiras, área A=25 cm² (0.0025 m²), corrente I=0.8 A e n ao longo do eixo Z: m_z = 250 * 0.8 * 0.0025 * 1 = 0.5 A m². Isso gera torque τ = m × B ≈ 1.5 × 10^{-5} Nm em órbita baixa (B=50 μT), suficiente para correções de atitude lentas.",
                              "finalVerifications": [
                                "Deriva corretamente m = N I A n de conceitos básicos.",
                                "Calcula m com precisão para parâmetros dados (erro <5%).",
                                "Explica direção de n usando regra da mão direita.",
                                "Identifica valores típicos CubeSat (m ~0.1-1 A m²).",
                                "Discute limitações como saturação e potência.",
                                "Simula variação de m com I em código simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (fórmula e passos).",
                                "Correção em cálculos numéricos e unidades.",
                                "Compreensão conceitual (explicação física).",
                                "Aplicação contextual a CubeSats (valores realistas).",
                                "Clareza em diagramas e vetores.",
                                "Identificação de erros comuns e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores, integrais de linha e produtos vetoriais.",
                                "Engenharia Elétrica: Circuitos, resistência e potência em bobinas.",
                                "Programação: Simulações NumPy/MATLAB para dinâmica de atitude.",
                                "Física: Interação dipolo-campo (energia potencial -m·B).",
                                "Ciência de Materiais: Núcleos ferromagnéticos para amplificação."
                              ],
                              "realWorldApplication": "Em CubeSats como o PocketQube ou missões universitárias (ex: ESTCube-1), magnetorquers usam m = N I A n para desaturação de rodas de reação e controle de atitude passivo, economizando massa e energia sem propelentes, essencial para missões de baixo custo em órbita LEO."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Avaliar limitações de potência e saturação",
                            "description": "Discutir restrições de corrente máxima devido a aquecimento (I²R) e limites de dipolo para evitar saturação em campos B fortes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender dissipação de potência em bobinas de torque magnético",
                                  "subSteps": [
                                    "Explicar o conceito de perdas Joule (I²R) em bobinas resistivas.",
                                    "Derivar a fórmula de potência dissipada P = I²R, identificando componentes: corrente I, resistência R.",
                                    "Discutir impactos térmicos: aquecimento leva a degradação de isolantes e redução de eficiência.",
                                    "Analisar fatores que afetam R: comprimento do fio, seção transversal, material (cobre típico).",
                                    "Calcular R aproximada para uma bobina típica de magnetorquer em CubeSat (ex: 100 espiras, fio AWG 28)."
                                  ],
                                  "verification": "Derivar e calcular P para I=1A e R=10Ω, resultando em 10W, e explicar implicações térmicas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para cálculos",
                                    "Folha de dados de fio AWG",
                                    "Texto sobre eletromagnetismo (ex: Griffiths)"
                                  ],
                                  "tips": "Sempre use unidades SI consistentes (A, Ω, W) para evitar erros de escala.",
                                  "learningObjective": "Entender as origens físicas da dissipação de potência e sua relação com aquecimento.",
                                  "commonMistakes": "Confundir potência dissipada com potência elétrica total; ignorar variação de R com temperatura."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar limite de corrente máxima por restrições térmicas",
                                  "subSteps": [
                                    "Definir orçamento térmico: limite de temperatura T_max (ex: 80°C para eletrônicos espaciais).",
                                    "Modelar equilíbrio térmico: P = h*A*(T - T_amb), onde h é coeficiente de convecção, A área superficial.",
                                    "Resolver para I_max = sqrt( (h*A*(T_max - T_amb)) / R ).",
                                    "Considerar radiação no vácuo espacial: P = ε*σ*A*(T^4 - T_amb^4).",
                                    "Simular variação com duty cycle (ligado/desligado) para controle de atitude."
                                  ],
                                  "verification": "Calcular I_max para bobina com R=5Ω, h*A=0.5 W/K, T_max=80°C, T_amb=0°C, obtendo ~1.58A.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Excel ou script Python para simulação térmica",
                                    "Dados térmicos de CubeSats (NASA reports)",
                                    "Software como Thermal Desktop (opcional)"
                                  ],
                                  "tips": "Inclua fator de segurança 1.5-2x para picos de corrente em manobras.",
                                  "learningObjective": "Calcular quantitativamente o limite de corrente baseado em análise térmica.",
                                  "commonMistakes": "Negligenciar radiação espacial vs. convecção terrestre; superestimar h em vácuo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar saturação magnética no núcleo do dipolo",
                                  "subSteps": [
                                    "Definir momento de dipolo m = N * I * A, onde N=espiras, A=área.",
                                    "Explicar saturação: B = μ*H até B_sat ~1.5-2T para ferromagnetos (ex: permalloy).",
                                    "Relacionar com campo externo B_ext: saturação quando H_int > H_sat, m efetivo limitado.",
                                    "Calcular m_max = (B_sat / μ0) * Volume_núcleo, aproximando para núcleos moles.",
                                    "Plotar curva B-H e identificar ponto de saturação para campos B fortes (ex: 50μT equatorial)."
                                  ],
                                  "verification": "Para N=200, A=0.01m², I_max=1A sem saturação, mas limitar m a 0.1 Am² para B=60μT.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Gráficos B-H de materiais magnéticos (datasheets)",
                                    "MATLAB ou Python (matplotlib) para curvas",
                                    "Modelo IGRF para campo magnético terrestre"
                                  ],
                                  "tips": "Use μ_r efetivo que cai perto da saturação; teste com simulações FEMM gratuitas.",
                                  "learningObjective": "Compreender e quantificar o limite de dipolo devido à saturação magnética.",
                                  "commonMistakes": "Assumir m linear ilimitado; ignorar histerese em ciclos rápidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar limitações de potência e saturação para avaliação completa",
                                  "subSteps": [
                                    "Comparar I_max_térmico vs. I_max_saturação e tomar o mínimo.",
                                    "Avaliar trade-offs: mais espiras reduzem I mas aumentam R e massa.",
                                    "Simular performance em órbita LEO: torque m x B vs. limites.",
                                    "Otimizar design: calcular eficiência torque/potência.",
                                    "Documentar relatório com gráficos de I vs. T e m vs. B."
                                  ],
                                  "verification": "Produzir tabela comparativa de limites para dois designs de magnetorquer, recomendando o viável.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software de simulação orbital (ex: GMAT ou STK trial)",
                                    "Python para otimização (scipy.optimize)",
                                    "Templates de relatório em LaTeX"
                                  ],
                                  "tips": "Considere variações orbitais de B (polar vs. equatorial) para worst-case.",
                                  "learningObjective": "Avaliar limitações combinadas e propor designs otimizados.",
                                  "commonMistakes": "Não considerar duty cycle ou variações de B; otimizar apenas potência ignorando massa."
                                }
                              ],
                              "practicalExample": "Em um CubeSat 1U com magnetorquer de 4 bobinas ortogonais, simule operação em órbita LEO: calcule I_max=0.8A térmico (P=3.2W total, T<70°C) e m_max=0.15Am² por eixo para evitar saturação em B=40μT polar; teste torque gerado para correção de 1°/s em 10s sem exceder limites.",
                              "finalVerifications": [
                                "Calcular corretamente I_max térmico com erro <5% para caso dado.",
                                "Determinar m_max sem saturação para B_ext especificado.",
                                "Identificar limite dominante (térmico ou magnético) em cenários variados.",
                                "Simular trade-off N vs. I e justificar escolha ótima.",
                                "Explicar impactos em controle de atitude (ex: slew rate limitado)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações e cálculos (80% peso).",
                                "Compreensão conceitual de física envolvida (térmica e magnética).",
                                "Qualidade da simulação prática e gráficos gerados.",
                                "Análise de trade-offs e recomendações realistas.",
                                "Clareza na documentação e verificações finais.",
                                "Integração de contexto espacial (órbita, vácuo)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Termodinâmica (balanço de calor) e Eletromagnetismo (curvas B-H).",
                                "Engenharia Elétrica: Análise de circuitos e bobinas.",
                                "Ciência de Materiais: Propriedades magnéticas e térmicas de ferromagnetos.",
                                "Engenharia Aeroespacial: Dinâmica orbital e controle de atitude.",
                                "Matemática: Otimização não-linear e modelagem diferencial."
                              ],
                              "realWorldApplication": "Em missões CubeSat como QB50 ou MarCO, magnetorquers são usados para desaturação de rodas de reação; avaliar limites garante operação segura sem falhas térmicas ou perda de torque em campos magnéticos variáveis da Terra, otimizando vida útil e precisão de pointing."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Geração e Aplicação de Torque Magnético",
                        "description": "Cálculo do torque resultante e estratégias de controle de atitude usando interação m × B.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Calcular o torque magnético resultante",
                            "description": "Aplicar a equação vetorial τ = m × B, computando magnitude e direção para configurações dadas de dipolo m e campo B conhecido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os vetores dipolo magnético m e campo magnético B",
                                  "subSteps": [
                                    "Defina o dipolo magnético m como um vetor com magnitude m e direção alinhada ao eixo do dipolo.",
                                    "Explique o campo magnético B como um vetor com magnitude B e direção dada pelo problema.",
                                    "Identifique o ângulo θ entre m e B, essencial para o cálculo.",
                                    "Revise unidades: m em Am², B em Tesla (T) ou μT, torque τ em Nm.",
                                    "Esboce diagramas vetoriais para visualização"
                                  ],
                                  "verification": "Desenhe vetores m e B corretamente e identifique θ com precisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Referência de unidades SI"
                                  ],
                                  "tips": "Sempre normalize os vetores para encontrar θ usando produto escalar.",
                                  "learningObjective": "Entender a representação vetorial de m e B no contexto de torque magnético.",
                                  "commonMistakes": [
                                    "Confundir direção de m com campo gerado",
                                    "Ignorar unidades e escalas",
                                    "Não considerar orientação relativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar vetores em componentes cartesianas",
                                  "subSteps": [
                                    "Expresse m = (m_x, m_y, m_z) e B = (B_x, B_y, B_z) em coordenadas cartesianas.",
                                    "Calcule a magnitude |m| = sqrt(m_x² + m_y² + m_z²) e |B| = sqrt(B_x² + B_y² + B_z²).",
                                    "Determine o ângulo θ usando cosθ = (m · B) / (|m| |B|).",
                                    "Verifique se os vetores estão no mesmo sistema de coordenadas (ex: ECEF para aeroespacial).",
                                    "Pratique com dados numéricos de um problema simples"
                                  ],
                                  "verification": "Liste componentes corretas e magnitudes com erro <1%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou Python para vetores"
                                  ],
                                  "tips": "Use sympy ou numpy em Python para automação inicial.",
                                  "learningObjective": "Dominar decomposição vetorial para cálculos precisos.",
                                  "commonMistakes": [
                                    "Erro em raízes quadradas",
                                    "Misturar coordenadas esféricas/cartesianas",
                                    "Esquecer sinal nos componentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o produto vetorial τ = m × B",
                                  "subSteps": [
                                    "Aplique a fórmula: τ_x = m_y B_z - m_z B_y; τ_y = m_z B_x - m_x B_z; τ_z = m_x B_y - m_y B_x.",
                                    "Compute cada componente sequencialmente para evitar erros aritméticos.",
                                    "Calcule magnitude |τ| = |m| |B| sinθ, onde sinθ = sqrt(1 - cos²θ).",
                                    "Confirme com software de verificação (ex: MATLAB cross() ou Python np.cross()).",
                                    "Registre valores com precisão de 3 casas decimais"
                                  ],
                                  "verification": "Resultado do produto vetorial bate com cálculo manual e software.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software Python/MATLAB",
                                    "Tabela de fórmulas vetoriais"
                                  ],
                                  "tips": "Lembre: ordem importa, m × B = - (B × m).",
                                  "learningObjective": "Executar produto vetorial com precisão matemática.",
                                  "commonMistakes": [
                                    "Inverter sinais nos componentes",
                                    "Usar produto escalar por engano",
                                    "Arredondar prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar direção, validar e aplicar em configuração",
                                  "subSteps": [
                                    "Use a regra da mão direita para direção de τ: dedos de m para B, polegar aponta τ.",
                                    "Valide se |τ| = 0 quando m paralelo a B (θ=0° ou 180°).",
                                    "Aplique em configuração aeroespacial: dipolo de satélite em campo terrestre.",
                                    "Analise impacto no controle de atitude (rotação induzida).",
                                    "Documente relatório com diagrama final"
                                  ],
                                  "verification": "Direção correta confirmada por simulação e direção perpendicular a m e B.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de visualização 3D (ex: GeoGebra)",
                                    "Dados de campo magnético IGRF"
                                  ],
                                  "tips": "Simule em Python com matplotlib quiver para visualização.",
                                  "learningObjective": "Integrar cálculo com interpretação física e aplicação prática.",
                                  "commonMistakes": [
                                    "Direção errada na regra da mão",
                                    "Ignorar dependência em θ",
                                    "Não contextualizar em aeroespacial"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um magnetotorquer em satélite com m = (0, 0, 1000) Am² e campo magnético terrestre B = (20e-6, 30e-6, 0) T, calcule τ. Resultado esperado: τ ≈ (30, -20, 0) × 10^{-3} Nm, direção ao longo de x-y.",
                              "finalVerifications": [
                                "Calcula corretamente todos componentes de τ para exemplo dado.",
                                "Identifica magnitude e direção com erro <5%.",
                                "Explica dependência em θ e casos especiais (alinhamento).",
                                "Aplica em contexto de satélite com unidades consistentes.",
                                "Valida com software e diagrama vetorial.",
                                "Discute limitações (ex: campo não-uniforme)"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos componentes vetoriais (90%+ correto).",
                                "Correta aplicação da regra da mão direita para direção.",
                                "Uso apropriado de unidades SI e conversões.",
                                "Integração com conceitos aeroespaciais (controle de atitude).",
                                "Clareza em documentação e visualizações.",
                                "Identificação e correção de erros comuns"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra vetorial e produtos cruzados.",
                                "Engenharia Aeroespacial: Dinâmica de veículos espaciais e ADCS.",
                                "Física: Eletromagnetismo e interações dipolo-campo.",
                                "Programação: Simulações numéricas em Python/MATLAB.",
                                "Química: Magnetismo em materiais para bobinas"
                              ],
                              "realWorldApplication": "Em satélites CubeSat, magnetotorquers usam torque magnético τ = m × B para controle de atitude passivo, estabilizando orientação sem combustível, essencial para missões como Earth observation onde campo terrestre fornece B ~30-60 μT."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Implementar controle B-dot para desaturação",
                            "description": "Descrever e simular o algoritmo B-dot (m proporcional a -dB/dt) para dissipar momento angular de rodas de reação usando torque magnético.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos do Controle B-dot e Desaturação de Rodas de Reação",
                                  "subSteps": [
                                    "Estude o problema de saturação de rodas de reação em veículos espaciais: acumulação de momento angular devido a distúrbios.",
                                    "Revise o torque magnético gerado por bobinas de torque: m × B, onde m é o dipolo magnético e B o campo magnético terrestre.",
                                    "Aprenda o princípio B-dot: estimar dB/dt a partir de medições de magnetômetros e comandar m = -k * dB/dt para dissipar momento.",
                                    "Analise equações cinemáticas de atitude: ω̇ = I⁻¹ (τ_ext + τ_control), focando em τ_control magnético.",
                                    "Explore limitações: dependência do campo magnético e eficiência em órbitas LEO."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes do sistema (magnetômetro, bobinas, rodas) e explique verbalmente como B-dot desatura rodas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Spacecraft Attitude Determination and Control' (Sidi), Artigo 'B-dot controller' (PDF online), Vídeo tutorial sobre controle de atitude magnético"
                                  ],
                                  "tips": [
                                    "Use analogias terrestres como amortecedores magnéticos para visualizar dissipação.",
                                    "Anote equações chave em um caderno para referência rápida."
                                  ],
                                  "learningObjective": "Compreender teoricamente o papel do B-dot na desaturação de momentum.",
                                  "commonMistakes": [
                                    "Confundir B-dot com controle de apontamento (é apenas desaturação).",
                                    "Ignorar variação do campo B com órbita.",
                                    "Subestimar ruído em medições de magnetômetro."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Descrever o Algoritmo B-dot",
                                  "subSteps": [
                                    "Derive dB/dt: use filtro passa-baixa ou diferenças finitas finitas em amostras de B (ex: dB/dt ≈ (B(t) - B(t-Δt))/Δt).",
                                    "Defina o ganho k: escolha baseado em limites de m (m_max) e requisitos de desaturação (k = m_max / |dB/dt|_max).",
                                    "Escreva pseudocódigo: leia B, compute dB/dt, calcule m = -k * dB/dt, satura m se |m| > m_max, aplique a bobinas.",
                                    "Inclua modelo dinâmico simplificado: ḣ = -ω × h - b × m, onde h é momentum das rodas, b é campo unitário.",
                                    "Simule manualmente um ciclo orbitário com valores típicos (B ~ 30 μT LEO)."
                                  ],
                                  "verification": "Implemente pseudocódigo em papel e compute m para um B senoidal simulado; verifique se torque opõe variação de B.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Matlab/Octave para cálculos iniciais",
                                    "Modelo IGRF para campo magnético terrestre",
                                    "Folha de cálculo Excel para derivação numérica"
                                  ],
                                  "tips": [
                                    "Comece com Δt pequeno (0.1s) para precisão em dB/dt.",
                                    "Plote B vs tempo para visualizar derivada."
                                  ],
                                  "learningObjective": "Derivar algoritmo B-dot e parametrizá-lo corretamente.",
                                  "commonMistakes": [
                                    "Usar B em vez de dB/dt no comando de m.",
                                    "Não saturar m, levando a comandos irreais.",
                                    "Escolha errada de k causando oscilações."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Simulação do Controle B-dot",
                                  "subSteps": [
                                    "Configure simulador: use ODE solver (RK4) para dinâmica rígida 3D de satélite.",
                                    "Modele campo B: implemente modelo dipolo ou IGRF simplificado baseado em posição orbital.",
                                    "Adicione magnetômetro com ruído gaussiano (σ=10nT).",
                                    "Implemente rodas de reação: modelo com saturação (±0.1 Nms) e torque de desaturação via m.",
                                    "Codifique loop de controle: amostragem 10Hz, aplique m às bobinas."
                                  ],
                                  "verification": "Execute simulação inicial sem controle; confirme saturação de rodas, então ative B-dot e veja dissipação.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (SciPy ODEINT + NumPy)",
                                    "Código template de simulação de atitude (GitHub repos como 'spacecraft-dynamics')",
                                    "Ferramenta de plotagem (Matplotlib)"
                                  ],
                                  "tips": [
                                    "Modularize código: funções separadas para B-field, B-dot, dynamics.",
                                    "Use quaternions para representação de atitude sem gimbal lock."
                                  ],
                                  "learningObjective": "Implementar numericamente o algoritmo em um ambiente de simulação realista.",
                                  "commonMistakes": [
                                    "Erro de sinal em m = -k dB/dt.",
                                    "Frequência de amostragem baixa causando aliasing em dB/dt.",
                                    "Modelo de B incorreto (use coordenadas ECF)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Analisar e Otimizar a Simulação",
                                  "subSteps": [
                                    "Simule cenários: órbita LEO circular, distúrbios gravitacionais/magnéticos, saturação inicial.",
                                    "Meça métricas: tempo de desaturação, uso de rodas, erro de apontamento.",
                                    "Ajuste parâmetros: varie k, filtros em dB/dt (ex: α em filtro exponencial).",
                                    "Adicione realismo: falhas parciais de bobinas, variação orbital.",
                                    "Gere relatórios: plots de h_wheels, m, dB/dt ao longo do tempo.",
                                    "verification]: ",
                                    "estimatedTime]: "
                                  ],
                                  "verification": "Compare simulações com/sem B-dot: reduza |h| > 80% em < 1 órbita; documente em relatório.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Simulador do Step 3",
                                    "Ferramentas de análise (FFT para ruído, métricas RMS)"
                                  ],
                                  "tips": [
                                    "Teste sensibilidade: Monte Carlo com ruído variável.",
                                    "Salve seeds para reprodutibilidade."
                                  ],
                                  "learningObjective": "Analisar performance e otimizar controle B-dot.",
                                  "commonMistakes": [
                                    "Sobre-otimizar k causando inestabilidade.",
                                    "Ignorar efeitos de nutação induzida.",
                                    "Plots incompletos sem baselines."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat 3U em órbita LEO a 500km, rodas saturam após 2 dias por gradiente gravitacional. Implemente B-dot: magnetômetro TRIAD estima B, compute dB/dt a 4Hz, gera m ~ 0.2 Am² oposto à variação, dissipando h de 0.05 para <0.01 Nms em 90min.",
                              "finalVerifications": [
                                "Simulação mostra desaturação estável sem exceder limites de m.",
                                "Derivada dB/dt corretamente filtrada e proporcional a torque.",
                                "Momentum das rodas retorna a zero em <1 órbita para casos nominais.",
                                "Sistema tolera ruído de sensor ±20nT sem divergência.",
                                "Relatório inclui equações, código e plots validados."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação: erro <5% em torque vs teoria.",
                                "Robustez: performance em 5 cenários variados.",
                                "Eficiência: tempo de desaturação <2h por saturação.",
                                "Documentação: código comentado, derivações claras.",
                                "Análise: identificação de trade-offs (k vs oscilação)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Derivadas numéricas e filtros digitais.",
                                "Física: Eletromagnetismo (torque dipolo) e dinâmica orbital.",
                                "Programação: Simulação numérica e ODE solvers.",
                                "Engenharia de Controle: LQR vs bang-off-bang vs B-dot."
                              ],
                              "realWorldApplication": "Usado em CubeSats como o QB50 para desaturação autônoma, economizando propulsores; aplicado na ISS para gerenciamento de momentum via magnetotorquers, reduzindo custos operacionais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Projetar lei de controle para estabilização de atitude",
                            "description": "Desenvolver controladores proporcionais ou PD baseados em torque magnético para apontamento nadir ou estabilização, considerando não-linearidades de B.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a Dinâmica de Atitude com Torque Magnético",
                                  "subSteps": [
                                    "Derive as equações cinemáticas e dinâmicas de atitude usando quaternions ou ângulos de Euler.",
                                    "Inclua o torque de controle magnético: τ_m = m × B, onde m é o momento magnético e B o campo magnético.",
                                    "Defina o estado do sistema: vetor de atitude q e velocidades angulares ω.",
                                    "Linearize o modelo ao redor do ponto de equilíbrio (apontamento nadir ou estabilização).",
                                    "Implemente o modelo em software de simulação."
                                  ],
                                  "verification": "Verifique se as equações reproduzem corretamente a dinâmica livre (sem controle) em simulação.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB/Simulink ou Python com SciPy/NumPy; modelo de campo magnético IGRF.",
                                  "tips": "Use quaternions para evitar singularidades nos ângulos de Euler.",
                                  "learningObjective": "Compreender e formular o modelo matemático do sistema de atitude com atuadores magnéticos.",
                                  "commonMistakes": "Ignorar a dependência não-linear de B na posição orbital; confundir cinemática com dinâmica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Controlador Proporcional (P) ou PD Básico",
                                  "subSteps": [
                                    "Defina a lei de controle: m = -K_p * q_e - K_d * ω, onde q_e é erro de atitude.",
                                    "Converta o momento de controle desejado em comando de momento magnético: m = B × τ_d / ||B||^2.",
                                    "Escolha matrizes de ganho K_p e K_d iniciais via método de colocação de polos ou Ziegler-Nichols.",
                                    "Implemente a lei em loop fechado no modelo simulado.",
                                    "Teste estabilidade com análise de Lyapunov ou root locus."
                                  ],
                                  "verification": "Confirme que o controlador linear estabiliza o sistema linearizado em simulação.",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB Control System Toolbox ou Python Control Library; simulador de dinâmica.",
                                  "tips": "Comece com ganhos conservadores para evitar oscilações.",
                                  "learningObjective": "Desenvolver e implementar um controlador PD para sistemas de atitude lineares.",
                                  "commonMistakes": "Não normalizar o momento magnético pela magnitude de B; ganhos excessivos causando saturação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Não-Linearidades do Campo Magnético B",
                                  "subSteps": [
                                    "Modele B como função não-linear da posição orbital usando IGRF ou modelo dipolo.",
                                    "Adapte a lei de controle para B não constante: use estimativa de B em tempo real.",
                                    "Implemente saturação do dipolo magnético: ||m|| ≤ m_max.",
                                    "Adicione filtro ou observer para estimar direção de B.",
                                    "Analise robustez com variações de B ao longo da órbita."
                                  ],
                                  "verification": "Simule uma órbita completa e verifique se o controle compensa variações de B.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Modelo orbital SGP4/IGRF; Simulink ou Python com poliastro.",
                                  "tips": "Use B-field de modelo realista para órbitas LEO.",
                                  "learningObjective": "Lidar com não-linearidades inerentes ao torque magnético em ambientes reais.",
                                  "commonMistakes": "Assumir B constante; ignorar saturação levando a comandos irrealizáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, Validar e Ajustar o Controlador",
                                  "subSteps": [
                                    "Execute simulações com perturbações iniciais e ruídos sensoriais.",
                                    "Meça métricas: tempo de estabilização, overshoot, consumo de momento.",
                                    "Tune ganhos iterativamente para otimizar desempenho.",
                                    "Compare com baseline (sem controle) e analise sensibilidade.",
                                    "Documente o design final com parâmetros otimizados."
                                  ],
                                  "verification": "O sistema atinge erro de atitude < 5° em < 10 minutos orbitais em simulações variadas.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Ferramentas de plotagem (MATLAB/Python); scripts de Monte Carlo para robustez.",
                                  "tips": "Use automação para sweeps de parâmetros de ganho.",
                                  "learningObjective": "Validar e refinar o controlador através de simulações realistas.",
                                  "commonMistakes": "Testar apenas condições nominais; não considerar ruído de sensores."
                                }
                              ],
                              "practicalExample": "Projetar um controlador PD para um CubeSat 3U em órbita LEO (400km), usando magnetorquers de 0.2 Am² para estabilização de atitude e apontamento nadir, compensando variações de B de 20-40 μT ao longo da órbita.",
                              "finalVerifications": [
                                "Simulação mostra estabilização em < 5 minutos com erro < 2°.",
                                "Comandos de m respeitam limites de saturação.",
                                "Robustez a ±20% variação em B e ruído giroscópico.",
                                "Análise de Lyapunov confirma estabilidade global.",
                                "Consumo médio de energia < limite do satélite."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo dinâmico (erro < 1% em simulação livre).",
                                "Desempenho do controlador: tempo de settling < 10 min, overshoot < 10%.",
                                "Tratamento adequado de não-linearidades (sem divergência em órbita completa).",
                                "Eficiência: uso ótimo de atuadores magnéticos.",
                                "Documentação clara com equações, parâmetros e resultados.",
                                "Análise de sensibilidade e trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rotação), equações diferenciais não-lineares.",
                                "Física: Eletromagnetismo (interação dipolo-campo), mecânica orbital.",
                                "Programação: Implementação numérica em MATLAB/Python, simulação orientada a objetos.",
                                "Engenharia de Sistemas: Análise de robustez e trade-offs de design."
                              ],
                              "realWorldApplication": "Desenvolvimento de controladores para CubeSats como o PocketQube ou missões da NASA/ESA (ex: Swarm), onde magnetorquers são usados para desaturação de rodas de reação e apontamento preciso em constelações de satélites de observação terrestre."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.4",
                            "name": "Simular dinâmica de atitude com torque magnético",
                            "description": "Usar equações de Euler rígido (I ω̇ + ω × I ω = τ_mag) em software como MATLAB/Simulink para validar controle em órbita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e derivar as equações de Euler rígido para dinâmica de atitude",
                                  "subSteps": [
                                    "Estude as equações de Euler: I ω̇ + ω × (I ω) = τ_mag, onde I é o tensor de inércia, ω é a velocidade angular e τ_mag é o torque magnético.",
                                    "Derive o termo não-linear ω × (I ω) para entender o acoplamento dinâmico.",
                                    "Defina coordenadas de referência: body frame e inertial frame para simulação orbital.",
                                    "Calcule o tensor de inércia I para um modelo de satélite típico (ex: CubeSat 1U).",
                                    "Identifique variáveis de estado: quaternion de atitude q e ω."
                                  ],
                                  "verification": "Escreva as equações completas em um documento e resolva manualmente um exemplo simples com ω inicial não-zero.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de dinâmica de spacecraft (ex: Sidi 'Spacecraft Dynamics and Control')",
                                    "Papel e calculadora",
                                    "MATLAB para verificação simbólica (opcional)"
                                  ],
                                  "tips": "Use syms no MATLAB para derivar simbolicamente e evitar erros algébricos.",
                                  "learningObjective": "Compreender matematicamente a dinâmica de atitude com torque magnético.",
                                  "commonMistakes": [
                                    "Ignorar o termo cruzado ω × (I ω)",
                                    "Confundir frames de referência",
                                    "Assumir I diagonal sem justificar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir parâmetros do satélite e modelo orbital",
                                  "subSteps": [
                                    "Especifique propriedades: massa, dimensões, dipolo magnético dos magnetorquers, campo magnético orbital (use modelo IGRF).",
                                    "Gere o campo magnético B(t) usando modelo de órbita circular (ex: LEO a 500km).",
                                    "Calcule τ_mag = m × B, onde m é o momento magnético controlável.",
                                    "Defina condições iniciais: erro de atitude inicial de 10 graus, perturbações mínimas.",
                                    "Crie script MATLAB para gerar dados paramétricos."
                                  ],
                                  "verification": "Execute script e plote B(t) e τ_mag para uma órbita completa; verifique magnitudes realistas (τ_mag ~ 10^-5 Nm).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB",
                                    "Dados orbitais (ex: toolbox Aeroespacial)",
                                    "Referência: modelo IGRF para campo magnético"
                                  ],
                                  "tips": "Use ode45 para preview rápido de integração; normalize quaternions sempre.",
                                  "learningObjective": "Preparar dados realistas para simulação precisa.",
                                  "commonMistakes": [
                                    "Usar campo magnético constante",
                                    "Escala errada de τ_mag",
                                    "Órbita não propagada corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar as equações no MATLAB ou Simulink",
                                  "subSteps": [
                                    "Crie função de dinâmica: dX/dt = [ω; inv(I)*(τ_mag - ω × (I ω))], com X = [q; ω] e cinemática dq/dt = 0.5 * Ω(ω) q.",
                                    "Implemente controle simples: lei de torque proporcional ao erro de atitude.",
                                    "Monte modelo Simulink: blocos para dinâmica, integração, modelo B(t).",
                                    "Adicione saturação nos magnetorquers (±m_max).",
                                    "Teste com simulação de 1 órbita."
                                  ],
                                  "verification": "Rode simulação e confirme que atitude converge para <1 grau de erro sem divergir.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Aerospace Toolbox (opcional)",
                                    "Exemplos de GitHub para attitude dynamics"
                                  ],
                                  "tips": "Use quaternions modificados para evitar singularidades; debugue com plots de ω e q.",
                                  "learningObjective": "Codificar corretamente a dinâmica rígida em software.",
                                  "commonMistakes": [
                                    "Erro na matriz Ω(ω) para quaternions",
                                    "Inversão errada de I",
                                    "Não normalizar q"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações e analisar estabilidade",
                                  "subSteps": [
                                    "Simule cenários: nominal, com ruído em B(t), falha em um eixo.",
                                    "Plote trajetórias: atitude (Euler angles), ω, τ_mag ao longo do tempo.",
                                    "Calcule métricas: tempo de convergência, overshoot, RMS de erro.",
                                    "Compare com simulação sem torque (drift livre).",
                                    "Ajuste ganhos de controle para otimização."
                                  ],
                                  "verification": "Gere relatório com plots mostrando convergência estável em <3 órbitas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB plots e scripts",
                                    "Ferramentas de análise (ex: stepinfo)"
                                  ],
                                  "tips": "Use sim() no Simulink para batch simulations; salve dados em .mat.",
                                  "learningObjective": "Avaliar performance da simulação em controle orbital.",
                                  "commonMistakes": [
                                    "Plots não sincronizados com órbita",
                                    "Ignorar deriva secular",
                                    "Ganhos altos causando oscilação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar contra benchmarks e otimizar",
                                  "subSteps": [
                                    "Compare resultados com literatura (ex: papers sobre B-dot control).",
                                    "Implemente controlador avançado (ex: LQR com τ_mag).",
                                    "Teste sensibilidade a parâmetros (varie I em ±10%).",
                                    "Documente código com comentários e gere animação 3D da atitude.",
                                    "Exporte para relatório final."
                                  ],
                                  "verification": "Simulação reproduz resultados de referência com erro <5%; código roda sem warnings.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Papers IEEE/AC sobre magnetic attitude control",
                                    "MATLAB Animator"
                                  ],
                                  "tips": "Versione código no Git; use parfor para sweeps paramétricos.",
                                  "learningObjective": "Validar simulação e refinar para aplicações reais.",
                                  "commonMistakes": [
                                    "Não validar cinemática",
                                    "Sobrecarga computacional",
                                    "Falta de documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat 3U em órbita LEO (400km, 98° inclinação) usando magnetorquers para recuperar de um erro de atitude de 20° em roll-pitch-yaw, aplicando lei PD: τ_mag = -K_p * erro - K_d * ω, com simulação de 10 órbitas mostrando convergência para <0.5° RMS.",
                              "finalVerifications": [
                                "Equações implementadas corretamente geram dinâmica estável sem drift ilimitado.",
                                "Simulação reproduz campo magnético orbital realista (plot B(t) vs modelo IGRF).",
                                "Controle valida: erro de atitude <2° após 5 órbitas em cenários nominais.",
                                "Código modular e comentado permite reutilização.",
                                "Análise sensível mostra robustez a ±20% variação em I.",
                                "Animação 3D visualiza rotação do satélite corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação das equações de Euler (sem erros numéricos >1e-6).",
                                "Qualidade dos plots e métricas (legíveis, com unidades, múltiplos cenários).",
                                "Robustez do código (roda em <5min, sem crashes).",
                                "Profundidade da análise (métricas como settling time <10min).",
                                "Conexão com controle real (saturação, ruído incluídos).",
                                "Documentação clara (relatório de 2-3 páginas)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletromagnetismo (dipolo × B) e mecânica clássica (rígido body).",
                                "Programação: Numéricos em MATLAB (ODE solvers, vetores/quaternions).",
                                "Engenharia de Controle: Estabilidade, leis PD/LQR.",
                                "Matemática: Álgebra linear (tensores, cross products), integração numérica.",
                                "Ciência de Dados: Análise de séries temporais e visualização."
                              ],
                              "realWorldApplication": "Desenvolvimento de sistemas de controle de atitude para CubeSats de baixo custo, como missões universitárias (ex: QB50), estações espaciais (ISS torque rods) ou constelações Starlink, onde magnetorquers são eficientes, sem propelentes, para manutenção orbital em LEO."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Simulação de Veículos Espaciais",
                "description": "Simulação focada no controle para estabilização de atitude e realização de manobras de atitude.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Simulação de Determinação de Atitude com Sensores",
                    "description": "Modelagem e simulação de sensores terrestres infravermelho, solares, estelares e inerciais para estimativa de atitude.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Sensores Terrestres Infravermelho",
                        "description": "Modelagem matemática e simulação de sensores infravermelhos baseados em observação de horizontes terrestres para determinação de atitude em veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Modelar a geometria de detecção de horizonte infravermelho",
                            "description": "Desenvolver equações que descrevem o vetor de medida do sensor infravermelho em relação à atitude do veículo, considerando a curvatura terrestre e ruído térmico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos da Detecção de Horizonte Infravermelho",
                                  "subSteps": [
                                    "Estude o princípio de funcionamento de sensores IR que detectam o horizonte terrestre emitindo radiação térmica contrastante com o espaço frio.",
                                    "Revise coordenadas esféricas e vetores unitários para representar direções do sensor.",
                                    "Analise diagramas geométricos básicos de um sensor apontando para o horizonte sem curvatura.",
                                    "Identifique parâmetros chave: raio da Terra (R), altitude do veículo (h), ângulo de elevação do horizonte.",
                                    "Compile referências bibliográficas sobre modelagem de sensores IR em atitude de satélites."
                                  ],
                                  "verification": "Crie um diagrama esquemático anotado mostrando o sensor, horizonte e vetores relevantes; revise com um colega ou tutor.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livros de dinâmica orbital (ex: Vallado), artigos sobre sensores IR, software de desenho (ex: Draw.io)"
                                  ],
                                  "tips": "Comece com aproximações planas para construir intuição antes de adicionar complexidade.",
                                  "learningObjective": "Compreender os princípios físicos e geométricos básicos da detecção de horizonte IR.",
                                  "commonMistakes": [
                                    "Ignorar a diferença de temperatura entre Terra e espaço",
                                    "Confundir coordenadas inerciais com do corpo do veículo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a Curvatura Terrestre no Vetor de Medida",
                                  "subSteps": [
                                    "Derive a equação do ângulo de elevação do horizonte: cos(ε) = R / (R + h), onde ε é o dip angle.",
                                    "Defina o vetor de medida nominal m̂ como perpendicular ao plano tangente na Terra.",
                                    "Expresse o vetor do centro da Terra ao veículo em coordenadas ECEF (Earth-Centered Earth-Fixed).",
                                    "Calcule a geometria esférica usando lei dos cossenos esféricos para o cone de visão do sensor.",
                                    "Implemente numericamente em Python/MATLAB para validar com valores típicos (h=500km)."
                                  ],
                                  "verification": "Compare resultados numéricos com valores tabelados em literatura (erro <1%); plote o cone de detecção.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy/MATLAB Symbolic), referências como 'Spacecraft Attitude Determination'"
                                  ],
                                  "tips": "Use aproximações para pequenos ângulos inicialmente para simplificar derivações.",
                                  "learningObjective": "Derivar e implementar equações geométricas considerando a esfericidade da Terra.",
                                  "commonMistakes": [
                                    "Negligenciar o raio efetivo da atmosfera",
                                    "Erro em convenções de coordenadas (ECEF vs ECI)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar a Atitude do Veículo no Modelo Geométrico",
                                  "subSteps": [
                                    "Defina a matriz de rotação de atitude A (body to inertial frame) usando ângulos de Euler ou quaternions.",
                                    "Transforme o vetor geométrico nominal para o frame do corpo: m = A * m̂_inercial.",
                                    "Incorpore o campo de visão do sensor (FOV) como um cone com semi-ângulo α.",
                                    "Derive a função de medida: sinal proporcional ao ângulo entre m e o eixo do sensor.",
                                    "Simule variações de atitude (roll, pitch, yaw) e plote respostas do sensor."
                                  ],
                                  "verification": "Simule 10 cenários de atitude; verifique se o modelo detecta corretamente o horizonte (threshold de sinal).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink, Python com NumPy/SciPy), dados de missão real (ex: CubeSat)"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades em rotações.",
                                  "learningObjective": "Conectar a geometria sensorial à dinâmica de atitude do veículo.",
                                  "commonMistakes": [
                                    "Inversão da matriz de rotação (A vs A^T)",
                                    "Ignorar alinhamento inicial do sensor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar Ruído Térmico e Finalizar o Modelo",
                                  "subSteps": [
                                    "Modele ruído térmico como gaussiano aditivo: v ~ N(0, σ²), com σ baseado em temperatura do sensor.",
                                    "Adicione ruído de fundo espacial e emissividade variável da Terra.",
                                    "Derive o vetor de medida completo: y = f(atitude) + v, onde f inclui não-linearidades geométricas.",
                                    "Estime covariância do ruído via simulações Monte Carlo (1000 runs).",
                                    "Documente o modelo completo em LaTeX com equações, plots e código fonte."
                                  ],
                                  "verification": "Execute simulação end-to-end; compute RMSE entre modelo ideal e ruidoso < threshold especificado.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python (NumPy, Matplotlib), LaTeX para documentação"
                                  ],
                                  "tips": "Tune σ com dados reais de sensores IR comerciais para realismo.",
                                  "learningObjective": "Integrar efeitos estocásticos realistas no modelo determinístico.",
                                  "commonMistakes": [
                                    "Ruído multiplicativo em vez de aditivo",
                                    "Subestimar variabilidade térmica diurna/noturna"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um CubeSat em órbita LEO a 500km, modele o vetor de medida de um sensor IR com FOV=45° durante uma manobra de roll de 10°. Simule 1 órbita completa, plotando detecções vs atitude verdadeira, incluindo ruído térmico de 0.5° RMS.",
                              "finalVerifications": [
                                "Equações derivadas coincidem com referências padrão (ex: psi angle correto).",
                                "Simulações numéricas mostram detecção precisa do horizonte (±2° erro).",
                                "Modelo responde corretamente a mudanças de atitude (teste sensibilidade).",
                                "Covariância de ruído estimada realisticamente (σ <1°).",
                                "Documentação inclui código reproduzível e plots validados.",
                                "Teste de consistência: modelo simétrico para hemisférios norte/sul."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivações matemáticas (100% corretas).",
                                "Realismo da inclusão de curvatura e ruído (validação numérica).",
                                "Qualidade da implementação simulada (código limpo, plots claros).",
                                "Completude da documentação (equações, premissas, limitações).",
                                "Criatividade em testes de validação (ex: Monte Carlo).",
                                "Integração correta de atitude (matrizes de rotação sem erros)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria esférica e álgebra linear (matrizes de rotação).",
                                "Física: Termodinâmica (radiação IR) e mecânica orbital.",
                                "Programação: Simulação numérica e análise estocástica (Python/MATLAB).",
                                "Engenharia: Sistemas embarcados e calibração de sensores.",
                                "Estatística: Modelagem de ruído gaussiano e estimação de parâmetros."
                              ],
                              "realWorldApplication": "Esse modelo é essencial para sistemas de determinação de atitude em satélites como o Hubble ou CubeSats, permitindo orientação autônoma sem GPS, crucial em missões de observação terrestre ou constelações como Starlink."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Implementar simulação numérica do sensor infravermelho",
                            "description": "Criar código em MATLAB ou Python para simular saídas do sensor com base em parâmetros orbitais e atitudes conhecidas, incluindo adição de ruído gaussiano.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros orbitais, de atitude e modelo do sensor IR",
                                  "subSteps": [
                                    "Pesquisar e listar parâmetros orbitais típicos (ex: altura orbital 500 km, inclinação 98° para LEO polar).",
                                    "Definir vetor de posição do satélite em coordenadas ECEF/ECI usando fórmulas keplerianas.",
                                    "Especificar ângulos de atitude (roll, pitch, yaw) e matriz de rotação DCM.",
                                    "Modelar o sensor IR: campo de visão (FOV), eixo de boresight, modelo geométrico do horizonte terrestre como elipsoide.",
                                    "Implementar função para calcular fração do disco terrestre visível no FOV do sensor."
                                  ],
                                  "verification": "Verificar se todos os parâmetros estão definidos como variáveis no código e impressos corretamente sem erros.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Python com NumPy, SciPy e Matplotlib",
                                    "Documentação orbital (ex: SGP4 model)",
                                    "Referências sobre sensores IR espaciais"
                                  ],
                                  "tips": "Use unidades consistentes (km para distâncias, radianos para ângulos) e comentários detalhados no código.",
                                  "learningObjective": "Compreender e parametrizar o ambiente orbital e o modelo físico do sensor infravermelho.",
                                  "commonMistakes": [
                                    "Confundir coordenadas ECI com ECEF",
                                    "Esquecer de normalizar vetores de direção",
                                    "Usar graus em vez de radianos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar modelo determinístico da saída do sensor",
                                  "subSteps": [
                                    "Calcular vetor de linha de visada (LOS) no frame do sensor usando DCM e boresight.",
                                    "Determinar interseção da LOS com o horizonte terrestre (raio da Terra + atmosfera).",
                                    "Computar ângulo de elevação ou fração iluminada baseada na geometria esférica.",
                                    "Gerar sinal de saída proporcional à intensidade IR detectada (ex: função sigmoide do ângulo).",
                                    "Testar com atitude nominal (apontando nadir) e imprimir saída esperada."
                                  ],
                                  "verification": "Executar código com atitude conhecida e comparar saída com valores teóricos manuais (ex: sinal máximo em nadir).",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Código Python do Step 1",
                                    "Fórmulas de geometria orbital (ex: livro 'Spacecraft Attitude Determination')"
                                  ],
                                  "tips": "Visualize vetores com Matplotlib 3D para depuração geométrica.",
                                  "learningObjective": "Desenvolver o núcleo matemático da simulação sem ruído para validar geometria.",
                                  "commonMistakes": [
                                    "Erro na multiplicação de matrizes DCM",
                                    "Ignorar refração atmosférica básica",
                                    "Assumir Terra esférica perfeita sem achatamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar ruído gaussiano e modelar incertezas",
                                  "subSteps": [
                                    "Definir parâmetros de ruído: desvio padrão σ baseado em specs de sensores reais (ex: 0.1°).",
                                    "Implementar ruído aditivo usando np.random.normal() em cada amostra de saída.",
                                    "Adicionar ruído multiplicativo para modelar variações de temperatura.",
                                    "Gerar múltiplas realizações (Monte Carlo) para estatísticas de ensemble.",
                                    "Calcular viés e covariância da saída ruidosa."
                                  ],
                                  "verification": "Histograma das saídas ruidosas deve ser gaussiano centrado na saída determinística.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "NumPy para geração de ruído",
                                    "Specs de sensores IR como IRU- something"
                                  ],
                                  "tips": "Use semente fixa (np.random.seed()) para reprodutibilidade durante testes.",
                                  "learningObjective": "Incorporar realismo estatístico à simulação através de ruído gaussiano.",
                                  "commonMistakes": [
                                    "Ruído excessivo que mascara sinal útil",
                                    "Não gerar suficientes amostras para estatísticas",
                                    "Confundir ruído aditivo com multiplicativo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulação completa, validar e visualizar",
                                  "subSteps": [
                                    "Simular sequência temporal: propagar órbita simples e variar atitude.",
                                    "Gerar plots: saída vs tempo, erro RMS, comparação determinístico vs ruidoso.",
                                    "Implementar filtro simples (ex: média móvel) para demonstrar processamento.",
                                    "Salvar dados em arquivo CSV para análise externa.",
                                    "Documentar código com README incluindo parâmetros usados."
                                  ],
                                  "verification": "Simulação roda para 1 órbita completa sem crashes; RMS do ruído matches σ especificado.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Pandas para exportação opcional"
                                  ],
                                  "tips": "Anime plots de atitude para insight visual.",
                                  "learningObjective": "Integrar e validar a simulação end-to-end com visualizações acionáveis.",
                                  "commonMistakes": [
                                    "Escala errada nos plots ocultando features",
                                    "Propagação orbital instável",
                                    "Falta de loops para múltiplas runs"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO a 500 km detectando o horizonte IR da Terra. Com atitude nadir-pointing, saída determinística = 0.9 (90% fração visível); adicione ruído σ=0.05. Varie roll de -10° a +10° e plote sinal ruidoso vs tempo orbital.",
                              "finalVerifications": [
                                "Código executa sem erros para 1000 amostras.",
                                "Saída determinística matches cálculos analíticos em pelo menos 3 casos teste.",
                                "Distribuição do ruído é gaussiana (teste KS p>0.05).",
                                "RMS do erro é consistente com σ definido.",
                                "Visualizações mostram comportamento físico esperado (pico em nadir).",
                                "Código é modular e reutilizável com parâmetros configuráveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo geométrico (erro <1% em ângulos nadir).",
                                "Correta implementação de ruído (estatísticas match specs).",
                                "Qualidade do código: legível, comentado, eficiente (O(n) tempo).",
                                "Visualizações claras e informativas.",
                                "Validação quantitativa com métricas (RMS, viés).",
                                "Robustez a variações de parâmetros."
                              ],
                              "crossCurricularConnections": [
                                "Física: Radiância IR terrestre e termodinâmica.",
                                "Matemática: Álgebra linear (DCM), Probabilidade (gaussiano).",
                                "Programação: NumPy vetorialização, OOP para classes de sensor.",
                                "Engenharia Aeroespacial: Propagação orbital, ADCS.",
                                "Estatística: Análise Monte Carlo."
                              ],
                              "realWorldApplication": "Em missões como CubeSats (ex: NASA MarCO), simulações de sensores IR validam algoritmos de determinação de atitude antes do lançamento, reduzindo custos e riscos em manobras autônomas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Estimar atitude usando medidas infravermelhas",
                            "description": "Aplicar método dos mínimos quadrados para estimar quaternions de atitude a partir de vetores de medida simulados do sensor infravermelho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos Teóricos de Quaternions e Sensores Infravermelhos",
                                  "subSteps": [
                                    "Estude a representação de atitude por quaternions unitários e suas propriedades (norma unitária, composição).",
                                    "Revise o funcionamento de sensores infravermelhos terrestres: detecção de borda do horizonte IR para vetores de medida.",
                                    "Analise a geometria: vetor IR medido no body frame vs. reference frame (Earth-centered).",
                                    "Defina o modelo matemático: relação entre quaternion de atitude q e vetores medidos b_i = A(q) r_i, onde A(q) é a matriz de rotação.",
                                    "Prepare um glossário de termos: Wahba's problem, least-squares para atitude."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo os conceitos chave e confirme que a norma do quaternion é 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de quaternions (NASA TN D-7216), tutoriais de sensores IR espaciais, caderno de notas.",
                                  "tips": "Use visualizações 3D para entender rotações quaternion.",
                                  "learningObjective": "Dominar a teoria por trás da estimativa de atitude com IR.",
                                  "commonMistakes": "Confundir quaternion com ângulos de Euler; ignorar a unitariedade do quaternion."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular Vetores de Medida Infravermelhos",
                                  "subSteps": [
                                    "Implemente uma função para gerar vetores de referência IR (r_i) no frame de referência (ex: múltiplos pontos no horizonte terrestre).",
                                    "Simule ruído gaussiano nos vetores medidos (b_i) para realismo.",
                                    "Gere um conjunto de medidas simuladas para N observações (N >= 3 para observabilidade).",
                                    "Aplique um quaternion de atitude 'verdadeiro' conhecido para rotacionar r_i para b_i = A(q_true) r_i + noise.",
                                    "Visualize os vetores em 3D para validar a simulação."
                                  ],
                                  "verification": "Plot dos vetores medidos e referência mostram alinhamento aproximado com ruído.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com NumPy, Matplotlib, SciPy; ou MATLAB.",
                                  "tips": "Use seed para reprodutibilidade do ruído.",
                                  "learningObjective": "Gerar dados realistas de sensores IR simulados.",
                                  "commonMistakes": "Usar N < 3 observações; não normalizar vetores unitários."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o Problema de Mínimos Quadrados",
                                  "subSteps": [
                                    "Defina a função custo de Wahba: J(q) = (1/2) sum ||b_i - A(q) r_i||^2.",
                                    "Expresse em termos de matrizes: construa matrizes de observação Z = [b1 r1; b2 r2; ...].",
                                    "Derive a solução analítica usando método de Davenport (ou QUEST para aproximação).",
                                    "Implemente a restrição de unitariedade via Lagrange ou projeção.",
                                    "Linearize para gradiente descendente se necessário (iterativo)."
                                  ],
                                  "verification": "A função custo J(q) é mínima para q_true dentro de tolerância.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "Código Python/MATLAB, referências: 'Quaternion-based Attitude Determination' papers.",
                                  "tips": "Comece com solução fechada para simplicidade.",
                                  "learningObjective": "Configurar matematicamente o problema de estimação.",
                                  "commonMistakes": "Esquecer fator 1/2 em Wahba; não lidar com ambiguidade de sinal no quaternion."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Resolver a Estimação",
                                  "subSteps": [
                                    "Codifique a função para construir A(q) a partir de quaternion.",
                                    "Implemente o solver de mínimos quadrados (ex: SVD na matriz K de Davenport).",
                                    "Execute a estimação para dados simulados.",
                                    "Normalize o quaternion estimado.",
                                    "Calcule erro de atitude: angle error = 2 acos(q_est * q_true)."
                                  ],
                                  "verification": "Erro de atitude < 1 grau para SNR alto.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Bibliotecas: NumPy.linalg.svd, SciPy.optimize.",
                                  "tips": "Teste com q_true = [1,0,0,0] primeiro.",
                                  "learningObjective": "Aplicar numericamente o método de mínimos quadrados.",
                                  "commonMistakes": "Não inverter corretamente a matriz de covariância; propagar erros de normalização."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar Resultados",
                                  "subSteps": [
                                    "Varie níveis de ruído e plote erro vs. SNR.",
                                    "Compare com métodos alternativos (ex: TRIAD).",
                                    "Analise sensibilidade a número de observações.",
                                    "Gere relatório com métricas: RMSE, tempo de CPU.",
                                    "Discuta limitações: obstruções terrestres, calibração."
                                  ],
                                  "verification": "Gráficos mostram convergência e precisão esperada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de plotagem, Jupyter Notebook.",
                                  "tips": "Use Monte Carlo para estatísticas robustas.",
                                  "learningObjective": "Avaliar performance da estimação.",
                                  "commonMistakes": "Ignorar ambiguidade quaternion (-q equiv q); superestimar precisão sem ruído."
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita baixa terrestre (LEO) com 6 sensores IR detectando o horizonte. Gere 10 medidas com ruído de 0.1 grau, aplique mínimos quadrados para estimar q, obtendo erro de 0.5 grau, permitindo controle preciso de apontamento para imageamento.",
                              "finalVerifications": [
                                "Quaternion estimado tem norma unitária ≈1 (erro <1e-10).",
                                "Erro de atitude médio <2 graus para ruído típico.",
                                "Função custo J(q_est) < threshold baseado em ruído.",
                                "Visualização 3D dos vetores alinhados pós-estimação.",
                                "Teste com 100 simulações Monte Carlo: 95% confiança no erro.",
                                "Comparação com ground truth converge com mais observações."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimação (erro <1 grau em cenários nominais).",
                                "Eficiência computacional (solução em <1ms por iteração).",
                                "Robustez a ruído e falhas de sensor (graceful degradation).",
                                "Correta implementação da unitariedade e ambiguidade.",
                                "Qualidade da análise de sensibilidade e visualizações.",
                                "Clareza do código com comentários e modularidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (SVD, eigenvalores), Otimização não-linear.",
                                "Programação: NumPy/SciPy para computação científica, visualização de dados.",
                                "Física: Óptica infravermelha, Cinemática orbital, Geometria esférica.",
                                "Estatística: Modelagem de ruído gaussiano, Análise de Monte Carlo."
                              ],
                              "realWorldApplication": "Em satélites como CubeSats (ex: missions da NASA), sensores IR terrestres fornecem determinação de atitude autônoma e barata para controle de apontamento, navegação durante eclipses (quando star trackers falham), e estabilização em formações espaciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Sensores Solares",
                        "description": "Modelagem e simulação de sensores solares que detectam a direção do vetor Sol para estimativa de atitude em órbita.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Derivar modelo matemático do vetor Sol",
                            "description": "Calcular a direção unitária do Sol no referencial inercial e transformá-la para o referencial do corpo do veículo espacial usando matrizes de rotação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a posição do Sol no referencial inercial (ICRF/J2000)",
                                  "subSteps": [
                                    "Identificar o referencial inercial padrão (ICRF ou J2000) para coordenadas celestes.",
                                    "Obter as coordenadas eclípticas ou equatoriais do Sol em função do tempo (usando efemérides como DE430).",
                                    "Calcular o vetor posição do Sol relativo à posição da spacecraft no Sistema Solar Barycêntrico (SSB).",
                                    "Expressar o vetor como [x, y, z] no referencial inercial.",
                                    "Documentar suposições, como distância média Terra-Sol para simplificação."
                                  ],
                                  "verification": "Verificar se o vetor aponta corretamente para o Sol verificando ângulo com direção conhecida (ex: 0° ao meio-dia solar).",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Efemérides SPICE (NASA)",
                                    "Documentação JPL Horizons",
                                    "Calculadora simbólica (SymPy ou MATLAB)"
                                  ],
                                  "tips": "Use bibliotecas como Orekit ou Poliastro para automação inicial; valide com dados públicos do Sol.",
                                  "learningObjective": "Compreender a representação vetorial do Sol em referenciais inerciais astronômicos.",
                                  "commonMistakes": [
                                    "Confundir coordenadas eclípticas com equatoriais sem conversão",
                                    "Ignorar o tempo sideral para epoch J2000",
                                    "Usar posição geocêntrica em vez de heliocêntrica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o vetor direção unitário no referencial inercial",
                                  "subSteps": [
                                    "Calcular a norma (magnitude) do vetor posição do Sol: ||S_inertial|| = sqrt(x² + y² + z²).",
                                    "Normalizar o vetor: S_unit_inertial = S_inertial / ||S_inertial||.",
                                    "Verificar numericamente se ||S_unit_inertial|| ≈ 1 (erro < 1e-10).",
                                    "Expressar em componentes unitárias: [sx, sy, sz].",
                                    "Testar com datas específicas para validar consistência temporal."
                                  ],
                                  "verification": "Computar norma do vetor resultante e confirmar que é unitária dentro de tolerância numérica.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Python com NumPy",
                                    "MATLAB Vector Toolbox",
                                    "Planilhas com fórmulas vetoriais"
                                  ],
                                  "tips": "Sempre use operações vetoriais para evitar erros de transposição; plote o vetor em 3D para visualização.",
                                  "learningObjective": "Dominar normalização de vetores para representar direções unitárias.",
                                  "commonMistakes": [
                                    "Dividir por zero ou norma nula",
                                    "Arredondamento excessivo levando a norma ≠1",
                                    "Confundir vetor posição com direção"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz de rotação do referencial inercial para o body frame",
                                  "subSteps": [
                                    "Obter parâmetros de atitude da spacecraft (quaternions, ângulos de Euler ou DCM conhecida).",
                                    "Converter parâmetros para Direction Cosine Matrix (DCM) C_b^i (de inercial para body).",
                                    "Verificar ortogonalidade da DCM: C * C^T = I e det(C) = 1.",
                                    "Documentar convenções de rotação (ex: 3-2-1 Euler).",
                                    "Implementar função para atualização dinâmica da DCM."
                                  ],
                                  "verification": "Multiplicar DCM por sua transposta e confirmar identidade unitária.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "'Spacecraft Attitude Determination and Control' (Wertz)",
                                    "Biblioteca pyquaternion ou scipy.spatial.transform"
                                  ],
                                  "tips": "Use quaternions para evitar gimbal lock; teste com rotações identidade (DCM = I).",
                                  "learningObjective": "Aplicar transformações de atitude usando matrizes de rotação em engenharia aeroespacial.",
                                  "commonMistakes": [
                                    "Inverter ordem de rotação (body-to-inertial vs inertial-to-body)",
                                    "Erros em convenções de ângulos de Euler",
                                    "Não normalizar quaternions"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Transformar o vetor unitário para o referencial do corpo",
                                  "subSteps": [
                                    "Aplicar transformação: S_unit_body = C_b^i * S_unit_inertial.",
                                    "Calcular componentes no body frame: multiplicação matricial [3x3] x [3x1].",
                                    "Verificar preservação da norma: ||S_unit_body|| ≈ 1.",
                                    "Interpretar componentes: alinhamento com eixos do corpo (ex: boresight do sensor).",
                                    "Gerar equação geral do modelo: S_body(t) = C_b^i(t) * S_unit_inertial(t)."
                                  ],
                                  "verification": "Comparar norma antes/depois e simular rotação conhecida (ex: 90° em roll).",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "NumPy/MATLAB para multiplicação matricial",
                                    "Simulador de atitude (ex: FreeFlyer trial)"
                                  ],
                                  "tips": "Implemente em loop temporal para ver evolução; use debugging com prints de matrizes.",
                                  "learningObjective": "Executar transformações de coordenadas entre referenciais rotantes e inerciais.",
                                  "commonMistakes": [
                                    "Erro de transposição na multiplicação (coluna vs linha)",
                                    "Usar DCM errada (C_i^b em vez de C_b^i)",
                                    "Ignorar dependência temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e finalizar o modelo matemático",
                                  "subSteps": [
                                    "Simular cenários variados (dia/noite, diferentes atitudes).",
                                    "Comparar com modelo analítico simplificado (ex: vetor Sol aproximado).",
                                    "Documentar equações finais e pseudocódigo.",
                                    "Testar sensibilidade a erros em efemérides ou atitude.",
                                    "Preparar para integração com modelo de sensor solar (adicionar ruído)."
                                  ],
                                  "verification": "Erro médio < 0.1° em direção comparado a software padrão como STK.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "AGI STK ou GMAT (gratuitos)",
                                    "Jupyter Notebook para plots"
                                  ],
                                  "tips": "Grave vídeo de simulação 3D; use unit tests para funções modulares.",
                                  "learningObjective": "Validar modelos matemáticos em contextos de simulação aeroespacial.",
                                  "commonMistakes": [
                                    "Não testar casos edge (Sol eclipsado)",
                                    "Sobrepujar precisão numérica desnecessária",
                                    "Esquecer unidades consistentes (rad vs deg)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um CubeSat em órbita LEO a 400km de altitude às 12:00 UTC em 2024-01-01, com quaternion de atitude [1,0,0,0] (alinhado), calcule S_inertial ≈ [1,0,0], aplique DCM identidade, obtendo S_body = [1,0,0], significando Sol alinhado ao eixo X do corpo; rotacione 90° em yaw para verificar transformação.",
                              "finalVerifications": [
                                "Norma do vetor unitário final é exatamente 1 (tolerância 1e-12).",
                                "Transformação preserva direção para rotações identidade.",
                                "Vetor varia corretamente com tempo (período ~1 dia).",
                                "Alinhamento com boresight do sensor solar é consistente.",
                                "Erro de validação < 0.05° vs efemérides referenciadas.",
                                "Modelo integrado roda em tempo real sem crashes."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: fórmulas corretas e normalização exata (90%).",
                                "Implementação computacional: código reproduzível e eficiente (80%).",
                                "Validação robusta: testes em múltiplos cenários (85%).",
                                "Documentação clara: equações, suposições e limites (90%).",
                                "Interpretação física: ligação com sensores solares (85%).",
                                "Criatividade: extensões como ruído ou eclipses (bônus)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, vetores unitários).",
                                "Física: Mecânica celeste e referenciais rotantes.",
                                "Computação: Programação numérica (NumPy, simulações).",
                                "Engenharia: Controle de atitude e modelagem de sistemas.",
                                "Astronomia: Efemérides e coordenadas celestes."
                              ],
                              "realWorldApplication": "Este modelo é essencial para sensores solares em satélites como o James Webb Space Telescope ou CubeSats, permitindo determinação de atitude autônoma via medições de direção solar, crucial para pointing preciso em missões científicas e de comunicação."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Simular respostas de sensores solares com sombreamento",
                            "description": "Implementar simulação considerando campo de visão do sensor, obstruções pelo veículo e ruído de detecção em ambiente orbital.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sensor solar e seu campo de visão",
                                  "subSteps": [
                                    "Defina as especificações do sensor solar: ângulo de campo de visão (FOV), posição relativa ao centro de massa do veículo e eixos de referência.",
                                    "Implemente a geometria cônica do FOV usando vetores unitários e matrizes de rotação.",
                                    "Crie uma função para calcular a direção unitária do Sol a partir da posição orbital e efemérides solares.",
                                    "Valide o modelo comparando com dados de sensores reais (ex: dados de CubeSats).",
                                    "Documente parâmetros como sensibilidade e resolução angular."
                                  ],
                                  "verification": "Execute testes unitários: a função deve retornar true se o Sol estiver dentro do FOV para ângulos conhecidos.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink ou Python com NumPy/SciPy)",
                                    "Documentação de sensores solares (ex: AdCSS-405)",
                                    "Efemérides solares (SPICE kernels)"
                                  ],
                                  "tips": "Use quaternions para rotações 3D para evitar singularidades gimbal lock.",
                                  "learningObjective": "Compreender e implementar representação geométrica precisa do FOV de sensores solares.",
                                  "commonMistakes": [
                                    "Ignorar a direção relativa do Sol em coordenadas orbitais",
                                    "Confundir FOV com ângulo de aceitação total",
                                    "Não normalizar vetores de direção"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar obstruções e sombreamento pelo veículo",
                                  "subSteps": [
                                    "Crie um modelo CAD simplificado ou mesh wireframe do veículo espacial (painéis solares, antenas, corpo principal).",
                                    "Implemente ray-tracing: lance raios do sensor para o Sol e verifique interseções com superfícies do veículo.",
                                    "Defina superfícies opacas e compute fração de sombreamento baseada na área projetada.",
                                    "Incorpore rotação do veículo usando matrizes de atitude (quaternions ou DCM).",
                                    "Otimize com bounding volumes (ex: esferas delimitadoras) para ray-tracing eficiente."
                                  ],
                                  "verification": "Simule attitudes conhecidas: confirme sombreamento total quando painel bloqueia FOV e livre quando não.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Bibliotecas de ray-tracing (Python: PyRay ou custom com Shapely)",
                                    "Modelos 3D do veículo (STEP/STL files)",
                                    "Ferramentas de visualização (Blender ou Matplotlib 3D)"
                                  ],
                                  "tips": "Comece com geometria convexa simples para depuração antes de meshes complexas.",
                                  "learningObjective": "Dominar simulação de auto-sombreamento em veículos espaciais usando ray-tracing.",
                                  "commonMistakes": [
                                    "Ray-tracing sem considerar espessura de superfícies",
                                    "Erro em transformações de coordenadas veículo-Sol",
                                    "Ignorar sombreamento parcial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar ruído de detecção e ambiente orbital",
                                  "subSteps": [
                                    "Modele ruído gaussiano aditivo na medição de ângulo solar (baseado em SNR e temperatura).",
                                    "Integre propagador orbital (SGP4 ou Runge-Kutta) para posição/velocidade em órbita.",
                                    "Compute vetor Sol-veículo usando J2000 e ECEF coordenadas.",
                                    "Aplique ruído dependente de sombreamento: reduza sinal em frações sombreadas.",
                                    "Gere sequências temporais de simulação para uma órbita completa (ex: 90 min LEO)."
                                  ],
                                  "verification": "Analise histogramas de ruído: deve seguir distribuição gaussiana com variância esperada.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Bibliotecas orbitais (Orekit Python ou poliastro)",
                                    "Geradores de ruído (NumPy random)",
                                    "Dados reais de sensores (NASA CDHF)"
                                  ],
                                  "tips": "Use seed fixo para reprodutibilidade em testes.",
                                  "learningObjective": "Integrar dinâmica orbital e ruído realista em simulações de sensores.",
                                  "commonMistakes": [
                                    "Ruído constante independente de intensidade solar",
                                    "Erro em propagação orbital sem perturbações",
                                    "Não sincronizar timestamps de simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar simulação completa e validar respostas",
                                  "subSteps": [
                                    "Combine módulos: FOV + sombreamento + ruído em uma função de simulação de resposta.",
                                    "Gere outputs: ângulos medidos, flags de sombreamento, confiança probabilística.",
                                    "Compare com modelo ideal (sem ruído/sombreamento) usando métricas como RMSE.",
                                    "Execute Monte Carlo: 1000 runs para estatísticas de erro.",
                                    "Visualize resultados: plots de ângulo vs tempo com sombreamentos reais."
                                  ],
                                  "verification": "RMSE < 0.5° em condições livres; detecção correta de 95% dos eventos de sombreamento.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ferramentas de plotting (Matplotlib/Plotly)",
                                    "Scripts de Monte Carlo",
                                    "Dados de validação (simulações GMAT/STK)"
                                  ],
                                  "tips": "Modularize código para facilitar depuração de módulos individuais.",
                                  "learningObjective": "Construir e validar pipeline completo de simulação de sensores solares.",
                                  "commonMistakes": [
                                    "Não calibrar escalas de ruído com specs reais",
                                    "Sobrecarga computacional em Monte Carlo sem vetorização",
                                    "Plots sem legendas/contextos orbitais"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO (400km, 51° inc) com sensores solares nos cantos. Durante rotação, painéis solares sombreiam sensores por 20s/orbita. Implemente para prever perda de sinal durante manobras de atitude, gerando dados para filtro de Kalman em ADCS.",
                              "finalVerifications": [
                                "Simulação detecta corretamente 100% dos sombreamentos em attitudes fixas.",
                                "Distribuição de ruído matches specs do sensor (σ < 1°).",
                                "Respostas variam realisticamente com fase orbital (eclipse/sol).",
                                "Tempo de execução < 1s por órbita para simulações em tempo real.",
                                "Código modular com testes unitários passando >95%.",
                                "Visualizações mostram sombreamentos consistentes com geometria do veículo."
                              ],
                              "assessmentCriteria": [
                                "Precisão geométrica: FOV e ray-tracing sem erros >0.1°.",
                                "Realismo do ruído: variância alinhada com modelos físicos.",
                                "Eficiência computacional: escalável para simulações longas.",
                                "Validação quantitativa: RMSE e estatísticas de Monte Carlo reportadas.",
                                "Documentação: parâmetros, assunções e limitações claras.",
                                "Integração orbital: consistente com propagadores padrão."
                              ],
                              "crossCurricularConnections": [
                                "Física: Óptica geométrica e mecânica orbital.",
                                "Matemática: Álgebra linear (rotações), estatística (ruído gaussiano).",
                                "Programação: Algoritmos numéricos e otimização.",
                                "Engenharia: Modelagem CAD e sistemas embarcados.",
                                "Ciência de Dados: Análise estatística e visualização."
                              ],
                              "realWorldApplication": "Em missões como CubeSats (ex: MarCO da NASA), simulações de sensores solares com sombreamento são críticas para ADCS robusto, prevendo falhas em determinação de atitude durante eclipses ou manobras, reduzindo risco de perda de controle."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Realizar determinação de atitude com sensores solares",
                            "description": "Usar algoritmos TRIAD para combinar medidas solares com outros vetores de referência e validar precisão da estimativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Princípios de Sensores Solares e Algoritmo TRIAD",
                                  "subSteps": [
                                    "Estude o funcionamento de sensores solares (SSCs) e como eles medem o vetor solar.",
                                    "Revise a matemática do algoritmo TRIAD: definição de vetores observados e de referência.",
                                    "Aprenda a representar atitudes com quaternions ou matrizes de rotação.",
                                    "Identifique limitações dos sensores solares (ex.: obstruções, precisão angular).",
                                    "Pratique cálculos manuais de TRIAD com vetores simples."
                                  ],
                                  "verification": "Resuma em um diagrama os passos do TRIAD e calcule manualmente uma atitude com vetores exemplo, verificando erro < 1 grau.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação NASA/ESA sobre TRIAD, MATLAB/Python com bibliotecas de álgebra linear (numpy, scipy), artigos acadêmicos sobre SSCs.",
                                  "tips": "Use visualizações 3D para entender vetores (ex.: plot em matplotlib).",
                                  "learningObjective": "Dominar fundamentos teóricos para implementação prática.",
                                  "commonMistakes": "Confundir vetor solar observado com referência inercial; ignorar normalização de vetores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Simulação de Veículo Espacial",
                                  "subSteps": [
                                    "Instale e configure software de simulação (ex.: GMAT, STK ou Python com poliastro/orekit).",
                                    "Defina órbita e modelo de veículo com sensor solar virtual.",
                                    "Gere dados simulados de vetor solar (direção do Sol relativa ao body frame).",
                                    "Inclua ruído realista nos dados (ex.: 1-3 graus de erro).",
                                    "Teste propagação orbital para sincronizar com tempo real."
                                  ],
                                  "verification": "Execute simulação básica e plote trajetória orbital com vetor solar estável.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software GMAT/STK gratuito, Python (poliastro, skyfield), computador com GPU para simulações rápidas.",
                                  "tips": "Comece com órbita LEO circular para simplicidade.",
                                  "learningObjective": "Preparar ambiente realista para testes de atitude.",
                                  "commonMistakes": "Não modelar rotação da Terra corretamente; escalas erradas em unidades (km vs. m)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Algoritmo TRIAD com Medidas Solares",
                                  "subSteps": [
                                    "Codifique função TRIAD: entrada vetores b1, b2 (solares) e r1, r2 (referência).",
                                    "Combine com outro vetor (ex.: magnetômetro) para resolver ambiguidade.",
                                    "Converta resultado em quaternion ou ângulos de Euler.",
                                    "Adicione filtros para suavizar estimativas (ex.: média móvel).",
                                    "Teste unitário com casos conhecidos."
                                  ],
                                  "verification": "Compare saída TRIAD com atitude conhecida; erro RMS < 2 graus em 100 iterações.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Editor de código (VSCode/Jupyter), bibliotecas (numpy, scipy.spatial.transform).",
                                  "tips": "Implemente em função modular para reutilização.",
                                  "learningObjective": "Desenvolver código funcional para determinação de atitude.",
                                  "commonMistakes": "Não tratar singularidades (vetores colineares); propagação de erros de normalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Simulação e Validar Precisão",
                                  "subSteps": [
                                    "Integre TRIAD na loop de simulação em tempo real.",
                                    "Colete dados de atitude estimada vs. verdadeira ao longo de uma órbita.",
                                    "Calcule métricas: erro RMS, desvio máximo, convergência.",
                                    "Ajuste parâmetros (thresholds, filtros) para otimizar.",
                                    "Gere relatórios com gráficos de erro."
                                  ],
                                  "verification": "Gráficos mostram convergência < 1 grau após 10s; relatório com métricas salvas.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Mesmo ambiente de simulação, ferramentas de plot (matplotlib, plotly).",
                                  "tips": "Use logging para debug em tempo real.",
                                  "learningObjective": "Avaliar performance e iterar melhorias.",
                                  "commonMistakes": "Overfitting a um cenário; ignorar efeitos dinâmicos como eclipse."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Documentar Melhoria",
                                  "subSteps": [
                                    "Compare com métodos alternativos (ex.: QUEST).",
                                    "Identifique cenários de falha (ex.: eclipse solar).",
                                    "Proponha fusão com outros sensores (EKF).",
                                    "Documente código e resultados em relatório.",
                                    "Apresente findings em vídeo/demo."
                                  ],
                                  "verification": "Relatório completo com análise estatística e sugestões de melhoria.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de documentação (Markdown, LaTeX), gravador de tela.",
                                  "tips": "Foque em métricas quantitativas para credibilidade.",
                                  "learningObjective": "Consolidar conhecimento e preparar para aplicações avançadas.",
                                  "commonMistakes": "Subestimar impacto de ruído; não versionar código."
                                }
                              ],
                              "practicalExample": "Em um CubeSat simulando missão de imageamento terrestre, use TRIAD para combinar vetor solar (de SSC) com magnetômetro durante órbita LEO. Inicialmente com rotação aleatória, a atitude converge de 45° para <1° de erro em 30s, permitindo apontamento preciso da câmera.",
                              "finalVerifications": [
                                "Erro RMS de atitude < 1° em simulação de 1 órbita completa.",
                                "Código executa em <10ms por iteração em hardware embarcado simulado.",
                                "Estimativa resiste a 20% de ruído nos sensores solares.",
                                "Validação cruzada com método QUEST mostra concordância >95%.",
                                "Relatório inclui gráficos de convergência e análise de sensibilidade.",
                                "Demo em vídeo mostra estabilização em tempo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação TRIAD (correção matemática: 40%)",
                                "Qualidade da simulação e dados gerados (30%)",
                                "Análise de erros e validação quantitativa (20%)",
                                "Clareza do código e documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear, quaternions e transformações ortogonais.",
                                "Física: Dinâmica orbital, vetores inerciais e campos magnéticos.",
                                "Programação: Algoritmos numéricos e simulação em Python/MATLAB.",
                                "Engenharia: Sistemas embarcados e controle de atitude.",
                                "Estatística: Análise de erros RMS e filtros de Kalman."
                              ],
                              "realWorldApplication": "Satélites como o CubeSat da NASA (MarCO) usam TRIAD com sensores solares para determinação inicial de atitude em missões deep-space, garantindo comunicações e apontamento de antenas sem GPS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Sensores Estelares",
                        "description": "Modelagem de sensores de estrelas para rastreamento de estrelas conhecidas e estimativa precisa de atitude.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Construir catálogo de estrelas e modelo de aquisição",
                            "description": "Selecionar estrelas de catálogo (ex: Hipparcos) e modelar vetores inerciais projetados no plano focal do sensor estelar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter e preparar o catálogo de estrelas",
                                  "subSteps": [
                                    "Baixe o catálogo Hipparcos do site oficial da ESA ou CDS Strasbourg.",
                                    "Importe os dados em um formato utilizável (CSV ou FITS) usando Python com bibliotecas como Astropy.",
                                    "Extraia colunas essenciais: ID da estrela, ascensão reta (RA), declinação (DEC) e magnitude visual.",
                                    "Filtre estrelas por magnitude (ex: <6 para visibilidade).",
                                    "Converta coordenadas celestes equatoriais para o sistema inercial do veículo (ex: ECI)."
                                  ],
                                  "verification": "Verifique se o DataFrame ou array contém pelo menos 1000 estrelas filtradas com coordenadas válidas.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": "Catálogo Hipparcos (gratuito online), Python com Astropy/Pandas, Jupyter Notebook",
                                  "tips": "Use funções prontas do Astropy como SkyCoord para conversões coordenadas.",
                                  "learningObjective": "Entender estrutura de catálogos estelares e prepará-los para simulações.",
                                  "commonMistakes": "Ignorar filtros de magnitude levando a estrelas invisíveis; erros em unidades de coordenadas (graus vs radianos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar estrelas relevantes para o sensor",
                                  "subSteps": [
                                    "Defina parâmetros do sensor: campo de visão (FOV, ex: 10°x10°), posição e atitude atual do veículo.",
                                    "Calcule o cone de visibilidade baseado na matriz de rotação de atitude (quaternions ou DCM).",
                                    "Para cada estrela, verifique se seu vetor inercial está dentro do FOV projetado.",
                                    "Selecione top N estrelas (ex: 10-20) por brilho e distribuição uniforme.",
                                    "Armazene lista selecionada com IDs e posições."
                                  ],
                                  "verification": "Confirme que pelo menos 10 estrelas foram selecionadas e estão dentro do FOV simulado.",
                                  "estimatedTime": "2 hours",
                                  "materials": "Código Python/MATLAB para vetores e matrizes de rotação, parâmetros do sensor fictícios",
                                  "tips": "Use vetores unitários para normalizar direções estelares e evite divisões por zero.",
                                  "learningObjective": "Aplicar geometria esférica para seleção de alvos visíveis.",
                                  "commonMistakes": "Esquecer de normalizar vetores estelares; confundir coordenadas do veículo com estrelas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar vetores inerciais das estrelas selecionadas",
                                  "subSteps": [
                                    "Converta RA/DEC para vetor unitário inercial: [cos(DEC)*cos(RA), cos(DEC)*sin(RA), sin(DEC)].",
                                    "Aplique rotação da Terra (precessão/nutação) se necessário para epoch atual.",
                                    "Gere matriz de posições para todas estrelas selecionadas.",
                                    "Valide magnitudes e posições com plot 3D (ex: usando Matplotlib).",
                                    "Salve vetores em estrutura de dados para projeção."
                                  ],
                                  "verification": "Plote vetores unitários e confirme norma unitária (erro <1e-6) para todas estrelas.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": "Bibliotecas NumPy/SciPy para vetores, Matplotlib para visualização",
                                  "tips": "Trabalhe sempre em radianos para funções trigonométricas.",
                                  "learningObjective": "Dominar transformação de coordenadas celestes para vetores cartesianos inerciais.",
                                  "commonMistakes": "Usar graus em vez de radianos; inverter eixos RA/DEC."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Projetar vetores no plano focal do sensor",
                                  "subSteps": [
                                    "Defina modelo do sensor: matriz de projeção pinhole ou focal length (f).",
                                    "Aplique rotação de boresight: vetor projetado = R * vetor_inercial, onde R é DCM do sensor.",
                                    "Projete em plano focal: u = f * x/z, v = f * y/z (coordenadas de pixel).",
                                    "Aplique distorções óticas simples se aplicável (ex: modelo pincushion).",
                                    "Gere lista de spots projetados com intensidades baseadas em magnitude."
                                  ],
                                  "verification": "Simule imagem focal e confirme spots dentro dos limites do detector (ex: 1024x1024 pixels).",
                                  "estimatedTime": "2-3 hours",
                                  "materials": "Código para matrizes de rotação (quaternions), modelo de câmera simples",
                                  "tips": "Teste com estrela no boresight (deve projetar no centro).",
                                  "learningObjective": "Implementar projeção perspectiva para simulação de sensor estelar.",
                                  "commonMistakes": "Dividir por z=0 (estrela atrás); ignorar escala focal levando a distorções."
                                }
                              ],
                              "practicalExample": "Para um CubeSat em órbita LEO com sensor estelar de 8° FOV, selecione 15 estrelas do Hipparcos visíveis sobre o Pacífico, calcule vetores inerciais em ECI, projete no plano focal de 512x512 pixels, gerando spots para tracking de atitude com precisão <0.01°.",
                              "finalVerifications": [
                                "Catálogo carregado corretamente com >1000 estrelas filtradas.",
                                "Seleção de estrelas dentro do FOV com distribuição uniforme.",
                                "Vetores unitários normalizados (norma=1).",
                                "Projeções no plano focal dentro dos limites do sensor.",
                                "Simulação roda sem erros e gera imagem de spots válida.",
                                "Precisão de projeção <1 pixel de erro para estrelas centrais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática dos vetores inerciais (erro <1e-6).",
                                "Eficiência na seleção (tempo <1s para 1000 estrelas).",
                                "Qualidade da projeção (spots centrados corretamente).",
                                "Código modular e comentado.",
                                "Validações implementadas em cada step.",
                                "Visualizações claras (plots 3D e 2D)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rotação, vetores unitários).",
                                "Programação: Manipulação de dados astronômicos com Python/Astropy.",
                                "Física: Cinemática orbital e óptica geométrica.",
                                "Astronomia: Coordenadas celestes e catálogos estelares."
                              ],
                              "realWorldApplication": "Sensores estelares em satélites como o Hubble, GPS III ou missões CubeSat usam catálogos Hipparcos/Tycho para determinação autônoma de atitude com precisão arcsegundo, essencial para apontamento preciso de antenas e câmeras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Simular detecção e rastreamento estelar",
                            "description": "Desenvolver simulação com distorções ópticas, ruído de centroiding e limiares de magnitude para gerar medidas realistas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de simulação e catálogo estelar",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias como NumPy, Astropy, Matplotlib e SciPy.",
                                    "Carregar um catálogo estelar real (ex: Hipparcos ou Gaia) com magnitudes, posições RA/DEC.",
                                    "Projetar estrelas no plano focal da câmera usando modelo pinhole ou distorção radial básica.",
                                    "Gerar imagem 2D simulada com fundo de céu e intensidades baseadas em magnitude.",
                                    "Definir parâmetros da câmera: FOV, resolução, tempo de exposição."
                                  ],
                                  "verification": "Visualizar imagem gerada com estrelas detectáveis plotadas corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python 3+, bibliotecas: numpy, astropy, matplotlib, scipy; Catálogo estelar (CSV ou FITS).",
                                  "tips": "Use Astropy para coordenadas celestes precisas; normalize magnitudes para escala de pixels.",
                                  "learningObjective": "Entender projeção de estrelas em sensores CCD/CMOS.",
                                  "commonMistakes": "Ignorar rotação da Terra ou movimento orbital; usar catálogos sem filtro de magnitude."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção de estrelas com limiares de magnitude",
                                  "subSteps": [
                                    "Converter magnitudes em fluxos de fótons usando zero-point calibrado.",
                                    "Aplicar filtro gaussiano para suavização de imagem.",
                                    "Usar threshold adaptativo (ex: Otsu ou multi-escala) para binarizar imagem.",
                                    "Identificar blobs/candidatos a estrelas via connected components ou watershed.",
                                    "Filtrar candidatos por tamanho, forma e brilho mínimo (limiar de magnitude)."
                                  ],
                                  "verification": "Detectar pelo menos 80% das estrelas acima de magnitude limite em imagem de teste.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Scikit-image para processamento de imagem; Jupyter Notebook para iteração rápida.",
                                  "tips": "Teste com diferentes limiares; plote histograma de intensidades para calibrar.",
                                  "learningObjective": "Dominar detecção de fontes pontuais em imagens astronômicas ruidosas.",
                                  "commonMistakes": "Threshold fixo levando a falsos positivos/negativos; não filtrar ruído cósmico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar distorções ópticas na projeção estelar",
                                  "subSteps": [
                                    "Implementar modelo de distorção radial (Brown-Conrady) com coeficientes k1-k3.",
                                    "Aplicar distorção a coordenadas ideais de estrelas no plano de imagem.",
                                    "Simular aberrações cromáticas básicas dividindo por comprimento de onda.",
                                    "Incorporar desalinhamento de eixos (tangencial distortion).",
                                    "Validar com mapa de distorção plotado sobre estrelas conhecidas."
                                  ],
                                  "verification": "Posições distorcidas coincidem com modelo real de lente (erro < 0.1 pixel).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "NumPy para matrizes de transformação; OpenCV opcional para calibração.",
                                  "tips": "Comece com distorção simples; use otimização least-squares para fit de coeficientes.",
                                  "learningObjective": "Compreender impactos de óptica real em precisão astrométrica.",
                                  "commonMistakes": "Confundir distorção radial com tangencial; ignorar escala não-uniforme."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular centroiding com ruído e gerar medidas",
                                  "subSteps": [
                                    "Calcular centroide ponderado (weighted moments) para cada estrela detectada.",
                                    "Adicionar ruído gaussiano ao centroiding (sigma baseado em SNR).",
                                    "Incluir bias sistemático (ex: pixel não-linearidade) e ruído de leitura.",
                                    "Gerar vetor de medidas: posições 2D + covariâncias para cada frame.",
                                    "Simular sequência temporal com rotação da câmera para rastreamento."
                                  ],
                                  "verification": "Medidas têm estatísticas realistas (desvio < 1 arcsec para estrelas brilhantes).",
                                  "estimatedTime": "3 horas",
                                  "materials": "SciPy para estatísticas; Pandas para log de medidas.",
                                  "tips": "SNR = sinal/ruído guia o sigma; plote distribuições de erro.",
                                  "learningObjective": "Modelar incertezas em estimação de posição sub-pixel.",
                                  "commonMistakes": "Centroiding sem máscara levando a bias; ruído uniforme em vez de poisson."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar rastreamento e validar simulação completa",
                                  "subSteps": [
                                    "Implementar filtro Kalman simples para rastrear estrelas entre frames.",
                                    "Associar detecções via nearest neighbor ou Hungarian algorithm.",
                                    "Gerar quaternions de atitude mock e derivar medidas observadas.",
                                    "Comparar com verdade fundamental (ground truth).",
                                    "Exportar dados para análise (ex: TRIAD ou QUEST para attitude determination)."
                                  ],
                                  "verification": "Rastreamento mantém >90% estrelas por >10 frames; erro de atitude <0.1 deg.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "FilterPy ou pykalman para filtros; Código de attitude determination básico.",
                                  "tips": "Use velocidades angulares realistas (~0.1 deg/s); teste com manobras.",
                                  "learningObjective": "Conectar simulação sensorial a estimação de atitude.",
                                  "commonMistakes": "Associação errada em campos densos; ignorar dropout de estrelas."
                                }
                              ],
                              "practicalExample": "Simule um sensor estelar em um CubeSat em órbita LEO: gere 100 frames com rotação de 1 deg/s, detecte 50 estrelas (mag <7), aplique distorções de uma lente comercial, adicione ruído (sigma=0.5 pixel), e produza medidas para estimar atitude com erro <0.05 deg.",
                              "finalVerifications": [
                                "Simulação gera imagens realistas com estrelas detectadas acima limiar de magnitude.",
                                "Distorções ópticas alteram posições em até 2 pixels nas bordas do FOV.",
                                "Centroides exibem ruído gaussiano com sigma proporcional a 1/SNR.",
                                "Rastreamento mantém identidade de estrelas por sequência de frames.",
                                "Medidas finais permitem recuperação de atitude com precisão sub-arcminuto.",
                                "Código roda em <1 min por 100 frames e é modular/reutilizável."
                              ],
                              "assessmentCriteria": [
                                "Precisão das medidas: erro RMS <1 pixel para centroiding.",
                                "Robustez a ruído: detecção >85% em SNR baixo.",
                                "Fidelidade óptica: mapa de distorção matches modelo real.",
                                "Eficiência computacional: <10 ms/frame em hardware padrão.",
                                "Documentação: código comentado com parâmetros ajustáveis.",
                                "Validação: comparação quantitativa com dados reais (ex: HST star tracker)."
                              ],
                              "crossCurricularConnections": [
                                "Física Óptica: aberrações de lente e difração.",
                                "Estatística: modelagem de ruído gaussiano/poissoniano.",
                                "Processamento de Imagens: detecção de bordas e segmentação.",
                                "Controle e Dinâmica: filtros Kalman para rastreamento.",
                                "Astronomia: catálogos estelares e astrometria."
                              ],
                              "realWorldApplication": "Desenvolvimento de software para star trackers em satélites (ex: CubeSats da NASA, telescópios como JWST), calibração de sensores ópticos em missões espaciais, e treinamento de algoritmos de visão computacional para navegação autônoma em veículos espaciais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Aplicar algoritmos de identificação e estimativa estelar",
                            "description": "Implementar método Lost-in-Space e filtro de Kalman para estimativa de atitude baseada em múltiplas estrelas observadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Identificação Estelar e Catálogos",
                                  "subSteps": [
                                    "Estude catálogos estelares como Hipparcos ou Gaia, focando em magnitude, posição RA/DEC e vetores unitários.",
                                    "Aprenda princípios de observação estelar com CCD em sensores estelares, incluindo ruído e distorções geométricas.",
                                    "Revise representações de atitude: quaternions, matrizes de rotação e ângulos de Euler.",
                                    "Simule geração de medidas estelares a partir de atitude conhecida usando modelo pinhole.",
                                    "Identifique desafios como falsos positivos em identificação devido a estrelas próximas."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes do processo LIS e liste 3 catálogos estelares com suas características.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação Astropy, PDF sobre sensores estelares, Python com numpy e matplotlib.",
                                  "tips": "Use visualizações 3D para entender geometria esférica das estrelas.",
                                  "learningObjective": "Compreender os dados de entrada para algoritmos de identificação estelar.",
                                  "commonMistakes": "Confundir coordenadas celestes (equatoriais) com coordenadas do sensor (body frame)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Algoritmo Lost-in-Space (LIS)",
                                  "subSteps": [
                                    "Gere um subcatálogo de estrelas brilhantes dentro do FOV do sensor (tipicamente 10-20 graus).",
                                    "Extraia características das observações: posições angulares de 2-4 estrelas observadas.",
                                    "Aplique algoritmo de reconhecimento de padrões: triangulação ou k-vector para candidatos de match.",
                                    "Calcule scores de similaridade (ex: distância angular ponderada) e selecione o melhor match.",
                                    "Valide matches com testes de consistência (ex: resíduos < threshold)."
                                  ],
                                  "verification": "Teste com dados simulados: identifique corretamente estrelas em 90% dos casos com ruído baixo.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python, numpy, scipy.spatial para KD-tree, código base de quaternion (pyquaternion).",
                                  "tips": "Otimize com KD-tree para buscas rápidas em catálogos grandes.",
                                  "learningObjective": "Implementar LIS para aquisição inicial de atitude sem conhecimento prévio.",
                                  "commonMistakes": "Ignorar magnitude na seleção de subcatálogo, levando a matches errados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Filtro de Kalman para Estimativa de Atitude",
                                  "subSteps": [
                                    "Defina estado: quaternion de atitude + velocidades angulares (7D).",
                                    "Modele dinâmica: propagação com equações de cinemática de quaternions e aceleração zero ou conhecida.",
                                    "Defina modelo de observação: medidas de vetor estelar mapeadas para body frame via direção conhecida.",
                                    "Implemente predição (EKF com multiplicativa para quaternions) e update com Jacobianas.",
                                    "Ajuste covariâncias Q (processo) e R (medida) baseadas em simulações."
                                  ],
                                  "verification": "Execute filtro em loop aberto: covariância converge para valores estáveis.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python com filterpy ou implementações customizadas, numpy para lineares.",
                                  "tips": "Normalizar quaternions após cada update para evitar drift numérico.",
                                  "learningObjective": "Criar um EKF robusto para fusão de medidas estelares.",
                                  "commonMistakes": "Jacobianas erradas no update, causando instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar LIS com Kalman e Simular Cenários",
                                  "subSteps": [
                                    "Inicie com LIS para atitude inicial quando lost-in-space detectado.",
                                    "Transição para modo tracking: use Kalman para refinar com novas observações.",
                                    "Simule cenários: aquisição inicial, tracking contínuo, perda de estrelas por rotação.",
                                    "Adicione ruído realista (gaussiano em posições, dropout de estrelas).",
                                    "Implemente lógica de handover: re-inicialize LIS se erro de atitude > threshold."
                                  ],
                                  "verification": "Simulação completa: erro RMS de atitude < 0.1 graus após 10s de tracking.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Código dos steps anteriores, matplotlib para plots de erro vs tempo.",
                                  "tips": "Grave logs de estados e plots de convergência para debug.",
                                  "learningObjective": "Integrar aquisição e tracking para estimativa contínua.",
                                  "commonMistakes": "Falta de gating em matches, permitindo outliers no Kalman."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Otimizar o Sistema",
                                  "subSteps": [
                                    "Teste Monte Carlo: 100 runs com variações de ruído e FOV.",
                                    "Calcule métricas: tempo de aquisição, precisão final, taxa de falha.",
                                    "Tune hiperparâmetros: thresholds LIS, covariâncias Kalman via grid search.",
                                    "Analise sensibilidade a condições (nuvens estelares, magnitude limite).",
                                    "Documente código com comentários e gere relatório de performance."
                                  ],
                                  "verification": "Relatório mostra precisão < 10 arcsec em 95% dos casos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Scripts de simulação, Jupyter notebook para análise.",
                                  "tips": "Use seed para reprodutibilidade em Monte Carlo.",
                                  "learningObjective": "Avaliar robustez e otimizar para cenários reais.",
                                  "commonMistakes": "Sobre-otimização para um cenário, perdendo generalização."
                                }
                              ],
                              "practicalExample": "Simule um CubeSat perdido no espaço: use LIS para identificar 3 estrelas no FOV de 15°, inicialize Kalman, e track atitude durante manobra de rotação a 1°/s, alcançando precisão de 5 arcsec após 30s.",
                              "finalVerifications": [
                                "LIS identifica estrelas corretamente em >95% dos testes com ruído.",
                                "Kalman converge para erro <0.01° em <10s de tracking.",
                                "Sistema lida com perda de 50% das estrelas sem divergência.",
                                "Código roda em tempo real (<1s por ciclo).",
                                "Plots mostram resíduos gaussianos e covariância decrescente.",
                                "Handover LIS-Kalman sem jumps >1°."
                              ],
                              "assessmentCriteria": [
                                "Precisão da atitude estimada (RMS error <10 arcsec).",
                                "Robustez a ruído e dropout (sucesso >90% em Monte Carlo).",
                                "Eficiência computacional (tempo por frame <100ms).",
                                "Correção de implementação (matches LIS validados, Jacobianas corretas).",
                                "Documentação e modularidade do código.",
                                "Análise de sensibilidade reportada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rotação), probabilidade (filtros bayesianos).",
                                "Física/Astronomia: Cinemática orbital, coordenadas celestes.",
                                "Programação: Otimização numérica, simulações estocásticas.",
                                "Engenharia de Controle: Estimadores de estado, fusão sensorial."
                              ],
                              "realWorldApplication": "Usado em satélites como o Hubble Space Telescope para aquisição autônoma de atitude, CubeSats para controle preciso sem GPS, e missões interplanetárias como New Horizons para navegação estelar em deep space."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.4",
                        "name": "Sensores Inerciais",
                        "description": "Modelagem de giroscópios e acelerômetros para propagação e estimativa de atitude em curto prazo.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.4.1",
                            "name": "Modelar dinâmica de sensores inerciais",
                            "description": "Derivar equações de integração de taxas angulares de giroscópios e correção de biases e scale factors para quaternions de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos de Giroscópios e Representação de Atitude com Quaternions",
                                  "subSteps": [
                                    "Estude o princípio de operação de giroscópios inerciais e como medem taxas angulares (ωx, ωy, ωz).",
                                    "Revise a representação de atitude usando quaternions unitários (q = [q0, q1, q2, q3]) e suas propriedades (norma 1).",
                                    "Entenda a cinemática de rotação: relação entre vetor de taxa angular ω e derivada do quaternion ḣq.",
                                    "Implemente uma função simples para normalizar quaternions em código (ex: Python com NumPy).",
                                    "Visualize rotações 3D usando quaternios em uma ferramenta como Matplotlib."
                                  ],
                                  "verification": "Capacidade de explicar verbalmente a relação ω → ḣq e normalizar um quaternion de exemplo corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Rigid Body Dynamics' ou notas de curso de aeroespacial",
                                    "NumPy e Matplotlib instalados",
                                    "Referência: 'Quaternion Kinematics for Error-State Kalman Filter' paper"
                                  ],
                                  "tips": "Sempre verifique a norma do quaternion após operações para evitar drift numérico.",
                                  "learningObjective": "Compreender os conceitos básicos de sensores giroscópicos e quaternions para modelagem de atitude.",
                                  "commonMistakes": "Confundir quaternions com vetores de Euler; esquecer normalização levando a quaternions não unitários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivação das Equações de Integração de Taxas Angulares para Quaternions",
                                  "subSteps": [
                                    "Derive a equação cinemática ḣq = (1/2) * Ω(ω) * q, onde Ω(ω) é a matriz skew-symmetric de ω.",
                                    "Expanda Ω(ω) explicitamente: [[0, -ωz, ωy, ωx], [ωz, 0, -ωx, ωy], ...].",
                                    "Integre numericamente usando método de Runge-Kutta de 4ª ordem (RK4) para propagar q(t).",
                                    "Implemente o integrador em código, testando com ω constante (rotação uniforme).",
                                    "Compare resultados analíticos (para caso simples) com numéricos."
                                  ],
                                  "verification": "Código roda sem erros e produz rotação correta para ω constante (ex: 90° em 10s).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "SciPy para integração numérica",
                                    "Caderno para derivações matemáticas",
                                    "Exemplo de código base de quaternion integration"
                                  ],
                                  "tips": "Use pequenos passos de tempo (dt < 0.01s) para precisão em simulações de alta taxa angular.",
                                  "learningObjective": "Derivar e implementar a integração de taxas angulares para propagação de quaternions.",
                                  "commonMistakes": "Erro no sinal da matriz Ω(ω); integração Euler simples causando drift rápido."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelagem de Erros em Giroscópios: Biases e Scale Factors",
                                  "subSteps": [
                                    "Defina o modelo de erro: ω_meas = S * (ω_true + b) + noise, onde S é matriz de scale factors, b é bias.",
                                    "Estime bias b como média de ω em repouso (turn-on bias).",
                                    "Modele scale factors S como diagonal (Sx, Sy, Sz) e derive correções: ω_corr = S_inv * (ω_meas - b).",
                                    "Implemente estimação de b e S usando dados simulados ou reais de giroscópio.",
                                    "Adicione ruído gaussiano ao modelo para realismo."
                                  ],
                                  "verification": "Após correção, erro de atitude < 1° após 60s de simulação com biases introduzidos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Dados de giroscópio simulados (gerados via script)",
                                    "Biblioteca Pandas para análise de dados",
                                    "Referência: IMU error modeling papers"
                                  ],
                                  "tips": "Calibre bias em múltiplas condições estáticas para robustez.",
                                  "learningObjective": "Modelar e quantificar erros sistemáticos em medições de giroscópios.",
                                  "commonMistakes": "Ignorar cross-coupling em scale factors; subestimar variabilidade temporal do bias."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração Completa do Modelo com Correções e Simulação",
                                  "subSteps": [
                                    "Combine integração corrigida: use ω_corr em RK4 para propagar q.",
                                    "Simule manobras espaciais (ex: slew de satélite) com erros realistas.",
                                    "Implemente re-normalização periódica de q para mitigar drift.",
                                    "Gere plots de atitude vs tempo, com e sem correções.",
                                    "Avalie sensibilidade a variações de b e S."
                                  ],
                                  "verification": "Simulação completa mostra convergência de atitude corrigida para verdade ground-truth.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ambiente Jupyter Notebook",
                                    "Dados de manobra de satélite (ex: de NASA]",
                                    "Ferramentas de plotting avançadas como Plotly"
                                  ],
                                  "tips": "Salve estados em checkpoints para depuração longa simulação.",
                                  "learningObjective": "Construir e simular um modelo completo de dinâmica de sensores inerciais para atitude.",
                                  "commonMistakes": "Acúmulo de erro sem re-normalização; passos de tempo inadequados em manobras rápidas."
                                }
                              ],
                              "practicalExample": "Simule a determinação de atitude de um CubeSat durante uma manobra de apontamento: integre taxas angulares de giroscópios com bias de 0.01°/s e scale error de 1%, corrigindo para manter erro de atitude abaixo de 0.5° após 300s.",
                              "finalVerifications": [
                                "Equações derivadas coincidem com referências padrão (ex: Ω(ω) correta).",
                                "Código simula rotação sem drift excessivo (>99% norma quaternion preservada).",
                                "Correções reduzem erro de atitude em pelo menos 80% em teste com erros conhecidos.",
                                "Plots mostram atitude corrigida alinhada com ground-truth.",
                                "Modelo lida com ω nulos (repouso) sem acumulação de bias.",
                                "Execução eficiente: simulação de 1h real-time em <1min computacional."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivações matemáticas (sem erros algébricos).",
                                "Correta implementação de correções de bias e scale factors.",
                                "Estabilidade numérica da integração (erro <0.1°/h em repouso).",
                                "Capacidade de generalizar para diferentes cenários de manobra.",
                                "Clareza e documentação do código (comentários em equações chave).",
                                "Análise quantitativa de erros (RMSE de atitude <1°)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes skew-symmetric), cálculo diferencial (cinemática).",
                                "Física: Dinâmica de corpo rígido, mecânica orbital.",
                                "Programação: Integração numérica (RK4), manipulação de arrays multidimensionais.",
                                "Estatística: Estimação de parâmetros (bias via médias), modelagem de ruído.",
                                "Engenharia de Controle: Fundamentos para filtros Kalman em AHRS."
                              ],
                              "realWorldApplication": "Em satélites e naves espaciais (ex: ISS, Starlink), para propagar atitude entre atualizações de estrelas-trackers, corrigindo erros de IMU para manter precisão de apontamento de antenas e câmeras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.4.2",
                            "name": "Implementar simulação de propagação inercial",
                            "description": "Simular deriva inercial ao longo do tempo com ruído aleatório e vibrações, comparando com atitude verdadeira.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir modelo matemático de atitude verdadeira e sensores inerciais",
                                  "subSteps": [
                                    "Estabeleça quaternions ou matrizes de rotação para representar a atitude verdadeira ao longo do tempo.",
                                    "Defina velocidades angulares verdadeiras (ω_true) usando funções suaves como seno ou perfis de manobra.",
                                    "Modele leituras de giroscópio ideais como ω_measured = ω_true.",
                                    "Especifique parâmetros iniciais: tempo de simulação (ex: 3600s), taxa de amostragem (100Hz).",
                                    "Implemente uma função para gerar a ground truth integrando ω_true."
                                  ],
                                  "verification": "Execute código e verifique se quaternions de atitude verdadeira têm norma unitária ≈1 e evoluem suavemente.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python, NumPy, SciPy (para integração quaternion)",
                                  "tips": "Use scipy.spatial.transform.Rotation para manipulação de rotações.",
                                  "learningObjective": "Compreender representação matemática de atitude e sensores inerciais ideais.",
                                  "commonMistakes": "Normalizar quaternions incorretamente, levando a deriva numérica; ignorar taxa de amostragem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar propagação inercial básica via integração numérica",
                                  "subSteps": [
                                    "Implemente equação cinemática: d(q)/dt = 0.5 * q * ω (em quaternions).",
                                    "Use método de Runge-Kutta (RK4) ou scipy.integrate.odeint para integrar ao longo do tempo.",
                                    "Inicialize quaternion estimado como q_est(0) = q_true(0).",
                                    "Propague q_est(t) = ∫ ω_measured dt a partir de condições iniciais.",
                                    "Armazene trajetórias de q_true e q_est em arrays temporais."
                                  ],
                                  "verification": "Sem erros, q_est deve coincidir exatamente com q_true; plote ângulos de erro = 0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python, NumPy, SciPy.integrate",
                                  "tips": "Implemente multiplicação quaternion-vetor manualmente para compreensão profunda.",
                                  "learningObjective": "Dominar integração numérica para propagação de atitude inercial.",
                                  "commonMistakes": "Erro na ordem de multiplicação quaternion (q*ω vs ω*q); passos de tempo grandes causando instabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar ruído aleatório, bias e vibrações aos sensores",
                                  "subSteps": [
                                    "Gere bias constante: ω_bias ~ N(0, σ_bias).",
                                    "Adicione ruído branco: ω_noise ~ N(0, σ_noise) por amostra.",
                                    "Modele vibrações como sinal senoidal: ω_vib = A * sin(2π f t + φ), com f alta (ex: 50Hz).",
                                    "Combine: ω_measured = ω_true + ω_bias + ω_noise + ω_vib.",
                                    "Re-propagar q_est com ω_measured ruidosa e plote deriva inicial."
                                  ],
                                  "verification": "Plots mostram deriva crescente em q_est vs q_true; estatísticas de ruído coincidem com σ especificados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python, NumPy.random, Matplotlib",
                                  "tips": "Use np.cumsum para bias persistente; filtre vibrações se necessário para realismo.",
                                  "learningObjective": "Modelar erros realistas de sensores inerciais e seu impacto na propagação.",
                                  "commonMistakes": "Ruído não correlacionado corretamente; vibrações com amplitude irreal (A < 0.01 rad/s)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular ao longo do tempo, comparar e visualizar resultados",
                                  "subSteps": [
                                    "Execute simulação completa por 1 hora com parâmetros realistas (σ_noise=0.01°/s/√Hz, bias=0.005°/s).",
                                    "Calcule erros: ângulo de erro ε = 2*acos(q_true · q_est).",
                                    "Gere plots: atitude vs tempo, erro cumulativo, histograma de ruído.",
                                    "Compare curvas: deriva inercial ~ t²/2 devido a bias.",
                                    "Exporte dados para análise adicional."
                                  ],
                                  "verification": "Erro cresce quadraticamente; RMS erro > 1° após 30min, consistente com teoria.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python, Matplotlib, Seaborn para plots",
                                  "tips": "Use subplots para múltiplas visualizações; anote desvios padrão nos plots.",
                                  "learningObjective": "Analisar e validar simulação de propagação inercial com erros.",
                                  "commonMistakes": "Escala errada em plots ocultando deriva; não computar norma de quaternion."
                                }
                              ],
                              "practicalExample": "Simule um satélite CubeSat em órbita baixa: ω_true = [0.001, 0.002, 0.0005] rad/s constantes + manobra de 10°/s. Adicione bias 0.005°/s/√hr e ruído 0.01°/s/√Hz. Após 1h, q_est diverge 2° da q_true, demonstrando necessidade de correção por estrelas.",
                              "finalVerifications": [
                                "Norma de todos quaternions ≈1 (erro <1e-10).",
                                "Erro de atitude cresce quadraticamente com tempo devido a bias.",
                                "Estatísticas de ruído: média≈0, desvio=σ especificado.",
                                "Plots mostram vibrações de alta frequência em ω_measured.",
                                "Propagação sem ruído reproduz q_true perfeitamente.",
                                "RMS erro final >0.5° para parâmetros realistas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática da integração (erro numérico <1e-6).",
                                "Realismo dos modelos de erro (consistente com specs de giroscópios MEMS).",
                                "Qualidade dos plots e análises (legendas, escalas corretas).",
                                "Código modular e comentado, executável sem erros.",
                                "Compreensão demonstrada em comentários sobre deriva inercial.",
                                "Tempo de simulação eficiente (<10s para 1h de dados)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Cinemática de corpo rígido e equações de rotação.",
                                "Estatística: Modelagem estocástica de ruído gaussiano.",
                                "Programação: Integração numérica e manipulação vetorial.",
                                "Engenharia de Controle: Impacto de erros em sistemas de navegação."
                              ],
                              "realWorldApplication": "Em veículos espaciais como o James Webb Telescope, simulações de propagação inercial validam sistemas de determinação de atitude (ADCS), prevendo desvios para fusão com sensores como star trackers, essencial para apontamento preciso de instrumentos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.4.3",
                            "name": "Integrar sensores inerciais com estimadores de atitude",
                            "description": "Desenvolver filtro complementar ou Kalman estendido para fusão de medidas inerciais com sensores absolutos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sensores Inerciais e Estimadores de Atitude",
                                  "subSteps": [
                                    "Estude os princípios de funcionamento de giroscópios e acelerômetros (IMUs).",
                                    "Revise representações de atitude (quaternions, ângulos de Euler, matrizes de rotação).",
                                    "Analise estimadores básicos de atitude como integradores de giroscópio e correções com sensores absolutos (magnetômetro, GPS).",
                                    "Identifique limitações: drift em giroscópios e ruído em sensores absolutos.",
                                    "Colete especificações de sensores reais (ex: MPU-6050 ou ADIS16488)."
                                  ],
                                  "verification": "Resuma em um diagrama os sinais de entrada/saída e equações de propagação de atitude.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Documentação de IMUs (datasheets), MATLAB/Python com bibliotecas como numpy/scipy, tutoriais sobre quaternions."
                                  ],
                                  "tips": "Use visualizações 3D para entender rotações e evitar confusão com convenções de ângulos.",
                                  "learningObjective": "Compreender os dados crus e modelos cinemáticos necessários para fusão.",
                                  "commonMistakes": "Ignorar alinhamento de eixos entre sensores ou confundir coordenadas corpo/inercial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Sistema de Estados e Medidas para Fusão",
                                  "subSteps": [
                                    "Defina o vetor de estado: atitude (quaternions), biases de giroscópio, velocidades angulares.",
                                    "Escreva a equação de propagação discreta usando integração numérica (RK4 ou Euler).",
                                    "Modele medidas: aceleração corrigida por gravidade para roll/pitch, magnetômetro para yaw.",
                                    "Formule a matriz de Jacobiana para linearização (necessária para EKF).",
                                    "Implemente funções para previsão e atualização em pseudocódigo."
                                  ],
                                  "verification": "Gere plots de simulação open-loop mostrando drift sem fusão.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (sympy para Jacobianas), paper 'Quaternion kinematics for error-state Kalman filter'."
                                  ],
                                  "tips": "Comece com filtro complementar simples antes de EKF para validar modelo.",
                                  "learningObjective": "Criar modelo dinâmico e de observabilidade para o filtro.",
                                  "commonMistakes": "Estado não observável (ex: yaw sem magnetômetro), Jacobiana incorreta levando a instabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Filtro Complementar ou Estendido Kalman (EKF)",
                                  "subSteps": [
                                    "Escolha e implemente: filtro complementar (ganhos proporcionais) ou EKF completo.",
                                    "Codifique a etapa de previsão: propagar estado e covariância com ruído de processo.",
                                    "Codifique a etapa de atualização: calcular ganho de Kalman, inovações e correção.",
                                    "Inicialize covariâncias: Q (processo), R (medida) baseadas em datasheets.",
                                    "Adicione detecção de falhas (innovation bounds, chi-squared test)."
                                  ],
                                  "verification": "Execute loop fechado em simulação estática; verifique convergência para verdade ground.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": [
                                    "Python (filterpy ou custom), MATLAB Aerospace Toolbox, exemplos de código open-source como RTIMULib."
                                  ],
                                  "tips": "Tune Q/R iterativamente: comece com valores altos e reduza baseado em resíduos.",
                                  "learningObjective": "Desenvolver algoritmo de fusão sensorial em código executável.",
                                  "commonMistakes": "Normalização incorreta de quaternions, overflow em covariâncias, tuning inadequado causando oscilações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, Testar e Otimizar a Integração",
                                  "subSteps": [
                                    "Crie cenários de simulação: manobras espaciais (rotações 3D, tumbling).",
                                    "Injete ruído realista e falhas (bias shift, outages).",
                                    "Compare performance: erro RMS de atitude vs. sensores isolados.",
                                    "Otimize hiperparâmetros via grid search ou otimização bayesiana.",
                                    "Integre em simulador de veículo (ex: JSBSim ou custom 6DOF)."
                                  ],
                                  "verification": "Gere relatórios com métricas: tempo de convergência < 10s, erro < 1° em steady-state.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": [
                                    "Simulink/Python para 6DOF dynamics, dados de telemetria real de cubsats (ex: NASA)."
                                  ],
                                  "tips": "Use Monte Carlo runs (100+) para estatísticas robustas.",
                                  "learningObjective": "Validar filtro em condições realistas e iterar melhorias.",
                                  "commonMistakes": "Testes só em condições ideais, ignorar latência de sensores, superestimação de performance."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Preparar para Deploy Real",
                                  "subSteps": [
                                    "Documente arquitetura, equações e tuning em relatório LaTeX.",
                                    "Exporte código para embedded (C++ com Eigen para ARM/STM32).",
                                    "Teste hardware-in-loop com IMU real.",
                                    "Avalie computacional: ciclos CPU, memória.",
                                    "Planeje certificação: DO-178C compliance para aeroespacial."
                                  ],
                                  "verification": "Demo em hardware mostrando atitude estável em bancada rotativa.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Hardware: Arduino/RPi + IMU, ROS para HIL, Eigen library."
                                  ],
                                  "tips": "Versione código com Git; inclua unit tests para funções críticas.",
                                  "learningObjective": "Transicionar de simulação para aplicação prática.",
                                  "commonMistakes": "Código não portable, falta de profiling de performance."
                                }
                              ],
                              "practicalExample": "Em um CubeSat simulado, integre dados de MPU-9250 (IMU) com magnetômetro para estimar atitude durante detumbling pós-lançamento, corrigindo drift de 5°/s para precisão de 0.5° em 30s.",
                              "finalVerifications": [
                                "Filtro converge em <10s para manobras de 90°/s.",
                                "Erro RMS de atitude <1° em simulações com ruído realista.",
                                "Covariância converge sem divergência.",
                                "Robustez a outages de 5s em sensores absolutos.",
                                "Performance em tempo real: >100Hz update rate.",
                                "Comparação com baseline (Madgwick filter) mostra melhoria >20%."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro de atitude <2° em 95% dos casos.",
                                "Robustez: mantém estimativa durante falhas sensoriais.",
                                "Eficiência: latência <10ms, uso CPU <30%.",
                                "Observabilidade: rank completo da matriz.",
                                "Documentação: equações, tuning e testes reproduzíveis.",
                                "Escalabilidade: adapta a diferentes IMUs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (Jacobianas), Probabilidade (filtros bayesianos).",
                                "Programação: Algoritmos numéricos, Otimização (SciPy).",
                                "Física: Dinâmica rotacional, Cinemática de rígidos.",
                                "Engenharia de Software: Testes unitários, Integração contínua.",
                                "Eletrônica: Interfaces I2C/SPI para sensores."
                              ],
                              "realWorldApplication": "Em satélites como o CubeSat da NASA (MarCO), fusão IMU+magnômetro mantém orientação precisa para comunicação laser durante missões interplanetárias, evitando perda de sinal por drift."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Simulação de Perturbações Externas em Atitude",
                    "description": "Simulação de torques de pressão solar e magnético afetando a dinâmica de atitude.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Simulação de Torque de Pressão Solar",
                        "description": "Modelagem e simulação do torque gerado pela pressão de radiação solar sobre superfícies do veículo espacial, considerando sua influência na dinâmica de atitude, conforme descrito em Sidi (2006) e Wiesel (2010).",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Calcular o torque de pressão solar",
                            "description": "Derivar e computar o vetor de torque devido à pressão solar, utilizando a fórmula τ_solar = (A · cosθ · P_solar / c) × r_cm, onde A é a área projetada, θ o ângulo de incidência, P_solar a pressão solar e r_cm o vetor ao centro de massa, para diferentes orientações do satélite.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de pressão de radiação solar e torque",
                                  "subSteps": [
                                    "Estudar o conceito de pressão de radiação: P_solar = I / c, onde I é a intensidade solar e c a velocidade da luz.",
                                    "Revisar o que é torque vetorial: τ = r × F, e sua importância em dinâmica rotacional.",
                                    "Entender a pressão solar em superfícies espaciais: força por área projetada perpendicular à direção do sol.",
                                    "Analisar como a pressão solar gera torque em satélites não simétricos via deslocamento do centro de pressão.",
                                    "Explorar unidades: Pa (Pascal) para pressão, Nm para torque."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como a pressão solar causa torque em um satélite, citando a fórmula básica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de dinâmica orbital (ex: 'Orbital Mechanics for Engineering Students')",
                                    "Vídeos sobre pressão de radiação no YouTube/Khan Academy",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Visualize o satélite como uma vela solar: a luz empurra perpendicular à superfície iluminada.",
                                  "learningObjective": "O aluno compreenderá os princípios físicos da pressão solar e torque, preparando para a derivação.",
                                  "commonMistakes": [
                                    "Confundir pressão solar com pressão atmosférica",
                                    "Ignorar que a força é na direção da luz incidente",
                                    "Esquecer que torque requer braço de alavanca assimétrico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e parametrizar os componentes da fórmula de torque solar",
                                  "subSteps": [
                                    "Definir A: área projetada da superfície perpendicular ao vetor solar (A = A_total * cosθ).",
                                    "Explicar θ: ângulo de incidência entre o vetor solar e a normal da superfície.",
                                    "Determinar P_solar: pressão solar típica (cerca de 4.5 μPa na Terra).",
                                    "Localizar r_cm: vetor do centro de massa ao centro de pressão.",
                                    "Entender c: velocidade da luz (3 × 10^8 m/s), constante na fórmula."
                                  ],
                                  "verification": "Listar e descrever cada parâmetro da fórmula τ_solar = (A · cosθ · P_solar / c) × r_cm com valores típicos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel ou software de desenho vetorial (ex: GeoGebra)",
                                    "Tabela de constantes físicas (P_solar ≈ 4.56 × 10^-6 Pa)"
                                  ],
                                  "tips": "Desenhe diagramas 3D do satélite com vetores solar, normal e r_cm para visualizar.",
                                  "learningObjective": "O aluno identificará corretamente todos os parâmetros e suas unidades na fórmula.",
                                  "commonMistakes": [
                                    "Usar área total em vez de projetada",
                                    "Confundir θ com ângulo azimutal",
                                    "Esquecer a divisão por c"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a fórmula do torque de pressão solar passo a passo",
                                  "subSteps": [
                                    "Calcular a força solar: F_solar = (A · cosθ · P_solar), na direção do vetor solar.",
                                    "Ajustar pela relatividade: F_solar = (A · cosθ · I / c), onde P_solar = I/c.",
                                    "Determinar o ponto de aplicação: centro de pressão, deslocado de r_cm.",
                                    "Aplicar τ = r_cm × F_solar, resultando em τ_solar = (A · cosθ · P_solar / c) × r_cm.",
                                    "Verificar dimensionalmente: [F] = Pa * m² = N, τ = N * m."
                                  ],
                                  "verification": "Derivar a fórmula do zero e compará-la com a dada, mostrando cada equação intermediária.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Software simbólico como SymPy (Python) para vetores"
                                  ],
                                  "tips": "Use notação vetorial: assuma vetor solar unitário ŝ, F = (A cosθ P_solar / c) ŝ.",
                                  "learningObjective": "O aluno derivará com confiança a fórmula completa do torque solar.",
                                  "commonMistakes": [
                                    "Erro no produto vetorial (direção errada)",
                                    "Omitir cosθ na projeção",
                                    "Confundir escalar e vetor na força"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar torque para orientações específicas do satélite",
                                  "subSteps": [
                                    "Escolher uma orientação: θ = 0° (normal ao sol), r_cm = [0.1, 0, 0] m.",
                                    "Calcular numericamente: A=1 m², P_solar=4.5e-6 Pa, c=3e8 m/s.",
                                    "Executar produto cruzado: τ = |r_cm| * F * sinφ (φ=90° aqui).",
                                    "Variar θ para 30°, 60°, calcular magnitude e direção.",
                                    "Implementar em código simples para automação."
                                  ],
                                  "verification": "Resolver um problema numérico dado e obter τ correto (ex: magnitude 1.5e-10 Nm).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/MATLAB com NumPy",
                                    "Planilha Excel para cálculos"
                                  ],
                                  "tips": "Sempre normalize vetores e verifique direção com regra da mão direita.",
                                  "learningObjective": "O aluno calculará torque vetorial com precisão para casos dados.",
                                  "commonMistakes": [
                                    "Erro de ordem de grandeza (microPa vs Pa)",
                                    "Direção errada no cross product",
                                    "Esquecer unidades SI"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simular torque para diferentes orientações e validar",
                                  "subSteps": [
                                    "Definir matriz de rotação para orientações variadas (roll, pitch, yaw).",
                                    "Loop em θ de 0° a 180°, plotar τ vs θ.",
                                    "Comparar com software de simulação (ex: GMAT ou Orekit).",
                                    "Analisar impacto em controle de atitude: magnitude típica vs rodas de reação.",
                                    "Documentar resultados em relatório curto."
                                  ],
                                  "verification": "Gerar gráfico de τ(θ) e explicar picos/mínimos físicos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "Documentação de simulação orbital"
                                  ],
                                  "tips": "Use quaternions para rotações precisas sem gimbal lock.",
                                  "learningObjective": "O aluno simulará e analisará torque em cenários reais de satélite.",
                                  "commonMistakes": [
                                    "Ignorar variação diária de P_solar",
                                    "Não considerar múltiplas faces",
                                    "Plot errada (polar vs cartesiano)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um CubeSat 1U (A projetada=0.01 m², θ=30°, P_solar=4.5 μPa, c=3e8 m/s, r_cm=[0.05, 0.02, 0] m): F_solar=(0.01*cos(30°)*4.5e-6)=3.89e-8 N; τ_solar = r_cm × F_solar ≈ [0, -1.95e-9, 1.95e-10] Nm. Implemente em Python para rotacionar o satélite.",
                              "finalVerifications": [
                                "Derivar corretamente a fórmula τ_solar a partir de princípios físicos.",
                                "Calcular torque para 3 orientações diferentes com erro <1%.",
                                "Explicar direção do torque via produto vetorial.",
                                "Simular variação de τ com θ e identificar máximo.",
                                "Comparar resultado com valor de referência de literatura.",
                                "Implementar função computacional reutilizável."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos vetoriais (90%+ correto).",
                                "Compreensão física: explicar causalidade de torque.",
                                "Qualidade da derivação: passos lógicos e completos.",
                                "Efetividade da simulação: gráficos claros e análise.",
                                "Correção de unidades e ordens de grandeza.",
                                "Criatividade em exemplos reais de satélites."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra vetorial e produto cruzado.",
                                "Física: Mecânica clássica e eletromagnetismo (radiação).",
                                "Programação: NumPy/SciPy para simulações numéricas.",
                                "Engenharia: Modelagem de sistemas dinâmicos em aeroespacial.",
                                "Astronomia: Variação de fluxo solar com distância heliocêntrica."
                              ],
                              "realWorldApplication": "Em missões como o satélite Amazonia-1 ou CubeSats da ISS, o torque solar é modelado em softwares de controle de atitude (ex: ADCS) para compensar perturbações via rodas de inércia ou propulsores, garantindo apontamento preciso de antenas/câmeras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Incorporar torque solar nas equações de atitude",
                            "description": "Integrar o torque de pressão solar nas equações diferenciais de Euler rígido para rotação, modificando o modelo dinâmico J · ω_dot + ω × (J · ω) = τ_control + τ_solar + outras perturbações, implementando em software de simulação como MATLAB/Simulink.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações de Atitude Básicas de Corpo Rígido",
                                  "subSteps": [
                                    "Estude as equações diferenciais de Euler para rotação: J · ω_dot + ω × (J · ω) = τ_total.",
                                    "Identifique os componentes atuais de τ_total (ex: τ_control, τ_grav, τ_drag).",
                                    "Revise a representação quaternion ou ângulos de Euler para atitude.",
                                    "Confirme a inércia J do veículo espacial e sua dependência de configuração.",
                                    "Anote limitações do modelo atual sem perturbações solares."
                                  ],
                                  "verification": "Resuma as equações em um documento e derive manualmente para um caso simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de dinâmica orbital (ex: Vallado)",
                                    "Notas de equações de atitude",
                                    "MATLAB para verificação simbólica"
                                  ],
                                  "tips": "Use syms no MATLAB para manipulação simbólica das equações.",
                                  "learningObjective": "Compreender a estrutura das equações de atitude e identificar onde adicionar τ_solar.",
                                  "commonMistakes": [
                                    "Confundir frame inercial com body frame",
                                    "Ignorar termos não lineares ω × (J · ω)",
                                    "Assumir J constante sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Torque de Pressão Solar (τ_solar)",
                                  "subSteps": [
                                    "Calcule a pressão solar P = 4.56e-6 N/m² na Terra.",
                                    "Defina a área projetada A_proj = A · n_sun (vetor normal à superfície para direção solar).",
                                    "Formule τ_solar = r_cm × (P · A_proj · c_r), onde r_cm é vetor ao centro de massa, c_r coeficiente de reflexão.",
                                    "Expresse n_sun no body frame usando quaternions de atitude.",
                                    "Considere shadowing e variação orbital (ex: fator de eclipse)."
                                  ],
                                  "verification": "Implemente função MATLAB para τ_solar dado quaternion e posição orbital; teste com valores conhecidos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação NASA sobre pressão solar",
                                    "MATLAB Aerospace Toolbox",
                                    "Dados de satélite exemplo (área, c_r)"
                                  ],
                                  "tips": "Use unit vectors para n_sun e normalize vetores de posição.",
                                  "learningObjective": "Derivar e computar τ_solar como vetor no body frame.",
                                  "commonMistakes": [
                                    "Esquecer o braço de momento r_cm",
                                    "Usar pressão constante sem eclipse",
                                    "Confundir coeficientes absorção vs reflexão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar τ_solar nas Equações de Atitude",
                                  "subSteps": [
                                    "Modifique τ_total = τ_control + τ_solar + τ_outras.",
                                    "Atualize o modelo dinâmico: J · ω_dot = -ω × (J · ω) + τ_total.",
                                    "Inclua propagação de atitude (ex: q_dot = 0.5 · Ω(ω) · q).",
                                    "Linearize se necessário para análise de controle.",
                                    "Documente suposições (ex: corpo rígido, J diagonal)."
                                  ],
                                  "verification": "Derive as equações modificadas em papel e compare com original.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno para derivações",
                                    "MATLAB Symbolic Math Toolbox",
                                    "Referências de controle de atitude"
                                  ],
                                  "tips": "Mantenha consistência de frames: tudo em body frame.",
                                  "learningObjective": "Incorporar τ_solar corretamente no modelo dinâmico completo.",
                                  "commonMistakes": [
                                    "Erro de sinal no termo coriolis",
                                    "Não propagar τ_solar para equações cinemáticas",
                                    "Ignorar acoplamento com translação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Simular em MATLAB/Simulink",
                                  "subSteps": [
                                    "Crie script MATLAB com ODE45 para integrar equações modificadas.",
                                    "Adicione bloco Simulink para τ_solar baseado em ephimerides solares.",
                                    "Configure condições iniciais: órbita LEO, atitude inicial.",
                                    "Rode simulação com/ sem τ_solar e plote ω(t), q(t).",
                                    "Otimize para tempo real se aplicável."
                                  ],
                                  "verification": "Compare drift de atitude com/ sem τ_solar; deve mostrar desvio mensurável.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Aerospace Blockset",
                                    "Dados orbitais SGP4"
                                  ],
                                  "tips": "Use ode45 com tolerâncias apertadas para precisão.",
                                  "learningObjective": "Implementar modelo numérico funcional e observável.",
                                  "commonMistakes": [
                                    "Índices errados em matrizes de rotação",
                                    "Não inicializar quaternions unitários",
                                    "Escala errada de τ_solar (muito pequeno)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar Resultados",
                                  "subSteps": [
                                    "Compare com literatura ou dados reais de missões.",
                                    "Calcule erro de atitude RMS com/ sem modelo.",
                                    "Teste sensibilidade a parâmetros (área, c_r).",
                                    "Adicione controle PD e avalie mitigação.",
                                    "Gere relatório com plots e conclusões."
                                  ],
                                  "verification": "Erro de atitude < 5° em 1 órbita sem controle, reduzido com controle.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados de CubeSat reais",
                                    "Ferramentas de plot MATLAB",
                                    "Referências validadas"
                                  ],
                                  "tips": "Use log scales para perturbações pequenas.",
                                  "learningObjective": "Validar implementação e quantificar impacto de τ_solar.",
                                  "commonMistakes": [
                                    "Não considerar múltiplas superfícies",
                                    "Ignorar J2 ou outras perturbações dominantes",
                                    "Overfitting a um caso específico"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat 1U em órbita LEO (400km, 98° inclinação) com painéis solares assimétricos (A=0.01m², c_r=1.5). Rode 3 órbitas sem controle: observe drift de roll devido a τ_solar ~1e-7 Nm, atingindo 2° em 90min.",
                              "finalVerifications": [
                                "τ_solar computado varia com atitude e órbita corretamente.",
                                "Simulação mostra impacto mensurável em ω e q sem controle.",
                                "Modelo integrado roda sem erros numéricos em ODE.",
                                "Comparação com caso sem τ_solar difere <1% em outros termos.",
                                "Controle mitiga drift induzido por solar.",
                                "Documentação inclui derivações e código comentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação de τ_solar (erro <5% vs analítico).",
                                "Correta integração nas EDOs (verificação simbólica).",
                                "Implementação numérica estável e eficiente.",
                                "Análise quantitativa de impacto (plots com métricas).",
                                "Tratamento de edge cases (eclipse, singularidades).",
                                "Clareza e reprodutibilidade do código."
                              ],
                              "crossCurricularConnections": [
                                "Física: Radiação e momentum fotônico.",
                                "Matemática: Equações diferenciais não lineares, quaternions.",
                                "Programação: Simulação numérica, ODE solvers.",
                                "Engenharia: Modelagem multiphysics, controle de sistemas.",
                                "Astronomia: Ephimerides solares e orbitais."
                              ],
                              "realWorldApplication": "Em missões como CubeSats (ex: MarCO da NASA), τ_solar causa drift de atitude não mitigado, exigindo rodas de reação; modelo preciso otimiza tamanho de atuadores e vida útil da missão."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Simular evolução da atitude sob pressão solar",
                            "description": "Executar simulações numéricas (ex.: Runge-Kutta) para analisar desvios de atitude causados isoladamente pelo torque solar em órbita LEO, plotando ângulos de Euler ou quaternions ao longo do tempo e avaliando estabilidade sem controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros da órbita LEO e geometria do satélite",
                                  "subSteps": [
                                    "Especificar parâmetros orbitais: altitude (ex.: 500 km), inclinação, RAAN, anomalia verdadeira inicial.",
                                    "Definir propriedades do satélite: massa, momento de inércia (matriz 3x3), dimensões e superfícies expostas (painéis solares).",
                                    "Calcular vetor posição e velocidade usando modelo Kepleriano ou SGP4.",
                                    "Determinar vetor solar unitário em função do tempo orbital.",
                                    "Inicializar condições iniciais de atitude: quaternions ou ângulos de Euler zero."
                                  ],
                                  "verification": "Verificar se parâmetros orbitais reproduzem uma órbita LEO estável e geometria gera torque não-zero em eclipse.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python, NumPy, bibliotecas orbitais como poliastro ou Skyfield",
                                  "tips": "Use unidades consistentes (SI) e valide posição orbital com ferramentas online como Heavens-Above.",
                                  "learningObjective": "Compreender configuração inicial para simulações realistas de atitude em LEO.",
                                  "commonMistakes": "Ignorar variação do vetor solar ou usar momentos de inércia isotrópicos para satélites assimétricos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o torque de pressão solar",
                                  "subSteps": [
                                    "Implementar fórmula do torque: τ = (P * A * cosθ * r) onde P é pressão solar, A área projetada, θ ângulo incidência, r vetor centro de pressão.",
                                    "Calcular área projetada dinamicamente: A_proj = A * |n · s| com n normal à superfície, s vetor solar.",
                                    "Somar contribuições de múltiplas superfícies (corpo principal + painéis solares).",
                                    "Expressar torque no frame do satélite usando matriz de rotação de quaternions.",
                                    "Testar modelo em condições estacionárias (eclipse e pleno sol)."
                                  ],
                                  "verification": "Torque deve ser zero em eclipse e máximo (~10^-6 Nm para CubeSat) em pleno sol perpendicular.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python, NumPy, SciPy para vetores e matrizes",
                                  "tips": "Visualize vetores torque e solar em 3D para depuração intuitiva.",
                                  "learningObjective": "Dominar modelagem física precisa do torque solar como perturbação não-gravitacional.",
                                  "commonMistakes": "Confundir frame inercial com body-frame ou negligenciar sombra da Terra."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar equações de dinâmica de atitude e integrador Runge-Kutta",
                                  "subSteps": [
                                    "Escrever EDOs de atitude: d q/dt = (1/2) Ω q (quaternions) e d ω/dt = I^{-1} (τ - ω × I ω).",
                                    "Implementar Runge-Kutta de ordem 4 (RK4) para integração temporal com passo dt ~ 10s.",
                                    "Incluir propagação orbital acoplada para atualizar posição/solar.",
                                    "Normalizar quaternions a cada passo para evitar deriva numérica.",
                                    "Configurar simulação para múltiplas órbitas (ex.: 10 períodos orbitais)."
                                  ],
                                  "verification": "Energia cinética e norma quaternion conservadas dentro de 1e-10; teste com torque zero deve manter atitude constante.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Python, SciPy (odeint ou solve_ivp), NumPy",
                                  "tips": "Use RK45 adaptativo se disponível para eficiência; monitore estabilidade numérica.",
                                  "learningObjective": "Aplicar métodos numéricos para resolver EDOs rígidas de dinâmica rotacional.",
                                  "commonMistakes": "Passo de tempo grande causando instabilidade ou esquecimento da cinemática quaternion."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulação, plotar resultados e analisar desvios",
                                  "subSteps": [
                                    "Executar simulação sem controle ativo por 10 órbitas.",
                                    "Converter quaternions para ângulos de Euler (roll, pitch, yaw) usando rotação 3-2-1.",
                                    "Plotar evolução temporal: ângulos vs tempo, torque componentes, sombreamento.",
                                    "Calcular desvios máximos e RMS de atitude.",
                                    "Comparar com analítico aproximado para pequenas perturbações."
                                  ],
                                  "verification": "Plots mostram oscilações seculares com período orbital; desvios ~graus após várias órbitas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Matplotlib, Seaborn para visualizações; Pandas para dados",
                                  "tips": "Use subplots para múltiplas visualizações; anime rotação 3D para insight.",
                                  "learningObjective": "Interpretar resultados numéricos de simulações de atitude.",
                                  "commonMistakes": "Singularidades em Euler (gimbal lock) ou plots sem legendas/unidades."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar estabilidade e sensibilidade",
                                  "subSteps": [
                                    "Identificar regimes instáveis: crescimento exponencial ou drift secular.",
                                    "Variar parâmetros (área, inércia) e re-simular para estudo de sensibilidade.",
                                    "Calcular tempos de divergência (quando ângulo > 10°).",
                                    "Discutir implicações para ADCS passivo.",
                                    "Documentar relatório com plots e conclusões."
                                  ],
                                  "verification": "Relatório mostra instabilidade sem controle e quantifica impacto solar vs outras perturbações.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Jupyter Notebook para relatório interativo",
                                  "tips": "Use loops para varredura paramétrica; salve simulações para reprodutibilidade.",
                                  "learningObjective": "Avaliar estabilidade dinâmica e implicações de engenharia.",
                                  "commonMistakes": "Atribuir instabilidade a erros numéricos em vez de física real."
                                }
                              ],
                              "practicalExample": "Simule um CubeSat 3U em órbita LEO a 500 km com painéis solares assimétricos: inicialize atitude nula, propague por 5 dias sem rodas de reação; observe drift de roll até 15° devido a torque solar diferencial, plotando quaternions e torque diário.",
                              "finalVerifications": [
                                "Simulação roda sem erros numéricos por >10 órbitas.",
                                "Plots mostram desvios crescentes isolados do torque solar (zero em sombra).",
                                "Desvios RMS em roll/pitch/yaw quantificados (<1°/órbita inicial).",
                                "Quaternions normalizados e conservados.",
                                "Comparação com literatura: torque ~1e-6 Nm para CubeSat.",
                                "Código modular e comentado para reutilização."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo torque (erro <5% vs analítico).",
                                "Estabilidade numérica da integração RK4 (conservação <1e-8).",
                                "Qualidade dos plots: legíveis, multi-view, anotados.",
                                "Análise quantitativa de desvios e estabilidade.",
                                "Documentação completa com unidades e premissas.",
                                "Eficiência computacional (<1 min por simulação)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução numérica de EDOs não-lineares (RK4).",
                                "Física: Dinâmica rotacional e perturbações orbitais.",
                                "Programação: Vetorização NumPy e visualização Matplotlib.",
                                "Engenharia: Análise de sistemas espaciais (ADCS).",
                                "Computação Científica: Simulação multi-física acoplada."
                              ],
                              "realWorldApplication": "Em missões CubeSat como MarCO ou Lightsail, simulações isolam torque solar para dimensionar rodas de reação ou velas solares, prevendo vida útil sem controle ativo e otimizando geometria para minimizar drift de atitude em LEO."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Simulação de Torque Magnético",
                        "description": "Modelagem e simulação do torque magnético resultante da interação do dipolo magnético do satélite com o campo geomagnético terrestre, impactando a dinâmica de atitude, baseado em Wertz (1978) e Sidi (2006).",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Modelar o campo magnético terrestre",
                            "description": "Implementar o modelo dipolo inclinado do campo magnético da Terra, B(r) = (μ_0 / 4π) · (3(m · u)r - m) / r^3, onde m é o momento magnético terrestre, para posições orbitais específicas, calculando o vetor B local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Modelo Dipolo Magnético Terrestre",
                                  "subSteps": [
                                    "Estude a teoria do campo magnético dipolo, incluindo a aproximação para grandes distâncias da Terra.",
                                    "Analise a fórmula B(r) = (μ₀ / 4π) · (3(m · u)r - m) / r³, identificando cada termo: μ₀, m (momento magnético), u (vetor unitário de posição), r (vetor posição).",
                                    "Revise o momento magnético terrestre: magnitude ≈ 7.94 × 10²² A m², direção inclinada ≈ 11° do eixo de rotação.",
                                    "Entenda as coordenadas: geocentricas inertes (ECI) para posições orbitais.",
                                    "Discuta limitações do modelo (válido para r > 2 r_Terra)."
                                  ],
                                  "verification": "Resuma em um parágrafo os componentes da fórmula e justifique sua validade para órbitas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação IGRF ou World Magnetic Model",
                                    "Livro 'Orbital Mechanics for Engineering Students'",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use diagramas vetoriais para visualizar m, r e B.",
                                  "learningObjective": "Explicar matematicamente o modelo dipolo inclinado e suas premissas.",
                                  "commonMistakes": [
                                    "Confundir coordenadas geográficas com ECI",
                                    "Ignorar a inclinação do dipolo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Parâmetros e Configurar Posições Orbitais",
                                  "subSteps": [
                                    "Defina constantes: μ₀ = 4π × 10^{-7} H/m, m = [0, 0, 7.94e22] A m² ajustado para inclinação.",
                                    "Implemente rotação para inclinação: matriz de rotação em torno do eixo x por 11°.",
                                    "Gere posições orbitais exemplo: LEO (r = 6878 km, inclinação 51.6°), GEO (r = 42164 km).",
                                    "Converta para vetor r em ECI: use elementos orbitais (a, e, i, Ω, ω, ν).",
                                    "Calcule u = r / |r| manualmente para verificação."
                                  ],
                                  "verification": "Liste parâmetros em uma tabela e calcule |r| e u para duas órbitas, comparando com valores esperados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "TLE de satélites reais (Celestrak)",
                                    "Referência: NASA GSFC coefficients"
                                  ],
                                  "tips": "Use funções vetorizadas no NumPy para eficiência.",
                                  "learningObjective": "Preparar dados precisos para computação do campo magnético em órbitas reais.",
                                  "commonMistakes": [
                                    "Erros de unidade (km vs m)",
                                    "Esquecer normalização de u"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Função de Cálculo do Vetor B",
                                  "subSteps": [
                                    "Escreva função def magnetic_field_dipole(r, m): retorne B.",
                                    "Calcule produto escalar m · u.",
                                    "Compute 3(m · u)r - m.",
                                    "Divida por r³ e multiplique por μ₀ / 4π.",
                                    "Teste com r alinhado a m: B deve ser paralelo e |B| ≈ (μ₀ / 4π) * 2|m| / r³."
                                  ],
                                  "verification": "Execute para r equatorial (|B| = (μ₀ / 4π) * |m| / r³) e valide magnitude ≈ 0.3 μT na superfície.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/Jupyter",
                                    "Biblioteca NumPy para vetores",
                                    "Valores de referência do NOAA NGDC"
                                  ],
                                  "tips": "Vectorize a função para múltiplas posições.",
                                  "learningObjective": "Codificar corretamente a fórmula vetorial do campo dipolo.",
                                  "commonMistakes": [
                                    "Erro no sinal do termo 3(m·u)r - m",
                                    "Dividir por |r|^3 em vez de r³ vetorial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, Visualizar e Integrar em Simulação de Torque",
                                  "subSteps": [
                                    "Compare B calculado com modelo IGRF para 5 posições orbitais.",
                                    "Plote |B| vs altitude e componentes Bx, By, Bz em órbita.",
                                    "Calcule torque magnético τ = m_sat × B, com m_sat exemplo.",
                                    "Simule variação ao longo de uma órbita (100 pontos).",
                                    "Analise erros: RMS < 10% para r > 3000 km."
                                  ],
                                  "verification": "Gere gráfico de |B| vs tempo orbital e tabela de comparação com dados reais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matplotlib/Plotly para visualização",
                                    "Modelo IGRF via pyIGRF",
                                    "Dados de satélite GOES ou ISS"
                                  ],
                                  "tips": "Use animações para órbita para insight visual.",
                                  "learningObjective": "Aplicar o modelo em contexto de simulação de atitude espacial.",
                                  "commonMistakes": [
                                    "Não converter unidades consistentemente",
                                    "Ignorar rotação terrestre para longo prazo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um satélite CubeSat em órbita LEO (h=400km, i=51.6°), calcule B em posição (x=5000km, y=3000km, z=2000km) ECI. Resultado esperado: |B| ≈ 20-40 μT, usado para controlar rotores magnéticos de desaturação de rodas de reação.",
                              "finalVerifications": [
                                "Código computa B corretamente para 10 posições orbitais variadas.",
                                "|B| coincide com IGRF dentro de 15% para r > 1.5 r_Terra.",
                                "Torque τ = m × B é perpendicular a m e B.",
                                "Visualizações mostram variação dipolo: mais forte nos polos.",
                                "Função é eficiente (<1ms por chamada).",
                                "Testes unitários passam para casos polares/equatoriais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática da implementação (100% fidelidade à fórmula).",
                                "Correção de unidades e coordenadas (m, T para B).",
                                "Validação quantitativa com modelos padrão (erro <10%).",
                                "Clareza do código: documentado e modular.",
                                "Capacidade de extensão para torque/simulação.",
                                "Compreensão conceitual via explicação escrita."
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletromagnetismo (lei de Biot-Savart para dipolos).",
                                "Matemática: Álgebra vetorial e análise numérica.",
                                "Programação: Computação científica com NumPy/SciPy.",
                                "Engenharia: Dinâmica de atitude e controle de satélites.",
                                "Geofísica: Modelos reais como IGRF/CHAOS."
                              ],
                              "realWorldApplication": "Em missões espaciais como CubeSats (ex: MarCO), o modelo dipolo é usado em sistemas ADCS para estimar campo B via magnetômetros, gerando torque magnético para controle de atitude e remoção de momento angular, reduzindo consumo de propelente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Calcular torque magnético do satélite",
                            "description": "Computar o torque τ_mag = m_sc × B, onde m_sc é o dipolo magnético residual do satélite (devido a correntes, magnetização etc.), considerando variações com atitude e posição orbital.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Dipolos Magnéticos e Torque",
                                  "subSteps": [
                                    "Estude a definição de dipolo magnético e sua representação vetorial m.",
                                    "Revise a lei do torque magnético τ = m × B para dipolos em campos magnéticos.",
                                    "Aprenda sobre o campo magnético terrestre modelado como dipolo (ex: modelo IGRF).",
                                    "Identifique componentes do dipolo residual m_sc em satélites (correntes, magnetização).",
                                    "Pratique cálculos escalares de torque em casos simplificados (m paralelo a B)."
                                  ],
                                  "verification": "Resolva 3 exercícios teóricos de torque magnético e explique verbalmente a orientação do vetor τ.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Eletromagnetismo (Griffiths)",
                                    "Vídeos Khan Academy sobre magnetostática",
                                    "Folha de fórmulas vetoriais"
                                  ],
                                  "tips": "Visualize vetores com desenhos 3D para entender o produto vetorial.",
                                  "learningObjective": "Compreender a física subjacente do torque magnético em satélites.",
                                  "commonMistakes": [
                                    "Confundir torque com força magnética F = q(v × B)",
                                    "Ignorar a natureza vetorial do cálculo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Dipolo Magnético Residual do Satélite (m_sc)",
                                  "subSteps": [
                                    "Colete dados típicos de m_sc para CubeSats (ex: 0.1-1 Am² por eixo).",
                                    "Expresse m_sc em frame do corpo do satélite, considerando rotação com atitude.",
                                    "Incorpore variações devido a correntes induzidas ou histerese magnética.",
                                    "Transforme m_sc para frame inercial usando matriz de rotação de atitude (DCM).",
                                    "Valide modelo com dados de satélites reais (ex: literatura de CubeSats)."
                                  ],
                                  "verification": "Crie um script simples que gera m_sc variando com ângulo de rotação e verifique magnitudes.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Documentação de CubeSats (NASA)",
                                    "Software MATLAB/Python para vetores",
                                    "Planilhas Excel para prototipagem"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades na rotação de atitude.",
                                  "learningObjective": "Modelar precisamente o dipolo m_sc considerando dinâmica do satélite.",
                                  "commonMistakes": [
                                    "Assumir m_sc constante sem variações de atitude",
                                    "Erros de unidades (Am² vs. A/m²)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar o Campo Magnético Orbital B",
                                  "subSteps": [
                                    "Implemente modelo dipolo terrestre centrado: B(r, λ) com posição orbital r e latitude λ.",
                                    "Use modelo IGRF para precisão, obtendo coeficientes via API ou biblioteca.",
                                    "Expresse B em frame orbital (TIRS ou ECEF) e transforme para frame do satélite.",
                                    "Simule variações ao longo da órbita (ex: LEO a 500 km, inclinação 51°).",
                                    "Plote B vs. tempo orbital para uma passagem completa."
                                  ],
                                  "verification": "Gere gráfico de |B| ao longo de uma órbita e compare com dados reais de satélites.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Biblioteca PyIGRF ou MATLAB Aerospace Toolbox",
                                    "Dados orbitais TLE de satélites",
                                    "Ferramenta de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Comece com modelo dipolo simples antes de IGRF para depuração.",
                                  "learningObjective": "Obter B preciso na posição e atitude do satélite.",
                                  "commonMistakes": [
                                    "Usar B constante em vez de dependente de posição",
                                    "Confundir frames de referência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o Torque τ_mag = m_sc × B",
                                  "subSteps": [
                                    "Implemente produto vetorial em código: τ_x = m_y B_z - m_z B_y, etc.",
                                    "Integre com loops de simulação temporal, atualizando atitude e posição.",
                                    "Calcule magnitude e direção de τ_mag, normalizando para análise.",
                                    "Some τ_mag a outros torques em simulação de atitude (ex: rodas de reação).",
                                    "Teste sensibilidade: varie m_sc e B para cenários extremos."
                                  ],
                                  "verification": "Execute simulação de 1 órbita e verifique que τ_mag oscila com período orbital.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python/NumPy para vetores",
                                    "Simulador orbital (Orekit ou GMAT)",
                                    "Código template de produto vetorial"
                                  ],
                                  "tips": "Use funções vetorizadas no NumPy para eficiência em loops.",
                                  "learningObjective": "Computar τ_mag dinamicamente em simulação.",
                                  "commonMistakes": [
                                    "Erro no sinal do produto vetorial",
                                    "Não sincronizar timesteps de atitude e órbita"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Integrar em Simulação Completa",
                                  "subSteps": [
                                    "Compare τ_mag simulado com literatura ou dados de missão (ex: GOCE).",
                                    "Analise impacto em dinâmica de atitude (equações de Euler).",
                                    "Implemente mitigação (ex: magnetotorquers opostos).",
                                    "Execute Monte Carlo com variações em m_sc e órbita.",
                                    "Documente resultados com gráficos de τ vs. tempo."
                                  ],
                                  "verification": "Relatório com simulação mostrando estabilidade de atitude com/sem τ_mag.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Simulador de atitude (ex: 42 toolbox)",
                                    "Dados de missões reais (ESA/NASA)",
                                    "Ferramentas de relatório (Jupyter)"
                                  ],
                                  "tips": "Grave vídeos da simulação 3D para visualização intuitiva.",
                                  "learningObjective": "Integrar cálculo de τ_mag em fluxo de simulação aeroespacial.",
                                  "commonMistakes": [
                                    "Ignorar efeitos não-lineares em atitudes extremas",
                                    "Sobrestimar m_sc sem calibração"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um CubeSat 3U em órbita LEO (500 km, 51° incl.), com m_sc = [0.5, 0.2, -0.3] Am² no frame do corpo e atitude nadir-pointing, calcule τ_mag usando B do modelo IGRF. Simule uma órbita: τ_mag varia de 1e-6 a 5e-6 Nm, exigindo correção por magnetotorquers.",
                              "finalVerifications": [
                                "O aluno deriva corretamente τ = m × B e explica dependências.",
                                "Implementa código que reproduz variações orbitais de τ_mag.",
                                "Valida resultados contra dados reais com erro <10%.",
                                "Identifica frames corretos para m_sc e B.",
                                "Analisa impacto em controle de atitude.",
                                "Documenta código com comentários e testes unitários."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática do produto vetorial (100% correto).",
                                "Correta modelagem de variações com atitude/órbita.",
                                "Eficiência computacional (timestep <1s para órbita).",
                                "Unidades consistentes (Nm para torque).",
                                "Qualidade de visualizações e relatórios.",
                                "Tratamento de erros e casos edge."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra vetorial e produto cruzado.",
                                "Física: Eletromagnetismo e dinâmica orbital.",
                                "Programação: Simulação numérica em Python/MATLAB.",
                                "Engenharia: Controle de sistemas e modelagem multiphysics.",
                                "Ciência de Dados: Análise de sensibilidade e Monte Carlo."
                              ],
                              "realWorldApplication": "Em missões como Swarm (ESA) ou CubeSats universitários, o cálculo preciso de τ_mag permite projetar sistemas de controle de atitude robustos, evitando instabilidades e otimizando consumo de energia em magnetotorquers para manobras orbitais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Integrar torque magnético na simulação dinâmica",
                            "description": "Adicionar τ_mag às equações de atitude no simulador, simulando cenários com e sem controle (ex.: rodas de reação), analisando precessão e nutação induzidas pelo torque magnético em diferentes inclinações orbitais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o Torque Magnético (τ_mag)",
                                  "subSteps": [
                                    "Estudar o modelo do campo magnético terrestre (ex.: modelo IGRF ou dipolo simples).",
                                    "Derivar a fórmula do torque magnético: τ_mag = m × B, onde m é o momento magnético do satélite e B o campo magnético.",
                                    "Definir parâmetros do satélite: dipolo magnético residual ou magnetorquers.",
                                    "Implementar função para calcular B em função da posição orbital (coordenadas ECEF para orbital).",
                                    "Testar a função com valores conhecidos de B em diferentes altitudes e inclinações."
                                  ],
                                  "verification": "Função τ_mag retorna valores consistentes com literatura para órbitas LEO (ex.: |τ_mag| ~ 10^-6 Nm).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Documentação IGRF",
                                    "Biblioteca Python NumPy/SciPy",
                                    "Código base do simulador de atitude"
                                  ],
                                  "tips": "Use modelo dipolo para simplicidade inicial; valide com dados de satélites reais como GOCE.",
                                  "learningObjective": "Compreender e implementar o cálculo físico do torque magnético em ambiente orbital.",
                                  "commonMistakes": [
                                    "Confundir frames de referência (inercial vs. orbital)",
                                    "Ignorar variação diurna do campo magnético"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Integrar τ_mag nas Equações de Atitude",
                                  "subSteps": [
                                    "Revisar equações de Euler ou quaternions para dinâmica de atitude: Ṅ = f(ω, τ_total).",
                                    "Adicionar τ_mag ao vetor de torques totais: τ_total = τ_control + τ_mag + τ_gravity + ...",
                                    "Modificar o integrador numérico (ex.: RK4) para incluir o novo termo nas derivadas de quaternion/ângulo.",
                                    "Implementar rotação de vetores entre frames (body para orbital) para m e B.",
                                    "Compilar e testar integração sem erros numéricos (verificar estabilidade)."
                                  ],
                                  "verification": "Simulação de 1 órbita sem torque magnético mantém atitude estável; com τ_mag, observa-se deriva esperada.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Código simulador existente",
                                    "Referência: Sidi 'Spacecraft Dynamics and Control'",
                                    "MATLAB/Python ODE solvers"
                                  ],
                                  "tips": "Normalizar quaternions a cada passo para evitar drift numérico.",
                                  "learningObjective": "Integrar perturbações externas nas equações diferenciais de atitude de forma precisa.",
                                  "commonMistakes": [
                                    "Erro na transformação de frames (DCM body-to-orbital)",
                                    "Escala incorreta de τ_mag vs. outros torques"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Simulações de Cenários com e sem Controle",
                                  "subSteps": [
                                    "Configurar cenários: órbitas equatoriais (0°), polares (90°), SSO (98°).",
                                    "Simular sem controle: apenas τ_mag atuando.",
                                    "Adicionar controle simples com rodas de reação (PD controller para ω).",
                                    "Executar simulações para múltiplas órbitas (ex.: 10 órbitas).",
                                    "Registrar dados: ângulos de Euler, quaternions, ω, τ_mag ao longo do tempo."
                                  ],
                                  "verification": "Gráficos mostram torque oscilante com período orbital; controle reduz desvios em >80%.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Ferramentas de plotagem (Matplotlib/Plotly)",
                                    "Parâmetros orbitais reais (TLEs)",
                                    "Modelo de rodas de reação"
                                  ],
                                  "tips": "Use propagador orbital preciso (SGP4) para posição; salve dados em HDF5 para análise.",
                                  "learningObjective": "Configurar e executar simulações comparativas de perturbações com mitigação ativa.",
                                  "commonMistakes": [
                                    "Passo de tempo grande causando instabilidade",
                                    "Inicialização errada de condições de atitude"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Precessão e Nutação Induzidas",
                                  "subSteps": [
                                    "Plotar trajetórias de atitude (roll, pitch, yaw) e decompor em modos (precessão/nutação).",
                                    "Calcular taxas de precessão: dψ/dt ≈ |m × B| / Iω.",
                                    "Comparar cenários: amplitude e frequência de nutação vs. inclinação orbital.",
                                    "Quantificar impacto: desvios RMS com/sem controle.",
                                    "Documentar insights em relatório com gráficos e tabelas."
                                  ],
                                  "verification": "Análise confirma precessão ~0.1°/órbita em LEO equatorial, maior em polares.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ferramentas FFT para análise espectral",
                                    "Literatura: 'Torque-induced precession in satellites'"
                                  ],
                                  "tips": "Use filtros para separar precessão lenta de nutação rápida.",
                                  "learningObjective": "Identificar e quantificar efeitos dinâmicos específicos induzidos por torques magnéticos.",
                                  "commonMistakes": [
                                    "Confundir precessão com nutação",
                                    "Escala errada nos gráficos ocultando efeitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat 3U em órbita LEO a 500km com inclinação 51.6° (ISS-like): sem controle, observe precessão de 0.5°/dia; com rodas de reação, mantenha pointing nadir <1° RMS.",
                              "finalVerifications": [
                                "Código integra τ_mag sem crashes em simulações >24h.",
                                "Torque magnético varia corretamente com posição orbital e inclinação.",
                                "Sem controle: detecção de precessão e nutação em plots de atitude.",
                                "Com controle: redução efetiva dos desvios de atitude.",
                                "Resultados validados contra referências analíticas ou simulações conhecidas.",
                                "Análise quantitativa com métricas RMS <5% de erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão física da implementação de τ_mag (fórmula e frames corretos).",
                                "Estabilidade numérica da simulação integrada (>10 órbitas sem drift).",
                                "Qualidade da análise: identificação clara de precessão/nutação por inclinação.",
                                "Comparação com/sem controle: gráficos legíveis e conclusões fundamentadas.",
                                "Documentação: código comentado e relatório com evidências.",
                                "Eficiência: tempo de simulação <1min por órbita em hardware padrão."
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletromagnetismo (momento dipolo × campo B).",
                                "Matemática: Equações diferenciais não-lineares e análise modal (FFT).",
                                "Programação: Integração numérica (RK4/ODEINT) e visualização de dados.",
                                "Engenharia: Controle de sistemas (PD para rodas de reação).",
                                "Ciência de Dados: Análise espectral de séries temporais orbitais."
                              ],
                              "realWorldApplication": "Desenvolvimento de controladores de atitude para satélites CubeSat como os da missão QB50, onde torques magnéticos causam desvios que magnetorquers ou rodas contrabalançam para manter comunicação e sensores apontados."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.4",
                            "name": "Analisar efeitos combinados de perturbações",
                            "description": "Simular dinâmica de atitude sob torques solar e magnético simultâneos, comparando com casos isolados, avaliando requisitos de controle para estabilização, utilizando métricas como taxa de deriva angular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar torques solar e magnético individualmente",
                                  "subSteps": [
                                    "Derive as equações matemáticas para o torque solar baseado na pressão de radiação e área projetada do satélite.",
                                    "Formule o torque magnético usando o momento dipolar do satélite e o campo magnético terrestre (modelo IGRF).",
                                    "Implemente os modelos em um resolvedor numérico, definindo parâmetros iniciais como órbita, atitude e propriedades do veículo.",
                                    "Valide os modelos isolados com literatura ou dados de referência.",
                                    "Teste sensibilidade a variações de parâmetros orbitais e geométricos."
                                  ],
                                  "verification": "Equações implementadas produzem resultados consistentes com simulações de referência isoladas (erro <5%).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "MATLAB/Simulink ou Python (NumPy, SciPy, Orekit/SGP4 para propagação orbital), documentação de modelos de torque (NASA/ESA papers).",
                                  "tips": "Use unidades consistentes (Nm para torque, graus/s para taxas angulares) desde o início para evitar erros de escala.",
                                  "learningObjective": "Compreender e implementar modelos físicos precisos de perturbações torques isoladas.",
                                  "commonMistakes": "Ignorar variações do campo magnético ao longo da órbita ou assumir torque solar constante."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular dinâmica de atitude com torques isolados",
                                  "subSteps": [
                                    "Configure condições iniciais: atitude quiescente, órbita LEO circular.",
                                    "Execute simulação para torque solar isolado por 1 órbita completa, registrando quaternions, taxas angulares e torques.",
                                    "Repita para torque magnético isolado, plotando curvas de deriva angular.",
                                    "Calcule métricas: taxa média de deriva angular (deg/s), desvio máximo de atitude.",
                                    "Gere gráficos comparativos de evolução temporal."
                                  ],
                                  "verification": "Gráficos mostram deriva angular estável e quantificável para cada caso isolado.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Software de simulação (MATLAB ode45 ou Python solve_ivp), planilhas para métricas.",
                                  "tips": "Escolha passo de integração pequeno (1-10s) para capturar dinâmicas rápidas.",
                                  "learningObjective": "Executar simulações numéricas de dinâmica de atitude sob perturbações unitárias.",
                                  "commonMistakes": "Passo de tempo grande levando a instabilidade numérica ou perda de precisão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar e simular torques combinados",
                                  "subSteps": [
                                    "Some os vetores de torque solar e magnético no modelo dinâmico (equações de Euler rígido).",
                                    "Execute simulação combinada com mesmas condições iniciais por múltiplas órbitas.",
                                    "Registre todas as variáveis: atitudes, taxas, torques individuais e totais.",
                                    "Compare visual e numericamente com casos isolados (ex: soma vetorial vs. efeito não-linear).",
                                    "Analise interações, como alinhamentos que amplificam ou cancelam torques."
                                  ],
                                  "verification": "Simulação combinada roda sem erros e produz dados comparáveis aos isolados.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Mesmo software de simulação, ferramentas de plotting (Matplotlib/Plotly).",
                                  "tips": "Normalize torques para visualizar contribuições relativas; rode Monte Carlo para variabilidade orbital.",
                                  "learningObjective": "Implementar superposição de múltiplas perturbações em simulações acopladas.",
                                  "commonMistakes": "Não linearizar corretamente as somas vetoriais ou ignorar acoplamentos cinemáticos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar efeitos e avaliar requisitos de controle",
                                  "subSteps": [
                                    "Calcule métricas combinadas: taxa de deriva efetiva, tempo para perda de pointing (ex: 5° erro).",
                                    "Compare com isolados: quantifique sinergias (ex: deriva 2x maior).",
                                    "Desenhe controlador PD simples para estabilização e simule com ganho mínimo necessário.",
                                    "Otimize ganhos baseados em métricas (overshoot <10%, settling time <1 órbita).",
                                    "Documente requisitos: torque de controle máximo em Nm."
                                  ],
                                  "verification": "Relatório com tabelas/gráficos mostra requisitos de controle quantificados.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Ferramentas de controle (Control Toolbox MATLAB/Python), templates de relatório.",
                                  "tips": "Use métricas como RMS de erro de atitude para robustez.",
                                  "learningObjective": "Avaliar impactos combinados e derivar especificações de sistemas de controle.",
                                  "commonMistakes": "Subestimar efeitos não-lineares ou escolher métricas inadequadas para pointing."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e sintetizar análise",
                                  "subSteps": [
                                    "Rode simulações de sensibilidade (variações de inclinação orbital, BAM magnético).",
                                    "Valide contra dados reais (ex: CubeSat telemetry) ou simulações avançadas.",
                                    "Sintetize achados em relatório: tabelas de comparação, recomendações de design.",
                                    "Identifique cenários worst-case para requisitos de controle.",
                                    "Arquive código e resultados para reprodutibilidade."
                                  ],
                                  "verification": "Análise sensível confirma robustez; relatório cobre todos os aspectos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Dados de referência (NASA GOCE/CubeSat), Git para versionamento.",
                                  "tips": "Automatize plots com scripts para eficiência em iterações.",
                                  "learningObjective": "Validar simulações e comunicar insights acionáveis.",
                                  "commonMistakes": "Falta de validação externa ou relatórios incompletos."
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO (400km, 51° inclinação) com painéis solares de 0.1m² e dipolo magnético de 0.01 Am². Torque solar ~1e-6 Nm, magnético ~5e-7 Nm. Isolados: deriva ~0.01°/orbita cada. Combinado: 0.025°/orbita devido a alinhamentos, requerendo rodas de reação de 1mNs capacidade.",
                              "finalVerifications": [
                                "Gráficos comparam deriva angular isolada vs. combinada com quantificação numérica.",
                                "Métricas de controle (ganho PD mínimo) derivadas e simuladas com estabilização bem-sucedida.",
                                "Análise de sensibilidade cobre ±20% variações em parâmetros.",
                                "Relatório documenta não-linearidades observadas (ex: amplificação > soma).",
                                "Código reproduz resultados em <5% desvio.",
                                "Requisitos de torque de controle especificados em Nm para worst-case."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem de torques (erro <10% vs. referências teóricas).",
                                "Qualidade das simulações numéricas (estabilidade, convergência demonstrada).",
                                "Profundidade da comparação qualitativa/quantitativa entre casos.",
                                "Correção na derivação de requisitos de controle (simulações com/ sem controlador).",
                                "Clareza e completude do relatório com visualizações e interpretações.",
                                "Identificação de interações não-lineares e recomendações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletromagnetismo (campo B terrestre) e mecânica orbital.",
                                "Matemática: Equações diferenciais não-lineares e métodos numéricos (Runge-Kutta).",
                                "Engenharia de Controle: Projeto de loops PD para sistemas multi-DOF.",
                                "Computação: Programação científica e visualização de dados dinâmicos.",
                                "Engenharia Aeroespacial: Design de ADCS para missões reais."
                              ],
                              "realWorldApplication": "Em missões CubeSat como o QB50 ou estações espaciais (ISS), análise de torques solar-magnéticos combinados otimiza rodas de reação e magnetotorquers, prevenindo perda de pointing para comunicações e sensores, reduzindo custos de combustível e estendendo vida útil da missão."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Simulação de Atuadores para Controle de Atitude",
                    "description": "Modelagem de sistemas propulsivos, rodas de reação e rodas de reação com gimbal para geração de torque.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Sistemas Propulsivos para Controle de Atitude",
                        "description": "Modelagem matemática e simulação de sistemas propulsivos, como propulsores químicos ou elétricos, utilizados para gerar torque de controle de atitude em veículos espaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Modelar o torque gerado por propulsores",
                            "description": "Desenvolver equações cinemáticas e dinâmicas para calcular o torque resultante de empuxo off-center em propulsores, considerando eficiência, impulso específico e limitações de saturação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Torque e Propulsão Espacial",
                                  "subSteps": [
                                    "Defina torque como τ = r × F, onde r é o vetor de posição do ponto de aplicação da força F.",
                                    "Explique empuxo de propulsores como F = ṁ * v_e, com ṁ taxa de fluxo de massa e v_e velocidade de exaustão.",
                                    "Discuta impulso específico I_sp = v_e / g_0 e sua relação com eficiência η.",
                                    "Identifique limitações de saturação: thrust máximo F_max e tempo de queima limitado.",
                                    "Revise cinemática de atitude: ângulos de Euler ou quaternions para rotação."
                                  ],
                                  "verification": "Resuma os conceitos em um diagrama vetorial e liste equações chave em um documento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Spacecraft Dynamics and Control' de Sidi",
                                    "Notebook para anotações",
                                    "Software de desenho vetorial como Draw.io"
                                  ],
                                  "tips": "Use convenções de coordenadas do corpo (body frame) para consistência em veículos espaciais.",
                                  "learningObjective": "Compreender os princípios físicos básicos de torque e propulsão off-center.",
                                  "commonMistakes": [
                                    "Confundir torque com força linear",
                                    "Ignorar direção do vetor r",
                                    "Esquecer g_0 no cálculo de I_sp"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Equação de Torque para Propulsor Único Off-Center",
                                  "subSteps": [
                                    "Posicione o propulsor em vetor r relativo ao centro de massa (CM).",
                                    "Calcule força F = η * ṁ * v_e * u, onde u é vetor unitário de direção.",
                                    "Derive τ = r × F, expandindo em componentes cartesianos: τ_x = r_y F_z - r_z F_y, etc.",
                                    "Inclua eficiência η e I_sp: v_e = I_sp * g_0.",
                                    "Expresse torque em função de duty cycle ou sinal de controle u ∈ [0,1] para saturação."
                                  ],
                                  "verification": "Teste a equação com valores numéricos simples e verifique magnitude e direção.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python ou MATLAB para cálculos vetoriais",
                                    "Folha de cálculo para validação numérica"
                                  ],
                                  "tips": "Sempre normalize vetores para evitar erros de magnitude; use cross product built-in functions.",
                                  "learningObjective": "Derivar matematicamente o torque gerado por um propulsor deslocado.",
                                  "commonMistakes": [
                                    "Usar produto escalar em vez de vetorial",
                                    "Negligenciar o sinal do torque baseado na direção de r",
                                    "Unidades inconsistentes (N vs mN)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar Torque Resultante de Múltiplos Propulsores",
                                  "subSteps": [
                                    "Liste posições r_i e direções u_i para N propulsores (ex: 8-12 em configuração típica).",
                                    "Calcule τ_total = Σ (r_i × F_i), com F_i = η * ṁ_i * I_sp_i * g_0 * u_i * sat(u_i).",
                                    "Implemente função de saturação: F_i = min(F_max_i, F_nominal_i).",
                                    "Analise acoplamento: torque em eixos indesejados devido a desalinhamentos.",
                                    "Linearize para pequenos ângulos: τ ≈ B * u, onde B é matriz de distribuição de torque."
                                  ],
                                  "verification": "Gere matriz B para uma configuração padrão e verifique independência de eixos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python com NumPy para matrizes",
                                    "Diagrama CAD de CubeSat com propulsores"
                                  ],
                                  "tips": "Configure propulsores em pares opostos para controle desacoplado.",
                                  "learningObjective": "Combinar torques de múltiplos atuadores em um modelo dinâmico coeso.",
                                  "commonMistakes": [
                                    "Soma vetorial incorreta",
                                    "Ignorar assimetrias em r_i",
                                    "Sobrestimar thrust sem saturação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar Eficiência, I_sp e Validar o Modelo Completo",
                                  "subSteps": [
                                    "Ajuste modelo com η(pressão, temperatura) e I_sp variável por tipo de propulsor (cold gas vs químico).",
                                    "Inclua dinâmica: I * ω_dot = τ_total - τ_distúrbios, onde I é tensor de inércia.",
                                    "Simule resposta: integre equações com solver numérico (ex: ode45 em MATLAB).",
                                    "Valide contra dados reais: compare com thrust curves de propulsores comerciais.",
                                    "Otimize: minimize consumo de propelente para torque desejado."
                                  ],
                                  "verification": "Execute simulação e plote τ vs tempo; confira se respeita limites físicos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python SciPy para integração",
                                    "Dados de datasheet de propulsores (ex: CubeSat cold gas thrusters)"
                                  ],
                                  "tips": "Use unidades SI consistentes; teste com cenários de falha (um propulsor off).",
                                  "learningObjective": "Integrar fatores reais como eficiência e saturação em um modelo acionável.",
                                  "commonMistakes": [
                                    "Assumir η=1 constante",
                                    "Erro na integração numérica (passo de tempo grande)",
                                    "Negligenciar tensor de inércia não-diagonal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat 3U com 8 propulsores cold gas posicionados 0.1m off-center nos cantos, ative dois propulsores opostos para gerar 0.001 Nm de torque em roll. Calcule τ_total considerando I_sp=70s, η=0.85 e saturação em 1mN, simulando rotação de 5° em 10s.",
                              "finalVerifications": [
                                "Equações derivadas corretamente para τ = r × F com componentes vetoriais.",
                                "Modelo inclui η, I_sp e função de saturação para todos propulsores.",
                                "Simulação numérica converge sem instabilidades.",
                                "Torque resultante é ortogonal ao desejado com erro <5%.",
                                "Consumo de propelente calculado realisticamente.",
                                "Matriz de distribuição B tem rank 3 para controle completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das derivações (100% correção vetorial).",
                                "Incorporação completa de eficiência, I_sp e saturação.",
                                "Clareza e documentação do modelo (equações + código comentado).",
                                "Validação numérica com erros <1% vs casos analíticos.",
                                "Análise de robustez a variações (ex: desalinhamento 1°).",
                                "Eficiência computacional da simulação (tempo <1min para 100s)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra vetorial e cálculo matricial para cross products e linearização.",
                                "Física: Dinâmica newtoniana e conservação de momento angular.",
                                "Engenharia de Controle: Modelagem para law de controle (PD ou LQR).",
                                "Programação: Implementação numérica com NumPy/SciPy.",
                                "Química: Propriedades de propelentes e variação de I_sp com temperatura."
                              ],
                              "realWorldApplication": "Esse modelo é essencial para sistemas de controle de atitude em CubeSats como os da missão MarCO (NASA), permitindo manobras precisas de apontamento de antenas ou desorbitagem, otimizando consumo de propelente em missões de baixo custo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Implementar simulação numérica de propulsores",
                            "description": "Criar um modelo de simulação em software como MATLAB/Simulink para integrar a dinâmica de atitude com comandos de acionamento de propulsores, incluindo delays e consumo de propelente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a Dinâmica de Atitude do Veículo Espacial",
                                  "subSteps": [
                                    "Definir as equações de Euler para rotação rígida: derivadas angulares em quaternions ou ângulos de Euler.",
                                    "Implementar a matriz de inércia do spacecraft em MATLAB.",
                                    "Criar função para calcular torque total aplicado ao veículo.",
                                    "Integrar numericamente as equações usando ode45 ou similar.",
                                    "Testar modelo sem propulsores para verificar estabilidade."
                                  ],
                                  "verification": "Executar simulação livre e confirmar que ângulos de atitude permanecem constantes (erro < 1e-6 rad/s).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB/Simulink instalado",
                                    "Documentação de dinâmica orbital (ex: Sidi 'Spacecraft Dynamics')",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades em ângulos de Euler; normalize quaternions a cada passo.",
                                  "learningObjective": "Compreender e implementar equações cinemáticas e dinâmicas de atitude em código.",
                                  "commonMistakes": [
                                    "Esquecer normalização de quaternions",
                                    "Invertar sinal do torque",
                                    "Usar unidades inconsistentes (graus vs radianos)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar os Propulsores Individuais",
                                  "subSteps": [
                                    "Definir parâmetros: impulso específico (Isp), massa de propelente inicial, thrust nominal por propulsor.",
                                    "Implementar delay de acionamento (ex: 0.1s) usando delay blocks ou funções timedelay.",
                                    "Criar modelo de consumo: dm/dt = -thrust / (Isp * g0), com g0=9.81 m/s².",
                                    "Calcular torque/força vetorial por posição dos propulsores no corpo.",
                                    "Adicionar ruído ou falhas simuladas para realismo."
                                  ],
                                  "verification": "Simular acionamento único e verificar: delay correto, massa reduzida proporcionalmente, torque no vetor esperado.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "MATLAB com Aerospace Toolbox",
                                    "Dados de propulsores reais (ex: cold gas thrusters specs)",
                                    "Planilhas para calcular posições CPS (Cold Plasma System)"
                                  ],
                                  "tips": "Vetorize cálculos para múltiplos propulsores usando arrays; use struct para organizar parâmetros por ID de propulsor.",
                                  "learningObjective": "Modelar física de propulsores com delays e consumo limitado de forma numérica precisa.",
                                  "commonMistakes": [
                                    "Ignorar direção vetorial do thrust",
                                    "Não limitar massa de propelente a zero",
                                    "Delay implementado como soma simples em vez de fila"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Comandos de Acionamento com Dinâmica",
                                  "subSteps": [
                                    "Definir interface: comandos booleanos ou PWM por propulsor de um controlador de atitude.",
                                    "Implementar lógica de pairing: quais propulsores ativar para torque desejado (ex: +roll usa thrusters 1 e 3).",
                                    "Conectar saída do controlador à entrada dos propulsores com delays.",
                                    "Atualizar dinâmica: somar torques de todos propulsores ativos.",
                                    "Adicionar saturação de comandos baseada em propelente restante."
                                  ],
                                  "verification": "Simular comando de roll: confirmar torque aplicado após delay, atitude responde corretamente.",
                                  "estimatedTime": "3.5 horas",
                                  "materials": [
                                    "Simulink para blocos lógicos",
                                    "Exemplos de controladores PD simples",
                                    "Debugger MATLAB"
                                  ],
                                  "tips": "Use Stateflow para lógica complexa de pairing; teste com comandos unitários primeiro.",
                                  "learningObjective": "Integrar atuadores com loop de controle fechado, considerando limitações reais.",
                                  "commonMistakes": [
                                    "Sobrecarga de pairing causando torque oposto",
                                    "Comandos não saturados por massa restante",
                                    "Integração assíncrona causando instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar e Executar a Simulação Completa",
                                  "subSteps": [
                                    "Configurar solver: variável step, ode45, tolerâncias 1e-9 para precisão.",
                                    "Definir cenário inicial: atitude errada, perfil de comandos de um controlador.",
                                    "Executar simulação longa (ex: 1000s) monitorando consumo e atitude.",
                                    "Plotar resultados: trajetórias de atitude, uso de propelente por thruster.",
                                    "Otimizar performance: pré-alocar arrays, vetorizar."
                                  ],
                                  "verification": "Simulação completa sem crashes; atitude converge ao setpoint em <100s; massa final >0.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Simulink model viewer",
                                    "MATLAB plotting functions (plot, subplot)",
                                    "Scripts de análise"
                                  ],
                                  "tips": "Salve modelo como .slx; use sim('model') em script para batch runs.",
                                  "learningObjective": "Executar simulações numéricas robustas e analisar saídas.",
                                  "commonMistakes": [
                                    "Solver rígido desnecessário causando lentidão",
                                    "Escalas de plot erradas ocultando erros",
                                    "Tempo de simulação curto para ver consumo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar Resultados da Simulação",
                                  "subSteps": [
                                    "Comparar com modelo analítico simples (ex: double integrator).",
                                    "Testar casos edge: propelente zero, delays altos, falhas.",
                                    "Calcular métricas: tempo de settling, consumo total, overshoot.",
                                    "Documentar discrepâncias e ajustes feitos.",
                                    "Exportar dados para relatório."
                                  ],
                                  "verification": "Métricas dentro de 5% de benchmarks teóricos; relatório com plots e conclusões.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Benchmark papers on attitude control",
                                    "Excel/MATLAB para métricas",
                                    "LaTeX para relatório"
                                  ],
                                  "tips": "Use assert() para testes automatizados; compare com simulações open-source.",
                                  "learningObjective": "Validar simulações numericamente e identificar fontes de erro.",
                                  "commonMistakes": [
                                    "Ignorar acumulação numérica em longas sims",
                                    "Não testar falhas",
                                    "Conclusões sem métricas quantitativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat 3U com 8 cold gas thrusters em órbita LEO: inicie com erro de 10° em roll devido a distúrbios gravitacionais; aplique comandos PD para corrigir, monitorando delays de 50ms e consumo total <10% da massa inicial em 600s de simulação.",
                              "finalVerifications": [
                                "Simulação executa sem erros numéricos ou crashes por 1000s.",
                                "Delays de acionamento são respeitados (lag visível em plots de thrust).",
                                "Consumo de propelente bate com integral de thrust/Isp (erro <1%).",
                                "Atitude converge ao setpoint com overshoot <5° e settling <200s.",
                                "Torque total varia corretamente com pairing de thrusters.",
                                "Massa restante >=0 e satura comandos quando esgotado."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo dinâmico: erro de integração <1e-6 rad.",
                                "Fidelidade do modelo de propulsores: thrust/delay/consumo realistas.",
                                "Integração robusta: lida com saturações e edge cases.",
                                "Eficiência computacional: sim de 1000s em <5min.",
                                "Análise completa: plots, métricas e validação incluídos.",
                                "Código modular e comentado para reutilização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Métodos de Runge-Kutta e estabilidade de solvers.",
                                "Programação: Estruturas orientadas a objetos em MATLAB para modelos.",
                                "Física: Conservação de momento angular e termodinâmica de propulsores.",
                                "Engenharia de Software: Versionamento de modelos Simulink com Git.",
                                "Controle Automático: Integração com loops PD/PID."
                              ],
                              "realWorldApplication": "Em missões como o CubeSat da NASA MarCO (2018), simulações semelhantes foram usadas para otimizar uso de propulsores durante manobras de atitude em voo profundo, prevendo consumo e evitando esgotamento prematuro em trajetórias interplanetárias."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Simular manobras de atitude com propulsores",
                            "description": "Executar simulações de estabilização e slewing de atitude usando propulsores, analisando precisão, tempo de convergência e efeitos de perturbações externas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de simulação para dinâmica de atitude",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias como NumPy, SciPy e Matplotlib para Python ou equivalente em MATLAB.",
                                    "Definir parâmetros iniciais do satélite: momento de inércia (3x3 matrix), posição inicial de atitude (quaternions ou ângulos de Euler).",
                                    "Implementar equações cinemáticas e dinâmicas de rotação rígida (equações de Euler).",
                                    "Criar modelo básico de propulsores: thrust vector, localização no corpo e impulso específico.",
                                    "Testar integração numérica (RK4 ou odeint) com condições iniciais zero."
                                  ],
                                  "verification": "Executar simulação sem propulsores e verificar que atitude permanece constante (erro < 0.01° após 100s).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/MATLAB com bibliotecas NumPy/SciPy/Matplotlib",
                                    "Documentação de dinâmica de spacecraft (ex: Sidi 'Spacecraft Dynamics and Control')"
                                  ],
                                  "tips": "Use quaternions para evitar gimbal lock; normalize quaternions após cada atualização.",
                                  "learningObjective": "Compreender e implementar o modelo básico de dinâmica de atitude sem atuadores.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar quaternions",
                                    "Usar ângulos de Euler sem cuidado com singularidades",
                                    "Erro na matriz de inércia não simétrica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar e integrar o sistema de propulsores no simulador",
                                  "subSteps": [
                                    "Definir configuração de propulsores: 12 thrusters em pares opostos para 3 eixos (roll, pitch, yaw).",
                                    "Calcular torque gerado por cada propulor: τ = r × F, onde r é vetor de braço, F é força.",
                                    "Implementar lógica de firing: bang-bang ou PWM baseado em erro de atitude.",
                                    "Adicionar limitações reais: taxa de queima máxima, massa de propelente decrescente.",
                                    "Simular uma queima simples e plotar torque vs. tempo."
                                  ],
                                  "verification": "Aplicar torque em um eixo e verificar mudança angular correta (ex: ω aumenta linearmente com τ/I).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código do Step 1",
                                    "Diagramas de thruster configurations de CubeSats (ex: NASA docs)"
                                  ],
                                  "tips": "Vetores de thrust em body frame; transforme para inertial se necessário.",
                                  "learningObjective": "Modelar fisicamente propulsores como atuadores de torque vetorial.",
                                  "commonMistakes": [
                                    "Ignorar direção do thrust em body frame",
                                    "Não contabilizar depleção de combustível",
                                    "Torque zero para thrusters colineares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar controladores para estabilização e slewing",
                                  "subSteps": [
                                    "Desenvolver controlador PD para estabilização: u = -Kp*q - Kd*ω (quaternion error).",
                                    "Adaptar para slewing: adicionar setpoint de atitude alvo, computar quaternion de erro.",
                                    "Implementar lógica de saturação para evitar over-actuation.",
                                    "Testar em loop aberto primeiro, depois fechado com ruído mínimo.",
                                    "Ajustar gains iniciais via Ziegler-Nichols ou trial-and-error."
                                  ],
                                  "verification": "Estabilizar de atitude randômica: convergência em <30s com overshoot <5%.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Teoria de controle (ex: Ogata 'Modern Control Engineering')",
                                    "Ferramentas de plotting para step response"
                                  ],
                                  "learningObjective": "Projetar e tunar controladores para manobras de atitude com propulsores.",
                                  "commonMistakes": [
                                    "Gains muito altos causando oscilações",
                                    "Erro de quaternion não normalizado",
                                    "Ignorar acoplamento entre eixos"
                                  ],
                                  "tips": [
                                    "Sempre normalize o quaternion de erro: q_err /= norm(q_err).",
                                    "Use erro multiplicativo: q_err = q_alvo * conj(q_atual).",
                                    "Inicie com gains baixos (Kp=0.5, Kd=0.1) e aumente gradualmente.",
                                    "Aplique filtro passa-baixa em ω para reduzir ruído.",
                                    "Monitore norma de q_err e ω para detecção de falhas.",
                                    "Considere limites de torque dos propulsores na saturação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações de manobras e analisar métricas chave",
                                  "subSteps": [
                                    "Rodar simulações de estabilização (de perturbação inicial) e slewing (180° slew).",
                                    "Calcular métricas: precisão final (erro quaternion <10^-4), tempo de convergência (3σ settling time).",
                                    "Plotar trajetórias: atitude, taxa angular, uso de propelente.",
                                    "Variar cenários: diferentes setpoints, condições iniciais.",
                                    "Exportar dados para análise estatística (média, desvio padrão)."
                                  ],
                                  "verification": "Relatório com plots mostrando convergência estável em todos os testes.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código completo dos steps anteriores",
                                    "Jupyter Notebook para análise"
                                  ],
                                  "tips": "Use métricas padrão como 3σ para settling time; log escala para erros pequenos.",
                                  "learningObjective": "Analisar performance de simulações com foco em precisão e eficiência.",
                                  "commonMistakes": [
                                    "Definir settling time subjetivamente",
                                    "Não plotar todos os eixos",
                                    "Ignorar consumo de propelente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Incorporar perturbações externas e otimizar o sistema",
                                  "subSteps": [
                                    "Adicionar modelos de perturbações: gradiente gravitacional, pressão solar, drag aerodinâmico (simplificado).",
                                    "Re-simular manobras com perturbações ativas.",
                                    "Otimizar gains via simulações Monte Carlo ou genetic algorithm básico.",
                                    "Comparar before/after: impacto em precisão e tempo.",
                                    "Documentar trade-offs (ex: precisão vs. consumo de combustível)."
                                  ],
                                  "verification": "Com perturbações, precisão mantida <1° e convergência <60s em 95% dos casos.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Modelos de perturbações (ex: Vallado 'Fundamentals of Astrodynamics')",
                                    "Biblioteca de otimização como SciPy.optimize"
                                  ],
                                  "learningObjective": "Avaliar robustez do controle sob perturbações reais e otimizar performance.",
                                  "commonMistakes": [
                                    "Perturbações muito fracas ou irreais",
                                    "Otimização sem métricas claras",
                                    "Sobre-otimizar ignorando ruído"
                                  ],
                                  "tips": [
                                    "Comece com uma perturbação por vez (ex: só drag) para debugar.",
                                    "Escalone perturbações com fatores realistas (LEO: drag ~10^{-5} kg/m²).",
                                    "Monte Carlo: 1000+ runs, seed fixo para reprodutibilidade.",
                                    "GA: população 50-100, elite 10%, mutação 5-10%.",
                                    "Compare métricas: RMSE erro, tempo conv., ΔV total.",
                                    "Plots: before/after histograms de overshoot e settling time."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO executando um slew de 90° para apontar painel solar ao Sol usando 8 thrusters de peróxido. Analise: converge em 45s com erro final 0.5°, consome 2g de propelente, resiste a torque de gradiente gravitacional de 10^-6 Nm.",
                              "finalVerifications": [
                                "Simulação de estabilização converge em menos de 30 segundos com erro <0.1°.",
                                "Slewing de 180° completo com overshoot <10% e precisão final <0.5°.",
                                "Análise de propelente: consumo realista e abaixo de limite (ex: 5g por manobra).",
                                "Robustez a perturbações: erro médio <1° em 100 runs Monte Carlo.",
                                "Plots de atitude, ω e torque gerados sem divergências.",
                                "Tempo de convergência reportado com 3σ confidence."
                              ],
                              "assessmentCriteria": [
                                "Precisão de atitude final: erro quaternion norm < 10^-4.",
                                "Tempo de convergência: settling time < 60s para slews.",
                                "Eficiência de propelente: delta-V < 0.01 m/s por manobra.",
                                "Estabilidade numérica: sem NaNs ou explosões em simulações longas.",
                                "Análise quantitativa: métricas calculadas corretamente com plots claros.",
                                "Robustez: performance degradada <20% com perturbações realistas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de corpos rígidos e torques vetoriais.",
                                "Matemática: Álgebra linear (matrizes de rotação, quaternions) e EDOs não-lineares.",
                                "Programação: Simulação numérica e visualização de dados (Python/MATLAB).",
                                "Engenharia de Controle: Projeto de PD controllers e análise de estabilidade.",
                                "Física Espacial: Modelos de perturbações orbitais."
                              ],
                              "realWorldApplication": "Em missões como o satélite Starlink ou a ISS, propulsores RCS são usados para fine pointing e station-keeping, simulados previamente para validar control laws e evitar colisões ou perda de sinal."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Rodas de Reação",
                        "description": "Modelagem e simulação de rodas de reação (Reaction Wheels) como atuadores de momento inercial para controle fino de atitude sem consumo de propelente.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Derivar modelo dinâmico de rodas de reação",
                            "description": "Estabelecer as equações de conservação de momento angular para um sistema com rodas de reação em eixos ortogonais, incluindo rigidez e momento de inércia das rodas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema de coordenadas e componentes do satélite com rodas de reação",
                                  "subSteps": [
                                    "Estabeleça o referencial inercial (frame inercial) e o referencial do corpo rígido (body frame) alinhado com os eixos principais do satélite.",
                                    "Identifique as três rodas de reação montadas em eixos ortogonais (x, y, z), definindo ângulos de rotação θ_x, θ_y, θ_z.",
                                    "Defina símbolos para o momento de inércia do corpo do satélite I_b (matriz 3x3) e das rodas J_w (diagonal para cada roda).",
                                    "Inclua parâmetros de rigidez torsional k_x, k_y, k_z para modelar flexibilidade nos mounts das rodas.",
                                    "Desenhe um diagrama esquemático mostrando a configuração."
                                  ],
                                  "verification": "Diagrama completo com todos os símbolos definidos e legendas claras.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou software como Draw.io",
                                    "Referências de dinâmica de spacecraft (ex: Sidi 'Spacecraft Dynamics and Control')"
                                  ],
                                  "tips": "Use convenções de notação vetorial padrão (negrito para vetores, tilde para matrizes).",
                                  "learningObjective": "Compreender a configuração geométrica e simbólica do sistema de rodas de reação.",
                                  "commonMistakes": [
                                    "Confundir frame inercial com body frame",
                                    "Esquecer de especificar ortogonalidade dos eixos",
                                    "Ignorar rigidez torsional nos mounts"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os momentos de inércia totais e expressar o momento angular do sistema",
                                  "subSteps": [
                                    "Calcule o momento angular do corpo rígido: h_b = I_b * ω, onde ω é a velocidade angular do satélite.",
                                    "Para cada roda, expresse o momento angular: h_{w_i} = J_{w_i} * (ω_i + θ̇_i), com ω_i componente de ω no eixo i.",
                                    "Inclua efeito da rigidez: torque de restauração τ_{k_i} = k_i * (θ_i - α_i), onde α_i é desalinhamento angular.",
                                    "Some os momentos angulares: h_total = h_b + Σ h_{w_i}.",
                                    "Verifique simetria para eixos ortogonais."
                                  ],
                                  "verification": "Expressões algébricas corretas para h_total derivadas e simplificadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno de equações",
                                    "Calculadora simbólica como SymPy ou Mathematica"
                                  ],
                                  "tips": "Assuma rodas simétricas inicialmente para simplificar J_w diagonal.",
                                  "learningObjective": "Modelar contribuições individuais ao momento angular total.",
                                  "commonMistakes": [
                                    "Esquecer o termo de velocidade relativa θ̇_i nas rodas",
                                    "Não incluir rigidez k_i no momento angular",
                                    "Erro em soma vetorial de h_{w_i}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer as equações de conservação de momento angular",
                                  "subSteps": [
                                    "Aplique a lei de conservação: ḣ_total = 0 no frame inercial (sem torques externos).",
                                    "Transforme para body frame: ḣ_b + ω × h_total = -Σ τ_{w_i} (torques das rodas).",
                                    "Incorpore dinâmica das rodas: J_{w_i} * θ̈_i = u_i - k_i*(θ_i - α_i) - d_i*θ̇_i (u_i comando de torque).",
                                    "Escreva o sistema acoplado de 6 equações (3 para atitude, 3 para rodas).",
                                    "Linearize se necessário para pequenos ângulos."
                                  ],
                                  "verification": "Sistema de EDOs (equações diferenciais ordinárias) escrito corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de álgebra simbólica",
                                    "Livro de referência como Hughes 'Spacecraft Attitude Dynamics'"
                                  ],
                                  "tips": "Use a identidade de transporte de Euler para derivadas no body frame.",
                                  "learningObjective": "Derivar leis fundamentais de conservação para sistemas com atuadores rotativos.",
                                  "commonMistakes": [
                                    "Esquecer o termo de transporte ω × h",
                                    "Não acoplar dinâmica das rodas com rigidez",
                                    "Confundir comandos u_i com torques internos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e finalizar o modelo dinâmico completo",
                                  "subSteps": [
                                    "Substitua h_total nas equações principais para obter I_b * ω̇ + termos de rodas = 0.",
                                    "Expresse estado completo: [q, ω, θ, θ̇] onde q é quaternion de atitude.",
                                    "Implemente uma simulação numérica simples em Python/MATLAB para teste.",
                                    "Verifique limites: conservação de |h_total| constante.",
                                    "Documente suposições e extensões possíveis (ex: atrito)."
                                  ],
                                  "verification": "Modelo simulado roda sem deriva de momento angular.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Código template de simulação de attitude"
                                  ],
                                  "tips": "Teste com caso simples: uma roda, ω inicial zero.",
                                  "learningObjective": "Integrar e validar o modelo dinâmico derivado.",
                                  "commonMistakes": [
                                    "Erro na linearização de produtos cruzados",
                                    "Não verificar conservação numérica",
                                    "Esquecer estados das rodas no vetor de estado"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um CubeSat com três rodas de reação ortogonais (J_w = diag(0.01, 0.01, 0.01) kg m², k = 1e-3 Nm/rad), derive as equações assumindo I_b = diag(0.1, 0.1, 0.15) kg m². Simule uma manobra de 90° em yaw com comandos u_z(t), verificando que h_total se conserva.",
                              "finalVerifications": [
                                "Momento angular total constante em simulação sem torques externos.",
                                "Equações acopladas corretamente entre ω e θ̇ das rodas.",
                                "Inclusão explícita de termos de rigidez k_i em todas as rodas.",
                                "Matriz de inércia total consistente com ortogonalidade.",
                                "Simulação numérica converge sem instabilidades numéricas.",
                                "Limites físicos respeitados (ex: velocidades de rotação das rodas < 6000 rpm)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (sem erros algébricos).",
                                "Inclusão completa de rigidez torsional e momentos de inércia.",
                                "Clareza na documentação de símbolos e suposições.",
                                "Validação via simulação com resultados quantitativos.",
                                "Capacidade de generalizar para configurações não simétricas.",
                                "Eficiência computacional do modelo final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de inércia) e EDOs não-lineares.",
                                "Física: Mecânica clássica (conservação de momento angular) e dinâmica rotacional.",
                                "Engenharia de Controle: Modelagem para síntese de leis de controle (ex: LQR).",
                                "Programação: Implementação numérica em Python/MATLAB para simulação.",
                                "Engenharia Mecânica: Análise de vibrações torsionais em mounts."
                              ],
                              "realWorldApplication": "Modelos derivados são usados no controle de atitude de satélites como o CubeSat da NASA ou a ISS, permitindo manobras precisas sem propelentes, otimizando vida útil em missões de observação terrestre e telecomunicações."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Simular controle com rodas de reação",
                            "description": "Implementar lei de controle (ex: PD ou LQR) em simulação para gerenciar velocidades das rodas, monitorando saturação e desaturação via propulsores auxiliares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o modelo matemático e de simulação da dinâmica do spacecraft e rodas de reação",
                                  "subSteps": [
                                    "Definir a matriz de inércia do spacecraft e parâmetros das rodas (momento de inércia, velocidade máxima).",
                                    "Modelar as equações de atitude (cinemática quaternion ou Euler angles) e dinâmica (Euler's equations).",
                                    "Implementar o modelo das rodas de reação: torque gerado proporcional à aceleração angular da roda.",
                                    "Configurar integrador numérico (ex: ode45 no MATLAB ou solve_ivp no Python).",
                                    "Testar simulação aberta sem controle para validar dinâmica básica."
                                  ],
                                  "verification": "Simulação roda sem torque externo mantém velocidade zero e atitude estável; plote gráficos de ângulos e velocidades.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software: MATLAB/Simulink ou Python (NumPy, SciPy, Matplotlib)",
                                    "Referências: Documentação de dinâmica orbital (ex: Sidi 'Spacecraft Dynamics and Control')"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades em Euler angles; normalize quaternions periodicamente.",
                                  "learningObjective": "Compreender e implementar o modelo físico-matemático de um sistema de rodas de reação em simulação.",
                                  "commonMistakes": [
                                    "Esquecer de incluir o momento de inércia das rodas na matriz total.",
                                    "Usar unidades inconsistentes (graus vs radianos).",
                                    "Não normalizar quaternions, levando a deriva numérica."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar e implementar a lei de controle (PD ou LQR)",
                                  "subSteps": [
                                    "Definir estado do sistema: vetor de atitude erro, velocidades angulares e velocidades das rodas.",
                                    "Para PD: Calcular ganhos Kp e Kd via simulação ou método de Ziegler-Nichols adaptado.",
                                    "Para LQR: Construir matrizes A, B, Q, R; resolver equação de Riccati para K.",
                                    "Implementar lei de controle: u = -K * x, onde u são torques demandados às rodas.",
                                    "Mapear torques para comandos individuais de rodas considerando configuração (ex: skew-symmetric)."
                                  ],
                                  "verification": "Simulação com distúrbio inicial: atitude converge para zero em <10s sem oscilações excessivas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas: lqr() no MATLAB ou control.lqr no Python control library",
                                    "Templates de código para dinâmica de spacecraft"
                                  ],
                                  "tips": "Pondere Q mais em atitude do que velocidades para priorizar precisão de apontamento.",
                                  "learningObjective": "Dominar o design de controladores lineares para sistemas multi-variável como rodas de reação.",
                                  "commonMistakes": [
                                    "Ganhos PD muito altos causando overshoot e instabilidade.",
                                    "Matriz B incorreta para distribuição de torque entre rodas.",
                                    "Linearizar incorretamente o modelo não-linear."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar monitoramento de saturação e lógica de desaturação com propulsores auxiliares",
                                  "subSteps": [
                                    "Monitorar velocidades das rodas: se |ω_wheel| > 90% ω_max, sinalizar saturação.",
                                    "Implementar desaturação: calcular torque necessário para zerar velocidades das rodas usando propulsores.",
                                    "Modelar propulsores: impulso finito (delta-v), direção via matriz de configuração.",
                                    "Integrar lógica no loop de controle: priorizar rodas, usar propulsores só em saturação.",
                                    "Adicionar deadband para evitar acionamentos frequentes."
                                  ],
                                  "verification": "Em simulação longa com distúrbios, rodas saturam e desaturam corretamente sem perda de atitude.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de código para momentum dumping em spacecraft",
                                    "Bibliotecas: Simulink blocks ou custom Python functions"
                                  ],
                                  "tips": "Use filtro de média móvel para velocidades para reduzir ruído no monitoramento.",
                                  "learningObjective": "Implementar estratégias de gerenciamento de momentum em sistemas de controle de atitude reais.",
                                  "commonMistakes": [
                                    "Propulsores causando torque indesejado na atitude principal.",
                                    "Desaturação muito agressiva levando a overshoot.",
                                    "Ignorar limites de impulso dos propulsores."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações completas, analisar resultados e otimizar",
                                  "subSteps": [
                                    "Rodar cenários: aquisição de atitude, rejeição de distúrbios, saturação intencional.",
                                    "Plotar métricas: erro de atitude, velocidades rodas/propulsores, uso de combustível.",
                                    "Analisar desempenho: tempo de estabilização, overshoot, eficiência de desaturação.",
                                    "Otimizar ganhos via tuning iterativo ou otimização (ex: fmincon).",
                                    "Documentar relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Sistema mantém atitude <0.1° erro RMS por 1000s, com <5 desaturações eficientes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de plotagem avançada (Matplotlib, MATLAB figures)",
                                    "Templates de análise de controle (Bode, step response)"
                                  ],
                                  "tips": "Salve seeds aleatórios para reprodutibilidade em distúrbios.",
                                  "learningObjective": "Avaliar e refinar controladores em simulações realistas de missões espaciais.",
                                  "commonMistakes": [
                                    "Escalas erradas em plots ocultando problemas.",
                                    "Não testar casos extremos como saturação total.",
                                    "Otimização sem métricas claras de custo."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO com 4 rodas de reação em configuração pyramidal. Aplique distúrbio de gravidade-gradient e solar pressure; o controlador PD+LQR deve manter apontamento nadir com erro <1°, desaturando rodas a cada 30 minutos usando 4 propulsores de 1Nms.",
                              "finalVerifications": [
                                "Atitude erro converge para <0.5° em todos os eixos em <20s.",
                                "Velocidades das rodas mantidas abaixo de 95% do limite máximo durante operação nominal.",
                                "Desaturação via propulsores zera velocidades das rodas sem exceder 10% de delta-v total alocado.",
                                "Nenhum oscilação persistente ou instabilidade em simulações de 1 hora.",
                                "Uso de propulsores <1% do tempo total de simulação.",
                                "Gráficos mostram monitoramento correto de saturação em tempo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo dinâmico validada contra referências teóricas (erro <1%).",
                                "Controlador implementado corretamente com ganhos otimizados (sem instabilidade).",
                                "Lógica de saturação/desaturação funcional e eficiente (sem perda de performance).",
                                "Análise completa com métricas quantitativas e visualizações claras.",
                                "Código modular, comentado e reprodutível.",
                                "Relatório demonstra compreensão de trade-offs (ex: precisão vs consumo)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes A/B para LQR), equações diferenciais.",
                                "Programação: Simulação numérica, otimização (SciPy/MATLAB solvers).",
                                "Física: Dinâmica rotacional, conservação de momento angular.",
                                "Engenharia de Software: Modularidade e testes unitários em simulações.",
                                "Sistemas: Teoria de controle feedback e estados saturados."
                              ],
                              "realWorldApplication": "Em satélites como o Hubble ou estações espaciais (ISS), rodas de reação controlam atitude precisa para imagens e experimentos; desaturação com propulsores previne perda de controle, essencial para missões longas como telescópios espaciais ou constelações Starlink."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Analisar efeitos de perturbações em simulações",
                            "description": "Incorporar torque de pressão solar e magnético em simulações com rodas de reação, avaliando desempenho em regimes de microgravidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar torques de perturbação: pressão solar e magnético",
                                  "subSteps": [
                                    "Derive a equação do torque de pressão solar baseado na área projetada, intensidade solar e coeficiente de reflexão.",
                                    "Calcule o torque magnético usando o momento dipolar do satélite e o campo magnético terrestre (modelo IGRF).",
                                    "Implemente funções matemáticas para ambos os torques em código (ex: Python com NumPy).",
                                    "Valide os modelos com dados teóricos ou referências da literatura aeroespacial.",
                                    "Crie visualizações iniciais dos torques em função do tempo ou posição orbital."
                                  ],
                                  "verification": "Compare saídas do modelo com valores esperados de exemplos analíticos; gráficos mostram variação realista.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Python (NumPy, Matplotlib), documentação NASA sobre torques de perturbação, modelo IGRF.",
                                  "tips": "Use unidades consistentes (Nm para torque) e considere orientação do satélite.",
                                  "learningObjective": "Compreender e quantificar matematicamente os torques de perturbação ambientais em órbita.",
                                  "commonMistakes": "Ignorar variação da pressão solar com distância ao Sol; confundir vetor magnético com escalar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Integrar torques no simulador de rodas de reação",
                                  "subSteps": [
                                    "Configure o modelo dinâmico do satélite: equações de Euler para atitude (quaternions).",
                                    "Adicione dinâmicas das rodas de reação: torque de controle e momento de inércia.",
                                    "Incorpore os torques de perturbação como forças externas no loop de simulação.",
                                    "Implemente controlador de atitude (ex: PD ou LQR) para compensar perturbações.",
                                    "Teste integração com simulação sem perturbações para baseline."
                                  ],
                                  "verification": "Simulação roda sem crashes; atitude estabiliza sem perturbações.",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "Simulador Python (SciPy para integração ODE), bibliotecas como Orekit ou poliastro para órbitas.",
                                  "tips": "Use solvers numéricos adaptativos (RK45) para precisão em microgravidade.",
                                  "learningObjective": "Integrar perturbações realistas em modelos de controle de atitude.",
                                  "commonMistakes": "Erro de sinal nos torques; saturação prematura das rodas não modelada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações em regimes de microgravidade",
                                  "subSteps": [
                                    "Defina cenários orbitais: LEO (baixa órbita terrestre) com microgravidade simulada.",
                                    "Varie parâmetros: diferentes orientações, intensidades solares, campos magnéticos.",
                                    "Rode múltiplas simulações (Monte Carlo para variabilidade).",
                                    "Registre métricas: erro de apontamento, consumo de rodas (momentum dump).",
                                    "Gere plots de tempo: atitude, velocidades angulares, torques."
                                  ],
                                  "verification": "Simulações completam sem erros; dados salvos em arquivos CSV/plots.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Scripts de simulação personalizados, Jupyter Notebook para análise.",
                                  "tips": "Paralelize simulações com multiprocessing para eficiência.",
                                  "learningObjective": "Simular condições reais de microgravidade e coletar dados de desempenho.",
                                  "commonMistakes": "Não considerar ciclo orbital completo; timestep muito grande causando instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e avaliar desempenho sob perturbações",
                                  "subSteps": [
                                    "Calcule KPIs: RMSE de atitude, taxa de desvio de momentum das rodas.",
                                    "Compare cenários com/sem perturbações via gráficos e estatísticas.",
                                    "Identifique regimes críticos (ex: alinhamento solar-magnético).",
                                    "Proponha mitigações: redesenho de controlador ou magnetotorquers.",
                                    "Documente insights em relatório com visualizações."
                                  ],
                                  "verification": "Relatório gerado com KPIs quantificados e conclusões claras.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Pandas/Matplotlib/Seaborn para análise, LaTeX ou Markdown para relatório.",
                                  "tips": "Use boxplots para variabilidade em simulações Monte Carlo.",
                                  "learningObjective": "Interpretar resultados de simulação para avaliar robustez do sistema.",
                                  "commonMistakes": "Atribuir causalidade incorreta; ignorar efeitos cumulativos de perturbações."
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO com rodas de reação: aplique torque solar de 1e-7 Nm (painel solar exposto) e magnético de 5e-6 Nm (dipolo residual). Avalie se o controlador mantém apontamento nadir com erro <1 grau após 3 órbitas, medindo acúmulo de momentum nas rodas.",
                              "finalVerifications": [
                                "Modelos de torque reproduzem valores físicos conhecidos (ex: pressão solar ~4.5e-6 N/m²).",
                                "Simulações em microgravidade mostram estabilização de atitude apesar de perturbações.",
                                "KPIs calculados: erro de apontamento <2°, momentum acumulado quantificado.",
                                "Gráficos exibem efeitos claros de cada perturbação isolada e combinada.",
                                "Relatório identifica pelo menos 2 regimes críticos e sugestões de melhoria.",
                                "Código roda reproduzivelmente em ambiente padrão (requirements.txt)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos modelos de torque (erro <5% vs. referências).",
                                "Estabilidade e realismo da simulação (sem divergências numéricas).",
                                "Qualidade da análise quantitativa (uso de métricas estatísticas).",
                                "Interpretação correta dos efeitos em microgravidade.",
                                "Documentação clara com visualizações profissionais.",
                                "Criatividade em cenários e mitigações propostas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica rotacional, eletromagnetismo (campo magnético terrestre).",
                                "Matemática: Equações diferenciais ordinárias, integração numérica.",
                                "Programação: Simulação orientada a objetos, análise de dados (Pandas/NumPy).",
                                "Engenharia: Controle de sistemas, modelagem multiphysics.",
                                "Astronomia: Propagação orbital, ambiente espacial."
                              ],
                              "realWorldApplication": "Em missões como o satélite Hubble ou CubeSats da NASA (ex: MarCO), análise de perturbações garante controle de atitude preciso, evitando perda de orientação e otimizando vida útil das rodas de reação em microgravidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Rodas de Reação com Gimbal (CMGs)",
                        "description": "Modelagem avançada de Control Moment Gyros (CMGs) ou rodas de reação com gimbal para geração de torque direcional elevado em manobras de atitude.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Modelar torque de CMGs",
                            "description": "Desenvolver a matriz de Jacobiano para calcular torque resultante de múltiplos CMGs com velocidades angulares e ângulos de gimbal variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de CMGs e Torque Angular",
                                  "subSteps": [
                                    "Estude a geometria e funcionamento de um CMG: roda de momento inercial com gimbal.",
                                    "Revise vetores de momento angular e torque em dinâmica rotacional.",
                                    "Identifique variáveis chave: velocidade angular da roda (Ω), ângulo do gimbal (δ), vetor de momento inercial (h).",
                                    "Desenhe diagramas vetoriais para um CMG único em 3D.",
                                    "Calcule torque para casos simples (gimbal fixo)."
                                  ],
                                  "verification": "Crie um diagrama vetorial correto e calcule torque para δ=0 com precisão <1%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de dinâmica espacial (ex: Sidi 'Spacecraft Dynamics'), software de desenho vetorial (ex: GeoGebra), caderno de anotações."
                                  ],
                                  "tips": "Use convenções de coordenadas corpo-veículo para consistência.",
                                  "learningObjective": "Compreender os princípios físicos básicos de CMGs e torque resultante.",
                                  "commonMistakes": [
                                    "Confundir momento angular da roda com torque",
                                    "Ignorar direção do vetor gimbal",
                                    "Usar coordenadas erradas (inercial vs. corpo)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Torque de um Único CMG",
                                  "subSteps": [
                                    "Expresse o momento angular h = h * (u_g × u_r + u_r), onde u_g é unitário gimbal, u_r unitário roda.",
                                    "Derive torque τ = dh/dt = Ω × h + h * dδ/dt * u_g × u_r (aproximação quasi-estática).",
                                    "Implemente em coordenadas esféricas ou Euler angles para gimbal.",
                                    "Simplifique para torque perpendicular ao plano gimbal-roda.",
                                    "Valide com equações conhecidas da literatura (ex: Margulies & Aubrun)."
                                  ],
                                  "verification": "Derive equação τ = h Ω (u_s × u_g) e compare com referência (erro <5%).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/SymPy para derivação simbólica",
                                    "Artigos sobre CMGs (NASA reports)",
                                    "Calculadora simbólica."
                                  ],
                                  "tips": "Use regra da mão direita para vetores cruzados; derive simbolicamente primeiro.",
                                  "learningObjective": "Derivar matematicamente o torque de um CMG com variáveis dinâmicas.",
                                  "commonMistakes": [
                                    "Esquecer termo coriolis Ω × h",
                                    "Normalizar vetores incorretamente",
                                    "Confundir taxas angulares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Matriz de Jacobiano para Múltiplos CMGs",
                                  "subSteps": [
                                    "Defina configuração de N CMGs com vetores unitários fixos u_i e variáveis δ_i, Ω_i.",
                                    "Monte torque total τ_total = sum(τ_i) = J * u, onde u = [Ω_1 δdot_1 ... Ω_N δdot_N]^T.",
                                    "Derive elementos da Jacobiana J: ∂τ/∂Ω_i e ∂τ/∂δdot_i usando produto vetorial.",
                                    "Implemente J como matriz 3x2N com blocos [A_i B_i] por CMG.",
                                    "Teste singularidades e pseudo-inverso para controle."
                                  ],
                                  "verification": "Gere J para 4 CMGs pyramidais; verifique rank(J)=3 em configuração nominal.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB/Python (NumPy/SciPy)",
                                    "Documentação de configurações CMG (ex: 4-CMG skewed pyramid)",
                                    "Papel quadriculado."
                                  ],
                                  "tips": "Padronize ângulos gimbal de 0 a π; use sympy para Jacobiana analítica.",
                                  "learningObjective": "Formular a Jacobiana linearizando torque para múltiplos CMGs.",
                                  "commonMistakes": [
                                    "Dimensões erradas de J (deve ser 3x2N)",
                                    "Esquecer dependência em δ para A_i",
                                    "Não considerar acoplamento entre CMGs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Simular Modelo de Torque",
                                  "subSteps": [
                                    "Codifique funções para h_i(δ_i, Ω_i), J(δ_vec), τ(J, u).",
                                    "Simule trajetória: varie δ_i e Ω_i para rastrear torque desejado (ex: slew maneuver).",
                                    "Inclua dinâmica do gimbal (inércia, atrito) se aplicável.",
                                    "Plote τ vs. tempo e compare com torque comandado.",
                                    "Otimize com pseudo-inverso J^+ para u = J^+ τ_cmd."
                                  ],
                                  "verification": "Simulação reproduz torque com erro RMS <2% para perfil senoidal.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (Matplotlib, SciPy odeint)",
                                    "Exemplo código de CMG steering law."
                                  ],
                                  "tips": "Use ode45 para integração; inicialize em singularidade evitada.",
                                  "learningObjective": "Aplicar modelo em simulação numérica validada.",
                                  "commonMistakes": [
                                    "Numeração errada de colunas em J",
                                    "Escala errada de h (Nm s)",
                                    "Ignorar saturação de Ω"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar o Modelo Completo",
                                  "subSteps": [
                                    "Compare com benchmarks: torque magnitude, eficiência vs. RWAs.",
                                    "Analise sensibilidade a ruído em δ/Ω measurements.",
                                    "Teste configurações: pyramidal, coplanar; detecte singularidades.",
                                    "Documente código e resultados em relatório.",
                                    "Proponha melhorias (ex: null-motion para evitar singularidades)."
                                  ],
                                  "verification": "Relatório mostra concordância com literatura (>95% precisão em casos teste).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de plotagem",
                                    "Referências: Wie 'Space Vehicle Dynamics', papers AIAA."
                                  ],
                                  "tips": "Grave vídeos de simulação; use det(J) para monitorar singularidades.",
                                  "learningObjective": "Validar modelo e identificar limitações práticas.",
                                  "commonMistakes": [
                                    "Sobrepor torque sem soma vetorial",
                                    "Não testar limites operacionais",
                                    "Relatório sem métricas quantitativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar 4 CMGs em configuração pyramidal skew (ângulos gimbal iniciais 45°) para um satélite de 500kg rastreando um alvo terrestre. Simular slew de 30° em 60s, calculando τ resultante via J para comandar attitude.",
                              "finalVerifications": [
                                "Matriz J tem dimensões 3x8 e rank 3 em configs nominais.",
                                "Torque simulado segue comando com erro <3% RMS.",
                                "Derivação simbólica bate com numérica (teste unitário).",
                                "Simulação detecta e evita singularidades via null-space.",
                                "Eficiência angular > RWAs em manobras rápidas.",
                                "Código modular e comentado roda sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão da Jacobiana: derivada analítica vs. finita diferenças (<1e-6 erro).",
                                "Correção física: conservação de momento angular em simulação fechada.",
                                "Eficiência computacional: tempo simulação <1s para 1000 steps.",
                                "Robustez: performance com ±5% ruído em sensores.",
                                "Documentação: equações, código e plots claros.",
                                "Inovação: inclusão de dinâmica gimbal ou steering law."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (Jacobianas, pseudo-inversas), cálculo vetorial.",
                                "Física: Dinâmica rotacional, mecânica celeste.",
                                "Programação: Modelagem numérica, simulação ODE, visualização 3D.",
                                "Engenharia de Controle: Linearização não-linear, leis de steering.",
                                "Ciência de Dados: Análise de sensibilidade, otimização."
                              ],
                              "realWorldApplication": "Controle de atitude em estações espaciais como ISS (CMGs principais), satélites ágil como WorldView, ou missões deep-space (ex: James Webb ST para apontamento preciso), otimizando torque sem desgaste como em RWAs."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Implementar simulação de cluster de CMGs",
                            "description": "Simular configurações pyramidais ou coplanar de CMGs em ambiente de simulação, incluindo algoritmos de steering para evitar singularidades.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar Dinâmica de um Único CMG",
                                  "subSteps": [
                                    "Defina os parâmetros cinemáticos do CMG: vetor de giro angular constante ω_g, ângulo de gimbal γ, e momento de inércia J.",
                                    "Implemente a equação de torque gerado: h = J * ω_g * [cos(γ), sin(γ), 0]^T para um eixo de gimbal simples.",
                                    "Crie uma função para derivada do momento angular: ḣ = J * ω_g * [-sin(γ), cos(γ), 0]^T * γ̇.",
                                    "Adicione ruído e limites realistas (ex: γ entre -90° e 90°).",
                                    "Visualize o torque em 3D usando Matplotlib."
                                  ],
                                  "verification": "Execute a simulação de um CMG isolado e confirme que o torque segue uma elipse no plano de saída sem erros numéricos.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "SciPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use vetores unitários para normalizar direções e evite overflows em seno/cosseno.",
                                  "learningObjective": "Compreender e implementar o modelo matemático básico de torque de um CMG.",
                                  "commonMistakes": [
                                    "Confundir vetor de giro com eixo de gimbal",
                                    "Ignorar limites de gimbal levando a NaNs",
                                    "Não normalizar vetores de momento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Geometria do Cluster de CMGs",
                                  "subSteps": [
                                    "Escolha configuração: pyramidal (4 CMGs em pirâmide) ou coplanar (4 CMGs no plano XY).",
                                    "Defina matriz de geometria A (3xN) onde cada coluna é o vetor unitário de saída de torque de um CMG.",
                                    "Implemente torque total do cluster: h_total = A * [h1; h2; ...; hN].",
                                    "Calcule pseudoinverso de A para mapeamento inicial de torque desejado para comandos de gimbal.",
                                    "Teste com torque constante desejado e plote momentos individuais."
                                  ],
                                  "verification": "Verifique que o cluster gera torque desejado unitário em qualquer direção com erro < 1%.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Python com NumPy/SciPy (pinv)",
                                    "Jupyter Notebook para visualização"
                                  ],
                                  "tips": "Para pyramidal, skew os ângulos em 54.74° para cobertura ótima; valide det(A) != 0.",
                                  "learningObjective": "Construir e validar geometria de cluster para cobertura esférica de torque.",
                                  "commonMistakes": [
                                    "Matriz A transposta incorreta",
                                    "Escolha de ângulos levando a singularidades inerentes",
                                    "Não escalar magnitudes de h corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Algoritmo de Steering para Evitar Singularidades",
                                  "subSteps": [
                                    "Identifique métrica de singularidade: det(A(γ)) ou momentum envelope.",
                                    "Implemente steering reativo (ex: método de Singh): ajuste γ̇ perpendicular ao plano de singularidade.",
                                    "Defina lógica: se |det(A)| < threshold, compute γ̇_steer = k * (∇ det(A)) × h_desejado.",
                                    "Integre com controlador PID para rastrear torque desejado: γ̇_total = γ̇_pid + γ̇_steer.",
                                    "Simule trajetória de torque com mudança brusca para testar evasão."
                                  ],
                                  "verification": "Simule 100s de manobra; confirme que det(A) nunca cai abaixo de 0.5 e torque erro < 5%.",
                                  "estimatedTime": "4 hours",
                                  "materials": [
                                    "SciPy para integração numérica (odeint)",
                                    "NumPy para gradientes"
                                  ],
                                  "tips": "Threshold de singularidade ~0.1-0.3; normalize γ̇_steer para |γ̇| < 1 rad/s.",
                                  "learningObjective": "Desenvolver algoritmos que mantêm o cluster fora de singularidades durante operações.",
                                  "commonMistakes": [
                                    "Gradiente numérico instável sem suavização",
                                    "Steering oscilante por ganho alto",
                                    "Ignorar limites de taxa de gimbal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Simulação Completa com Dinâmica do Veículo Espacial",
                                  "subSteps": [
                                    "Modele dinâmica do S/C: I * ω̇ + ω × (h_cmgs + h_rw) = τ_ext (simplificado).",
                                    "Implemente loop de simulação fechado: torque_desejado de quaternion PD controller.",
                                    "Inclua propagação de atitude com RK4 ou odeint.",
                                    "Adicione distúrbios (gravity gradient, drag).",
                                    "Gere plots: atitude erro, envelope de momentum, trajetórias de gimbal."
                                  ],
                                  "verification": "Execute simulação de 1 órbita; atinja apontamento com erro < 0.1° sem singularidades.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Python SciPy.integrate",
                                    "Astropy para modelo orbital opcional"
                                  ],
                                  "tips": "Use quaternions para evitar gimbal lock; inicialize CMGs em posições balanceadas.",
                                  "learningObjective": "Integrar cluster de CMGs em simulação realista de controle de atitude.",
                                  "commonMistakes": [
                                    "Não desacoplar rotação do S/C dos CMGs",
                                    "Escala errada de inércias",
                                    "Loops de controle instáveis sem tuning"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Otimizar a Simulação",
                                  "subSteps": [
                                    "Compare com benchmarks literários (ex: torque pyramid de 0.707 max).",
                                    "Teste cenários edge: desaturação, falha de CMG simulada.",
                                    "Otimize performance com vetorização NumPy.",
                                    "Gere relatório com métricas: tempo de computação, uso de gimbal range.",
                                    "Exporte animação 3D do cluster."
                                  ],
                                  "verification": "Todos testes passam; otimização reduz tempo sim < 10s para 1h real.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Matplotlib animation",
                                    "Benchmark papers PDF"
                                  ],
                                  "tips": "Simule falha zerando um h_i; verifique redundância.",
                                  "learningObjective": "Garantir robustez e eficiência da simulação de cluster.",
                                  "commonMistakes": [
                                    "Validação sem casos extremos",
                                    "Animações lentas por plots excessivos",
                                    "Otimização prematura"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um cluster pyramidal de 4 CMGs em um satélite CubeSat realizando uma manobra de 90° de apontamento para aquisição de imagem terrestre, evitando singularidades durante aceleração máxima de torque (0.5 Nm).",
                              "finalVerifications": [
                                "Simulação executa sem crashes ou NaNs por 1000s de tempo simulado.",
                                "Torque gerado matches desejado com erro médio < 2% em todas direções.",
                                "Métrica de singularidade permanece > 0.5 durante toda a trajetória.",
                                "Uso de gimbal < 80% do range total.",
                                "Atitude do S/C converge para setpoint com overshoot < 5°.",
                                "Momentum total do cluster dumpável via desaturação simulada."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo matemático (erro torque < 1%).",
                                "Robustez do steering (zero singularidades em testes randômicos).",
                                "Eficiência computacional (simulação de 1 órbita < 30s).",
                                "Qualidade de visualizações e documentação de código.",
                                "Capacidade de lidar com falhas (redundância demonstrada).",
                                "Alinhamento com literatura (ex: cobertura esférica 100%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (pseudoinverso, determinantes), cálculo vetorial.",
                                "Física: Dinâmica rotacional, conservação de momento angular.",
                                "Programação: Integração numérica, OOP para modelar atuadores.",
                                "Engenharia de Controle: PID, métricas de performance não-lineares.",
                                "Ciência de Dados: Visualização 3D, análise de envelopes."
                              ],
                              "realWorldApplication": "Clusters de CMGs são usados na Estação Espacial Internacional (ISS) para controle de atitude preciso e eficiente, economizando propelente em comparação com rodas de reação, e em satélites como o James Webb Space Telescope para manobras finas sem vibrações."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Avaliar desempenho em manobras complexas",
                            "description": "Executar simulações de grandes manobras de atitude com CMGs, comparando eficiência energética e precisão com outros atuadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de simulação para CMGs e atuadores comparativos",
                                  "subSteps": [
                                    "Instalar e configurar software de simulação (ex: MATLAB/Simulink ou Python com Orekit/ poliastro).",
                                    "Modelar o veículo espacial com dinâmica de atitude rígida, incluindo inércia e CMGs parametrizados (singularidades, torque máximo).",
                                    "Adicionar modelos de atuadores alternativos: rodas de reação (RWs), propulsores (thrusters).",
                                    "Definir condições iniciais: estado de atitude quiescente, perturbações gravitacionais e aerodinâmicas mínimas.",
                                    "Validar modelo com teste de manobra simples (ex: rotação de 10°)."
                                  ],
                                  "verification": "Executar simulação de teste e confirmar que ângulos de atitude convergem para zero com erro < 0.1°.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB/Simulink com Aerospace Toolbox; Python (NumPy, SciPy, Orekit); documentação de CMGs (NASA/ESA specs).",
                                  "tips": "Use bibliotecas open-source como Spacecraft Control Toolbox para aceleração.",
                                  "learningObjective": "Entender modelagem precisa de atuadores para simulações realistas.",
                                  "commonMistakes": "Ignorar singularidades de CMGs, levando a torques irreais; não normalizar matrizes de inércia."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e parametrizar manobras complexas de atitude",
                                  "subSteps": [
                                    "Selecionar manobras: reorientação Euler 90°-180°-90°, slew de apontamento rápido, evasão simulada.",
                                    "Especificar perfil de comando: quaternions desejados, taxas angulares limites (ex: 5°/s).",
                                    "Configurar métricas: eficiência energética (Δv ou impulso específico), precisão (erro de apontamento RMS).",
                                    "Implementar lei de controle: PD para RWs/thrusters; steering law para CMGs (ex: B-dot modificado).",
                                    "Gerar scripts automatizados para múltiplas runs com variações (ex: massa alterada)."
                                  ],
                                  "verification": "Visualizar trajetórias de quaternions e confirmar alcance de estados finais em < 10 minutos simulados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Scripts Python/MATLAB para geração de comandos; referências de manobras (ex: papers sobre ISS CMGs).",
                                  "tips": "Comece com manobras simétricas para isolar efeitos de singularidade.",
                                  "learningObjective": "Dominar definição de cenários realistas de manobras espaciais.",
                                  "commonMistakes": "Definir comandos muito agressivos sem limites físicos, causando saturação prematura."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações e coletar dados de desempenho",
                                  "subSteps": [
                                    "Rodar simulações para cada atuador: 10 iterações por manobra, com ruído sensorial (0.01°).",
                                    "Registrar dados: torques, consumos energéticos (∫|u|^2 dt), tempos de settling, erros de tracking.",
                                    "Exportar logs para CSV/MAT: tempo, estado, controle, métricas integradas.",
                                    "Simular falhas: perda de 1 CMG gimbal, saturação de RW.",
                                    "Plotar preliminar: curvas de atitude vs tempo para inspeção visual."
                                  ],
                                  "verification": "Verificar que todas simulações completam sem crashes e dados exportados corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Cluster computacional ou PC com GPU para paralelização; ferramentas de plotting (Matplotlib/Plotly).",
                                  "tips": "Paralelize runs com multiprocessing para eficiência.",
                                  "learningObjective": "Coletar dados robustos para análise comparativa.",
                                  "commonMistakes": "Não incluir ruído, superestimando precisão; amostragem insuficiente em picos de torque."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e comparar eficiência energética e precisão",
                                  "subSteps": [
                                    "Calcular métricas: eficiência = precisão / energia; comparar boxplots por atuador.",
                                    "Análise estatística: médias, desvios, testes t para significância (p<0.05).",
                                    "Identificar trade-offs: CMGs vs RWs (alta torque vs acúmulo de momentum).",
                                    "Visualizar: radar charts de métricas, heatmaps de singularidades.",
                                    "Documentar insights: ex: CMGs 30% mais eficientes em slews grandes."
                                  ],
                                  "verification": "Gerar relatório com tabelas/gráficos mostrando CMGs superiores em pelo menos 2 métricas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Pandas/NumPy para análise; Seaborn para visualizações; LaTeX/Jupyter para relatório.",
                                  "tips": "Normalize energia por unidade de massa para comparações justas.",
                                  "learningObjective": "Avaliar quantitativamente desempenho de atuadores.",
                                  "commonMistakes": "Comparar sem normalização, favorecendo atuadores de alta capacidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar resultados e formular recomendações",
                                  "subSteps": [
                                    "Sintetizar achados: prós/cons de CMGs (eficiência vs complexidade).",
                                    "Simular cenários reais: órbita LEO com eclipse energético.",
                                    "Propor otimizações: hybrid CMG-RW steering.",
                                    "Preparar apresentação: slides com key plots e conclusões.",
                                    "Autoavaliar: métricas atendem specs industriais (ex: <1% erro, energia < benchmark)."
                                  ],
                                  "verification": "Conclusões suportadas por dados; recomendações acionáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": "PowerPoint/Google Slides; benchmarks de missões (ex: Hubble, SWARM).",
                                  "tips": "Foque em impacto: custo vs performance para seleção.",
                                  "learningObjective": "Traduzir análise em decisões de engenharia.",
                                  "commonMistakes": "Ignorar viabilidade prática, como peso/custo de CMGs."
                                }
                              ],
                              "practicalExample": "Simule uma manobra de reorientação de 180° em um satélite de observação terrestre usando 4 CMGs vs 4 RWs: CMGs completam em 120s com 15% menos energia e erro RMS de 0.05°, enquanto RWs acumulam momentum requerendo desaturação.",
                              "finalVerifications": [
                                "Simulações rodam sem erros numéricos ou singularidades críticas.",
                                "Comparação mostra eficiência energética de CMGs ≥20% superior em manobras >90°.",
                                "Precisão de atitude <0.1° RMS para todos atuadores testados.",
                                "Relatório inclui gráficos de torque/energia e tabelas estatísticas.",
                                "Recomendações alinhadas com trade-offs reais (ex: CMGs para agilidade alta).",
                                "Testes de sensibilidade confirmam robustez a variações de parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Eficiência energética: ΔE_CMGs < 0.8 * ΔE_outros.",
                                "Precisão: erro final < 0.05° com settling < 5% em 60s.",
                                "Robustez: performance sob falha de 25% capacidade mantida >80%.",
                                "Análise estatística: significância comprovada (p<0.01).",
                                "Documentação: clareza e completude (todos plots/métricas presentes).",
                                "Tempo total de manobra: CMGs <150s para slew 180°."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (quaternions, eigenaxes), otimização (steering laws).",
                                "Física: Dinâmica rígida, conservação de momento angular.",
                                "Programação: Simulação numérica (ODE solvers), análise de dados (Pandas/Stats).",
                                "Engenharia de Sistemas: Trade-off analysis, model-based design.",
                                "Gestão de Projetos: Benchmarking e validação de requisitos."
                              ],
                              "realWorldApplication": "Seleção de atuadores para satélites ágeis como Starlink ou missões da NASA (ex: Roman Space Telescope), otimizando vida útil via menor consumo energético em reorientações frequentes para imaging."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Simulação de Controle para Estabilização de Atitude",
                    "description": "Implementação de algoritmos de controle visando a estabilização da orientação do veículo espacial.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Determinação de Atitude a partir de Sensores",
                        "description": "Conceitos fundamentais sobre os sensores utilizados para estimar a orientação (atitude) do veículo espacial, incluindo princípios de funcionamento e integração de dados.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Sensores Terrestres Infravermelho",
                            "description": "Compreender e simular o uso de sensores infravermelhos terrestres para determinar a atitude, considerando detecção de horizontes terrestres e algoritmos de processamento de sinal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Básicos dos Sensores Infravermelhos Terrestres",
                                  "subSteps": [
                                    "Estudar a emissão de radiação infravermelha pela superfície terrestre devido à temperatura.",
                                    "Analisar o contraste térmico entre o horizonte terrestre e o fundo espacial frio.",
                                    "Explorar os tipos de detectores IR (ex: bolômetros, fotodiodos) usados em spacecraft.",
                                    "Revisar a óptica focalizadora e o campo de visão (FOV) típico dos sensores.",
                                    "Identificar fontes de ruído como emissividade variável e interferência solar."
                                  ],
                                  "verification": "Criar um diagrama esquemático do sensor IR detectando o horizonte e explicar o contraste térmico em 200 palavras.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Textos sobre sensores ópticos em aeroespacial",
                                    "Vídeos da NASA sobre sensores de horizonte",
                                    "Simulador online de radiação térmica"
                                  ],
                                  "tips": "Visualize o sensor girando para escanear o horizonte; foque no pico de sinal no limiar terra-espaço.",
                                  "learningObjective": "Explicar o mecanismo físico de detecção de horizontes via contraste IR.",
                                  "commonMistakes": [
                                    "Confundir radiação IR refletida com emitida",
                                    "Ignorar a dependência da temperatura ambiente do sensor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Detecção de Horizontes Terrestres",
                                  "subSteps": [
                                    "Simular geometricamente a geometria orbital e o ângulo de nadir para detecção.",
                                    "Analisar o perfil de sinal: rampa ascendente no horizonte devido ao gradiente térmico.",
                                    "Explorar técnicas de thresholding para identificar o limiar terra-espaço.",
                                    "Estudar compensação para variações de altitude e inclinação orbital.",
                                    "Revisar calibração do sensor com dados reais de missões espaciais."
                                  ],
                                  "verification": "Plotar um gráfico simulado do sinal IR durante uma varredura de 360 graus, marcando o horizonte detectado.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software MATLAB/Python para plotagem",
                                    "Dados de sensores IR públicos da NASA",
                                    "Documentação de satélites como GOES"
                                  ],
                                  "tips": "Use modelagem simples de Terra como elipsoide negro para simulações iniciais.",
                                  "learningObjective": "Modelar e detectar o horizonte terrestre a partir de sinais IR simulados.",
                                  "commonMistakes": [
                                    "Subestimar o alargamento do horizonte em órbitas baixas",
                                    "Não considerar assimetrias no sinal devido a nuvens"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Algoritmos de Processamento de Sinal",
                                  "subSteps": [
                                    "Implementar filtros passa-baixa para redução de ruído de alta frequência.",
                                    "Aplicar detecção de borda (ex: Canny adaptado) no perfil de sinal IR.",
                                    "Desenvolver algoritmo de estimação de atitude via regressão linear no limiar.",
                                    "Integrar dados de múltiplos sensores para triangulação de atitude.",
                                    "Otimizar com técnicas como Kalman filter para fusão de medições."
                                  ],
                                  "verification": "Codificar e testar um script que processa sinal ruidoso e estima o ângulo de rolagem com erro <5 graus.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Tutoriais de processamento de sinal digital",
                                    "Código aberto de attitude determination"
                                  ],
                                  "tips": "Comece com filtros simples antes de avançar para Kalman; valide com sinais sintéticos.",
                                  "learningObjective": "Aplicar processamento de sinal para extrair atitude precisa de dados IR.",
                                  "commonMistakes": [
                                    "Sobrefiltragem que borra o limiar do horizonte",
                                    "Não normalizar sinais de sensores diferentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Determinação de Atitude Completa",
                                  "subSteps": [
                                    "Configurar um modelo dinâmico de spacecraft com sensores IR em simulação.",
                                    "Integrar detecção de horizonte e processamento em loop de controle.",
                                    "Simular cenários: órbita LEO, tumbling inicial, recuperação de atitude.",
                                    "Avaliar performance com métricas como RMSE de atitude estimada.",
                                    "Refinar algoritmo com dados reais ou benchmarks de literatura."
                                  ],
                                  "verification": "Executar simulação full e gerar relatório com gráficos de atitude verdadeira vs. estimada.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "MATLAB Aerospace Toolbox ou Orekit (Python)",
                                    "Dados orbitais TLE",
                                    "Scripts de simulação de attitude"
                                  ],
                                  "tips": "Use quaternions para representação de atitude para evitar gimbal lock.",
                                  "learningObjective": "Simular sistema completo de determinação de atitude usando sensores IR terrestres.",
                                  "commonMistakes": [
                                    "Erro na propagação orbital afetando geometria",
                                    "Ignorar delays de processamento em loop real-time"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python com SciPy, simule um satélite em órbita a 500km varrendo com 4 sensores IR. Detecte horizontes em sinais ruidosos, aplique filtro Kalman e estime rolagem/pitch com precisão de 0.5 graus, comparando com atitude conhecida.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo desde sinal bruto até atitude estimada.",
                                "Implementar simulação que converge atitude em <10s sob ruído realista.",
                                "Identificar e corrigir erros em sinal sintético com horizonte obscurecido.",
                                "Comparar resultados com paper clássico de horizon sensor (ex: NASA TN D-4741).",
                                "Desenhar diagrama de blocos do sistema de processamento.",
                                "Calcular covariância de erro para múltiplas órbitas simuladas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimação de atitude: erro médio <2 graus.",
                                "Robustez a ruído: performance estável com SNR >10dB.",
                                "Eficiência computacional: processamento <1ms por amostra.",
                                "Correção conceitual: 100% acerto em quiz sobre princípios IR.",
                                "Qualidade da simulação: gráficos claros e análise quantitativa.",
                                "Criatividade: extensão com fusão multi-sensor."
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de Planck e Stefan-Boltzmann para radiação térmica.",
                                "Matemática: Filtros digitais, estimação bayesiana e geometria esférica.",
                                "Computação: Programação numérica e simulação de sistemas dinâmicos.",
                                "Engenharia Elétrica: Eletrônica de sensores e processamento embarcado.",
                                "Geografia: Modelos orbitais e topografia terrestre afetando sinais."
                              ],
                              "realWorldApplication": "Em satélites geoestacionários como o GOES-16, sensores IR terrestres fornecem determinação autônoma de atitude para apontamento preciso de antenas e imageamento da Terra, essencial em operações sem GPS ou em falhas de giroscópios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Sensores Solares e de Estrelas",
                            "description": "Analisar sensores solares para detecção de direção solar e sensores de estrelas para referência estelar fixa, incluindo calibração e fusão de dados para estimativa precisa de atitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Funcionamento de Sensores Solares",
                                  "subSteps": [
                                    "Estude os princípios físicos da detecção solar usando fotodiodos ou células solares em array.",
                                    "Analise como os sensores medem a intensidade da luz solar em múltiplos eixos para determinar a direção do vetor solar.",
                                    "Explore modelos matemáticos para converter leituras de intensidade em ângulos de incidência (ex: modelo de cosine law).",
                                    "Simule geometricamente a posição relativa do Sol em relação ao veículo espacial.",
                                    "Identifique limitações como obstruções ou variações atmosféricas (embora mínimas no espaço)."
                                  ],
                                  "verification": "Desenhe um diagrama do sensor solar e calcule manualmente a direção solar para um caso dado com erro <5°.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação técnica de sensores solares (ex: NASA docs)",
                                    "Software de simulação como MATLAB ou Python com NumPy",
                                    "Diagramas de sensores impressos"
                                  ],
                                  "tips": "Visualize o sensor como um 'olho' que vê o Sol mais forte quando apontado diretamente para ele.",
                                  "learningObjective": "Explicar como sensores solares detectam a direção do Sol e modelar suas leituras matematicamente.",
                                  "commonMistakes": [
                                    "Ignorar a lei do cosseno nas projeções angulares",
                                    "Confundir intensidade com ângulo diretamente",
                                    "Não considerar rotação da Terra no modelo solar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Funcionamento de Sensores de Estrelas",
                                  "subSteps": [
                                    "Aprenda sobre câmeras de estrelas que capturam imagens estelares e reconhecem padrões de constelações.",
                                    "Estude algoritmos de reconhecimento de estrelas (ex: lost-in-space vs. track mode).",
                                    "Analise catálogos estelares como Hipparcos ou Gaia para referências fixas.",
                                    "Entenda a geração de quaternions de atitude a partir de vetores de estrelas observados vs. catálogos.",
                                    "Discuta precisão típica (arcosegundos) e desafios como brilho solar ou movimento."
                                  ],
                                  "verification": "Identifique corretamente 3 estrelas em uma imagem simulada e compute o vetor de atitude.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Catálogos estelares online (ex: Gaia DR3)",
                                    "Software como StellaTracker ou Python com Astropy",
                                    "Imagens de teste de sensores de estrelas"
                                  ],
                                  "tips": "Comece com imagens claras de noites sem Lua para praticar reconhecimento.",
                                  "learningObjective": "Modelar sensores de estrelas como referências inerciais fixas para atitude.",
                                  "commonMistakes": [
                                    "Usar estrelas erradas devido a falsos positivos",
                                    "Não alinhar campos de visão corretamente",
                                    "Ignorar aberração estelar em altas velocidades"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Calibração dos Sensores",
                                  "subSteps": [
                                    "Colete dados de sensores em posições conhecidas usando uma plataforma de teste giratória.",
                                    "Aplique métodos de calibração como least-squares para offsets e escalas nos sensores solares.",
                                    "Para sensores de estrelas, calibre o boresight (alinhamento ótico) e distorção da lente.",
                                    "Valide calibração comparando leituras com modelos teóricos ou GPS/IMU auxiliares.",
                                    "Documente parâmetros calibrados (matrizes de calibração, desvios)."
                                  ],
                                  "verification": "Aplique parâmetros calibrados e reduza erro de direção solar para <1° em teste.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Plataforma de rotação ou simulador (ex: MATLAB Aerospace Toolbox)",
                                    "Sensores reais ou emuladores",
                                    "Planilhas Excel ou Python scripts para least-squares"
                                  ],
                                  "tips": "Use dados redundantes (múltiplas rotações) para robustez na calibração.",
                                  "learningObjective": "Calibrar sensores para minimizar vieses e maximizar precisão.",
                                  "commonMistakes": [
                                    "Subamostragem de dados levando a overfitting",
                                    "Não isolar vibrações durante coleta",
                                    "Confundir calibração estática com dinâmica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Fusão de Dados para Estimativa Precisa de Atitude",
                                  "subSteps": [
                                    "Implemente filtros como Kalman Estendido (EKF) para fundir vetores solares (baixo custo) e estelares (alta precisão).",
                                    "Defina modelo de estado com quaternions de atitude e taxas angulares.",
                                    "Incorpore medições: direção solar como observável e estrelas para updates precisos.",
                                    "Simule cenários com ruído e valide convergência para erro <0.1°.",
                                    "Otimize pesos de fusão baseado em covariâncias de cada sensor."
                                  ],
                                  "verification": "Execute simulação onde filtro converge para atitude verdadeira com RMSE <0.05°.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com SciPy/NumPy para EKF",
                                    "Ferramentas como Orekit ou GMAT para simulação orbital",
                                    "Datasets de sensores públicos (ex: CubeSat missions)"
                                  ],
                                  "tips": "Inicialize com solução solar grosseira antes de refinar com estrelas.",
                                  "learningObjective": "Integrar dados de múltiplos sensores para estimativa ótima de atitude.",
                                  "commonMistakes": [
                                    "Linearização incorreta no EKF",
                                    "Covariâncias mal definidas causando divergência",
                                    "Não tratar outages de sensores (ex: Sol eclipsado)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integração e Testes Finais",
                                  "subSteps": [
                                    "Integre sistema completo em um loop de simulação de veículo espacial.",
                                    "Teste em cenários reais: eclipse solar, manobras, falhas de sensor.",
                                    "Analise performance com métricas como tempo de convergência e robustez.",
                                    "Gere relatórios com plots de atitude estimada vs. verdade.",
                                    "Proponha melhorias como adição de magnetômetros."
                                  ],
                                  "verification": "Sistema mantém atitude precisa em 95% dos cenários simulados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador integrado (ex: MATLAB Simulink)",
                                    "Scripts de análise de performance"
                                  ],
                                  "tips": "Use Monte Carlo simulations para estatísticas robustas.",
                                  "learningObjective": "Validar sistema de determinação de atitude em condições operacionais.",
                                  "commonMistakes": [
                                    "Testes só em condições ideais",
                                    "Ignorar latência de processamento",
                                    "Sobreajuste a um cenário específico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um simulador de CubeSat usando Python e Orekit, implemente sensores solares e de estrelas para determinar a atitude durante uma órbita LEO, fundindo dados para apontar painéis solares com precisão de 0.1° e rastrear estrelas para orientação inercial.",
                              "finalVerifications": [
                                "Calcular direção solar com erro <1° a partir de leituras brutas.",
                                "Reconhecer e vetorizar estrelas em imagens com >95% acurácia.",
                                "Calibrar sensores reduzindo bias para <0.5°.",
                                "Fusão via EKF converge em <10s com erro final <0.05°.",
                                "Sistema opera corretamente em simulações com falhas de sensor.",
                                "Explicar trade-offs entre sensores solares (rápidos, imprecisos) e estelares (precisos, lentos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa de atitude (RMSE <0.1°).",
                                "Robustez a ruído e falhas (sucesso >90% em testes).",
                                "Eficiência computacional (tempo real <1s por ciclo).",
                                "Qualidade da calibração (residuals <0.2°).",
                                "Documentação clara de modelos e resultados.",
                                "Capacidade de explicar fusão de dados interdisciplinarmente."
                              ],
                              "crossCurricularConnections": [
                                "Física: Óptica e mecânica orbital.",
                                "Matemática: Álgebra linear (quaternions), filtros estocásticos.",
                                "Programação: Simulações numéricas em Python/MATLAB.",
                                "Engenharia: Sistemas embarcados e controle.",
                                "Astronomia: Catálogos estelares e efemérides solares."
                              ],
                              "realWorldApplication": "Em satélites como os da constelação Starlink ou missões da NASA (ex: James Webb), sensores solares e de estrelas determinam atitude para apontamento preciso de antenas, painéis solares e instrumentos científicos, essencial para comunicações e observações."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Sensores Inerciais",
                            "description": "Implementar modelos de giroscópios e acelerômetros inerciais para propagação de atitude em curto prazo, lidando com deriva e integração numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Fundamentais de Sensores Inerciais",
                                  "subSteps": [
                                    "Estude o princípio físico do giroscópio baseado na conservação do momento angular e precessão.",
                                    "Analise como giroscópios medem velocidades angulares (ω) em três eixos (roll, pitch, yaw).",
                                    "Explore o funcionamento de acelerômetros MEMS, que medem acelerações específicas lineares.",
                                    "Diferencie sensores inerciais strapdown (fixos no corpo) de plataformas estabilizadas.",
                                    "Revise unidades de medida (rad/s para ω, m/s² para a) e taxas de amostragem típicas (100-1000 Hz)."
                                  ],
                                  "verification": "Crie um diagrama esquemático mostrando saídas de um IMU (Inertial Measurement Unit) e explique verbalmente ou por escrito.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação de IMUs (ex: datasheet Bosch BMI088)",
                                    "Vídeo 'How IMUs Work' no YouTube",
                                    "Livro 'Strapdown Inertial Navigation' capítulo introdutório"
                                  ],
                                  "tips": "Use visualizações 3D (ex: Blender ou MATLAB) para simular rotações e entender eixos do corpo vs. inercial.",
                                  "learningObjective": "Explicar como giroscópios e acelerômetros fornecem dados indiretos para propagação de atitude.",
                                  "commonMistakes": [
                                    "Confundir velocidades angulares com ângulos absolutos",
                                    "Ignorar alinhamento de eixos do sensor com o frame do veículo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar as Equações Matemáticas dos Sensores",
                                  "subSteps": [
                                    "Derive as equações de saída do giroscópio: ω_m = ω + b_g + n_g + S_g * ω (bias, ruído, fator de escala).",
                                    "Modele o acelerômetro: f_m = f + b_a + n_a + S_a * f (força específica no frame do corpo).",
                                    "Defina os frames de referência: inercial (NED), corpo (body-frame).",
                                    "Escreva a cinemática de atitude usando quaternions: ḣ = (1/2) q ⊗ ω_b^n.",
                                    "Inclua deriva determinística (bias drift) e estocástica (ruído aleatório)."
                                  ],
                                  "verification": "Implemente as equações em um notebook simbólico (SymPy ou MATLAB) e verifique simplificações para ω constante.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SymPy ou MATLAB Symbolic Toolbox",
                                    "Artigo 'Quaternion Kinematics for Error-State Kalman Filter'"
                                  ],
                                  "tips": "Sempre normalize quaternions após integração para evitar crescimento numérico.",
                                  "learningObjective": "Formular modelos matemáticos precisos para saídas de sensores inerciais com erros realistas.",
                                  "commonMistakes": [
                                    "Esquecer a matriz de rotação na propagação",
                                    "Usar ângulos de Euler em vez de quaternions, levando a gimbal lock"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Propagação de Atitude via Integração Numérica",
                                  "subSteps": [
                                    "Escolha e implemente um integrador numérico (ex: Runge-Kutta 4ª ordem para dq/dt = 0.5 q * ω).",
                                    "Code a função de propagação em Python/MATLAB: atualize quaternion a partir de ω_m ao longo de Δt.",
                                    "Incorpore compensação básica de bias estimado (subtraia b_g médio).",
                                    "Teste com rotação constante conhecida (ex: 1 rad/s em roll) por 10s.",
                                    "Compare propagação com solução analítica para validar precisão."
                                  ],
                                  "verification": "Execute simulação e plote erro de atitude vs. tempo; erro < 0.1° em 10s sem deriva.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Exemplo código GitHub 'quaternion_attitude_propagation'"
                                  ],
                                  "tips": "Use Δt pequeno (0.001s) para estabilidade; filtre ω com média móvel para reduzir ruído.",
                                  "learningObjective": "Desenvolver código para propagar atitude em curto prazo usando dados de giroscópio.",
                                  "commonMistakes": [
                                    "Integração instável por Δt grande",
                                    "Não converter ω do frame body para inercial corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Lidar com Deriva, Integração de Acelerômetros e Validação",
                                  "subSteps": [
                                    "Modele e simule deriva: adicione bias crescente (ex: 0.01°/s/h) e ruído Gaussiano.",
                                    "Integre dados de acelerômetro para gravidade no frame body e use para correção de roll/pitch.",
                                    "Implemente detecção de deriva: monitore crescimento de norma do vetor de atitude.",
                                    "Valide com dados reais/simulados: compare com verdade-ground (ex: de GPS ou estrelas).",
                                    "Otimize: ajuste fatores de escala e bias via least-squares em batch."
                                  ],
                                  "verification": "Simule 60s com deriva; atitude diverge < 5° e correção reduz erro em 50%.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Dados de IMU open-source (ex: Xsens dataset)",
                                    "Ferramenta de plotagem Matplotlib/Plotly"
                                  ],
                                  "tips": "Para curto prazo (<1min), priorize giroscópio; use acelerômetro só para tilt inicial.",
                                  "learningObjective": "Mitigar erros de deriva em propagação inercial e validar implementação.",
                                  "commonMistakes": [
                                    "Ignorar deriva bias em simulações idealizadas",
                                    "Sobrecompensar ruído, introduzindo lag"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simulação Integrada e Análise de Sensibilidade",
                                  "subSteps": [
                                    "Crie script completo simulando missão: propagação durante manobra de atitude.",
                                    "Analise sensibilidade: varie bias, ruído, Δt e plote impactos no erro.",
                                    "Integre com filtro simples (ex: complementar) para fusão com magnetômetro.",
                                    "Gere relatório com métricas: RMSE de atitude, tempo de computação.",
                                    "Exporte modelo para uso em simulador de spacecraft (ex: MATLAB Aerospace Toolbox)."
                                  ],
                                  "verification": "Relatório mostra RMSE < 1° em 30s sob condições nominais; código roda em <1s.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Aerospace Blockset ou Python Orekit",
                                    "Templates de simulação GitHub"
                                  ],
                                  "tips": "Automatize testes com Monte Carlo (100 runs) para estatísticas robustas.",
                                  "learningObjective": "Avaliar robustez do modelo em cenários realistas aeroespaciais.",
                                  "commonMistakes": [
                                    "Testar só casos ideais, sem variabilidade real",
                                    "Sobrecarregar simulação com parâmetros irrelevantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um satélite CubeSat, implemente em Python um modelo que propague a atitude a partir de dados de giroscópio durante uma manobra de slew de 90° em yaw (10s), usando RK4 com Δt=0.01s, modelando bias de 0.005°/s e ruído σ=0.01°/s√Hz; compare com quaternion verdade-ground e corrija roll/pitch via acelerômetro detectando direção da gravidade.",
                              "finalVerifications": [
                                "Propagação sem deriva mantém erro <0.5° em 30s.",
                                "Inclusão de bias realista causa deriva linear observável (~1°/min).",
                                "Correção com acelerômetro alinha roll/pitch com gravidade (<2° erro).",
                                "Código executa em tempo real (taxa >100Hz em hardware embarcado).",
                                "Validação contra solução analítica para ω constante converge (erro <1e-6).",
                                "Análise de sensibilidade identifica bias como maior driver de erro.",
                                "Modelo integra seamless com pipeline de controle de atitude."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações: 100% match com referências padrão (ex: Farrell livro).",
                                "Correção numérica: ordem de convergência RK4 confirmada (erro O(Δt^4)).",
                                "Tratamento de erros: deriva e ruído modelados com parâmetros realistas (baseados em datasheets).",
                                "Eficiência: tempo de simulação <1ms por step em Python vetorizado.",
                                "Robustez: funciona com inputs ruidosos reais sem crash ou NaNs.",
                                "Documentação: código comentado, README com uso e limitações.",
                                "Validação: testes unitários passam >95% cobertura."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de quaternions e métodos numéricos de ODE (Runge-Kutta).",
                                "Física: Mecânica rotacional e dinâmica de corpo rígido.",
                                "Programação: Simulações numéricas em Python/SciPy e vetoração para performance.",
                                "Engenharia de Controle: Propagadores em estimadores Kalman para navegação inercial.",
                                "Estatística: Modelagem de ruído Gaussiano e análise de Monte Carlo."
                              ],
                              "realWorldApplication": "Em veículos espaciais como o satélite Starlink ou missões da NASA (ex: James Webb), sensores inerciais propagam atitude entre observações estelares (dead-reckoning de minutos), em drones para estabilização GPS-denied, e em aviões comerciais como backup AHRS quando pitot/IRS falham, garantindo segurança em manobras rápidas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.1.2",
                        "name": "Atuadores para Controle de Atitude",
                        "description": "Estudo dos atuadores que geram torques para controle de atitude, incluindo dinâmica associada e limitações operacionais em ambiente espacial.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.2.1",
                            "name": "Sistemas Propulsivos e Torque de Pressão Solar",
                            "description": "Modelar torques gerados por propulsores e pressão solar, simulando efeitos em veículos espaciais e estratégias de compensação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Torque Propulsivo e Pressão Solar",
                                  "subSteps": [
                                    "Estudar o conceito de torque como produto vetorial de força e braço de alavanca (T = r × F).",
                                    "Analisar sistemas propulsivos: thrusters químicos ou elétricos, identificando vetores de empuxo e momentos.",
                                    "Explorar pressão de radiação solar (SRP): calcular força F = (P * A * (1 + ρ)) / c, onde P é fluxo solar, A área, ρ coeficiente de refletividade, c velocidade da luz.",
                                    "Identificar impactos em veículos espaciais: desestabilização de atitude por torques residuais.",
                                    "Revisar exemplos reais de missões como Hubble ou James Webb Telescope."
                                  ],
                                  "verification": "Resumir em diagrama vetorial os torques de thruster e SRP, confirmando equações corretas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livros/textos de dinâmica orbital (ex: Vallado), calculadora, papel e lápis para diagramas"
                                  ],
                                  "tips": "Use vetores unitários para visualizar direções; foque em LEO onde SRP é significativo.",
                                  "learningObjective": "Dominar conceitos físicos de torques gerados por propulsores e SRP em ambientes espaciais.",
                                  "commonMistakes": [
                                    "Confundir torque com força linear; ignorar dependência angular da SRP."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver Modelos Matemáticos de Torques",
                                  "subSteps": [
                                    "Derivar modelo de torque propulsivo: T_thrust = sum(r_i × F_i) para múltiplos thrusters.",
                                    "Modelar torque de SRP: T_SRP = r × F_SRP, considerando orientação do spacecraft.",
                                    "Incorporar parâmetros: massa, inércia (matriz I), posição solar.",
                                    "Combinar modelos em equação dinâmica: I * ω_dot + ω × (I * ω) = T_thrust + T_SRP + outros.",
                                    "Validar modelo com cenários simples (ex: thruster único desalinhado)."
                                  ],
                                  "verification": "Implementar equações em planilha ou código simples e comparar com valores teóricos conhecidos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software MATLAB/Python/SymPy, documentação NASA SRP models"
                                  ],
                                  "tips": "Linearize modelos para pequenos ângulos; use coordenadas corpo para simplicidade.",
                                  "learningObjective": "Construir equações precisas para torques de propulsores e SRP em simulações de atitude.",
                                  "commonMistakes": [
                                    "Esquecer termos de momento angular; usar unidades inconsistentes (SI vs. astronômicas)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Simulação Numérica",
                                  "subSteps": [
                                    "Configurar simulador em Python (usar scipy.integrate.odeint) ou MATLAB Simulink.",
                                    "Integrar equações de atitude (quaternions ou ângulos de Euler) com torques modelados.",
                                    "Simular cenários: thruster firing + SRP em órbita, plotar evoluções de ângulo/velocidade angular.",
                                    "Adicionar ruído e perturbações realistas (ex: variação solar).",
                                    "Executar múltiplas runs variando parâmetros (ex: órbita, orientação)."
                                  ],
                                  "verification": "Gerar plots de atitude estável vs. instável, confirmando torques causam desvios esperados.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib, ou MATLAB; templates de simulação orbital"
                                  ],
                                  "tips": "Use quaternions para evitar gimbal lock; normalize periodicamente.",
                                  "learningObjective": "Simular dinamicamente efeitos de torques propulsivos e SRP em veículos espaciais.",
                                  "commonMistakes": [
                                    "Passos de integração grandes causando instabilidade; plots não normalizados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver e Testar Estratégias de Compensação",
                                  "subSteps": [
                                    "Projetar compensação feedforward: T_comp = - (T_thrust + T_SRP estimado).",
                                    "Implementar controle closed-loop (ex: PID) para rejeitar torques residuais.",
                                    "Simular com compensação: comparar performance (overshoot, settling time).",
                                    "Otimizar parâmetros via tuning ou LQR.",
                                    "Analisar sensibilidade a erros de modelo (ex: SRP mal estimada)."
                                  ],
                                  "verification": "Demonstrar estabilização em <5° erro em simulações de 1 órbita.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código da simulação anterior, bibliotecas controle (control-python ou MATLAB Control Toolbox)"
                                  ],
                                  "tips": "Comece com feedforward puro; adicione feedback para robustez.",
                                  "learningObjective": "Aplicar técnicas de controle para mitigar torques de propulsores e SRP.",
                                  "commonMistakes": [
                                    "Ganho PID alto causando oscilações; ignorar delays de atuadores."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO (400km) com 4 thrusters de 1mN para correção de atitude. Ative um thruster por 10s, superpondo SRP de painel solar de 0.1m². Implemente compensação para manter quaternion de atitude em [1,0,0,0] (estável).",
                              "finalVerifications": [
                                "Simulação reproduz desvios de atitude devido a T_thrust e T_SRP dentro de 5% de valores analíticos.",
                                "Estratégias de compensação estabilizam spacecraft em <10s após perturbação.",
                                "Plots mostram rejeição efetiva de torques combinados em múltiplas órbitas.",
                                "Modelo SRP varia corretamente com eclipse solar.",
                                "Análise de sensibilidade identifica thresholds de falha."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: equações corretas e implementadas (30%).",
                                "Qualidade da simulação: estabilidade numérica e visualizações claras (25%).",
                                "Eficácia da compensação: métricas de performance (RMS erro <1°) (20%).",
                                "Análise completa: identificação de erros e otimizações (15%).",
                                "Documentação: código comentado e relatório explicativo (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica newtoniana e eletromagnetismo (radiação).",
                                "Matemática: Álgebra linear (matrizes de inércia), integração numérica.",
                                "Programação: Modelagem computacional e visualização de dados.",
                                "Engenharia: Controle de sistemas e design orbital."
                              ],
                              "realWorldApplication": "Em missões como o satélite GOCE da ESA ou Starlink, compensar torques de thrusters e SRP garante precisão de pointing para instrumentos científicos e comunicações, evitando deriva de órbita e falhas operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2.2",
                            "name": "Rodas de Reação e Atuadores de Troca de Momentos",
                            "description": "Simular rodas de reação e rodas com gimbal para controle de momento angular, incluindo saturação e desaturação via propulsores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Princípios Fundamentais de Rodas de Reação e Atuadores de Troca de Momentos",
                                  "subSteps": [
                                    "Estude o conceito de conservação de momento angular e como rodas de reação (RWs) alteram o momento angular do veículo espacial sem expelir massa.",
                                    "Analise rodas com gimbal (CMGs), focando em sua configuração em cluster e torque gerado por precessão.",
                                    "Compare RWs e CMGs em termos de capacidade de torque, eficiência e limitações como singularidades em CMGs.",
                                    "Revise equações básicas: torque τ = I ω_dot para RWs e torque via vetores de momento angular para CMGs.",
                                    "Identifique cenários de uso em estabilização de atitude para satélites e estações espaciais."
                                  ],
                                  "verification": "Resuma em um diagrama os princípios e diferenças entre RWs e CMGs, explicando conservação de momento angular.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livros/textos sobre dinâmica de spacecraft (e.g., Sidi 'Spacecraft Dynamics and Control')",
                                    "Vídeos tutoriais sobre attitude control",
                                    "Ferramentas de desenho como Draw.io"
                                  ],
                                  "tips": "Use analogias terrestres, como patinadores girando braços para ilustrar conservação de momento angular.",
                                  "learningObjective": "Compreender os fundamentos físicos e diferenças operacionais entre RWs e CMGs.",
                                  "commonMistakes": [
                                    "Confundir RWs com propulsores (RWs não ejetam massa)",
                                    "Ignorar limitações de velocidade máxima em RWs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Dinamicamente os Atuadores",
                                  "subSteps": [
                                    "Defina o modelo matemático para RWs: equações de estado com vetor de momento angular h_rw e dinâmica J ω_dot = -ω × (h_sc + h_rw) + τ_ext.",
                                    "Modele CMGs considerando ângulos de gimbal e geometria do cluster (e.g., piramidal).",
                                    "Implemente a lei de controle para velocidades de rotação das RWs ou taxas de gimbal dos CMGs usando controladores PID ou LQR.",
                                    "Inclua efeitos não lineares como atrito viscoso e limite de velocidade/momento máximo.",
                                    "Valide o modelo com simulações simples em 1D para rotação em um eixo."
                                  ],
                                  "verification": "Implemente e plote respostas de um modelo simples em Python/MATLAB, verificando conservação de momento total.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB/Simulink",
                                    "Referências: Wie 'Space Vehicle Dynamics and Control'",
                                    "Templates de código para dinâmica de spacecraft"
                                  ],
                                  "tips": "Comece com modelo 1D antes de 3D para depuração mais fácil.",
                                  "learningObjective": "Desenvolver modelos matemáticos precisos para simulação de RWs e CMGs.",
                                  "commonMistakes": [
                                    "Esquecer cross-products nos termos cinéticos",
                                    "Não normalizar vetores de gimbal em CMGs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Controle de Atitude com os Atuadores",
                                  "subSteps": [
                                    "Configure uma simulação 3D de um satélite rígido com matriz de inércia J e sensores de atitude (e.g., giroscópio, star tracker).",
                                    "Integre o modelo de atuadores em um loop de controle fechado para rastreamento de quaternion de atitude.",
                                    "Simule distúrbios como gradiente gravitacional e pressão de radiação solar.",
                                    "Teste manobras de slew (mudança rápida de atitude) usando apenas RWs ou CMGs.",
                                    "Analise desempenho com métricas como tempo de estabilização e overshoot."
                                  ],
                                  "verification": "Execute simulação e gere gráficos de erro de atitude < 1° em 100s sob distúrbios.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Simulink ou Python com ODE solvers (scipy.integrate)",
                                    "Bibliotecas como Orekit ou poliastro para dinâmica orbital",
                                    "Computador com GPU para simulações rápidas"
                                  ],
                                  "tips": "Use quaternions para evitar gimbal lock em representações de atitude.",
                                  "learningObjective": "Implementar e simular loops de controle completos para estabilização de atitude.",
                                  "commonMistakes": [
                                    "Mal dimensionar matriz de inércia",
                                    "Ignorar alinhamento inicial dos atuadores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Saturação e Desaturação via Propulsores",
                                  "subSteps": [
                                    "Detecte saturação: monitore velocidades das RWs > 90% do limite ou singularidades em CMGs.",
                                    "Modele propulsores (thrusters) com impulsos Δv e torque gerado por configuração off-center.",
                                    "Desenvolva lógica de desaturação: comando thrusters para cancelar momento acumulado nas rodas.",
                                    "Integre modos híbridos: RWs/CMGs para controle fino, thrusters para desaturação.",
                                    "Simule ciclos completos de saturação-desaturação e avalie impacto no consumo de propelente."
                                  ],
                                  "verification": "Simule 10 ciclos de operação; verifique que momento nas rodas retorna a zero sem perda de atitude.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código da simulação anterior",
                                    "Modelos de thrusters de literatura (e.g., NASA reports)",
                                    "Ferramentas de plotagem avançada como Matplotlib"
                                  ],
                                  "tips": "Use deadbands para evitar comandos desnecessários de thrusters.",
                                  "learningObjective": "Gerenciar limitações operacionais através de estratégias híbridas de atuadores.",
                                  "commonMistakes": [
                                    "Sobrestimar capacidade de thrusters levando a Δv excessivo",
                                    "Não sincronizar desaturação com janelas orbitais"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO usando 4 RWs em configuração piramidal para estabilizar atitude após uma manobra de slew de 90°. Inclua saturação após 30 minutos de distúrbios e desaturação com 4 thrusters hidrazina, mantendo erro de apontamento < 0.5°.",
                              "finalVerifications": [
                                "Simulação completa roda sem crashes numéricos ou singularidades.",
                                "Erro de atitude estabiliza abaixo de 1° em menos de 200s.",
                                "Desaturação reduz velocidades de RW para <10% do máximo usando <5% do propelente disponível.",
                                "Conservação de momento angular total verificada em todos os eixos.",
                                "Gráficos mostram transições suaves entre modos de controle.",
                                "Relatório explica trade-offs entre RWs e CMGs no cenário."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo dinâmico (erro <5% em torque previsto vs. simulado).",
                                "Robustez à distúrbios (desempenho consistente em 5 runs aleatórias).",
                                "Eficiência de propelente na desaturação (<10% consumo por ciclo).",
                                "Clareza e completude do código com comentários.",
                                "Análise qualitativa/quantitativa dos resultados.",
                                "Correta detecção e manejo de saturação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rotação, autovalores para modos).",
                                "Física: Dinâmica clássica e mecânica orbital.",
                                "Engenharia de Controle: PID/LQR, observadores de estado.",
                                "Programação: Simulação numérica e visualização de dados.",
                                "Eletrônica: Interfaces com sensores/atuadores reais."
                              ],
                              "realWorldApplication": "Essas simulações são usadas na missão James Webb Space Telescope para controle preciso de atitude com CMGs, e em CubeSats como o NASA's PhoneSat para estabilização usando RWs econômicas, evitando uso excessivo de propelentes limitados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2.3",
                            "name": "Torque Magnético",
                            "description": "Implementar controle via bobinas magnéticas interagindo com o campo magnético terrestre, modelando dependências orbitais e eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos do Torque Magnético",
                                  "subSteps": [
                                    "Estude o princípio físico: torque τ = m × B, onde m é o momento magnético das bobinas e B o campo magnético terrestre.",
                                    "Analise variações do campo B com altitude e inclinação orbital usando modelos como IGRF.",
                                    "Revise componentes de atitude: roll, pitch, yaw e como torque afeta cada eixo.",
                                    "Calcule momento magnético gerado por bobinas: m = N * I * A * n, com N espiras, I corrente, A área, n direção.",
                                    "Discuta limitações: torque pequeno (~10^-6 Nm), dependente de orientação orbital."
                                  ],
                                  "verification": "Resuma em um diagrama vetorial a interação m × B e explique dependências orbitais em um relatório de 1 página.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Spacecraft Attitude Determination and Control' (Sidi), modelo IGRF online, software de desenho vetorial (ex: Draw.io)"
                                  ],
                                  "tips": "Visualize vetores em 3D para melhor compreensão; use simulações interativas como GeoMagia.",
                                  "learningObjective": "Compreender física e dependências orbitais do torque magnético em veículos espaciais.",
                                  "commonMistakes": [
                                    "Ignorar variação de B com órbita",
                                    "Confundir momento magnético com campo magnético",
                                    "Subestimar magnitude pequena do torque"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Sistema Dinâmico",
                                  "subSteps": [
                                    "Defina equações de movimento de atitude: J ω̇ + ω × J ω = τ_m + τ_g + τ_d, focando em τ_m = m × B.",
                                    "Modele B orbital: use coordenadas ECEF para GEO ou LEO, implemente modelo dipolo simples B = (μ / r^3) * (2 cosθ ê_r + sinθ ê_θ).",
                                    "Inclua dependências: posição orbital via TLE, propagação Kepleriana.",
                                    "Defina control law: m_cmd = -K * q * B, onde q é quaternion de atitude, K ganho.",
                                    "Linearize para pequenos ângulos e analise estabilidade via eigenvalues.",
                                    "verification]: "
                                  ],
                                  "verification": [
                                    "Implemente simulação numérica (RK4 ou odeint) para 1 órbita (~90min LEO).",
                                    "Sem controle (m=0): verifique oscilações devido a τ_g + τ_d.",
                                    "Com controle: q → [0,0,0,1], ω → 0 em <10min.",
                                    "Eigenvalues de A na linearização têm Re(λ) < 0.",
                                    "Compare B modelo com dados reais (ex: GOES TLE)."
                                  ],
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python: numpy, scipy.integrate, skyfield (para TLE/orbitas)",
                                    "Ou MATLAB: Aerospace Toolbox",
                                    "Dados TLE de Celestrak (ex: CubeSat LEO/GEO)",
                                    "Notebook Jupyter para prototipagem"
                                  ],
                                  "tips": [
                                    "Normalize quaternions: ||q||=1 após integração.",
                                    "Para LEO, use r≈7000km; GEO r≈42000km.",
                                    "Ganho K inicial: 1e-7 a 1e-5 Nm/T (tune via simulação).",
                                    "Plote 3D: traçatório q no tetraedro unitário.",
                                    "ECEF para B: converta lat/long para θ (dipolo)."
                                  ],
                                  "learningObjective": "Modelar matematicamente e simular numericamente o sistema dinâmico de atitude de um CubeSat com atuadores magnéticos, incluindo propagação orbital, campo magnético dipolo, lei de controle B-dot like, linearização e análise de estabilidade.",
                                  "commonMistakes": [
                                    "Omitir ω × (J ω) (termo gyroscópico dominante em spin).",
                                    "B em Gauss ao invés de Tesla (fator 1e-4).",
                                    "q não normalizado → ||q|| explode.",
                                    "Linearizar em Euler angles (gimbal lock) ao invés de quaternion error.",
                                    "Propagação orbital errada: use ECI para atitude, ECEF para B local."
                                  ]
                                },
                                "verification: "
                              ],
                              "practicalExample": "Implemente uma simulação no MATLAB/Simulink ou Python (usando Orekit ou poliastro) de um CubeSat em órbita LEO com torquers magnéticos, demonstrando detumbling inicial e controle de apontamento nadir ao longo de 3 órbitas, variando corrente nas bobinas conforme lei de controle B-dot ou proporcional.",
                              "finalVerifications": [
                                "Simulação completa validando estabilização de atitude em <5° RMS após 1 órbita.",
                                "Relatório de 3-5 páginas com gráficos de evolução de quaternions, torque e campo B.",
                                "Análise de sensibilidade a erros em TLE e modelo IGRF, com discussão de mitigações."
                              ],
                              "assessmentCriteria": [
                                "Correção das equações dinâmicas e modelo de B (30%)",
                                "Implementação e estabilidade da simulação (30%)",
                                "Análise qualitativa/quantitativa de desempenho (20%)",
                                "Clareza do relatório e visualizações (10%)",
                                "Tratamento de limitações e erros comuns (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física III (Eletromagnetismo): cálculo de momento magnético e interação com B.",
                                "Mecânica Orbital (VO-31): propagação de TLE e modelos de campo geomagnético.",
                                "Teoria de Controle (VC-22): linearização, estabilidade e leis de controle não-lineares.",
                                "Engenharia de Satélites (VA-45): subsistemas ADCS e integração com outros torques."
                              ],
                              "realWorldApplication": "Uso em CubeSats de baixo custo como Tancredo-1 (ITA/CPTEC), missões universitárias brasileiras (UnB, USP) e programas NASA/ESA (Cubesat Launch Initiative), para detumbling pós-lançamento e controle fino sem giroscópios ou rodas de reação caras, reduzindo massa e consumo energético."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.1.3",
                        "name": "Implementação de Algoritmos de Controle para Estabilização",
                        "description": "Desenvolvimento e simulação de algoritmos de controle para estabilizar a atitude do veículo espacial, integrando sensores e atuadores.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.3.1",
                            "name": "Algoritmos de Controle Clássico",
                            "description": "Projetar controladores PID ou LQR para estabilização de atitude, simulando respostas a perturbações e convergência para orientação desejada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão dos Fundamentos de Controladores PID e LQR",
                                  "subSteps": [
                                    "Estude a estrutura matemática do controlador PID: entenda os termos proporcional (Kp), integral (Ki) e derivativo (Kd).",
                                    "Revise o LQR: aprenda sobre a minimização de uma função custo quadrática e a solução da equação de Riccati.",
                                    "Compare PID e LQR em termos de aplicação para sistemas lineares invariantes no tempo (LTI).",
                                    "Identifique quando usar PID (simples, robusto) vs LQR (ótimo para estados completos).",
                                    "Resolva exercícios analíticos simples de tuning PID usando método de Ziegler-Nichols."
                                  ],
                                  "verification": "Responda corretamente a um quiz com 5 perguntas sobre equações PID/LQR e diferenças.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Feedback Control of Dynamic Systems' (capítulos PID/LQR)",
                                    "Notas de aula sobre controle aeroespacial",
                                    "Python/MATLAB com bibliotecas control"
                                  ],
                                  "tips": "Use diagramas de blocos para visualizar o laço de feedback.",
                                  "learningObjective": "Compreender as bases matemáticas e heurísticas de PID e LQR para estabilização.",
                                  "commonMistakes": [
                                    "Confundir ganhos PID (ex: Kd alto causa oscilações)",
                                    "Ignorar saturação de atuadores no LQR"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelagem da Dinâmica de Estabilização de Atitude",
                                  "subSteps": [
                                    "Derive as equações cinemáticas e dinâmicas de rotação para um veículo espacial usando quaternions ou ângulos de Euler.",
                                    "Linearize o modelo não-linear ao redor do ponto de equilíbrio (atitude zero).",
                                    "Obtenha matrizes A, B, C, D do modelo estado-espaço para roll, pitch e yaw.",
                                    "Valide o modelo com propriedades físicas (ex: momentos de inércia realistas).",
                                    "Implemente o modelo em software de simulação."
                                  ],
                                  "verification": "Simule o modelo em malha aberta e confirme instabilidade ou deriva esperada.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Documentação de dinâmica orbital (Vallado)",
                                    "MATLAB/Simulink ou Python (scipy.integrate)",
                                    "Parâmetros de inércia de satélites CubeSat"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades de Euler.",
                                  "learningObjective": "Construir um modelo estado-espaço preciso para atitude de spacecraft.",
                                  "commonMistakes": [
                                    "Linearização incorreta levando a matriz A instável",
                                    "Unidades inconsistentes em momentos de inércia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projeto e Implementação dos Controladores PID e LQR",
                                  "subSteps": [
                                    "Implemente PID para cada eixo (roll/pitch/yaw) com tuning manual ou Ziegler-Nichols.",
                                    "Defina matrizes Q e R para LQR e resolva a equação de Riccati usando lqr() no MATLAB/Python.",
                                    "Inclua observador de estado se necessário para LQR (full-state feedback).",
                                    "Aplique saturação e anti-windup no PID para realismo.",
                                    "Teste em simulação estática (resposta degrau)."
                                  ],
                                  "verification": "Ganhos calculados produzem resposta com overshoot <20% e tempo de estabilização <10s.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox ou Python control library",
                                    "Scripts de exemplo para LQR/PID"
                                  ],
                                  "tips": "Comece com PID para intuição, depois otimize com LQR.",
                                  "learningObjective": "Projetar controladores com ganhos otimizados para estabilização.",
                                  "commonMistakes": [
                                    "Matrizes Q/R mal escaladas causando controle agressivo",
                                    "Esquecer de discretizar para simulações em tempo discreto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simulação de Respostas a Perturbações e Análise de Convergência",
                                  "subSteps": [
                                    "Introduza perturbações realistas (torques gravitacionais, aerodinâmicos, ruído sensorial).",
                                    "Simule cenários: inicial off-nominal, perturbações constantes e impulsivas.",
                                    "Plote respostas: ângulos, velocidades angulares, sinais de controle vs tempo.",
                                    "Calcule métricas: tempo de assentamento, overshoot, erro steady-state.",
                                    "Compare PID vs LQR e ajuste parâmetros para melhor performance."
                                  ],
                                  "verification": "Sistema converge para orientação desejada em <30s sob perturbações, com erro <1 grau.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Simulink para modelagem gráfica",
                                    "Python matplotlib para plots",
                                    "Dados de perturbações de missões reais (ex: ISS)"
                                  ],
                                  "tips": "Use Monte Carlo para robustez a variações de parâmetros.",
                                  "learningObjective": "Avaliar performance do controlador em condições realistas.",
                                  "commonMistakes": [
                                    "Perturbações muito fracas mascarando problemas",
                                    "Ignorar ruído de sensores levando a tuning irreal"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimização e Validação Final",
                                  "subSteps": [
                                    "Otimize ganhos via simulação iterativa ou otimização (ex: fmincon no MATLAB).",
                                    "Teste sensibilidade a variações de massa/inércia.",
                                    "Gere relatório com plots e métricas.",
                                    "Implemente código reutilizável com comentários.",
                                    "Discuta limitações (ex: PID não ótimo para MIMO)."
                                  ],
                                  "verification": "Sistema robusto: performance degradada <20% em cenários variados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de otimização (MATLAB Optimization Toolbox)"
                                  ],
                                  "tips": "Automatize tuning com scripts.",
                                  "learningObjective": "Refinar controlador para aplicação prática.",
                                  "commonMistakes": [
                                    "Overfitting a um cenário específico",
                                    "Relatórios sem métricas quantitativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Projetar um PID para estabilizar o roll de um CubeSat simulando perturbação gravitacional: tune Kp=10, Ki=1, Kd=5; simule convergência de 10° para 0° em 15s com torque máximo 0.1 Nm.",
                              "finalVerifications": [
                                "Simulação converge para erro <0.1° em todos eixos sob perturbações.",
                                "Tempo de assentamento <20s para 90% dos casos.",
                                "Sinais de controle saturam realisticamente sem windup.",
                                "Comparação PID vs LQR mostra trade-offs claros.",
                                "Código executa sem erros e é reproduzível.",
                                "Plots mostram rejeição de perturbações externas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem (matrizes A/B corretas).",
                                "Performance de estabilização (métricas tempo/overshoot).",
                                "Robustez a perturbações variadas.",
                                "Qualidade do tuning (PID/LQR ótimo).",
                                "Clareza de análise e plots.",
                                "Correção matemática e implementação.",
                                "Documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (equações de Riccati), otimização quadrática.",
                                "Física: Dinâmica rotacional, torques gravitacionais/orbitais.",
                                "Computação: Programação numérica, simulação (MATLAB/Python).",
                                "Engenharia de Software: Código modular e versionado.",
                                "Estatística: Análise de Monte Carlo para incertezas."
                              ],
                              "realWorldApplication": "Estabilização de atitude em satélites CubeSat (ex: missões Planet Labs) ou drones espaciais, garantindo apontamento preciso de câmeras/antenas apesar de perturbações como gradiente gravitacional e pressão solar."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3.2",
                            "name": "Simulação de Estabilização de Atitude",
                            "description": "Criar simulações numéricas completas do laço fechado de controle, validando estabilidade com métricas como tempo de assentamento e overshoot.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a Dinâmica de Atitude do Veículo Espacial",
                                  "subSteps": [
                                    "Derivar as equações cinemáticas e dinâmicas de rotação usando quaternions para representar a atitude.",
                                    "Definir os momentos de inércia da matriz de inércia do satélite (ex: diagonal para simetria).",
                                    "Incluir torques perturbadores como gradiente gravitacional e pressão de radiação solar.",
                                    "Linearizar o modelo não-linear ao redor do ponto de equilíbrio para análise de estabilidade.",
                                    "Implementar o modelo em código usando matrizes de rotação e derivadas de quaternion."
                                  ],
                                  "verification": "Verificar se o modelo simula corretamente uma rotação livre sem controle, plotando ângulos de Euler ao longo do tempo.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "MATLAB ou Octave",
                                    "Documentação de dinâmica de atitude (ex: Sidi 'Spacecraft Dynamics and Control')"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades gimbal lock; normalize-os periodicamente.",
                                  "learningObjective": "Compreender e implementar o modelo matemático preciso da dinâmica de atitude de um veículo espacial.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar quaternions levando a deriva numérica",
                                    "Ignorar torques perturbadores resultando em modelo irrealista",
                                    "Confundir cinemática com dinâmica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar o Controlador de Estabilização",
                                  "subSteps": [
                                    "Selecionar e tunar um controlador PID para os eixos de roll, pitch e yaw.",
                                    "Implementar ganhos proporcionais, integrais e derivados com filtros para ruído.",
                                    "Alternativamente, projetar um controlador LQR linearizando o modelo e resolvendo a equação de Riccati.",
                                    "Definir matrizes de peso Q e R para penalizar erros de atitude e esforço de controle.",
                                    "Simular resposta em malha aberta para validar projeto inicial."
                                  ],
                                  "verification": "Plotar respostas unitárias do controlador em malha aberta mostrando estabilidade e desempenho desejado.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": [
                                    "Python com control library ou MATLAB Control System Toolbox",
                                    "Ferramentas de root locus e Bode plot"
                                  ],
                                  "tips": "Comece com tuning Ziegler-Nichols para PID; ajuste manualmente para overshoot < 10%.",
                                  "learningObjective": "Projetar controladores robustos para estabilização de atitude considerando trade-offs de desempenho.",
                                  "commonMistakes": [
                                    "Ganhos altos causando oscilações",
                                    "Falta de filtro derivativo amplificando ruído",
                                    "Matrizes Q/R mal escaladas em LQR"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Simulação Numérica do Laço Fechado",
                                  "subSteps": [
                                    "Integrar o modelo dinâmico com o controlador usando integrador Runge-Kutta de ordem 4 (RK4).",
                                    "Adicionar atuadores (rodas de reação) com saturação e dinâmicas realistas.",
                                    "Incluir sensores (giros e estrelas) com ruído gaussiano e bias.",
                                    "Configurar condições iniciais: erro de atitude de 10 graus e perturbações.",
                                    "Executar simulação por tempo fixo (ex: 1000 segundos) e logar estados."
                                  ],
                                  "verification": "Gerar plots de atitude, velocidades angulares e comandos de controle ao longo do tempo.",
                                  "estimatedTime": "5-6 horas",
                                  "materials": [
                                    "Python: SciPy.integrate.odeint ou solve_ivp",
                                    "Matplotlib para visualização",
                                    "Jupyter Notebook para iterações rápidas"
                                  ],
                                  "tips": "Use dt pequeno (0.01s) para precisão; vetorize computações para velocidade.",
                                  "learningObjective": "Construir uma simulação numérica realista de laço fechado integrando modelo, controlador e atuadores/sensores.",
                                  "commonMistakes": [
                                    "Passo de tempo grande causando instabilidade numérica",
                                    "Esquecer saturação de atuadores",
                                    "Ruído de sensor não modelado adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Estabilidade e Analisar Métricas de Desempenho",
                                  "subSteps": [
                                    "Calcular métricas: tempo de assentamento (ts < 60s), overshoot (<5%), erro estacionário (<0.1°).",
                                    "Analisar estabilidade via autovalores da linearização ou Lyapunov.",
                                    "Testar robustez variando parâmetros (massa, inércia ±20%, ruído).",
                                    "Gerar relatórios com plots e tabelas de métricas.",
                                    "Otimizar tuning se métricas falharem."
                                  ],
                                  "verification": "Relatório confirma todas métricas dentro de specs para cenários nominais e perturbados.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "SciPy para autovalores",
                                    "Pandas para tabelas de métricas",
                                    "LaTeX ou Markdown para relatório"
                                  ],
                                  "tips": "Automatize cálculo de métricas com funções dedicadas; compare com benchmarks analíticos.",
                                  "learningObjective": "Avaliar quantitativamente a estabilidade e desempenho de sistemas de controle espaciais.",
                                  "commonMistakes": [
                                    "Definições erradas de métricas (ex: ts a 2% vs 5%)",
                                    "Análise sem testes de robustez",
                                    "Ignorar transients iniciais"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat em órbita LEO com erro inicial de 15° em roll devido a ejeção. O controlador PID estabiliza em <30s com overshoot <3%, resistindo a torques de arrasto atmosférico.",
                              "finalVerifications": [
                                "Plots mostram convergência suave de atitude e velocidades angulares para zero.",
                                "Métricas calculadas: ts ≤ 60s, overshoot ≤ 5%, erro estacionário ≤ 0.1°.",
                                "Simulação roda sem crashes numéricos por 2000s.",
                                "Testes de sensibilidade confirmam robustez a ±20% variação de inércia.",
                                "Relatório inclui código fonte e dados reproduzíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo dinâmico (comparado a referências padrão).",
                                "Desempenho do controlador (métricas dentro de limites especificados).",
                                "Qualidade da implementação numérica (estabilidade e eficiência).",
                                "Análise completa de estabilidade e robustez.",
                                "Clareza de visualizações e documentação.",
                                "Reprodutibilidade do código e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rotação), EDOs não-lineares.",
                                "Programação: Numérica (integração, otimização), visualização de dados.",
                                "Física: Mecânica orbital, dinâmica rotacional.",
                                "Engenharia de Controle: Teoria clássica/moderna, análise de robustez."
                              ],
                              "realWorldApplication": "Em missões como o satélite Starlink ou ISS, simulações validam controladores de atitude para manter orientação precisa para comunicações, painéis solares e aquisição de imagens, prevenindo falhas custosas em bilhões de dólares."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3.3",
                            "name": "Manobras de Atitude em Simulação",
                            "description": "Estender simulações para incluir manobras de mudança de atitude, otimizando trajetórias com restrições de atuadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Dinâmica de Atitude e Atuadores",
                                  "subSteps": [
                                    "Estude os quaternions e matrizes de rotação para representar atitude.",
                                    "Analise tipos de atuadores: rodas de reação, thrusters e magnetotorquers.",
                                    "Revise equações de Euler para dinâmica rígida de satélites.",
                                    "Identifique restrições típicas: torque máximo, consumo de combustível.",
                                    "Simule um modelo básico de atitude livre sem controle."
                                  ],
                                  "verification": "Resolva um problema simples de propagação de atitude e compare com soluções analíticas.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Documentação de quaternions (NASA tutorials)",
                                    "Python com NumPy e SciPy",
                                    "Livro 'Spacecraft Attitude Determination and Control' (PDF)"
                                  ],
                                  "tips": "Use visualizações 3D para entender rotações intuitivamente.",
                                  "learningObjective": "Compreender representações matemáticas e limitações físicas de manobras de atitude.",
                                  "commonMistakes": "Confundir ângulos de Euler com gimbal lock; ignorar acoplamento entre eixos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Manobras de Atitude com Restrições de Atuadores",
                                  "subSteps": [
                                    "Defina perfil de manobra: ângulo alvo, tempo máximo, aceleração angular.",
                                    "Incorpore modelo dinâmico: J ω_dot + ω × J ω = τ, com τ limitado.",
                                    "Implemente restrições: |τ| ≤ τ_max, integral de consumo ≤ limite.",
                                    "Crie função de custo para otimização: tempo + consumo + overshoot.",
                                    "Teste modelo em simulação aberta sem controle fechado."
                                  ],
                                  "verification": "Gere plots de trajetória angular que respeitem limites de torque.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (control library)",
                                    "Exemplos de código de simulação orbital (Orekit ou poliastro)"
                                  ],
                                  "tips": "Comece com manobras 1D (roll apenas) antes de 3D.",
                                  "learningObjective": "Modelar realisticamente manobras considerando hardware constraints.",
                                  "commonMistakes": "Subestimar inércia não-diagonal; esquecer efeitos de momentum acumulado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Algoritmo de Otimização de Trajetória",
                                  "subSteps": [
                                    "Escolha método: gradient descent, genetic algorithm ou B-splines para parametrização.",
                                    "Defina variáveis de otimização: spline coefficients para τ(t).",
                                    "Inclua controle PD para tracking da trajetória otimizada.",
                                    "Otimize iterativamente: simule, avalie custo, ajuste parâmetros.",
                                    "Valide sensibilidade a perturbações iniciais e ruído."
                                  ],
                                  "verification": "Obtenha trajetória que minimize tempo/consumo em <10% do baseline.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Python SciPy.optimize ou CVXPY",
                                    "Jupyter Notebook para iterações rápidas"
                                  ],
                                  "tips": "Use warm-start com soluções iniciais heurísticas (bang-coast-bang).",
                                  "learningObjective": "Aplicar otimização numérica para trajetórias eficientes.",
                                  "commonMistakes": "Violar restrições por tolerâncias numéricas frouxas; convergência local em mínimos ruins."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Validar na Simulação de Controle de Atitude",
                                  "subSteps": [
                                    "Integre otimizador na loop de simulação de estabilização existente.",
                                    "Adicione realismo: delays, sensor noise, falhas parciais de atuadores.",
                                    "Execute cenários: slew de 180°, pointing para alvo móvel.",
                                    "Compare performance: tempo, precisão final, uso de atuadores.",
                                    "Documente e refine baseado em métricas."
                                  ],
                                  "verification": "Simulação completa converge para alvo com erro <1° em todos os eixos.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Simulador full (Gazebo/Unity com plugins aeroespaciais)",
                                    "Dados reais de missões (ex: ISS maneuvers)"
                                  ],
                                  "tips": "Grave vídeos da simulação 3D para análise visual.",
                                  "learningObjective": "Estender simulações existentes para manobras otimizadas.",
                                  "commonMistakes": "Ignorar acoplamento com órbita; não testar edge cases como saturação."
                                }
                              ],
                              "practicalExample": "Simule um CubeSat executando uma manobra de 90° em yaw para apontar painel solar ao Sol, usando rodas de reação com torque máx 1 mNm, otimizando para tempo mínimo (<60s) sem exceder momentum storage de 10 mNms.",
                              "finalVerifications": [
                                "Trajetória respeita todas restrições de atuadores em simulação.",
                                "Erro final de atitude <0.5° após settling time <10s.",
                                "Custo otimizado 20% melhor que controle heurístico.",
                                "Simulação roda em tempo real sem crashes.",
                                "Plots mostram overshoot <5% e settling sem oscilações.",
                                "Testes com ruído mostram robustez (erro médio <1°)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem dinâmica (match com referências >95%).",
                                "Eficiência da otimização (convergência em <100 iterações).",
                                "Qualidade da simulação integrada (stability em múltiplos runs).",
                                "Documentação clara de código e resultados.",
                                "Análise de trade-offs (tempo vs consumo).",
                                "Capacidade de generalizar para novos perfis de manobra."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e splines.",
                                "Física: Dinâmica de corpos rígidos e conservação de momento angular.",
                                "Programação: NumPy/SciPy para simulação e solvers.",
                                "Engenharia de Controle: Trajectory planning e constrained optimization.",
                                "Ciência de Dados: Análise de sensibilidade e Monte Carlo simulations."
                              ],
                              "realWorldApplication": "Em missões como o satélite Starlink ou James Webb Space Telescope, onde manobras precisas de atitude otimizam comunicação, imaging e gerenciamento de energia sob restrições de propulsores limitados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Simulação de Manobras de Atitude",
                    "description": "Simulação de estratégias de controle para execução de mudanças planejadas de atitude.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Determinação de Atitude a partir de Sensores",
                        "description": "Conceitos fundamentais para estimar a orientação (atitude) de veículos espaciais utilizando diferentes tipos de sensores, incluindo sensores terrestres infravermelho, sensores solares, sensores de estrelas e sensores inerciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Identificar e descrever sensores terrestres infravermelho e solares",
                            "description": "Explicar o funcionamento dos sensores terrestres infravermelho para detecção de horizontes terrestres e sensores solares para rastreamento do Sol, incluindo limitações como obstruções e precisão angular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios básicos dos sensores infravermelhos terrestres",
                                  "subSteps": [
                                    "Estudar a emissão de radiação infravermelha pela superfície terrestre devido à temperatura.",
                                    "Explicar a detecção do horizonte pela transição abrupta de temperatura entre a Terra quente e o espaço frio.",
                                    "Identificar componentes principais: detector de IR (ex: bolômetro ou fotodiodo), lentes ópticas e filtros espectrais.",
                                    "Analisar as bandas infravermelhas típicas usadas (8-12 μm para atmosfera limpa).",
                                    "Revisar diagramas esquemáticos de sensores como o ITHACO ou modernos equivalentes."
                                  ],
                                  "verification": "Desenhar um diagrama simples do sensor e explicar seu princípio em 3-5 frases.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livros de sensores espaciais (ex: 'Spacecraft Attitude Determination'), artigos da NASA sobre Earth Horizon Sensors",
                                    "Vídeos educativos no YouTube sobre detecção de horizonte IR"
                                  ],
                                  "tips": "Visualize a Terra como uma fonte térmica contrastando com o vácuo frio do espaço.",
                                  "learningObjective": "Dominar os fundamentos físicos da detecção de horizontes terrestres via infravermelho.",
                                  "commonMistakes": [
                                    "Confundir radiação IR emitida com refletida (é emitida por temperatura)",
                                    "Ignorar a importância dos filtros para rejeitar nuvens"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o funcionamento dos sensores infravermelhos para detecção de horizontes",
                                  "subSteps": [
                                    "Explicar o escaneamento: sensor gira ou usa espelhos para varrer o horizonte.",
                                    "Detalhar o processamento do sinal: detecção de borda do horizonte pela variação de intensidade IR.",
                                    "Calcular ângulos de atitude (roll e pitch) a partir da posição da borda detectada.",
                                    "Simular em software simples o perfil de sinal IR durante uma varredura.",
                                    "Comparar sensores cone-scan vs. fan-scan."
                                  ],
                                  "verification": "Produzir um gráfico manual ou digital do sinal IR típico de uma varredura de horizonte.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software gratuito como MATLAB/Octave ou Python com Matplotlib",
                                    "Tutoriais sobre processamento de sinal IR espacial"
                                  ],
                                  "tips": "Pense no sinal como uma 'escada' térmica: alta IR na Terra, baixa no espaço.",
                                  "learningObjective": "Explicar o processo completo de aquisição e processamento para determinação de atitude.",
                                  "commonMistakes": [
                                    "Subestimar o impacto da rotação da Terra no sinal",
                                    "Confundir precisão com resolução angular"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender os sensores solares e seu rastreamento do Sol",
                                  "subSteps": [
                                    "Descrever sensores solares como células fotovoltaicas ou fotorresistores em configurações de 2 ou 4 quadrantes.",
                                    "Explicar o rastreamento: diferença de corrente entre quadrantes indica ângulo solar.",
                                    "Detalhar calibração para precisão angular (tipicamente 0.1°).",
                                    "Analisar modos de operação: coarse sun sensor vs. fine sun sensor.",
                                    "Simular o sinal de saída para diferentes ângulos de incidência solar."
                                  ],
                                  "verification": "Calcular manualmente o ângulo solar a partir de um exemplo de desbalanceamento de sinal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagramas de Sun Sensors da Ball Aerospace",
                                    "Simulador online de sensores solares"
                                  ],
                                  "tips": "Lembre-se: sensores solares são baratos e robustos, ideais para aquisição inicial de atitude.",
                                  "learningObjective": "Compreender como sensores solares fornecem referência solar para yaw e aquisição.",
                                  "commonMistakes": [
                                    "Esquecer que funcionam apenas quando o Sol está visível",
                                    "Confundir com star trackers"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar limitações e integrações dos sensores IR e solares",
                                  "subSteps": [
                                    "Listar limitações IR: obstruções por nuvens/albedo, baixa precisão em polos (0.1-0.5°).",
                                    "Listar limitações solares: eclipse solar (até 50% órbita), precisão afeta por sombras.",
                                    "Discutir fusão de dados: Kalman filter combinando IR (roll/pitch) e solar (yaw).",
                                    "Comparar precisão: IR ~0.2°, solar ~0.05-1° dependendo do tipo.",
                                    "Explorar mitigações: redundância e modelagem de erros."
                                  ],
                                  "verification": "Escrever um relatório curto (200 palavras) sobre limitações e soluções.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papers IEEE sobre determinação de atitude",
                                    "Documentação de missões como GOES"
                                  ],
                                  "tips": "Sempre considere o ciclo orbital: solar invisível em eclipse, IR ruim em auroras.",
                                  "learningObjective": "Avaliar trade-offs e aplicações reais dos sensores.",
                                  "commonMistakes": [
                                    "Superestimar precisão sem contexto ambiental",
                                    "Ignorar fusão com outros sensores como giroscópios"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CubeSat em órbita LEO, o sensor IR detecta o horizonte para estabilizar roll/pitch durante o dia, enquanto o sensor solar rastreia o Sol para yaw no período iluminado; durante eclipse, fusão com IMU mantém atitude.",
                              "finalVerifications": [
                                "Explicar corretamente o princípio de detecção térmica do horizonte IR.",
                                "Desenhar e rotular diagrama de sensor solar de quadrantes.",
                                "Listar pelo menos 4 limitações combinadas dos dois sensores.",
                                "Calcular ângulo aproximado de atitude de um sinal simulado.",
                                "Descrever fusão de dados em um cenário orbital real.",
                                "Identificar aplicações em missões espaciais específicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição física dos princípios (80% correto).",
                                "Detalhe e correção nos diagramas e simulações (clareza visual).",
                                "Completude na lista de limitações e mitigações (mínimo 5 itens).",
                                "Capacidade de integrar conceitos em exemplo prático.",
                                "Uso correto de terminologia técnica (ex: cone-scan, angular resolution).",
                                "Profundidade nas verificações e cálculos manuais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Radiação térmica, lei de Planck e óptica infravermelha.",
                                "Matemática: Geometria esférica e filtros de Kalman para fusão.",
                                "Engenharia Eletrônica: Processamento de sinal analógico-digital.",
                                "Informática: Simulações em Python/MATLAB de perfis de sinal.",
                                "Ciência da Terra: Impacto de albedo e nuvens na detecção IR."
                              ],
                              "realWorldApplication": "Esses sensores são essenciais em satélites como o Landsat ou CubeSats educacionais para determinação autônoma de atitude, permitindo imagens estáveis da Terra e comunicações direcionais sem GPS, reduzindo custos em missões de baixo orçamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Aplicar sensores de estrelas e inerciais na determinação de atitude",
                            "description": "Descrever o uso de sensores de estrelas para orientação absoluta de alta precisão e sensores inerciais (giroscópios e acelerômetros) para medições relativas, incluindo fusão de dados via filtros como Kalman.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios dos sensores de estrelas e inerciais",
                                  "subSteps": [
                                    "Estude o funcionamento dos sensores de estrelas: rastreamento de estrelas conhecidas para quaternions de atitude absoluta com precisão de arcosegundos.",
                                    "Analise sensores inerciais: giroscópios medem taxas angulares relativas, acelerômetros medem acelerações lineares para derivação de atitude.",
                                    "Identifique limitações: sensores de estrelas sensíveis a obstruções, inerciais acumulam erros de drift ao longo do tempo.",
                                    "Revise coordenadas celestes e transformações de rotação (matrizes de direção, quaternions).",
                                    "Compare precisão: estrelas para alta precisão absoluta, inerciais para atualizações de alta frequência."
                                  ],
                                  "verification": "Resuma em um diagrama os princípios e limitações de cada sensor, com exemplos numéricos de precisão típica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação de sensores espaciais (ex: NASA Star Tracker Handbook)",
                                    "Vídeos tutoriais sobre quaternions",
                                    "Software de visualização como Stellarium"
                                  ],
                                  "tips": "Use analogias terrestres: estrelas como GPS celeste, giroscópios como bússola que deriva sem correção.",
                                  "learningObjective": "Explicar com precisão o papel complementar de sensores de estrelas e inerciais na determinação de atitude.",
                                  "commonMistakes": [
                                    "Confundir medições absolutas com relativas",
                                    "Ignorar efeitos de ruído e bias nos inerciais",
                                    "Subestimar a necessidade de calibração inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar os sensores em um ambiente de simulação",
                                  "subSteps": [
                                    "Defina modelo matemático para sensores de estrelas: vetor de direção da estrela no corpo vs. inercial, com ruído gaussiano.",
                                    "Modele giroscópios: ω_meas = ω_true + bias + noise, integrando para quaternions com correção de drift.",
                                    "Modele acelerômetros: a_meas = a_true + gravity + noise, projetando em frame inercial para atitude.",
                                    "Implemente simulação em Python/MATLAB: gere trajetórias verdadeiras de atitude e adicione ruídos realistas.",
                                    "Valide modelo: compare saídas simuladas com dados reais de missões (ex: datasets públicos de CubeSats)."
                                  ],
                                  "verification": "Execute simulação simples e plote erros de atitude sem fusão; erro inercial deve crescer linearmente.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Bibliotecas: NumPy, SciPy, PyQuaternion ou MATLAB Aerospace Toolbox",
                                    "Datasets de simulação (ex: Orekit ou GMAT)"
                                  ],
                                  "tips": "Comece com ruído baixo para depuração, aumente gradualmente para realismo.",
                                  "learningObjective": "Criar modelos numéricos realistas de sensores que reproduzam comportamentos observados em voo.",
                                  "commonMistakes": [
                                    "Esquecer normalização de quaternions",
                                    "Não modelar bias estático nos giroscópios",
                                    "Usar ângulos de Euler em vez de quaternions (gimbal lock)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar fusão de dados com filtro de Kalman estendido (EKF)",
                                  "subSteps": [
                                    "Revise EKF para atitude: estado [quaternion, bias giroscópio], observações de estrelas e inerciais.",
                                    "Defina matrizes: F (transição), H (observação estrelas), Q (processo), R (medição).",
                                    "Implemente predição: integre dinâmica inercial, propague covariância.",
                                    "Implemente atualização: corrija com medições de estrelas, compute ganho de Kalman.",
                                    "Teste em loop fechado: simule 1 órbita com obstruções intermitentes de estrelas."
                                  ],
                                  "verification": "O filtro deve reduzir erro RMS de atitude para <0.1° após convergência.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Código base EKF para atitude (ex: GitHub repos como pykalman)",
                                    "Referências: 'Kalman Filtering for Spacecraft Attitude' papers"
                                  ],
                                  "tips": "Linearize Jacobian numericamente se analítico for complexo; monitore covariância para detecção de falhas.",
                                  "learningObjective": "Desenvolver e depurar um EKF funcional para fusão sensor de atitude em tempo real.",
                                  "commonMistakes": [
                                    "Jacobiana errada na linearização",
                                    "Covariâncias mal tunadas (R muito pequeno ignora ruído)",
                                    "Não tratar singularidades em quaternions"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar sensores em simulação de manobra de atitude",
                                  "subSteps": [
                                    "Configure simulação de veículo: dinâmica rígida com torques de atuadores (RWAs).",
                                    "Incorpore determinação de atitude no loop de controle: use EKF para feedback.",
                                    "Simule manobras: slew de 90° apontando para alvo estelar, com perda temporária de estrelas.",
                                    "Adicione realismo: campo de visão limitado do star tracker, vibrações estruturais.",
                                    "Otimize parâmetros: tune Q/R para minimizar lag e overshoot."
                                  ],
                                  "verification": "Manobra completa com erro final <0.5° e tempo de aquisição <10s.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Simuladores: JSBSim, 20-sim ou Python com poliastro para órbitas"
                                  ],
                                  "tips": "Grave todos os sinais (verdadeiro, medido, estimado) para análise pós-simulação.",
                                  "learningObjective": "Integrar estimador de atitude em um sistema de controle fechado para manobras espaciais.",
                                  "commonMistakes": [
                                    "Latência não modelada entre sensores",
                                    "Ignorar alinhamento inicial entre sensores",
                                    "Sobrecarga computacional em EKF"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar desempenho e validar resultados",
                                  "subSteps": [
                                    "Compute métricas: erro RMS, tempo de convergência, robustez a falhas (ex: estrela perdida).",
                                    "Compare com baselines: apenas inercial, apenas estrelas, outros filtros (UKF, PF).",
                                    "Realize estudo de Monte Carlo: 100 runs com ruídos variados.",
                                    "Gere relatórios: plots de 3σ bounds, tabelas de performance.",
                                    "Proponha melhorias: adicionar magnetômetros ou GPS para backup."
                                  ],
                                  "verification": "Relatório com gráficos mostrando superioridade do EKF fused vs. sensores isolados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de plot: Matplotlib, MATLAB plots",
                                    "Templates de análise de ADCS"
                                  ],
                                  "tips": "Use histogramas para validar suposições gaussianas.",
                                  "learningObjective": "Avaliar quantitativamente a eficácia da fusão de sensores em cenários realistas.",
                                  "commonMistakes": [
                                    "Métricas enviesadas por outliers",
                                    "Não testar cenários de falha",
                                    "Confundir ruído com bias"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de CubeSat em órbita LEO, use star tracker para aquisição inicial de atitude (precisão 10 arcsec), giroscópios para rastreamento durante slew de 180° para imaging, e EKF para fundir dados, mantendo erro <1° mesmo com 50% de estrelas obstruídas por painéis solares.",
                              "finalVerifications": [
                                "Erro RMS de atitude <0.1° em simulação estacionária.",
                                "Convergência do EKF em <30s após inicialização.",
                                "Robustez: performance mantida com 30% de dropout em medições de estrelas.",
                                "Plot de covariância mostra redução consistente.",
                                "Manobra simulada completa com overshoot <2°.",
                                "Comparação Monte Carlo: 95% dos runs abaixo de threshold de erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem: match com dados reais >95%.",
                                "Correta implementação EKF: predição/atualização sem divergência.",
                                "Análise quantitativa completa com métricas padrão ADCS.",
                                "Código limpo, comentado e reproduzível.",
                                "Interpretação física dos resultados (ex: por que fusão melhora).",
                                "Tratamento de edge cases (falhas sensor)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (quaternions, Jacobianas), Probabilidade (EKF bayesiano).",
                                "Programação: Algoritmos numéricos em Python/MATLAB, simulação orientada a objetos.",
                                "Física: Dinâmica rotacional, mecânica orbital.",
                                "Engenharia de Controle: Estimadores, loops fechados.",
                                "Estatística: Análise de Monte Carlo, validação de modelos."
                              ],
                              "realWorldApplication": "Missões como Hubble Space Telescope usam star trackers fused com gyros via Kalman para apontamento preciso de 0.01 arcsec; CubeSats como MarCO da NASA empregam isso para comunicação interplanetária estável."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Calcular atitude combinando múltiplos sensores",
                            "description": "Realizar cálculos básicos de quaternions ou matrizes de rotação a partir de medidas de sensores combinados, considerando ruídos e calibração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Sensores e Representação de Atitude",
                                  "subSteps": [
                                    "Estude os princípios de funcionamento de sensores comuns: acelerômetro (mede aceleração específica), giroscópio (mede taxas angulares) e magnetômetro (mede campo magnético).",
                                    "Aprenda representações de atitude: quaternions unitários e matrizes de rotação (DCM - Direction Cosine Matrix).",
                                    "Revise vetores de referência: vetor gravitacional local, campo magnético da Terra e eixos do corpo do veículo.",
                                    "Identifique limitações: ruído gaussiano, bias e misalignment nos sensores.",
                                    "Pratique conversão de ângulos de Euler para quaternions usando fórmulas básicas."
                                  ],
                                  "verification": "Resuma em um diagrama os vetores de medida de cada sensor e escreva a fórmula de um quaternion unitário.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação de sensores (datasheets), Notebook com Python/MATLAB, Tutoriais sobre quaternions (ex: NASA Attitude Determination docs)"
                                  ],
                                  "tips": "Use visualizações 3D para entender rotações; comece com ângulos simples como 90 graus.",
                                  "learningObjective": "Dominar conceitos básicos de sensores e representações de atitude para combinação posterior.",
                                  "commonMistakes": [
                                    "Confundir vetores de corpo com vetores inerciais",
                                    "Ignorar normalização de quaternions",
                                    "Esquecer que magnetômetro requer modelo de campo magnético local"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calibrar Sensores Individuais",
                                  "subSteps": [
                                    "Colete dados estáticos do acelerômetro em posições conhecidas (ex: repouso para medir bias gravitacional).",
                                    "Aplique método de calibração de 6 posições para magnetômetro (elipsoide para esfera).",
                                    "Estime bias e escala do giroscópio integrando taxas angulares em manobras conhecidas.",
                                    "Implemente modelo de ruído: assuma ruído branco gaussiano e compute covariâncias.",
                                    "Valide calibração comparando medidas corrigidas com valores teóricos esperados."
                                  ],
                                  "verification": "Gere gráficos de medidas calibradas vs. não calibradas, mostrando redução de bias e ruído.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Dados simulados ou reais de sensores (ex: dataset Arduino/IMU), Software de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Use mínimos quadrados para ajuste de parâmetros; teste em múltiplas temperaturas se possível.",
                                  "learningObjective": "Calibrar sensores para minimizar erros sistemáticos antes da fusão.",
                                  "commonMistakes": [
                                    "Não considerar cross-coupling entre eixos",
                                    "Usar poucos pontos de calibração",
                                    "Ignorar variações ambientais como temperatura"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Fusão de Dados com Método TRIAD ou Similar",
                                  "subSteps": [
                                    "Escolha método determinístico: TRIAD para combinação de dois vetores (ex: acelerômetro + magnetômetro).",
                                    "Construa matriz de observabilidade com vetores de referência e medidas calibradas.",
                                    "Compute DCM via produto vetorial e cross-product orthogonolização.",
                                    "Estenda para quaternions usando decomposição polar ou Davenport's q-method (QUEST).",
                                    "Incorpore giroscópio para propagação: atualize quaternion via integração diferencial."
                                  ],
                                  "verification": "Implemente código que produza DCM/quaternion a partir de vetores de entrada e verifique ortogonalidade (det(A) ≈ 1).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Código Python/MATLAB para álgebra de quaternions (ex: pyquaternion library), Exemplos de código TRIAD open-source"
                                  ],
                                  "tips": "Sempre normalize quaternions após updates; teste com vetores colineares para edge cases.",
                                  "learningObjective": "Realizar fusão básica de múltiplos sensores para estimar atitude.",
                                  "commonMistakes": [
                                    "Erro na ordem dos vetores de referência vs. corpo",
                                    "Não ortogonalizar corretamente o terceiro vetor",
                                    "Propagação instável sem normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, Testar e Analisar Erros com Ruído",
                                  "subSteps": [
                                    "Gere dados simulados: atitude conhecida + ruído adicionado aos sensores.",
                                    "Execute fusão em loop temporal e compare com verdade terrestre.",
                                    "Compute métricas de erro: ângulo de erro (trace(DCM_err - I)/2), RMS de quaternions.",
                                    "Ajuste pesos de sensores baseado em covariâncias de ruído.",
                                    "Implemente filtro simples (ex: complementar) para suavização temporal."
                                  ],
                                  "verification": "Produza relatório com gráficos de erro vs. tempo, mostrando precisão < 5 graus RMS.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Simulador (ex: MATLAB Simulink ou Python com numpy/scipy), Datasets de teste (ex: Oregon State MEMS)"
                                  ],
                                  "tips": "Use Monte Carlo simulations para estatísticas robustas; compare métodos TRIAD vs. QUEST.",
                                  "learningObjective": "Avaliar e refinar cálculo de atitude considerando ruídos reais.",
                                  "commonMistakes": [
                                    "Não adicionar ruído realista",
                                    "Comparar quaternions sem unwrap (sin^2 erro)",
                                    "Ignorar singularidades em fusão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um satélite CubeSat, combine medidas de acelerômetro (vetor gravidade), magnetômetro (campo Terra) e giroscópio para estimar atitude durante manobra de apontamento solar. Implemente em Python: leia dados IMU simulados, calibre, aplique TRIAD para DCM, converta para quaternion e plote erro vs. verdade (ex: rotação de 30 graus em yaw).",
                              "finalVerifications": [
                                "Quaternion resultante tem norma unitária (|q| = 1 ± 1e-6).",
                                "Matriz de rotação é ortogonal (A * A^T = I).",
                                "Erro de atitude RMS < 3 graus em simulação com ruído típico (0.1 deg/s gyro, 1% mag).",
                                "Calibração reduz bias do acelerômetro para <0.01 g.",
                                "Fusão lida com falha de sensor (ex: ignorar magnetômetro em alta latitude).",
                                "Propagação gyroscópica mantém precisão por 60 segundos sem updates."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro médio < 2 graus em testes variados.",
                                "Robustez: Performance estável com ruído 2x maior que nominal.",
                                "Eficiência: Código executa em <1s para 1000 timesteps.",
                                "Documentação: Código comentado com fórmulas matemáticas.",
                                "Validação: Comparação com método referência (ex: EKF) <5% diferença.",
                                "Generalidade: Funciona para múltiplos conjuntos de sensores."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, autovalores), Estatística (covariâncias, mínimos quadrados).",
                                "Programação: NumPy/SciPy para vetores, visualização com Matplotlib.",
                                "Física: Dinâmica rotacional, Cinemática de corpos rígidos.",
                                "Engenharia de Controle: Filtros de estimação (Kalman intro), Modelagem de sistemas.",
                                "Ciência de Dados: Processamento de sinais ruidosos, Simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em satélites como o CubeSat universitário ou missões NASA (ex: CYGNSS), essa habilidade permite determinação autônoma de atitude para controle preciso de antenas e painéis solares, essencial para comunicações e geração de energia em órbita sem GPS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Dinâmica e Atuadores de Controle de Atitude",
                        "description": "Princípios de dinâmica rotacional de veículos espaciais e os principais atuadores utilizados para gerar torques de controle, como sistemas propulsivos, pressão solar, rodas de reação e torque magnético.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Modelar dinâmica de atitude e torques perturbadores",
                            "description": "Derivar equações de Euler rígido para rotação de corpo rígido no espaço, incluindo torques gravitacionais, de arrasto atmosférico e pressão solar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Dinâmica de Corpo Rígido e Representação de Atitude",
                                  "subSteps": [
                                    "Estudar os princípios básicos de rotação de corpo rígido, incluindo momentos de inércia e tensores de inércia.",
                                    "Aprender representações de atitude: ângulos de Euler, quaternions e matrizes de rotação.",
                                    "Definir frames de referência: corpo rígido (body frame) e inercial (inertial frame).",
                                    "Calcular o tensor de inércia para um corpo rígido genérico ou exemplo como um satélite cúbico.",
                                    "Derivar a relação cinemática entre velocidades angulares e derivadas de quaternions."
                                  ],
                                  "verification": "Resumir em um diagrama os frames de referência e listar as equações cinemáticas derivadas corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Spacecraft Dynamics and Control' de Sidi; software MATLAB ou Python com NumPy/SciPy.",
                                  "tips": "Use quaternions para evitar singularidades nos ângulos de Euler desde o início.",
                                  "learningObjective": "Compreender as bases matemáticas para modelagem de atitude em veículos espaciais.",
                                  "commonMistakes": "Confundir frames de referência body e inertial; ignorar propriedades simétricas do tensor de inércia."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as Equações Dinâmicas de Euler para Rotação Livre",
                                  "subSteps": [
                                    "Partir do princípio de momento angular: dH/dt = torque total no frame inercial.",
                                    "Transformar para frame body: Euler's equation I ω_dot + ω × (I ω) = T.",
                                    "Derivar explicitamente para os três eixos, assumindo tensor de inércia diagonal.",
                                    "Implementar numericamente em código para validar rotação livre (sem torques).",
                                    "Simular um caso simples como 'tennis racket theorem' para corpos assimétricos."
                                  ],
                                  "verification": "Executar simulação numérica e plotar velocidades angulares; deve estabilizar ou flipar conforme esperado.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB/Simulink ou Python (SciPy odeint); exemplos de código de dinâmica orbital.",
                                  "tips": "Diagonalize o tensor de inércia para simplificar cálculos iniciais.",
                                  "learningObjective": "Dominar a derivação e implementação das equações de Euler puras.",
                                  "commonMistakes": "Esquecer o termo de acoplamento ω × (I ω); unidades inconsistentes em simulações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar Torques Perturbadores: Gravitacional, Arrasto Atmosférico e Pressão Solar",
                                  "subSteps": [
                                    "Derivar torque gravitacional: T_g = 3 (μ / r^5) × (r × I r), para órbita circular.",
                                    "Modelar arrasto atmosférico: T_drag = -0.5 ρ C_d A |v| (ω × r_cm), adaptado para atitude.",
                                    "Calcular pressão solar: T_srp = -P_cr A_r (r_hat × n) × r_cm, com coeficiente de reflexão.",
                                    "Expressar todos os torques no frame body usando matrizes de rotação.",
                                    "Analisar dependências: altitude para arrasto, posição orbital para gravitacional e solar."
                                  ],
                                  "verification": "Calcular magnitudes típicas para um satélite LEO e comparar com valores de literatura.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Dados orbitais (NASA Celestia ou Orekit library); planilhas Excel para cálculos analíticos.",
                                  "tips": "Use aproximações lineares para torques pequenos em análises de estabilidade.",
                                  "learningObjective": "Quantificar e formular matematicamente os principais torques perturbadores.",
                                  "commonMistakes": "Negligir direção vetorial dos torques; usar densidade atmosférica errada para LEO."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Modelo Completo e Realizar Simulação Inicial",
                                  "subSteps": [
                                    "Combinar equações: I ω_dot + ω × (I ω) = T_control + T_g + T_drag + T_srp.",
                                    "Implementar integrador numérico (RK4 ou ode45) com estado [quaternion, ω, posição orbital].",
                                    "Simular manobra de atitude em LEO, incluindo propagação orbital simplificada.",
                                    "Analisar impacto dos perturbadores na deriva de atitude ao longo de uma órbita.",
                                    "Otimizar parâmetros para matching com dados reais de satélite."
                                  ],
                                  "verification": "Plotar trajetórias de atitude e ω; verificar se perturbadores causam desvios realistas (~0.1-1 deg/orbit).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com poliastro para órbitas + Matplotlib; ou MATLAB Aerospace Toolbox.",
                                  "tips": "Normalize quaternions a cada passo para estabilidade numérica.",
                                  "learningObjective": "Construir e simular um modelo dinâmico completo de atitude com perturbadores.",
                                  "commonMistakes": "Instabilidades numéricas por passos de tempo grandes; esquecêr propagar cinemática de atitude."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar Sensibilidade do Modelo",
                                  "subSteps": [
                                    "Comparar simulação com soluções analíticas para casos sem perturbadores.",
                                    "Realizar análise de sensibilidade variando I, altitude e área solar.",
                                    "Calcular Jacobiano linearizado para estudo de estabilidade.",
                                    "Documentar equações finais em LaTeX e código comentado.",
                                    "Preparar relatório com plots e conclusões sobre dominância de cada torque."
                                  ],
                                  "verification": "Modelo reproduz desvios conhecidos de CubeSats em LEO; erros <5% em magnitudes de torque.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Jupyter Notebook para documentação; SymPy para derivações simbólicas.",
                                  "tips": "Use Monte Carlo para quantificar incertezas em parâmetros atmosféricos.",
                                  "learningObjective": "Avaliar robustez e precisão do modelo desenvolvido.",
                                  "commonMistakes": "Sobreestimar pressão solar sem coeficiente de reflexão; ignorar variação diurna."
                                }
                              ],
                              "practicalExample": "Modelar a dinâmica de atitude de um CubeSat em órbita baixa da Terra (400 km), simulando uma manobra de apontamento nadir com torques gravitacionais dominantes (~10^-6 Nm), arrasto residual (~10^-7 Nm) e pressão solar (~10^-7 Nm), prevendo deriva de 0.5° por órbita sem controle.",
                              "finalVerifications": [
                                "Equações de Euler derivadas corretamente com termo de acoplamento.",
                                "Torques perturbadores expressos no frame body com vetores posição.",
                                "Simulação numérica converge sem instabilidades para 10 órbitas.",
                                "Magnitudes de torques batem com referências (ex: Wertz 'Space Mission Analysis').",
                                "Plots mostram impacto relativo: gravitacional > solar > arrasto em LEO.",
                                "Código modular e reutilizável para adicionar atuadores."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das derivações (80% pesos nas equações).",
                                "Correção da implementação numérica e estabilidade (plots limpos).",
                                "Realismo dos modelos de torque (valores físicos plausíveis).",
                                "Análise qualitativa/quantitativa dos efeitos perturbadores.",
                                "Clareza da documentação e código comentado.",
                                "Criatividade na análise de sensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rotação), EDOs não-lineares.",
                                "Física: Mecânica clássica, gravitação newtoniana.",
                                "Programação: Integração numérica, visualização científica.",
                                "Engenharia: Design orbital, controle de sistemas.",
                                "Ciência de Dados: Análise de sensibilidade e validação de modelos."
                              ],
                              "realWorldApplication": "Desenvolvimento de sistemas de controle de atitude para satélites CubeSat e missões espaciais como Starlink ou James Webb Space Telescope, onde modelagem precisa de perturbadores é essencial para manter apontamento preciso com rodas de reação e thrusters, minimizando consumo de combustível."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Descrever atuadores: rodas de reação e sistemas propulsivos",
                            "description": "Explicar o princípio de conservação de momento angular em rodas de reação (incluindo rodas com gimbal) e o uso de propulsores para torques finitos em manobras grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio de Conservação de Momento Angular",
                                  "subSteps": [
                                    "Revise a definição de momento angular como L = Iω, onde I é o momento de inércia e ω é a velocidade angular.",
                                    "Estude a lei de conservação: em sistemas isolados, o momento angular total é constante.",
                                    "Analise exemplos terrestres, como patinador girando braços para acelerar.",
                                    "Aplique ao espaço: ausência de torque externo preserva momento angular do satélite + atuadores.",
                                    "Derive equação básica: torque no satélite = -torque na roda."
                                  ],
                                  "verification": "Resuma o princípio em 3 frases e resolva um problema simples de conservação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Vídeos do Khan Academy sobre momento angular",
                                    "Folha de papel e calculadora",
                                    "Livro de física clássica (ex: Halliday Resnick)"
                                  ],
                                  "tips": "Visualize vetores de momento angular para intuitar a conservação.",
                                  "learningObjective": "Explicar matematicamente como a conservação de momento angular permite controle de atitude sem propelentes.",
                                  "commonMistakes": "Confundir momento linear com angular; ignorar que o sistema é satélite + roda."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Rodas de Reação (Reaction Wheels)",
                                  "subSteps": [
                                    "Descreva reação wheels como motores elétricos com rotores de alto momento de inércia em eixos fixos.",
                                    "Explique operação: acelerar roda gera torque oposto no satélite via conservação.",
                                    "Discuta limitações: saturação do momento angular da roda requer desaturação.",
                                    "Simule mudança de atitude: acelere roda para girar satélite, desacelere para parar.",
                                    "Calcule torque: τ = I_roda * α_roda, onde α é aceleração angular."
                                  ],
                                  "verification": "Desenhe diagrama de vetor de momento angular antes/depois da aceleração da roda.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador online de reaction wheels (ex: JSatTrak ou Python com Matplotlib)",
                                    "Notas de aula sobre dinâmica de spacecraft"
                                  ],
                                  "tips": "Use animações 3D para visualizar o giro do satélite e roda.",
                                  "learningObjective": "Modelar o controle de atitude usando reaction wheels e conservação de momento.",
                                  "commonMistakes": "Esquecer que rodas têm eixos fixos, limitando a 3 DOF sem múltiplas rodas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Rodas de Reação com Gimbal (Control Moment Gyros - CMGs)",
                                  "subSteps": [
                                    "Diferencie CMGs: rotores girando rápido com gimbal permitindo orientação do eixo.",
                                    "Explique torque: direção variável pelo gimbal gera torques maiores sem mudar velocidade do rotor.",
                                    "Estude configurações: cluster de CMGs para cobertura esférica de torque.",
                                    "Compare com reaction wheels: CMGs fornecem torque amplificado, mas complexos.",
                                    "Simule manobra: gire gimbal para produzir torque perpendicular ao momento do rotor."
                                  ],
                                  "verification": "Explique em um parágrafo como CMGs superam limitações das reaction wheels.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Vídeo NASA sobre CMGs no ISS",
                                    "Software GMAT ou STK para simulação",
                                    "Diagramas de vetores de torque"
                                  ],
                                  "tips": "Lembre: torque = ω_roda × h_roda, onde h é momento angular do rotor.",
                                  "learningObjective": "Distinguir e calcular torques gerados por CMGs via orientação de gimbal.",
                                  "commonMistakes": "Confundir aceleração da roda com mudança de gimbal; subestimar singularidades em clusters."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender Sistemas Propulsivos para Manobras Grandes",
                                  "subSteps": [
                                    "Descreva propulsores (thrusters): jatos químicos/elétricos gerando força finita.",
                                    "Explique torque: pares de thrusters offset criam momento (τ = F × d).",
                                    "Discuta uso: manobras grandes ou desaturação de rodas, onde torque é ilimitado mas consome propelente.",
                                    "Compare com rodas: propulsores para slew rates altas, rodas para precisão fina.",
                                    "Calcule exemplo: tempo de manobra com aceleração angular α = τ / I_satélite."
                                  ],
                                  "verification": "Resolva problema: calcule torque de dois thrusters 1N a 1m de distância.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilhas Excel para cálculos",
                                    "Documentação de thrusters CubeSat",
                                    "Vídeos de manobras do SpaceX"
                                  ],
                                  "tips": "Priorize thrusters radiais/tangenciais para controle puro de atitude.",
                                  "learningObjective": "Justificar uso de propulsores quando rodas/CMGs saturam em manobras grandes.",
                                  "commonMistakes": "Ignorar perturbações de centro de massa ou consumo de propelente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Atuadores em Estratégias de Controle",
                                  "subSteps": [
                                    "Desenvolva hierarquia: rodas/CMGs para manobras pequenas, thrusters para grandes.",
                                    "Discuta modos híbridos: thrusters desaturam rodas periodicamente.",
                                    "Analise trade-offs: eficiência propelente vs. precisão e vida útil.",
                                    "Simule sequência completa de manobra de atitude.",
                                    "Avalie aplicações reais: ISS usa CMGs + thrusters."
                                  ],
                                  "verification": "Crie fluxograma de seleção de atuadores baseado em tamanho da manobra.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Python script com NumPy para simulação dinâmica",
                                    "Artigos IEEE sobre controle de atitude"
                                  ],
                                  "tips": "Pense em controladores PD para comandar atuadores.",
                                  "learningObjective": "Sintetizar uso combinado de atuadores para controle ótimo de atitude.",
                                  "commonMistakes": "Subestimar efeitos de vibração ou falhas em atuadores."
                                }
                              ],
                              "practicalExample": "Simule o controle de atitude de um CubeSat: use reaction wheels para apontar painel solar (manobra pequena, 5°/s), CMGs para aquisição rápida de estrela (10°/s), e thrusters para correção de 90° após desaturação das rodas. Implemente em Python plotando vetores de momento angular ao longo do tempo.",
                              "finalVerifications": [
                                "Explica corretamente conservação de momento em rodas de reação com diagrama.",
                                "Diferencia reaction wheels de CMGs com equações de torque.",
                                "Calcula torque de thrusters para uma manobra específica.",
                                "Descreve estratégia híbrida para manobra de 180° sem saturação.",
                                "Identifica limitações reais (ex: singularidades em CMGs).",
                                "Simula e verifica mudança de atitude em software."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 30% (conservação e princípios corretos)",
                                "Profundidade técnica: 25% (equações e cálculos precisos)",
                                "Clareza explicativa: 20% (diagramas e fluxogramas claros)",
                                "Aplicação prática: 15% (exemplos e simulações viáveis)",
                                "Completude: 10% (cobre todos atuadores e integrações)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica clássica e conservação de quantidades.",
                                "Matemática: Álgebra vetorial e cinemática rotacional.",
                                "Engenharia de Controle: Sistemas dinâmicos e feedback.",
                                "Computação: Simulações numéricas em Python/MATLAB.",
                                "Química: Propelentes e termodinâmica de jatos."
                              ],
                              "realWorldApplication": "No Telescópio Espacial Hubble, reaction wheels controlam apontamento preciso para observações; CMGs no ISS gerenciam grandes mudanças de atitude; thrusters da Starlink desaturam rodas durante órbitas, otimizando vida útil e eficiência de combustível em constelações de satélites."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Analisar torque de pressão solar e magnético",
                            "description": "Calcular torques devidos à pressão de radiação solar em superfícies assimétricas e interações magnéticas com o campo terrestre usando dipolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos da Pressão de Radiação Solar e Torque Magnético",
                                  "subSteps": [
                                    "Estude a pressão de radiação solar: P = (L / (4πr²c)) onde L é luminosidade solar, r distância, c velocidade da luz.",
                                    "Revise torque como τ = r × F, focando em componentes vetoriais.",
                                    "Aprenda modelo de dipolo magnético para satélites: m × B, onde m é momento magnético, B campo magnético terrestre.",
                                    "Analise assimetrias em superfícies: projeção da área normal ao vetor solar.",
                                    "Explore modelo do campo magnético terrestre (dipolo inclinado)."
                                  ],
                                  "verification": "Resuma em um diagrama os vetores envolvidos em torque solar e magnético, identificando forças e momentos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de dinâmica orbital (ex: Vallado), calculadora científica, software de desenho vetorial (ex: GeoGebra)"
                                  ],
                                  "tips": "Use animações online de pressão solar para visualizar forças em painéis assimétricos.",
                                  "learningObjective": "Compreender os princípios físicos subjacentes aos torques solares e magnéticos em veículos espaciais.",
                                  "commonMistakes": "Confundir pressão de radiação com pressão atmosférica; ignorar direção do vetor normal na superfície."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Torque de Pressão Solar em Superfícies Assimétricas",
                                  "subSteps": [
                                    "Calcule pressão solar constante: Ps = 4.56 μN/m² em 1 UA.",
                                    "Modele superfície assimétrica: divida em painéis com áreas A_i e ângulos θ_i ao vetor solar.",
                                    "Compute força em cada painel: F_i = Ps * A_i * cos(θ_i) * (1 + ρ), ρ coeficiente de reflexão.",
                                    "Determine torque total: τ_solar = Σ (r_i × F_i), usando coordenadas do CM.",
                                    "Implemente em código simples (Python/MATLAB) para variação angular."
                                  ],
                                  "verification": "Calcule τ_solar para um painel de 1m² a 30° de incidência; resultado deve ser ~1.36e-5 Nm.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Planilhas Excel ou Python com NumPy, dados solares da NASA (ex: SOLAR2000)"
                                  ],
                                  "tips": "Sempre normalize vetores de posição e força para evitar erros de magnitude.",
                                  "learningObjective": "Dominar o cálculo vetorial de torque solar considerando geometria assimétrica.",
                                  "commonMistakes": "Esquecer fator de reflexão (ρ~1 para espelhos); usar escalares em vez de vetores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar e Calcular Torque Magnético com Dipolos",
                                  "subSteps": [
                                    "Defina momento de dipolo: m = (V/μ0) * M para material magnetizado.",
                                    "Modele campo terrestre: B(r,λ) = B0 (R_e/r)^3 * f(λ, declinação).",
                                    "Calcule τ_mag = m × B, com componentes em roll/pitch/yaw.",
                                    "Inclua rotação terrestre: atualize B com atitude do satélite.",
                                    "Simule variação orbital usando elementos keplerianos simples."
                                  ],
                                  "verification": "Para m=10 Am² e B=30μT equatorial, τ_mag ~ 3e-4 Nm; valide direção perpendicular.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Modelo IGRF para B terrestre (software ou API), MATLAB/Simulink para simulação"
                                  ],
                                  "tips": "Use matrizes de rotação para alinhar frames do satélite e campo magnético.",
                                  "learningObjective": "Aplicar modelo de dipolo para quantificar torque magnético em órbita.",
                                  "commonMistakes": "Ignorar inclinação do dipolo terrestre (11°); confundir m com B na fórmula cruzada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Analisar Torques Combinados em Simulação",
                                  "subSteps": [
                                    "Some torques: τ_total = τ_solar + τ_mag + outros (ex: gradiente).",
                                    "Simule dinâmica de atitude: dω/dt = I^{-1} (τ_total - ω × Iω).",
                                    "Analise estabilidade: plote τ vs. ângulo de atitude.",
                                    "Otimize geometria: teste reduções de assimetria.",
                                    "Valide com dados reais de satélites (ex: GOES)."
                                  ],
                                  "verification": "Simulação mostra desvio <1°/órbita sem controle; compare com benchmark analítico.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de simulação orbital (ex: GMAT, STK free version), Jupyter Notebook"
                                  ],
                                  "tips": "Linearize equações para análise inicial antes de simulação numérica.",
                                  "learningObjective": "Integrar torques perturbadores em modelo dinâmico completo de atitude.",
                                  "commonMistakes": "Negligir inércia tensorial; não converter unidades consistentemente (Nm vs. μNm)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Otimizar Análise com Cenários Reais",
                                  "subSteps": [
                                    "Carregue modelo de satélite real (ex: CubeSat com painéis solares).",
                                    "Execute Monte Carlo para variações de órbita e B.",
                                    "Compare com telemetria pública (ex: Celestris).",
                                    "Proponha mitigações: bobinas de controle ou balanceamento.",
                                    "Documente relatório com gráficos de torque vs. tempo."
                                  ],
                                  "verification": "Relatório mostra erro <5% vs. dados reais; inclua sensibilidade a parâmetros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados de missão NASA/ESA, Python com Matplotlib/Plotly"
                                  ],
                                  "tips": "Use unidades SI rigorosas e valide com ferramentas open-source como Orekit.",
                                  "learningObjective": "Aplicar análise em contextos reais e propor soluções de engenharia.",
                                  "commonMistakes": "Sobrestimar precisão sem validação experimental; ignorar efeitos não-lineares."
                                }
                              ],
                              "practicalExample": "Para um CubeSat 3U em LEO (400km, 51° inc), com painéis solares assimétricos (A=0.5m², θ=20°), e dipolo m=5Am²: calcule τ_solar ≈ 1.1μNm e τ_mag ≈ 1.5μNm, simulando drift de atitude em 1 órbita.",
                              "finalVerifications": [
                                "Cálculos de τ_solar e τ_mag coincidem com benchmarks em ±2%.",
                                "Simulação mostra evolução de atitude realista sem controle.",
                                "Vetores de torque são perpendiculares às forças corretamente.",
                                "Análise de sensibilidade identifica parâmetros dominantes.",
                                "Relatório inclui gráficos de τ vs. tempo/atitude.",
                                "Mitigações propostas reduzem τ_total em >50%."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: fórmulas e vetores corretos (30%).",
                                "Profundidade da simulação: inclusão de dinâmica completa (25%).",
                                "Validação: comparação com referências reais (20%).",
                                "Clareza da documentação: diagramas e explicações (15%).",
                                "Criatividade em otimizações: soluções práticas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletromagnetismo e mecânica vetorial.",
                                "Matemática: Álgebra linear e cálculo diferencial.",
                                "Engenharia: Controle de sistemas e design orbital.",
                                "Computação: Programação numérica e simulação.",
                                "Ciências da Terra: Modelos geomagnéticos."
                              ],
                              "realWorldApplication": "Em missões como CubeSats (ex: MarCO da NASA), análise de torques solares/magnéticos é essencial para dimensionar atuadores de controle de atitude, evitando perda de apontamento para comunicações ou sensores, economizando combustível e estendendo vida útil da missão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Simulação de Manobras e Estabilização de Atitude",
                        "description": "Estratégias de simulação numérica para controle de atitude, focando em estabilização e execução de manobras planejadas, utilizando leis de controle como PD, LQR ou bang-bang.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Implementar simulação de estabilização de atitude",
                            "description": "Desenvolver modelo dinâmico em software (ex: MATLAB/Simulink) para simular controle PD com rodas de reação, avaliando convergência e overshoot.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar e implementar o modelo dinâmico de atitude do satélite",
                                  "subSteps": [
                                    "Estude as equações cinemáticas e dinâmicas de atitude usando quaternions ou ângulos de Euler.",
                                    "Defina os parâmetros do satélite: momento de inércia (I), condições iniciais de atitude (quaternions iniciais, velocidades angulares).",
                                    "Implemente as equações no MATLAB: d(q)/dt = (1/2) * Omega * q e I * dot(omega) = -omega x (I omega) + tau.",
                                    "Crie um script MATLAB para integrar as equações usando ode45.",
                                    "Valide o modelo sem controle simulando deriva livre."
                                  ],
                                  "verification": "Execute simulação sem torque; verifique se a atitude deriva realisticamente sem divergir.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Documentação de dinâmica de spacecraft (ex: Sidi 'Spacecraft Dynamics and Control')",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use quaternions para evitar singularidades; normalize-os periodicamente.",
                                  "learningObjective": "Compreender e codificar as equações não-lineares de rotação rígida.",
                                  "commonMistakes": [
                                    "Esquecer o skew-symmetric em omega x (I omega)",
                                    "Não normalizar quaternions",
                                    "Usar ângulos de Euler sem gimbal lock handling"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar e implementar o controlador PD",
                                  "subSteps": [
                                    "Defina os ganhos PD: Kp para proporcional (atitude erro), Kd para derivativo (velocidade angular erro).",
                                    "Calcule erro de atitude usando quaternion error: q_err = q_d * conj(q).",
                                    "Implemente tau = -Kp * phi - Kd * omega, onde phi é o vetor de erro de atitude.",
                                    "Inicialize valores iniciais de ganhos (ex: Kp=10, Kd=5) baseados em regras de thumb.",
                                    "Teste em simulação open-loop adicionando o torque ao modelo dinâmico."
                                  ],
                                  "verification": "Simule com PD básico; observe redução inicial no erro de atitude.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "MATLAB",
                                    "Referências de controle PD para attitude (ex: artigos de reaction wheels)"
                                  ],
                                  "tips": "Comece com ganhos baixos para evitar instabilidade; use simulações curtas para tuning rápido.",
                                  "learningObjective": "Implementar feedback PD linearizado para sistemas não-lineares.",
                                  "commonMistakes": [
                                    "Erro de sinal no torque (sinal negativo errado)",
                                    "Não converter quaternion error para vetor de ângulo",
                                    "Ganhos altos causando oscilações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar as rodas de reação como atuadores",
                                  "subSteps": [
                                    "Defina dinâmicas das rodas: Jw * dot(omega_w) = tau_m - omega x Jw omega_w, onde tau_m é torque do motor.",
                                    "Implemente alocação de torque: tau_rw = B * alpha, com B matriz de configuração das rodas.",
                                    "Inclua saturação: limite torque e velocidade das rodas (ex: max 0.01 Nm, 6000 rpm).",
                                    "Integre dinâmicas acopladas: tau_total = tau_rw - omega x h_rw.",
                                    "Atualize o solver ODE para incluir estados das rodas."
                                  ],
                                  "verification": "Simule comando de torque constante; verifique aceleração das rodas e torque entregue sem exceder limites.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "MATLAB",
                                    "Dados típicos de reaction wheels (ex: CubeSat specs)"
                                  ],
                                  "tips": "Use 4 rodas em configuração tetrahedral para redundância; pseudoinverse para alocação.",
                                  "learningObjective": "Modelar atuadores com dinâmicas próprias e saturação realista.",
                                  "commonMistakes": [
                                    "Ignorar cross-coupling omega x h_rw",
                                    "Não saturar velocidades/momentos",
                                    "Matriz B incorreta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar e executar simulação no Simulink",
                                  "subSteps": [
                                    "Crie um modelo Simulink: blocos para dinâmica, PD, rodas, integradores.",
                                    "Configure solver: ode45 variável-step, tolerâncias 1e-6.",
                                    "Defina cenário: perturbação inicial (ex: 10 deg roll, 5 deg/s spin).",
                                    "Adicione scopes para plotar q, omega, h_rw, tau.",
                                    "Execute simulação por 1000s e salve dados."
                                  ],
                                  "verification": "Modelo roda sem erros; plots mostram estados evoluindo.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Simulink toolbox",
                                    "Modelos prévios em MATLAB como base"
                                  ],
                                  "tips": "Use MATLAB Function blocks para equações custom; debug com simulações curtas.",
                                  "learningObjective": "Migrar script MATLAB para ambiente gráfico Simulink para análise.",
                                  "commonMistakes": [
                                    "Solver inadequado causando numérica instabilidade",
                                    "Estados iniciais errados",
                                    "Scopes não configurados"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar convergência, overshoot e otimizar",
                                  "subSteps": [
                                    "Plote respostas: tempo para convergência (<1 deg erro), overshoot percentual.",
                                    "Calcule métricas: settling time, peak overshoot usando stepinfo-like.",
                                    "Tune ganhos PD iterativamente para minimizar ITAE ou overshoot <10%.",
                                    "Teste robustez: adicione ruído sensorial e distúrbios gravitacionais.",
                                    "Documente resultados em relatório com plots."
                                  ],
                                  "verification": "Erro de atitude <0.1 deg após 200s, overshoot <15%, sem saturação excessiva.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Simulink plots",
                                    "Ferramentas de análise (ex: Control System Toolbox)"
                                  ],
                                  "tips": "Use sisotool para tuning aproximado; compare com benchmarks literários.",
                                  "learningObjective": "Avaliar performance de controle e otimizar via simulação.",
                                  "commonMistakes": [
                                    "Métricas erradas (ex: medir em quaternion norm em vez de ângulo)",
                                    "Não testar com ruído",
                                    "Overfitting a um cenário"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CubeSat 3U logo após deployment da ISS, com perturbação inicial de 20° em pitch e 10°/s spin rate. Implemente PD com 4 rodas RW-0.01, tune para settling em 300s com overshoot <10%, visualizando estabilização para nadir-pointing.",
                              "finalVerifications": [
                                "Simulação converge para erro de atitude <0.5° em menos de 500s.",
                                "Overshoot máximo <15% em todos eixos.",
                                "Velocidades das rodas saturam corretamente sem exceder 5000 rpm.",
                                "Sem instabilidade numérica (normas de estados limitadas).",
                                "Resposta robusta a ruído gaussiano de 0.01°/s em giros.",
                                "Torque total respeita limites de potência do satélite."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo dinâmico (erro <1% vs. referências analíticas).",
                                "Correta implementação de PD e alocação de rodas (sem erros de sinal).",
                                "Análise quantitativa completa (métricas de performance reportadas).",
                                "Tuning eficaz (settling time otimizado, overshoot controlado).",
                                "Código modular e comentado, reproduzível.",
                                "Inclusão de realismo (saturação, ruído, distúrbios)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (quaternions, skew matrices), EDOs não-lineares.",
                                "Física: Dinâmica de corpo rígido, conservação de momento angular.",
                                "Programação: Integração numérica (ode solvers), modelagem em Simulink.",
                                "Engenharia de Controle: Teoria PD, análise de estabilidade.",
                                "Eletrônica: Modelagem de motores DC em rodas de reação."
                              ],
                              "realWorldApplication": "Em missões como CubeSats (ex: MarCO da NASA), simulações de estabilização de atitude garantem pointing preciso para comunicação e sensores, prevendo performance antes do lançamento e otimizando consumo de energia das rodas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Simular manobras de atitude planejadas",
                            "description": "Planejar e simular rotação Slewing de 90 graus usando perfil trapezoidal ou polinomial, integrando sensores e atuadores para manobras precisas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelagem do Veículo Espacial e Cinemática de Atitude",
                                  "subSteps": [
                                    "Defina os parâmetros inerciais do veículo espacial (momentos de inércia).",
                                    "Implemente a cinemática de atitude usando quaternions ou ângulos de Euler.",
                                    "Estabeleça as condições iniciais de atitude (zero graus em todos os eixos).",
                                    "Crie o modelo matemático da rotação desejada de 90 graus.",
                                    "Valide a representação matemática com testes unitários simples."
                                  ],
                                  "verification": "Verifique se o modelo cinemático reproduz corretamente rotações básicas sem erros numéricos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de simulação (MATLAB/Simulink ou Python com NumPy/SciPy), documentação de cinemática de atitude.",
                                  "tips": "Use quaternions para evitar singularidades em rotações grandes.",
                                  "learningObjective": "Compreender e implementar a representação matemática da atitude de um veículo espacial.",
                                  "commonMistakes": "Confundir ângulos de Euler com quaternions, levando a gimbal lock."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejamento do Perfil de Rotação (Trapezoidal ou Polinomial)",
                                  "subSteps": [
                                    "Escolha o perfil: trapezoidal para aceleração constante ou polinomial para suavidade.",
                                    "Calcule parâmetros: aceleração máxima, velocidade máxima e tempo total para 90 graus.",
                                    "Gere a trajetória angular (posição, velocidade e aceleração vs. tempo).",
                                    "Ajuste parâmetros para minimizar overshoot e tempo de estabilização.",
                                    "Plote as curvas para visual inspeção."
                                  ],
                                  "verification": "Confirme que a integral da aceleração resulta em exatamente 90 graus de rotação.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ferramentas de plotagem (Matplotlib ou MATLAB plots), calculadora simbólica (SymPy).",
                                  "tips": "Para perfil polinomial, use 5º grau para continuidade em aceleração.",
                                  "learningObjective": "Planejar trajetórias de rotação suaves e otimizadas para manobras de atitude.",
                                  "commonMistakes": "Escolher acelerações muito altas, causando vibrações simuladas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integração de Sensores e Atuadores no Modelo",
                                  "subSteps": [
                                    "Modele atuadores (momentum wheels ou thrusters) com torque de controle baseado no perfil.",
                                    "Inclua sensores (giros ou star trackers) com ruído gaussiano realista.",
                                    "Implemente um loop de controle simples (PD ou LQR) para seguir o perfil.",
                                    "Adicione dinâmica rígida: equações de Euler para rotação.",
                                    "Simule o sistema fechado em tempo discreto."
                                  ],
                                  "verification": "Teste se o torque gerado pelos atuadores corresponde ao perfil planejado.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Bibliotecas de controle (Control Toolbox no MATLAB ou python-control), simulador numérico.",
                                  "tips": "Comece com ganho baixo no controlador para evitar instabilidade.",
                                  "learningObjective": "Integrar hardware simulado (sensores/atuadores) em um loop de controle fechado.",
                                  "commonMistakes": "Ignorar delays nos sensores, levando a oscilações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementação e Execução da Simulação",
                                  "subSteps": [
                                    "Codifique o simulador completo em script ou modelo Simulink.",
                                    "Execute simulações para ambos perfis (trapezoidal e polinomial).",
                                    "Registre saídas: atitude, erro de rastreamento, consumo de torque.",
                                    "Compare desempenho: tempo de manobra, overshoot, precisão final.",
                                    "Otimize parâmetros iterativamente."
                                  ],
                                  "verification": "A simulação converge para 90 graus com erro < 0.1 grau após estabilização.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ambiente de programação (Python/Jupyter ou MATLAB), hardware para execução (PC padrão).",
                                  "tips": "Use step size pequeno (dt=0.01s) para precisão numérica.",
                                  "learningObjective": "Executar simulações numéricas realistas de manobras de atitude.",
                                  "commonMistakes": "Passo de tempo grande causando instabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Análise e Verificação dos Resultados",
                                  "subSteps": [
                                    "Analise métricas: tempo de settling, RMSE do erro de atitude.",
                                    "Gere gráficos de comparação entre perfis.",
                                    "Avalie impacto de ruído e perturbações externas.",
                                    "Documente conclusões sobre qual perfil é superior.",
                                    "Prepare relatório com visualizações."
                                  ],
                                  "verification": "Relatório confirma precisão e suavidade da manobra simulada.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de análise (Pandas/Matplotlib), template de relatório.",
                                  "tips": "Foque em métricas quantitativas para objetividade.",
                                  "learningObjective": "Analisar criticamente resultados de simulações espaciais.",
                                  "commonMistakes": "Interpretar erroneamente overshoot como falha."
                                }
                              ],
                              "practicalExample": "Simule uma manobra de slewing de 90 graus em um CubeSat para realinhar painéis solares com o Sol, usando perfil trapezoidal: acelere por 10s, cruzeiro por 20s, desacelere por 10s, integrando giros com ruído e momentum wheels.",
                              "finalVerifications": [
                                "Rotação final exata de 90 graus com erro < 0.05 graus.",
                                "Tempo de settling < 5 segundos após fim da manobra.",
                                "Ausência de overshoot > 2 graus.",
                                "Trajetória segue fielmente o perfil planejado (RMSE < 1 grau).",
                                "Torque dos atuadores dentro de limites realistas (ex: < 0.1 Nm).",
                                "Simulação estável com ruído de sensores incluído."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação do perfil de rotação (trapezoidal/polinomial).",
                                "Correta integração de dinâmica, sensores e atuadores.",
                                "Análise quantitativa completa com métricas e gráficos.",
                                "Escolha justificada do perfil e parâmetros otimizados.",
                                "Relatório claro documentando processo e resultados.",
                                "Capacidade de depurar erros comuns em simulações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios, integrais e métodos numéricos de integração.",
                                "Física: Dinâmica rotacional e leis de Newton-Euler.",
                                "Programação: Simulação numérica e controle de sistemas.",
                                "Engenharia de Controle: Loops PD/LQR e estabilidade.",
                                "Análise de Dados: Métricas RMSE e visualização."
                              ],
                              "realWorldApplication": "Em missões de satélites como CubeSats ou estações espaciais (ex: ISS), manobras de slewing são usadas para apontar antenas, câmeras ou painéis solares com precisão, minimizando consumo de combustível e vibrações que afetam instrumentos científicos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Avaliar desempenho de simulações com perturbações",
                            "description": "Incluir ruídos de sensores, torques perturbadores e saturação de atuadores em simulações, analisando métricas como tempo de assentamento e erro quiescente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo base de simulação de manobra de atitude",
                                  "subSteps": [
                                    "Definir os parâmetros do veículo espacial (momento de inércia, condições iniciais de atitude).",
                                    "Implementar o modelo dinâmico sem perturbações usando equações de Euler ou quaternions.",
                                    "Configurar o controlador de atitude (ex: PD ou LQR).",
                                    "Testar simulação nominal para validar o setup base.",
                                    "Documentar parâmetros iniciais e resultados nominais."
                                  ],
                                  "verification": "Simulação roda sem erros e atinge atitude desejada em tempo finito; plotar gráficos de ângulos vs tempo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de simulação (MATLAB/Simulink, Python com SciPy/Control library); documentação de modelo de veículo.",
                                  "tips": "Use quaternions para evitar singularidades em rotações.",
                                  "learningObjective": "Entender e configurar um modelo dinâmico básico de atitude para veículos espaciais.",
                                  "commonMistakes": "Ignorar normalização de quaternions; unidades inconsistentes (graus vs radianos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Incorporar ruídos de sensores nas medições",
                                  "subSteps": [
                                    "Modelar ruído gaussiano branco para giroscópios e acelerômetros (definir variância baseada em specs reais).",
                                    "Adicionar ruído aos sinais de entrada do controlador (ex: taxas angulares medidas).",
                                    "Implementar filtro simples (média móvel) ou Kalman básico para demonstração.",
                                    "Executar simulações com diferentes níveis de ruído e registrar impactos.",
                                    "Plotar distribuições de ruído e sinais ruidosos vs limpos."
                                  ],
                                  "verification": "Sinais de sensor mostram variância esperada; histograma do ruído é gaussiano.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Funções randn() em MATLAB/Python; especificações de sensores espaciais (ex: de CubeSats).",
                                  "tips": "Use sementes fixas para reprodutibilidade em testes iniciais.",
                                  "learningObjective": "Modelar e integrar ruídos realistas de sensores em loops de controle.",
                                  "commonMistakes": "Ruído excessivamente alto que destrói estabilidade; não escalar variância corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar torques perturbadores externos",
                                  "subSteps": [
                                    "Definir fontes de perturbação: gradiente gravitacional, pressão de radiação solar, arrasto atmosférico (para LEO).",
                                    "Implementar torques como funções do tempo e atitude (ex: torque gravitacional = 3ω²u × I u).",
                                    "Incluir torques aleatórios ou periódicos (ex: vento solar modelado como passo).",
                                    "Simular múltiplos cenários e comparar com nominal.",
                                    "Analisar envelopes de perturbação em gráficos."
                                  ],
                                  "verification": "Torques perturbadores aparecem nos gráficos de torque total; atitude desvia sem controle.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Modelos analíticos de perturbações espaciais; bibliotecas como Orekit ou poliastro.",
                                  "tips": "Comece com perturbações pequenas para validar linearidade.",
                                  "learningObjective": "Simular distúrbios ambientais realistas em dinâmica orbital.",
                                  "commonMistakes": "Confundir coordenadas corpo vs inercial; escalas erradas de torque."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Modelar saturação de atuadores",
                                  "subSteps": [
                                    "Definir limites de torque para rodas de reação ou thrusters (ex: ±0.1 Nm).",
                                    "Implementar função de saturação (min(max(u, -u_max), u_max)) no sinal de controle.",
                                    "Adicionar dinâmica de slew rate se aplicável.",
                                    "Executar simulações saturadas e observar windup ou perda de performance.",
                                    "Comparar respostas saturada vs não-saturada."
                                  ],
                                  "verification": "Comandos de controle clipam nos limites; torque aplicado respeita saturação.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Especificações de atuadores espaciais (ex: RWAs de satélites); funções clip em software.",
                                  "tips": "Implemente anti-windup básico no integrador para melhorar.",
                                  "learningObjective": "Incorporar não-linearidades de atuadores em simulações de controle.",
                                  "commonMistakes": "Esquecer saturação em ambos os sentidos (±); não testar limites extremos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar métricas de desempenho com perturbações",
                                  "subSteps": [
                                    "Calcular tempo de assentamento (tempo para |erro| < 5% do pico).",
                                    "Computar erro quiescente (média de erro nos últimos 10% da simulação).",
                                    "Gerar métricas adicionais: overshoot, RMSE, consumo de combustível.",
                                    "Executar Monte Carlo (50 runs) para estatísticas (média, desvio padrão).",
                                    "Plotar boxplots e comparar cenários (nominal vs perturbado)."
                                  ],
                                  "verification": "Relatório com tabela de métricas; gráficos mostram degradação esperada.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Scripts para automação (loops Monte Carlo); ferramentas de plot (Matplotlib).",
                                  "tips": "Defina thresholds claros para métricas automáticas.",
                                  "learningObjective": "Quantificar robustez de controladores via métricas padrão.",
                                  "commonMistakes": "Medir erro quiescente durante transientes; amostras insuficientes em Monte Carlo."
                                }
                              ],
                              "practicalExample": "Simule uma manobra de apontamento de 90° para um CubeSat em órbita LEO, adicionando ruído de giroscópio (σ=0.01°/s), torque de gradiente gravitacional (0.001 Nm) e saturação de RWA (±0.05 Nm). Analise se o tempo de assentamento excede 300s e erro quiescente fica abaixo 0.5°.",
                              "finalVerifications": [
                                "Todas perturbações implementadas corretamente sem erros numéricos.",
                                "Métricas calculadas para pelo menos 3 cenários (nominal, sensor+torque, full).",
                                "Monte Carlo mostra variância estatisticamente significativa.",
                                "Gráficos de atitude, controle e perturbações são claros e rotulados.",
                                "Relatório resume impactos quantitativamente (ex: +20% em tempo de assentamento).",
                                "Simulação roda em <5min por run."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de perturbações (validação contra referências).",
                                "Correta computação de métricas (tempo de assentamento < erro <5%).",
                                "Análise estatística robusta (Monte Carlo com >30 runs).",
                                "Interpretação qualitativa e quantitativa dos resultados.",
                                "Código limpo, comentado e reproduzível.",
                                "Identificação de trade-offs (ex: ganho vs robustez)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística (distribuições gaussianas, Monte Carlo).",
                                "Física: Dinâmica orbital e não-linearidades.",
                                "Programação: Simulação numérica e automação.",
                                "Engenharia de Controle: Robustez e não-linearidades.",
                                "Probabilidade: Modelagem de incertezas."
                              ],
                              "realWorldApplication": "Em missões como o James Webb Space Telescope ou CubeSats, avaliar simulações com perturbações garante que controladores de atitude mantenham precisão de apontamento sob ruídos reais, evitando falhas em aquisição de dados científicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.4",
                            "name": "Referenciar bibliografia para validação",
                            "description": "Consultar e aplicar conceitos de Sidi, Wiesel e Wertz para validar simulações de controle de atitude em cenários reais de veículos espaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Coletar Referências Bibliográficas Relevantes",
                                  "subSteps": [
                                    "Pesquise os livros principais: 'Spacecraft Dynamics and Control' de Michael Sidi, 'Spaceflight Dynamics' de William Wiesel, e 'Space Mission Analysis and Design' de James Wertz.",
                                    "Identifique capítulos sobre controle de atitude, dinâmica rotacional e validação de modelos (ex: Capítulos 6-8 em Sidi).",
                                    "Baixe ou acesse PDFs digitais/e-books via bibliotecas acadêmicas ou IEEE Xplore.",
                                    "Compile uma lista anotada com citações APA/ IEEE para cada referência chave.",
                                    "Crie um índice de conceitos relevantes como quaternions, matrizes de rotação e controladores PD."
                                  ],
                                  "verification": "Lista de 5-10 referências com resumos de 1 parágrafo cada, armazenada em documento compartilhável.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Acesso a biblioteca digital (Google Scholar, ResearchGate)",
                                    "Livros: Sidi (1997), Wiesel (1997), Wertz (1999)",
                                    "Ferramenta de notas: Notion ou Evernote"
                                  ],
                                  "tips": "Priorize edições recentes e busque erratas para precisão; use DOI para citações permanentes.",
                                  "learningObjective": "Dominar localização e catalogação de fontes primárias em dinâmica espacial.",
                                  "commonMistakes": [
                                    "Ignorar edições atualizadas",
                                    "Não anotar páginas específicas",
                                    "Confundir autores similares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair Conceitos Teóricos de Controle de Atitude",
                                  "subSteps": [
                                    "Leia seções sobre equações de Euler e cinemática de atitude (Sidi Ch. 4, Wiesel Ch. 5).",
                                    "Extraia fórmulas chave: propagação de quaternions, torque de controle e estabilidade.",
                                    "Compare abordagens: controladores lineares em Wertz vs. não-lineares em Sidi.",
                                    "Crie tabelas comparativas de parâmetros nominais (ex: momento de inércia para satélites LEO).",
                                    "Anote cenários reais citados, como estabilização do Hubble (Wertz)."
                                  ],
                                  "verification": "Tabela de 10+ conceitos com fórmulas, citações e diagramas extraídos.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Livros citados",
                                    "Software de edição: LaTeX ou MATLAB para equações",
                                    "Calculadora simbólica: SymPy"
                                  ],
                                  "tips": "Use marcadores de cores para diferenciar teoria vs. exemplos reais; foque em validação numérica.",
                                  "learningObjective": "Compreender fundamentos teóricos para benchmarking de simulações.",
                                  "commonMistakes": [
                                    "Copiar fórmulas sem entender derivação",
                                    "Ignorar unidades (rad/s vs. deg/s)",
                                    "Não contextualizar com missões reais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Conceitos Bibliográficos à Simulação",
                                  "subSteps": [
                                    "Implemente modelo de simulação em MATLAB/Simulink com parâmetros de Sidi (ex: I = diag([100,100,200] kg m²)).",
                                    "Defina cenários reais: manobra de 90° em LEO (Wiesel ex. 7.3).",
                                    "Alinhe variáveis: ângulo de atitude, taxa angular com equações de referência.",
                                    "Configure métricas de erro: RMSE para atitude vs. valores teóricos.",
                                    "Teste sensibilidade a perturbações citadas em Wertz."
                                  ],
                                  "verification": "Script de simulação com comentários ligando linhas a citações bibliográficas.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (SciPy)",
                                    "Livros para parâmetros",
                                    "Dados orbitais: NORAD TLE"
                                  ],
                                  "tips": "Use blocos modulares no Simulink para fácil comparação; versione com Git.",
                                  "learningObjective": "Integrar teoria bibliográfica em modelos computacionais acionáveis.",
                                  "commonMistakes": [
                                    "Escala errada de parâmetros",
                                    "Não linearizar corretamente",
                                    "Ignorar efeitos gravitacionais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Validação Comparativa",
                                  "subSteps": [
                                    "Rode simulações para 3 cenários: estabilização, slew e pointing (Sidi/Wiesel).",
                                    "Compare saídas: plote atitude simulada vs. analítica (equações fechadas).",
                                    "Calcule métricas: erro <5% em taxa angular, tempo de convergência.",
                                    "Documente discrepâncias e ajuste modelo (ex: adicionar ruído per Wertz).",
                                    "Gere relatório com gráficos sobrepostos e tabelas numéricas."
                                  ],
                                  "verification": "Relatório PDF com 10+ gráficos e tabela de validação (erro médio <2%).",
                                  "estimatedTime": "7 horas",
                                  "materials": [
                                    "MATLAB com Aerospace Toolbox",
                                    "Livros para baselines",
                                    "Ferramenta de plot: Matplotlib"
                                  ],
                                  "tips": "Automatize plots com loops; valide unidades consistentemente (SI).",
                                  "learningObjective": "Avaliar fidelidade de simulações contra padrões acadêmicos.",
                                  "commonMistakes": [
                                    "Amostragem insuficiente",
                                    "Não reportar intervalos de confiança",
                                    "Bias em cenários cherry-picked"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Sintetizar Validação",
                                  "subSteps": [
                                    "Escreva seção de validação citando fontes (IEEE format).",
                                    "Resuma achados: 'Simulação valida com erro 1.2% per Sidi Eq. 6.45'.",
                                    "Inclua limitações e sugestões futuras (ex: controle adaptativo de Wertz).",
                                    "Compartilhe repositório GitHub com código e relatório.",
                                    "Autoavalie contra critérios de validação V&V em aeroespacial."
                                  ],
                                  "verification": "Repositório público com relatório final aprovado por peer review simulada.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "GitHub",
                                    "LaTeX/Overleaf para relatório",
                                    "Referências bibliográficas"
                                  ],
                                  "tips": "Use templates AIAA para relatórios; inclua DOI para reprodutibilidade.",
                                  "learningObjective": "Comunicar validações de forma profissional e reprodutível.",
                                  "commonMistakes": [
                                    "Citações vagas",
                                    "Não incluir código fonte",
                                    "Exagerar precisão sem bounds"
                                  ]
                                }
                              ],
                              "practicalExample": "Valide uma simulação MATLAB de manobra de slew de 180° em um CubeSat em órbita LEO (400km), usando Eq. 7.12 de Sidi para torque de controle, comparando tempo de estabilização (<10s) com exemplo 5.4 de Wiesel, alcançando RMSE de 0.8° em atitude.",
                              "finalVerifications": [
                                "Referências citadas corretamente em todas as comparações (DOI/páginas).",
                                "Erros de simulação <5% vs. baselines teóricos.",
                                "Gráficos mostram convergência qualitativa e quantitativa.",
                                "Relatório inclui análise de sensibilidade a perturbações.",
                                "Código é executável e reprodutível em máquina padrão.",
                                "Limitações discutidas com referências adicionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das comparações (peso 30%).",
                                "Profundidade de extração conceitual da bibliografia (25%).",
                                "Qualidade da implementação simulacional (20%).",
                                "Clareza e reprodutibilidade da documentação (15%).",
                                "Análise de discrepâncias e robustez (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (quaternions, matrizes DCM).",
                                "Física: Mecânica clássica e dinâmica rotacional.",
                                "Engenharia de Software: Modelagem em MATLAB/Simulink.",
                                "Gestão de Projetos: V&V em ciclos de desenvolvimento ágil."
                              ],
                              "realWorldApplication": "Em missões como o satélite James Webb, validações bibliográficas garantem que software de controle de atitude passe testes de qualificação, evitando falhas como o giroscópio do Hubble, economizando milhões em retrabalho."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 176
          }
        ],
        "totalSkills": 176,
        "percentage": 0
      }
    ]
  }
}